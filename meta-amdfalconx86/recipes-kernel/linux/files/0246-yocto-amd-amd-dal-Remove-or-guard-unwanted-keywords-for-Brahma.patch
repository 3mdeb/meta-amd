From d557ec22ac6f873917f98d0a417a31d04b8a091a Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Tue, 14 Jul 2015 10:17:36 -0400
Subject: [PATCH 363/401] amd/dal: Remove or guard unwanted keywords for Brahma

Clean up comments or references to:
- registry, reg
- windows, win
- amdsoc

We don't want to make it obvious to the Linux kernel world that this is
an OS-independent driver and don't want to unnecessarily advertise internal
code names to the world.

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Mykola Lysenko <mykola.lysenko@amd.com>
Reviewed-by: Jordan Lazare <jordan.lazare@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/dal/Makefile                   |  2 +-
 drivers/gpu/drm/amd/dal/adapter/adapter_service.c  | 26 ++++++++++---------
 drivers/gpu/drm/amd/dal/adapter/adapter_service.h  |  2 +-
 .../drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c |  2 +-
 drivers/gpu/drm/amd/dal/basics/logger.c            |  2 +-
 .../amd/dal/controller/dce110/csc_grph_dce110.c    | 12 +++++----
 .../amd/dal/controller/dce110/scaler_v_dce110.c    |  2 +-
 drivers/gpu/drm/amd/dal/dal_services.h             |  7 +++--
 drivers/gpu/drm/amd/dal/dal_services_types.h       |  2 --
 drivers/gpu/drm/amd/dal/dcs/dcs.c                  | 19 +++++++-------
 drivers/gpu/drm/amd/dal/dcs/ddc_service.c          |  4 +--
 drivers/gpu/drm/amd/dal/dcs/default_modes_dco.c    |  2 +-
 .../gpu/drm/amd/dal/display_path/display_path.c    |  2 +-
 .../drm/amd/dal/display_service/display_service.c  | 30 ++--------------------
 .../drm/amd/dal/display_service/ds_calculation.c   |  2 +-
 .../dal/display_service/ds_dispatch_mode_setting.c |  4 +--
 drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c    |  4 +--
 drivers/gpu/drm/amd/dal/hw_sequencer/Makefile      |  2 --
 .../gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c    |  4 +--
 .../amd/dal/include/adapter_service_interface.h    |  2 +-
 .../drm/amd/dal/include/adapter_service_types.h    |  7 ++---
 drivers/gpu/drm/amd/dal/include/adjustment_types.h | 11 ++++----
 drivers/gpu/drm/amd/dal/include/dal_types.h        |  4 +--
 drivers/gpu/drm/amd/dal/include/logger_interface.h |  5 +---
 drivers/gpu/drm/amd/dal/include/logger_types.h     |  7 +++--
 drivers/gpu/drm/amd/dal/include/scaler_types.h     |  3 ---
 drivers/gpu/drm/amd/dal/interface/dal.c            |  3 +--
 .../drm/amd/dal/link_service/dpsst_link_service.c  |  4 +--
 .../gpu/drm/amd/dal/mode_manager/mode_manager.c    |  6 +++--
 .../gpu/drm/amd/dal/topology/tm_detection_mgr.c    | 12 ++++-----
 drivers/gpu/drm/amd/dal/topology/topology.c        | 17 +++++-------
 31 files changed, 90 insertions(+), 121 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/Makefile b/drivers/gpu/drm/amd/dal/Makefile
index 05dacde..49f1651 100644
--- a/drivers/gpu/drm/amd/dal/Makefile
+++ b/drivers/gpu/drm/amd/dal/Makefile
@@ -1,6 +1,6 @@
 #
 # Makefile for the DAL (Display Abstract Layer), which is a  sub-component
-# of AMDSOC/AMDGPU drm driver.
+# of the AMDGPU drm driver.
 # It provides the HW control for display related functionalities.
 
 AMDDALPATH = $(RELATIVE_AMD_DAL_PATH)
diff --git a/drivers/gpu/drm/amd/dal/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
index 6686450..f1ac686 100644
--- a/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
@@ -412,7 +412,7 @@ case FEATURE_ ## feature: \
 /*
  * override_default_parameters
  *
- * Override features (from registry or cmdline)
+ * Override features (from runtime parameter)
  * corresponding to Adapter Service Feature ID
  */
 static bool override_default_parameters(
@@ -628,7 +628,7 @@ static bool generate_feature_set(
 		set_idx = (uint32_t)((entry->feature_id - 1) / 32);
 		internal_idx = (uint32_t)((entry->feature_id - 1) % 32);
 
-		/* TODO: wireless->registry->vbios->asiccap*/
+		/* TODO: wireless, runtime parameter, vbios */
 		if (!override_default_parameters(as, param, i, &value)) {
 			if (!get_feature_value_from_data_sources(
 					as, i, &value)) {
@@ -1442,7 +1442,7 @@ bool dal_adapter_service_get_bandwidth_tuning_params(
 	union bandwidth_tuning_params *params)
 {
 	/* TODO: add implementation */
-	/* note: data comes from Registry */
+	/* note: data comes from runtime parameters */
 	return false;
 }
 
@@ -1500,7 +1500,7 @@ struct gpio *dal_adapter_service_obtain_gpio(
 struct gpio *dal_adapter_service_obtain_stereo_gpio(
 	struct adapter_service *as)
 {
-	const bool have_registry_stereo_gpio = false;
+	const bool have_param_stereo_gpio = false;
 
 	struct asic_feature_flags result;
 
@@ -1512,12 +1512,12 @@ struct gpio *dal_adapter_service_obtain_stereo_gpio(
 		return dal_gpio_service_create_gpio_ex(
 			as->gpio_service, GPIO_ID_GENERIC, GPIO_GENERIC_A,
 			GPIO_PIN_OUTPUT_STATE_ACTIVE_LOW);
-	/* Case 2 : registry override for sideband stereo */
-	else if (have_registry_stereo_gpio) {
-		/* TODO implement */
-		return NULL;
-	/* Case 3 : VBIOS gives us GPIO for sideband stereo */
-	} else {
+       /* Case 2 : runtime parameter override for sideband stereo */
+       else if (have_param_stereo_gpio) {
+               /* TODO implement */
+               return NULL;
+       /* Case 3 : VBIOS gives us GPIO for sideband stereo */
+       } else {
 		const struct graphics_object_id id =
 			dal_graphics_object_id_init(
 				GENERIC_ID_STEREO,
@@ -1978,11 +1978,13 @@ uint32_t dal_adapter_service_get_view_port_pixel_granularity(
 }
 
 /**
- * Get number of paths per DP 1.2 connector from the registry if exists
+ * Get number of paths per DP 1.2 connector from the runtime parameter if it
+ * exists.
  * A check to see if MST is supported for the generation of ASIC is done
  *
  * \return
- *    Number of paths per DP 1.2 connector is exists in registry or ASIC cap
+ *    Number of paths per DP 1.2 connector is exists in runtime parameters
+ *    or ASIC cap
  */
 uint32_t dal_adapter_service_get_num_of_path_per_dp_mst_connector(
 		struct adapter_service *as)
diff --git a/drivers/gpu/drm/amd/dal/adapter/adapter_service.h b/drivers/gpu/drm/amd/dal/adapter/adapter_service.h
index f40cdcd..df5d997 100644
--- a/drivers/gpu/drm/amd/dal/adapter/adapter_service.h
+++ b/drivers/gpu/drm/amd/dal/adapter/adapter_service.h
@@ -54,7 +54,7 @@ struct adapter_service {
 	uint32_t backlight_8bit_lut[SIZEOF_BACKLIGHT_LUT];
 };
 
-/* Type of feature with its registry and default value */
+/* Type of feature with its runtime parameter and default value */
 struct feature_source_entry {
 	enum adapter_feature_id feature_id;
 	uint32_t default_value;
diff --git a/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c b/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c
index dbda470b..80a35112 100644
--- a/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c
@@ -1640,10 +1640,10 @@ static void hw_initialize(
 	if (stream_id != FIRST_AUDIO_STREAM_ID)
 		return;
 
+
 	/* Suport R5 - 32khz
 	 * Suport R6 - 44.1khz
 	 * Suport R7 - 48khz
-	 * 44.1khz needs to be supported for Windows7
 	 */
 	addr = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES;
 	{
diff --git a/drivers/gpu/drm/amd/dal/basics/logger.c b/drivers/gpu/drm/amd/dal/basics/logger.c
index 7e6b9c3..09cd935 100644
--- a/drivers/gpu/drm/amd/dal/basics/logger.c
+++ b/drivers/gpu/drm/amd/dal/basics/logger.c
@@ -28,7 +28,7 @@
 #include "include/logger_interface.h"
 #include "logger.h"
 
-/* TODO: for now - empty, use DRM defines from amdsoc_dal_services.h
+/* TODO: for now - empty, use DRM defines from dal services.
 		Need to define appropriate levels of prints, and implement
 		this component
 void dal_log(const char *format, ...)
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/csc_grph_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/csc_grph_dce110.c
index 794788a..802fa85 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/csc_grph_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/csc_grph_dce110.c
@@ -96,7 +96,7 @@ static const uint32_t csc_grph_regs[][CG_REGS_IDX_SIZE] = {
 	regs_for_csc_grph(5)
 };
 
-static const struct dcp_color_matrix global_color_matrix_reg[] = {
+static const struct dcp_color_matrix global_color_matrix[] = {
 { COLOR_SPACE_SRGB_FULL_RANGE,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
 { COLOR_SPACE_SRGB_LIMITED_RANGE,
@@ -259,14 +259,16 @@ static void set_grph_csc_default(
 		enum grph_color_adjust_option option =
 			GRPH_COLOR_MATRIX_HW_DEFAULT;
 		uint32_t i;
-		/* HW default false we program locally defined matrix
+		/*
+		 * HW default false we program locally defined matrix
 		 * HW default true  we use predefined hw matrix and we
 		 * do not need to program matrix
-		 * OEM wants the HW default via registry key. */
+		 * OEM wants the HW default via runtime parameter.
+		 */
 		option = GRPH_COLOR_MATRIX_SW;
 
-		for (i = 0; i < ARRAY_SIZE(global_color_matrix_reg); ++i) {
-			elm = &global_color_matrix_reg[i];
+		for (i = 0; i < ARRAY_SIZE(global_color_matrix); ++i) {
+			elm = &global_color_matrix[i];
 			if (elm->color_space != default_adjust->color_space)
 				continue;
 			/* program the matrix with default values from this
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c
index 8dff6b6..2dbe6cc 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c
@@ -314,7 +314,7 @@ static bool setup_scaling_configuration(
 
 	{
 		/* we can ignore this register because we are ok with hw
-		 * default 0 -- change to 1 according to window code*/
+		 * default 0 -- change to 1 according to dal2 code*/
 		value = dal_read_reg(dal_ctx,
 				scl->regs[IDX_SCL_CONTROL]);
 		 /* 0 - Replaced out of bound pixels with black pixel
diff --git a/drivers/gpu/drm/amd/dal/dal_services.h b/drivers/gpu/drm/amd/dal/dal_services.h
index 37729c5..982e544 100644
--- a/drivers/gpu/drm/amd/dal/dal_services.h
+++ b/drivers/gpu/drm/amd/dal/dal_services.h
@@ -219,8 +219,11 @@ static inline uint32_t dal_bios_cmd_table_para_revision(
 	uint8_t frev;
 	uint8_t crev;
 
-	if (cgs_atom_get_cmd_table_revs(ctx->cgs_device,
-			index, &frev, &crev) != 0)
+	if (cgs_atom_get_cmd_table_revs(
+			ctx->cgs_device,
+			index,
+			&frev,
+			&crev) != 0)
 		return 0;
 
 	return crev;
diff --git a/drivers/gpu/drm/amd/dal/dal_services_types.h b/drivers/gpu/drm/amd/dal/dal_services_types.h
index 7bad47c..532dee2 100644
--- a/drivers/gpu/drm/amd/dal/dal_services_types.h
+++ b/drivers/gpu/drm/amd/dal/dal_services_types.h
@@ -36,8 +36,6 @@
 
 #include "cgs_linux.h"
 
-/* The same symbols are defined in amdsoc.h, redefined here just in
- * case DAL need to work with other drivers besides amdsoc. */
 #if defined(__BIG_ENDIAN) && !defined(BIGENDIAN_CPU)
 #define BIGENDIAN_CPU
 #elif defined(__LITTLE_ENDIAN) && !defined(LITTLEENDIAN_CPU)
diff --git a/drivers/gpu/drm/amd/dal/dcs/dcs.c b/drivers/gpu/drm/amd/dal/dcs/dcs.c
index 5c003f9..7ca70c7 100644
--- a/drivers/gpu/drm/amd/dal/dcs/dcs.c
+++ b/drivers/gpu/drm/amd/dal/dcs/dcs.c
@@ -722,18 +722,18 @@ static void build_drr_settings(struct dcs *dcs)
 	}
 
 	/* PART B - DRR Feature */
-	/* VBIOS override and registry key override is only for embedded */
+	/* VBIOS override and runtime parameter override is only for embedded */
 	if ((INTERFACE_TYPE_LVDS == dcs->display_type) ||
 			(INTERFACE_TYPE_EDP == dcs->display_type)) {
-		/* First try to find DRR capability from Registry Key.
-		 * DRR registry key may disable feature. */
+		/* First try to find DRR capability from runtime parameter.
+		 * DRR runtime parameter may disable feature. */
 		if (!dal_adapter_service_get_feature_value(
 			FEATURE_DRR_SUPPORT,
 			&feature_value,
 			sizeof(feature_value)))
 			return;
 
-		/* DRR is not supported if disabled by registry key. */
+		/* DRR is not supported if disabled by runtime parameter. */
 		if (feature_value == AS_DRR_SUPPORT_DISABLED)
 			return;
 		else if (feature_value >= AS_DRR_SUPPORT_MIN_FORCED_FPS) {
@@ -745,7 +745,7 @@ static void build_drr_settings(struct dcs *dcs)
 		}
 
 
-		/* Check VBIOS if not forced by registry */
+		/* Check VBIOS if not forced by runtime parameter */
 		if (0 == dcs->drr_config.min_fps_in_microhz &&
 				NULL != dcs->vbios_dco) {
 			dcs->drr_config.min_fps_in_microhz =
@@ -759,17 +759,18 @@ static void build_drr_settings(struct dcs *dcs)
 
 	} else {
 		/* For non-embedded displays, check if DRR support is disabled
-		 * by registry key */
+		 * by runtime parameter */
 		if (dal_adapter_service_is_feature_supported(
 				FEATURE_SUPPORT_EXTERNAL_PANEL_DRR)) {
 			/* DRR is not supported on external panels if disabled
-			 * by registry key. */
+			 * by runtime parameter. */
 			return;
 		}
 	}
 
-	/* Finally check EDID if not found in VBIOS or Registry. EDID method of
-	 * supporting DRR is possible on both external and internal panels. */
+	/* Finally check EDID if not found in VBIOS or runtime parameters.
+	 * EDID method of supporting DRR is possible on both external and
+	 * internal panels. */
 	if (0 == dcs->drr_config.min_fps_in_microhz && NULL != edid_base) {
 		dcs->drr_config.min_fps_in_microhz =
 			dal_edid_get_min_drr_fps(edid_base);
diff --git a/drivers/gpu/drm/amd/dal/dcs/ddc_service.c b/drivers/gpu/drm/amd/dal/dcs/ddc_service.c
index 9639c58..49cf989 100644
--- a/drivers/gpu/drm/amd/dal/dcs/ddc_service.c
+++ b/drivers/gpu/drm/amd/dal/dcs/ddc_service.c
@@ -587,7 +587,7 @@ static uint8_t i2c_read_edid_block(
 /*
  * Some I2C engines don't handle stop/start between write-offset and read-data
  * commands properly. For those displays, we have to force the newer E-DDC
- * behavior of repeated-start which can be enabled by registry key. */
+ * behavior of repeated-start which can be enabled by runtime parameter. */
 /* Originally implemented for OnLive using NXP receiver chip */
 
 	if (index == 0 && !ddc->flags.FORCE_READ_REPEATED_START) {
@@ -612,7 +612,7 @@ static uint8_t i2c_read_edid_block(
 	} else {
 		/*
 		 * extension block use E-DDC, submit as 1 command
-		 * or if repeated-start is forced by registry key
+		 * or if repeated-start is forced by runtime parameter
 		 */
 		if (segment != 0) {
 			/* include segment offset in command*/
diff --git a/drivers/gpu/drm/amd/dal/dcs/default_modes_dco.c b/drivers/gpu/drm/amd/dal/dcs/default_modes_dco.c
index fff502c..08040e7 100644
--- a/drivers/gpu/drm/amd/dal/dcs/default_modes_dco.c
+++ b/drivers/gpu/drm/amd/dal/dcs/default_modes_dco.c
@@ -141,7 +141,7 @@ bool dal_default_modes_dco_multi_sync_dco_add_mode_timing(
 
 		/* set default timing standard as GTF.*/
 		/* default modes getting from "DALNonStandardModesBCD"
-		registry should use GTF for Non-EDID monitor.*/
+		runtime parameters should use GTF for Non-EDID monitor.*/
 		if (mode_timing.mode_info.timing_standard ==
 			TIMING_STANDARD_UNDEFINED)
 			mode_timing.mode_info.timing_standard =
diff --git a/drivers/gpu/drm/amd/dal/display_path/display_path.c b/drivers/gpu/drm/amd/dal/display_path/display_path.c
index f4cb67a..caf14e3 100644
--- a/drivers/gpu/drm/amd/dal/display_path/display_path.c
+++ b/drivers/gpu/drm/amd/dal/display_path/display_path.c
@@ -795,7 +795,7 @@ bool dal_display_path_is_drr_supported(const struct display_path *path)
 
 	/* The check for DRR supported returns true means it satisfied:
 	 * 1. EDID reported DRR capability and Stream supports DRR or
-	 * 2. Forced capability through registry key or
+	 * 2. Forced capability through runtime parameter or
 	 * 3. Forced capability through VBIOS */
 	if (((drr_config.support_method.SUPPORTED_BY_EDID == 1) &&
 		dal_ls_is_stream_drr_supported(ls)) ||
diff --git a/drivers/gpu/drm/amd/dal/display_service/display_service.c b/drivers/gpu/drm/amd/dal/display_service/display_service.c
index d5ba922..ada8753 100644
--- a/drivers/gpu/drm/amd/dal/display_service/display_service.c
+++ b/drivers/gpu/drm/amd/dal/display_service/display_service.c
@@ -269,35 +269,9 @@ enum ds_return dal_display_service_target_power_control(
 			path_data->display_state.OUTPUT_ENABLED = 1;
 			path_data->display_state.OUTPUT_BLANKED = 0;
 
-			/* Re-enable PSR if display is not in blanked state
-			 * This is added particularly for a specific Win7
-			 * case, but looks like a logical generic change.
-			 * In Win8+,
-			 * Lid close/open action is accompanied by
-			 * Blank/Unblank calls. In this function,
-			 * DisplaySetPowerState is called while
-			 * display is blanked. We do not want
-			 * to enable PSR while display is blanked!
-			 * We will correctly disable/enable PSR
-			 * because unblank will re-enable PSR when
-			 * lid is opened.
-			 * In Win7,
-			 * Lid close/open do NOT call
-			 * blank/unblank/setmode.
-			 * Only DisplaySetPowerState
-			 * is called if the LCD is the
-			 * last display connected. When we
-			 * close lid, we power down the
-			 * display stream, therefore we
-			 * should disable PSR. However,
-			 * when lid is opened PSR is
-			 * not properly re-enabled
-			 * because there is no
-			 * unblank/setmode call.
-			 * So, this should be done here.
-			 *
+			/*
+			 * Re-enable PSR if display is not in blanked state
 			 */
-
 			if (dal_display_path_is_source_blanked(display_path) &&
 				dal_display_path_is_psr_supported(display_path))
 				dal_hw_sequencer_psr_enable(
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c b/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c
index 22510f4..a1357dc 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c
@@ -198,7 +198,7 @@ void dal_ds_calculation_setup_ranged_timing(
 	} else if (dal_display_path_is_drr_supported(display_path)) {
 		/* The check for DRR supported returns true means it satisfied:
 		 * 1. EDID reported DRR capability and Stream supports DRR or
-		 * 2. Forced capability through registry key or
+		 * 2. Forced capability through runtime parameter or
 		 * 3. Forced capability through VBIOS */
 		drr_supported = true;
 	}
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
index c991b39..384ebba 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
@@ -437,10 +437,10 @@ static void cal_scaling_overscan_params(
 	/* Here we build a bounding rectangle for the destination rectangles
 	 * provided by OS. As the name implies all of the destination
 	 * rectangles are bound inside this rectangle. It is necessary as
-	 * windows destination rectangles do not necessarily coincide with
+	 * destination rectangles do not necessarily coincide with the
 	 * display timing. The bounding rectangle is used to calculate a common
 	 * scaling ratio (CSR) for all surfaces which when multiplied by scaling
-	 * ration to get windows source rect scaled onto the dest rect will give
+	 * ration to get source rect scaled onto the dest rect will give
 	 * us the true scaling ratio. This is done in a single step so no actual
 	 * CSR is calculated.
 	 */
diff --git a/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c b/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c
index 35e84a8..97f8705 100644
--- a/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c
+++ b/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c
@@ -79,7 +79,7 @@ bool dal_bandwidth_manager_construct_base(
 	base->fix_latency_multiplier = 100;
 	base->use_urgency_watermark_offset = 0;
 
-	/* obtain Bandwidth tuning parameters from registry*/
+	/* obtain Bandwidth tuning parameters from runtime parameters*/
 	if (dal_adapter_service_get_bandwidth_tuning_params(as, &info)) {
 		base->read_dly_stutter_off =
 			info.tuning_info.read_delay_stutter_off_usec;
@@ -91,7 +91,7 @@ bool dal_bandwidth_manager_construct_base(
 			base->no_extra_recording_latency = false;
 
 		/*MCLatency is obtained from ASIC cap as in the above,
-		 * extraMCLatency which is obtained from registry */
+		 * extraMCLatency which is obtained from runtime parameters*/
 		if (info.tuning_info.extra_mc_latency_usec != 0)
 			base->mc_latency +=
 				info.tuning_info.extra_mc_latency_usec;
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/Makefile b/drivers/gpu/drm/amd/dal/hw_sequencer/Makefile
index d7bb167..d367c7f 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/Makefile
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/Makefile
@@ -2,8 +2,6 @@
 # Makefile for the 'hw_sequencer' sub-component of DAL.
 # It provides hw programming sequences implementation.
 
-ccflags-y += -Iinclude/drm -Idrivers/staging/android -Idrivers/gpu/drm/amdsoc/
-
 HWS = hw_sequencer.o hw_path_mode_set.o hw_sequencer_helpers.o \
 	hw_sync_control.o hw_sequencer_adjustments.o hw_sequencer_parameters.o
 
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
index c34bc4f..f495f65 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
@@ -3192,8 +3192,8 @@ static void program_alpha_mode(
 	if (blend_flags->bits.PER_PIXEL_ALPHA_BLEND == 1) {
 		blending_config.flags.bits.MODE_IS_SET = 1;
 		blending_config.mode = ALPHA_MODE_PIXEL;
-		/* TODO we need to understand why Windows programs
-		 * MODE_MULTIPLIED bits. These seem to be the root of
+		/* TODO we need to understand why MODE_MULTIPLIED bits
+		 * are set. These seem to be the root of
 		 * color corruption on HDMI.
 		 * We'll only set these for RGB for now to avoid color
 		 * corruption with YCbCr outputs.
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
index 3ca32b4..b60e4c9 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
@@ -299,7 +299,7 @@ enum adapter_feature_id {
 	FEATURE_SET_27_START = FEATURE_SMOOTH_BRTN_ADJ_TIME_IN_MS,
 	FEATURE_SET_27_END = FEATURE_SET_27_START + 31,
 
-	/* Set 28: UInt set, 1 entry: Allow registry key  to force specific
+	/* Set 28: UInt set, 1 entry: Allow runtime parameter to force specific
 	 * Static Screen Event triggers for test purposes. */
 	FEATURE_FORCE_STATIC_SCREEN_EVENT_TRIGGERS = FEATURE_SET_27_END + 1,
 	FEATURE_SET_28_START = FEATURE_FORCE_STATIC_SCREEN_EVENT_TRIGGERS,
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_types.h b/drivers/gpu/drm/amd/dal/include/adapter_service_types.h
index 224ef82..ffa195b 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_types.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_types.h
@@ -36,9 +36,10 @@ enum as_signal_type {
 	AS_SIGNAL_TYPE_UNKNOWN
 };
 
-/*Struct used for algorithm of Bandwidth tuning parameters
- *the sequence of the fields is binded with
- *registry reading and static tables aRegBandwidthTuningParameter.*/
+/*
+ * Struct used for algorithm of Bandwidth tuning parameters
+ * the sequence of the fields is binded with runtime parameter.
+ */
 union bandwidth_tuning_params {
 	struct bandwidth_tuning_params_struct {
 		uint32_t read_delay_stutter_off_usec;
diff --git a/drivers/gpu/drm/amd/dal/include/adjustment_types.h b/drivers/gpu/drm/amd/dal/include/adjustment_types.h
index 423fe21..67a5daf 100644
--- a/drivers/gpu/drm/amd/dal/include/adjustment_types.h
+++ b/drivers/gpu/drm/amd/dal/include/adjustment_types.h
@@ -126,7 +126,7 @@ union adjustment_property {
 		uint32_t SETMODE_REQ:1;
 		/*adjustment is applied at the end of set mode*/
 		uint32_t POST_SET:1;
-/*when adjustment is applied its value should be stored in registry
+/*when adjustment is applied its value should be stored
 in place and not wait for flush call*/
 		uint32_t SAVE_IN_PLACE:1;
 		/*adjustment is always apply*/
@@ -250,9 +250,9 @@ enum ds_color_space {
 	DS_COLOR_SPACE_YCBCR709_YONLY/*same as YCbCr, but Y in Full range*/
 };
 
-enum ds_reg_underscan_options {
-	DS_REG_UNDERSCAN_OPTION_DEFAULT = 0,
-	DS_REG_UNDERSCAN_OPTION_USECEA861D
+enum ds_underscan_options {
+	DS_UNDERSCAN_OPTION_DEFAULT = 0,
+	DS_UNDERSCAN_OPTION_USECEA861D
 };
 
 enum dpms_state {
@@ -380,8 +380,7 @@ union ds_regamma_flags {
 };
 
 struct ds_regamma_ramp {
-/* gamma ramp packed  in same way as OS windows ,r , g & b*/
-	uint16_t gamma[256 * 3];
+	uint16_t gamma[256 * 3]; /* gamma ramp packed as RGB */
 
 };
 
diff --git a/drivers/gpu/drm/amd/dal/include/dal_types.h b/drivers/gpu/drm/amd/dal/include/dal_types.h
index 095336a..4611872 100644
--- a/drivers/gpu/drm/amd/dal/include/dal_types.h
+++ b/drivers/gpu/drm/amd/dal/include/dal_types.h
@@ -119,7 +119,7 @@ struct bdf_info {
 /* shift values for bool override parameter mask
  * bmask is for this struct,if we touch this feature
  * bval indicates every bit fields for this struct too,1 is enable this feature
- * amdsoc.disp_bval=1594, amdsoc.disp_bmask=1594 ,
+ * amdgpu.disp_bval=1594, amdgpu.disp_bmask=1594 ,
  * finally will show log like this:
  * Overridden FEATURE_LIGHT_SLEEP is enabled now
  * Overridden FEATURE_USE_MAX_DISPLAY_CLK is enabled now
@@ -184,7 +184,7 @@ struct dal_context {
 #if defined(BUILD_DAL_TEST)
 	struct test_driver_context *driver_context;
 #else
-	void *driver_context; /* e.g. amdsoc_device */
+	void *driver_context; /* e.g. amdgpu_device */
 #endif
 	struct dal_logger *logger;
 	void *cgs_device;
diff --git a/drivers/gpu/drm/amd/dal/include/logger_interface.h b/drivers/gpu/drm/amd/dal/include/logger_interface.h
index 940b43d..ce887f4 100644
--- a/drivers/gpu/drm/amd/dal/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/logger_interface.h
@@ -33,10 +33,7 @@ struct dal_context;
 union logger_flags;
 
 /*
- * TODO:
- * This logger functionality needs to be implemented and reworked.
- * for now, just moving it outside of amdsoc_dal_services
- *
+ * TODO: This logger functionality needs to be implemented and reworked.
  */
 
 
diff --git a/drivers/gpu/drm/amd/dal/include/logger_types.h b/drivers/gpu/drm/amd/dal/include/logger_types.h
index 40921ee..80509b5 100644
--- a/drivers/gpu/drm/amd/dal/include/logger_types.h
+++ b/drivers/gpu/drm/amd/dal/include/logger_types.h
@@ -27,12 +27,11 @@
 #define __DAL_LOGGER_TYPES_H__
 
 
-/* TODO:
- * This logger functionality needs to be implemented and reworked.
- * for now, just moving it outside of amdsoc_dal_services
- *
+/*
+ * TODO: This logger functionality needs to be implemented and reworked.
  */
 
+
 struct dal_logger;
 
 enum log_major {
diff --git a/drivers/gpu/drm/amd/dal/include/scaler_types.h b/drivers/gpu/drm/amd/dal/include/scaler_types.h
index e56e515..114d928 100644
--- a/drivers/gpu/drm/amd/dal/include/scaler_types.h
+++ b/drivers/gpu/drm/amd/dal/include/scaler_types.h
@@ -222,9 +222,6 @@ struct scaler_data {
 	const struct hw_crtc_timing *hw_crtc_timing;
 
 	struct rect viewport;
-	/* pixel_format
-	 * Android set_mode_types.h == window surfacetypes
-	 * Android surface_pixel_format == window dalpixelformat*/
 
 	enum pixel_format dal_pixel_format;/*plane concept*/
 	/*stereoformat TODO*/
diff --git a/drivers/gpu/drm/amd/dal/interface/dal.c b/drivers/gpu/drm/amd/dal/interface/dal.c
index c1988c0..ac57ef0 100644
--- a/drivers/gpu/drm/amd/dal/interface/dal.c
+++ b/drivers/gpu/drm/amd/dal/interface/dal.c
@@ -718,9 +718,8 @@ bool dal_pre_adapter_clock_change(struct dal *dal,
 		result = dal_ds_dispatch_pre_adapter_clock_change(ds_dispatch);
 
 		/* cache new clock values, to be applied when
-		 * amdsoc_dm_post_adapter_clock_change is called
+		 * post_adapter_clock_change is called
 		 */
-
 		gpu_clk_info.min_sclk_khz = clks_info->min_sclk;
 		gpu_clk_info.max_sclk_khz = clks_info->max_sclk;
 		gpu_clk_info.min_mclk_khz = clks_info->min_mclk;
diff --git a/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c b/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c
index ecad5b7..29447b6 100644
--- a/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c
+++ b/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c
@@ -588,7 +588,7 @@ static void retrieve_psr_link_cap(
 	}
 
 	/* For PSR test support. This code enables PSR on non-supported panels
-	 * through registry key settings. */
+	 * through runtime parameters. */
 	if (dal_adapter_service_is_feature_supported(FEATURE_FORCE_PSR)) {
 		union psr_capabilities psr_capabilities;
 
@@ -2724,7 +2724,7 @@ static bool handle_hpd_irq_psr_sink(struct link_service *ls)
 	 * registers. We should only read PSR status registers in
 	 * DPCD only if we've attached the DMCU object to the display
 	 * path and we are supporting the PSR feature. Without test
-	 * related registry keys set, the DMCU object is only attached
+	 * related runtime parameters set, the DMCU object is only attached
 	 * to an eDP panel, in which values are defined by the eDP 1.3 spec. */
 	if (!dal_ls_is_link_psr_supported(ls))
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c
index 0689d9f..2baa54a 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c
@@ -222,7 +222,6 @@ static bool construct(
 	mm->supported_pixel_format |= PIXEL_FORMAT_ARGB8888;
 	mm->supported_pixel_format |= PIXEL_FORMAT_ARGB2101010;
 
-	/* XRBIAS supported on win7 */
 	if (dal_adapter_service_get_asic_runtime_flags(mm->as).bits.
 		SUPPORT_XRBIAS)
 		mm->supported_pixel_format |=
@@ -556,7 +555,10 @@ static bool insert_view_and_update_solutions(
 	/* this is newly added view, insert the View to master view list, and
 	 * insert association to all association tables. */
 	if (!dal_view_info_list_insert(&mm->master_view_list, vi))
-		/* failed to insert the view due to pruning against registry */
+		/*
+		 * failed to insert the view due to pruning against
+		 * runtime parameters
+		 */
 		return false;
 
 	solution_container_count =
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
index 888b2fc..86eb300 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
@@ -476,7 +476,7 @@ static void allow_aux_while_hpd_low(
  *  Function: need_handle_connection_status_based_on_sink_count
  *
  *  @brief : check whether we need handle dongle sink count info. only check
- *  sink_count == 0 for some known dongle or registry key exist.
+ *  sink_count == 0 for some known dongle or if runtime parameter exist.
  *
  *  @return
  *
@@ -586,7 +586,7 @@ static bool apply_load_detection_based_edid_patch(
 				/*if connectors are the same, and the temp
 				 * display path's signal type is RGB (CRT).
 				 * TODO : what does temp_path !=
-				 * display_path mean? debug under windbg
+				 * display_path mean? debug
 				 * if (temp_path != display_path &&
 				 *  dal_display_path_get_query_signal
 				 * (temp_path, SINK_LINK_INDEX) ==
@@ -827,7 +827,7 @@ static bool read_edid(
 	if (dal_is_dp_signal(detection_status->detected_signal))
 		connected = (detection_status->connected || connected);
 
-	/* Handling the case of unplugging of a VGA monitor on Win7 with
+	/* Handling the case of unplugging of a VGA monitor with
 	 * DDC polling. In this case we keep track of previous EDID read status
 	 * so we can detect a change and detect the unplug return so that we do
 	 * not try and detect load as this is non destructive and we want to
@@ -1106,8 +1106,8 @@ static void do_target_detection(
 	}
 
 	/** Step 5. Edid read  - updates detection status
-	 *  only read edid, if connected (HPD sensebit check), or registry key
-	 *  not set, or set but value is 0
+	 *  only read edid, if connected (HPD sensebit check), or
+	 *  runtime parameters not set, or set but value is 0
 	 */
 	if (detection_status->connected
 			|| !dal_adapter_service_is_feature_supported(
@@ -2329,7 +2329,7 @@ void dal_tm_detection_mgr_update_active_state(
 
 	/*here only handle registered display path*/
 	for (i = 0; i < connector_irq->displays_num; ++i) {
-		/* TODO: check connector id only. check under windbg*/
+		/* TODO: check connector id only. */
 		if (dal_graphics_object_id_is_equal(
 				get_connector_obj_id(
 						connector_irq->displays[i]),
diff --git a/drivers/gpu/drm/amd/dal/topology/topology.c b/drivers/gpu/drm/amd/dal/topology/topology.c
index c4eba4b..fa74b76 100644
--- a/drivers/gpu/drm/amd/dal/topology/topology.c
+++ b/drivers/gpu/drm/amd/dal/topology/topology.c
@@ -2670,13 +2670,13 @@ static void tm_initialize_static_screen_events(struct topology_mgr *tm,
 	/* Initialize to set no events. */
 	events.u_all = 0;
 
-	/* Try to find registry forced events. */
+	/* Try to find runtime parameter forced events. */
 	dal_adapter_service_get_feature_value(
 			FEATURE_FORCE_STATIC_SCREEN_EVENT_TRIGGERS,
 			&events.u_all,
 			sizeof(events.u_all));
 
-	/* If registry key is not set or set to 0, we should use Driver
+	/* If runtime parameter is not set or set to 0, we should use Driver
 	 * defaults, which is defined by the logic below. */
 	if (events.u_all == 0) {
 		/* Set initial Static Screen trigger events. */
@@ -2684,13 +2684,10 @@ static void tm_initialize_static_screen_events(struct topology_mgr *tm,
 		events.bits.GFX_UPDATE = 1;
 		events.bits.OVL_UPDATE = 1;
 
-		/* Memory hit region trigger events are only needed if OS
-		 * supports writing directly to primary surface. These OS
-		 * include Win 7 DWM Off case and Linux. Otherwise, memory
-		 * hit region triggers would not be needed because a flip
-		 * would occur in order to update surface, such as for Win 8
-		 * and above. This registry key may be set to some default
-		 * value for different OS based on its behaviour. */
+		/*
+		 * On Linux the OS might write directly to the primary
+		 * surface. Enable memory trigger events.
+		 */
 		if (dal_adapter_service_is_feature_supported(
 				FEATURE_ALLOW_DIRECT_MEMORY_ACCESS_TRIG)) {
 
@@ -4451,7 +4448,7 @@ static enum tm_engine_priority tm_get_stream_engine_priority(
 
 	/* For embedded panels(LVDS only), we want to reserve one stream engine
 	 * resource to guarantee the embedded panel can be used.
-	 * We don't reserve for eDP (controlled by registry key) because on
+	 * We don't reserve for eDP (controlled by runtime parameter) because on
 	 * some ASICs for e.g. Kabini where there are only 2 DIGs and if we
 	 * reserve one for eDP then we can drive only one MST monitor even if
 	 * the user disables eDP, by not reserving for eDP, the user will have
-- 
1.9.1

