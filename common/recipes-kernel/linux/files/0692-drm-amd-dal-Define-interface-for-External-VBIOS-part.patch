From 777022b361d791813c9e399bd7d7b1e3efe28232 Mon Sep 17 00:00:00 2001
From: David Rokhvarg <David.Rokhvarg@amd.com>
Date: Tue, 12 Jan 2016 12:01:10 -0500
Subject: [PATCH 0692/1110] drm/amd/dal: Define interface for External VBIOS -
 part 2.

Signed-off-by: David Rokhvarg <David.Rokhvarg@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
---
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c   | 140 ++--
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.h   |   5 +-
 .../drm/amd/dal/dc/adapter/wireless_data_source.c  |   9 +-
 .../drm/amd/dal/dc/adapter/wireless_data_source.h  |   4 +-
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c      | 807 ++++++++++++++-------
 .../gpu/drm/amd/dal/dc/bios/bios_parser_helper.c   |   1 -
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |   4 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |   5 +-
 drivers/gpu/drm/amd/dal/dc/dc_bios_types.h         | 248 ++++++-
 drivers/gpu/drm/amd/dal/dc/dc_helpers.h            |   2 +
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  51 +-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |  59 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |   2 +-
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  |   7 +-
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.h  |   2 +-
 .../amd/dal/dc/dce110/dce110_timing_generator.c    |   7 +-
 .../gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.c |   2 +-
 .../gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.h |   4 +-
 drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c      |   7 +-
 drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h      |   2 +-
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |   4 +-
 .../dal/dc/gpu/dce110/pll_clock_source_dce110.c    |   6 +-
 .../dal/dc/gpu/dce110/vce_clock_source_dce110.c    |   4 +-
 drivers/gpu/drm/amd/dal/dc/gpu/ext_clock_source.c  |  11 +-
 drivers/gpu/drm/amd/dal/dc/gpu/pll_clock_source.c  |   7 +-
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |   2 +-
 drivers/gpu/drm/amd/dal/dc/inc/stream_encoder.h    |   4 +-
 .../amd/dal/include/adapter_service_interface.h    |   3 +-
 .../drm/amd/dal/include/adapter_service_types.h    |   1 +
 .../drm/amd/dal/include/bios_parser_interface.h    | 216 +-----
 .../gpu/drm/amd/dal/include/bios_parser_types.h    |  19 +-
 .../drm/amd/dal/include/timing_generator_types.h   |   3 +-
 32 files changed, 1007 insertions(+), 641 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index 6084466..b3b3be7 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -26,15 +26,15 @@
 
 #include "dal_services.h"
 
+#include "dc_bios_types.h"
+
 #include "include/adapter_service_interface.h"
 #include "include/i2caux_interface.h"
 #include "include/asic_capability_types.h"
-#include "include/bios_parser_interface.h"
 #include "include/gpio_service_interface.h"
 #include "include/asic_capability_interface.h"
 #include "include/logger_interface.h"
 
-#include "dc_bios_types.h"
 #include "adapter_service.h"
 #include "hw_ctx_adapter_service.h"
 #include "wireless_data_source.h"
@@ -233,10 +233,8 @@ static void initialize_backlight_caps(
 			return;
 	}
 
-	if (dal_bios_parser_get_firmware_info
-			(as->bios_parser, &fw_info)	!= BP_RESULT_OK ||
-		dal_bios_parser_get_embedded_panel_info
-			(as->bios_parser, &panel_info) != BP_RESULT_OK)
+	if (as->dcb->funcs->get_firmware_info(as->dcb, &fw_info) != BP_RESULT_OK ||
+		as->dcb->funcs->get_embedded_panel_info(as->dcb, &panel_info) != BP_RESULT_OK)
 		return;
 
 	params.data = &caps;
@@ -553,7 +551,7 @@ static bool get_hpd_info(struct adapter_service *as,
 	struct graphics_object_hpd_info *info)
 {
 	return BP_RESULT_OK ==
-		dal_bios_parser_get_hpd_info(as->bios_parser, id, info);
+		as->dcb->funcs->get_hpd_info(as->dcb, id, info);
 }
 
 /*
@@ -687,10 +685,10 @@ static void adapter_service_destruct(
 {
 	dal_adapter_service_destroy_hw_ctx(&as->hw_ctx);
 	dal_i2caux_destroy(&as->i2caux);
-	dal_bios_parser_destroy(&as->bios_parser);
 	dal_gpio_service_destroy(&as->gpio_service);
 	dal_asic_capability_destroy(&as->asic_cap);
-	dal_bios_parser_destroy_integrated_info(as->ctx, &as->integrated_info);
+	as->dcb->funcs->destroy_integrated_info(as->dcb, &as->integrated_info);
+	dal_bios_parser_destroy(&as->dcb);
 }
 
 /*
@@ -736,18 +734,16 @@ static bool adapter_service_construct(
 		goto failed_to_generate_features;
 	}
 
-	if (init_data->vbios_override) {
-		/* TODO: remove the typecast */
-		as->bios_parser = (struct bios_parser *)init_data->vbios_override;
-	} else {
+	if (init_data->vbios_override)
+		as->dcb = init_data->vbios_override;
+	else {
 		/* Create BIOS parser */
 		init_data->bp_init_data.ctx = init_data->ctx;
 
-		as->bios_parser =
-			dal_bios_parser_create(&init_data->bp_init_data, as);
+		as->dcb = dal_bios_parser_create(&init_data->bp_init_data, as);
 	}
 
-	if (!as->bios_parser) {
+	if (!as->dcb) {
 		ASSERT_CRITICAL(false);
 		goto failed_to_create_bios_parser;
 	}
@@ -784,10 +780,10 @@ static bool adapter_service_construct(
 	/* Avoid wireless encoder creation in upstream branch. */
 
 	/* Integrated info is not provided on discrete ASIC. NULL is allowed */
-	as->integrated_info = dal_bios_parser_create_integrated_info(
-			as->bios_parser);
+	as->integrated_info = as->dcb->funcs->create_integrated_info(
+			as->dcb);
 
-	dal_bios_parser_post_init(as->bios_parser);
+	as->dcb->funcs->post_init(as->dcb);
 
 	/* Generate backlight translation table and initializes
 			  other brightness properties */
@@ -809,7 +805,7 @@ failed_to_create_i2caux:
 	dal_gpio_service_destroy(&as->gpio_service);
 
 failed_to_create_gpio_service:
-	dal_bios_parser_destroy(&as->bios_parser);
+	dal_bios_parser_destroy(&as->dcb);
 
 failed_to_create_bios_parser:
 	dal_asic_capability_destroy(&as->asic_cap);
@@ -926,8 +922,7 @@ uint8_t dal_adapter_service_get_connectors_num(
 	uint8_t wireless_connectors_num = 0;
 	struct dc_bios *dcb;
 
-	/* TODO: remove type cast */
-	dcb = (struct dc_bios*)dal_adapter_service_get_bios_parser(as);
+	dcb = dal_adapter_service_get_bios_parser(as);
 
 	vbios_connectors_num = dcb->funcs->get_connectors_number(dcb);
 
@@ -964,7 +959,7 @@ uint32_t dal_adapter_service_get_src_num(
 	if (is_wireless_object(id))
 		return wireless_get_srcs_num(as, id);
 	else
-		return dal_bios_parser_get_src_number(as->bios_parser, id);
+		return as->dcb->funcs->get_src_number(as->dcb, id);
 }
 
 /**
@@ -989,8 +984,8 @@ struct graphics_object_id dal_adapter_service_get_src_obj(
 		src_object_id = wireless_get_src_obj_id(as, id, index);
 	else {
 		if (BP_RESULT_OK !=
-			dal_bios_parser_get_src_obj(
-				as->bios_parser, id, index, &src_object_id))
+			as->dcb->funcs->get_src_obj(
+				as->dcb, id, index, &src_object_id))
 			src_object_id =
 				dal_graphics_object_id_init(
 					0,
@@ -1017,8 +1012,7 @@ struct graphics_object_id dal_adapter_service_get_connector_obj_id(
 	struct dc_bios *dcb;
 	uint8_t bios_connectors_num;
 
-	/* TODO: remove type cast */
-	dcb = (struct dc_bios*)dal_adapter_service_get_bios_parser(as);
+	dcb = dal_adapter_service_get_bios_parser(as);
 
 	bios_connectors_num = dcb->funcs->get_connectors_number(dcb);
 
@@ -1027,8 +1021,8 @@ struct graphics_object_id dal_adapter_service_get_connector_obj_id(
 				as,
 				connector_index);
 	else
-		return dal_bios_parser_get_connector_id(
-				as->bios_parser,
+		return as->dcb->funcs->get_connector_id(
+				as->dcb,
 				connector_index);
 }
 
@@ -1038,7 +1032,7 @@ bool dal_adapter_service_get_device_tag(
 		uint32_t device_tag_index,
 		struct connector_device_tag_info *info)
 {
-	if (BP_RESULT_OK == dal_bios_parser_get_device_tag(as->bios_parser,
+	if (BP_RESULT_OK == as->dcb->funcs->get_device_tag(as->dcb,
 			connector_object_id, device_tag_index, info))
 		return true;
 	else
@@ -1049,7 +1043,7 @@ bool dal_adapter_service_get_device_tag(
 bool dal_adapter_service_is_device_id_supported(struct adapter_service *as,
 		struct device_id id)
 {
-	return dal_bios_parser_is_device_id_supported(as->bios_parser, id);
+	return as->dcb->funcs->is_device_id_supported(as->dcb, id);
 }
 
 bool dal_adapter_service_is_meet_underscan_req(struct adapter_service *as)
@@ -1092,7 +1086,7 @@ uint8_t dal_adapter_service_get_clock_sources_num(
 	 * as a clock source for DP
 	 */
 	enum bp_result bp_result =
-			dal_bios_parser_get_firmware_info(as->bios_parser,
+			as->dcb->funcs->get_firmware_info(as->dcb,
 					&fw_info);
 
 	if (BP_RESULT_OK == bp_result &&
@@ -1211,7 +1205,7 @@ bool dal_adapter_service_get_i2c_info(
 	}
 
 	return BP_RESULT_OK ==
-		dal_bios_parser_get_i2c_info(as->bios_parser, id, i2c_info);
+		as->dcb->funcs->get_i2c_info(as->dcb, id, i2c_info);
 }
 
 /*
@@ -1269,7 +1263,7 @@ struct irq *dal_adapter_service_obtain_hpd_irq(
 	if (!get_hpd_info(as, id, &hpd_info))
 		return NULL;
 
-	bp_result = dal_bios_parser_get_gpio_pin_info(as->bios_parser,
+	bp_result = as->dcb->funcs->get_gpio_pin_info(as->dcb,
 		hpd_info.hpd_int_gpio_uid, &pin_info);
 
 	if (bp_result != BP_RESULT_OK) {
@@ -1304,7 +1298,7 @@ uint32_t dal_adapter_service_get_ss_info_num(
 	struct adapter_service *as,
 	enum as_signal_type signal)
 {
-	return dal_bios_parser_get_ss_entry_number(as->bios_parser, signal);
+	return as->dcb->funcs->get_ss_entry_number(as->dcb, signal);
 }
 
 /*
@@ -1319,8 +1313,8 @@ bool dal_adapter_service_get_ss_info(
 	struct spread_spectrum_info *info)
 {
 	enum bp_result bp_result =
-		dal_bios_parser_get_spread_spectrum_info(
-			as->bios_parser, signal, idx, info);
+		as->dcb->funcs->get_spread_spectrum_info(
+			as->dcb, signal, idx, info);
 
 	return BP_RESULT_OK == bp_result;
 }
@@ -1510,22 +1504,20 @@ struct gpio *dal_adapter_service_obtain_stereo_gpio(
 	result.raw = as->asic_cap->data[ASIC_DATA_FEATURE_FLAGS];
 
 	/* Case 1 : Workstation stereo */
-	if (result.bits.WORKSTATION_STEREO)
+	if (result.bits.WORKSTATION_STEREO) {
 		/* "active low" <--> "default 3d right eye polarity" = false */
-		return dal_gpio_service_create_gpio_ex(
-			as->gpio_service, GPIO_ID_GENERIC, GPIO_GENERIC_A,
-			GPIO_PIN_OUTPUT_STATE_ACTIVE_LOW);
+		return dal_gpio_service_create_gpio_ex(as->gpio_service,
+				GPIO_ID_GENERIC, GPIO_GENERIC_A,
+				GPIO_PIN_OUTPUT_STATE_ACTIVE_LOW);
 	/* Case 2 : runtime parameter override for sideband stereo */
-	else if (have_param_stereo_gpio) {
+	} else if (have_param_stereo_gpio) {
 		/* TODO implement */
 		return NULL;
-	/* Case 3 : VBIOS gives us GPIO for sideband stereo */
+		/* Case 3 : VBIOS gives us GPIO for sideband stereo */
 	} else {
 		const struct graphics_object_id id =
-			dal_graphics_object_id_init(
-				GENERIC_ID_STEREO,
-				ENUM_ID_1,
-				OBJECT_TYPE_GENERIC);
+				dal_graphics_object_id_init(GENERIC_ID_STEREO,
+						ENUM_ID_1, OBJECT_TYPE_GENERIC);
 
 		struct bp_gpio_cntl_info cntl_info;
 		struct gpio_pin_info pin_info;
@@ -1533,18 +1525,21 @@ struct gpio *dal_adapter_service_obtain_stereo_gpio(
 		/* Get GPIO record for this object.
 		 * Stereo GPIO record should have exactly one entry
 		 * where active state defines stereosync polarity */
-		if (1 != dal_bios_parser_get_gpio_record(
-			as->bios_parser, id, &cntl_info, 1)) {
+		if (1 != as->dcb->funcs->get_gpio_record(
+						as->dcb, id, &cntl_info,
+						1)) {
 			return NULL;
-		} else if (BP_RESULT_OK != dal_bios_parser_get_gpio_pin_info(
-			as->bios_parser, cntl_info.id, &pin_info)) {
+		} else if (BP_RESULT_OK
+				!= as->dcb->funcs->get_gpio_pin_info(
+						as->dcb, cntl_info.id,
+						&pin_info)) {
 			/*ASSERT_CRITICAL(false);*/
 			return NULL;
-		} else
-			return dal_gpio_service_create_gpio_ex(
-				as->gpio_service,
-				pin_info.offset, pin_info.mask,
-				cntl_info.state);
+		} else {
+			return dal_gpio_service_create_gpio_ex(as->gpio_service,
+					pin_info.offset, pin_info.mask,
+					cntl_info.state);
+		}
 	}
 }
 
@@ -1569,7 +1564,7 @@ bool dal_adapter_service_get_firmware_info(
 	struct adapter_service *as,
 	struct firmware_info *info)
 {
-	return dal_bios_parser_get_firmware_info(as->bios_parser, info) ==
+	return as->dcb->funcs->get_firmware_info(as->dcb, info) ==
 		BP_RESULT_OK;
 }
 
@@ -1666,13 +1661,10 @@ uint32_t dal_adapter_service_get_memory_type_multiplier(
  *
  * Get BIOS parser handler
  */
-/* TODO: change return type to 'dc_bios'. */
-struct bios_parser *dal_adapter_service_get_bios_parser(
+struct dc_bios *dal_adapter_service_get_bios_parser(
 	struct adapter_service *as)
 {
-	/* TODO: conditionally return 'override' or 'real'.
-	 * Works for now because 'base' is first member of 'bios parser' */
-	return as->bios_parser;
+	return as->dcb;
 }
 
 /*
@@ -1764,8 +1756,7 @@ bool dal_adapter_service_get_embedded_panel_info(
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
 
-	result = dal_bios_parser_get_embedded_panel_info(
-		as->bios_parser, info);
+	result = as->dcb->funcs->get_embedded_panel_info(as->dcb, info);
 
 	return result == BP_RESULT_OK;
 }
@@ -1781,8 +1772,8 @@ bool dal_adapter_service_enum_embedded_panel_patch_mode(
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
 
-	result = dal_bios_parser_enum_embedded_panel_patch_mode(
-		as->bios_parser, index, mode);
+	result = as->dcb->funcs->enum_embedded_panel_patch_mode(
+		as->dcb, index, mode);
 
 	return result == BP_RESULT_OK;
 }
@@ -1793,9 +1784,8 @@ bool dal_adapter_service_get_faked_edid_len(
 {
 	enum bp_result result;
 
-	result = dal_bios_parser_get_faked_edid_len(
-		as->bios_parser,
-		len);
+	result = as->dcb->funcs->get_faked_edid_len(as->dcb, len);
+
 	return result == BP_RESULT_OK;
 }
 
@@ -1806,8 +1796,8 @@ bool dal_adapter_service_get_faked_edid_buf(
 {
 	enum bp_result result;
 
-	result = dal_bios_parser_get_faked_edid_buf(
-		as->bios_parser,
+	result = as->dcb->funcs->get_faked_edid_buf(
+		as->dcb,
 		buf,
 		len);
 	return result == BP_RESULT_OK;
@@ -1896,7 +1886,7 @@ bool dal_adapter_service_should_optimize(
  */
 bool dal_adapter_service_is_in_accelerated_mode(struct adapter_service *as)
 {
-	return dal_bios_parser_is_accelerated_mode(as->bios_parser);
+	return as->dcb->funcs->is_accelerated_mode(as->dcb);
 }
 
 struct ddc *dal_adapter_service_obtain_ddc_from_i2c_info(
@@ -1946,7 +1936,7 @@ bool dal_adapter_service_is_lid_open(struct adapter_service *as)
 		return is_lid_open;
 
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
-	return dal_bios_parser_is_lid_open(as->bios_parser);
+	return as->dcb->funcs->is_lid_open(as->dcb);
 #else
 	return false;
 #endif
@@ -2033,8 +2023,8 @@ bool dal_adapter_service_get_encoder_cap_info(
 	 * - dpHbr2Cap: indicates supported/not supported by HW Encoder
 	 * - dpHbr2En : indicates DP spec compliant/not compliant
 	 */
-	result = dal_bios_parser_get_encoder_cap_info(
-			as->bios_parser,
+	result = as->dcb->funcs->get_encoder_cap_info(
+			as->dcb,
 			id,
 			&bp_cap_info);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h
index dd5bb00..5bb4446 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h
@@ -27,6 +27,7 @@
 #define __DAL_ADAPTER_SERVICE_H__
 
 /* Include */
+#include "dc_bios_types.h"
 #include "include/adapter_service_interface.h"
 #include "wireless_data_source.h"
 
@@ -35,13 +36,13 @@
  */
 struct gpio_service;
 struct asic_cap;
-struct dc_bios;
+
 
 /* Adapter service */
 struct adapter_service {
 	struct dc_context *ctx;
 	struct asic_capability *asic_cap;
-	struct bios_parser *bios_parser;/* TODO: remove it. replace by struct dc_bios *dcb; */
+	struct dc_bios *dcb;
 	struct gpio_service *gpio_service;
 	struct i2caux *i2caux;
 	struct wireless_data wireless_data;
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
index dcb885d..0249829 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
@@ -32,12 +32,12 @@
 
 /*construct wireless data*/
 bool wireless_data_init(struct wireless_data *data,
-		struct bios_parser *bp,
+		struct dc_bios *dcb,
 		struct wireless_init_data *init_data)
 {
 	struct firmware_info info;
 
-	if (data == NULL || bp == NULL || init_data == NULL) {
+	if (data == NULL || dcb == NULL || init_data == NULL) {
 		ASSERT_CRITICAL(false);
 		return false;
 	}
@@ -66,10 +66,9 @@ bool wireless_data_init(struct wireless_data *data,
 		 * Check if SBIOS sets remote display enable, exposed
 		 * through VBIOS. This is only valid for APU, not dGPU
 		 */
-		dal_bios_parser_get_firmware_info(bp, &info);
+		dcb->funcs->get_firmware_info(dcb, &info);
 
-		if ((REMOTE_DISPLAY_ENABLE ==
-			info.remote_display_config) &&
+		if ((REMOTE_DISPLAY_ENABLE == info.remote_display_config) &&
 				init_data->fusion) {
 			data->wireless_enable = true;
 			data->wireless_disp_path_enable = true;
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h
index 54b140a..b64089e 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h
@@ -33,7 +33,7 @@
  * Forward declaration
  */
 struct adapter_service;
-struct bios_parser;
+struct dc_bios;
 
 /* Wireless data init structure */
 struct wireless_init_data {
@@ -55,7 +55,7 @@ struct wireless_data {
 /*construct wireless data*/
 bool wireless_data_init(
 	struct wireless_data *data,
-	struct bios_parser *bp,
+	struct dc_bios *dcb,
 	struct wireless_init_data *init_data);
 
 uint8_t wireless_get_clocks_num(
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
index 3329322..3ca165b 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
@@ -40,6 +40,7 @@
 #endif
 #include "command_table_helper.h"
 #include "bios_parser.h"
+#include "bios_parser_interface.h"
 
 #define THREE_PERCENT_OF_10000 300
 
@@ -100,101 +101,21 @@ static void process_ext_display_connection_info(struct bios_parser *bp);
 #define BIOS_IMAGE_SIZE_UNIT 512
 
 /*****************************************************************************/
-static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb);
-
-const struct dc_vbios_funcs vbios_funcs = {
-	.get_connectors_number = bios_parser_get_connectors_number
-};
-
 static bool bios_parser_construct(
 	struct bios_parser *bp,
 	struct bp_init_data *init,
-	struct adapter_service *as)
-{
-	uint16_t *rom_header_offset = NULL;
-	ATOM_ROM_HEADER *rom_header = NULL;
-	ATOM_OBJECT_HEADER *object_info_tbl;
-	enum dce_version dce_version;
-
-	if (!as)
-		return false;
+	struct adapter_service *as);
 
-	if (!init)
-		return false;
+static uint8_t bios_parser_get_connectors_number(
+	struct dc_bios *dcb);
 
-	if (!init->bios)
-		return false;
-
-	bp->base.funcs = &vbios_funcs;
-
-	dce_version = dal_adapter_service_get_dce_version(as);
-	bp->ctx = init->ctx;
-	bp->as = as;
-	bp->bios = init->bios;
-	bp->bios_size = bp->bios[BIOS_IMAGE_SIZE_OFFSET] * BIOS_IMAGE_SIZE_UNIT;
-	bp->bios_local_image = NULL;
-	bp->lcd_scale = LCD_SCALE_UNKNOWN;
-
-	rom_header_offset =
-	GET_IMAGE(uint16_t, OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER);
-
-	if (!rom_header_offset)
-		return false;
-
-	rom_header = GET_IMAGE(ATOM_ROM_HEADER, *rom_header_offset);
-
-	if (!rom_header)
-		return false;
-
-	bp->master_data_tbl =
-	GET_IMAGE(ATOM_MASTER_DATA_TABLE,
-		rom_header->usMasterDataTableOffset);
-
-	if (!bp->master_data_tbl)
-		return false;
-
-	bp->object_info_tbl_offset = DATA_TABLES(Object_Header);
-
-	if (!bp->object_info_tbl_offset)
-		return false;
-
-	object_info_tbl =
-	GET_IMAGE(ATOM_OBJECT_HEADER, bp->object_info_tbl_offset);
-
-	if (!object_info_tbl)
-		return false;
-
-	get_atom_data_table_revision(&object_info_tbl->sHeader,
-		&bp->object_info_tbl.revision);
-
-	if (bp->object_info_tbl.revision.major == 1
-		&& bp->object_info_tbl.revision.minor >= 3) {
-		ATOM_OBJECT_HEADER_V3 *tbl_v3;
-
-		tbl_v3 = GET_IMAGE(ATOM_OBJECT_HEADER_V3,
-			bp->object_info_tbl_offset);
-		if (!tbl_v3)
-			return false;
-
-		bp->object_info_tbl.v1_3 = tbl_v3;
-	} else if (bp->object_info_tbl.revision.major == 1
-		&& bp->object_info_tbl.revision.minor >= 1)
-		bp->object_info_tbl.v1_1 = object_info_tbl;
-	else
-		return false;
-
-#if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
-	bp->vbios_helper_data.active = 0;
-	bp->vbios_helper_data.requested = 0;
-	dal_bios_parser_init_bios_helper(bp, dce_version);
-#endif
-	dal_bios_parser_init_cmd_tbl(bp);
-	dal_bios_parser_init_cmd_tbl_helper(&bp->cmd_helper, dce_version);
+static enum bp_result bios_parser_get_embedded_panel_info(
+	struct dc_bios *dcb,
+	struct embedded_panel_info *info);
 
-	return true;
-}
+/*****************************************************************************/
 
-struct bios_parser *dal_bios_parser_create(
+struct dc_bios *dal_bios_parser_create(
 	struct bp_init_data *init, struct adapter_service *as)
 {
 	struct bios_parser *bp = NULL;
@@ -204,7 +125,7 @@ struct bios_parser *dal_bios_parser_create(
 		return NULL;
 
 	if (bios_parser_construct(bp, init, as))
-		return bp;
+		return &bp->base;
 
 	dc_service_free(init->ctx, bp);
 	BREAK_TO_DEBUGGER();
@@ -217,29 +138,35 @@ static void destruct(struct bios_parser *bp)
 		dc_service_free(bp->ctx, bp->bios_local_image);
 }
 
-void dal_bios_parser_destroy(struct bios_parser **bp)
+void dal_bios_parser_destroy(struct dc_bios **dcb)
 {
-	if (!bp || !*bp) {
+	struct bios_parser *bp = BP_FROM_DCB(*dcb);
+
+	if (!bp) {
 		BREAK_TO_DEBUGGER();
 		return;
 	}
 
-	destruct(*bp);
+	destruct(bp);
 
-	dc_service_free((*bp)->ctx, *bp);
-	*bp = NULL;
+	dc_service_free((bp)->ctx, bp);
+	*dcb = NULL;
 }
 
-void dal_bios_parser_power_down(struct bios_parser *bp)
+static void bios_parser_power_down(struct dc_bios *dcb)
 {
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	dal_bios_parser_set_scratch_lcd_scale(bp, bp->lcd_scale);
 #endif
 }
 
-void dal_bios_parser_power_up(struct bios_parser *bp)
+static void bios_parser_power_up(struct dc_bios *dcb)
 {
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (bp->lcd_scale == LCD_SCALE_UNKNOWN)
 		bp->lcd_scale = dal_bios_parser_get_scratch_lcd_scale(bp);
 #endif
@@ -259,8 +186,10 @@ static uint8_t get_number_of_objects(struct bios_parser *bp, uint32_t offset)
 		return table->ucNumberOfObjects;
 }
 
-uint8_t dal_bios_parser_get_encoders_number(struct bios_parser *bp)
+static uint8_t bios_parser_get_encoders_number(struct dc_bios *dcb)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	return get_number_of_objects(bp,
 		le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset));
 }
@@ -273,9 +202,10 @@ static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)
 		le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset));
 }
 
-uint32_t dal_bios_parser_get_oem_ddc_lines_number(struct bios_parser *bp)
+static uint32_t bios_parser_get_oem_ddc_lines_number(struct dc_bios *dcb)
 {
 	uint32_t number = 0;
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (DATA_TABLES(OemInfo) != 0) {
 		ATOM_OEM_INFO *info;
@@ -296,9 +226,11 @@ uint32_t dal_bios_parser_get_oem_ddc_lines_number(struct bios_parser *bp)
 	return number;
 }
 
-struct graphics_object_id dal_bios_parser_get_encoder_id(struct bios_parser *bp,
+static struct graphics_object_id bios_parser_get_encoder_id(
+	struct dc_bios *dcb,
 	uint32_t i)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct graphics_object_id object_id = dal_graphics_object_id_init(
 		0, ENUM_ID_UNKNOWN, OBJECT_TYPE_UNKNOWN);
 
@@ -317,10 +249,11 @@ struct graphics_object_id dal_bios_parser_get_encoder_id(struct bios_parser *bp,
 	return object_id;
 }
 
-struct graphics_object_id dal_bios_parser_get_connector_id(
-	struct bios_parser *bp,
+static struct graphics_object_id bios_parser_get_connector_id(
+	struct dc_bios *dcb,
 	uint8_t i)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct graphics_object_id object_id = dal_graphics_object_id_init(
 		0, ENUM_ID_UNKNOWN, OBJECT_TYPE_UNKNOWN);
 
@@ -339,12 +272,13 @@ struct graphics_object_id dal_bios_parser_get_connector_id(
 	return object_id;
 }
 
-uint32_t dal_bios_parser_get_src_number(struct bios_parser *bp,
+static uint32_t bios_parser_get_src_number(struct dc_bios *dcb,
 	struct graphics_object_id id)
 {
 	uint32_t offset;
 	uint8_t *number;
 	ATOM_OBJECT *object;
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	object = get_bios_object(bp, id);
 
@@ -363,21 +297,23 @@ uint32_t dal_bios_parser_get_src_number(struct bios_parser *bp,
 	return *number;
 }
 
-uint32_t dal_bios_parser_get_dst_number(struct bios_parser *bp,
+static uint32_t bios_parser_get_dst_number(struct dc_bios *dcb,
 	struct graphics_object_id id)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object = get_bios_object(bp, id);
 
 	return get_dst_number_from_object(bp, object);
 }
 
-enum bp_result dal_bios_parser_get_src_obj(struct bios_parser *bp,
+static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
 	struct graphics_object_id object_id, uint32_t index,
 	struct graphics_object_id *src_object_id)
 {
 	uint32_t number;
 	uint16_t *id;
 	ATOM_OBJECT *object;
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!src_object_id)
 		return BP_RESULT_BADINPUT;
@@ -399,13 +335,14 @@ enum bp_result dal_bios_parser_get_src_obj(struct bios_parser *bp,
 	return BP_RESULT_OK;
 }
 
-enum bp_result dal_bios_parser_get_dst_obj(struct bios_parser *bp,
+static enum bp_result bios_parser_get_dst_obj(struct dc_bios *dcb,
 	struct graphics_object_id object_id, uint32_t index,
 	struct graphics_object_id *dest_object_id)
 {
 	uint32_t number;
 	uint16_t *id;
 	ATOM_OBJECT *object;
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!dest_object_id)
 		return BP_RESULT_BADINPUT;
@@ -422,10 +359,11 @@ enum bp_result dal_bios_parser_get_dst_obj(struct bios_parser *bp,
 	return BP_RESULT_OK;
 }
 
-enum bp_result dal_bios_parser_get_oem_ddc_info(struct bios_parser *bp,
+static enum bp_result bios_parser_get_oem_ddc_info(struct dc_bios *dcb,
 	uint32_t index,
 	struct graphics_object_i2c_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!info)
 		return BP_RESULT_BADINPUT;
@@ -458,7 +396,7 @@ enum bp_result dal_bios_parser_get_oem_ddc_info(struct bios_parser *bp,
 	return BP_RESULT_NORECORD;
 }
 
-enum bp_result dal_bios_parser_get_i2c_info(struct bios_parser *bp,
+static enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,
 	struct graphics_object_id id,
 	struct graphics_object_i2c_info *info)
 {
@@ -466,6 +404,7 @@ enum bp_result dal_bios_parser_get_i2c_info(struct bios_parser *bp,
 	ATOM_OBJECT *object;
 	ATOM_COMMON_RECORD_HEADER *header;
 	ATOM_I2C_RECORD *record;
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!info)
 		return BP_RESULT_BADINPUT;
@@ -563,7 +502,28 @@ static enum bp_result get_voltage_ddc_info_v3(uint8_t *i2c_line,
 	return result;
 }
 
-enum bp_result dal_bios_parser_get_voltage_ddc_info(struct bios_parser *bp,
+static enum bp_result bios_parser_get_thermal_ddc_info(
+	struct dc_bios *dcb,
+	uint32_t i2c_channel_id,
+	struct graphics_object_i2c_info *info)
+{
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+	ATOM_I2C_ID_CONFIG_ACCESS *config;
+	ATOM_I2C_RECORD record;
+
+	if (!info)
+		return BP_RESULT_BADINPUT;
+
+	config = (ATOM_I2C_ID_CONFIG_ACCESS *) &i2c_channel_id;
+
+	record.sucI2cId.bfHW_Capable = config->sbfAccess.bfHW_Capable;
+	record.sucI2cId.bfI2C_LineMux = config->sbfAccess.bfI2C_LineMux;
+	record.sucI2cId.bfHW_EngineID = config->sbfAccess.bfHW_EngineID;
+
+	return get_gpio_i2c_info(bp, &record, info);
+}
+
+static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
 	uint32_t index,
 	struct graphics_object_i2c_info *info)
 {
@@ -572,6 +532,7 @@ enum bp_result dal_bios_parser_get_voltage_ddc_info(struct bios_parser *bp,
 	uint8_t *voltage_info_address;
 	ATOM_COMMON_TABLE_HEADER *header;
 	struct atom_data_revision revision = {0};
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!DATA_TABLES(VoltageObjectInfo))
 		return result;
@@ -599,34 +560,14 @@ enum bp_result dal_bios_parser_get_voltage_ddc_info(struct bios_parser *bp,
 	}
 
 	if (result == BP_RESULT_OK)
-		result = dal_bios_parser_get_thermal_ddc_info(bp,
+		result = bios_parser_get_thermal_ddc_info(dcb,
 			i2c_line, info);
 
 
 	return result;
 }
 
-enum bp_result dal_bios_parser_get_thermal_ddc_info(
-	struct bios_parser *bp,
-	uint32_t i2c_channel_id,
-	struct graphics_object_i2c_info *info)
-{
-	ATOM_I2C_ID_CONFIG_ACCESS *config;
-	ATOM_I2C_RECORD record;
-
-	if (!info)
-		return BP_RESULT_BADINPUT;
-
-	config = (ATOM_I2C_ID_CONFIG_ACCESS *) &i2c_channel_id;
-
-	record.sucI2cId.bfHW_Capable = config->sbfAccess.bfHW_Capable;
-	record.sucI2cId.bfI2C_LineMux = config->sbfAccess.bfI2C_LineMux;
-	record.sucI2cId.bfHW_EngineID = config->sbfAccess.bfHW_EngineID;
-
-	return get_gpio_i2c_info(bp, &record, info);
-}
-
-enum bp_result dal_bios_parser_get_ddc_info_for_i2c_line(struct bios_parser *bp,
+enum bp_result bios_parser_get_ddc_info_for_i2c_line(struct bios_parser *bp,
 	uint8_t i2c_line, struct graphics_object_i2c_info *info)
 {
 	uint32_t offset;
@@ -690,10 +631,11 @@ enum bp_result dal_bios_parser_get_ddc_info_for_i2c_line(struct bios_parser *bp,
 	return BP_RESULT_NORECORD;
 }
 
-enum bp_result dal_bios_parser_get_hpd_info(struct bios_parser *bp,
+static enum bp_result bios_parser_get_hpd_info(struct dc_bios *dcb,
 	struct graphics_object_id id,
 	struct graphics_object_hpd_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
 	ATOM_HPD_INT_RECORD *record = NULL;
 
@@ -716,12 +658,13 @@ enum bp_result dal_bios_parser_get_hpd_info(struct bios_parser *bp,
 	return BP_RESULT_NORECORD;
 }
 
-uint32_t dal_bios_parser_get_gpio_record(
-	struct bios_parser *bp,
+static uint32_t bios_parser_get_gpio_record(
+	struct dc_bios *dcb,
 	struct graphics_object_id id,
 	struct bp_gpio_cntl_info *gpio_record,
 	uint32_t record_size)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_COMMON_RECORD_HEADER *header = NULL;
 	ATOM_OBJECT_GPIO_CNTL_RECORD *record = NULL;
 	ATOM_OBJECT *object = get_bios_object(bp, id);
@@ -789,7 +732,7 @@ uint32_t dal_bios_parser_get_gpio_record(
 	return pins_number;
 }
 
-enum bp_result dal_bios_parser_get_device_tag_record(
+enum bp_result bios_parser_get_device_tag_record(
 	struct bios_parser *bp,
 	ATOM_OBJECT *object,
 	ATOM_CONNECTOR_DEVICE_TAG_RECORD **record)
@@ -826,12 +769,13 @@ enum bp_result dal_bios_parser_get_device_tag_record(
 	return BP_RESULT_NORECORD;
 }
 
-enum bp_result dal_bios_parser_get_device_tag(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_device_tag(
+	struct dc_bios *dcb,
 	struct graphics_object_id connector_object_id,
 	uint32_t device_tag_index,
 	struct connector_device_tag_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
 	ATOM_CONNECTOR_DEVICE_TAG_RECORD *record = NULL;
 	ATOM_CONNECTOR_DEVICE_TAG *device_tag;
@@ -847,7 +791,7 @@ enum bp_result dal_bios_parser_get_device_tag(
 		return BP_RESULT_BADINPUT;
 	}
 
-	if (dal_bios_parser_get_device_tag_record(bp, object, &record)
+	if (bios_parser_get_device_tag_record(bp, object, &record)
 		!= BP_RESULT_OK)
 		return BP_RESULT_NORECORD;
 
@@ -873,10 +817,11 @@ static enum bp_result get_firmware_info_v2_2(
 	struct bios_parser *bp,
 	struct firmware_info *info);
 
-enum bp_result dal_bios_parser_get_firmware_info(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_firmware_info(
+	struct dc_bios *dcb,
 	struct firmware_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	enum bp_result result = BP_RESULT_BADBIOSTABLE;
 	ATOM_COMMON_TABLE_HEADER *header;
 	struct atom_data_revision revision;
@@ -1223,61 +1168,73 @@ static enum bp_result get_ss_info_v3_1(
 	return BP_RESULT_NORECORD;
 }
 
-enum bp_result dal_bios_parser_transmitter_control(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_transmitter_control(
+	struct dc_bios *dcb,
 	struct bp_transmitter_control *cntl)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.transmitter_control)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.transmitter_control(bp, cntl);
 }
 
-enum bp_result dal_bios_parser_encoder_control(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_encoder_control(
+	struct dc_bios *dcb,
 	struct bp_encoder_control *cntl)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.dig_encoder_control)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.dig_encoder_control(bp, cntl);
 }
 
-enum bp_result dal_bios_parser_adjust_pixel_clock(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_adjust_pixel_clock(
+	struct dc_bios *dcb,
 	struct bp_adjust_pixel_clock_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.adjust_display_pll)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.adjust_display_pll(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_set_pixel_clock(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_set_pixel_clock(
+	struct dc_bios *dcb,
 	struct bp_pixel_clock_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.set_pixel_clock)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.set_pixel_clock(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_set_dce_clock(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_set_dce_clock(
+	struct dc_bios *dcb,
 	struct bp_set_dce_clock_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.set_dce_clock)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.set_dce_clock(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_enable_spread_spectrum_on_ppll(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_enable_spread_spectrum_on_ppll(
+	struct dc_bios *dcb,
 	struct bp_spread_spectrum_parameters *bp_params,
 	bool enable)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.enable_spread_spectrum_on_ppll)
 		return BP_RESULT_FAILURE;
 
@@ -1286,20 +1243,23 @@ enum bp_result dal_bios_parser_enable_spread_spectrum_on_ppll(
 
 }
 
-enum bp_result dal_bios_parser_program_crtc_timing(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_program_crtc_timing(
+	struct dc_bios *dcb,
 	struct bp_hw_crtc_timing_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.set_crtc_timing)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.set_crtc_timing(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_program_display_engine_pll(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_program_display_engine_pll(
+	struct dc_bios *dcb,
 	struct bp_pixel_clock_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!bp->cmd_tbl.program_clock)
 		return BP_RESULT_FAILURE;
@@ -1308,12 +1268,14 @@ enum bp_result dal_bios_parser_program_display_engine_pll(
 
 }
 
-enum signal_type dal_bios_parser_dac_load_detect(
-	struct bios_parser *bp,
+static enum signal_type bios_parser_dac_load_detect(
+	struct dc_bios *dcb,
 	struct graphics_object_id encoder,
 	struct graphics_object_id connector,
 	enum signal_type display_signal)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.dac_load_detection)
 		return SIGNAL_TYPE_NONE;
 
@@ -1321,62 +1283,73 @@ enum signal_type dal_bios_parser_dac_load_detect(
 		display_signal);
 }
 
-enum bp_result dal_bios_parser_get_divider_for_target_display_clock(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_divider_for_target_display_clock(
+	struct dc_bios *dcb,
 	struct bp_display_clock_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.compute_memore_engine_pll)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.compute_memore_engine_pll(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_dvo_encoder_control(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_dvo_encoder_control(
+	struct dc_bios *dcb,
 	struct bp_dvo_encoder_control *cntl)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.dvo_encoder_control)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.dvo_encoder_control(bp, cntl);
 }
 
-enum bp_result dal_bios_parser_enable_crtc(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_enable_crtc(
+	struct dc_bios *dcb,
 	enum controller_id id,
 	bool enable)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.enable_crtc)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.enable_crtc(bp, id, enable);
 }
 
-enum bp_result dal_bios_parser_blank_crtc(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_blank_crtc(
+	struct dc_bios *dcb,
 	struct bp_blank_crtc_parameters *bp_params,
 	bool blank)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.blank_crtc)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.blank_crtc(bp, bp_params, blank);
 }
 
-enum bp_result dal_bios_parser_crtc_source_select(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_crtc_source_select(
+	struct dc_bios *dcb,
 	struct bp_crtc_source_select *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.select_crtc_source)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.select_crtc_source(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_set_overscan(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_set_overscan(
+	struct dc_bios *dcb,
 	struct bp_hw_crtc_overscan_parameters *bp_params)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	if (!bp->cmd_tbl.set_crtc_overscan)
 		return BP_RESULT_FAILURE;
@@ -1384,32 +1357,38 @@ enum bp_result dal_bios_parser_set_overscan(
 	return bp->cmd_tbl.set_crtc_overscan(bp, bp_params);
 }
 
-enum bp_result dal_bios_parser_enable_memory_requests(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_enable_memory_requests(
+	struct dc_bios *dcb,
 	enum controller_id controller_id,
 	bool enable)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.enable_crtc_mem_req)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.enable_crtc_mem_req(bp, controller_id, enable);
 }
 
-enum bp_result dal_bios_parser_external_encoder_control(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_external_encoder_control(
+	struct dc_bios *dcb,
 	struct bp_external_encoder_control *cntl)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.external_encoder_control)
 		return BP_RESULT_FAILURE;
 
 	return bp->cmd_tbl.external_encoder_control(bp, cntl);
 }
 
-enum bp_result dal_bios_parser_enable_disp_power_gating(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_enable_disp_power_gating(
+	struct dc_bios *dcb,
 	enum controller_id controller_id,
 	enum bp_pipe_control_action action)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (!bp->cmd_tbl.enable_disp_power_gating)
 		return BP_RESULT_FAILURE;
 
@@ -1417,21 +1396,24 @@ enum bp_result dal_bios_parser_enable_disp_power_gating(
 		action);
 }
 
-bool dal_bios_parser_is_device_id_supported(
-	struct bios_parser *bp,
+static bool bios_parser_is_device_id_supported(
+	struct dc_bios *dcb,
 	struct device_id id)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	uint32_t mask = get_support_mask_for_device_id(id);
 
 	return (le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport) & mask) != 0;
 }
 
-enum bp_result dal_bios_parser_crt_control(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_crt_control(
+	struct dc_bios *dcb,
 	enum engine_id engine_id,
 	bool enable,
 	uint32_t pixel_clock)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	uint8_t standard;
 
 	if (!bp->cmd_tbl.dac1_encoder_control &&
@@ -1568,7 +1550,7 @@ static enum bp_result get_ss_info_from_tbl(
 	uint32_t id,
 	struct spread_spectrum_info *ss_info);
 /**
- * dal_bios_parser_get_spread_spectrum_info
+ * bios_parser_get_spread_spectrum_info
  * Get spread spectrum information from the ASIC_InternalSS_Info(ver 2.1 or
  * ver 3.1) or SS_Info table from the VBIOS. Currently ASIC_InternalSS_Info
  * ver 2.1 can co-exist with SS_Info table. Expect ASIC_InternalSS_Info ver 3.1,
@@ -1580,12 +1562,13 @@ static enum bp_result get_ss_info_from_tbl(
  * @param [out] ss_info, sprectrum information structure,
  * @return Bios parser result code
  */
-enum bp_result dal_bios_parser_get_spread_spectrum_info(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_spread_spectrum_info(
+	struct dc_bios *dcb,
 	enum as_signal_type signal,
 	uint32_t index,
 	struct spread_spectrum_info *ss_info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	enum bp_result result = BP_RESULT_UNSUPPORTED;
 	uint32_t clk_id_ss = 0;
 	ATOM_COMMON_TABLE_HEADER *header;
@@ -1777,7 +1760,7 @@ static enum bp_result get_ss_info_from_ss_info_table(
 	{
 		struct embedded_panel_info panel_info;
 
-		if (dal_bios_parser_get_embedded_panel_info(bp, &panel_info)
+		if (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)
 				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
@@ -1833,10 +1816,11 @@ static enum bp_result get_embedded_panel_info_v1_3(
 	struct bios_parser *bp,
 	struct embedded_panel_info *info);
 
-enum bp_result dal_bios_parser_get_embedded_panel_info(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_embedded_panel_info(
+	struct dc_bios *dcb,
 	struct embedded_panel_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_COMMON_TABLE_HEADER *hdr;
 
 	if (!DATA_TABLES(LCD_Info))
@@ -2111,7 +2095,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 }
 
 /**
- * dal_bios_parser_get_encoder_cap_info
+ * bios_parser_get_encoder_cap_info
  *
  * @brief
  *  Get encoder capability information of input object id
@@ -2122,11 +2106,12 @@ static enum bp_result get_embedded_panel_info_v1_3(
  * @return Bios parser result code
  *
  */
-enum bp_result dal_bios_parser_get_encoder_cap_info(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_encoder_cap_info(
+	struct dc_bios *dcb,
 	struct graphics_object_id object_id,
 	struct bp_encoder_cap_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
 	ATOM_ENCODER_CAP_RECORD *record = NULL;
 
@@ -2198,7 +2183,7 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 }
 
 /**
- * dal_bios_parser_get_din_connector_info
+ * bios_parser_get_din_connector_info
  * @brief
  *   Get GPIO record for the DIN connector, this GPIO tells whether there is a
  *    CV dumb dongle
@@ -2209,11 +2194,12 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
  * @param info             - GPIO record infor
  * @return Bios parser result code
  */
-enum bp_result dal_bios_parser_get_din_connector_info(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_din_connector_info(
+	struct dc_bios *dcb,
 	struct graphics_object_id id,
 	struct din_connector_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_COMMON_RECORD_HEADER *header;
 	ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD *record = NULL;
 	ATOM_OBJECT *object;
@@ -2294,10 +2280,11 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
  * @param[in] signal, ASSignalType to be converted to SSid
  * @return number of SS Entry that match the signal
  */
-uint32_t dal_bios_parser_get_ss_entry_number(
-	struct bios_parser *bp,
+static uint32_t bios_parser_get_ss_entry_number(
+	struct dc_bios *dcb,
 	enum as_signal_type signal)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	uint32_t ss_id = 0;
 	ATOM_COMMON_TABLE_HEADER *header;
 	struct atom_data_revision revision;
@@ -2381,7 +2368,7 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 	case ASIC_INTERNAL_SS_ON_LVDS: {
 		struct embedded_panel_info panel_info;
 
-		if (dal_bios_parser_get_embedded_panel_info(bp, &panel_info)
+		if (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)
 				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
@@ -2544,10 +2531,11 @@ static ATOM_FAKE_EDID_PATCH_RECORD *get_faked_edid_record(
 	return (ATOM_FAKE_EDID_PATCH_RECORD *)record;
 }
 
-enum bp_result dal_bios_parser_get_faked_edid_len(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_faked_edid_len(
+	struct dc_bios *dcb,
 	uint32_t *len)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_FAKE_EDID_PATCH_RECORD *edid_record = get_faked_edid_record(bp);
 
 	if (!edid_record)
@@ -2558,11 +2546,12 @@ enum bp_result dal_bios_parser_get_faked_edid_len(
 	return BP_RESULT_OK;
 }
 
-enum bp_result dal_bios_parser_get_faked_edid_buf(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_faked_edid_buf(
+	struct dc_bios *dcb,
 	uint8_t *buff,
 	uint32_t len)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_FAKE_EDID_PATCH_RECORD *edid_record = get_faked_edid_record(bp);
 	uint32_t edid_size;
 
@@ -2580,7 +2569,7 @@ enum bp_result dal_bios_parser_get_faked_edid_buf(
 }
 
 /**
- * dal_bios_parser_get_gpio_pin_info
+ * bios_parser_get_gpio_pin_info
  * Get GpioPin information of input gpio id
  *
  * @param gpio_id, GPIO ID
@@ -2592,11 +2581,12 @@ enum bp_result dal_bios_parser_get_faked_edid_buf(
  *  2. in DATA_TABLE.GPIO_Pin_LUT, search all records, to get the registerA
  *  offset/mask
  */
-enum bp_result dal_bios_parser_get_gpio_pin_info(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_get_gpio_pin_info(
+	struct dc_bios *dcb,
 	uint32_t gpio_id,
 	struct gpio_pin_info *info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_GPIO_PIN_LUT *header;
 	uint32_t count = 0;
 	uint32_t i = 0;
@@ -2648,11 +2638,12 @@ enum bp_result dal_bios_parser_get_gpio_pin_info(
  * @param info, embedded panel patch mode structure
  * @return Bios parser result code
  */
-enum bp_result dal_bios_parser_enum_embedded_panel_patch_mode(
-	struct bios_parser *bp,
+static enum bp_result bios_parser_enum_embedded_panel_patch_mode(
+	struct dc_bios *dcb,
 	uint32_t index,
 	struct embedded_panel_patch_mode *mode)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	uint32_t record_size;
 	uint32_t record_index;
 	uint8_t *record;
@@ -3711,7 +3702,7 @@ static void add_device_tag_from_ext_display_path(
 	ATOM_CONNECTOR_DEVICE_TAG *device_tag = NULL;
 	ATOM_CONNECTOR_DEVICE_TAG_RECORD *device_tag_record = NULL;
 	enum bp_result result =
-			dal_bios_parser_get_device_tag_record(
+			bios_parser_get_device_tag_record(
 					bp, object, &device_tag_record);
 
 	if ((le16_to_cpu(ext_display_path->usDeviceTag) != CONNECTOR_OBJECT_ID_NONE)
@@ -3958,7 +3949,7 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 				continue;
 
 			/* Remove support for all device tags. */
-			if (dal_bios_parser_get_device_tag_record(
+			if (bios_parser_get_device_tag_record(
 					bp, object, &dev_tag_record) != BP_RESULT_OK)
 				continue;
 
@@ -4212,14 +4203,18 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 	}
 }
 
-void dal_bios_parser_post_init(struct bios_parser *bp)
+static void bios_parser_post_init(struct dc_bios *dcb)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	process_ext_display_connection_info(bp);
 }
 
-bool dal_bios_parser_is_accelerated_mode(
-	struct bios_parser *bp)
+static bool bios_parser_is_accelerated_mode(
+	struct dc_bios *dcb)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	return bp->bios_helper->is_accelerated_mode(
 			bp->ctx);
@@ -4233,7 +4228,7 @@ bool dal_bios_parser_is_accelerated_mode(
 }
 
 /**
- * dal_bios_parser_set_scratch_connected
+ * bios_parser_set_scratch_connected
  *
  * @brief
  *  update VBIOS scratch register about connected displays
@@ -4243,12 +4238,14 @@ bool dal_bios_parser_is_accelerated_mode(
  *  bool - connection state
  *  const ConnectorDeviceTagInfo* - pointer to device type and enum ID
  */
-void dal_bios_parser_set_scratch_connected(
-	struct bios_parser *bp,
+static void bios_parser_set_scratch_connected(
+	struct dc_bios *dcb,
 	struct graphics_object_id connector_id,
 	bool connected,
 	const struct connector_device_tag_info *device_tag)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_connected(
 			bp->ctx,
@@ -4262,7 +4259,7 @@ void dal_bios_parser_set_scratch_connected(
 }
 
 /**
- * dal_bios_parser_set_scratch_critical_state
+ * bios_parser_set_scratch_critical_state
  *
  * @brief
  *  update critical state bit in VBIOS scratch register
@@ -4270,10 +4267,12 @@ void dal_bios_parser_set_scratch_connected(
  * @param
  *  bool - to set or reset state
  */
-void dal_bios_parser_set_scratch_critical_state(
-	struct bios_parser *bp,
+static void bios_parser_set_scratch_critical_state(
+	struct dc_bios *dcb,
 	bool state)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_critical_state(
 			bp->ctx, state);
@@ -4285,9 +4284,11 @@ void dal_bios_parser_set_scratch_critical_state(
 #endif
 }
 
-void dal_bios_parser_set_scratch_acc_mode_change(
-	struct bios_parser *bp)
+static void bios_parser_set_scratch_acc_mode_change(
+	struct dc_bios *dcb)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_acc_mode_change(
 			bp->ctx);
@@ -4300,7 +4301,7 @@ void dal_bios_parser_set_scratch_acc_mode_change(
 }
 
 /**
- * dal_bios_parser_prepare_scratch_active_and_requested
+ * bios_parser_prepare_scratch_active_and_requested
  *
  * @brief
  *  update VBIOS scratch registers about active and requested displays
@@ -4311,12 +4312,14 @@ void dal_bios_parser_set_scratch_acc_mode_change(
  *  const struct connector_device_tag_info * - pointer to display type and
  *  enum Id
  */
-void dal_bios_parser_prepare_scratch_active_and_requested(
-	struct bios_parser *bp,
+static void bios_parser_prepare_scratch_active_and_requested(
+	struct dc_bios *dcb,
 	enum controller_id controller_id,
 	enum signal_type signal,
 	const struct connector_device_tag_info *device_tag)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->prepare_scratch_active_and_requested(
 			bp->ctx,
@@ -4332,9 +4335,11 @@ void dal_bios_parser_prepare_scratch_active_and_requested(
 #endif
 }
 
-void dal_bios_parser_set_scratch_active_and_requested(
-	struct bios_parser *bp)
+static void bios_parser_set_scratch_active_and_requested(
+	struct dc_bios *dcb)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_active_and_requested(
 			bp->ctx,
@@ -4726,21 +4731,11 @@ static enum bp_result construct_integrated_info(
 	return result;
 }
 
-/*
- * dal_bios_parser_create_integrated_info
- *
- * @brief
- * Create integrated info
- *
- * @param
- * bios_parser *bp - [in] BIOS  parser handler
- *
- * @return
- * struct integrated_info * - pointer to the newly created integrated info
- */
-struct integrated_info *dal_bios_parser_create_integrated_info(
-	struct bios_parser *bp)
+
+static struct integrated_info *bios_parser_create_integrated_info(
+	struct dc_bios *dcb)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct integrated_info *info = NULL;
 
 	info = dc_service_alloc(bp->ctx, sizeof(struct integrated_info));
@@ -4758,24 +4753,344 @@ struct integrated_info *dal_bios_parser_create_integrated_info(
 	return NULL;
 }
 
-/*
- * dal_bios_parser_destroy_integrated_info
- *
- * @brief
- * Destroy provided integrated info
- *
- * @param
- * struct integrated_info **info - [in] info to be destroied
- */
-void dal_bios_parser_destroy_integrated_info(struct dc_context *ctx, struct integrated_info **info)
+static void bios_parser_destroy_integrated_info(
+	struct dc_bios *dcb,
+	struct integrated_info **info)
 {
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
+
 	if (info == NULL) {
 		ASSERT_CRITICAL(0);
 		return;
 	}
 
 	if (*info != NULL) {
-		dc_service_free(ctx, *info);
+		dc_service_free(bp->ctx, *info);
 		*info = NULL;
 	}
 }
+
+/******************************************************************************
+ * Stub-functions */
+static bool is_lid_open(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return false;
+}
+
+static bool is_lid_status_changed(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return false;
+}
+
+static bool is_display_config_changed(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return false;
+}
+
+static void set_scratch_lcd_scale(
+	struct dc_bios *bios,
+	enum lcd_scale scale)
+{
+	BREAK_TO_DEBUGGER();
+}
+
+static enum lcd_scale get_scratch_lcd_scale(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return LCD_SCALE_NONE;
+}
+
+static void get_bios_event_info(
+	struct dc_bios *bios,
+	struct bios_event_info *info)
+{
+	BREAK_TO_DEBUGGER();
+}
+
+static void update_requested_backlight_level(
+	struct dc_bios *bios,
+	uint32_t backlight_8bit)
+{
+	BREAK_TO_DEBUGGER();
+}
+
+static uint32_t get_requested_backlight_level(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return 0;
+}
+
+static void take_backlight_control(
+	struct dc_bios *bios,
+	bool cntl)
+{
+	BREAK_TO_DEBUGGER();
+}
+
+static bool is_active_display(
+	struct dc_bios *bios,
+	enum signal_type signal,
+	const struct connector_device_tag_info *device_tag)
+{
+	BREAK_TO_DEBUGGER();
+	return false;
+}
+
+static enum controller_id get_embedded_display_controller_id(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return CONTROLLER_ID_UNDEFINED;
+}
+
+static uint32_t get_embedded_display_refresh_rate(
+	struct dc_bios *bios)
+{
+	BREAK_TO_DEBUGGER();
+	return 0;
+}
+
+/******************************************************************************/
+
+static const struct dc_vbios_funcs vbios_funcs = {
+	.get_connectors_number = bios_parser_get_connectors_number,
+
+	.power_down = bios_parser_power_down,
+
+	.power_up = bios_parser_power_up,
+
+	.get_encoders_number = bios_parser_get_encoders_number,
+
+	.get_oem_ddc_lines_number = bios_parser_get_oem_ddc_lines_number,
+
+	.get_encoder_id = bios_parser_get_encoder_id,
+
+	.get_connector_id = bios_parser_get_connector_id,
+
+	.get_src_number = bios_parser_get_src_number,
+
+	.get_dst_number = bios_parser_get_dst_number,
+
+	.get_gpio_record = bios_parser_get_gpio_record,
+
+	.get_src_obj = bios_parser_get_src_obj,
+
+	.get_dst_obj = bios_parser_get_dst_obj,
+
+	.get_i2c_info = bios_parser_get_i2c_info,
+
+	.get_oem_ddc_info = bios_parser_get_oem_ddc_info,
+
+	.get_voltage_ddc_info = bios_parser_get_voltage_ddc_info,
+
+	.get_thermal_ddc_info = bios_parser_get_thermal_ddc_info,
+
+	.get_hpd_info = bios_parser_get_hpd_info,
+
+	.get_device_tag = bios_parser_get_device_tag,
+
+	.get_firmware_info = bios_parser_get_firmware_info,
+
+	.get_spread_spectrum_info = bios_parser_get_spread_spectrum_info,
+
+	.get_ss_entry_number = bios_parser_get_ss_entry_number,
+
+	.get_embedded_panel_info = bios_parser_get_embedded_panel_info,
+
+	.enum_embedded_panel_patch_mode = bios_parser_enum_embedded_panel_patch_mode,
+
+	.get_gpio_pin_info = bios_parser_get_gpio_pin_info,
+
+	.get_embedded_panel_info = bios_parser_get_embedded_panel_info,
+
+	.get_gpio_pin_info = bios_parser_get_gpio_pin_info,
+
+	.get_faked_edid_len = bios_parser_get_faked_edid_len,
+
+	.get_faked_edid_buf = bios_parser_get_faked_edid_buf,
+
+	.get_encoder_cap_info = bios_parser_get_encoder_cap_info,
+
+	.get_din_connector_info = bios_parser_get_din_connector_info,
+
+	.is_lid_open = is_lid_open,
+
+	.is_lid_status_changed = is_lid_status_changed,
+
+	.is_display_config_changed = is_display_config_changed,
+
+	.is_accelerated_mode = bios_parser_is_accelerated_mode,
+
+	.set_scratch_lcd_scale = set_scratch_lcd_scale,
+
+	.get_scratch_lcd_scale = get_scratch_lcd_scale,
+
+	.get_bios_event_info = get_bios_event_info,
+
+	.update_requested_backlight_level = update_requested_backlight_level,
+
+	.get_requested_backlight_level = get_requested_backlight_level,
+
+	.take_backlight_control = take_backlight_control,
+
+	.is_active_display = is_active_display,
+
+	.get_embedded_display_controller_id = get_embedded_display_controller_id,
+
+	.get_embedded_display_refresh_rate = get_embedded_display_refresh_rate,
+
+	.set_scratch_connected = bios_parser_set_scratch_connected,
+
+	.prepare_scratch_active_and_requested = bios_parser_prepare_scratch_active_and_requested,
+
+	.set_scratch_active_and_requested = bios_parser_set_scratch_active_and_requested,
+
+	.set_scratch_critical_state = bios_parser_set_scratch_critical_state,
+
+	.set_scratch_acc_mode_change = bios_parser_set_scratch_acc_mode_change,
+
+	.is_device_id_supported = bios_parser_is_device_id_supported,
+
+	/* COMMANDS */
+	.encoder_control = bios_parser_encoder_control,
+
+	.transmitter_control = bios_parser_transmitter_control,
+
+	.crt_control = bios_parser_crt_control,
+
+	.dvo_encoder_control = bios_parser_dvo_encoder_control,
+
+	.enable_crtc = bios_parser_enable_crtc,
+
+	.adjust_pixel_clock = bios_parser_adjust_pixel_clock,
+
+	.set_pixel_clock = bios_parser_set_pixel_clock,
+
+	.set_dce_clock = bios_parser_set_dce_clock,
+
+	.enable_spread_spectrum_on_ppll = bios_parser_enable_spread_spectrum_on_ppll,
+
+	.program_crtc_timing = bios_parser_program_crtc_timing,
+
+	.blank_crtc = bios_parser_blank_crtc,
+
+	.set_overscan = bios_parser_set_overscan,
+
+	.crtc_source_select = bios_parser_crtc_source_select,
+
+	.program_display_engine_pll = bios_parser_program_display_engine_pll,
+
+	.get_divider_for_target_display_clock = bios_parser_get_divider_for_target_display_clock,
+
+	.dac_load_detect = bios_parser_dac_load_detect,
+
+	.enable_memory_requests = bios_parser_enable_memory_requests,
+
+	.external_encoder_control = bios_parser_external_encoder_control,
+
+	.enable_disp_power_gating = bios_parser_enable_disp_power_gating,
+
+	.post_init = bios_parser_post_init,
+
+	.create_integrated_info = bios_parser_create_integrated_info,
+
+	.destroy_integrated_info = bios_parser_destroy_integrated_info,
+};
+
+static bool bios_parser_construct(
+	struct bios_parser *bp,
+	struct bp_init_data *init,
+	struct adapter_service *as)
+{
+	uint16_t *rom_header_offset = NULL;
+	ATOM_ROM_HEADER *rom_header = NULL;
+	ATOM_OBJECT_HEADER *object_info_tbl;
+	enum dce_version dce_version;
+
+	if (!as)
+		return false;
+
+	if (!init)
+		return false;
+
+	if (!init->bios)
+		return false;
+
+	bp->base.funcs = &vbios_funcs;
+
+	dce_version = dal_adapter_service_get_dce_version(as);
+	bp->ctx = init->ctx;
+	bp->as = as;
+	bp->bios = init->bios;
+	bp->bios_size = bp->bios[BIOS_IMAGE_SIZE_OFFSET] * BIOS_IMAGE_SIZE_UNIT;
+	bp->bios_local_image = NULL;
+	bp->lcd_scale = LCD_SCALE_UNKNOWN;
+
+	rom_header_offset =
+	GET_IMAGE(uint16_t, OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER);
+
+	if (!rom_header_offset)
+		return false;
+
+	rom_header = GET_IMAGE(ATOM_ROM_HEADER, *rom_header_offset);
+
+	if (!rom_header)
+		return false;
+
+	bp->master_data_tbl =
+	GET_IMAGE(ATOM_MASTER_DATA_TABLE,
+		rom_header->usMasterDataTableOffset);
+
+	if (!bp->master_data_tbl)
+		return false;
+
+	bp->object_info_tbl_offset = DATA_TABLES(Object_Header);
+
+	if (!bp->object_info_tbl_offset)
+		return false;
+
+	object_info_tbl =
+	GET_IMAGE(ATOM_OBJECT_HEADER, bp->object_info_tbl_offset);
+
+	if (!object_info_tbl)
+		return false;
+
+	get_atom_data_table_revision(&object_info_tbl->sHeader,
+		&bp->object_info_tbl.revision);
+
+	if (bp->object_info_tbl.revision.major == 1
+		&& bp->object_info_tbl.revision.minor >= 3) {
+		ATOM_OBJECT_HEADER_V3 *tbl_v3;
+
+		tbl_v3 = GET_IMAGE(ATOM_OBJECT_HEADER_V3,
+			bp->object_info_tbl_offset);
+		if (!tbl_v3)
+			return false;
+
+		bp->object_info_tbl.v1_3 = tbl_v3;
+	} else if (bp->object_info_tbl.revision.major == 1
+		&& bp->object_info_tbl.revision.minor >= 1)
+		bp->object_info_tbl.v1_1 = object_info_tbl;
+	else
+		return false;
+
+#if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
+	bp->vbios_helper_data.active = 0;
+	bp->vbios_helper_data.requested = 0;
+	dal_bios_parser_init_bios_helper(bp, dce_version);
+#endif
+	dal_bios_parser_init_cmd_tbl(bp);
+	dal_bios_parser_init_cmd_tbl_helper(&bp->cmd_helper, dce_version);
+
+	return true;
+}
+
+/******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c
index 0089800..a0927cf 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c
@@ -28,7 +28,6 @@
 #include "atom.h"
 
 #include "include/bios_parser_types.h"
-#include "include/adapter_service_types.h"
 #include "bios_parser_helper.h"
 #include "command_table_helper.h"
 #include "command_table.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 00a2453..841e02e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -143,7 +143,7 @@ failed_alloc:
 static void init_hw(struct dc *dc)
 {
 	int i;
-	struct bios_parser *bp;
+	struct dc_bios *bp;
 	struct transform *xfm;
 
 	bp = dal_adapter_service_get_bios_parser(dc->res_pool.adapter_srv);
@@ -164,7 +164,7 @@ static void init_hw(struct dc *dc)
 	}
 
 	dc->hwss.clock_gating_power_up(dc->ctx, false);
-	dal_bios_parser_power_up(bp);
+	bp->funcs->power_up(bp);
 	/***************************************/
 
 	for (i = 0; i < dc->link_count; i++) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index f86ddb0..341c968 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -27,9 +27,8 @@
 #define DC_INTERFACE_H_
 
 #include "dc_types.h"
-/* TODO: We should not include audio_interface.h here. Maybe just define
- * struct audio_info here */
-#include "audio_interface.h"
+#include "dal_types.h"
+#include "audio_types.h"
 #include "logger_types.h"
 
 #define MAX_SINKS_PER_LINK 4
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h b/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
index a82cbee..0f85f63 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
@@ -26,15 +26,255 @@
 #ifndef DC_BIOS_TYPES_H
 #define DC_BIOS_TYPES_H
 
-struct dc_vbios_funcs;
+/******************************************************************************
+ * Interface file for VBIOS implementations.
+ *
+ * The default implementation is inside DC.
+ * Display Manager (which instantiates DC) has the option to supply it's own
+ * (external to DC) implementation of VBIOS, which will be called by DC, using
+ * this interface.
+ * (The intended use is Diagnostics, but other uses may appear.)
+ *****************************************************************************/
+
+#include "include/bios_parser_types.h"
 
-struct dc_bios {
-	const struct dc_vbios_funcs *funcs;
-};
 
 struct dc_vbios_funcs {
 	uint8_t (*get_connectors_number)(struct dc_bios *bios);
+
+	void (*power_down)(struct dc_bios *bios);
+	void (*power_up)(struct dc_bios *bios);
+
+	uint8_t (*get_encoders_number)(struct dc_bios *bios);
+	uint32_t (*get_oem_ddc_lines_number)(struct dc_bios *bios);
+
+	struct graphics_object_id (*get_encoder_id)(
+		struct dc_bios *bios,
+		uint32_t i);
+	struct graphics_object_id (*get_connector_id)(
+		struct dc_bios *bios,
+		uint8_t connector_index);
+	uint32_t (*get_src_number)(
+		struct dc_bios *bios,
+		struct graphics_object_id id);
+	uint32_t (*get_dst_number)(
+		struct dc_bios *bios,
+		struct graphics_object_id id);
+
+	uint32_t (*get_gpio_record)(
+		struct dc_bios *dcb,
+		struct graphics_object_id id,
+		struct bp_gpio_cntl_info *gpio_record,
+		uint32_t record_size);
+
+	enum bp_result (*get_src_obj)(
+		struct dc_bios *bios,
+		struct graphics_object_id object_id, uint32_t index,
+		struct graphics_object_id *src_object_id);
+	enum bp_result (*get_dst_obj)(
+		struct dc_bios *bios,
+		struct graphics_object_id object_id, uint32_t index,
+		struct graphics_object_id *dest_object_id);
+	enum bp_result (*get_oem_ddc_info)(
+		struct dc_bios *bios,
+		uint32_t index,
+		struct graphics_object_i2c_info *info);
+
+	enum bp_result (*get_i2c_info)(
+		struct dc_bios *dcb,
+		struct graphics_object_id id,
+		struct graphics_object_i2c_info *info);
+
+	enum bp_result (*get_voltage_ddc_info)(
+		struct dc_bios *bios,
+		uint32_t index,
+		struct graphics_object_i2c_info *info);
+	enum bp_result (*get_thermal_ddc_info)(
+		struct dc_bios *bios,
+		uint32_t i2c_channel_id,
+		struct graphics_object_i2c_info *info);
+	enum bp_result (*get_hpd_info)(
+		struct dc_bios *bios,
+		struct graphics_object_id id,
+		struct graphics_object_hpd_info *info);
+	enum bp_result (*get_device_tag)(
+		struct dc_bios *bios,
+		struct graphics_object_id connector_object_id,
+		uint32_t device_tag_index,
+		struct connector_device_tag_info *info);
+	enum bp_result (*get_firmware_info)(
+		struct dc_bios *bios,
+		struct firmware_info *info);
+	enum bp_result (*get_spread_spectrum_info)(
+		struct dc_bios *bios,
+		enum as_signal_type signal,
+		uint32_t index,
+		struct spread_spectrum_info *ss_info);
+	uint32_t (*get_ss_entry_number)(
+		struct dc_bios *bios,
+		enum as_signal_type signal);
+	enum bp_result (*get_embedded_panel_info)(
+		struct dc_bios *bios,
+		struct embedded_panel_info *info);
+	enum bp_result (*enum_embedded_panel_patch_mode)(
+		struct dc_bios *bios,
+		uint32_t index,
+		struct embedded_panel_patch_mode *mode);
+	enum bp_result (*get_gpio_pin_info)(
+		struct dc_bios *bios,
+		uint32_t gpio_id,
+		struct gpio_pin_info *info);
+	enum bp_result (*get_faked_edid_len)(
+		struct dc_bios *bios,
+		uint32_t *len);
+	enum bp_result (*get_faked_edid_buf)(
+		struct dc_bios *bios,
+		uint8_t *buff,
+		uint32_t len);
+	enum bp_result (*get_encoder_cap_info)(
+		struct dc_bios *bios,
+		struct graphics_object_id object_id,
+		struct bp_encoder_cap_info *info);
+	enum bp_result (*get_din_connector_info)(
+		struct dc_bios *bios,
+		struct graphics_object_id id,
+		struct din_connector_info *info);
+
+	bool (*is_lid_open)(
+		struct dc_bios *bios);
+	bool (*is_lid_status_changed)(
+		struct dc_bios *bios);
+	bool (*is_display_config_changed)(
+		struct dc_bios *bios);
+	bool (*is_accelerated_mode)(
+		struct dc_bios *bios);
+	void (*set_scratch_lcd_scale)(
+		struct dc_bios *bios,
+		enum lcd_scale scale);
+	enum lcd_scale  (*get_scratch_lcd_scale)(
+		struct dc_bios *bios);
+	void (*get_bios_event_info)(
+		struct dc_bios *bios,
+		struct bios_event_info *info);
+	void (*update_requested_backlight_level)(
+		struct dc_bios *bios,
+		uint32_t backlight_8bit);
+	uint32_t (*get_requested_backlight_level)(
+		struct dc_bios *bios);
+	void (*take_backlight_control)(
+		struct dc_bios *bios,
+		bool cntl);
+	bool (*is_active_display)(
+		struct dc_bios *bios,
+		enum signal_type signal,
+		const struct connector_device_tag_info *device_tag);
+	enum controller_id (*get_embedded_display_controller_id)(
+		struct dc_bios *bios);
+	uint32_t (*get_embedded_display_refresh_rate)(
+		struct dc_bios *bios);
+	void (*set_scratch_connected)(
+		struct dc_bios *bios,
+		struct graphics_object_id connector_id,
+		bool connected,
+		const struct connector_device_tag_info *device_tag);
+	void (*prepare_scratch_active_and_requested)(
+		struct dc_bios *bios,
+		enum controller_id controller_id,
+		enum signal_type signal,
+		const struct connector_device_tag_info *device_tag);
+	void (*set_scratch_active_and_requested)(
+		struct dc_bios *bios);
+	void (*set_scratch_critical_state)(
+		struct dc_bios *bios,
+		bool state);
+	void (*set_scratch_acc_mode_change)(
+		struct dc_bios *bios);
+
+	bool (*is_device_id_supported)(
+		struct dc_bios *bios,
+		struct device_id id);
+
+	/* COMMANDS */
+
+	enum bp_result (*encoder_control)(
+		struct dc_bios *bios,
+		struct bp_encoder_control *cntl);
+	enum bp_result (*transmitter_control)(
+		struct dc_bios *bios,
+		struct bp_transmitter_control *cntl);
+	enum bp_result (*crt_control)(
+		struct dc_bios *bios,
+		enum engine_id engine_id,
+		bool enable,
+		uint32_t pixel_clock);
+	enum bp_result (*dvo_encoder_control)(
+		struct dc_bios *bios,
+		struct bp_dvo_encoder_control *cntl);
+	enum bp_result (*enable_crtc)(
+		struct dc_bios *bios,
+		enum controller_id id,
+		bool enable);
+	enum bp_result (*adjust_pixel_clock)(
+		struct dc_bios *bios,
+		struct bp_adjust_pixel_clock_parameters *bp_params);
+	enum bp_result (*set_pixel_clock)(
+		struct dc_bios *bios,
+		struct bp_pixel_clock_parameters *bp_params);
+	enum bp_result (*set_dce_clock)(
+		struct dc_bios *bios,
+		struct bp_set_dce_clock_parameters *bp_params);
+	enum bp_result (*enable_spread_spectrum_on_ppll)(
+		struct dc_bios *bios,
+		struct bp_spread_spectrum_parameters *bp_params,
+		bool enable);
+	enum bp_result (*program_crtc_timing)(
+		struct dc_bios *bios,
+		struct bp_hw_crtc_timing_parameters *bp_params);
+	enum bp_result (*blank_crtc)(
+		struct dc_bios *bios,
+		struct bp_blank_crtc_parameters *bp_params,
+		bool blank);
+	enum bp_result (*set_overscan)(
+		struct dc_bios *bios,
+		struct bp_hw_crtc_overscan_parameters *bp_params);
+	enum bp_result (*crtc_source_select)(
+		struct dc_bios *bios,
+		struct bp_crtc_source_select *bp_params);
+	enum bp_result (*program_display_engine_pll)(
+		struct dc_bios *bios,
+		struct bp_pixel_clock_parameters *bp_params);
+	enum bp_result (*get_divider_for_target_display_clock)(
+		struct dc_bios *bios,
+		struct bp_display_clock_parameters *bp_params);
+	enum signal_type (*dac_load_detect)(
+		struct dc_bios *bios,
+		struct graphics_object_id encoder,
+		struct graphics_object_id connector,
+		enum signal_type display_signal);
+	enum bp_result (*enable_memory_requests)(
+		struct dc_bios *bios,
+		enum controller_id controller_id,
+		bool enable);
+	enum bp_result (*external_encoder_control)(
+		struct dc_bios *bios,
+		struct bp_external_encoder_control *cntl);
+	enum bp_result (*enable_disp_power_gating)(
+		struct dc_bios *bios,
+		enum controller_id controller_id,
+		enum bp_pipe_control_action action);
+
+	void (*post_init)(struct dc_bios *bios);
+
+	struct integrated_info *(*create_integrated_info)(
+		struct dc_bios *bios);
+
+	void (*destroy_integrated_info)(
+		struct dc_bios *dcb,
+		struct integrated_info **info);
 };
 
+struct dc_bios {
+	const struct dc_vbios_funcs *funcs;
+};
 
 #endif /* DC_BIOS_TYPES_H */
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_helpers.h b/drivers/gpu/drm/amd/dal/dc/dc_helpers.h
index 7a14300..bd082d8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_helpers.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_helpers.h
@@ -33,6 +33,8 @@
 #include "dc_types.h"
 #include "dc.h"
 
+struct dp_mst_stream_allocation_table;
+
 enum dc_edid_status dc_helpers_parse_edid_caps(
 	struct dc_context *ctx,
 	const struct dc_edid *edid,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 4f37282..fbcd799 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -24,6 +24,7 @@
  */
 #include "dc_services.h"
 #include "dc.h"
+#include "dc_bios_types.h"
 #include "core_types.h"
 #include "core_status.h"
 #include "resource.h"
@@ -146,7 +147,7 @@ static void dce110_enable_display_pipe_clock_gating(
 static bool dce110_enable_display_power_gating(
 	struct dc_context *ctx,
 	uint8_t controller_id,
-	struct bios_parser *bp,
+	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
 {
 	enum bp_result bp_result = BP_RESULT_OK;
@@ -161,8 +162,8 @@ static bool dce110_enable_display_power_gating(
 
 	if (!(power_gating == PIPE_GATING_CONTROL_INIT &&
 					(controller_id + 1) != CONTROLLER_ID_D0))
-		bp_result = dal_bios_parser_enable_disp_power_gating(
-						bp, controller_id + 1, cntl);
+		bp_result = dcb->funcs->enable_disp_power_gating(
+						dcb, controller_id + 1, cntl);
 
 	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
 		init_pte(ctx);
@@ -235,12 +236,13 @@ static bool set_gamma_ramp(
 static enum dc_status bios_parser_crtc_source_select(
 		struct core_stream *stream)
 {
+	struct dc_bios *dcb;
 	/* call VBIOS table to set CRTC source for the HW
 	 * encoder block
 	 * note: video bios clears all FMT setting here. */
-
 	struct bp_crtc_source_select crtc_source_select = {0};
 	const struct core_sink *sink = stream->sink;
+
 	crtc_source_select.engine_id = stream->stream_enc->id;
 	crtc_source_select.controller_id = stream->controller_idx + 1;
 	/*TODO: Need to un-hardcode color depth, dp_audio and account for
@@ -249,14 +251,16 @@ static enum dc_status bios_parser_crtc_source_select(
 	crtc_source_select.signal = sink->public.sink_signal;
 	crtc_source_select.enable_dp_audio = false;
 	crtc_source_select.sink_signal = sink->public.sink_signal;
-	crtc_source_select.display_output_bit_depth
-		= PANEL_8BIT_COLOR;
+	crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
+
+	dcb = dal_adapter_service_get_bios_parser(sink->link->adapter_srv);
 
-	if (BP_RESULT_OK != dal_bios_parser_crtc_source_select(
-		dal_adapter_service_get_bios_parser(sink->link->adapter_srv),
+	if (BP_RESULT_OK != dcb->funcs->crtc_source_select(
+		dcb,
 		&crtc_source_select)) {
 		return DC_ERROR_UNEXPECTED;
 	}
+
 	return DC_OK;
 }
 
@@ -625,9 +629,9 @@ static void set_blender_mode(
 static void update_bios_scratch_critical_state(struct adapter_service *as,
 		bool state)
 {
-	dal_bios_parser_set_scratch_critical_state(
-		dal_adapter_service_get_bios_parser(as),
-		state);
+	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
+
+	dcb->funcs->set_scratch_critical_state(dcb, state);
 }
 
 static void update_info_frame(struct core_stream *stream)
@@ -787,14 +791,14 @@ static enum dc_status apply_single_controller_ctx_to_hw(uint8_t controller_idx,
 	bool timing_changed = context->res_ctx.controller_ctx[controller_idx]
 			.flags.timing_changed;
 	enum color_space color_space;
-	struct bios_parser *bp;
+	struct dc_bios *dcb;
 
-	bp = dal_adapter_service_get_bios_parser(
+	dcb = dal_adapter_service_get_bios_parser(
 			context->res_ctx.pool.adapter_srv);
 
 	if (timing_changed) {
 		dce110_enable_display_power_gating(
-				stream->ctx, controller_idx, bp,
+				stream->ctx, controller_idx, dcb,
 				PIPE_GATING_CONTROL_DISABLE);
 
 		/* Must blank CRTC after disabling power gating and before any
@@ -961,10 +965,10 @@ static void disable_vga_and_power_gate_all_controllers(
 {
 	int i;
 	struct timing_generator *tg;
-	struct bios_parser *bp;
+	struct dc_bios *dcb;
 	struct dc_context *ctx;
 
-	bp = dal_adapter_service_get_bios_parser(
+	dcb = dal_adapter_service_get_bios_parser(
 			dc->res_pool.adapter_srv);
 
 	for (i = 0; i < dc->res_pool.controller_count; i++) {
@@ -977,7 +981,7 @@ static void disable_vga_and_power_gate_all_controllers(
 		 * powergating. */
 		dce110_enable_display_pipe_clock_gating(ctx,
 				true);
-		dce110_enable_display_power_gating(ctx, i+1, bp,
+		dce110_enable_display_power_gating(ctx, i+1, dcb,
 				PIPE_GATING_CONTROL_ENABLE);
 	}
 }
@@ -991,16 +995,15 @@ static void disable_vga_and_power_gate_all_controllers(
  */
 static void enable_accelerated_mode(struct dc *dc)
 {
-	struct bios_parser *bp;
+	struct dc_bios *dcb;
 
-	bp = dal_adapter_service_get_bios_parser(
-			dc->res_pool.adapter_srv);
+	dcb = dal_adapter_service_get_bios_parser(dc->res_pool.adapter_srv);
 
 	power_down_all_hw_blocks(dc);
 
 	disable_vga_and_power_gate_all_controllers(dc);
 
-	dal_bios_parser_set_scratch_acc_mode_change(bp);
+	dcb->funcs->set_scratch_acc_mode_change(dcb);
 }
 
 #if 0
@@ -1559,9 +1562,9 @@ static bool update_plane_address(
 static void reset_single_stream_hw_ctx(struct core_stream *stream,
 		struct validate_context *context)
 {
-	struct bios_parser *bp;
+	struct dc_bios *dcb;
 
-	bp = dal_adapter_service_get_bios_parser(
+	dcb = dal_adapter_service_get_bios_parser(
 			context->res_ctx.pool.adapter_srv);
 	if (stream->audio) {
 		dal_audio_disable_output(stream->audio,
@@ -1580,7 +1583,7 @@ static void reset_single_stream_hw_ctx(struct core_stream *stream,
 	disable_stereo_mixer(stream->ctx);
 	unreference_clock_source(&context->res_ctx, stream->clock_source);
 	dce110_enable_display_power_gating(
-			stream->ctx, stream->controller_idx, bp,
+			stream->ctx, stream->controller_idx, dcb,
 			PIPE_GATING_CONTROL_ENABLE);
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index deaf94d..73ba7b8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -29,6 +29,8 @@
 #include "stream_encoder.h"
 #include "dce110_link_encoder.h"
 #include "i2caux_interface.h"
+#include "dc_bios_types.h"
+
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 #include "dce/dce_11_0_enum.h"
@@ -168,6 +170,19 @@ static enum transmitter translate_encoder_to_transmitter(
 	}
 }
 
+static enum bp_result link_transmitter_control(
+	struct dce110_link_encoder *enc110,
+	struct bp_transmitter_control *cntl)
+{
+	enum bp_result result;
+	struct dc_bios *bp = dal_adapter_service_get_bios_parser(
+					enc110->base.adapter_service);
+
+	result = bp->funcs->transmitter_control(bp, cntl);
+
+	return result;
+}
+
 static void enable_phy_bypass_mode(
 	struct dce110_link_encoder *enc110,
 	bool enable)
@@ -672,9 +687,7 @@ static void link_encoder_edp_power_control(
 		cntl.lanes_number = LANE_COUNT_FOUR;
 		cntl.hpd_sel = enc110->base.hpd_source;
 
-		bp_result = dal_bios_parser_transmitter_control(
-				dal_adapter_service_get_bios_parser(
-					enc110->base.adapter_service), &cntl);
+		bp_result = link_transmitter_control(enc110, &cntl);
 
 		if (BP_RESULT_OK != bp_result) {
 
@@ -866,10 +879,7 @@ static void link_encoder_edp_backlight_control(
 	 * Enable it in the future if necessary.
 	 */
 	/* dc_service_sleep_in_milliseconds(50); */
-
-	dal_bios_parser_transmitter_control(
-		dal_adapter_service_get_bios_parser(
-			enc110->base.adapter_service), &cntl);
+	link_transmitter_control(enc110, &cntl);
 }
 
 static bool is_dig_enabled(const struct dce110_link_encoder *enc110)
@@ -1299,10 +1309,7 @@ void dce110_link_encoder_hw_init(
 	cntl.coherent = false;
 	cntl.hpd_sel = enc110->base.hpd_source;
 
-	result = dal_bios_parser_transmitter_control(
-		dal_adapter_service_get_bios_parser(
-			enc110->base.adapter_service),
-		&cntl);
+	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
 		dal_logger_write(ctx->logger,
@@ -1317,10 +1324,8 @@ void dce110_link_encoder_hw_init(
 	if (enc110->base.connector.id == CONNECTOR_ID_LVDS) {
 		cntl.action = TRANSMITTER_CONTROL_BACKLIGHT_BRIGHTNESS;
 
-		result = dal_bios_parser_transmitter_control(
-			dal_adapter_service_get_bios_parser(
-				enc110->base.adapter_service),
-			&cntl);
+		result = link_transmitter_control(enc110, &cntl);
+
 		ASSERT(result == BP_RESULT_OK);
 
 	} else if (enc110->base.connector.id == CONNECTOR_ID_EDP) {
@@ -1416,10 +1421,7 @@ void dce110_link_encoder_enable_tmds_output(
 	cntl.pixel_clock = pixel_clock;
 	cntl.color_depth = color_depth;
 
-	result = dal_bios_parser_transmitter_control(
-		dal_adapter_service_get_bios_parser(
-			enc110->base.adapter_service),
-		&cntl);
+	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
 		dal_logger_write(ctx->logger,
@@ -1475,10 +1477,7 @@ void dce110_link_encoder_enable_dp_output(
 	/* TODO: check if undefined works */
 	cntl.color_depth = COLOR_DEPTH_UNDEFINED;
 
-	result = dal_bios_parser_transmitter_control(
-		dal_adapter_service_get_bios_parser(
-			enc110->base.adapter_service),
-		&cntl);
+	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
 		dal_logger_write(ctx->logger,
@@ -1521,10 +1520,7 @@ void dce110_link_encoder_enable_dp_mst_output(
 	/* TODO: check if undefined works */
 	cntl.color_depth = COLOR_DEPTH_UNDEFINED;
 
-	result = dal_bios_parser_transmitter_control(
-		dal_adapter_service_get_bios_parser(
-			enc110->base.adapter_service),
-		&cntl);
+	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
 		dal_logger_write(ctx->logger,
@@ -1578,9 +1574,7 @@ void dce110_link_encoder_disable_output(
 	cntl.signal = signal;
 	cntl.connector_obj_id = enc110->base.connector;
 
-	result = dal_bios_parser_transmitter_control(
-		dal_adapter_service_get_bios_parser(
-			enc110->base.adapter_service), &cntl);
+	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
 		dal_logger_write(ctx->logger,
@@ -1654,10 +1648,7 @@ void dce110_link_encoder_dp_set_lane_settings(
 		cntl.lane_settings = training_lane_set.raw;
 
 		/* call VBIOS table to set voltage swing and pre-emphasis */
-
-		dal_bios_parser_transmitter_control(
-			dal_adapter_service_get_bios_parser(
-				enc110->base.adapter_service), &cntl);
+		link_transmitter_control(enc110, &cntl);
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 80d3f8a..565f9cb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -104,7 +104,7 @@ static struct timing_generator *dce110_timing_generator_create(
 static struct stream_encoder *dce110_stream_encoder_create(
 	enum engine_id eng_id,
 	struct dc_context *ctx,
-	struct bios_parser *bp,
+	struct dc_bios *bp,
 	const struct dce110_stream_enc_offsets *offsets)
 {
 	struct dce110_stream_encoder *enc110 =
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index 81996f7..87f59ee 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -24,6 +24,7 @@
  */
 
 #include "dal_services.h"
+#include "dc_bios_types.h"
 #include "dce110_stream_encoder.h"
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -282,7 +283,7 @@ static void dce110_update_hdmi_info_packet(
 bool dce110_stream_encoder_construct(
 	struct dce110_stream_encoder *enc110,
 	struct dc_context *ctx,
-	struct bios_parser *bp,
+	struct dc_bios *bp,
 	enum engine_id eng_id,
 	const struct dce110_stream_enc_offsets *offsets)
 {
@@ -411,7 +412,7 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 	cntl.lanes_number = LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (dal_bios_parser_encoder_control(
+	if (enc110->base.bp->funcs->encoder_control(
 			enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
@@ -592,7 +593,7 @@ void dce110_stream_encoder_dvi_set_stream_attribute(
 				LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (dal_bios_parser_encoder_control(
+	if (enc110->base.bp->funcs->encoder_control(
 			enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
index 200308c..ddc16cd 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
@@ -44,7 +44,7 @@ struct dce110_stream_encoder {
 bool dce110_stream_encoder_construct(
 	struct dce110_stream_encoder *enc110,
 	struct dc_context *ctx,
-	struct bios_parser *bp,
+	struct dc_bios *bp,
 	enum engine_id eng_id,
 	const struct dce110_stream_enc_offsets *offsets);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index 2c7c27f..5dc3605 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -30,6 +30,7 @@
 #include "dce/dce_11_0_sh_mask.h"
 
 #include "dc_types.h"
+#include "dc_bios_types.h"
 
 #include "include/grph_object_id.h"
 #include "include/adapter_service_interface.h"
@@ -288,7 +289,7 @@ bool dce110_timing_generator_enable_crtc(struct timing_generator *tg)
 	dal_write_reg(tg->ctx,
 			CRTC_REG(mmCRTC_MASTER_UPDATE_MODE), value);
 
-	result = dal_bios_parser_enable_crtc(tg->bp, tg110->controller_id, true);
+	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, true);
 
 	return result == BP_RESULT_OK;
 }
@@ -467,7 +468,7 @@ bool dce110_timing_generator_disable_crtc(struct timing_generator *tg)
 
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	result = dal_bios_parser_enable_crtc(tg->bp, tg110->controller_id, false);
+	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, false);
 
 	/* Need to make sure stereo is disabled according to the DCE5.0 spec */
 
@@ -572,7 +573,7 @@ bool dce110_timing_generator_program_timing_generator(
 	if (patched_crtc_timing.flags.HORZ_COUNT_BY_TWO == 1)
 		bp_params.flags.HORZ_COUNT_BY_TWO = 1;
 
-	result = dal_bios_parser_program_crtc_timing(tg->bp, &bp_params);
+	result = tg->bp->funcs->program_crtc_timing(tg->bp, &bp_params);
 
 	program_horz_count_by_2(tg, &patched_crtc_timing);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.c b/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.c
index 7c94733..acc8838 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.c
@@ -326,7 +326,7 @@ static bool calc_pll_clock_source_max_vco_construct(
 			init_data->bp == NULL)
 		return false;
 
-	if (dal_bios_parser_get_firmware_info(
+	if (init_data->bp->funcs->get_firmware_info(
 				init_data->bp,
 				&fw_info) != BP_RESULT_OK)
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.h b/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.h
index be44d06..48db3d6 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/calc_pll_clock_source.h
@@ -24,10 +24,12 @@
 #ifndef __DAL_CALC_PLL_CLOCK_SOURCE_H__
 #define __DAL_CALC_PLL_CLOCK_SOURCE_H__
 
+#include "dc_bios_types.h"
+
 #include "include/clock_source_types.h"
 
 struct calc_pll_clock_source_init_data {
-	struct bios_parser *bp;
+	struct dc_bios *bp;
 	uint32_t min_pix_clk_pll_post_divider;
 	uint32_t max_pix_clk_pll_post_divider;
 	uint32_t min_pll_ref_divider;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c
index 11f16b7..cd4a91e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c
@@ -265,9 +265,10 @@ void dal_clock_source_get_ss_info_from_atombios(
 	spread_spectrum_data[0] = NULL;
 	*ss_entries_num = 0;
 
-	*ss_entries_num = dal_bios_parser_get_ss_entry_number(
+	*ss_entries_num = clk_src->bios_parser->funcs->get_ss_entry_number(
 			clk_src->bios_parser,
 			as_signal);
+
 	if (*ss_entries_num == 0)
 		return;
 
@@ -285,11 +286,13 @@ void dal_clock_source_get_ss_info_from_atombios(
 	for (i = 0, ss_info_cur = ss_info;
 		i < (*ss_entries_num);
 		++i, ++ss_info_cur) {
-		bp_result = dal_bios_parser_get_spread_spectrum_info(
+
+		bp_result = clk_src->bios_parser->funcs->get_spread_spectrum_info(
 				clk_src->bios_parser,
 				as_signal,
 				i,
 				ss_info_cur);
+
 		if (bp_result != BP_RESULT_OK)
 			goto out_free_data;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h
index 67ececd..a7863cd 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h
@@ -100,7 +100,7 @@ struct clock_source {
 	struct graphics_object_id id;
 	enum clock_source_id clk_src_id;
 	struct adapter_service *adapter_service;
-	struct bios_parser *bios_parser;
+	struct dc_bios *bios_parser;
 
 	struct spread_spectrum_data *ep_ss_params;
 	uint32_t ep_ss_params_cnt;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index e582ba0..a2a615a 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -774,7 +774,7 @@ static void set_clock(
 {
 	struct bp_pixel_clock_parameters pxl_clk_params;
 	struct display_clock_dce110 *dc = DCLCK110_FROM_BASE(base);
-	struct bios_parser *bp = dal_adapter_service_get_bios_parser(base->as);
+	struct dc_bios *bp = dal_adapter_service_get_bios_parser(base->as);
 
 	/* Prepare to program display clock*/
 	dc_service_memset(&pxl_clk_params, 0, sizeof(pxl_clk_params));
@@ -782,7 +782,7 @@ static void set_clock(
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = base->id;
 
-	dal_bios_parser_program_display_engine_pll(bp, &pxl_clk_params);
+	bp->funcs->program_display_engine_pll(bp, &pxl_clk_params);
 
 	if (dc->dfs_bypass_enabled) {
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/pll_clock_source_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/pll_clock_source_dce110.c
index d83eea3..cce9b0b 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/pll_clock_source_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/pll_clock_source_dce110.c
@@ -127,7 +127,7 @@ static bool disable_spread_spectrum(struct pll_clock_source_dce110 *clk_src)
 	bp_ss_params.pll_id = clock_source->clk_src_id;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	result = dal_bios_parser_enable_spread_spectrum_on_ppll(
+	result = clock_source->bios_parser->funcs->enable_spread_spectrum_on_ppll(
 			clock_source->bios_parser,
 			&bp_ss_params,
 			false);
@@ -171,7 +171,7 @@ static bool enable_spread_spectrum(
 				bp_params.flags.EXTERNAL_SS = 1;
 
 			if (BP_RESULT_OK !=
-				dal_bios_parser_enable_spread_spectrum_on_ppll(
+				clock_source->bios_parser->funcs->enable_spread_spectrum_on_ppll(
 						clock_source->bios_parser,
 						&bp_params,
 						true))
@@ -283,7 +283,7 @@ static bool program_pix_clk(
 	bp_pc_params.flags.SET_EXTERNAL_REF_DIV_SRC =
 					pll_settings->use_external_clk;
 
-	if (dal_bios_parser_set_pixel_clock(clk_src->bios_parser,
+	if (clk_src->bios_parser->funcs->set_pixel_clock(clk_src->bios_parser,
 						&bp_pc_params) != BP_RESULT_OK)
 		return false;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/vce_clock_source_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/vce_clock_source_dce110.c
index ce59228..0a0b516 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/vce_clock_source_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/vce_clock_source_dce110.c
@@ -79,7 +79,7 @@ static bool program_pix_clk(struct clock_source *clk_src,
 	bp_pix_clk_params.encoder_object_id = pix_clk_params->encoder_object_id;
 	bp_pix_clk_params.signal_type = pix_clk_params->signal_type;
 
-	if (dal_bios_parser_set_pixel_clock(clk_src->bios_parser,
+	if (clk_src->bios_parser->funcs->set_pixel_clock(clk_src->bios_parser,
 			&bp_pix_clk_params) == BP_RESULT_OK)
 		return true;
 
@@ -162,7 +162,7 @@ static bool construct(
 	/*Get Reference frequency, Input frequency range into PLL
 	 * and Output frequency range of the PLL
 	 * from ATOMBIOS Data table */
-	if (dal_bios_parser_get_firmware_info(
+	if (vce_clk_src->base.bios_parser->funcs->get_firmware_info(
 			vce_clk_src->base.bios_parser,
 			&fw_info) != BP_RESULT_OK)
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/ext_clock_source.c b/drivers/gpu/drm/amd/dal/dc/gpu/ext_clock_source.c
index ac27cd7..3a26312 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/ext_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/ext_clock_source.c
@@ -23,8 +23,9 @@
  */
 
 #include "dal_services.h"
-#include "include/clock_source_types.h"
+
 #include "include/bios_parser_interface.h"
+#include "include/clock_source_types.h"
 #include "include/logger_interface.h"
 #include "ext_clock_source.h"
 
@@ -71,11 +72,11 @@ bool dal_ext_clock_source_program_pix_clk(
 	bp_pix_clk_params.signal_type = pix_clk_params->signal_type;
 	bp_pix_clk_params.dvo_config = pix_clk_params->dvo_cfg;
 
-
-	if (dal_bios_parser_set_pixel_clock(
+	if (clk_src->bios_parser->funcs->set_pixel_clock(
 					clk_src->bios_parser,
 					&bp_pix_clk_params) == BP_RESULT_OK)
 		return true;
+
 	return false;
 
 }
@@ -108,11 +109,13 @@ bool dal_ext_clock_source_construct(
 			SIGNAL_TYPE_DISPLAY_PORT_MST |
 			SIGNAL_TYPE_EDP;
 
+
 	/*Get External clock frequency from ATOMBIOS Data table */
-	if (dal_bios_parser_get_firmware_info(
+	if (ext_clk_src->base.bios_parser->funcs->get_firmware_info(
 			ext_clk_src->base.bios_parser,
 			&fw_info) != BP_RESULT_OK)
 		return false;
+
 	ext_clk_src->ext_clk_freq_khz = fw_info.
 			external_clock_source_frequency_for_dp;
 	return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/pll_clock_source.c b/drivers/gpu/drm/amd/dal/dc/gpu/pll_clock_source.c
index 8bb0304..3049842 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/pll_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/pll_clock_source.c
@@ -40,7 +40,7 @@ bool dal_pll_clock_source_power_down_pll(
 	bp_pixel_clock_params.flags.FORCE_PROGRAMMING_OF_PLL = 1;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	bp_result = dal_bios_parser_set_pixel_clock(
+	bp_result = clk_src->bios_parser->funcs->set_pixel_clock(
 			clk_src->bios_parser,
 			&bp_pixel_clock_params);
 
@@ -102,7 +102,7 @@ bool dal_pll_clock_source_adjust_pix_clk(
 		display_pll_config = pix_clk_params->disp_pll_cfg;
 	bp_adjust_pixel_clock_params.
 		ss_enable = pix_clk_params->flags.ENABLE_SS;
-	bp_result = dal_bios_parser_adjust_pixel_clock(
+	bp_result = pll_clk_src->base.bios_parser->funcs->adjust_pixel_clock(
 			pll_clk_src->base.bios_parser,
 			&bp_adjust_pixel_clock_params);
 	if (bp_result == BP_RESULT_OK) {
@@ -131,10 +131,11 @@ bool dal_pll_clock_source_construct(
 			clk_src_init_data))
 		return false;
 
-	if (dal_bios_parser_get_firmware_info(
+	if (pll_clk_src->base.bios_parser->funcs->get_firmware_info(
 			pll_clk_src->base.bios_parser,
 			&fw_info) != BP_RESULT_OK)
 		return false;
+
 	pll_clk_src->ref_freq_khz = fw_info.pll_info.crystal_frequency;
 
 	return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 317110e..a5ccb5e 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -141,7 +141,7 @@ struct hw_sequencer_funcs {
 	bool (*enable_display_power_gating)(
 					struct dc_context *ctx,
 					uint8_t controller_id,
-					struct bios_parser *bp,
+					struct dc_bios *dcb,
 					enum pipe_gating_control power_gating);
 
 	/* resource management and validation*/
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/stream_encoder.h
index 25028b7..9665356 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/stream_encoder.h
@@ -9,10 +9,12 @@
 #include "include/encoder_types.h"
 #include "include/bios_parser_interface.h"
 
+struct dc_bios;
+
 struct stream_encoder {
 	struct stream_encoder_funcs *funcs;
 	struct dc_context *ctx;
-	struct bios_parser *bp;
+	struct dc_bios *bp;
 	enum engine_id id;
 };
 
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
index e449db6..2851266 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
@@ -36,7 +36,6 @@
 #include "asic_capability_types.h"
 
 /* forward declaration */
-struct bios_parser;
 struct i2caux;
 struct adapter_service;
 
@@ -481,7 +480,7 @@ bool dal_adapter_service_get_i2c_info(
 	struct graphics_object_i2c_info *i2c_info);
 
 /* Get bios parser handler */
-struct bios_parser *dal_adapter_service_get_bios_parser(
+struct dc_bios *dal_adapter_service_get_bios_parser(
 	struct adapter_service *as);
 
 /* Get i2c aux handler */
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_types.h b/drivers/gpu/drm/amd/dal/include/adapter_service_types.h
index fb47ef3..4cb4b4b 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_types.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_types.h
@@ -26,6 +26,7 @@
 #ifndef __DAL_ADAPTER_SERVICE_TYPES_H__
 #define __DAL_ADAPTER_SERVICE_TYPES_H__
 
+/* TODO: include signal_types.h and remove this enum */
 enum as_signal_type {
 	AS_SIGNAL_TYPE_NONE = 0L, /* no signal */
 	AS_SIGNAL_TYPE_DVI,
diff --git a/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h b/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h
index 77999fc..e4291b9 100644
--- a/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h
@@ -26,143 +26,25 @@
 #ifndef __DAL_BIOS_PARSER_INTERFACE_H__
 #define __DAL_BIOS_PARSER_INTERFACE_H__
 
-#include "bios_parser_types.h"
-#include "adapter_service_types.h"
-#include "gpio_types.h"
+#include "dc_bios_types.h"
 
 struct adapter_service;
 struct bios_parser;
 
-struct bp_gpio_cntl_info {
-	uint32_t id;
-	enum gpio_pin_output_state state;
-};
-
-enum bp_result {
-	BP_RESULT_OK = 0, /* There was no error */
-	BP_RESULT_BADINPUT, /*Bad input parameter */
-	BP_RESULT_BADBIOSTABLE, /* Bad BIOS table */
-	BP_RESULT_UNSUPPORTED, /* BIOS Table is not supported */
-	BP_RESULT_NORECORD, /* Record can't be found */
-	BP_RESULT_FAILURE
-};
-
 struct bp_init_data {
 	struct dc_context *ctx;
 	uint8_t *bios;
 };
 
-struct bios_parser *dal_bios_parser_create(
+struct dc_bios *dal_bios_parser_create(
 	struct bp_init_data *init,
 	struct adapter_service *as);
-void dal_bios_parser_destroy(
-	struct bios_parser **bp);
-
-
-void dal_bios_parser_power_down(
-	struct bios_parser *bp);
-void dal_bios_parser_power_up(
-	struct bios_parser *bp);
 
-uint8_t dal_bios_parser_get_encoders_number(
-	struct bios_parser *bp);
-uint32_t dal_bios_parser_get_oem_ddc_lines_number(
-	struct bios_parser *bp);
-struct graphics_object_id dal_bios_parser_get_encoder_id(
-	struct bios_parser *bp,
-	uint32_t i);
-struct graphics_object_id dal_bios_parser_get_connector_id(
-	struct bios_parser *bp,
-	uint8_t connector_index);
-uint32_t dal_bios_parser_get_src_number(
-	struct bios_parser *bp,
-	struct graphics_object_id id);
-uint32_t dal_bios_parser_get_dst_number(
-	struct bios_parser *bp,
-	struct graphics_object_id id);
-uint32_t dal_bios_parser_get_gpio_record(
-	struct bios_parser *bp,
-	struct graphics_object_id id,
-	struct bp_gpio_cntl_info *gpio_record,
-	uint32_t record_size);
-enum bp_result dal_bios_parser_get_src_obj(
-	struct bios_parser *bp,
-	struct graphics_object_id object_id, uint32_t index,
-	struct graphics_object_id *src_object_id);
-enum bp_result dal_bios_parser_get_dst_obj(
-	struct bios_parser *bp,
-	struct graphics_object_id object_id, uint32_t index,
-	struct graphics_object_id *dest_object_id);
-enum bp_result dal_bios_parser_get_i2c_info(
-	struct bios_parser *bp,
-	struct graphics_object_id id,
-	struct graphics_object_i2c_info *info);
-enum bp_result dal_bios_parser_get_oem_ddc_info(
-	struct bios_parser *bp,
-	uint32_t index,
-	struct graphics_object_i2c_info *info);
-enum bp_result dal_bios_parser_get_voltage_ddc_info(
-	struct bios_parser *bp,
-	uint32_t index,
-	struct graphics_object_i2c_info *info);
-enum bp_result dal_bios_parser_get_thermal_ddc_info(
-	struct bios_parser *bp,
-	uint32_t i2c_channel_id,
-	struct graphics_object_i2c_info *info);
-enum bp_result dal_bios_parser_get_hpd_info(
-	struct bios_parser *bp,
-	struct graphics_object_id id,
-	struct graphics_object_hpd_info *info);
-enum bp_result dal_bios_parser_get_device_tag(
-	struct bios_parser *bp,
-	struct graphics_object_id connector_object_id,
-	uint32_t device_tag_index,
-	struct connector_device_tag_info *info);
-enum bp_result dal_bios_parser_get_firmware_info(
-	struct bios_parser *bp,
-	struct firmware_info *info);
-enum bp_result dal_bios_parser_get_spread_spectrum_info(
-	struct bios_parser *bp,
-	enum as_signal_type signal,
-	uint32_t index,
-	struct spread_spectrum_info *ss_info);
-uint32_t dal_bios_parser_get_ss_entry_number(
-	struct bios_parser *bp,
-	enum as_signal_type signal);
-enum bp_result dal_bios_parser_get_embedded_panel_info(
-	struct bios_parser *bp,
-	struct embedded_panel_info *info);
-enum bp_result dal_bios_parser_enum_embedded_panel_patch_mode(
-	struct bios_parser *bp,
-	uint32_t index,
-	struct embedded_panel_patch_mode *mode);
-enum bp_result dal_bios_parser_get_gpio_pin_info(
-	struct bios_parser *bp,
-	uint32_t gpio_id,
-	struct gpio_pin_info *info);
-enum bp_result dal_bios_parser_get_embedded_panel_info(
-	struct bios_parser *bp,
-	struct embedded_panel_info *info);
-enum bp_result dal_bios_parser_get_gpio_pin_info(
-	struct bios_parser *bp,
-	uint32_t gpio_id,
-	struct gpio_pin_info *info);
-enum bp_result dal_bios_parser_get_faked_edid_len(
-	struct bios_parser *bp,
-	uint32_t *len);
-enum bp_result dal_bios_parser_get_faked_edid_buf(
-	struct bios_parser *bp,
-	uint8_t *buff,
-	uint32_t len);
-enum bp_result dal_bios_parser_get_encoder_cap_info(
-	struct bios_parser *bp,
-	struct graphics_object_id object_id,
-	struct bp_encoder_cap_info *info);
-enum bp_result dal_bios_parser_get_din_connector_info(
-	struct bios_parser *bp,
-	struct graphics_object_id id,
-	struct din_connector_info *info);
+void dal_bios_parser_destroy(
+	struct dc_bios **dcb);
 
+/*****************************************************************************/
+/* Interfaces of BIOS Parser Helper */
 bool dal_bios_parser_is_lid_open(
 	struct bios_parser *bp);
 bool dal_bios_parser_is_lid_status_changed(
@@ -213,88 +95,4 @@ void dal_bios_parser_set_scratch_critical_state(
 void dal_bios_parser_set_scratch_acc_mode_change(
 	struct bios_parser *bp);
 
-bool dal_bios_parser_is_device_id_supported(
-	struct bios_parser *bp,
-	struct device_id id);
-
-/* COMMANDS */
-
-enum bp_result dal_bios_parser_encoder_control(
-	struct bios_parser *bp,
-	struct bp_encoder_control *cntl);
-enum bp_result dal_bios_parser_transmitter_control(
-	struct bios_parser *bp,
-	struct bp_transmitter_control *cntl);
-enum bp_result dal_bios_parser_crt_control(
-	struct bios_parser *bp,
-	enum engine_id engine_id,
-	bool enable,
-	uint32_t pixel_clock);
-enum bp_result dal_bios_parser_dvo_encoder_control(
-	struct bios_parser *bp,
-	struct bp_dvo_encoder_control *cntl);
-enum bp_result dal_bios_parser_enable_crtc(
-	struct bios_parser *bp,
-	enum controller_id id,
-	bool enable);
-enum bp_result dal_bios_parser_adjust_pixel_clock(
-	struct bios_parser *bp,
-	struct bp_adjust_pixel_clock_parameters *bp_params);
-enum bp_result dal_bios_parser_set_pixel_clock(
-	struct bios_parser *bp,
-	struct bp_pixel_clock_parameters *bp_params);
-enum bp_result dal_bios_parser_set_dce_clock(
-	struct bios_parser *bp,
-	struct bp_set_dce_clock_parameters *bp_params);
-enum bp_result dal_bios_parser_enable_spread_spectrum_on_ppll(
-	struct bios_parser *bp,
-	struct bp_spread_spectrum_parameters *bp_params,
-	bool enable);
-enum bp_result dal_bios_parser_program_crtc_timing(
-	struct bios_parser *bp,
-	struct bp_hw_crtc_timing_parameters *bp_params);
-enum bp_result dal_bios_parser_blank_crtc(
-	struct bios_parser *bp,
-	struct bp_blank_crtc_parameters *bp_params,
-	bool blank);
-enum bp_result dal_bios_parser_set_overscan(
-	struct bios_parser *bp,
-	struct bp_hw_crtc_overscan_parameters *bp_params);
-enum bp_result dal_bios_parser_crtc_source_select(
-	struct bios_parser *bp,
-	struct bp_crtc_source_select *bp_params);
-enum bp_result dal_bios_parser_program_display_engine_pll(
-	struct bios_parser *bp,
-	struct bp_pixel_clock_parameters *bp_params);
-enum bp_result dal_bios_parser_get_divider_for_target_display_clock(
-	struct bios_parser *bp,
-	struct bp_display_clock_parameters *bp_params);
-enum signal_type dal_bios_parser_dac_load_detect(
-	struct bios_parser *bp,
-	struct graphics_object_id encoder,
-	struct graphics_object_id connector,
-	enum signal_type display_signal);
-enum bp_result dal_bios_parser_enable_memory_requests(
-	struct bios_parser *bp,
-	enum controller_id controller_id,
-	bool enable);
-enum bp_result dal_bios_parser_external_encoder_control(
-	struct bios_parser *bp,
-	struct bp_external_encoder_control *cntl);
-enum bp_result dal_bios_parser_enable_disp_power_gating(
-	struct bios_parser *bp,
-	enum controller_id controller_id,
-	enum bp_pipe_control_action action);
-
-void dal_bios_parser_post_init(struct bios_parser *bp);
-
-/* Parse integrated BIOS info */
-struct integrated_info *dal_bios_parser_create_integrated_info(
-	struct bios_parser *bp);
-
-/* Destroy provided integrated info */
-void dal_bios_parser_destroy_integrated_info(struct dc_context *ctx, struct integrated_info **info);
-
-
-
-#endif
+#endif /* __DAL_BIOS_PARSER_INTERFACE_H__ */
diff --git a/drivers/gpu/drm/amd/dal/include/bios_parser_types.h b/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
index 4176f28..7b93997 100644
--- a/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
+++ b/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
@@ -28,7 +28,17 @@
 
 #include "include/signal_types.h"
 #include "include/grph_object_ctrl_defs.h"
-#include "link_service_types.h"
+#include "include/gpio_types.h"
+#include "include/adapter_service_types.h" /* for as_signal_type */
+
+enum bp_result {
+	BP_RESULT_OK = 0, /* There was no error */
+	BP_RESULT_BADINPUT, /*Bad input parameter */
+	BP_RESULT_BADBIOSTABLE, /* Bad BIOS table */
+	BP_RESULT_UNSUPPORTED, /* BIOS Table is not supported */
+	BP_RESULT_NORECORD, /* Record can't be found */
+	BP_RESULT_FAILURE
+};
 
 enum bp_encoder_control_action {
 	/* direct VBIOS translation! Just to simplify the translation */
@@ -337,4 +347,9 @@ struct bp_encoder_cap_info {
 	uint32_t RESERVED:30;
 };
 
-#endif
+struct bp_gpio_cntl_info {
+	uint32_t id;
+	enum gpio_pin_output_state state;
+};
+
+#endif /*__DAL_BIOS_PARSER_TYPES_H__ */
diff --git a/drivers/gpu/drm/amd/dal/include/timing_generator_types.h b/drivers/gpu/drm/amd/dal/include/timing_generator_types.h
index 3f5f1ec..75dfbab 100644
--- a/drivers/gpu/drm/amd/dal/include/timing_generator_types.h
+++ b/drivers/gpu/drm/amd/dal/include/timing_generator_types.h
@@ -28,6 +28,7 @@
 
 #include "include/grph_csc_types.h"
 
+struct dc_bios;
 
 /**
  *  These parameters are required as input when doing blanking/Unblanking
@@ -142,7 +143,7 @@ enum crtc_state {
 
 struct timing_generator {
 	struct timing_generator_funcs *funcs;
-	struct bios_parser *bp;
+	struct dc_bios *bp;
 	struct dc_context *ctx;
 };
 
-- 
2.7.4

