From 0262fd5b79f75dcdd346db13043e79f7e13ba113 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 12 Apr 2016 11:50:02 +1000
Subject: [PATCH 0552/1722] drm/amd/dal: pipe adapter_service into feature
 requests

So far the feature table is stored globally when really it should
be per-adapter.

This changes all the APIs so we can fix this.

Signed-off-by: Dave Airlie <airlied@redhat.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c    | 21 ++++++++++-----------
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c    |  3 ++-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c       |  4 ++--
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c       |  5 +++--
 drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c |  5 +++--
 .../gpu/drm/amd/dal/dc/dce110/dce110_compressor.c   |  6 +++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c | 11 ++++++-----
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c    |  3 ++-
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h    |  1 +
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c  |  5 +++--
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h  |  3 ++-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c |  7 ++++---
 .../gpu/drm/amd/dal/dc/dce112/dce112_compressor.c   |  6 +++---
 .../gpu/drm/amd/dal/dc/dce112/dce112_mem_input.c    |  3 ++-
 .../gpu/drm/amd/dal/dc/dce112/dce112_mem_input.h    |  1 +
 drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c |  4 +++-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c |  6 +++---
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c   |  6 +++---
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c  |  3 ++-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.h  |  1 +
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c   |  5 +++--
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c    |  2 +-
 .../amd/dal/dc/gpu/dce112/display_clock_dce112.c    |  2 +-
 .../drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c  |  4 ++--
 .../drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c    |  2 +-
 .../gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c  |  2 +-
 .../drm/amd/dal/include/adapter_service_interface.h |  4 ++--
 27 files changed, 70 insertions(+), 55 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index a7b6345..2f91f8c 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -55,7 +55,6 @@
 
 #include "diagnostics/hw_ctx_adapter_service_diag.h"
 
-#define SIZEOF_BACKLIGHT_LUT 101
 #define ABSOLUTE_BACKLIGHT_MAX 255
 #define DEFAULT_MIN_BACKLIGHT 12
 #define DEFAULT_MAX_BACKLIGHT 255
@@ -1067,7 +1066,7 @@ uint8_t dal_adapter_service_get_clock_sources_num(
 	num += (uint32_t)wireless_get_clocks_num(as);
 
 	/* Check the "max number of clock sources" feature */
-	if (dal_adapter_service_get_feature_value(
+	if (dal_adapter_service_get_feature_value(as,
 			FEATURE_MAX_CLOCK_SOURCE_NUM,
 			&max_clk_src,
 			sizeof(uint32_t)))
@@ -1110,12 +1109,12 @@ uint8_t dal_adapter_service_get_func_controllers_num(
  * Return if a given feature is supported by the ASIC. The feature has to be
  * a boolean type.
  */
-bool dal_adapter_service_is_feature_supported(
-	enum adapter_feature_id feature_id)
+bool dal_adapter_service_is_feature_supported(struct adapter_service *as,
+					      enum adapter_feature_id feature_id)
 {
 	bool data = 0;
 
-	dal_adapter_service_get_feature_value(feature_id, &data, sizeof(bool));
+	dal_adapter_service_get_feature_value(as, feature_id, &data, sizeof(bool));
 
 	return data;
 }
@@ -1281,7 +1280,7 @@ bool dal_adapter_service_is_dfs_bypass_enabled(
 	if (as->integrated_info == NULL)
 		return false;
 	if ((as->integrated_info->gpu_cap_info & DFS_BYPASS_ENABLE) &&
-		dal_adapter_service_is_feature_supported(
+	    dal_adapter_service_is_feature_supported(as,
 			FEATURE_ENABLE_DFS_BYPASS))
 		return true;
 	else
@@ -1371,10 +1370,10 @@ uint8_t dal_adapter_service_get_stream_engines_num(
  * Get the cached value of a given feature. This value can be a boolean, int,
  * or characters.
  */
-bool dal_adapter_service_get_feature_value(
-	const enum adapter_feature_id feature_id,
-	void *data,
-	uint32_t size)
+bool dal_adapter_service_get_feature_value(struct adapter_service *as,
+					   const enum adapter_feature_id feature_id,
+					   void *data,
+					   uint32_t size)
 {
 	uint32_t entry_idx = 0;
 	uint32_t set_idx = 0;
@@ -1499,7 +1498,7 @@ bool dal_adapter_service_should_optimize(
 	uint32_t supported_optimization = 0;
 	struct dal_asic_runtime_flags flags;
 
-	if (!dal_adapter_service_get_feature_value(FEATURE_OPTIMIZATION,
+	if (!dal_adapter_service_get_feature_value(as, FEATURE_OPTIMIZATION,
 			&supported_optimization, sizeof(uint32_t)))
 		return false;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
index 8b9ad02..2ffea23 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
@@ -275,7 +275,8 @@ static enum audio_result initialize(
 	/* override HW default settings */
 	audio->hw_ctx->funcs->hw_initialize(audio->hw_ctx);
 
-	if (dal_adapter_service_is_feature_supported(FEATURE_LIGHT_SLEEP))
+	if (dal_adapter_service_is_feature_supported(audio->adapter_service,
+						     FEATURE_LIGHT_SLEEP))
 		audio->hw_ctx->funcs->disable_az_clock_gating(audio->hw_ctx);
 
 	return AUDIO_RESULT_OK;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
index c38e60e..9d8c427 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
@@ -285,11 +285,11 @@ static bool construct(
 	ddc_service->flags.EDID_QUERY_DONE_ONCE = false;
 
 	ddc_service->flags.FORCE_READ_REPEATED_START =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(ddc_service->as,
 			FEATURE_DDC_READ_FORCE_REPEATED_START);
 
 	ddc_service->flags.EDID_STRESS_READ =
-			dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(ddc_service->as,
 				FEATURE_EDID_STRESS_READ);
 
 	ddc_service->flags.IS_INTERNAL_DISPLAY =
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 6a93bf1..f65d6c3 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -219,8 +219,9 @@ struct clock_source *resource_find_used_clk_src_for_sharing(
 					struct resource_context *res_ctx,
 					struct pipe_ctx *pipe_ctx)
 {
-	if (!dal_adapter_service_is_feature_supported
-			(FEATURE_DISABLE_CLOCK_SHARING)) {
+	if (!dal_adapter_service_is_feature_supported(
+			res_ctx->pool->adapter_srv,
+			FEATURE_DISABLE_CLOCK_SHARING)) {
 		int i;
 
 		for (i = 0; i < MAX_PIPES; i++) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 4149fc3..2b768cc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -372,6 +372,7 @@ static struct stream_encoder *dce100_stream_encoder_create(
 
 static struct mem_input *dce100_mem_input_create(
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offset)
 {
@@ -382,7 +383,7 @@ static struct mem_input *dce100_mem_input_create(
 		return NULL;
 
 	if (dce110_mem_input_construct(mem_input110,
-			ctx, inst, offset))
+				       ctx, as, inst, offset))
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
@@ -839,7 +840,7 @@ bool dce100_construct_resource_pool(
 			goto controller_create_fail;
 		}
 
-		pool->mis[i] = dce100_mem_input_create(ctx, i,
+                pool->base.mis[i] = dce100_mem_input_create(ctx, as, i,
 				&dce100_mi_reg_offsets[i]);
 		if (pool->mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
index 7a647cd..8597d82 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
@@ -814,13 +814,13 @@ bool dce110_compressor_construct(struct dce110_compressor *compressor,
 	struct embedded_panel_info panel_info;
 
 	compressor->base.options.bits.FBC_SUPPORT = true;
-	if (!(dal_adapter_service_is_feature_supported(
+	if (!(dal_adapter_service_is_feature_supported(as,
 		FEATURE_DISABLE_LPT_SUPPORT)))
 		compressor->base.options.bits.LPT_SUPPORT = true;
 	 /* For DCE 11 always use one DRAM channel for LPT */
 	compressor->base.lpt_channels_num = 1;
 
-	if (dal_adapter_service_is_feature_supported(FEATURE_DUMMY_FBC_BACKEND))
+	if (dal_adapter_service_is_feature_supported(as, FEATURE_DUMMY_FBC_BACKEND))
 		compressor->base.options.bits.DUMMY_BACKEND = true;
 
 	/* Check if this system has more than 1 DRAM channel; if only 1 then LPT
@@ -828,7 +828,7 @@ bool dce110_compressor_construct(struct dce110_compressor *compressor,
 	if (compressor->base.memory_bus_width == 64)
 		compressor->base.options.bits.LPT_SUPPORT = false;
 
-	if (dal_adapter_service_is_feature_supported(
+	if (dal_adapter_service_is_feature_supported(as,
 		FEATURE_DISABLE_FBC_COMP_CLK_GATE))
 		compressor->base.options.bits.CLK_GATING_DISABLED = true;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 5af451a..7a91259 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -619,7 +619,7 @@ static void link_encoder_edp_wait_for_hpd_ready(
 		return;
 	}
 
-	if (!power_up && dal_adapter_service_is_feature_supported(
+	if (!power_up && dal_adapter_service_is_feature_supported(as,
 		FEATURE_NO_HPD_LOW_POLLING_VCC_OFF))
 		/* from KV, we will not HPD low after turning off VCC -
 		 * instead, we will check the SW timer in power_up(). */
@@ -1016,6 +1016,7 @@ bool dce110_link_encoder_construct(
 	const struct dce110_link_enc_bl_registers *bl_regs)
 {
 	struct graphics_object_encoder_cap_info enc_cap_info = {0};
+	struct adapter_service *as = init_data->adapter_service;
 
 	enc110->base.funcs = &dce110_lnk_enc_funcs;
 	enc110->base.ctx = init_data->ctx;
@@ -1025,7 +1026,7 @@ bool dce110_link_encoder_construct(
 	enc110->base.connector = init_data->connector;
 	enc110->base.input_signals = SIGNAL_TYPE_ALL;
 
-	enc110->base.adapter_service = init_data->adapter_service;
+	enc110->base.adapter_service = as;
 
 	enc110->base.preferred_engine = ENGINE_ID_UNKNOWN;
 
@@ -1047,7 +1048,7 @@ bool dce110_link_encoder_construct(
 	 * while doing the DP sink detect
 	 */
 
-	if (dal_adapter_service_is_feature_supported(
+	if (dal_adapter_service_is_feature_supported(as,
 		FEATURE_DP_SINK_DETECT_POLL_DATA_PIN))
 		enc110->base.features.flags.bits.
 			DP_SINK_DETECT_POLL_DATA_PIN = true;
@@ -1118,11 +1119,11 @@ bool dce110_link_encoder_construct(
 	enc110->base.features.flags.bits.IS_TPS3_CAPABLE = true;
 
 	enc110->base.features.flags.bits.IS_Y_ONLY_CAPABLE =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(as,
 			FEATURE_SUPPORT_DP_Y_ONLY);
 
 	enc110->base.features.flags.bits.IS_YCBCR_CAPABLE =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(as,
 			FEATURE_SUPPORT_DP_YUV);
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index 6629f2f..d232b4e5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -879,6 +879,7 @@ static struct mem_input_funcs dce110_mem_input_funcs = {
 bool dce110_mem_input_construct(
 	struct dce110_mem_input *mem_input110,
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets)
 {
@@ -890,7 +891,7 @@ bool dce110_mem_input_construct(
 	mem_input110->offsets = *offsets;
 
 	mem_input110->supported_stutter_mode = 0;
-	dal_adapter_service_get_feature_value(FEATURE_STUTTER_MODE,
+	dal_adapter_service_get_feature_value(as, FEATURE_STUTTER_MODE,
 			&(mem_input110->supported_stutter_mode),
 			sizeof(mem_input110->supported_stutter_mode));
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
index a42e06a..0704269 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
@@ -67,6 +67,7 @@ struct dce110_mem_input {
 bool dce110_mem_input_construct(
 	struct dce110_mem_input *mem_input110,
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
index 5f819de..85cde7d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
@@ -871,7 +871,8 @@ static struct mem_input_funcs dce110_mem_input_v_funcs = {
 
 bool dce110_mem_input_v_construct(
 	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx)
+	struct dc_context *ctx,
+	struct adapter_service *as)
 {
 	mem_input110->base.funcs = &dce110_mem_input_v_funcs;
 	mem_input110->base.ctx = ctx;
@@ -881,7 +882,7 @@ bool dce110_mem_input_v_construct(
 	mem_input110->offsets = dce110_mi_v_reg_offsets[0];
 
 	mem_input110->supported_stutter_mode = 0;
-	dal_adapter_service_get_feature_value(FEATURE_STUTTER_MODE,
+	dal_adapter_service_get_feature_value(as, FEATURE_STUTTER_MODE,
 			&(mem_input110->supported_stutter_mode),
 			sizeof(mem_input110->supported_stutter_mode));
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
index 3df346b..9852363 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
@@ -30,7 +30,8 @@
 
 bool dce110_mem_input_v_construct(
 	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx);
+	struct dc_context *ctx,
+	struct adapter_service *as);
 
 /*
  * This function will program nbp stutter and urgency watermarks to minimum
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 2ca21fc..ec1fc37 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -334,6 +334,7 @@ static struct stream_encoder *dce110_stream_encoder_create(
 
 static struct mem_input *dce110_mem_input_create(
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offset)
 {
@@ -344,7 +345,7 @@ static struct mem_input *dce110_mem_input_create(
 		return NULL;
 
 	if (dce110_mem_input_construct(mem_input110,
-			ctx, inst, offset))
+				       ctx, as, inst, offset))
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
@@ -947,7 +948,7 @@ static void underlay_create(struct dc_context *ctx, struct resource_pool *pool)
 
 	dce110_opp_v_construct(dce110_oppv, ctx);
 	dce110_timing_generator_v_construct(dce110_tgv, pool->adapter_srv, ctx);
-	dce110_mem_input_v_construct(dce110_miv, ctx);
+	dce110_mem_input_v_construct(dce110_miv, ctx, pool->adapter_srv);
 	dce110_transform_v_construct(dce110_xfmv, ctx);
 
 	pool->opps[pool->pipe_count] = &dce110_oppv->base;
@@ -1111,7 +1112,7 @@ bool dce110_construct_resource_pool(
 			goto controller_create_fail;
 		}
 
-		pool->mis[i] = dce110_mem_input_create(ctx, i,
+                pool->base.mis[i] = dce110_mem_input_create(ctx, as, i,
 				&dce110_mi_reg_offsets[i]);
 		if (pool->mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_compressor.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_compressor.c
index 9526ffd..1940d98 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_compressor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_compressor.c
@@ -814,13 +814,13 @@ bool dce112_compressor_construct(struct dce112_compressor *compressor,
 	struct embedded_panel_info panel_info;
 
 	compressor->base.options.bits.FBC_SUPPORT = true;
-	if (!(dal_adapter_service_is_feature_supported(
+	if (!(dal_adapter_service_is_feature_supported(as,
 		FEATURE_DISABLE_LPT_SUPPORT)))
 		compressor->base.options.bits.LPT_SUPPORT = true;
 	 /* For DCE 11 always use one DRAM channel for LPT */
 	compressor->base.lpt_channels_num = 1;
 
-	if (dal_adapter_service_is_feature_supported(FEATURE_DUMMY_FBC_BACKEND))
+	if (dal_adapter_service_is_feature_supported(as, FEATURE_DUMMY_FBC_BACKEND))
 		compressor->base.options.bits.DUMMY_BACKEND = true;
 
 	/* Check if this system has more than 1 DRAM channel; if only 1 then LPT
@@ -828,7 +828,7 @@ bool dce112_compressor_construct(struct dce112_compressor *compressor,
 	if (compressor->base.memory_bus_width == 64)
 		compressor->base.options.bits.LPT_SUPPORT = false;
 
-	if (dal_adapter_service_is_feature_supported(
+	if (dal_adapter_service_is_feature_supported(as,
 		FEATURE_DISABLE_FBC_COMP_CLK_GATE))
 		compressor->base.options.bits.CLK_GATING_DISABLED = true;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.c
index 823849e..4647177 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.c
@@ -442,10 +442,11 @@ static void dce112_mem_input_program_display_marks(
 bool dce112_mem_input_construct(
 	struct dce110_mem_input *mem_input110,
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets)
 {
-	if (!dce110_mem_input_construct(mem_input110, ctx, inst, offsets))
+  if (!dce110_mem_input_construct(mem_input110, ctx, as, inst, offsets))
 		return false;
 
 	mem_input110->base.funcs->mem_input_program_display_marks =
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.h b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.h
index de2aaf0..00b127a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_mem_input.h
@@ -31,6 +31,7 @@
 bool dce112_mem_input_construct(
 	struct dce110_mem_input *mem_input110,
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 3f3ed22..1431d86 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -389,6 +389,7 @@ static struct stream_encoder *dce112_stream_encoder_create(
 
 static struct mem_input *dce112_mem_input_create(
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offset)
 {
@@ -399,7 +400,7 @@ static struct mem_input *dce112_mem_input_create(
 		return NULL;
 
 	if (dce112_mem_input_construct(mem_input110,
-			ctx, inst, offset))
+				       ctx, as, inst, offset))
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
@@ -1145,6 +1146,7 @@ bool dce112_construct_resource_pool(
 
 		pool->mis[i] = dce112_mem_input_create(
 			ctx,
+                        adapter_serv,
 			i,
 			&dce112_mi_reg_offsets[i]);
 		if (pool->mis[i] == NULL) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c
index dc008e7..a05a3cb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c
@@ -795,13 +795,13 @@ bool dce80_compressor_construct(struct dce80_compressor *compressor,
 	struct embedded_panel_info panel_info;
 
 	compressor->base.options.bits.FBC_SUPPORT = true;
-	if (!(dal_adapter_service_is_feature_supported(
+	if (!(dal_adapter_service_is_feature_supported(as,
 		FEATURE_DISABLE_LPT_SUPPORT)))
 		compressor->base.options.bits.LPT_SUPPORT = true;
 	 /* For DCE 11 always use one DRAM channel for LPT */
 	compressor->base.lpt_channels_num = 1;
 
-	if (dal_adapter_service_is_feature_supported(FEATURE_DUMMY_FBC_BACKEND))
+	if (dal_adapter_service_is_feature_supported(as, FEATURE_DUMMY_FBC_BACKEND))
 		compressor->base.options.bits.DUMMY_BACKEND = true;
 
 	/* Check if this system has more than 1 DRAM channel; if only 1 then LPT
@@ -809,7 +809,7 @@ bool dce80_compressor_construct(struct dce80_compressor *compressor,
 	if (compressor->base.memory_bus_width == 64)
 		compressor->base.options.bits.LPT_SUPPORT = false;
 
-	if (dal_adapter_service_is_feature_supported(
+	if (dal_adapter_service_is_feature_supported(as,
 		FEATURE_DISABLE_FBC_COMP_CLK_GATE))
 		compressor->base.options.bits.CLK_GATING_DISABLED = true;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
index 60c9837..486378e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
@@ -251,7 +251,7 @@ bool dce80_link_encoder_construct(
 	 * while doing the DP sink detect
 	 */
 
-	if (dal_adapter_service_is_feature_supported(
+	if (dal_adapter_service_is_feature_supported(enc110->base.adapter_service,
 		FEATURE_DP_SINK_DETECT_POLL_DATA_PIN))
 		enc110->base.features.flags.bits.
 			DP_SINK_DETECT_POLL_DATA_PIN = true;
@@ -325,11 +325,11 @@ bool dce80_link_encoder_construct(
 	enc110->base.features.max_deep_color = COLOR_DEPTH_121212;
 
 	enc110->base.features.flags.bits.IS_Y_ONLY_CAPABLE =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(enc110->base.adapter_service,
 			FEATURE_SUPPORT_DP_Y_ONLY);
 
 	enc110->base.features.flags.bits.IS_YCBCR_CAPABLE =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(enc110->base.adapter_service,
 			FEATURE_SUPPORT_DP_YUV);
 
 	return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
index c73c118..7812a7d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
@@ -192,6 +192,7 @@ static struct mem_input_funcs dce80_mem_input_funcs = {
 bool dce80_mem_input_construct(
 	struct dce110_mem_input *mem_input80,
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets)
 {
@@ -204,7 +205,7 @@ bool dce80_mem_input_construct(
 	mem_input80->offsets = *offsets;
 
 	mem_input80->supported_stutter_mode = 0;
-	dal_adapter_service_get_feature_value(FEATURE_STUTTER_MODE,
+	dal_adapter_service_get_feature_value(as, FEATURE_STUTTER_MODE,
 			&(mem_input80->supported_stutter_mode),
 			sizeof(mem_input80->supported_stutter_mode));
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.h
index 357b9e2..6d589f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.h
@@ -30,6 +30,7 @@
 bool dce80_mem_input_construct(
 	struct dce110_mem_input *mem_input80,
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 6b78671..055e6e1 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -364,6 +364,7 @@ static struct stream_encoder *dce80_stream_encoder_create(
 
 static struct mem_input *dce80_mem_input_create(
 	struct dc_context *ctx,
+	struct adapter_service *as,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets)
 {
@@ -374,7 +375,7 @@ static struct mem_input *dce80_mem_input_create(
 		return NULL;
 
 	if (dce80_mem_input_construct(mem_input80,
-			ctx, inst, offsets))
+				      ctx, as, inst, offsets))
 		return &mem_input80->base;
 
 	BREAK_TO_DEBUGGER();
@@ -793,7 +794,7 @@ bool dce80_construct_resource_pool(
 			goto controller_create_fail;
 		}
 
-		pool->mis[i] = dce80_mem_input_create(ctx, i,
+                pool->base.mis[i] = dce80_mem_input_create(ctx, as, i,
 				&dce80_mi_reg_offsets[i]);
 		if (pool->mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index e498098..b499d8e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -705,7 +705,7 @@ static bool display_clock_integrated_info_construct(
 	disp_clk->dfs_bypass_enabled =
 		dal_adapter_service_is_dfs_bypass_enabled(as);
 	disp_clk->use_max_disp_clk =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(as,
 			FEATURE_USE_MAX_DISPLAY_CLK);
 
 	return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
index 34d1e72..75a0dec 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
@@ -694,7 +694,7 @@ static bool display_clock_integrated_info_construct(
 	disp_clk->dfs_bypass_enabled =
 		dal_adapter_service_is_dfs_bypass_enabled(as);
 	disp_clk->use_max_disp_clk =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(as,
 			FEATURE_USE_MAX_DISPLAY_CLK);
 
 	return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
index 9f01d16..7ef06fd 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
@@ -782,11 +782,11 @@ static bool display_clock_integrated_info_construct(
 
 	disp_clk->dfs_bypass_enabled =
 		dal_adapter_service_is_dfs_bypass_enabled(as) &&
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(as,
 			FEATURE_ENABLE_DFS_BYPASS);
 
 	disp_clk->use_max_disp_clk =
-		dal_adapter_service_is_feature_supported(
+		dal_adapter_service_is_feature_supported(as,
 			FEATURE_USE_MAX_DISPLAY_CLK);
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
index 2470c77..e6489c7 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
@@ -164,7 +164,7 @@ static bool construct(
 	reference_frequency =
 		dal_i2caux_get_reference_clock(as) >> 1;
 
-	use_i2c_sw_engine = dal_adapter_service_is_feature_supported(
+	use_i2c_sw_engine = dal_adapter_service_is_feature_supported(as,
 		FEATURE_RESTORE_USAGE_I2C_SW_ENGINE);
 
 	base = &i2caux_dce110->base;
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
index 1e5c2ad..7d49e40 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
@@ -170,7 +170,7 @@ static bool construct(
 	uint32_t reference_frequency =
 		dal_i2caux_get_reference_clock(as) >> 1;
 
-	/*bool use_i2c_sw_engine = dal_adapter_service_is_feature_supported(
+	/*bool use_i2c_sw_engine = dal_adapter_service_is_feature_supported(as,
 		FEATURE_RESTORE_USAGE_I2C_SW_ENGINE);*/
 
 	/* Use SWI2C for dce8 currently, sicne we have bug with hwi2c */
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
index 94424dd..432e426 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
@@ -384,11 +384,11 @@ bool dal_adapter_service_get_integrated_info(
 	struct integrated_info *info);
 
 /* Return if a given feature is supported by the ASIC */
-bool dal_adapter_service_is_feature_supported(
+bool dal_adapter_service_is_feature_supported(struct adapter_service *as,
 	enum adapter_feature_id feature_id);
 
 /* Get the cached value of a given feature */
-bool dal_adapter_service_get_feature_value(
+bool dal_adapter_service_get_feature_value(struct adapter_service *as,
 	const enum adapter_feature_id feature_id,
 	void *data,
 	uint32_t size);
-- 
2.7.4

