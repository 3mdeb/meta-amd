From f35184c340d5f7396d152b7035a2e430af3f8d66 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Thu, 15 Sep 2016 14:50:36 -0400
Subject: [PATCH 1108/1722] drm/amd/dal: (Workaround) Fix front end reset

Root cause is losing track of current state between surface update
and post surface update parts of surface commit. This workaround resets
hw during the surface update part.

Change-Id: I5d5fd34ebf9b481143a98bf2c93f37d5fda3e096
Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 53 ++++++++++------------
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 28 ++++++++----
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |  1 +
 3 files changed, 44 insertions(+), 38 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 0e6e143..5ce3fc9 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -1225,13 +1225,8 @@ bool dc_post_update_surfaces_to_target(struct dc *dc)
 
 	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count; i++) {
 		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL) {
-			core_dc->hwss.enable_display_power_gating(
-				core_dc, i, core_dc->ctx->dc_bios,
-				PIPE_GATING_CONTROL_ENABLE);
-			if (core_dc->current_context->res_ctx.pipe_ctx[i].xfm)
-				core_dc->current_context->res_ctx.pipe_ctx[i].xfm->funcs->transform_reset(
-						core_dc->current_context->res_ctx.pipe_ctx[i].xfm);
-			memset(&core_dc->current_context->res_ctx.pipe_ctx[i].scl_data, 0, sizeof(struct scaler_data));
+			core_dc->hwss.power_down_front_end(
+				core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
 		}
 	}
 
@@ -1351,7 +1346,7 @@ bool dc_commit_surfaces_to_target(
 				context->bw_results.dispclk_khz;
 	}
 
-	for (i = 0; i < new_surface_count; i++)
+	for (i = 0; i < new_surface_count; i++) {
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx =
 						&context->res_ctx.pipe_ctx[j];
@@ -1376,10 +1371,18 @@ bool dc_commit_surfaces_to_target(
 					true);
 
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-
-			core_dc->hwss.apply_ctx_for_surface(
-						core_dc, pipe_ctx->surface, context);
 		}
+		core_dc->hwss.apply_ctx_for_surface(
+			core_dc, DC_SURFACE_TO_CORE(new_surfaces[i]), context);
+	}
+	/* TODO W/A, get rid of this*/
+	if (!new_surface_count)
+		core_dc->hwss.apply_ctx_for_surface(
+			core_dc, 0, context);
+
+	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
+		target_disable_memory_requests(dc_target,
+				&context->res_ctx);
 
 	/* Go in reverse order so that all pipes are unlocked simultaneously
 	 * when pipe 0 is unlocked
@@ -1403,23 +1406,10 @@ bool dc_commit_surfaces_to_target(
 	dm_free(core_dc->current_context);
 	core_dc->current_context = context;
 
-	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
-		target_disable_memory_requests(dc_target,
-				&context->res_ctx);
-
-
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
-		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
-			core_dc->hwss.enable_display_power_gating(
-				core_dc, i, core_dc->ctx->dc_bios,
-				PIPE_GATING_CONTROL_ENABLE);
-			if (context->res_ctx.pipe_ctx[i].xfm)
-				context->res_ctx.pipe_ctx[i].xfm->funcs->transform_reset(
-						context->res_ctx.pipe_ctx[i].xfm);
-			memset(&context->res_ctx.pipe_ctx[i].scl_data,
-					0, sizeof(struct scaler_data));
-		}
-	}
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
+		if (context->res_ctx.pipe_ctx[i].surface == NULL)
+			core_dc->hwss.power_down_front_end(
+				core_dc, &context->res_ctx.pipe_ctx[i]);
 
 	core_dc->hwss.set_bandwidth(core_dc);
 
@@ -1553,6 +1543,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+		bool apply_ctx = false;
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1572,6 +1563,8 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			if (updates[i].plane_info || updates[i].scaling_info
 					|| is_new_pipe_surface[j]) {
 
+				apply_ctx = true;
+
 				core_dc->hwss.pipe_control_lock(
 						core_dc->ctx,
 						pipe_ctx->pipe_idx,
@@ -1581,14 +1574,14 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 						PIPE_LOCK_CONTROL_BLENDER |
 						PIPE_LOCK_CONTROL_MODE,
 						true);
-				core_dc->hwss.apply_ctx_for_surface(
-						core_dc, surface, context);
 			}
 
 			if (updates[i].gamma)
 				core_dc->hwss.prepare_pipe_for_context(
 						core_dc, pipe_ctx, context);
 		}
+		if (apply_ctx)
+			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
 	}
 
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 106cc99..7db034f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -942,10 +942,9 @@ static void disable_vga_and_power_gate_all_controllers(
 		 * powergating. */
 		enable_display_pipe_clock_gating(ctx,
 				true);
-		dc->hwss.enable_display_power_gating(dc, i, dcb,
-				PIPE_GATING_CONTROL_ENABLE);
-		dc->res_pool->transforms[i]->funcs->transform_reset(
-				dc->res_pool->transforms[i]);
+
+		dc->hwss.power_down_front_end(
+			dc, &dc->current_context->res_ctx.pipe_ctx[i]);
 	}
 }
 
@@ -1331,9 +1330,8 @@ static void reset_single_pipe_hw_ctx(
 	pipe_ctx->xfm->funcs->transform_set_scaler_bypass(pipe_ctx->xfm, NULL);
 	pipe_ctx->xfm->funcs->transform_reset(pipe_ctx->xfm);
 	resource_unreference_clock_source(&context->res_ctx, pipe_ctx->clock_source);
-	dc->hwss.enable_display_power_gating(
-		(struct core_dc *)dc, pipe_ctx->pipe_idx, dcb,
-			PIPE_GATING_CONTROL_ENABLE);
+
+	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
 
 	pipe_ctx->stream = NULL;
 }
@@ -2082,6 +2080,10 @@ static void dce110_apply_ctx_for_surface(
 {
 	int i;
 
+	/* TODO remove when removing the surface reset workaroud*/
+	if (!surface)
+		return;
+
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
@@ -2095,6 +2097,15 @@ static void dce110_apply_ctx_for_surface(
 
 }
 
+static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
+{
+	dc->hwss.enable_display_power_gating(
+		dc, pipe->pipe_idx, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
+	if (pipe->xfm)
+		pipe->xfm->funcs->transform_reset(pipe->xfm);
+	memset(&pipe->scl_data, 0, sizeof(struct scaler_data));
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = apply_ctx_to_hw,
@@ -2113,10 +2124,11 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
 	.crtc_switch_to_clk_src = dce110_crtc_switch_to_clk_src,
 	.enable_display_power_gating = dce110_enable_display_power_gating,
+	.power_down_front_end = dce110_power_down_fe,
 	.enable_fe_clock = dce110_enable_fe_clock,
 	.pipe_control_lock = dce110_pipe_control_lock,
 	.set_blender_mode = dce110_set_blender_mode,
-	.clock_gating_power_up = dal_dc_clock_gating_dce110_power_up,/*todo*/
+	.clock_gating_power_up = dal_dc_clock_gating_dce110_power_up,
 	.set_display_clock = set_display_clock,
 	.set_displaymarks = set_displaymarks,
 	.increase_watermarks_for_pipe = dce110_increase_watermarks_for_pipe,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 20b0ece..4586b11 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -108,6 +108,7 @@ struct hw_sequencer_funcs {
 					struct dc_bios *dcb,
 					enum pipe_gating_control power_gating);
 
+	void (*power_down_front_end)(struct core_dc *dc, struct pipe_ctx *pipe);
 	void (*update_info_frame)(struct pipe_ctx *pipe_ctx);
 
 	void (*enable_stream)(struct pipe_ctx *pipe_ctx);
-- 
2.7.4

