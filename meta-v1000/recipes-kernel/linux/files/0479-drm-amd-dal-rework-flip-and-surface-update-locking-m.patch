From 606fe3a9807be1c5702bdbb1630cd1f3e95254c8 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Wed, 11 May 2016 14:22:09 -0400
Subject: [PATCH 0479/1722] drm/amd/dal: rework flip and surface update locking
 mechanics

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 125 +++++++++++++++------
 .../drm/amd/dal/dc/dce100/dce100_hw_sequencer.c    |   8 --
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  65 ++---------
 .../drm/amd/dal/dc/dce112/dce112_hw_sequencer.c    |   8 --
 .../gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c  |   8 --
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |  12 +-
 6 files changed, 115 insertions(+), 111 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 7c715e9..a27b40f 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -910,7 +910,7 @@ bool dc_commit_surfaces_to_target(
 				&core_dc->current_context.res_ctx);
 
 	for (i = 0; i < new_surface_count; i++)
-		for (j = 0; j < MAX_PIPES; j++) {
+		for (j = 0; j < context->res_ctx.pool.pipe_count; j++) {
 			struct dc_surface *dc_surface = new_surfaces[i];
 			struct core_surface *surface =
 						DC_SURFACE_TO_CORE(dc_surface);
@@ -923,27 +923,43 @@ bool dc_commit_surfaces_to_target(
 				continue;
 
 			dal_logger_write(core_dc->ctx->logger,
-						LOG_MAJOR_INTERFACE_TRACE,
-						LOG_MINOR_COMPONENT_DC,
-					   "Pipe:%d 0x%x: addr hi:0x%x, "
-					   "addr low:0x%x, "
-					   "src: %d, %d, %d,"
-						" %d; dst: %d, %d, %d, %d;\n",
-						pipe_ctx->pipe_idx,
-						dc_surface,
-					    dc_surface->address.grph.addr.high_part,
-					    dc_surface->address.grph.addr.low_part,
-						dc_surface->src_rect.x,
-						dc_surface->src_rect.y,
-						dc_surface->src_rect.width,
-						dc_surface->src_rect.height,
-						dc_surface->dst_rect.x,
-						dc_surface->dst_rect.y,
-						dc_surface->dst_rect.width,
-						dc_surface->dst_rect.height);
+					LOG_MAJOR_INTERFACE_TRACE,
+					LOG_MINOR_COMPONENT_DC,
+					"Pipe:%d 0x%x: addr hi:0x%x, "
+					"addr low:0x%x, "
+					"src: %d, %d, %d,"
+					" %d; dst: %d, %d, %d, %d;\n",
+					pipe_ctx->pipe_idx,
+					dc_surface,
+					dc_surface->address.grph.addr.high_part,
+					dc_surface->address.grph.addr.low_part,
+					dc_surface->src_rect.x,
+					dc_surface->src_rect.y,
+					dc_surface->src_rect.width,
+					dc_surface->src_rect.height,
+					dc_surface->dst_rect.x,
+					dc_surface->dst_rect.y,
+					dc_surface->dst_rect.width,
+					dc_surface->dst_rect.height);
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_MODE,
+					false);
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_GRAPHICS |
+					PIPE_LOCK_CONTROL_SCL |
+					PIPE_LOCK_CONTROL_BLENDER |
+					PIPE_LOCK_CONTROL_SURFACE,
+					true);
 
 			core_dc->hwss.set_plane_config(
-				core_dc, pipe_ctx, &context->res_ctx);
+					core_dc, pipe_ctx, &context->res_ctx);
+
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 
 			if (surface->public.gamma_correction)
 				gamma = DC_GAMMA_TO_CORE(
@@ -955,7 +971,28 @@ bool dc_commit_surfaces_to_target(
 					gamma, surface);
 		}
 
-	core_dc->hwss.update_plane_addrs(core_dc, &context->res_ctx);
+	/* Go in reverse order so that all pipes are unlocked simultaneously
+	 * when pipe 0 is unlocked
+	 * Need PIPE_LOCK_CONTROL_MODE to be 1 for this
+	 */
+	for (j = context->res_ctx.pool.pipe_count - 1; j >= 0; j--)
+		for (i = new_surface_count - 1; i >= 0; i--) {
+			struct pipe_ctx *pipe_ctx =
+						&context->res_ctx.pipe_ctx[j];
+
+			if (pipe_ctx->surface !=
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_GRAPHICS |
+					PIPE_LOCK_CONTROL_SCL |
+					PIPE_LOCK_CONTROL_BLENDER |
+					PIPE_LOCK_CONTROL_SURFACE,
+					false);
+		}
 
 	/* Lower display clock if necessary */
 	if (prev_disp_clk > context->bw_results.dispclk_khz) {
@@ -1033,20 +1070,44 @@ void dc_flip_surface_addrs(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i, j;
+	int pipe_count = core_dc->current_context.res_ctx.pool.pipe_count;
 
-	for (i = 0; i < count; i++) {
-		for (j = 0; j < MAX_PIPES; j++) {
-			struct core_surface *ctx_surface =
-				core_dc->current_context.res_ctx.pipe_ctx[j].surface;
-			if (DC_SURFACE_TO_CORE(surfaces[i]) == ctx_surface) {
-				ctx_surface->public.address = flip_addrs[i].address;
-				ctx_surface->public.flip_immediate = flip_addrs[i].flip_immediate;
-				break;
-			}
+	for (i = 0; i < count; i++)
+		for (j = 0; j < pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&core_dc->current_context.res_ctx.pipe_ctx[j];
+			struct core_surface *ctx_surface = pipe_ctx->surface;
+
+			if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
+				continue;
+
+			ctx_surface->public.address = flip_addrs[i].address;
+			ctx_surface->public.flip_immediate = flip_addrs[i].flip_immediate;
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_SURFACE,
+					true);
+
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 		}
-	}
 
-	core_dc->hwss.update_plane_addrs(core_dc, &core_dc->current_context.res_ctx);
+	for (j = pipe_count - 1; j >= 0; j--)
+		for (i = count - 1; i >= 0; i--) {
+			struct pipe_ctx *pipe_ctx =
+				&core_dc->current_context.res_ctx.pipe_ctx[j];
+			struct core_surface *ctx_surface = pipe_ctx->surface;
+
+			if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
+				continue;
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_SURFACE,
+					false);
+		}
 }
 
 enum dc_irq_source dc_interrupt_to_irq_source(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
index 3e1e079..496a8d0 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
@@ -39,14 +39,6 @@ struct dce100_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
 
-enum pipe_lock_control {
-	PIPE_LOCK_CONTROL_GRAPHICS = 1 << 0,
-	PIPE_LOCK_CONTROL_BLENDER = 1 << 1,
-	PIPE_LOCK_CONTROL_SCL = 1 << 2,
-	PIPE_LOCK_CONTROL_SURFACE = 1 << 3,
-	PIPE_LOCK_CONTROL_MODE = 1 << 4
-};
-
 enum blender_mode {
 	BLENDER_MODE_CURRENT_PIPE = 0,/* Data from current pipe only */
 	BLENDER_MODE_OTHER_PIPE, /* Data from other pipe only */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 5f098a3f..eec1fe1 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -55,14 +55,6 @@ struct dce110_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
 
-enum pipe_lock_control {
-	PIPE_LOCK_CONTROL_GRAPHICS = 1 << 0,
-	PIPE_LOCK_CONTROL_BLENDER = 1 << 1,
-	PIPE_LOCK_CONTROL_SCL = 1 << 2,
-	PIPE_LOCK_CONTROL_SURFACE = 1 << 3,
-	PIPE_LOCK_CONTROL_MODE = 1 << 4
-};
-
 enum blender_mode {
 	BLENDER_MODE_CURRENT_PIPE = 0,/* Data from current pipe only */
 	BLENDER_MODE_OTHER_PIPE, /* Data from other pipe only */
@@ -1378,20 +1370,6 @@ static void set_plane_config(
 	struct core_surface *surface = pipe_ctx->surface;
 	enum blender_mode blender_mode = BLENDER_MODE_CURRENT_PIPE;
 
-	dc->hwss.pipe_control_lock(
-		ctx, pipe_ctx->pipe_idx, PIPE_LOCK_CONTROL_MODE, false);
-
-	/* While a non-root controller is programmed we
-	 * have to lock the root controller. */
-	dc->hwss.pipe_control_lock(
-			ctx,
-			pipe_ctx->pipe_idx,
-			PIPE_LOCK_CONTROL_GRAPHICS |
-			PIPE_LOCK_CONTROL_SCL |
-			PIPE_LOCK_CONTROL_BLENDER |
-			PIPE_LOCK_CONTROL_SURFACE,
-			true);
-
 	tg->funcs->program_timing(tg, crtc_timing, false);
 	tg->funcs->enable_advanced_request(
 			tg,
@@ -1427,49 +1405,30 @@ static void set_plane_config(
 			surface->public.rotation);
 }
 
-static void update_plane_addrs(struct core_dc *dc, struct resource_context *res_ctx)
+static void update_plane_addr(struct core_dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	int j;
-
-	/* Go through pipes in reverse order to avoid underflow on unlock */
-	for (j = MAX_PIPES - 1; j >= 0; j--) {
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[j];
-		struct core_surface *surface = pipe_ctx->surface;
-
-		if (surface == NULL ||
-			surface->status.requested_address.grph.addr.quad_part
-			== surface->public.address.grph.addr.quad_part)
-			continue;
+	struct core_surface *surface = pipe_ctx->surface;
 
-		dc->hwss.pipe_control_lock(
-			dc->ctx,
-			j,
-			PIPE_LOCK_CONTROL_SURFACE,
-			true);
+	if (surface == NULL)
+		return;
 
-			pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
+	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
 			&surface->public.address,
 			surface->public.flip_immediate);
 
-		surface->status.requested_address = surface->public.address;
+	surface->status.requested_address = surface->public.address;
+
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, false);
 
+	if (surface->public.flip_immediate) {
 		dc->hwss.pipe_control_lock(
 					dc->ctx,
 					pipe_ctx->pipe_idx,
-					PIPE_LOCK_CONTROL_GRAPHICS |
-					PIPE_LOCK_CONTROL_SCL |
-					PIPE_LOCK_CONTROL_BLENDER |
 					PIPE_LOCK_CONTROL_SURFACE,
 					false);
-
-		if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, false)) {
-			dm_error("DC: failed to unblank crtc!\n");
-			BREAK_TO_DEBUGGER();
-		}
-
-		if (surface->public.flip_immediate)
-			pipe_ctx->mi->funcs->wait_for_no_surface_update_pending(pipe_ctx->mi);
+		pipe_ctx->mi->funcs->wait_for_no_surface_update_pending(
+								pipe_ctx->mi);
 	}
 }
 
@@ -1626,7 +1585,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = apply_ctx_to_hw,
 	.set_plane_config = set_plane_config,
-	.update_plane_addrs = update_plane_addrs,
+	.update_plane_addr = update_plane_addr,
 	.set_gamma_correction = set_gamma_ramp,
 	.power_down = power_down,
 	.enable_accelerated_mode = enable_accelerated_mode,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
index 437b4c3..3354e93 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
@@ -42,14 +42,6 @@ struct dce112_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
 
-enum pipe_lock_control {
-	PIPE_LOCK_CONTROL_GRAPHICS = 1 << 0,
-	PIPE_LOCK_CONTROL_BLENDER = 1 << 1,
-	PIPE_LOCK_CONTROL_SCL = 1 << 2,
-	PIPE_LOCK_CONTROL_SURFACE = 1 << 3,
-	PIPE_LOCK_CONTROL_MODE = 1 << 4
-};
-
 enum blender_mode {
 	BLENDER_MODE_CURRENT_PIPE = 0,/* Data from current pipe only */
 	BLENDER_MODE_OTHER_PIPE, /* Data from other pipe only */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
index e99d694..92ed13c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
@@ -42,14 +42,6 @@ struct dce80_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
 
-enum pipe_lock_control {
-	PIPE_LOCK_CONTROL_GRAPHICS = 1 << 0,
-	PIPE_LOCK_CONTROL_BLENDER = 1 << 1,
-	PIPE_LOCK_CONTROL_SCL = 1 << 2,
-	PIPE_LOCK_CONTROL_SURFACE = 1 << 3,
-	PIPE_LOCK_CONTROL_MODE = 1 << 4
-};
-
 enum blender_mode {
 	BLENDER_MODE_CURRENT_PIPE = 0,/* Data from current pipe only */
 	BLENDER_MODE_OTHER_PIPE, /* Data from other pipe only */
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 3add573..36e91d2 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -35,6 +35,14 @@ enum pipe_gating_control {
 	PIPE_GATING_CONTROL_INIT
 };
 
+enum pipe_lock_control {
+	PIPE_LOCK_CONTROL_GRAPHICS = 1 << 0,
+	PIPE_LOCK_CONTROL_BLENDER = 1 << 1,
+	PIPE_LOCK_CONTROL_SCL = 1 << 2,
+	PIPE_LOCK_CONTROL_SURFACE = 1 << 3,
+	PIPE_LOCK_CONTROL_MODE = 1 << 4
+};
+
 struct hw_sequencer_funcs {
 
 	void (*init_hw)(struct core_dc *dc);
@@ -47,9 +55,9 @@ struct hw_sequencer_funcs {
 			struct pipe_ctx *pipe_ctx,
 			struct resource_context *res_ctx);
 
-	void (*update_plane_addrs)(
+	void (*update_plane_addr)(
 		struct core_dc *dc,
-		struct resource_context *res_ctx);
+		struct pipe_ctx *pipe_ctx);
 
 	bool (*set_gamma_correction)(
 				struct input_pixel_processor *ipp,
-- 
2.7.4

