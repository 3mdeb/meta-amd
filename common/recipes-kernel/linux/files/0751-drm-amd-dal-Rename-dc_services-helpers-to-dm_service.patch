From 48a216deab451d0091b8b90f64e66275f6e99bba Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 29 Jan 2016 12:02:29 -0500
Subject: [PATCH 0751/1110] drm/amd/dal: Rename dc_services/helpers to
 dm_services/helpers

Also renaming functions to keep consistency.

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/amdgpu_dm/Makefile         |   2 +-
 .../drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c    | 457 -------------------
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c  | 474 --------------------
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      |   6 +-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c  | 473 ++++++++++++++++++++
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c  |   2 +-
 .../drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c    |   9 +-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c | 457 +++++++++++++++++++
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    |  11 +-
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c   |  20 +-
 .../adapter/dce110/hw_ctx_adapter_service_dce110.c |  19 +-
 .../diagnostics/hw_ctx_adapter_service_diag.c      |   6 +-
 .../amd/dal/dc/adapter/hw_ctx_adapter_service.c    |   2 +-
 .../drm/amd/dal/dc/adapter/wireless_data_source.c  |   2 +-
 .../amd/dal/dc/asic_capability/asic_capability.c   |  10 +-
 .../dc/asic_capability/carrizo_asic_capability.c   |   6 +-
 .../dal/dc/asic_capability/tonga_asic_capability.c |   5 +-
 drivers/gpu/drm/amd/dal/dc/audio/audio_base.c      |   4 +-
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c |   9 +-
 .../amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c  | 155 +++----
 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c    |   2 +-
 drivers/gpu/drm/amd/dal/dc/basics/conversion.c     |   3 +-
 drivers/gpu/drm/amd/dal/dc/basics/fixpt31_32.c     |   2 +-
 drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c     |   2 +-
 drivers/gpu/drm/amd/dal/dc/basics/grph_object_id.c |   7 +-
 drivers/gpu/drm/amd/dal/dc/basics/logger.c         |  44 +-
 .../gpu/drm/amd/dal/dc/basics/register_logger.c    |  28 +-
 drivers/gpu/drm/amd/dal/dc/basics/signal_types.c   |   2 +-
 drivers/gpu/drm/amd/dal/dc/basics/vector.c         |  32 +-
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c      |  48 +-
 .../gpu/drm/amd/dal/dc/bios/bios_parser_helper.c   |   2 +-
 drivers/gpu/drm/amd/dal/dc/bios/command_table.c    |  46 +-
 .../gpu/drm/amd/dal/dc/bios/command_table_helper.c |   2 +-
 .../dal/dc/bios/dce110/bios_parser_helper_dce110.c |  34 +-
 .../dc/bios/dce110/command_table_helper_dce110.c   |   3 +-
 drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c |  11 +-
 drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c        |   2 +-
 drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c   |  50 +--
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  56 +--
 drivers/gpu/drm/amd/dal/dc/core/dc_hw_sequencer.c  |   2 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  38 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c      |  26 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c       |  29 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c     |  10 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  22 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_sink.c          |  10 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_stream.c        |  13 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_surface.c       |   8 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_target.c        |  27 +-
 drivers/gpu/drm/amd/dal/dc/dc_helpers.h            |  98 -----
 drivers/gpu/drm/amd/dal/dc/dc_services.h           | 490 ---------------------
 drivers/gpu/drm/amd/dal/dc/dc_services_types.h     | 167 -------
 drivers/gpu/drm/amd/dal/dc/dc_types.h              |   2 +-
 .../drm/amd/dal/dc/dce100/dce100_hw_sequencer.c    |  18 +-
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  94 ++--
 .../drm/amd/dal/dc/dce110/dce110_clock_source.c    |  22 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_compressor.c  | 108 ++---
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  44 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c     |   4 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c  |  32 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_ipp_gamma.c   |  96 ++--
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    | 123 +++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c   | 132 +++---
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c     |  63 +--
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c |  24 +-
 .../drm/amd/dal/dc/dce110/dce110_opp_formatter.c   |  54 +--
 .../gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c |  62 +--
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  77 ++--
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  | 147 ++++---
 .../amd/dal/dc/dce110/dce110_timing_generator.c    | 147 ++++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform.c   |   3 +-
 .../amd/dal/dc/dce110/dce110_transform_bit_depth.c |  32 +-
 .../drm/amd/dal/dc/dce110/dce110_transform_gamut.c |  18 +-
 .../drm/amd/dal/dc/dce110/dce110_transform_scl.c   |  80 ++--
 .../drm/amd/dal/dc/dce110/dce110_transform_sclv.c  |  50 +--
 drivers/gpu/drm/amd/dal/dc/dm_helpers.h            |  98 +++++
 drivers/gpu/drm/amd/dal/dc/dm_services.h           | 476 ++++++++++++++++++++
 drivers/gpu/drm/amd/dal/dc/dm_services_types.h     | 167 +++++++
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c |  35 +-
 .../drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c |   3 +-
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c |  15 +-
 .../amd/dal/dc/gpio/dce110/hw_translate_dce110.c   |   2 +-
 drivers/gpu/drm/amd/dal/dc/gpio/ddc.c              |   8 +-
 .../drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c  |   9 +-
 .../amd/dal/dc/gpio/diagnostics/hw_factory_diag.c  |   2 +-
 .../drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c  |   9 +-
 .../dal/dc/gpio/diagnostics/hw_translate_diag.c    |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c        |   6 +-
 drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c     |  14 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c           |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c       |   5 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio.c          |   9 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pad.c      |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pin.c      |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.c           |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_translate.c     |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpio/irq.c              |   9 +-
 .../gpu/drm/amd/dal/dc/gpu/dc_clock_generator.c    |   2 +-
 .../amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c |   6 +-
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |  22 +-
 drivers/gpu/drm/amd/dal/dc/gpu/display_clock.c     |   3 +-
 drivers/gpu/drm/amd/dal/dc/gpu/divider_range.c     |   2 +-
 drivers/gpu/drm/amd/dal/dc/i2caux/aux_engine.c     |  15 +-
 .../amd/dal/dc/i2caux/dce110/aux_engine_dce110.c   | 103 +++--
 .../dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c    |  76 ++--
 .../dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c    |  10 +-
 .../drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c   |  10 +-
 .../amd/dal/dc/i2caux/diagnostics/i2caux_diag.c    |   9 +-
 drivers/gpu/drm/amd/dal/dc/i2caux/engine_base.c    |   3 +-
 drivers/gpu/drm/amd/dal/dc/i2caux/i2c_engine.c     |   5 +-
 .../drm/amd/dal/dc/i2caux/i2c_generic_hw_engine.c  |   3 +-
 drivers/gpu/drm/amd/dal/dc/i2caux/i2c_hw_engine.c  |   5 +-
 drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c  |  49 +--
 drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c         |   3 +-
 drivers/gpu/drm/amd/dal/dc/inc/gamma_types.h       |   3 +-
 drivers/gpu/drm/amd/dal/dc/inc/opp.h               |   2 +-
 .../drm/amd/dal/dc/irq/dce110/irq_service_dce110.c |  12 +-
 drivers/gpu/drm/amd/dal/dc/irq/irq_service.c       |  12 +-
 .../drm/amd/dal/dc/virtual/virtual_link_encoder.c  |   2 +-
 .../amd/dal/dc/virtual/virtual_stream_encoder.c    |   7 +-
 .../gpu/drm/amd/dal/include/bios_parser_types.h    |   3 +-
 drivers/gpu/drm/amd/dal/include/fixed32_32.h       |   2 +-
 122 files changed, 3055 insertions(+), 3076 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c
 delete mode 100644 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c
 create mode 100644 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
 create mode 100644 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/dc_helpers.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/dc_services.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/dc_services_types.h
 create mode 100644 drivers/gpu/drm/amd/dal/dc/dm_helpers.h
 create mode 100644 drivers/gpu/drm/amd/dal/dc/dm_services.h
 create mode 100644 drivers/gpu/drm/amd/dal/dc/dm_services_types.h

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/Makefile b/drivers/gpu/drm/amd/dal/amdgpu_dm/Makefile
index 65ad370..0f365c6 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/Makefile
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/Makefile
@@ -7,7 +7,7 @@
 AMDGPUDM = amdgpu_dm_types.o amdgpu_dm.o amdgpu_dm_irq.o amdgpu_dm_mst_types.o
 
 ifneq ($(CONFIG_DRM_AMD_DAL),)
-AMDGPUDM += amdgpu_dal_services.o amdgpu_dc_helpers.o
+AMDGPUDM += amdgpu_dm_services.o amdgpu_dm_helpers.o
 endif
 
 subdir-ccflags-y += -I$(FULL_AMD_DAL_PATH)/dc
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c
deleted file mode 100644
index eec5313..0000000
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
- * Copyright 2015 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include <linux/string.h>
-#include <linux/acpi.h>
-
-#include <drm/drmP.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/amdgpu_drm.h>
-#include "amdgpu.h"
-#include "dc_services.h"
-#include "amdgpu_dm.h"
-#include "amdgpu_dm_irq.h"
-#include "amdgpu_dm_types.h"
-#include "amdgpu_pm.h"
-
-/*
-#include "logger_interface.h"
-#include "acpimethod_atif.h"
-#include "amdgpu_powerplay.h"
-#include "amdgpu_notifications.h"
-*/
-
-/* if the pointer is not NULL, the allocated memory is zeroed */
-void *dc_service_alloc(struct dc_context *ctx, uint32_t size)
-{
-	return kzalloc(size, GFP_KERNEL);
-}
-
-/* Reallocate memory. The contents will remain unchanged.*/
-void *dc_service_realloc(struct dc_context *ctx, const void *ptr, uint32_t size)
-{
-	return krealloc(ptr, size, GFP_KERNEL);
-}
-
-void dc_service_memmove(void *dst, const void *src, uint32_t size)
-{
-	memmove(dst, src, size);
-}
-
-void dc_service_free(struct dc_context *ctx, void *p)
-{
-	kfree(p);
-}
-
-void dc_service_memset(void *p, int32_t c, uint32_t count)
-{
-	memset(p, c, count);
-}
-
-int32_t dal_memcmp(const void *p1, const void *p2, uint32_t count)
-{
-	return memcmp(p1, p2, count);
-}
-
-int32_t dal_strncmp(const int8_t *p1, const int8_t *p2, uint32_t count)
-{
-	return strncmp(p1, p2, count);
-}
-
-void dc_service_sleep_in_milliseconds(struct dc_context *ctx, uint32_t milliseconds)
-{
-	if (milliseconds >= 20)
-		msleep(milliseconds);
-	else
-		usleep_range(milliseconds*1000, milliseconds*1000+1);
-}
-
-void dal_delay_in_nanoseconds(uint32_t nanoseconds)
-{
-	ndelay(nanoseconds);
-}
-
-void dc_service_delay_in_microseconds(struct dc_context *ctx, uint32_t microseconds)
-{
-	udelay(microseconds);
-}
-
-/******************************************************************************
- * IRQ Interfaces.
- *****************************************************************************/
-
-void dal_register_timer_interrupt(
-	struct dc_context *ctx,
-	struct dc_timer_interrupt_params *int_params,
-	interrupt_handler ih,
-	void *args)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-
-	if (!adev || !int_params) {
-		DRM_ERROR("DM_IRQ: invalid input!\n");
-		return;
-	}
-
-	if (int_params->int_context != INTERRUPT_LOW_IRQ_CONTEXT) {
-		/* only low irq ctx is supported. */
-		DRM_ERROR("DM_IRQ: invalid context: %d!\n",
-				int_params->int_context);
-		return;
-	}
-
-	amdgpu_dm_irq_register_timer(adev, int_params, ih, args);
-}
-
-void dal_isr_acquire_lock(struct dc_context *ctx)
-{
-	/*TODO*/
-}
-
-void dal_isr_release_lock(struct dc_context *ctx)
-{
-	/*TODO*/
-}
-
-/******************************************************************************
- * End-of-IRQ Interfaces.
- *****************************************************************************/
-
-bool dal_get_platform_info(struct dc_context *ctx,
-			struct platform_info_params *params)
-{
-	/*TODO*/
-	return false;
-}
-
-/**** power component interfaces ****/
-
-bool dc_service_pp_pre_dce_clock_change(
-		struct dc_context *ctx,
-		struct dal_to_power_info *input,
-		struct power_to_dal_info *output)
-{
-	/*TODO*/
-	return false;
-}
-
-bool dc_service_pp_apply_safe_state(
-		const struct dc_context *ctx)
-{
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	struct amdgpu_device *adev = ctx->driver_context;
-
-	if (adev->pm.dpm_enabled) {
-		/* TODO: Does this require PreModeChange event to PPLIB? */
-	}
-
-	return true;
-#else
-	return false;
-#endif
-}
-
-bool dc_service_pp_apply_display_requirements(
-		const struct dc_context *ctx,
-		const struct dc_pp_display_configuration *pp_display_cfg)
-{
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	struct amdgpu_device *adev = ctx->driver_context;
-
-	if (adev->pm.dpm_enabled) {
-
-		memset(&adev->pm.pm_display_cfg, 0,
-				sizeof(adev->pm.pm_display_cfg));
-
-		adev->pm.pm_display_cfg.cpu_cc6_disable =
-			pp_display_cfg->cpu_cc6_disable;
-
-		adev->pm.pm_display_cfg.cpu_pstate_disable =
-			pp_display_cfg->cpu_pstate_disable;
-
-		adev->pm.pm_display_cfg.cpu_pstate_separation_time =
-			pp_display_cfg->cpu_pstate_separation_time;
-
-		adev->pm.pm_display_cfg.nb_pstate_switch_disable =
-			pp_display_cfg->nb_pstate_switch_disable;
-
-		adev->pm.pm_display_cfg.num_display =
-				pp_display_cfg->display_count;
-		adev->pm.pm_display_cfg.num_path_including_non_display =
-				pp_display_cfg->display_count;
-
-		adev->pm.pm_display_cfg.min_core_set_clock =
-				pp_display_cfg->min_engine_clock_khz/10;
-		adev->pm.pm_display_cfg.min_core_set_clock_in_sr =
-				pp_display_cfg->min_engine_clock_deep_sleep_khz/10;
-		adev->pm.pm_display_cfg.min_mem_set_clock =
-				pp_display_cfg->min_memory_clock_khz/10;
-
-		adev->pm.pm_display_cfg.multi_monitor_in_sync =
-				pp_display_cfg->all_displays_in_sync;
-		adev->pm.pm_display_cfg.min_vblank_time =
-				pp_display_cfg->avail_mclk_switch_time_us;
-
-		adev->pm.pm_display_cfg.display_clk =
-				pp_display_cfg->disp_clk_khz/10;
-
-		adev->pm.pm_display_cfg.dce_tolerable_mclk_in_active_latency =
-				pp_display_cfg->avail_mclk_switch_time_in_disp_active_us;
-
-		adev->pm.pm_display_cfg.crtc_index = pp_display_cfg->crtc_index;
-		adev->pm.pm_display_cfg.line_time_in_us =
-				pp_display_cfg->line_time_in_us;
-
-		adev->pm.pm_display_cfg.crossfire_display_index = -1;
-		adev->pm.pm_display_cfg.min_bus_bandwidth = 0;
-
-		/* TODO: complete implementation of
-		 * amd_powerplay_display_configuration_change().
-		 * Follow example of:
-		 * PHM_StoreDALConfigurationData - powerplay\hwmgr\hardwaremanager.c
-		 * PP_IRI_DisplayConfigurationChange - powerplay\eventmgr\iri.c */
-		amd_powerplay_display_configuration_change(
-				adev->powerplay.pp_handle,
-				&adev->pm.pm_display_cfg);
-
-		/* TODO: replace by a separate call to 'apply display cfg'? */
-		amdgpu_pm_compute_clocks(adev);
-	}
-
-	return true;
-#else
-	return false;
-#endif
-}
-
-bool dc_service_get_system_clocks_range(
-		const struct dc_context *ctx,
-		struct dal_system_clock_range *sys_clks)
-{
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	struct amdgpu_device *adev = ctx->driver_context;
-#endif
-
-	/* Default values, in case PPLib is not compiled-in. */
-	sys_clks->max_mclk = 80000;
-	sys_clks->min_mclk = 80000;
-
-	sys_clks->max_sclk = 60000;
-	sys_clks->min_sclk = 30000;
-
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	if (adev->pm.dpm_enabled) {
-		sys_clks->max_mclk = amdgpu_dpm_get_mclk(adev, false);
-		sys_clks->min_mclk = amdgpu_dpm_get_mclk(adev, true);
-
-		sys_clks->max_sclk = amdgpu_dpm_get_sclk(adev, false);
-		sys_clks->min_sclk = amdgpu_dpm_get_sclk(adev, true);
-	}
-#endif
-
-	return true;
-}
-
-static void get_default_clock_levels(
-		enum dc_pp_clock_type clk_type,
-		struct dc_pp_clock_levels *clks)
-{
-	uint32_t disp_clks_in_khz[6] = {
-			300000, 400000, 496560, 626090, 685720, 757900 };
-	uint32_t sclks_in_khz[6] = {
-			300000, 360000, 423530, 514290, 626090, 720000 };
-	uint32_t mclks_in_khz[2] = { 333000, 800000 };
-
-	switch (clk_type) {
-	case DC_PP_CLOCK_TYPE_DISPLAY_CLK:
-		clks->num_levels = 6;
-		dc_service_memmove(clks->clocks_in_khz, disp_clks_in_khz,
-				sizeof(disp_clks_in_khz));
-		break;
-	case DC_PP_CLOCK_TYPE_ENGINE_CLK:
-		clks->num_levels = 6;
-		dc_service_memmove(clks->clocks_in_khz, sclks_in_khz,
-				sizeof(sclks_in_khz));
-		break;
-	case DC_PP_CLOCK_TYPE_MEMORY_CLK:
-		clks->num_levels = 2;
-		dc_service_memmove(clks->clocks_in_khz, mclks_in_khz,
-				sizeof(mclks_in_khz));
-		break;
-	default:
-		clks->num_levels = 0;
-		break;
-	}
-}
-
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-static enum amd_pp_clock_type dc_to_pp_clock_type(
-		enum dc_pp_clock_type dc_pp_clk_type)
-{
-	enum amd_pp_clock_type amd_pp_clk_type = 0;
-
-	switch (dc_pp_clk_type) {
-	case DC_PP_CLOCK_TYPE_DISPLAY_CLK:
-		amd_pp_clk_type = amd_pp_disp_clock;
-		break;
-	case DC_PP_CLOCK_TYPE_ENGINE_CLK:
-		amd_pp_clk_type = amd_pp_sys_clock;
-		break;
-	case DC_PP_CLOCK_TYPE_MEMORY_CLK:
-		amd_pp_clk_type = amd_pp_mem_clock;
-		break;
-	default:
-		DRM_ERROR("DM_PPLIB: invalid clock type: %d!\n",
-				dc_pp_clk_type);
-		break;
-	}
-
-	return amd_pp_clk_type;
-}
-
-static void pp_to_dc_clock_levels(
-		const struct amd_pp_clocks *pp_clks,
-		struct dc_pp_clock_levels *dc_clks,
-		enum dc_pp_clock_type dc_clk_type)
-{
-	uint32_t i;
-
-	if (pp_clks->count > DC_PP_MAX_CLOCK_LEVELS) {
-		DRM_INFO("DM_PPLIB: Warning: %s clock: number of levels %d exceeds maximum of %d!\n",
-				DC_DECODE_PP_CLOCK_TYPE(dc_clk_type),
-				pp_clks->count,
-				DC_PP_MAX_CLOCK_LEVELS);
-
-		dc_clks->num_levels = DC_PP_MAX_CLOCK_LEVELS;
-	} else
-		dc_clks->num_levels = pp_clks->count;
-
-	DRM_INFO("DM_PPLIB: values for %s clock\n",
-			DC_DECODE_PP_CLOCK_TYPE(dc_clk_type));
-
-	for (i = 0; i < dc_clks->num_levels; i++) {
-		DRM_INFO("DM_PPLIB:\t %d\n", pp_clks->clock[i]);
-		/* translate 10kHz to kHz */
-		dc_clks->clocks_in_khz[i] = pp_clks->clock[i] * 10;
-	}
-}
-#endif
-
-bool dc_service_pp_get_clock_levels_by_type(
-		const struct dc_context *ctx,
-		enum dc_pp_clock_type clk_type,
-		struct dc_pp_clock_levels *dc_clks)
-{
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	struct amdgpu_device *adev = ctx->driver_context;
-	void *pp_handle = adev->powerplay.pp_handle;
-	struct amd_pp_clocks pp_clks = { 0 };
-	struct amd_pp_simple_clock_info validation_clks = { 0 };
-	uint32_t i;
-
-	if (amd_powerplay_get_clock_by_type(pp_handle,
-			dc_to_pp_clock_type(clk_type), &pp_clks)) {
-		/* Error in pplib. Provide default values. */
-		get_default_clock_levels(clk_type, dc_clks);
-		return true;
-	}
-
-	pp_to_dc_clock_levels(&pp_clks, dc_clks, clk_type);
-
-	if (amd_powerplay_get_display_mode_validation_clocks(pp_handle,
-			&validation_clks)) {
-		/* Error in pplib. Provide default values. */
-		DRM_INFO("DM_PPLIB: Warning: using default validation clocks!\n");
-		validation_clks.engine_max_clock = 72000;
-		validation_clks.memory_max_clock = 80000;
-		validation_clks.level = 0;
-	}
-
-	DRM_INFO("DM_PPLIB: Validation clocks:\n");
-	DRM_INFO("DM_PPLIB:    engine_max_clock: %d\n",
-			validation_clks.engine_max_clock);
-	DRM_INFO("DM_PPLIB:    memory_max_clock: %d\n",
-			validation_clks.memory_max_clock);
-	DRM_INFO("DM_PPLIB:    level           : %d\n",
-			validation_clks.level);
-
-	/* Translate 10 kHz to kHz. */
-	validation_clks.engine_max_clock *= 10;
-	validation_clks.memory_max_clock *= 10;
-
-	/* Determine the highest non-boosted level from the Validation Clocks */
-	if (clk_type == DC_PP_CLOCK_TYPE_ENGINE_CLK) {
-		for (i = 0; i < dc_clks->num_levels; i++) {
-			if (dc_clks->clocks_in_khz[i] > validation_clks.engine_max_clock) {
-				/* This clock is higher the validation clock.
-				 * Than means the previous one is the highest
-				 * non-boosted one. */
-				DRM_INFO("DM_PPLIB: reducing engine clock level from %d to %d\n",
-						dc_clks->num_levels, i + 1);
-				dc_clks->num_levels = i;
-				break;
-			}
-		}
-	} else if (clk_type == DC_PP_CLOCK_TYPE_MEMORY_CLK) {
-		for (i = 0; i < dc_clks->num_levels; i++) {
-			if (dc_clks->clocks_in_khz[i] > validation_clks.memory_max_clock) {
-				DRM_INFO("DM_PPLIB: reducing memory clock level from %d to %d\n",
-						dc_clks->num_levels, i + 1);
-				dc_clks->num_levels = i;
-				break;
-			}
-		}
-	}
-#else
-	get_default_clock_levels(clk_type, dc_clks);
-#endif
-	return true;
-}
-
-/**** end of power component interfaces ****/
-
-
-/* Calls to notification */
-
-void dal_notify_setmode_complete(struct dc_context *ctx,
-	uint32_t h_total,
-	uint32_t v_total,
-	uint32_t h_active,
-	uint32_t v_active,
-	uint32_t pix_clk_in_khz)
-{
-	/*TODO*/
-}
-/* End of calls to notification */
-
-long dal_get_pid(void)
-{
-	return current->pid;
-}
-
-long dal_get_tgid(void)
-{
-	return current->tgid;
-}
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c
deleted file mode 100644
index ab426e3..0000000
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c
+++ /dev/null
@@ -1,474 +0,0 @@
-/*
- * Copyright 2015 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include <linux/string.h>
-#include <linux/acpi.h>
-
-#include <drm/drmP.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/amdgpu_drm.h>
-#include <drm/drm_edid.h>
-
-#include "amdgpu.h"
-#include "dc.h"
-#include "dc_services.h"
-
-#include "amdgpu_dm.h"
-#include "amdgpu_dm_irq.h"
-#include "amdgpu_dm_types.h"
-
-/* dc_helpers_parse_edid_caps
- *
- * Parse edid caps
- *
- * @edid:	[in] pointer to edid
- *  edid_caps:	[in] pointer to edid caps
- * @return
- *	void
- * */
-enum dc_edid_status dc_helpers_parse_edid_caps(
-		struct dc_context *ctx,
-		const struct dc_edid *edid,
-		struct dc_edid_caps *edid_caps)
-{
-	struct edid *edid_buf = (struct edid *) edid->raw_edid;
-	struct cea_sad *sads;
-	int sad_count = -1;
-	int sadb_count = -1;
-	int i = 0;
-	int j = 0;
-	uint8_t *sadb = NULL;
-
-	enum dc_edid_status result = EDID_OK;
-
-	if (!edid_caps || !edid)
-		return EDID_BAD_INPUT;
-
-	if (!drm_edid_is_valid(edid_buf))
-		result = EDID_BAD_CHECKSUM;
-
-	edid_caps->manufacturer_id = (uint16_t) edid_buf->mfg_id[0] |
-					((uint16_t) edid_buf->mfg_id[1])<<8;
-	edid_caps->product_id = (uint16_t) edid_buf->prod_code[0] |
-					((uint16_t) edid_buf->prod_code[1])<<8;
-	edid_caps->serial_number = edid_buf->serial;
-	edid_caps->manufacture_week = edid_buf->mfg_week;
-	edid_caps->manufacture_year = edid_buf->mfg_year;
-
-	/* One of the four detailed_timings stores the monitor name. It's
-	 * stored in an array of length 13. */
-	for (i = 0; i < 4; i++) {
-		if (edid_buf->detailed_timings[i].data.other_data.type == 0xfc) {
-			while (edid_buf->detailed_timings[i].data.other_data.data.str.str[j] && j < 13) {
-				if (edid_buf->detailed_timings[i].data.other_data.data.str.str[j] == '\n')
-					break;
-
-				edid_caps->display_name[j] =
-					edid_buf->detailed_timings[i].data.other_data.data.str.str[j];
-				j++;
-			}
-		}
-	}
-
-	sad_count = drm_edid_to_sad((struct edid *) edid->raw_edid, &sads);
-	if (sad_count <= 0) {
-		DRM_INFO("SADs count is: %d, don't need to read it\n",
-				sad_count);
-		return result;
-	}
-
-	edid_caps->audio_mode_count = sad_count < DC_MAX_AUDIO_DESC_COUNT ? sad_count : DC_MAX_AUDIO_DESC_COUNT;
-	for (i = 0; i < edid_caps->audio_mode_count; ++i) {
-		struct cea_sad *sad = &sads[i];
-
-		edid_caps->audio_modes[i].format_code = sad->format;
-		edid_caps->audio_modes[i].channel_count = sad->channels;
-		edid_caps->audio_modes[i].sample_rate = sad->freq;
-		edid_caps->audio_modes[i].sample_size = sad->byte2;
-	}
-
-	sadb_count = drm_edid_to_speaker_allocation((struct edid *) edid->raw_edid, &sadb);
-
-	if (sadb_count < 0) {
-		DRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sadb_count);
-		sadb_count = 0;
-	}
-
-	if (sadb_count)
-		edid_caps->speaker_flags = sadb[0];
-	else
-		edid_caps->speaker_flags = DEFAULT_SPEAKER_LOCATION;
-
-	kfree(sads);
-	kfree(sadb);
-
-	return result;
-}
-
-
-static struct amdgpu_connector *get_connector_for_sink(
-	struct drm_device *dev,
-	const struct dc_sink *sink)
-{
-	struct drm_connector *connector;
-	struct amdgpu_connector *aconnector = NULL;
-
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_connector(connector);
-		if (aconnector->dc_sink == sink)
-			break;
-	}
-
-	return aconnector;
-}
-
-static struct amdgpu_connector *get_connector_for_link(
-	struct drm_device *dev,
-	const struct dc_link *link)
-{
-	struct drm_connector *connector;
-	struct amdgpu_connector *aconnector = NULL;
-
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_connector(connector);
-		if (aconnector->dc_link == link)
-			break;
-	}
-
-	return aconnector;
-}
-
-static void get_payload_table(
-		struct amdgpu_connector *aconnector,
-		struct dp_mst_stream_allocation_table *proposed_table)
-{
-	int i;
-	struct drm_dp_mst_topology_mgr *mst_mgr =
-			&aconnector->mst_port->mst_mgr;
-
-	mutex_lock(&mst_mgr->payload_lock);
-
-	proposed_table->stream_count = 0;
-
-	/* number of active streams */
-	for (i = 0; i < mst_mgr->max_payloads; i++) {
-		if (mst_mgr->payloads[i].num_slots == 0)
-			break; /* end of vcp_id table */
-
-		ASSERT(mst_mgr->payloads[i].payload_state !=
-				DP_PAYLOAD_DELETE_LOCAL);
-
-		if (mst_mgr->payloads[i].payload_state == DP_PAYLOAD_LOCAL ||
-			mst_mgr->payloads[i].payload_state ==
-					DP_PAYLOAD_REMOTE) {
-
-			struct dp_mst_stream_allocation *sa =
-					&proposed_table->stream_allocations[
-						proposed_table->stream_count];
-
-			sa->slot_count = mst_mgr->payloads[i].num_slots;
-			sa->vcp_id = mst_mgr->proposed_vcpis[i]->vcpi;
-			proposed_table->stream_count++;
-		}
-	}
-
-	mutex_unlock(&mst_mgr->payload_lock);
-}
-
-/*
- * Writes payload allocation table in immediate downstream device.
- */
-bool dc_helpers_dp_mst_write_payload_allocation_table(
-		struct dc_context *ctx,
-		const struct dc_stream *stream,
-		struct dp_mst_stream_allocation_table *proposed_table,
-		bool enable)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector;
-	struct drm_dp_mst_topology_mgr *mst_mgr;
-	struct drm_dp_mst_port *mst_port;
-	int slots = 0;
-	bool ret;
-	int clock;
-	int bpp = 0;
-	int pbn = 0;
-
-	aconnector = get_connector_for_sink(dev, stream->sink);
-
-	if (!aconnector->mst_port)
-		return false;
-
-	mst_mgr = &aconnector->mst_port->mst_mgr;
-
-	if (!mst_mgr->mst_state)
-		return false;
-
-	mst_port = aconnector->port;
-
-	if (enable) {
-		clock = stream->timing.pix_clk_khz;
-
-		switch (stream->timing.display_color_depth) {
-
-		case COLOR_DEPTH_666:
-			bpp = 6;
-			break;
-		case COLOR_DEPTH_888:
-			bpp = 8;
-			break;
-		case COLOR_DEPTH_101010:
-			bpp = 10;
-			break;
-		case COLOR_DEPTH_121212:
-			bpp = 12;
-			break;
-		case COLOR_DEPTH_141414:
-			bpp = 14;
-			break;
-		case COLOR_DEPTH_161616:
-			bpp = 16;
-			break;
-		default:
-			ASSERT(bpp != 0);
-			break;
-		}
-
-		bpp = bpp * 3;
-
-		/* TODO need to know link rate */
-
-		pbn = drm_dp_calc_pbn_mode(clock, bpp);
-
-		ret = drm_dp_mst_allocate_vcpi(mst_mgr, mst_port, pbn, &slots);
-
-		if (!ret)
-			return false;
-
-	} else {
-		drm_dp_mst_reset_vcpi_slots(mst_mgr, mst_port);
-	}
-
-	ret = drm_dp_update_payload_part1(mst_mgr);
-
-	/* mst_mgr->->payloads are VC payload notify MST branch using DPCD or
-	 * AUX message. The sequence is slot 1-63 allocated sequence for each
-	 * stream. AMD ASIC stream slot allocation should follow the same
-	 * sequence. copy DRM MST allocation to dc */
-
-	get_payload_table(aconnector, proposed_table);
-
-	if (ret)
-		return false;
-
-	return true;
-}
-
-/*
- * Polls for ACT (allocation change trigger) handled and sends
- * ALLOCATE_PAYLOAD message.
- */
-bool dc_helpers_dp_mst_poll_for_allocation_change_trigger(
-		struct dc_context *ctx,
-		const struct dc_stream *stream)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector;
-	struct drm_dp_mst_topology_mgr *mst_mgr;
-	int ret;
-
-	aconnector = get_connector_for_sink(dev, stream->sink);
-
-	if (!aconnector->mst_port)
-		return false;
-
-	mst_mgr = &aconnector->mst_port->mst_mgr;
-
-	if (!mst_mgr->mst_state)
-		return false;
-
-	ret = drm_dp_check_act_status(mst_mgr);
-
-	if (ret)
-		return false;
-
-	return true;
-}
-
-bool dc_helpers_dp_mst_send_payload_allocation(
-		struct dc_context *ctx,
-		const struct dc_stream *stream,
-		bool enable)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector;
-	struct drm_dp_mst_topology_mgr *mst_mgr;
-	struct drm_dp_mst_port *mst_port;
-	int ret;
-
-	aconnector = get_connector_for_sink(dev, stream->sink);
-
-	mst_port = aconnector->port;
-
-	if (!aconnector->mst_port)
-		return false;
-
-	mst_mgr = &aconnector->mst_port->mst_mgr;
-
-	if (!mst_mgr->mst_state)
-		return false;
-
-	ret = drm_dp_update_payload_part2(mst_mgr);
-
-	if (ret)
-		return false;
-
-	if (!enable)
-		drm_dp_mst_deallocate_vcpi(mst_mgr, mst_port);
-
-	return true;
-}
-
-void dc_helpers_dp_mst_handle_mst_hpd_rx_irq(void *param)
-{
-	uint8_t esi[8] = { 0 };
-	uint8_t dret;
-	bool new_irq_handled = true;
-	struct amdgpu_connector *aconnector = (struct amdgpu_connector *)param;
-
-	/* DPCD 0x2002 - 0x2008 for down stream IRQ from MST, eDP etc. */
-	dret = drm_dp_dpcd_read(
-		&aconnector->dm_dp_aux.aux,
-		DP_SINK_COUNT_ESI, esi, 8);
-
-	while ((dret == 8) && new_irq_handled) {
-		uint8_t retry;
-
-		DRM_DEBUG_KMS("ESI %02x %02x %02x\n", esi[0], esi[1], esi[2]);
-
-		/* handle HPD short pulse irq */
-		drm_dp_mst_hpd_irq(&aconnector->mst_mgr, esi, &new_irq_handled);
-
-		if (new_irq_handled) {
-			/* ACK at DPCD to notify down stream */
-			for (retry = 0; retry < 3; retry++) {
-				uint8_t wret;
-
-				wret = drm_dp_dpcd_write(
-					&aconnector->dm_dp_aux.aux,
-					DP_SINK_COUNT_ESI + 1,
-					&esi[1],
-					3);
-				if (wret == 3)
-					break;
-			}
-
-			/* check if there is new irq to be handle */
-			dret = drm_dp_dpcd_read(
-				&aconnector->dm_dp_aux.aux,
-				DP_SINK_COUNT_ESI, esi, 8);
-		}
-	}
-}
-
-bool dc_helpers_dp_mst_start_top_mgr(
-		struct dc_context *ctx,
-		const struct dc_link *link,
-		bool boot)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
-
-	if (boot) {
-		DRM_INFO("DM_MST: Differing MST start on aconnector: %p [id: %d]\n",
-					aconnector, aconnector->base.base.id);
-		return true;
-	}
-
-	DRM_INFO("DM_MST: starting TM on aconnector: %p [id: %d]\n",
-			aconnector, aconnector->base.base.id);
-
-	return (drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true) == 0);
-}
-
-void dc_helpers_dp_mst_stop_top_mgr(
-		struct dc_context *ctx,
-		const struct dc_link *link)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
-
-	DRM_INFO("DM_MST: stopping TM on aconnector: %p [id: %d]\n",
-			aconnector, aconnector->base.base.id);
-
-	if (aconnector->mst_mgr.mst_state == true)
-		drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, false);
-}
-
-bool dc_helper_dp_read_dpcd(
-		struct dc_context *ctx,
-		const struct dc_link *link,
-		uint32_t address,
-		uint8_t *data,
-		uint32_t size) {
-
-
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
-
-	if (!aconnector) {
-		DRM_ERROR("Failed to found connector for link!");
-		return false;
-	}
-
-	return drm_dp_dpcd_read(&aconnector->dm_dp_aux.aux, address,
-			data, size) > 0;
-}
-
-bool dc_helper_dp_write_dpcd(
-		struct dc_context *ctx,
-		const struct dc_link *link,
-		uint32_t address,
-		const uint8_t *data,
-		uint32_t size) {
-
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
-
-	if (!aconnector) {
-		DRM_ERROR("Failed to found connector for link!");
-		return false;
-	}
-
-	return drm_dp_dpcd_write(&aconnector->dm_dp_aux.aux,
-			address, (uint8_t *)data, size) > 0;
-}
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index bb65892..47de461 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 #include "dc.h"
 
 #include "vid.h"
@@ -34,7 +34,7 @@
 
 #include "amd_shared.h"
 #include "amdgpu_dm_irq.h"
-#include "dc_helpers.h"
+#include "dm_helpers.h"
 
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -939,7 +939,7 @@ static void handle_hpd_rx_irq(void *param)
 	}
 
 	if (is_mst_root_connector)
-		dc_helpers_dp_mst_handle_mst_hpd_rx_irq(param);
+		dm_helpers_dp_mst_handle_mst_hpd_rx_irq(param);
 }
 
 static void register_hpd_handlers(struct amdgpu_device *adev)
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
new file mode 100644
index 0000000..e2c68fd
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
@@ -0,0 +1,473 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include <linux/string.h>
+#include <linux/acpi.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/amdgpu_drm.h>
+#include <drm/drm_edid.h>
+
+#include "dm_services.h"
+#include "amdgpu.h"
+#include "dc.h"
+#include "amdgpu_dm.h"
+#include "amdgpu_dm_irq.h"
+#include "amdgpu_dm_types.h"
+
+/* dm_helpers_parse_edid_caps
+ *
+ * Parse edid caps
+ *
+ * @edid:	[in] pointer to edid
+ *  edid_caps:	[in] pointer to edid caps
+ * @return
+ *	void
+ * */
+enum dc_edid_status dm_helpers_parse_edid_caps(
+		struct dc_context *ctx,
+		const struct dc_edid *edid,
+		struct dc_edid_caps *edid_caps)
+{
+	struct edid *edid_buf = (struct edid *) edid->raw_edid;
+	struct cea_sad *sads;
+	int sad_count = -1;
+	int sadb_count = -1;
+	int i = 0;
+	int j = 0;
+	uint8_t *sadb = NULL;
+
+	enum dc_edid_status result = EDID_OK;
+
+	if (!edid_caps || !edid)
+		return EDID_BAD_INPUT;
+
+	if (!drm_edid_is_valid(edid_buf))
+		result = EDID_BAD_CHECKSUM;
+
+	edid_caps->manufacturer_id = (uint16_t) edid_buf->mfg_id[0] |
+					((uint16_t) edid_buf->mfg_id[1])<<8;
+	edid_caps->product_id = (uint16_t) edid_buf->prod_code[0] |
+					((uint16_t) edid_buf->prod_code[1])<<8;
+	edid_caps->serial_number = edid_buf->serial;
+	edid_caps->manufacture_week = edid_buf->mfg_week;
+	edid_caps->manufacture_year = edid_buf->mfg_year;
+
+	/* One of the four detailed_timings stores the monitor name. It's
+	 * stored in an array of length 13. */
+	for (i = 0; i < 4; i++) {
+		if (edid_buf->detailed_timings[i].data.other_data.type == 0xfc) {
+			while (edid_buf->detailed_timings[i].data.other_data.data.str.str[j] && j < 13) {
+				if (edid_buf->detailed_timings[i].data.other_data.data.str.str[j] == '\n')
+					break;
+
+				edid_caps->display_name[j] =
+					edid_buf->detailed_timings[i].data.other_data.data.str.str[j];
+				j++;
+			}
+		}
+	}
+
+	sad_count = drm_edid_to_sad((struct edid *) edid->raw_edid, &sads);
+	if (sad_count <= 0) {
+		DRM_INFO("SADs count is: %d, don't need to read it\n",
+				sad_count);
+		return result;
+	}
+
+	edid_caps->audio_mode_count = sad_count < DC_MAX_AUDIO_DESC_COUNT ? sad_count : DC_MAX_AUDIO_DESC_COUNT;
+	for (i = 0; i < edid_caps->audio_mode_count; ++i) {
+		struct cea_sad *sad = &sads[i];
+
+		edid_caps->audio_modes[i].format_code = sad->format;
+		edid_caps->audio_modes[i].channel_count = sad->channels;
+		edid_caps->audio_modes[i].sample_rate = sad->freq;
+		edid_caps->audio_modes[i].sample_size = sad->byte2;
+	}
+
+	sadb_count = drm_edid_to_speaker_allocation((struct edid *) edid->raw_edid, &sadb);
+
+	if (sadb_count < 0) {
+		DRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sadb_count);
+		sadb_count = 0;
+	}
+
+	if (sadb_count)
+		edid_caps->speaker_flags = sadb[0];
+	else
+		edid_caps->speaker_flags = DEFAULT_SPEAKER_LOCATION;
+
+	kfree(sads);
+	kfree(sadb);
+
+	return result;
+}
+
+
+static struct amdgpu_connector *get_connector_for_sink(
+	struct drm_device *dev,
+	const struct dc_sink *sink)
+{
+	struct drm_connector *connector;
+	struct amdgpu_connector *aconnector = NULL;
+
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		aconnector = to_amdgpu_connector(connector);
+		if (aconnector->dc_sink == sink)
+			break;
+	}
+
+	return aconnector;
+}
+
+static struct amdgpu_connector *get_connector_for_link(
+	struct drm_device *dev,
+	const struct dc_link *link)
+{
+	struct drm_connector *connector;
+	struct amdgpu_connector *aconnector = NULL;
+
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		aconnector = to_amdgpu_connector(connector);
+		if (aconnector->dc_link == link)
+			break;
+	}
+
+	return aconnector;
+}
+
+static void get_payload_table(
+		struct amdgpu_connector *aconnector,
+		struct dp_mst_stream_allocation_table *proposed_table)
+{
+	int i;
+	struct drm_dp_mst_topology_mgr *mst_mgr =
+			&aconnector->mst_port->mst_mgr;
+
+	mutex_lock(&mst_mgr->payload_lock);
+
+	proposed_table->stream_count = 0;
+
+	/* number of active streams */
+	for (i = 0; i < mst_mgr->max_payloads; i++) {
+		if (mst_mgr->payloads[i].num_slots == 0)
+			break; /* end of vcp_id table */
+
+		ASSERT(mst_mgr->payloads[i].payload_state !=
+				DP_PAYLOAD_DELETE_LOCAL);
+
+		if (mst_mgr->payloads[i].payload_state == DP_PAYLOAD_LOCAL ||
+			mst_mgr->payloads[i].payload_state ==
+					DP_PAYLOAD_REMOTE) {
+
+			struct dp_mst_stream_allocation *sa =
+					&proposed_table->stream_allocations[
+						proposed_table->stream_count];
+
+			sa->slot_count = mst_mgr->payloads[i].num_slots;
+			sa->vcp_id = mst_mgr->proposed_vcpis[i]->vcpi;
+			proposed_table->stream_count++;
+		}
+	}
+
+	mutex_unlock(&mst_mgr->payload_lock);
+}
+
+/*
+ * Writes payload allocation table in immediate downstream device.
+ */
+bool dm_helpers_dp_mst_write_payload_allocation_table(
+		struct dc_context *ctx,
+		const struct dc_stream *stream,
+		struct dp_mst_stream_allocation_table *proposed_table,
+		bool enable)
+{
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector;
+	struct drm_dp_mst_topology_mgr *mst_mgr;
+	struct drm_dp_mst_port *mst_port;
+	int slots = 0;
+	bool ret;
+	int clock;
+	int bpp = 0;
+	int pbn = 0;
+
+	aconnector = get_connector_for_sink(dev, stream->sink);
+
+	if (!aconnector->mst_port)
+		return false;
+
+	mst_mgr = &aconnector->mst_port->mst_mgr;
+
+	if (!mst_mgr->mst_state)
+		return false;
+
+	mst_port = aconnector->port;
+
+	if (enable) {
+		clock = stream->timing.pix_clk_khz;
+
+		switch (stream->timing.display_color_depth) {
+
+		case COLOR_DEPTH_666:
+			bpp = 6;
+			break;
+		case COLOR_DEPTH_888:
+			bpp = 8;
+			break;
+		case COLOR_DEPTH_101010:
+			bpp = 10;
+			break;
+		case COLOR_DEPTH_121212:
+			bpp = 12;
+			break;
+		case COLOR_DEPTH_141414:
+			bpp = 14;
+			break;
+		case COLOR_DEPTH_161616:
+			bpp = 16;
+			break;
+		default:
+			ASSERT(bpp != 0);
+			break;
+		}
+
+		bpp = bpp * 3;
+
+		/* TODO need to know link rate */
+
+		pbn = drm_dp_calc_pbn_mode(clock, bpp);
+
+		ret = drm_dp_mst_allocate_vcpi(mst_mgr, mst_port, pbn, &slots);
+
+		if (!ret)
+			return false;
+
+	} else {
+		drm_dp_mst_reset_vcpi_slots(mst_mgr, mst_port);
+	}
+
+	ret = drm_dp_update_payload_part1(mst_mgr);
+
+	/* mst_mgr->->payloads are VC payload notify MST branch using DPCD or
+	 * AUX message. The sequence is slot 1-63 allocated sequence for each
+	 * stream. AMD ASIC stream slot allocation should follow the same
+	 * sequence. copy DRM MST allocation to dc */
+
+	get_payload_table(aconnector, proposed_table);
+
+	if (ret)
+		return false;
+
+	return true;
+}
+
+/*
+ * Polls for ACT (allocation change trigger) handled and sends
+ * ALLOCATE_PAYLOAD message.
+ */
+bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
+		struct dc_context *ctx,
+		const struct dc_stream *stream)
+{
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector;
+	struct drm_dp_mst_topology_mgr *mst_mgr;
+	int ret;
+
+	aconnector = get_connector_for_sink(dev, stream->sink);
+
+	if (!aconnector->mst_port)
+		return false;
+
+	mst_mgr = &aconnector->mst_port->mst_mgr;
+
+	if (!mst_mgr->mst_state)
+		return false;
+
+	ret = drm_dp_check_act_status(mst_mgr);
+
+	if (ret)
+		return false;
+
+	return true;
+}
+
+bool dm_helpers_dp_mst_send_payload_allocation(
+		struct dc_context *ctx,
+		const struct dc_stream *stream,
+		bool enable)
+{
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector;
+	struct drm_dp_mst_topology_mgr *mst_mgr;
+	struct drm_dp_mst_port *mst_port;
+	int ret;
+
+	aconnector = get_connector_for_sink(dev, stream->sink);
+
+	mst_port = aconnector->port;
+
+	if (!aconnector->mst_port)
+		return false;
+
+	mst_mgr = &aconnector->mst_port->mst_mgr;
+
+	if (!mst_mgr->mst_state)
+		return false;
+
+	ret = drm_dp_update_payload_part2(mst_mgr);
+
+	if (ret)
+		return false;
+
+	if (!enable)
+		drm_dp_mst_deallocate_vcpi(mst_mgr, mst_port);
+
+	return true;
+}
+
+void dm_helpers_dp_mst_handle_mst_hpd_rx_irq(void *param)
+{
+	uint8_t esi[8] = { 0 };
+	uint8_t dret;
+	bool new_irq_handled = true;
+	struct amdgpu_connector *aconnector = (struct amdgpu_connector *)param;
+
+	/* DPCD 0x2002 - 0x2008 for down stream IRQ from MST, eDP etc. */
+	dret = drm_dp_dpcd_read(
+		&aconnector->dm_dp_aux.aux,
+		DP_SINK_COUNT_ESI, esi, 8);
+
+	while ((dret == 8) && new_irq_handled) {
+		uint8_t retry;
+
+		DRM_DEBUG_KMS("ESI %02x %02x %02x\n", esi[0], esi[1], esi[2]);
+
+		/* handle HPD short pulse irq */
+		drm_dp_mst_hpd_irq(&aconnector->mst_mgr, esi, &new_irq_handled);
+
+		if (new_irq_handled) {
+			/* ACK at DPCD to notify down stream */
+			for (retry = 0; retry < 3; retry++) {
+				uint8_t wret;
+
+				wret = drm_dp_dpcd_write(
+					&aconnector->dm_dp_aux.aux,
+					DP_SINK_COUNT_ESI + 1,
+					&esi[1],
+					3);
+				if (wret == 3)
+					break;
+			}
+
+			/* check if there is new irq to be handle */
+			dret = drm_dp_dpcd_read(
+				&aconnector->dm_dp_aux.aux,
+				DP_SINK_COUNT_ESI, esi, 8);
+		}
+	}
+}
+
+bool dm_helpers_dp_mst_start_top_mgr(
+		struct dc_context *ctx,
+		const struct dc_link *link,
+		bool boot)
+{
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
+
+	if (boot) {
+		DRM_INFO("DM_MST: Differing MST start on aconnector: %p [id: %d]\n",
+					aconnector, aconnector->base.base.id);
+		return true;
+	}
+
+	DRM_INFO("DM_MST: starting TM on aconnector: %p [id: %d]\n",
+			aconnector, aconnector->base.base.id);
+
+	return (drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true) == 0);
+}
+
+void dm_helpers_dp_mst_stop_top_mgr(
+		struct dc_context *ctx,
+		const struct dc_link *link)
+{
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
+
+	DRM_INFO("DM_MST: stopping TM on aconnector: %p [id: %d]\n",
+			aconnector, aconnector->base.base.id);
+
+	if (aconnector->mst_mgr.mst_state == true)
+		drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, false);
+}
+
+bool dm_helper_dp_read_dpcd(
+		struct dc_context *ctx,
+		const struct dc_link *link,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size) {
+
+
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
+
+	if (!aconnector) {
+		DRM_ERROR("Failed to found connector for link!");
+		return false;
+	}
+
+	return drm_dp_dpcd_read(&aconnector->dm_dp_aux.aux, address,
+			data, size) > 0;
+}
+
+bool dm_helper_dp_write_dpcd(
+		struct dc_context *ctx,
+		const struct dc_link *link,
+		uint32_t address,
+		const uint8_t *data,
+		uint32_t size) {
+
+	struct amdgpu_device *adev = ctx->driver_context;
+	struct drm_device *dev = adev->ddev;
+	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
+
+	if (!aconnector) {
+		DRM_ERROR("Failed to found connector for link!");
+		return false;
+	}
+
+	return drm_dp_dpcd_write(&aconnector->dm_dp_aux.aux,
+			address, (uint8_t *)data, size) > 0;
+}
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c
index b624229..9b5fd70 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c
@@ -25,7 +25,7 @@
 
 #include <drm/drmP.h>
 
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 #include "dc.h"
 
 #include "amdgpu.h"
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
index f52b2f2..3f1d545 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -24,12 +24,13 @@
  */
 
 #include <drm/drm_atomic_helper.h>
-#include "dc_services.h"
+#include "dm_services.h"
 #include "amdgpu.h"
 #include "amdgpu_dm_types.h"
 #include "amdgpu_dm_mst_types.h"
+
 #include "dc.h"
-#include "dc_helpers.h"
+#include "dm_helpers.h"
 
 /* #define TRACE_DPCD */
 
@@ -195,7 +196,7 @@ static struct dc_sink *dm_dp_mst_add_mst_sink(
 	if (!dc_sink)
 		return NULL;
 
-	dc_service_memmove(dc_sink->dc_edid.raw_edid, edid, len);
+	dm_memmove(dc_sink->dc_edid.raw_edid, edid, len);
 	dc_sink->dc_edid.length = len;
 
 	if (!dc_link_add_remote_sink(
@@ -203,7 +204,7 @@ static struct dc_sink *dm_dp_mst_add_mst_sink(
 			dc_sink))
 		goto fail_add_sink;
 
-	edid_status = dc_helpers_parse_edid_caps(
+	edid_status = dm_helpers_parse_edid_caps(
 			NULL,
 			&dc_sink->dc_edid,
 			&dc_sink->edid_caps);
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
new file mode 100644
index 0000000..b155270
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
@@ -0,0 +1,457 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include <linux/string.h>
+#include <linux/acpi.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/amdgpu_drm.h>
+#include "dm_services.h"
+#include "amdgpu.h"
+#include "amdgpu_dm.h"
+#include "amdgpu_dm_irq.h"
+#include "amdgpu_dm_types.h"
+#include "amdgpu_pm.h"
+
+/*
+#include "logger_interface.h"
+#include "acpimethod_atif.h"
+#include "amdgpu_powerplay.h"
+#include "amdgpu_notifications.h"
+*/
+
+/* if the pointer is not NULL, the allocated memory is zeroed */
+void *dm_alloc(struct dc_context *ctx, uint32_t size)
+{
+	return kzalloc(size, GFP_KERNEL);
+}
+
+/* Reallocate memory. The contents will remain unchanged.*/
+void *dm_realloc(struct dc_context *ctx, const void *ptr, uint32_t size)
+{
+	return krealloc(ptr, size, GFP_KERNEL);
+}
+
+void dm_memmove(void *dst, const void *src, uint32_t size)
+{
+	memmove(dst, src, size);
+}
+
+void dm_free(struct dc_context *ctx, void *p)
+{
+	kfree(p);
+}
+
+void dm_memset(void *p, int32_t c, uint32_t count)
+{
+	memset(p, c, count);
+}
+
+int32_t dm_memcmp(const void *p1, const void *p2, uint32_t count)
+{
+	return memcmp(p1, p2, count);
+}
+
+int32_t dm_strncmp(const int8_t *p1, const int8_t *p2, uint32_t count)
+{
+	return strncmp(p1, p2, count);
+}
+
+void dm_sleep_in_milliseconds(struct dc_context *ctx, uint32_t milliseconds)
+{
+	if (milliseconds >= 20)
+		msleep(milliseconds);
+	else
+		usleep_range(milliseconds*1000, milliseconds*1000+1);
+}
+
+void dal_delay_in_nanoseconds(uint32_t nanoseconds)
+{
+	ndelay(nanoseconds);
+}
+
+void dm_delay_in_microseconds(struct dc_context *ctx, uint32_t microseconds)
+{
+	udelay(microseconds);
+}
+
+/******************************************************************************
+ * IRQ Interfaces.
+ *****************************************************************************/
+
+void dal_register_timer_interrupt(
+	struct dc_context *ctx,
+	struct dc_timer_interrupt_params *int_params,
+	interrupt_handler ih,
+	void *args)
+{
+	struct amdgpu_device *adev = ctx->driver_context;
+
+	if (!adev || !int_params) {
+		DRM_ERROR("DM_IRQ: invalid input!\n");
+		return;
+	}
+
+	if (int_params->int_context != INTERRUPT_LOW_IRQ_CONTEXT) {
+		/* only low irq ctx is supported. */
+		DRM_ERROR("DM_IRQ: invalid context: %d!\n",
+				int_params->int_context);
+		return;
+	}
+
+	amdgpu_dm_irq_register_timer(adev, int_params, ih, args);
+}
+
+void dal_isr_acquire_lock(struct dc_context *ctx)
+{
+	/*TODO*/
+}
+
+void dal_isr_release_lock(struct dc_context *ctx)
+{
+	/*TODO*/
+}
+
+/******************************************************************************
+ * End-of-IRQ Interfaces.
+ *****************************************************************************/
+
+bool dm_get_platform_info(struct dc_context *ctx,
+			struct platform_info_params *params)
+{
+	/*TODO*/
+	return false;
+}
+
+/**** power component interfaces ****/
+
+bool dm_pp_pre_dce_clock_change(
+		struct dc_context *ctx,
+		struct dal_to_power_info *input,
+		struct power_to_dal_info *output)
+{
+	/*TODO*/
+	return false;
+}
+
+bool dm_pp_apply_safe_state(
+		const struct dc_context *ctx)
+{
+#ifdef CONFIG_DRM_AMD_POWERPLAY
+	struct amdgpu_device *adev = ctx->driver_context;
+
+	if (adev->pm.dpm_enabled) {
+		/* TODO: Does this require PreModeChange event to PPLIB? */
+	}
+
+	return true;
+#else
+	return false;
+#endif
+}
+
+bool dm_pp_apply_display_requirements(
+		const struct dc_context *ctx,
+		const struct dc_pp_display_configuration *pp_display_cfg)
+{
+#ifdef CONFIG_DRM_AMD_POWERPLAY
+	struct amdgpu_device *adev = ctx->driver_context;
+
+	if (adev->pm.dpm_enabled) {
+
+		memset(&adev->pm.pm_display_cfg, 0,
+				sizeof(adev->pm.pm_display_cfg));
+
+		adev->pm.pm_display_cfg.cpu_cc6_disable =
+			pp_display_cfg->cpu_cc6_disable;
+
+		adev->pm.pm_display_cfg.cpu_pstate_disable =
+			pp_display_cfg->cpu_pstate_disable;
+
+		adev->pm.pm_display_cfg.cpu_pstate_separation_time =
+			pp_display_cfg->cpu_pstate_separation_time;
+
+		adev->pm.pm_display_cfg.nb_pstate_switch_disable =
+			pp_display_cfg->nb_pstate_switch_disable;
+
+		adev->pm.pm_display_cfg.num_display =
+				pp_display_cfg->display_count;
+		adev->pm.pm_display_cfg.num_path_including_non_display =
+				pp_display_cfg->display_count;
+
+		adev->pm.pm_display_cfg.min_core_set_clock =
+				pp_display_cfg->min_engine_clock_khz/10;
+		adev->pm.pm_display_cfg.min_core_set_clock_in_sr =
+				pp_display_cfg->min_engine_clock_deep_sleep_khz/10;
+		adev->pm.pm_display_cfg.min_mem_set_clock =
+				pp_display_cfg->min_memory_clock_khz/10;
+
+		adev->pm.pm_display_cfg.multi_monitor_in_sync =
+				pp_display_cfg->all_displays_in_sync;
+		adev->pm.pm_display_cfg.min_vblank_time =
+				pp_display_cfg->avail_mclk_switch_time_us;
+
+		adev->pm.pm_display_cfg.display_clk =
+				pp_display_cfg->disp_clk_khz/10;
+
+		adev->pm.pm_display_cfg.dce_tolerable_mclk_in_active_latency =
+				pp_display_cfg->avail_mclk_switch_time_in_disp_active_us;
+
+		adev->pm.pm_display_cfg.crtc_index = pp_display_cfg->crtc_index;
+		adev->pm.pm_display_cfg.line_time_in_us =
+				pp_display_cfg->line_time_in_us;
+
+		adev->pm.pm_display_cfg.crossfire_display_index = -1;
+		adev->pm.pm_display_cfg.min_bus_bandwidth = 0;
+
+		/* TODO: complete implementation of
+		 * amd_powerplay_display_configuration_change().
+		 * Follow example of:
+		 * PHM_StoreDALConfigurationData - powerplay\hwmgr\hardwaremanager.c
+		 * PP_IRI_DisplayConfigurationChange - powerplay\eventmgr\iri.c */
+		amd_powerplay_display_configuration_change(
+				adev->powerplay.pp_handle,
+				&adev->pm.pm_display_cfg);
+
+		/* TODO: replace by a separate call to 'apply display cfg'? */
+		amdgpu_pm_compute_clocks(adev);
+	}
+
+	return true;
+#else
+	return false;
+#endif
+}
+
+bool dc_service_get_system_clocks_range(
+		const struct dc_context *ctx,
+		struct dal_system_clock_range *sys_clks)
+{
+#ifdef CONFIG_DRM_AMD_POWERPLAY
+	struct amdgpu_device *adev = ctx->driver_context;
+#endif
+
+	/* Default values, in case PPLib is not compiled-in. */
+	sys_clks->max_mclk = 80000;
+	sys_clks->min_mclk = 80000;
+
+	sys_clks->max_sclk = 60000;
+	sys_clks->min_sclk = 30000;
+
+#ifdef CONFIG_DRM_AMD_POWERPLAY
+	if (adev->pm.dpm_enabled) {
+		sys_clks->max_mclk = amdgpu_dpm_get_mclk(adev, false);
+		sys_clks->min_mclk = amdgpu_dpm_get_mclk(adev, true);
+
+		sys_clks->max_sclk = amdgpu_dpm_get_sclk(adev, false);
+		sys_clks->min_sclk = amdgpu_dpm_get_sclk(adev, true);
+	}
+#endif
+
+	return true;
+}
+
+static void get_default_clock_levels(
+		enum dc_pp_clock_type clk_type,
+		struct dc_pp_clock_levels *clks)
+{
+	uint32_t disp_clks_in_khz[6] = {
+			300000, 400000, 496560, 626090, 685720, 757900 };
+	uint32_t sclks_in_khz[6] = {
+			300000, 360000, 423530, 514290, 626090, 720000 };
+	uint32_t mclks_in_khz[2] = { 333000, 800000 };
+
+	switch (clk_type) {
+	case DC_PP_CLOCK_TYPE_DISPLAY_CLK:
+		clks->num_levels = 6;
+		dm_memmove(clks->clocks_in_khz, disp_clks_in_khz,
+				sizeof(disp_clks_in_khz));
+		break;
+	case DC_PP_CLOCK_TYPE_ENGINE_CLK:
+		clks->num_levels = 6;
+		dm_memmove(clks->clocks_in_khz, sclks_in_khz,
+				sizeof(sclks_in_khz));
+		break;
+	case DC_PP_CLOCK_TYPE_MEMORY_CLK:
+		clks->num_levels = 2;
+		dm_memmove(clks->clocks_in_khz, mclks_in_khz,
+				sizeof(mclks_in_khz));
+		break;
+	default:
+		clks->num_levels = 0;
+		break;
+	}
+}
+
+#ifdef CONFIG_DRM_AMD_POWERPLAY
+static enum amd_pp_clock_type dc_to_pp_clock_type(
+		enum dc_pp_clock_type dc_pp_clk_type)
+{
+	enum amd_pp_clock_type amd_pp_clk_type = 0;
+
+	switch (dc_pp_clk_type) {
+	case DC_PP_CLOCK_TYPE_DISPLAY_CLK:
+		amd_pp_clk_type = amd_pp_disp_clock;
+		break;
+	case DC_PP_CLOCK_TYPE_ENGINE_CLK:
+		amd_pp_clk_type = amd_pp_sys_clock;
+		break;
+	case DC_PP_CLOCK_TYPE_MEMORY_CLK:
+		amd_pp_clk_type = amd_pp_mem_clock;
+		break;
+	default:
+		DRM_ERROR("DM_PPLIB: invalid clock type: %d!\n",
+				dc_pp_clk_type);
+		break;
+	}
+
+	return amd_pp_clk_type;
+}
+
+static void pp_to_dc_clock_levels(
+		const struct amd_pp_clocks *pp_clks,
+		struct dc_pp_clock_levels *dc_clks,
+		enum dc_pp_clock_type dc_clk_type)
+{
+	uint32_t i;
+
+	if (pp_clks->count > DC_PP_MAX_CLOCK_LEVELS) {
+		DRM_INFO("DM_PPLIB: Warning: %s clock: number of levels %d exceeds maximum of %d!\n",
+				DC_DECODE_PP_CLOCK_TYPE(dc_clk_type),
+				pp_clks->count,
+				DC_PP_MAX_CLOCK_LEVELS);
+
+		dc_clks->num_levels = DC_PP_MAX_CLOCK_LEVELS;
+	} else
+		dc_clks->num_levels = pp_clks->count;
+
+	DRM_INFO("DM_PPLIB: values for %s clock\n",
+			DC_DECODE_PP_CLOCK_TYPE(dc_clk_type));
+
+	for (i = 0; i < dc_clks->num_levels; i++) {
+		DRM_INFO("DM_PPLIB:\t %d\n", pp_clks->clock[i]);
+		/* translate 10kHz to kHz */
+		dc_clks->clocks_in_khz[i] = pp_clks->clock[i] * 10;
+	}
+}
+#endif
+
+bool dm_pp_get_clock_levels_by_type(
+		const struct dc_context *ctx,
+		enum dc_pp_clock_type clk_type,
+		struct dc_pp_clock_levels *dc_clks)
+{
+#ifdef CONFIG_DRM_AMD_POWERPLAY
+	struct amdgpu_device *adev = ctx->driver_context;
+	void *pp_handle = adev->powerplay.pp_handle;
+	struct amd_pp_clocks pp_clks = { 0 };
+	struct amd_pp_simple_clock_info validation_clks = { 0 };
+	uint32_t i;
+
+	if (amd_powerplay_get_clock_by_type(pp_handle,
+			dc_to_pp_clock_type(clk_type), &pp_clks)) {
+		/* Error in pplib. Provide default values. */
+		get_default_clock_levels(clk_type, dc_clks);
+		return true;
+	}
+
+	pp_to_dc_clock_levels(&pp_clks, dc_clks, clk_type);
+
+	if (amd_powerplay_get_display_mode_validation_clocks(pp_handle,
+			&validation_clks)) {
+		/* Error in pplib. Provide default values. */
+		DRM_INFO("DM_PPLIB: Warning: using default validation clocks!\n");
+		validation_clks.engine_max_clock = 72000;
+		validation_clks.memory_max_clock = 80000;
+		validation_clks.level = 0;
+	}
+
+	DRM_INFO("DM_PPLIB: Validation clocks:\n");
+	DRM_INFO("DM_PPLIB:    engine_max_clock: %d\n",
+			validation_clks.engine_max_clock);
+	DRM_INFO("DM_PPLIB:    memory_max_clock: %d\n",
+			validation_clks.memory_max_clock);
+	DRM_INFO("DM_PPLIB:    level           : %d\n",
+			validation_clks.level);
+
+	/* Translate 10 kHz to kHz. */
+	validation_clks.engine_max_clock *= 10;
+	validation_clks.memory_max_clock *= 10;
+
+	/* Determine the highest non-boosted level from the Validation Clocks */
+	if (clk_type == DC_PP_CLOCK_TYPE_ENGINE_CLK) {
+		for (i = 0; i < dc_clks->num_levels; i++) {
+			if (dc_clks->clocks_in_khz[i] > validation_clks.engine_max_clock) {
+				/* This clock is higher the validation clock.
+				 * Than means the previous one is the highest
+				 * non-boosted one. */
+				DRM_INFO("DM_PPLIB: reducing engine clock level from %d to %d\n",
+						dc_clks->num_levels, i + 1);
+				dc_clks->num_levels = i;
+				break;
+			}
+		}
+	} else if (clk_type == DC_PP_CLOCK_TYPE_MEMORY_CLK) {
+		for (i = 0; i < dc_clks->num_levels; i++) {
+			if (dc_clks->clocks_in_khz[i] > validation_clks.memory_max_clock) {
+				DRM_INFO("DM_PPLIB: reducing memory clock level from %d to %d\n",
+						dc_clks->num_levels, i + 1);
+				dc_clks->num_levels = i;
+				break;
+			}
+		}
+	}
+#else
+	get_default_clock_levels(clk_type, dc_clks);
+#endif
+	return true;
+}
+
+/**** end of power component interfaces ****/
+
+
+/* Calls to notification */
+
+void dal_notify_setmode_complete(struct dc_context *ctx,
+	uint32_t h_total,
+	uint32_t v_total,
+	uint32_t h_active,
+	uint32_t v_active,
+	uint32_t pix_clk_in_khz)
+{
+	/*TODO*/
+}
+/* End of calls to notification */
+
+long dm_get_pid(void)
+{
+	return current->pid;
+}
+
+long dm_get_tgid(void)
+{
+	return current->tgid;
+}
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index d09f0ad..a8350e6 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -23,15 +23,16 @@
  *
  */
 
-#include "dc_services_types.h"
-
 #include <linux/types.h>
 #include <drm/drmP.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_atomic.h>
+
 #include "amdgpu.h"
 #include "amdgpu_pm.h"
+#include "dm_services_types.h"
+
 // We need to #undef FRAME_SIZE and DEPRECATED because they conflict
 // with ptrace-abi.h's #define's of them.
 #undef FRAME_SIZE
@@ -625,7 +626,7 @@ static void dm_dc_surface_commit(
 	struct dc_target *dc_target = acrtc->target;
 
 	if (!dc_target) {
-		dal_error(
+		dm_error(
 			"%s: Failed to obtain target on crtc (%d)!\n",
 			__func__,
 			acrtc->crtc_id);
@@ -635,7 +636,7 @@ static void dm_dc_surface_commit(
 	dc_surface = dc_create_surface(dc);
 
 	if (!dc_surface) {
-		dal_error(
+		dm_error(
 			"%s: Failed to create a surface!\n",
 			__func__);
 		goto fail;
@@ -659,7 +660,7 @@ static void dm_dc_surface_commit(
 			&dc_surface,
 			1,
 			dc_target)) {
-		dal_error(
+		dm_error(
 			"%s: Failed to attach surface!\n",
 			__func__);
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index 9fb1be8..73bfd4e 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -23,8 +23,7 @@
  *
  */
 
-
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dc_bios_types.h"
 
@@ -36,6 +35,7 @@
 #include "include/logger_interface.h"
 
 #include "adapter_service.h"
+
 #include "hw_ctx_adapter_service.h"
 #include "wireless_data_source.h"
 
@@ -203,7 +203,7 @@ static void get_platform_info_methods(
 	params.data = &mask;
 	params.method = PM_GET_AVAILABLE_METHODS;
 
-	if (dal_get_platform_info(as->ctx, &params))
+	if (dm_get_platform_info(as->ctx, &params))
 		as->platform_methods_mask = mask;
 
 
@@ -235,7 +235,7 @@ static void initialize_backlight_caps(
 	params.data = &caps;
 	params.method = PM_GET_EXTENDED_BRIGHNESS_CAPS;
 
-	if (dal_get_platform_info(as->ctx, &params)) {
+	if (dm_get_platform_info(as->ctx, &params)) {
 		as->ac_level_percentage = caps.basic_caps.ac_level_percentage;
 		as->dc_level_percentage = caps.basic_caps.dc_level_percentage;
 		custom_curve_present = (caps.data_points_num > 0);
@@ -608,7 +608,7 @@ static bool generate_feature_set(
 	uint32_t entry_num = 0;
 	const struct feature_source_entry *entry = NULL;
 
-	dc_service_memset(adapter_feature_set, 0, sizeof(adapter_feature_set));
+	dm_memset(adapter_feature_set, 0, sizeof(adapter_feature_set));
 	entry_num = get_feature_entries_num();
 
 
@@ -850,7 +850,7 @@ struct adapter_service *dal_adapter_service_create(
 {
 	struct adapter_service *as;
 
-	as = dc_service_alloc(init_data->ctx, sizeof(struct adapter_service));
+	as = dm_alloc(init_data->ctx, sizeof(struct adapter_service));
 
 	if (!as) {
 		ASSERT_CRITICAL(false);
@@ -862,7 +862,7 @@ struct adapter_service *dal_adapter_service_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(init_data->ctx, as);
+	dm_free(init_data->ctx, as);
 
 	return NULL;
 }
@@ -887,7 +887,7 @@ void dal_adapter_service_destroy(
 
 	adapter_service_destruct(*as);
 
-	dc_service_free((*as)->ctx, *as);
+	dm_free((*as)->ctx, *as);
 
 	*as = NULL;
 }
@@ -1367,7 +1367,7 @@ bool dal_adapter_service_get_integrated_info(
 	if (info == NULL || as->integrated_info == NULL)
 		return false;
 
-	dc_service_memmove(info, as->integrated_info, sizeof(struct integrated_info));
+	dm_memmove(info, as->integrated_info, sizeof(struct integrated_info));
 
 	return true;
 }
@@ -1974,7 +1974,7 @@ bool dal_adapter_service_is_lid_open(struct adapter_service *as)
 	params.method = PM_GET_LID_STATE;
 
 	if ((PM_GET_LID_STATE & as->platform_methods_mask) &&
-		dal_get_platform_info(as->ctx, &params))
+		dm_get_platform_info(as->ctx, &params))
 		return is_lid_open;
 
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c b/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c
index 98b1475..f10bee6 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c
@@ -23,7 +23,8 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
+
 #include "../hw_ctx_adapter_service.h"
 
 #include "hw_ctx_adapter_service_dce110.h"
@@ -86,7 +87,7 @@ static void destroy(
 
 	destruct(hw_ctx);
 
-	dc_service_free(ptr->ctx, hw_ctx);
+	dm_free(ptr->ctx, hw_ctx);
 }
 
 /*
@@ -141,10 +142,10 @@ static uint32_t get_number_of_connected_audio_endpoints_multistream(
 			AZALIA_F0_CODEC_ENDPOINT_INDEX,
 			AZALIA_ENDPOINT_REG_INDEX);
 
-		dal_write_reg(ctx, audio_index_reg_offset[i], value);
+		dm_write_reg(ctx, audio_index_reg_offset[i], value);
 
 		value = 0;
-		value = dal_read_reg(ctx, audio_data_reg_offset[i]);
+		value = dm_read_reg(ctx, audio_data_reg_offset[i]);
 
 		/* 1 means not supported*/
 		if (get_reg_field_value(value,
@@ -173,7 +174,7 @@ static uint32_t get_number_of_connected_audio_endpoints(
 		/* audio straps indicate no audio supported */
 		return 0;
 
-	value = dal_read_reg(hw_ctx->ctx, addr);
+	value = dm_read_reg(hw_ctx->ctx, addr);
 
 	field = get_reg_field_value(
 			value, CC_DC_HDMI_STRAPS, AUDIO_STREAM_NUMBER);
@@ -216,14 +217,14 @@ static bool power_up(
 		uint32_t value = 0;
 		uint32_t field = 0;
 
-		value = dal_read_reg(hw_ctx->ctx, mmCC_DC_HDMI_STRAPS);
+		value = dm_read_reg(hw_ctx->ctx, mmCC_DC_HDMI_STRAPS);
 		field = get_reg_field_value(
 				value, CC_DC_HDMI_STRAPS, HDMI_DISABLE);
 
 		if (field == 0) {
 			hw_ctx->cached_audio_straps = AUDIO_STRAPS_DP_HDMI_AUDIO;
 		} else {
-			value = dal_read_reg(
+			value = dm_read_reg(
 					hw_ctx->ctx, mmDC_PINSTRAPS);
 			field = get_reg_field_value(
 						value,
@@ -285,7 +286,7 @@ struct hw_ctx_adapter_service *
 			struct dc_context *ctx)
 {
 	struct hw_ctx_adapter_service_dce110 *hw_ctx =
-			dc_service_alloc(ctx, sizeof(struct hw_ctx_adapter_service_dce110));
+			dm_alloc(ctx, sizeof(struct hw_ctx_adapter_service_dce110));
 
 	if (!hw_ctx) {
 		ASSERT_CRITICAL(false);
@@ -297,7 +298,7 @@ struct hw_ctx_adapter_service *
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, hw_ctx);
+	dm_free(ctx, hw_ctx);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c b/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c
index ba377f4..4f5f040 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c
@@ -25,7 +25,7 @@
 
 /* FPGA Diagnostics version of AS HW CTX. */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "../hw_ctx_adapter_service.h"
 
@@ -112,7 +112,7 @@ static bool construct(
 struct hw_ctx_adapter_service *dal_adapter_service_create_hw_ctx_diag(
 	struct dc_context *ctx)
 {
-	struct hw_ctx_adapter_service *hw_ctx = dc_service_alloc(ctx,
+	struct hw_ctx_adapter_service *hw_ctx = dm_alloc(ctx,
 			sizeof(*hw_ctx));
 
 	if (!hw_ctx) {
@@ -125,7 +125,7 @@ struct hw_ctx_adapter_service *dal_adapter_service_create_hw_ctx_diag(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, hw_ctx);
+	dm_free(ctx, hw_ctx);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/hw_ctx_adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/hw_ctx_adapter_service.c
index 0d13a90..12eabe0 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/hw_ctx_adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/hw_ctx_adapter_service.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/adapter_service_types.h"
 #include "include/grph_object_id.h"
 #include "hw_ctx_adapter_service.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
index 122222e..0b1151e 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
@@ -24,7 +24,7 @@
  */
 
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "adapter_service.h"
 #include "wireless_data_source.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c
index 05a92a4..7a905f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/logger_interface.h"
 
@@ -51,7 +51,7 @@ static bool construct(
 	bool asic_supported = false;
 
 	cap->ctx = ctx;
-	dc_service_memset(cap->data, 0, sizeof(cap->data));
+	dm_memset(cap->data, 0, sizeof(cap->data));
 
 	/* ASIC data */
 	cap->data[ASIC_DATA_VRAM_TYPE] = init->vram_type;
@@ -147,7 +147,7 @@ struct asic_capability *dal_asic_capability_create(
 		return NULL;
 	}
 
-	cap = dc_service_alloc(ctx, sizeof(struct asic_capability));
+	cap = dm_alloc(ctx, sizeof(struct asic_capability));
 
 	if (!cap) {
 		BREAK_TO_DEBUGGER();
@@ -159,7 +159,7 @@ struct asic_capability *dal_asic_capability_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dc_service_free(ctx, cap);
+	dm_free(ctx, cap);
 
 	return NULL;
 }
@@ -184,7 +184,7 @@ void dal_asic_capability_destroy(
 
 	destruct(*cap);
 
-	dc_service_free((*cap)->ctx, *cap);
+	dm_free((*cap)->ctx, *cap);
 
 	*cap = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c
index 1de790d..4aa8c30 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/asic_capability_interface.h"
 #include "include/asic_capability_types.h"
@@ -36,7 +36,7 @@
 #include "dce/dce_11_0_sh_mask.h"
 #include "dal_asic_id.h"
 
-#define ixVCE_HARVEST_FUSE_MACRO__ADDRESS     0xC0014074
+#define ixVCE_HARVEST_FUSE_MACRO__ADDRESS 0xC0014074
 
 /*
  * carrizo_asic_capability_create
@@ -85,7 +85,7 @@ void carrizo_asic_capability_create(struct asic_capability *cap,
 	cap->stereo_3d_caps.DISPLAYPORT_FRAME_ALT = true;
 	cap->stereo_3d_caps.INTERLEAVE = true;
 
-    e_fuse_setting = dal_read_index_reg(cap->ctx,CGS_IND_REG__SMC,ixVCE_HARVEST_FUSE_MACRO__ADDRESS);
+	e_fuse_setting = dm_read_index_reg(cap->ctx,CGS_IND_REG__SMC, ixVCE_HARVEST_FUSE_MACRO__ADDRESS);
 
 	/* Bits [28:27]*/
 	switch ((e_fuse_setting >> 27) & 0x3) {
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
index 7cd0b80..af669c8 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/asic_capability_interface.h"
 #include "include/asic_capability_types.h"
@@ -90,8 +90,7 @@ void tonga_asic_capability_create(struct asic_capability *cap,
 	cap->stereo_3d_caps.DISPLAYPORT_FRAME_ALT = true;
 	cap->stereo_3d_caps.INTERLEAVE = true;
 
-	e_fuse_setting = dal_read_index_reg(cap->ctx, CGS_IND_REG__SMC,
-			ixVCE_HARVEST_FUSE_MACRO__ADDRESS);
+	e_fuse_setting = dm_read_index_reg(cap->ctx, CGS_IND_REG__SMC, ixVCE_HARVEST_FUSE_MACRO__ADDRESS);
 
 	/* Bits [28:27]*/
 	switch ((e_fuse_setting >> 27) & 0x3) {
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
index 2311f29..bfd6725 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/logger_interface.h"
 
@@ -152,7 +152,7 @@ static struct audio_feature_support get_supported_features(struct audio *audio)
 	/*DCE specific, must be implemented in derived*/
 	struct audio_feature_support features;
 
-	dc_service_memset(&features, 0, sizeof(features));
+	dm_memset(&features, 0, sizeof(features));
 
 	features.ENGINE_DIGA = 1;
 	features.ENGINE_DIGB = 1;
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
index 5927b12..1aa0c1e 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
@@ -23,7 +23,8 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
+
 #include "include/logger_interface.h"
 
 #include "audio_dce110.h"
@@ -52,7 +53,7 @@ static void destroy(struct audio **ptr)
 	destruct(audio);
 
 	/* release memory allocated for audio_dce110*/
-	dc_service_free((*ptr)->ctx, audio);
+	dm_free((*ptr)->ctx, audio);
 	*ptr = NULL;
 }
 
@@ -425,7 +426,7 @@ struct audio *dal_audio_create_dce110(
 	const struct audio_init_data *init_data)
 {
 	/*allocate memory for audio_dce110 */
-	struct audio_dce110 *audio = dc_service_alloc(init_data->ctx, sizeof(*audio));
+	struct audio_dce110 *audio = dm_alloc(init_data->ctx, sizeof(*audio));
 
 	if (audio == NULL) {
 		ASSERT_CRITICAL(audio);
@@ -442,7 +443,7 @@ struct audio *dal_audio_create_dce110(
 		"Failed to create audio object for DCE11\n");
 
 	 /*release memory allocated if fail */
-	dc_service_free(init_data->ctx, audio);
+	dm_free(init_data->ctx, audio);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
index 288f14f..f24b964 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
@@ -23,7 +23,8 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
+
 #include "include/logger_interface.h"
 #include "../hw_ctx_audio.h"
 #include "hw_ctx_audio_dce110.h"
@@ -70,7 +71,7 @@ static void destroy(
 
 	destruct(hw_ctx_dce110);
 	/* release memory allocated for struct hw_ctx_audio_dce110 */
-	dc_service_free((*ptr)->ctx, hw_ctx_dce110);
+	dm_free((*ptr)->ctx, hw_ctx_dce110);
 
 	*ptr = NULL;
 }
@@ -93,7 +94,7 @@ static void write_indirect_azalia_reg(
 			AZALIA_F0_CODEC_ENDPOINT_INDEX,
 			AZALIA_ENDPOINT_REG_INDEX);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
@@ -106,7 +107,7 @@ static void write_indirect_azalia_reg(
 		set_reg_field_value(value, reg_data,
 			AZALIA_F0_CODEC_ENDPOINT_DATA,
 			AZALIA_ENDPOINT_REG_DATA);
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	dal_logger_write(
@@ -136,7 +137,7 @@ static uint32_t read_indirect_azalia_reg(
 			AZALIA_F0_CODEC_ENDPOINT_INDEX,
 			AZALIA_ENDPOINT_REG_INDEX);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
@@ -145,7 +146,7 @@ static uint32_t read_indirect_azalia_reg(
 			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
 			azf0endpointx_azalia_f0_codec_endpoint_data;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		ret_val = value;
 	}
 
@@ -349,7 +350,7 @@ static void setup_audio_wall_dto(
 {
 	struct azalia_clock_info clock_info = { 0 };
 
-	uint32_t value = dal_read_reg(hw_ctx->ctx, mmDCCG_AUDIO_DTO_SOURCE);
+	uint32_t value = dm_read_reg(hw_ctx->ctx, mmDCCG_AUDIO_DTO_SOURCE);
 
 	/* TODO: GraphicsObject\inc\GraphicsObjectDefs.hpp(131):
 	 *inline bool isHdmiSignal(SignalType signal)
@@ -387,19 +388,19 @@ static void setup_audio_wall_dto(
 				DCCG_AUDIO_DTO_SOURCE,
 				DCCG_AUDIO_DTO_SEL);
 
-			dal_write_reg(hw_ctx->ctx,
+			dm_write_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO_SOURCE, value);
 		}
 
 		/* module */
 		{
-			value = dal_read_reg(hw_ctx->ctx,
+			value = dm_read_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO0_MODULE);
 			set_reg_field_value(value,
 				clock_info.audio_dto_module,
 				DCCG_AUDIO_DTO0_MODULE,
 				DCCG_AUDIO_DTO0_MODULE);
-			dal_write_reg(hw_ctx->ctx,
+			dm_write_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO0_MODULE, value);
 		}
 
@@ -407,14 +408,14 @@ static void setup_audio_wall_dto(
 		{
 			value = 0;
 
-			value = dal_read_reg(hw_ctx->ctx,
+			value = dm_read_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO0_PHASE);
 			set_reg_field_value(value,
 				clock_info.audio_dto_phase,
 				DCCG_AUDIO_DTO0_PHASE,
 				DCCG_AUDIO_DTO0_PHASE);
 
-			dal_write_reg(hw_ctx->ctx,
+			dm_write_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO0_PHASE, value);
 		}
 
@@ -448,7 +449,7 @@ static void setup_audio_wall_dto(
 				DCCG_AUDIO_DTO2_USE_512FBR_DTO);
 			*/
 
-			dal_write_reg(hw_ctx->ctx,
+			dm_write_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO_SOURCE, value);
 		}
 
@@ -456,7 +457,7 @@ static void setup_audio_wall_dto(
 		{
 			value = 0;
 
-			value = dal_read_reg(hw_ctx->ctx,
+			value = dm_read_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO1_MODULE);
 
 			set_reg_field_value(value,
@@ -464,7 +465,7 @@ static void setup_audio_wall_dto(
 				DCCG_AUDIO_DTO1_MODULE,
 				DCCG_AUDIO_DTO1_MODULE);
 
-			dal_write_reg(hw_ctx->ctx,
+			dm_write_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO1_MODULE, value);
 		}
 
@@ -472,7 +473,7 @@ static void setup_audio_wall_dto(
 		{
 			value = 0;
 
-			value = dal_read_reg(hw_ctx->ctx,
+			value = dm_read_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO1_PHASE);
 
 			set_reg_field_value(value,
@@ -480,7 +481,7 @@ static void setup_audio_wall_dto(
 				DCCG_AUDIO_DTO1_PHASE,
 				DCCG_AUDIO_DTO1_PHASE);
 
-			dal_write_reg(hw_ctx->ctx,
+			dm_write_reg(hw_ctx->ctx,
 					mmDCCG_AUDIO_DTO1_PHASE, value);
 		}
 
@@ -515,7 +516,7 @@ static void setup_hdmi_audio(
 		addr =
 			mmHDMI_AUDIO_PACKET_CONTROL + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value, max_packets_per_line,
 			HDMI_AUDIO_PACKET_CONTROL,
@@ -525,27 +526,27 @@ static void setup_hdmi_audio(
 			HDMI_AUDIO_PACKET_CONTROL,
 			HDMI_AUDIO_DELAY_EN);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AFMT_AUDIO_PACKET_CONTROL */
 	{
 		addr = mmAFMT_AUDIO_PACKET_CONTROL + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value, 1,
 			AFMT_AUDIO_PACKET_CONTROL,
 			AFMT_60958_CS_UPDATE);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AFMT_AUDIO_PACKET_CONTROL2 */
 	{
 		addr = mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value, 0,
 				AFMT_AUDIO_PACKET_CONTROL2,
@@ -556,14 +557,14 @@ static void setup_hdmi_audio(
 			AFMT_AUDIO_PACKET_CONTROL2,
 			AFMT_60958_OSF_OVRD);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* HDMI_ACR_PACKET_CONTROL */
 	{
 		addr = mmHDMI_ACR_PACKET_CONTROL + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value, 1,
 			HDMI_ACR_PACKET_CONTROL,
 			HDMI_ACR_AUTO_SEND);
@@ -580,7 +581,7 @@ static void setup_hdmi_audio(
 			HDMI_ACR_PACKET_CONTROL,
 			HDMI_ACR_AUDIO_PRIORITY);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* Program audio clock sample/regeneration parameters */
@@ -595,73 +596,73 @@ static void setup_hdmi_audio(
 		{
 			addr = mmHDMI_ACR_32_0 + engine_offset[engine_id];
 
-			value = dal_read_reg(hw_ctx->ctx, addr);
+			value = dm_read_reg(hw_ctx->ctx, addr);
 
 			set_reg_field_value(value, audio_clock_info.cts_32khz,
 				HDMI_ACR_32_0,
 				HDMI_ACR_CTS_32);
 
-			dal_write_reg(hw_ctx->ctx, addr, value);
+			dm_write_reg(hw_ctx->ctx, addr, value);
 		}
 
 		/* HDMI_ACR_32_1__HDMI_ACR_N_32_MASK */
 		{
 			addr = mmHDMI_ACR_32_1 + engine_offset[engine_id];
 
-			value = dal_read_reg(hw_ctx->ctx, addr);
+			value = dm_read_reg(hw_ctx->ctx, addr);
 			set_reg_field_value(value, audio_clock_info.n_32khz,
 				HDMI_ACR_32_1,
 				HDMI_ACR_N_32);
 
-			dal_write_reg(hw_ctx->ctx, addr, value);
+			dm_write_reg(hw_ctx->ctx, addr, value);
 		}
 
 		/* HDMI_ACR_44_0__HDMI_ACR_CTS_44_MASK */
 		{
 			addr = mmHDMI_ACR_44_0 + engine_offset[engine_id];
 
-			value = dal_read_reg(hw_ctx->ctx, addr);
+			value = dm_read_reg(hw_ctx->ctx, addr);
 			set_reg_field_value(value, audio_clock_info.cts_44khz,
 				HDMI_ACR_44_0,
 				HDMI_ACR_CTS_44);
 
-			dal_write_reg(hw_ctx->ctx, addr, value);
+			dm_write_reg(hw_ctx->ctx, addr, value);
 		}
 
 		/* HDMI_ACR_44_1__HDMI_ACR_N_44_MASK */
 		{
 			addr = mmHDMI_ACR_44_1 + engine_offset[engine_id];
 
-			value = dal_read_reg(hw_ctx->ctx, addr);
+			value = dm_read_reg(hw_ctx->ctx, addr);
 			set_reg_field_value(value, audio_clock_info.n_44khz,
 				HDMI_ACR_44_1,
 				HDMI_ACR_N_44);
 
-			dal_write_reg(hw_ctx->ctx, addr, value);
+			dm_write_reg(hw_ctx->ctx, addr, value);
 		}
 
 		/* HDMI_ACR_48_0__HDMI_ACR_CTS_48_MASK */
 		{
 			addr = mmHDMI_ACR_48_0 + engine_offset[engine_id];
 
-			value = dal_read_reg(hw_ctx->ctx, addr);
+			value = dm_read_reg(hw_ctx->ctx, addr);
 			set_reg_field_value(value, audio_clock_info.cts_48khz,
 				HDMI_ACR_48_0,
 				HDMI_ACR_CTS_48);
 
-			dal_write_reg(hw_ctx->ctx, addr, value);
+			dm_write_reg(hw_ctx->ctx, addr, value);
 		}
 
 		/* HDMI_ACR_48_1__HDMI_ACR_N_48_MASK */
 		{
 			addr = mmHDMI_ACR_48_1 + engine_offset[engine_id];
 
-			value = dal_read_reg(hw_ctx->ctx, addr);
+			value = dm_read_reg(hw_ctx->ctx, addr);
 			set_reg_field_value(value, audio_clock_info.n_48khz,
 				HDMI_ACR_48_1,
 				HDMI_ACR_N_48);
 
-			dal_write_reg(hw_ctx->ctx, addr, value);
+			dm_write_reg(hw_ctx->ctx, addr, value);
 		}
 
 		/* Video driver cannot know in advance which sample rate will
@@ -675,7 +676,7 @@ static void setup_hdmi_audio(
 	{
 		addr = mmAFMT_60958_0 + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value, 1,
 			AFMT_60958_0,
 			AFMT_60958_CS_CHANNEL_NUMBER_L);
@@ -685,19 +686,19 @@ static void setup_hdmi_audio(
 			AFMT_60958_0,
 			AFMT_60958_CS_CLOCK_ACCURACY);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AFMT_60958_1 AFMT_60958_CS_CHALNNEL_NUMBER_R */
 	{
 		addr = mmAFMT_60958_1 + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value, 2,
 			AFMT_60958_1,
 			AFMT_60958_CS_CHANNEL_NUMBER_R);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/*AFMT_60958_2 now keep this settings until
@@ -705,7 +706,7 @@ static void setup_hdmi_audio(
 	{
 		addr = mmAFMT_60958_2 + engine_offset[engine_id];
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value, 3,
 			AFMT_60958_2,
 			AFMT_60958_CS_CHANNEL_NUMBER_2);
@@ -730,7 +731,7 @@ static void setup_hdmi_audio(
 			AFMT_60958_2,
 			AFMT_60958_CS_CHANNEL_NUMBER_7);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 }
 
@@ -751,7 +752,7 @@ static void setup_dp_audio(
 			DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT,
 			DP_SEC_AUD_N,
 			DP_SEC_AUD_N);
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* Async/auto-calc timestamp mode */
@@ -766,7 +767,7 @@ static void setup_dp_audio(
 			DP_SEC_TIMESTAMP,
 			DP_SEC_TIMESTAMP_MODE);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* --- The following are the registers
@@ -780,13 +781,13 @@ static void setup_dp_audio(
 
 		value = 0;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value,
 			1,
 			AFMT_AUDIO_PACKET_CONTROL,
 			AFMT_60958_CS_UPDATE);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AFMT_AUDIO_PACKET_CONTROL2 */
@@ -796,7 +797,7 @@ static void setup_dp_audio(
 
 		value = 0;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value,
 			0,
 			AFMT_AUDIO_PACKET_CONTROL2,
@@ -807,7 +808,7 @@ static void setup_dp_audio(
 			AFMT_AUDIO_PACKET_CONTROL2,
 			AFMT_60958_OSF_OVRD);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AFMT_INFOFRAME_CONTROL0 */
@@ -817,14 +818,14 @@ static void setup_dp_audio(
 
 		value = 0;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value,
 			1,
 			AFMT_INFOFRAME_CONTROL0,
 			AFMT_AUDIO_INFO_UPDATE);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY_MASK */
@@ -833,13 +834,13 @@ static void setup_dp_audio(
 
 		value = 0;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 		set_reg_field_value(value,
 			0,
 			AFMT_60958_0,
 			AFMT_60958_CS_CLOCK_ACCURACY);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 }
 
@@ -878,12 +879,12 @@ static void enable_afmt_clock(
 	uint32_t enable = enable_flag ? 1:0;
 
 	/* Enable Audio packets*/
-	value = dal_read_reg(hw_ctx->ctx, mmAFMT_CNTL + engine_offs);
+	value = dm_read_reg(hw_ctx->ctx, mmAFMT_CNTL + engine_offs);
 
 	/*enable AFMT clock*/
 	set_reg_field_value(value, enable,
 		AFMT_CNTL, AFMT_AUDIO_CLOCK_EN);
-	dal_write_reg(hw_ctx->ctx, mmAFMT_CNTL + engine_offs, value);
+	dm_write_reg(hw_ctx->ctx, mmAFMT_CNTL + engine_offs, value);
 
 	/*wait for AFMT clock to turn on,
 	 * the expectation is that this
@@ -891,8 +892,8 @@ static void enable_afmt_clock(
 	 */
 	do {
 		/* Wait for 1us between subsequent register reads.*/
-		dc_service_delay_in_microseconds(hw_ctx->ctx, 1);
-		value = dal_read_reg(hw_ctx->ctx,
+		dm_delay_in_microseconds(hw_ctx->ctx, 1);
+		value = dm_read_reg(hw_ctx->ctx,
 				mmAFMT_CNTL + engine_offs);
 	} while (get_reg_field_value(value,
 				AFMT_CNTL, AFMT_AUDIO_CLOCK_ON) !=
@@ -954,12 +955,12 @@ static void enable_dp_audio(
 	uint32_t value;
 
 	/* Enable Audio packets */
-	value = dal_read_reg(hw_ctx->ctx, addr);
+	value = dm_read_reg(hw_ctx->ctx, addr);
 	set_reg_field_value(value, 1,
 		DP_SEC_CNTL,
 		DP_SEC_ASP_ENABLE);
 
-	dal_write_reg(hw_ctx->ctx, addr, value);
+	dm_write_reg(hw_ctx->ctx, addr, value);
 
 	/* Program the ATP and AIP next */
 	set_reg_field_value(value, 1,
@@ -970,14 +971,14 @@ static void enable_dp_audio(
 		DP_SEC_CNTL,
 		DP_SEC_AIP_ENABLE);
 
-	dal_write_reg(hw_ctx->ctx, addr, value);
+	dm_write_reg(hw_ctx->ctx, addr, value);
 
 	/* Program STREAM_ENABLE after all the other enables. */
 	set_reg_field_value(value, 1,
 		DP_SEC_CNTL,
 		DP_SEC_STREAM_ENABLE);
 
-	dal_write_reg(hw_ctx->ctx, addr, value);
+	dm_write_reg(hw_ctx->ctx, addr, value);
 }
 
 /* disable DP audio */
@@ -990,7 +991,7 @@ static void disable_dp_audio(
 	uint32_t value;
 
 	/* Disable Audio packets */
-	value = dal_read_reg(hw_ctx->ctx, addr);
+	value = dm_read_reg(hw_ctx->ctx, addr);
 
 	set_reg_field_value(value, 0,
 		DP_SEC_CNTL,
@@ -1019,7 +1020,7 @@ static void disable_dp_audio(
 			DP_SEC_CNTL,
 			DP_SEC_STREAM_ENABLE);
 
-	dal_write_reg(hw_ctx->ctx, addr, value);
+	dm_write_reg(hw_ctx->ctx, addr, value);
 }
 
 static void configure_azalia(
@@ -1232,7 +1233,7 @@ static void configure_azalia(
 	} /* for */
 
 	if (is_ac3_supported)
-		dal_write_reg(hw_ctx->ctx,
+		dm_write_reg(hw_ctx->ctx,
 		mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
 		0x05);
 
@@ -1454,21 +1455,21 @@ static void setup_azalia(
 			AFMT_AUDIO_SRC_CONTROL,
 			AFMT_AUDIO_SRC_SELECT);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/* Channel allocation */
 	{
 		const uint32_t addr =
 			mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
-		uint32_t value = dal_read_reg(hw_ctx->ctx, addr);
+		uint32_t value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value,
 			channels,
 			AFMT_AUDIO_PACKET_CONTROL2,
 			AFMT_AUDIO_CHANNEL_ENABLE);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	configure_azalia(hw_ctx, signal, crtc_info, audio_info);
@@ -1484,12 +1485,12 @@ static void unmute_azalia_audio(
 
 	uint32_t value = 0;
 
-	value = dal_read_reg(hw_ctx->ctx, addr);
+	value = dm_read_reg(hw_ctx->ctx, addr);
 
 	set_reg_field_value(value, 1,
 		AFMT_AUDIO_PACKET_CONTROL, AFMT_AUDIO_SAMPLE_SEND);
 
-	dal_write_reg(hw_ctx->ctx, addr, value);
+	dm_write_reg(hw_ctx->ctx, addr, value);
 }
 
 /* mute audio */
@@ -1502,12 +1503,12 @@ static void mute_azalia_audio(
 
 	uint32_t value = 0;
 
-	value = dal_read_reg(hw_ctx->ctx, addr);
+	value = dm_read_reg(hw_ctx->ctx, addr);
 
 	set_reg_field_value(value, 0,
 		AFMT_AUDIO_PACKET_CONTROL, AFMT_AUDIO_SAMPLE_SEND);
 
-	dal_write_reg(hw_ctx->ctx, addr, value);
+	dm_write_reg(hw_ctx->ctx, addr, value);
 }
 
 /* enable channel splitting mapping */
@@ -1646,13 +1647,13 @@ static void hw_initialize(
 	{
 		uint32_t value;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value, 0x70,
 		AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES,
 		AUDIO_RATE_CAPABILITIES);
 
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 
 	/*Keep alive bit to verify HW block in BU. */
@@ -1660,7 +1661,7 @@ static void hw_initialize(
 	{
 		uint32_t value;
 
-		value = dal_read_reg(hw_ctx->ctx, addr);
+		value = dm_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value, 1,
 		AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
@@ -1669,7 +1670,7 @@ static void hw_initialize(
 		set_reg_field_value(value, 1,
 		AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
 		EPSS);
-		dal_write_reg(hw_ctx->ctx, addr, value);
+		dm_write_reg(hw_ctx->ctx, addr, value);
 	}
 }
 
@@ -1904,7 +1905,7 @@ struct hw_ctx_audio *dal_hw_ctx_audio_dce110_create(
 {
 	/* allocate memory for struc hw_ctx_audio_dce110 */
 	struct hw_ctx_audio_dce110 *hw_ctx_dce110 =
-			dc_service_alloc(ctx, sizeof(struct hw_ctx_audio_dce110));
+			dm_alloc(ctx, sizeof(struct hw_ctx_audio_dce110));
 
 	if (!hw_ctx_dce110) {
 		ASSERT_CRITICAL(hw_ctx_dce110);
@@ -1923,7 +1924,7 @@ struct hw_ctx_audio *dal_hw_ctx_audio_dce110_create(
 		"Failed to create hw_ctx_audio for DCE11\n");
 
 
-	dc_service_free(ctx, hw_ctx_dce110);
+	dm_free(ctx, hw_ctx_dce110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
index a78ab79..58207f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "hw_ctx_audio.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/conversion.c b/drivers/gpu/drm/amd/dal/dc/basics/conversion.c
index 0eb7813..2f1f3d4 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/conversion.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/conversion.c
@@ -23,7 +23,8 @@
  *
  */
 
-#include "dc_services.h"
+
+#include "dm_services.h"
 
 #define DIVIDER 10000
 
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/fixpt31_32.c b/drivers/gpu/drm/amd/dal/dc/basics/fixpt31_32.c
index 68626ba..9f93b3b 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/fixpt31_32.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/fixpt31_32.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/fixed31_32.h"
 
 static inline uint64_t abs_i64(
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c b/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c
index c52fe47..74e6d75 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/fixed32_32.h"
 
 static uint64_t u64_div(uint64_t n, uint64_t d)
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/grph_object_id.c b/drivers/gpu/drm/amd/dal/dc/basics/grph_object_id.c
index 714a571..9c80847 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/grph_object_id.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/grph_object_id.c
@@ -23,8 +23,7 @@
  *
  */
 
-#include "dc_services.h"
-
+#include "dm_services.h"
 #include "include/grph_object_id.h"
 
 bool dal_graphics_object_id_is_valid(struct graphics_object_id id)
@@ -55,13 +54,13 @@ bool dal_graphics_object_id_is_equal(
 	struct graphics_object_id id2)
 {
 	if (false == dal_graphics_object_id_is_valid(id1)) {
-		dal_output_to_console(
+		dm_output_to_console(
 		"%s: Warning: comparing invalid object 'id1'!\n", __func__);
 		return false;
 	}
 
 	if (false == dal_graphics_object_id_is_valid(id2)) {
-		dal_output_to_console(
+		dm_output_to_console(
 		"%s: Warning: comparing invalid object 'id2'!\n", __func__);
 		return false;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/logger.c b/drivers/gpu/drm/amd/dal/dc/basics/logger.c
index 49cef8a..e7938ec 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/logger.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/logger.c
@@ -23,7 +23,7 @@
  *
  */
 #include <stdarg.h>
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/dal_types.h"
 #include "include/logger_interface.h"
 #include "logger.h"
@@ -283,7 +283,7 @@ static bool construct(struct dc_context *ctx, struct dal_logger *logger)
 	/* malloc buffer and init offsets */
 
 	logger->log_buffer_size = DAL_LOGGER_BUFFER_MAX_SIZE;
-	logger->log_buffer = (char *)dc_service_alloc(ctx,
+	logger->log_buffer = (char *)dm_alloc(ctx,
 		logger->log_buffer_size *
 		sizeof(char));
 
@@ -307,7 +307,7 @@ static bool construct(struct dc_context *ctx, struct dal_logger *logger)
 
 	/* malloc and init minor mask array */
 	logger->log_enable_mask_minors =
-			(uint32_t *)dc_service_alloc(
+			(uint32_t *)dm_alloc(
 				ctx,
 				NUM_ELEMENTS(log_major_mask_info_tbl)
 				* sizeof(uint32_t));
@@ -329,12 +329,12 @@ static bool construct(struct dc_context *ctx, struct dal_logger *logger)
 static void destruct(struct dal_logger *logger)
 {
 	if (logger->log_buffer) {
-		dc_service_free(logger->ctx, logger->log_buffer);
+		dm_free(logger->ctx, logger->log_buffer);
 		logger->log_buffer = NULL;
 	}
 
 	if (logger->log_enable_mask_minors) {
-		dc_service_free(logger->ctx, logger->log_enable_mask_minors);
+		dm_free(logger->ctx, logger->log_enable_mask_minors);
 		logger->log_enable_mask_minors = NULL;
 	}
 }
@@ -342,12 +342,12 @@ static void destruct(struct dal_logger *logger)
 struct dal_logger *dal_logger_create(struct dc_context *ctx)
 {
 	/* malloc struct */
-	struct dal_logger *logger = dc_service_alloc(ctx, sizeof(struct dal_logger));
+	struct dal_logger *logger = dm_alloc(ctx, sizeof(struct dal_logger));
 
 	if (!logger)
 		return NULL;
 	if (!construct(ctx, logger)) {
-		dc_service_free(ctx, logger);
+		dm_free(ctx, logger);
 		return NULL;
 	}
 
@@ -359,7 +359,7 @@ uint32_t dal_logger_destroy(struct dal_logger **logger)
 	if (logger == NULL || *logger == NULL)
 		return 1;
 	destruct(*logger);
-	dc_service_free((*logger)->ctx, *logger);
+	dm_free((*logger)->ctx, *logger);
 	*logger = NULL;
 
 	return 0;
@@ -403,10 +403,10 @@ static void log_to_debug_console(struct log_entry *entry)
 	if (entry->buf_offset) {
 		switch (entry->major) {
 		case LOG_MAJOR_ERROR:
-			dal_error("%s", entry->buf);
+			dm_error("%s", entry->buf);
 			break;
 		default:
-			dal_output_to_console("%s", entry->buf);
+			dm_output_to_console("%s", entry->buf);
 			break;
 		}
 	}
@@ -418,17 +418,17 @@ static void flush_to_debug_console(struct dal_logger *logger)
 	int i = logger->buffer_read_offset;
 	char *string_start = &logger->log_buffer[i];
 
-	dal_output_to_console(
+	dm_output_to_console(
 		"---------------- FLUSHING LOG BUFFER ----------------\n");
 	while (i < logger->buffer_write_offset)	{
 
 		if (logger->log_buffer[i] == '\0') {
-			dal_output_to_console("%s", string_start);
+			dm_output_to_console("%s", string_start);
 			string_start = (char *)logger->log_buffer + i + 1;
 		}
 		i++;
 	}
-	dal_output_to_console(
+	dm_output_to_console(
 		"-------------- END FLUSHING LOG BUFFER --------------\n\n");
 }
 
@@ -481,7 +481,7 @@ static void log_to_internal_buffer(struct log_entry *entry)
 			/* No wrap around, copy 'size' bytes
 			 * from 'entry->buf' to 'log_buffer'
 			 */
-			dc_service_memmove(logger->log_buffer +
+			dm_memmove(logger->log_buffer +
 					logger->buffer_write_offset,
 					entry->buf, size);
 			logger->buffer_write_offset += size;
@@ -493,10 +493,10 @@ static void log_to_internal_buffer(struct log_entry *entry)
 			int space_after_wrap = total_free_space -
 					space_before_wrap;
 
-			dc_service_memmove(logger->log_buffer +
+			dm_memmove(logger->log_buffer +
 					logger->buffer_write_offset,
 					entry->buf, space_before_wrap);
-			dc_service_memmove(logger->log_buffer, entry->buf +
+			dm_memmove(logger->log_buffer, entry->buf +
 					space_before_wrap, space_after_wrap);
 
 			logger->buffer_write_offset = space_after_wrap;
@@ -510,7 +510,7 @@ static void log_to_internal_buffer(struct log_entry *entry)
 			flush_to_debug_console(logger);
 
 			/* Start writing to beginning of buffer */
-			dc_service_memmove(logger->log_buffer, entry->buf, size);
+			dm_memmove(logger->log_buffer, entry->buf, size);
 			logger->buffer_write_offset = size;
 			logger->buffer_read_offset = 0;
 		}
@@ -581,7 +581,7 @@ static void append_entry(
 	}
 
 	/* Todo: check if off by 1 byte due to \0 anywhere */
-	dc_service_memmove(entry->buf + entry->buf_offset, buffer, buf_size);
+	dm_memmove(entry->buf + entry->buf_offset, buffer, buf_size);
 	entry->buf_offset += buf_size;
 }
 
@@ -609,7 +609,7 @@ void dal_logger_write(
 		dal_logger_open(logger, &entry, major, minor);
 
 
-		size = dal_log_to_buffer(
+		size = dm_log_to_buffer(
 			buffer, DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE, msg, args);
 
 		if (size > 0 && size <
@@ -658,7 +658,7 @@ void dal_logger_append(
 
 		va_start(args, msg);
 
-		size = dal_log_to_buffer(
+		size = dm_log_to_buffer(
 			buffer, DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE, msg, args);
 
 		if (size < DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE - 1) {
@@ -763,7 +763,7 @@ void dal_logger_open(
 	entry->minor = 0;
 	entry->logger = logger;
 
-	entry->buf = dc_service_alloc(
+	entry->buf = dm_alloc(
 		logger->ctx,
 		DAL_LOGGER_BUFFER_MAX_SIZE * sizeof(char));
 
@@ -799,7 +799,7 @@ void dal_logger_close(struct log_entry *entry)
 
 cleanup:
 	if (entry->buf) {
-		dc_service_free(entry->logger->ctx, entry->buf);
+		dm_free(entry->logger->ctx, entry->buf);
 		entry->buf = NULL;
 		entry->buf_offset = 0;
 		entry->max_buf_bytes = 0;
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/register_logger.c b/drivers/gpu/drm/amd/dal/dc/basics/register_logger.c
index 5dcf3fc..6d32b1b 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/register_logger.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/register_logger.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/dal_types.h"
 #include "include/logger_interface.h"
 #include "logger.h"
@@ -74,8 +74,8 @@ static bool is_reg_dump_process(void)
 		struct dal_reg_dump_stack_location *stack_location
 					= &reg_dump_stack.stack_locations[i];
 
-		if (stack_location->current_pid == dal_get_pid()
-			&& stack_location->current_tgid == dal_get_tgid())
+		if (stack_location->current_pid == dm_get_pid()
+			&& stack_location->current_tgid == dm_get_tgid())
 			return true;
 	}
 
@@ -96,7 +96,7 @@ static struct dal_reg_dump_stack_location *dal_reg_dump_stack_push(void)
 
 	if (reg_dump_stack.stack_pointer >= DAL_REG_DUMP_STACK_MAX_SIZE) {
 		/* stack is full */
-		dal_output_to_console("[REG_DUMP]: %s: stack is full!\n",
+		dm_output_to_console("[REG_DUMP]: %s: stack is full!\n",
 				__func__);
 	} else {
 		current_location =
@@ -113,7 +113,7 @@ static struct dal_reg_dump_stack_location *dal_reg_dump_stack_pop(void)
 
 	if (dal_reg_dump_stack_is_empty()) {
 		/* stack is empty */
-		dal_output_to_console("[REG_DUMP]: %s: stack is empty!\n",
+		dm_output_to_console("[REG_DUMP]: %s: stack is empty!\n",
 				__func__);
 	} else {
 		--reg_dump_stack.stack_pointer;
@@ -137,13 +137,13 @@ void dal_reg_logger_push(const char *caller_func)
 	if (NULL == free_stack_location)
 		return;
 
-	dc_service_memset(free_stack_location, 0, sizeof(*free_stack_location));
+	dm_memset(free_stack_location, 0, sizeof(*free_stack_location));
 
 	free_stack_location->current_caller_func = caller_func;
-	free_stack_location->current_pid = dal_get_pid();
-	free_stack_location->current_tgid = dal_get_tgid();
+	free_stack_location->current_pid = dm_get_pid();
+	free_stack_location->current_tgid = dm_get_tgid();
 
-	dal_output_to_console("[REG_DUMP]:%s - start (pid:%ld, tgid:%ld)\n",
+	dm_output_to_console("[REG_DUMP]:%s - start (pid:%ld, tgid:%ld)\n",
 		caller_func,
 		free_stack_location->current_pid,
 		free_stack_location->current_tgid);
@@ -156,21 +156,21 @@ void dal_reg_logger_pop(void)
 	top_stack_location = dal_reg_dump_stack_pop();
 
 	if (NULL == top_stack_location) {
-		dal_output_to_console("[REG_DUMP]:%s - Stack is Empty!\n",
+		dm_output_to_console("[REG_DUMP]:%s - Stack is Empty!\n",
 				__func__);
 		return;
 	}
 
-	dal_output_to_console(
+	dm_output_to_console(
 	"[REG_DUMP]:%s - end."\
 	" Reg R/W Count: Total=%d Function=%d. (pid:%ld, tgid:%ld)\n",
 			top_stack_location->current_caller_func,
 			reg_dump_stack.total_rw_count,
 			top_stack_location->rw_count,
-			dal_get_pid(),
-			dal_get_tgid());
+			dm_get_pid(),
+			dm_get_tgid());
 
-	dc_service_memset(top_stack_location, 0, sizeof(*top_stack_location));
+	dm_memset(top_stack_location, 0, sizeof(*top_stack_location));
 }
 
 void dal_reg_logger_rw_count_increment(void)
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/signal_types.c b/drivers/gpu/drm/amd/dal/dc/basics/signal_types.c
index f589091..44447e0 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/signal_types.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/signal_types.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/signal_types.h"
 
 bool dc_is_hdmi_signal(enum signal_type signal)
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/vector.c b/drivers/gpu/drm/amd/dal/dc/basics/vector.c
index ea682a7..32ca6b1 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/vector.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/vector.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/vector.h"
 
 bool dal_vector_construct(
@@ -40,7 +40,7 @@ bool dal_vector_construct(
 		return false;
 	}
 
-	vector->container = dc_service_alloc(ctx, struct_size * capacity);
+	vector->container = dm_alloc(ctx, struct_size * capacity);
 	if (vector->container == NULL)
 		return false;
 	vector->capacity = capacity;
@@ -67,7 +67,7 @@ bool dal_vector_presized_costruct(
 		return false;
 	}
 
-	vector->container = dc_service_alloc(ctx, struct_size * count);
+	vector->container = dm_alloc(ctx, struct_size * count);
 
 	if (vector->container == NULL)
 		return false;
@@ -77,7 +77,7 @@ bool dal_vector_presized_costruct(
 	 * initialises the memory to. */
 	if (NULL != initial_value) {
 		for (i = 0; i < count; ++i)
-			dc_service_memmove(
+			dm_memmove(
 				vector->container + i * struct_size,
 				initial_value,
 				struct_size);
@@ -95,7 +95,7 @@ struct vector *dal_vector_presized_create(
 	void *initial_value,
 	uint32_t struct_size)
 {
-	struct vector *vector = dc_service_alloc(ctx, sizeof(struct vector));
+	struct vector *vector = dm_alloc(ctx, sizeof(struct vector));
 
 	if (vector == NULL)
 		return NULL;
@@ -105,7 +105,7 @@ struct vector *dal_vector_presized_create(
 		return vector;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, vector);
+	dm_free(ctx, vector);
 	return NULL;
 }
 
@@ -114,7 +114,7 @@ struct vector *dal_vector_create(
 	uint32_t capacity,
 	uint32_t struct_size)
 {
-	struct vector *vector = dc_service_alloc(ctx, sizeof(struct vector));
+	struct vector *vector = dm_alloc(ctx, sizeof(struct vector));
 
 	if (vector == NULL)
 		return NULL;
@@ -124,7 +124,7 @@ struct vector *dal_vector_create(
 
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, vector);
+	dm_free(ctx, vector);
 	return NULL;
 }
 
@@ -132,7 +132,7 @@ void dal_vector_destruct(
 	struct vector *vector)
 {
 	if (vector->container != NULL)
-		dc_service_free(vector->ctx, vector->container);
+		dm_free(vector->ctx, vector->container);
 	vector->count = 0;
 	vector->capacity = 0;
 }
@@ -143,7 +143,7 @@ void dal_vector_destroy(
 	if (vector == NULL || *vector == NULL)
 		return;
 	dal_vector_destruct(*vector);
-	dc_service_free((*vector)->ctx, *vector);
+	dm_free((*vector)->ctx, *vector);
 	*vector = NULL;
 }
 
@@ -170,7 +170,7 @@ bool dal_vector_remove_at_index(
 		return false;
 
 	if (index != vector->count - 1)
-		dc_service_memmove(
+		dm_memmove(
 			vector->container + (index * vector->struct_size),
 			vector->container + ((index + 1) * vector->struct_size),
 			(vector->count - index - 1) * vector->struct_size);
@@ -190,7 +190,7 @@ void dal_vector_set_at_index(
 		BREAK_TO_DEBUGGER();
 		return;
 	}
-	dc_service_memmove(
+	dm_memmove(
 		where,
 		what,
 		vector->struct_size);
@@ -219,12 +219,12 @@ bool dal_vector_insert_at(
 	insert_address = vector->container + (vector->struct_size * position);
 
 	if (vector->count && position < vector->count)
-		dc_service_memmove(
+		dm_memmove(
 			insert_address + vector->struct_size,
 			insert_address,
 			vector->struct_size * (vector->count - position));
 
-	dc_service_memmove(
+	dm_memmove(
 		insert_address,
 		what,
 		vector->struct_size);
@@ -273,7 +273,7 @@ struct vector *dal_vector_clone(
 	}
 
 	/* copy vector's data */
-	dc_service_memmove(vec_cloned->container, vector->container,
+	dm_memmove(vec_cloned->container, vector->container,
 			vec_cloned->struct_size * vec_cloned->capacity);
 
 	return vec_cloned;
@@ -291,7 +291,7 @@ bool dal_vector_reserve(struct vector *vector, uint32_t capacity)
 	if (capacity <= vector->capacity)
 		return true;
 
-	new_container = dc_service_realloc(vector->ctx, vector->container,
+	new_container = dm_realloc(vector->ctx, vector->container,
 		capacity * vector->struct_size);
 
 	if (new_container) {
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
index 2ef2543..4ce5f9f 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "atom.h"
 
@@ -120,14 +120,14 @@ struct dc_bios *dal_bios_parser_create(
 {
 	struct bios_parser *bp = NULL;
 
-	bp = dc_service_alloc(init->ctx, sizeof(struct bios_parser));
+	bp = dm_alloc(init->ctx, sizeof(struct bios_parser));
 	if (!bp)
 		return NULL;
 
 	if (bios_parser_construct(bp, init, as))
 		return &bp->base;
 
-	dc_service_free(init->ctx, bp);
+	dm_free(init->ctx, bp);
 	BREAK_TO_DEBUGGER();
 	return NULL;
 }
@@ -135,7 +135,7 @@ struct dc_bios *dal_bios_parser_create(
 static void destruct(struct bios_parser *bp)
 {
 	if (bp->bios_local_image)
-		dc_service_free(bp->ctx, bp->bios_local_image);
+		dm_free(bp->ctx, bp->bios_local_image);
 }
 
 void dal_bios_parser_destroy(struct dc_bios **dcb)
@@ -149,7 +149,7 @@ void dal_bios_parser_destroy(struct dc_bios **dcb)
 
 	destruct(bp);
 
-	dc_service_free((bp)->ctx, bp);
+	dm_free((bp)->ctx, bp);
 	*dcb = NULL;
 }
 
@@ -378,7 +378,7 @@ static enum bp_result bios_parser_get_oem_ddc_info(struct dc_bios *dcb,
 			ATOM_I2C_RECORD record;
 			ATOM_I2C_ID_CONFIG_ACCESS *config;
 
-			dc_service_memset(&record, 0, sizeof(record));
+			dm_memset(&record, 0, sizeof(record));
 
 			config = &tbl->sucI2cId + index - 1;
 
@@ -875,7 +875,7 @@ static enum bp_result get_firmware_info_v1_4(
 	if (!firmware_info)
 		return BP_RESULT_BADBIOSTABLE;
 
-	dc_service_memset(info, 0, sizeof(*info));
+	dm_memset(info, 0, sizeof(*info));
 
 	/* Pixel clock pll information. We need to convert from 10KHz units into
 	 * KHz units */
@@ -926,7 +926,7 @@ static enum bp_result get_firmware_info_v2_1(
 	if (!firmwareInfo)
 		return BP_RESULT_BADBIOSTABLE;
 
-	dc_service_memset(info, 0, sizeof(*info));
+	dm_memset(info, 0, sizeof(*info));
 
 	/* Pixel clock pll information. We need to convert from 10KHz units into
 	 * KHz units */
@@ -1012,7 +1012,7 @@ static enum bp_result get_firmware_info_v2_2(
 	if (!firmware_info)
 		return BP_RESULT_BADBIOSTABLE;
 
-	dc_service_memset(info, 0, sizeof(*info));
+	dm_memset(info, 0, sizeof(*info));
 
 	/* Pixel clock pll information. We need to convert from 10KHz units into
 	 * KHz units */
@@ -1117,7 +1117,7 @@ static enum bp_result get_ss_info_v3_1(
 	tbl = (ATOM_ASIC_SS_ASSIGNMENT_V3 *)
 				&ss_table_header_include->asSpreadSpectrum[0];
 
-	dc_service_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
+	dm_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
 
 	for (i = 0; i < table_size; i++) {
 		if (tbl[i].ucClockIndication != (uint8_t) id)
@@ -1664,7 +1664,7 @@ static enum bp_result get_ss_info_from_internal_ss_info_tbl_V2_1(
 	header = GET_IMAGE(ATOM_ASIC_INTERNAL_SS_INFO_V2,
 		DATA_TABLES(ASIC_InternalSS_Info));
 
-	dc_service_memset(info, 0, sizeof(struct spread_spectrum_info));
+	dm_memset(info, 0, sizeof(struct spread_spectrum_info));
 
 	tbl_size = (le16_to_cpu(header->sHeader.usStructureSize)
 			- sizeof(ATOM_COMMON_TABLE_HEADER))
@@ -1768,7 +1768,7 @@ static enum bp_result get_ss_info_from_ss_info_table(
 		if (id_local != (uint32_t)tbl->asSS_Info[i].ucSS_Id)
 			continue;
 
-		dc_service_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
+		dm_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
 
 		if (ATOM_EXTERNAL_SS_MASK &
 				tbl->asSS_Info[i].ucSpreadSpectrumType)
@@ -1860,7 +1860,7 @@ static enum bp_result get_embedded_panel_info_v1_2(
 		|| 2 > lvds->sHeader.ucTableContentRevision)
 		return BP_RESULT_UNSUPPORTED;
 
-	dc_service_memset(info, 0, sizeof(struct embedded_panel_info));
+	dm_memset(info, 0, sizeof(struct embedded_panel_info));
 
 	/* We need to convert from 10KHz units into KHz units*/
 	info->lcd_timing.pixel_clk =
@@ -1978,7 +1978,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 			&& (3 <= lvds->sHeader.ucTableContentRevision)))
 		return BP_RESULT_UNSUPPORTED;
 
-	dc_service_memset(info, 0, sizeof(struct embedded_panel_info));
+	dm_memset(info, 0, sizeof(struct embedded_panel_info));
 
 	/* We need to convert from 10KHz units into KHz units */
 	info->lcd_timing.pixel_clk =
@@ -2551,7 +2551,7 @@ static enum bp_result bios_parser_get_faked_edid_buf(
 	if (len < edid_size)
 		return BP_RESULT_BADINPUT; /* buffer not big enough to fill */
 
-	dc_service_memmove(buff, &edid_record->ucFakeEDIDString, edid_size);
+	dm_memmove(buff, &edid_record->ucFakeEDIDString, edid_size);
 
 	return BP_RESULT_OK;
 }
@@ -3540,7 +3540,7 @@ static uint32_t enum_first_device_id(uint32_t dev_id)
 
 	/* No group found for this device ID. */
 
-	dal_error("%s: incorrect input %d\n", __func__, dev_id);
+	dm_error("%s: incorrect input %d\n", __func__, dev_id);
 	/* No matching support flag for given device ID */
 	return 0;
 }
@@ -3830,7 +3830,7 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 	if (!opm_object)
 		return BP_RESULT_UNSUPPORTED;
 
-	dc_service_memset(&ext_display_connection_info_tbl, 0,
+	dm_memset(&ext_display_connection_info_tbl, 0,
 			sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO));
 
 	connector_tbl_offset = bp->object_info_tbl_offset
@@ -4088,14 +4088,14 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 		uint8_t *original_bios;
 		/* Step 1: Replace bios image with the new copy which will be
 		 * patched */
-		bp->bios_local_image = dc_service_alloc(bp->ctx, bp->bios_size);
+		bp->bios_local_image = dm_alloc(bp->ctx, bp->bios_size);
 		if (bp->bios_local_image == NULL) {
 			BREAK_TO_DEBUGGER();
 			/* Failed to alloc bp->bios_local_image */
 			return;
 		}
 
-		dc_service_memmove(bp->bios_local_image, bp->bios, bp->bios_size);
+		dm_memmove(bp->bios_local_image, bp->bios, bp->bios_size);
 		original_bios = bp->bios;
 		bp->bios = bp->bios_local_image;
 		connector_tbl =
@@ -4109,7 +4109,7 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 			/* Patching the bios image has failed. We will copy
 			 * again original image provided and afterwards
 			 * only remove null entries */
-			dc_service_memmove(
+			dm_memmove(
 					bp->bios_local_image,
 					original_bios,
 					bp->bios_size);
@@ -4126,7 +4126,7 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 				continue;
 
 			if (i != connectors_num) {
-				dc_service_memmove(
+				dm_memmove(
 						&connector_tbl->
 						asObjects[connectors_num],
 						object,
@@ -4673,7 +4673,7 @@ static struct integrated_info *bios_parser_create_integrated_info(
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct integrated_info *info = NULL;
 
-	info = dc_service_alloc(bp->ctx, sizeof(struct integrated_info));
+	info = dm_alloc(bp->ctx, sizeof(struct integrated_info));
 
 	if (info == NULL) {
 		ASSERT_CRITICAL(0);
@@ -4683,7 +4683,7 @@ static struct integrated_info *bios_parser_create_integrated_info(
 	if (construct_integrated_info(bp, info) == BP_RESULT_OK)
 		return info;
 
-	dc_service_free(bp->ctx, info);
+	dm_free(bp->ctx, info);
 
 	return NULL;
 }
@@ -4700,7 +4700,7 @@ static void bios_parser_destroy_integrated_info(
 	}
 
 	if (*info != NULL) {
-		dc_service_free(bp->ctx, *info);
+		dm_free(bp->ctx, *info);
 		*info = NULL;
 	}
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c
index fe05df2..0aa227a 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser_helper.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "atom.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
index 1a27bc8..3bc52f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "atom.h"
 
@@ -44,7 +44,7 @@
 		GetIndexIntoMasterTable(COMMAND, command), &frev, &crev)
 
 #define BIOS_CMD_TABLE_PARA_REVISION(command)\
-	dal_bios_cmd_table_para_revision(bp->ctx, \
+	dm_bios_cmd_table_para_revision(bp->ctx, \
 		GetIndexIntoMasterTable(COMMAND, command))
 
 
@@ -367,7 +367,7 @@ static enum bp_result transmitter_control_v2(
 	enum connector_id connector_id =
 		dal_graphics_object_id_get_connector_id(cntl->connector_obj_id);
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	switch (cntl->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -491,7 +491,7 @@ static enum bp_result transmitter_control_v3(
 	bool dual_link_conn = (CONNECTOR_ID_DUAL_LINK_DVII == conn_id)
 					|| (CONNECTOR_ID_DUAL_LINK_DVID == conn_id);
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	switch (cntl->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -640,7 +640,7 @@ static enum bp_result transmitter_control_v4(
 			dal_graphics_object_id_get_connector_id(cntl->connector_obj_id);
 	const struct command_table_helper *cmd = bp->cmd_helper;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	switch (cntl->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -778,7 +778,7 @@ static enum bp_result transmitter_control_v1_5(
 	const struct command_table_helper *cmd = bp->cmd_helper;
 	DIG_TRANSMITTER_CONTROL_PARAMETERS_V1_5 params;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 	params.ucPhyId = cmd->phy_id_to_atom(cntl->transmitter);
 	params.ucAction = (uint8_t)cntl->action;
 	params.ucLaneNum = (uint8_t)cntl->lanes_number;
@@ -844,7 +844,7 @@ static enum bp_result transmitter_control_v1_6(
 	const struct command_table_helper *cmd = bp->cmd_helper;
 	DIG_TRANSMITTER_CONTROL_PARAMETERS_V1_6 params;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 	params.ucPhyId = cmd->phy_id_to_atom(cntl->transmitter);
 	params.ucAction = (uint8_t)cntl->action;
 
@@ -948,7 +948,7 @@ static enum bp_result set_pixel_clock_v3(
 	PIXEL_CLOCK_PARAMETERS_V3 *params;
 	SET_PIXEL_CLOCK_PS_ALLOCATION allocation;
 
-	dc_service_memset(&allocation, 0, sizeof(allocation));
+	dm_memset(&allocation, 0, sizeof(allocation));
 
 	if (CLOCK_SOURCE_ID_PLL1 == bp_params->pll_id)
 		allocation.sPCLKInput.ucPpll = ATOM_PPLL1;
@@ -1021,7 +1021,7 @@ static enum bp_result set_pixel_clock_v5(
 	uint8_t controller_id;
 	uint32_t pll_id;
 
-	dc_service_memset(&clk, 0, sizeof(clk));
+	dm_memset(&clk, 0, sizeof(clk));
 
 	if (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)
 			&& bp->cmd_helper->controller_id_to_atom(
@@ -1078,7 +1078,7 @@ static enum bp_result set_pixel_clock_v6(
 	uint8_t controller_id;
 	uint32_t pll_id;
 
-	dc_service_memset(&clk, 0, sizeof(clk));
+	dm_memset(&clk, 0, sizeof(clk));
 
 	if (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)
 			&& bp->cmd_helper->controller_id_to_atom(
@@ -1157,7 +1157,7 @@ static enum bp_result set_pixel_clock_v7(
 	uint8_t controller_id;
 	uint32_t pll_id;
 
-	dc_service_memset(&clk, 0, sizeof(clk));
+	dm_memset(&clk, 0, sizeof(clk));
 
 	if (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)
 			&& bp->cmd_helper->controller_id_to_atom(bp_params->controller_id, &controller_id)) {
@@ -1267,7 +1267,7 @@ static enum bp_result enable_spread_spectrum_on_ppll_v1(
 	enum bp_result result = BP_RESULT_FAILURE;
 	ENABLE_SPREAD_SPECTRUM_ON_PPLL params;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	if ((enable == true) && (bp_params->percentage > 0))
 		params.ucEnable = ATOM_ENABLE;
@@ -1311,7 +1311,7 @@ static enum bp_result enable_spread_spectrum_on_ppll_v2(
 	enum bp_result result = BP_RESULT_FAILURE;
 	ENABLE_SPREAD_SPECTRUM_ON_PPLL_V2 params;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	if (bp_params->pll_id == CLOCK_SOURCE_ID_PLL1)
 		params.ucSpreadSpectrumType = ATOM_PPLL_SS_TYPE_V2_P1PLL;
@@ -1363,7 +1363,7 @@ static enum bp_result enable_spread_spectrum_on_ppll_v3(
 	enum bp_result result = BP_RESULT_FAILURE;
 	ENABLE_SPREAD_SPECTRUM_ON_PPLL_V3 params;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	switch (bp_params->pll_id) {
 	case CLOCK_SOURCE_ID_PLL0:
@@ -1484,7 +1484,7 @@ static enum bp_result adjust_display_pll_v3(
 	ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 params;
 	uint32_t pixel_clk_10_kHz_in = bp_params->pixel_clock / 10;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	/* We need to convert from KHz units into 10KHz units and then convert
 	 * output pixel clock back 10KHz-->KHz */
@@ -1731,7 +1731,7 @@ static enum signal_type dac_load_detection_v3(
 	DAC_LOAD_DETECTION_PS_ALLOCATION params;
 	enum signal_type signal = SIGNAL_TYPE_NONE;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	/* load detection is cupported for CRT, TV and CV */
 	switch (display_signal) {
@@ -2135,7 +2135,7 @@ static enum bp_result select_crtc_source_v2(
 	uint32_t atom_engine_id;
 	enum signal_type s = bp_params->signal;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	/* set controller id */
 	if (bp->cmd_helper->controller_id_to_atom(
@@ -2176,7 +2176,7 @@ static enum bp_result select_crtc_source_v3(
 	uint32_t atom_engine_id;
 	enum signal_type s = bp_params->signal;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	if (bp->cmd_helper->controller_id_to_atom(bp_params->controller_id,
 			&atom_controller_id))
@@ -2347,7 +2347,7 @@ static enum bp_result program_clock_v5(
 	SET_PIXEL_CLOCK_PS_ALLOCATION_V5 params;
 	uint32_t atom_pll_id;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 	if (!bp->cmd_helper->clock_source_id_to_atom(
 			bp_params->pll_id, &atom_pll_id)) {
 		BREAK_TO_DEBUGGER(); /* Invalid Inpute!! */
@@ -2378,7 +2378,7 @@ static enum bp_result program_clock_v6(
 	SET_PIXEL_CLOCK_PS_ALLOCATION_V6 params;
 	uint32_t atom_pll_id;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	if (!bp->cmd_helper->clock_source_id_to_atom(
 			bp_params->pll_id, &atom_pll_id)) {
@@ -2437,7 +2437,7 @@ static enum bp_result compute_memore_engine_pll_v4(
 	enum bp_result result = BP_RESULT_FAILURE;
 	COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V4 params;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	params.ulClock = cpu_to_le32(bp_params->target_display_clock / 10);
 
@@ -2493,7 +2493,7 @@ static enum bp_result external_encoder_control_v3(
 	struct graphics_object_id encoder;
 	bool is_input_signal_dp = false;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	cntl_params = &params.sExtEncoder;
 
@@ -2692,7 +2692,7 @@ static enum bp_result set_dce_clock_v2_1(
 	uint32_t atom_clock_type;
 	const struct command_table_helper *cmd = bp->cmd_helper;
 
-	dc_service_memset(&params, 0, sizeof(params));
+	dm_memset(&params, 0, sizeof(params));
 
 	if (!cmd->clock_source_id_to_atom(bp_params->pll_id, &atom_pll_id) ||
 			!cmd->dc_clock_type_to_atom(bp_params->clock_type, &atom_clock_type))
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c b/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c
index d379496..566604e 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "atom.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c b/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c
index f6c7df5..85d3103 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "atom.h"
 
@@ -52,11 +52,11 @@ static void set_scratch_acc_mode_change(
 	uint32_t addr = mmBIOS_SCRATCH_6;
 	uint32_t value = 0;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	value |= ATOM_S6_ACC_MODE;
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 /*
@@ -79,32 +79,32 @@ static void set_scratch_active_and_requested(
 	/* mmBIOS_SCRATCH_3 = mmBIOS_SCRATCH_0 + ATOM_ACTIVE_INFO_DEF */
 	addr = mmBIOS_SCRATCH_3;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	value &= ~ATOM_S3_DEVICE_ACTIVE_MASK;
 	value |= (d->active & ATOM_S3_DEVICE_ACTIVE_MASK);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* mmBIOS_SCRATCH_6 =  mmBIOS_SCRATCH_0 + ATOM_ACC_CHANGE_INFO_DEF */
 	addr = mmBIOS_SCRATCH_6;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	value &= ~ATOM_S6_ACC_REQ_MASK;
 	value |= (d->requested & ATOM_S6_ACC_REQ_MASK);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* mmBIOS_SCRATCH_5 =  mmBIOS_SCRATCH_0 + ATOM_DOS_REQ_INFO_DEF */
 	addr = mmBIOS_SCRATCH_5;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	value &= ~ATOM_S5_DOS_REQ_DEVICEw0;
 	value |= (d->active & ATOM_S5_DOS_REQ_DEVICEw0);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	d->active = 0;
 	d->requested = 0;
@@ -119,7 +119,7 @@ static enum lcd_scale get_scratch_lcd_scale(
 	uint32_t addr = mmBIOS_SCRATCH_6;
 	uint32_t value = 0;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	if (value & ATOM_S6_REQ_LCD_EXPANSION_FULL)
 		return LCD_SCALE_FULLPANEL;
@@ -235,7 +235,7 @@ static bool is_accelerated_mode(
 	struct dc_context *ctx)
 {
 	uint32_t addr = mmBIOS_SCRATCH_6;
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	return (value & ATOM_S6_ACC_MODE) ? true : false;
 }
@@ -275,7 +275,7 @@ static enum signal_type detect_sink(
 		return SIGNAL_TYPE_NONE;
 	}
 
-	bios_scratch0 = dal_read_reg(ctx,
+	bios_scratch0 = dm_read_reg(ctx,
 		mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF);
 
 	/* In further processing we use DACB masks. If we want detect load on
@@ -390,14 +390,14 @@ static void set_scratch_connected(
 	/* update scratch register */
 	addr = mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	if (connected)
 		value |= update;
 	else
 		value &= ~update;
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void set_scratch_critical_state(
@@ -405,14 +405,14 @@ static void set_scratch_critical_state(
 	bool state)
 {
 	uint32_t addr = mmBIOS_SCRATCH_6;
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	if (state)
 		value |= ATOM_S6_CRITICAL_STATE;
 	else
 		value &= ~ATOM_S6_CRITICAL_STATE;
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void set_scratch_lcd_scale(
@@ -430,7 +430,7 @@ static bool is_lid_open(struct dc_context *ctx)
 	uint32_t bios_scratch6;
 
 	bios_scratch6 =
-		dal_read_reg(
+		dm_read_reg(
 			ctx,
 			mmBIOS_SCRATCH_0 + ATOM_ACC_CHANGE_INFO_DEF);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c b/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c
index 182029b..614ba94 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c
@@ -23,7 +23,8 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
+
 #include "atom.h"
 
 #include "include/bios_parser_types.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
index 3cbf6f8..8faabbc 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
@@ -23,8 +23,7 @@
  *
  */
 
-#include "dc_services.h"
-
+#include "dm_services.h"
 #include "bandwidth_calcs.h"
 
 /*******************************************************************************
@@ -3704,10 +3703,10 @@ bool bw_calcs(struct dc_context *ctx, const struct bw_calcs_dceip *dceip,
 	const struct bw_calcs_mode_data *mode_data,
 	struct bw_calcs_output *calcs_output)
 {
-	struct bw_calcs_results *bw_results_internal = dc_service_alloc(
+	struct bw_calcs_results *bw_results_internal = dm_alloc(
 				ctx, sizeof(struct bw_calcs_results));
 	struct bw_calcs_mode_data_internal *bw_data_internal =
-		dc_service_alloc(
+		dm_alloc(
 			ctx, sizeof(struct bw_calcs_mode_data_internal));
 	switch (mode_data->number_of_displays) {
 	case (3):
@@ -3935,8 +3934,8 @@ bool bw_calcs(struct dc_context *ctx, const struct bw_calcs_dceip *dceip,
 		calcs_output->required_sclk = 0;
 	}
 
-	dc_service_free(ctx, bw_data_internal);
-	dc_service_free(ctx, bw_results_internal);
+	dm_free(ctx, bw_data_internal);
+	dm_free(ctx, bw_results_internal);
 
 	return is_display_configuration_supported(vbios, calcs_output);
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c b/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c
index b076bec..8a7a4c9 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "bw_fixed.h"
 
 
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c b/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
index 3dd8781..64ca203 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
@@ -22,7 +22,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/fixed31_32.h"
 
 #include "scaler_filter.h"
@@ -1099,7 +1099,7 @@ static bool allocate_3d_storage(
 	int32_t indexof_table = 0;
 	int32_t indexof_row = 0;
 
-	struct fixed31_32 ***tables = dc_service_alloc(
+	struct fixed31_32 ***tables = dm_alloc(
 		ctx,
 		numberof_tables * sizeof(struct fixed31_32 **));
 
@@ -1109,7 +1109,7 @@ static bool allocate_3d_storage(
 	}
 
 	while (indexof_table != numberof_tables) {
-		struct fixed31_32 **rows = dc_service_alloc(
+		struct fixed31_32 **rows = dm_alloc(
 			ctx,
 			numberof_rows * sizeof(struct fixed31_32 *));
 
@@ -1122,7 +1122,7 @@ static bool allocate_3d_storage(
 		tables[indexof_table] = rows;
 
 		while (indexof_row != numberof_rows) {
-			struct fixed31_32 *columns = dc_service_alloc(
+			struct fixed31_32 *columns = dm_alloc(
 				ctx,
 				numberof_columns * sizeof(struct fixed31_32));
 
@@ -1150,19 +1150,19 @@ failure:
 
 	while (indexof_table >= 0) {
 		while (indexof_row >= 0) {
-			dc_service_free(ctx, tables[indexof_table][indexof_row]);
+			dm_free(ctx, tables[indexof_table][indexof_row]);
 
 			--indexof_row;
 		}
 
 		indexof_row = numberof_rows - 1;
 
-		dc_service_free(ctx, tables[indexof_table]);
+		dm_free(ctx, tables[indexof_table]);
 
 		--indexof_table;
 	}
 
-	dc_service_free(ctx, tables);
+	dm_free(ctx, tables);
 
 	return false;
 }
@@ -1184,18 +1184,18 @@ static void destroy_3d_storage(
 		uint32_t indexof_row = 0;
 
 		while (indexof_row != numberof_rows) {
-			dc_service_free(
+			dm_free(
 				ctx, tables[indexof_table][indexof_row]);
 
 			++indexof_row;
 		};
 
-		dc_service_free(ctx, tables[indexof_table]);
+		dm_free(ctx, tables[indexof_table]);
 
 		++indexof_table;
 	};
 
-	dc_service_free(ctx, tables);
+	dm_free(ctx, tables);
 
 	*ptr = NULL;
 }
@@ -1627,13 +1627,13 @@ static bool generate_filter(
 
 	if (filter->coefficients_quantity < coefficients_quantity) {
 		if (filter->coefficients) {
-			dc_service_free(filter->ctx, filter->coefficients);
+			dm_free(filter->ctx, filter->coefficients);
 
 			filter->coefficients = NULL;
 			filter->coefficients_quantity = 0;
 		}
 
-		filter->coefficients = dc_service_alloc(
+		filter->coefficients = dm_alloc(
 			filter->ctx,
 			coefficients_quantity * sizeof(struct fixed31_32));
 
@@ -1655,13 +1655,13 @@ static bool generate_filter(
 
 	if (filter->coefficients_sum_quantity < coefficients_sum_quantity) {
 		if (filter->coefficients_sum) {
-			dc_service_free(filter->ctx, filter->coefficients_sum);
+			dm_free(filter->ctx, filter->coefficients_sum);
 
 			filter->coefficients_sum = NULL;
 			filter->coefficients_sum_quantity = 0;
 		}
 
-		filter->coefficients_sum = dc_service_alloc(
+		filter->coefficients_sum = dm_alloc(
 			filter->ctx,
 			coefficients_sum_quantity * sizeof(struct fixed31_32));
 
@@ -1831,16 +1831,16 @@ static void destruct_scaler_filter(
 	struct scaler_filter *filter)
 {
 	if (filter->coefficients_sum)
-		dc_service_free(filter->ctx, filter->coefficients_sum);
+		dm_free(filter->ctx, filter->coefficients_sum);
 
 	if (filter->coefficients)
-		dc_service_free(filter->ctx, filter->coefficients);
+		dm_free(filter->ctx, filter->coefficients);
 
 	if (filter->integer_filter)
-		dc_service_free(filter->ctx, filter->integer_filter);
+		dm_free(filter->ctx, filter->integer_filter);
 
 	if (filter->filter)
-		dc_service_free(filter->ctx, filter->filter);
+		dm_free(filter->ctx, filter->filter);
 
 	destroy_upscaling_table(filter);
 
@@ -1850,7 +1850,7 @@ static void destruct_scaler_filter(
 struct scaler_filter *dal_scaler_filter_create(struct dc_context *ctx)
 {
 	struct scaler_filter *filter =
-		dc_service_alloc(ctx, sizeof(struct scaler_filter));
+		dm_alloc(ctx, sizeof(struct scaler_filter));
 
 	if (!filter) {
 		BREAK_TO_DEBUGGER();
@@ -1862,7 +1862,7 @@ struct scaler_filter *dal_scaler_filter_create(struct dc_context *ctx)
 
 	BREAK_TO_DEBUGGER();
 
-	dc_service_free(ctx, filter);
+	dm_free(ctx, filter);
 
 	return NULL;
 }
@@ -1902,13 +1902,13 @@ bool dal_scaler_filter_generate(
 
 	if (filter_size_required > filter->filter_size_allocated) {
 		if (filter->filter) {
-			dc_service_free(filter->ctx, filter->filter);
+			dm_free(filter->ctx, filter->filter);
 
 			filter->filter = 0;
 			filter->filter_size_allocated = 0;
 		}
 
-		filter->filter = dc_service_alloc(
+		filter->filter = dm_alloc(
 			filter->ctx,
 			filter_size_required * sizeof(struct fixed31_32));
 
@@ -1918,12 +1918,12 @@ bool dal_scaler_filter_generate(
 		}
 
 		if (filter->integer_filter) {
-			dc_service_free(filter->ctx, filter->integer_filter);
+			dm_free(filter->ctx, filter->integer_filter);
 
 			filter->integer_filter = 0;
 		}
 
-		filter->integer_filter = dc_service_alloc(
+		filter->integer_filter = dm_alloc(
 			filter->ctx,
 			filter_size_required * sizeof(uint32_t));
 
@@ -1986,7 +1986,7 @@ void dal_scaler_filter_destroy(
 
 	destruct_scaler_filter(*filter);
 
-	dc_service_free((*filter)->ctx, *filter);
+	dm_free((*filter)->ctx, *filter);
 
 	*filter = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 770a66c..e6c7cac 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dc.h"
 
@@ -82,7 +82,7 @@ static bool create_links(struct dc *dc, const struct dc_init_data *init_params)
 	connectors_num = dcb->funcs->get_connectors_number(dcb);
 
 	if (connectors_num > ENUM_ID_COUNT) {
-		dal_error(
+		dm_error(
 			"DC: Number of connectors %d exceeds maximum of %d!\n",
 			connectors_num,
 			ENUM_ID_COUNT);
@@ -90,11 +90,11 @@ static bool create_links(struct dc *dc, const struct dc_init_data *init_params)
 	}
 
 	if (connectors_num == 0 && init_params->num_virtual_links == 0) {
-		dal_error("DC: Number of connectors can not be zero!\n");
+		dm_error("DC: Number of connectors can not be zero!\n");
 		return false;
 	}
 
-	dal_output_to_console(
+	dm_output_to_console(
 		"DC: %s: connectors_num: physical:%d, virtual:%d\n",
 		__func__,
 		connectors_num,
@@ -116,12 +116,12 @@ static bool create_links(struct dc *dc, const struct dc_init_data *init_params)
 			link->dc = dc;
 			++dc->link_count;
 		} else {
-			dal_error("DC: failed to create link!\n");
+			dm_error("DC: failed to create link!\n");
 		}
 	}
 
 	for (i = 0; i < init_params->num_virtual_links; i++) {
-		struct core_link *link = dc_service_alloc(
+		struct core_link *link = dm_alloc(
 			dc->ctx,
 			sizeof(*link));
 		struct encoder_init_data enc_init = {0};
@@ -138,7 +138,7 @@ static bool create_links(struct dc *dc, const struct dc_init_data *init_params)
 		link->link_id.type = OBJECT_TYPE_CONNECTOR;
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
-		link->link_enc = dc_service_alloc(
+		link->link_enc = dm_alloc(
 			dc->ctx,
 			sizeof(*link->link_enc));
 
@@ -215,7 +215,7 @@ static void init_hw(struct dc *dc)
 		struct audio *audio = dc->res_pool.audios[i];
 
 		if (dal_audio_power_up(audio) != AUDIO_RESULT_OK)
-			dal_error("Failed audio power up!\n");
+			dm_error("Failed audio power up!\n");
 	}
 
 }
@@ -227,7 +227,7 @@ static struct adapter_service *create_as(
 	struct adapter_service *as = NULL;
 	struct as_init_data init_data;
 
-	dc_service_memset(&init_data, 0, sizeof(init_data));
+	dm_memset(&init_data, 0, sizeof(init_data));
 
 	init_data.ctx = dc_init_data->ctx;
 
@@ -263,7 +263,7 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 	struct dc_pp_clock_levels clks = {0};
 
 	/*do system clock*/
-	dc_service_pp_get_clock_levels_by_type(
+	dm_pp_get_clock_levels_by_type(
 			dc->ctx,
 			DC_PP_CLOCK_TYPE_ENGINE_CLK,
 			&clks);
@@ -276,7 +276,7 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 			clks.clocks_in_khz[0], 1000);
 
 	/*do display clock*/
-	dc_service_pp_get_clock_levels_by_type(
+	dm_pp_get_clock_levels_by_type(
 			dc->ctx,
 			DC_PP_CLOCK_TYPE_DISPLAY_CLK,
 			&clks);
@@ -289,7 +289,7 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 			clks.clocks_in_khz[0], 1000);
 
 	/*do memory clock*/
-	dc_service_pp_get_clock_levels_by_type(
+	dm_pp_get_clock_levels_by_type(
 			dc->ctx,
 			DC_PP_CLOCK_TYPE_MEMORY_CLK,
 			&clks);
@@ -319,9 +319,9 @@ static bool construct(struct dc *dc, const struct dal_init_data *init_params)
 	ctx.cgs_device = init_params->cgs_device;
 	ctx.dc = dc;
 
-	dc_init_data.ctx = dc_service_alloc(&ctx, sizeof(*dc_init_data.ctx));
+	dc_init_data.ctx = dm_alloc(&ctx, sizeof(*dc_init_data.ctx));
 	if (!dc_init_data.ctx) {
-		dal_error("%s: failed to create ctx\n", __func__);
+		dm_error("%s: failed to create ctx\n", __func__);
 		goto ctx_fail;
 	}
 	dc_init_data.ctx->driver_context = init_params->driver;
@@ -334,7 +334,7 @@ static bool construct(struct dc *dc, const struct dal_init_data *init_params)
 
 	if (!logger) {
 		/* can *not* call logger. call base driver 'print error' */
-		dal_error("%s: failed to create Logger!\n", __func__);
+		dm_error("%s: failed to create Logger!\n", __func__);
 		goto logger_fail;
 	}
 	dc_init_data.ctx->logger = logger;
@@ -343,14 +343,14 @@ static bool construct(struct dc *dc, const struct dal_init_data *init_params)
 	dc_init_data.adapter_srv = create_as(&dc_init_data, init_params);
 
 	if (!dc_init_data.adapter_srv) {
-		dal_error("%s: create_as() failed!\n", __func__);
+		dm_error("%s: create_as() failed!\n", __func__);
 		goto as_fail;
 	}
 
 	/* Initialize HW controlled by Adapter Service */
 	if (false == dal_adapter_service_initialize_hw_data(
 			dc_init_data.adapter_srv)) {
-		dal_error("%s: dal_adapter_service_initialize_hw_data()"\
+		dm_error("%s: dal_adapter_service_initialize_hw_data()"\
 				"  failed!\n", __func__);
 		/* Note that AS exist, so have to destroy it.*/
 		goto as_fail;
@@ -385,7 +385,7 @@ as_fail:
 	dal_logger_destroy(&dc_init_data.ctx->logger);
 logger_fail:
 hwss_fail:
-	dc_service_free(&ctx, dc_init_data.ctx);
+	dm_free(&ctx, dc_init_data.ctx);
 ctx_fail:
 	return false;
 }
@@ -395,7 +395,7 @@ static void destruct(struct dc *dc)
 	destroy_links(dc);
 	dc->res_pool.funcs->destruct(&dc->res_pool);
 	dal_logger_destroy(&dc->ctx->logger);
-	dc_service_free(dc->ctx, dc->ctx);
+	dm_free(dc->ctx, dc->ctx);
 }
 
 /*******************************************************************************
@@ -408,7 +408,7 @@ struct dc *dc_create(const struct dal_init_data *init_params)
 		.driver_context = init_params->driver,
 		.cgs_device = init_params->cgs_device
 	};
-	struct dc *dc = dc_service_alloc(&ctx, sizeof(*dc));
+	struct dc *dc = dm_alloc(&ctx, sizeof(*dc));
 
 	if (NULL == dc)
 		goto alloc_fail;
@@ -423,7 +423,7 @@ struct dc *dc_create(const struct dal_init_data *init_params)
 	return dc;
 
 construct_fail:
-	dc_service_free(&ctx, dc);
+	dm_free(&ctx, dc);
 
 alloc_fail:
 	return NULL;
@@ -433,7 +433,7 @@ void dc_destroy(struct dc **dc)
 {
 	struct dc_context ctx = *(*dc)->ctx;
 	destruct(*dc);
-	dc_service_free(&ctx, *dc);
+	dm_free(&ctx, *dc);
 	*dc = NULL;
 }
 
@@ -445,14 +445,14 @@ bool dc_validate_resources(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
-	context = dc_service_alloc(dc->ctx, sizeof(struct validate_context));
+	context = dm_alloc(dc->ctx, sizeof(struct validate_context));
 	if(context == NULL)
 		goto context_alloc_fail;
 
 	result = dc->res_pool.funcs->validate_with_context(
 						dc, set, set_count, context);
 
-	dc_service_free(dc->ctx, context);
+	dm_free(dc->ctx, context);
 context_alloc_fail:
 
 	return (result == DC_OK);
@@ -556,7 +556,7 @@ bool dc_commit_targets(
 
 	}
 
-	context = dc_service_alloc(dc->ctx, sizeof(struct validate_context));
+	context = dm_alloc(dc->ctx, sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
 
@@ -611,7 +611,7 @@ bool dc_commit_targets(
 
 	/* TODO: disable unused plls*/
 fail:
-	dc_service_free(dc->ctx, context);
+	dm_free(dc->ctx, context);
 
 context_alloc_fail:
 	return (result == DC_OK);
@@ -731,7 +731,7 @@ const struct dc_target *dc_get_target_on_irq_source(
 		crtc_idx = src - DC_IRQ_SOURCE_PFLIP1;
 		break;
 	default:
-		dal_error("%s: invalid irq source: %d\n!",__func__, src);
+		dm_error("%s: invalid irq source: %d\n!" ,__func__, src);
 		return NULL;
 	}
 
@@ -741,7 +741,7 @@ const struct dc_target *dc_get_target_on_irq_source(
 		struct dc_target *dc_target;
 
 		if (NULL == target) {
-			dal_error("%s: 'dc_target' is NULL for irq source: %d\n!",
+			dm_error("%s: 'dc_target' is NULL for irq source: %d\n!",
 					__func__, src);
 			continue;
 		}
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/core/dc_hw_sequencer.c
index df7e89f..db4f131 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_hw_sequencer.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "core_types.h"
 
 #if defined(CONFIG_DRM_AMD_DAL_DCE10_0)
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 71653fa..b180cf6 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -23,8 +23,8 @@
  *
  */
 
-#include "dc_services.h"
-#include "dc_helpers.h"
+#include "dm_services.h"
+#include "dm_helpers.h"
 #include "dc.h"
 #include "core_dc.h"
 #include "adapter_service_interface.h"
@@ -449,7 +449,7 @@ static enum dc_edid_status read_edid(
 
 		dal_ddc_service_get_edid_buf(link->ddc,
 				sink->public.dc_edid.raw_edid);
-		edid_status = dc_helpers_parse_edid_caps(
+		edid_status = dm_helpers_parse_edid_caps(
 				sink->ctx,
 				&sink->public.dc_edid,
 				&sink->public.edid_caps);
@@ -524,7 +524,7 @@ static void detect_dp(
 			 * TODO: s3 resume check
 			 */
 
-			if (dc_helpers_dp_mst_start_top_mgr(
+			if (dm_helpers_dp_mst_start_top_mgr(
 				link->ctx,
 				&link->public, boot)) {
 				link->public.type = dc_connection_mst_branch;
@@ -718,7 +718,7 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 		if (link->public.type == dc_connection_mst_branch) {
 			LINK_INFO("link=%d, mst branch is now Disconnected\n",
 				link->public.link_index);
-			dc_helpers_dp_mst_stop_top_mgr(link->ctx, &link->public);
+			dm_helpers_dp_mst_stop_top_mgr(link->ctx, &link->public);
 		}
 
 		link->public.type = dc_connection_none;
@@ -905,7 +905,7 @@ static bool construct(
 			init_params->connector_index);
 
 	if (link->link_id.type != OBJECT_TYPE_CONNECTOR) {
-		dal_error("%s: Invalid Connector ObjectID from Adapter Service for connector index:%d!\n",
+		dm_error("%s: Invalid Connector ObjectID from Adapter Service for connector index:%d!\n",
 				__func__, init_params->connector_index);
 		goto create_fail;
 	}
@@ -1057,7 +1057,7 @@ create_fail:
 struct core_link *link_create(const struct link_init_data *init_params)
 {
 	struct core_link *link =
-			dc_service_alloc(init_params->ctx, sizeof(*link));
+			dm_alloc(init_params->ctx, sizeof(*link));
 
 	if (NULL == link)
 		goto alloc_fail;
@@ -1068,7 +1068,7 @@ struct core_link *link_create(const struct link_init_data *init_params)
 	return link;
 
 construct_fail:
-	dc_service_free(init_params->ctx, link);
+	dm_free(init_params->ctx, link);
 
 alloc_fail:
 	return NULL;
@@ -1077,7 +1077,7 @@ alloc_fail:
 void link_destroy(struct core_link **link)
 {
 	destruct(*link);
-	dc_service_free((*link)->ctx, *link);
+	dm_free((*link)->ctx, *link);
 	*link = NULL;
 }
 
@@ -1088,7 +1088,7 @@ static void dpcd_configure_panel_mode(
 	union dpcd_edp_config edp_config_set;
 	bool panel_mode_edp = false;
 
-	dc_service_memset(&edp_config_set, '\0', sizeof(union dpcd_edp_config));
+	dm_memset(&edp_config_set, '\0', sizeof(union dpcd_edp_config));
 
 	if (DP_PANEL_MODE_DEFAULT != panel_mode) {
 
@@ -1211,7 +1211,7 @@ static void enable_link_hdmi(struct core_stream *stream)
 			normalized_pix_clk,
 			stream->public.timing.flags.LTE_340MCSC_SCRAMBLE);
 
-	dc_service_memset(&stream->sink->link->cur_link_settings, 0,
+	dm_memset(&stream->sink->link->cur_link_settings, 0,
 			sizeof(struct link_settings));
 
 	link->link_enc->funcs->enable_tmds_output(
@@ -1237,7 +1237,7 @@ static enum dc_status enable_link(struct core_stream *stream)
 		break;
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
 		status = enable_link_dp_mst(stream);
-		dc_service_sleep_in_milliseconds(stream->ctx, 200);
+		dm_sleep_in_milliseconds(stream->ctx, 200);
 		break;
 	case SIGNAL_TYPE_DVI_SINGLE_LINK:
 	case SIGNAL_TYPE_DVI_DUAL_LINK:
@@ -1460,7 +1460,7 @@ static enum dc_status allocate_mst_payload(struct core_stream *stream)
 	 */
 
 	/* get calculate VC payload for stream: stream_alloc */
-	dc_helpers_dp_mst_write_payload_allocation_table(
+	dm_helpers_dp_mst_write_payload_allocation_table(
 		stream->ctx,
 		&stream->public,
 		&proposed_table,
@@ -1509,11 +1509,11 @@ static enum dc_status allocate_mst_payload(struct core_stream *stream)
 		&link->mst_stream_alloc_table);
 
 	/* send down message */
-	dc_helpers_dp_mst_poll_for_allocation_change_trigger(
+	dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 			stream->ctx,
 			&stream->public);
 
-	dc_helpers_dp_mst_send_payload_allocation(
+	dm_helpers_dp_mst_send_payload_allocation(
 			stream->ctx,
 			&stream->public,
 			true);
@@ -1557,12 +1557,12 @@ static enum dc_status deallocate_mst_payload(struct core_stream *stream)
 
 	/* TODO: which component is responsible for remove payload table? */
 	if (mst_mode)
-		dc_helpers_dp_mst_write_payload_allocation_table(
+		dm_helpers_dp_mst_write_payload_allocation_table(
 				stream->ctx,
 				&stream->public,
 				&proposed_table,
 				false);
-	dc_helpers_dp_mst_write_payload_allocation_table(
+	dm_helpers_dp_mst_write_payload_allocation_table(
 		stream->ctx,
 		&stream->public,
 		&proposed_table,
@@ -1598,11 +1598,11 @@ static enum dc_status deallocate_mst_payload(struct core_stream *stream)
 		&link->mst_stream_alloc_table);
 
 	if (mst_mode) {
-		dc_helpers_dp_mst_poll_for_allocation_change_trigger(
+		dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 			stream->ctx,
 			&stream->public);
 
-		dc_helpers_dp_mst_send_payload_allocation(
+		dm_helpers_dp_mst_send_payload_allocation(
 			stream->ctx,
 			&stream->public,
 			false);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
index 60fc743..62b8c26 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/adapter_service_interface.h"
 #include "include/ddc_service_types.h"
@@ -188,7 +188,7 @@ struct i2c_payloads *dal_ddc_i2c_payloads_create(struct dc_context *ctx, uint32_
 {
 	struct i2c_payloads *payloads;
 
-	payloads = dc_service_alloc(ctx, sizeof(struct i2c_payloads));
+	payloads = dm_alloc(ctx, sizeof(struct i2c_payloads));
 
 	if (!payloads)
 		return NULL;
@@ -197,7 +197,7 @@ struct i2c_payloads *dal_ddc_i2c_payloads_create(struct dc_context *ctx, uint32_
 		&payloads->payloads, ctx, count, sizeof(struct i2c_payload)))
 		return payloads;
 
-	dc_service_free(ctx, payloads);
+	dm_free(ctx, payloads);
 	return NULL;
 
 }
@@ -217,7 +217,7 @@ void dal_ddc_i2c_payloads_destroy(struct i2c_payloads **p)
 	if (!p || !*p)
 		return;
 	dal_vector_destruct(&(*p)->payloads);
-	dc_service_free((*p)->payloads.ctx, *p);
+	dm_free((*p)->payloads.ctx, *p);
 	*p = NULL;
 
 }
@@ -226,7 +226,7 @@ struct aux_payloads *dal_ddc_aux_payloads_create(struct dc_context *ctx, uint32_
 {
 	struct aux_payloads *payloads;
 
-	payloads = dc_service_alloc(ctx, sizeof(struct aux_payloads));
+	payloads = dm_alloc(ctx, sizeof(struct aux_payloads));
 
 	if (!payloads)
 		return NULL;
@@ -235,7 +235,7 @@ struct aux_payloads *dal_ddc_aux_payloads_create(struct dc_context *ctx, uint32_
 		&payloads->payloads, ctx, count, sizeof(struct aux_payloads)))
 		return payloads;
 
-	dc_service_free(ctx, payloads);
+	dm_free(ctx, payloads);
 	return NULL;
 }
 
@@ -256,7 +256,7 @@ void dal_ddc_aux_payloads_destroy(struct aux_payloads **p)
 		return;
 
 	dal_vector_destruct(&(*p)->payloads);
-	dc_service_free((*p)->payloads.ctx, *p);
+	dm_free((*p)->payloads.ctx, *p);
 	*p = NULL;
 }
 
@@ -341,7 +341,7 @@ struct ddc_service *dal_ddc_service_create(
 {
 	struct ddc_service *ddc_service;
 
-	ddc_service = dc_service_alloc(init_data->ctx, sizeof(struct ddc_service));
+	ddc_service = dm_alloc(init_data->ctx, sizeof(struct ddc_service));
 
 	if (!ddc_service)
 		return NULL;
@@ -349,7 +349,7 @@ struct ddc_service *dal_ddc_service_create(
 	if (construct(ddc_service, init_data))
 		return ddc_service;
 
-	dc_service_free(init_data->ctx, ddc_service);
+	dm_free(init_data->ctx, ddc_service);
 	return NULL;
 }
 
@@ -366,7 +366,7 @@ void dal_ddc_service_destroy(struct ddc_service **ddc)
 		return;
 	}
 	destruct(*ddc);
-	dc_service_free((*ddc)->ctx, *ddc);
+	dm_free((*ddc)->ctx, *ddc);
 	*ddc = NULL;
 }
 
@@ -409,7 +409,7 @@ static uint32_t defer_delay_converter_wa(
 
 	if (dal_ddc_service_get_dp_receiver_id_info(ddc, &dp_rec_info) &&
 		(dp_rec_info.branch_id == DP_BRANCH_DEVICE_ID_4) &&
-		!dal_strncmp(dp_rec_info.branch_name,
+		!dm_strncmp(dp_rec_info.branch_name,
 			DP_DVI_CONVERTER_ID_4,
 			sizeof(dp_rec_info.branch_name)))
 		return defer_delay > I2C_OVER_AUX_DEFER_WA_DELAY ?
@@ -781,7 +781,7 @@ uint32_t dal_ddc_service_get_edid_buf_len(struct ddc_service *ddc)
 
 void dal_ddc_service_get_edid_buf(struct ddc_service *ddc, uint8_t *edid_buf)
 {
-	dc_service_memmove(edid_buf,
+	dm_memmove(edid_buf,
 			ddc->edid_buf, ddc->edid_buf_len);
 }
 
@@ -1088,7 +1088,7 @@ struct ddc *dal_ddc_service_get_ddc_pin(struct ddc_service *ddc_service)
 
 void dal_ddc_service_reset_dp_receiver_id_info(struct ddc_service *ddc_service)
 {
-	dc_service_memset(&ddc_service->dp_receiver_id_info,
+	dm_memset(&ddc_service->dp_receiver_id_info,
 		0, sizeof(struct dp_receiver_id_info));
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
index 96ba910..742ab75 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
@@ -1,8 +1,9 @@
 /* Copyright 2015 Advanced Micro Devices, Inc. */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dc.h"
 #include "dc_link_dp.h"
-#include "dc_helpers.h"
+#include "dm_helpers.h"
+
 #include "inc/core_types.h"
 #include "link_hwss.h"
 #include "dc_link_ddc.h"
@@ -69,7 +70,7 @@ static void wait_for_training_aux_rd_interval(
 			default_wait_in_micro_secs;
 	}
 
-	dc_service_delay_in_microseconds(link->ctx, default_wait_in_micro_secs);
+	dm_delay_in_microseconds(link->ctx, default_wait_in_micro_secs);
 
 	dal_logger_write(link->ctx->logger,
 		LOG_MAJOR_HW_TRACE,
@@ -231,7 +232,7 @@ static void dpcd_set_lt_pattern_and_lane_settings(
 	size_in_bytes = lt_settings->link_settings.lane_count * sizeof(dpcd_lane[0]);
 
 	 // 0x00103 - 0x00102
-	dc_service_memmove(
+	dm_memmove(
 		&dpcd_lt_buffer[DPCD_ADDRESS_LANE0_SET - dpcd_base_lt_offset],
 		dpcd_lane,
 		size_in_bytes);
@@ -458,7 +459,7 @@ static void get_lane_status_and_drive_settings(
 	struct link_training_settings request_settings = {{0}};
 	uint32_t lane;
 
-	dc_service_memset(req_settings, '\0', sizeof(struct link_training_settings));
+	dm_memset(req_settings, '\0', sizeof(struct link_training_settings));
 
 	core_link_read_dpcd(
 		link,
@@ -694,7 +695,7 @@ static bool perform_post_lt_adj_req_sequence(
 				break;
 			}
 
-			dc_service_sleep_in_milliseconds(link->ctx, 1);
+			dm_sleep_in_milliseconds(link->ctx, 1);
 		}
 
 		if (!req_drv_setting_changed) {
@@ -818,8 +819,8 @@ static bool perform_clock_recovery_sequence(
 	while ((retries_cr < LINK_TRAINING_MAX_RETRY_COUNT) &&
 	(retry_count < LINK_TRAINING_MAX_CR_RETRY)) {
 
-		dc_service_memset(&dpcd_lane_status, '\0', sizeof(dpcd_lane_status));
-		dc_service_memset(&dpcd_lane_status_updated, '\0',
+		dm_memset(&dpcd_lane_status, '\0', sizeof(dpcd_lane_status));
+		dm_memset(&dpcd_lane_status_updated, '\0',
 		sizeof(dpcd_lane_status_updated));
 
 		/* 1. call HWSS to set lane settings*/
@@ -908,7 +909,7 @@ static bool perform_clock_recovery_sequence(
 	struct link_training_settings lt_settings;
 
 	status = false;
-	dc_service_memset(&lt_settings, '\0', sizeof(lt_settings));
+	dm_memset(&lt_settings, '\0', sizeof(lt_settings));
 
 	lt_settings.link_settings.link_rate = link_setting->link_rate;
 	lt_settings.link_settings.lane_count = link_setting->lane_count;
@@ -1095,7 +1096,7 @@ bool dp_hbr_verify_link_cap(
 				if (success)
 					break;
 
-				dc_service_sleep_in_milliseconds(
+				dm_sleep_in_milliseconds(
 					link->ctx,
 					delay_between_retries);
 
@@ -1643,12 +1644,12 @@ static void retrieve_link_cap(struct core_link *link)
 	union max_down_spread max_down_spread;
 	union dp_downstream_port_present ds_port = { 0 };
 
-	dc_service_memset(dpcd_data, '\0', sizeof(dpcd_data));
-	dc_service_memset(&down_strm_port_count,
+	dm_memset(dpcd_data, '\0', sizeof(dpcd_data));
+	dm_memset(&down_strm_port_count,
 		'\0', sizeof(union down_stream_port_count));
-	dc_service_memset(&edp_config_cap, '\0',
+	dm_memset(&edp_config_cap, '\0',
 		sizeof(union edp_configuration_cap));
-	dc_service_memset(&max_down_spread, '\0',
+	dm_memset(&max_down_spread, '\0',
 		sizeof(union max_down_spread));
 
 	core_link_read_dpcd(link, DPCD_ADDRESS_DPCD_REV,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
index 656ec71..39aa734 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
@@ -1,6 +1,6 @@
 /* Copyright 2015 Advanced Micro Devices, Inc. */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dc.h"
 #include "inc/core_dc.h"
 #include "include/ddc_service_types.h"
@@ -8,7 +8,7 @@
 #include "link_hwss.h"
 #include "hw_sequencer.h"
 #include "dc_link_ddc.h"
-#include "dc_helpers.h"
+#include "dm_helpers.h"
 #include "dce110/dce110_link_encoder.h"
 #include "dce110/dce110_stream_encoder.h"
 
@@ -19,7 +19,7 @@ enum dc_status core_link_read_dpcd(
 	uint8_t *data,
 	uint32_t size)
 {
-	if (!dc_helper_dp_read_dpcd(link->ctx,
+	if (!dm_helper_dp_read_dpcd(link->ctx,
 			&link->public,
 			address, data, size))
 			return DC_ERROR_UNEXPECTED;
@@ -33,7 +33,7 @@ enum dc_status core_link_write_dpcd(
 	const uint8_t *data,
 	uint32_t size)
 {
-	if (!dc_helper_dp_write_dpcd(link->ctx,
+	if (!dm_helper_dp_write_dpcd(link->ctx,
 			&link->public,
 			address, data, size))
 				return DC_ERROR_UNEXPECTED;
@@ -89,7 +89,7 @@ void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
 	link->link_enc->funcs->disable_output(link->link_enc, signal);
 
 	/* Clear current link setting.*/
-	dc_service_memset(&link->cur_link_settings, 0,
+	dm_memset(&link->cur_link_settings, 0,
 			sizeof(link->cur_link_settings));
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 65523e3..d166811 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "resource.h"
 #include "include/irq_service_interface.h"
@@ -91,7 +91,7 @@ bool is_same_timing(
 	const struct dc_crtc_timing *timing1,
 	const struct dc_crtc_timing *timing2)
 {
-	return dal_memcmp(timing1, timing2, sizeof(struct dc_crtc_timing)) == 0;
+	return dm_memcmp(timing1, timing2, sizeof(struct dc_crtc_timing)) == 0;
 }
 
 static bool is_sharable_clk_src(
@@ -425,7 +425,7 @@ bool logical_attach_surfaces_to_target(
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 
 	if (surface_count > MAX_SURFACE_NUM) {
-		dal_error("Surface: can not attach %d surfaces! Maximum is: %d\n",
+		dm_error("Surface: can not attach %d surfaces! Maximum is: %d\n",
 			surface_count, MAX_SURFACE_NUM);
 		return false;
 	}
@@ -521,7 +521,7 @@ static void fill_display_configs(
 void pplib_apply_safe_state(
 	const struct dc *dc)
 {
-	dc_service_pp_apply_safe_state(dc->ctx);
+	dm_pp_apply_safe_state(dc->ctx);
 }
 
 void pplib_apply_display_requirements(
@@ -566,7 +566,7 @@ void pplib_apply_display_requirements(
 							/ timing->pix_clk_khz;
 	}
 
-	dc_service_pp_apply_display_requirements(dc->ctx, &pp_display_cfg);
+	dm_pp_apply_display_requirements(dc->ctx, &pp_display_cfg);
 }
 
 /* Maximum TMDS single link pixel clock 165MHz */
@@ -872,7 +872,7 @@ static enum ds_color_space build_default_color_space(
 static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 	struct encoder_info_frame *encoder_info_frame)
 {
-	dc_service_memset(
+	dm_memset(
 		encoder_info_frame, 0, sizeof(struct encoder_info_frame));
 
 	/* For gamut we recalc checksum */
@@ -881,7 +881,7 @@ static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 		uint8_t *ptr;
 		uint8_t i;
 
-		dc_service_memmove(
+		dm_memmove(
 						&encoder_info_frame->gamut,
 						&hw_info_frame->gamut_packet,
 						sizeof(struct hw_info_packet));
@@ -896,28 +896,28 @@ static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 	}
 
 	if (hw_info_frame->avi_info_packet.valid) {
-		dc_service_memmove(
+		dm_memmove(
 						&encoder_info_frame->avi,
 						&hw_info_frame->avi_info_packet,
 						sizeof(struct hw_info_packet));
 	}
 
 	if (hw_info_frame->vendor_info_packet.valid) {
-		dc_service_memmove(
+		dm_memmove(
 						&encoder_info_frame->vendor,
 						&hw_info_frame->vendor_info_packet,
 						sizeof(struct hw_info_packet));
 	}
 
 	if (hw_info_frame->spd_packet.valid) {
-		dc_service_memmove(
+		dm_memmove(
 						&encoder_info_frame->spd,
 						&hw_info_frame->spd_packet,
 						sizeof(struct hw_info_packet));
 	}
 
 	if (hw_info_frame->vsc_packet.valid) {
-		dc_service_memmove(
+		dm_memmove(
 						&encoder_info_frame->vsc,
 						&hw_info_frame->vsc_packet,
 						sizeof(struct hw_info_packet));
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c b/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c
index 608fb99..c5a770e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c
@@ -23,8 +23,8 @@
  *
  */
 
-#include "dc_services.h"
-#include "dc_helpers.h"
+#include "dm_services.h"
+#include "dm_helpers.h"
 #include "core_types.h"
 
 /*******************************************************************************
@@ -83,7 +83,7 @@ void dc_sink_release(const struct dc_sink *dc_sink)
 
 	if (sink->ref_count == 0) {
 		destruct(sink);
-		dc_service_free(core_sink->ctx, sink);
+		dm_free(core_sink->ctx, sink);
 	}
 }
 
@@ -91,7 +91,7 @@ struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params)
 {
 	struct core_link *core_link = DC_LINK_TO_LINK(init_params->link);
 
-	struct sink *sink = dc_service_alloc(core_link->ctx, sizeof(*sink));
+	struct sink *sink = dm_alloc(core_link->ctx, sizeof(*sink));
 
 	if (NULL == sink)
 		goto alloc_fail;
@@ -105,7 +105,7 @@ struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params)
 	return &sink->protected.public;
 
 construct_fail:
-	dc_service_free(core_link->ctx, sink);
+	dm_free(core_link->ctx, sink);
 
 alloc_fail:
 	return NULL;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
index ab8999b..d7012bc 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
@@ -22,7 +22,8 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+
+#include "dm_services.h"
 #include "dc.h"
 #include "core_types.h"
 #include "resource.h"
@@ -45,7 +46,7 @@ static void build_bit_depth_reduction_params(
 		const struct core_stream *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth)
 {
-	dc_service_memset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));
+	dm_memset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));
 
 	/*TODO: Need to un-hardcode, refer to function with same name
 	 * in dal2 hw_sequencer*/
@@ -107,7 +108,7 @@ static bool construct(struct core_stream *stream,
 	stream->public.audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;
 	stream->public.audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;
 	stream->public.audio_info.video_latency = dc_sink_data->edid_caps.video_latency;
-	dc_service_memmove(
+	dm_memmove(
 		stream->public.audio_info.display_name,
 		dc_sink_data->edid_caps.display_name,
 		AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);
@@ -144,7 +145,7 @@ void dc_stream_release(struct dc_stream *public)
 
 	if (stream->ref_count == 0) {
 		destruct(protected);
-		dc_service_free(ctx, stream);
+		dm_free(ctx, stream);
 	}
 }
 
@@ -156,7 +157,7 @@ struct dc_stream *dc_create_stream_for_sink(const struct dc_sink *dc_sink)
 	if (sink == NULL)
 		goto alloc_fail;
 
-	stream = dc_service_alloc(sink->ctx, sizeof(struct stream));
+	stream = dm_alloc(sink->ctx, sizeof(struct stream));
 
 	if (NULL == stream)
 		goto alloc_fail;
@@ -169,7 +170,7 @@ struct dc_stream *dc_create_stream_for_sink(const struct dc_sink *dc_sink)
 	return &stream->protected.public;
 
 construct_fail:
-	dc_service_free(sink->ctx, stream);
+	dm_free(sink->ctx, stream);
 
 alloc_fail:
 	return NULL;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
index ce60e9d..1a9ee8f 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
@@ -24,7 +24,7 @@
  */
 
 /* DC interface (public) */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dc.h"
 
 /* DC core (private) */
@@ -85,7 +85,7 @@ void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 
 struct dc_surface *dc_create_surface(const struct dc *dc)
 {
-	struct surface *surface = dc_service_alloc(dc->ctx, sizeof(*surface));
+	struct surface *surface = dm_alloc(dc->ctx, sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
@@ -98,7 +98,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 	return &surface->protected.public;
 
 construct_fail:
-	dc_service_free(dc->ctx, surface);
+	dm_free(dc->ctx, surface);
 
 alloc_fail:
 	return NULL;
@@ -118,6 +118,6 @@ void dc_surface_release(const struct dc_surface *dc_surface)
 
 	if (surface->ref_count == 0) {
 		destruct(surface);
-		dc_service_free(surface->protected.ctx, surface);
+		dm_free(surface->protected.ctx, surface);
 	}
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
index f114fc4..e93e73d 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
@@ -22,7 +22,8 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+
+#include "dm_services.h"
 #include "core_types.h"
 #include "hw_sequencer.h"
 #include "resource.h"
@@ -93,7 +94,7 @@ void dc_target_release(struct dc_target *dc_target)
 	target->ref_count--;
 	if (target->ref_count == 0) {
 		destruct(protected);
-		dc_service_free(protected->ctx, target);
+		dm_free(protected->ctx, target);
 	}
 }
 
@@ -116,7 +117,7 @@ struct dc_target *dc_create_target_for_streams(
 
 	stream = DC_STREAM_TO_CORE(dc_streams[0]);
 
-	target = dc_service_alloc(stream->ctx, sizeof(struct target));
+	target = dm_alloc(stream->ctx, sizeof(struct target));
 
 	if (NULL == target)
 		goto target_alloc_fail;
@@ -177,7 +178,7 @@ static bool program_gamma(
 	struct gamma_parameters *gamma_param;
 	bool result= false;
 
-	gamma_param = dc_service_alloc(ctx, sizeof(struct gamma_parameters));
+	gamma_param = dm_alloc(ctx, sizeof(struct gamma_parameters));
 
 	if (!gamma_param)
 		goto gamma_param_fail;
@@ -188,7 +189,7 @@ static bool program_gamma(
 			&surface->gamma_correction,
 			gamma_param);
 
-	dc_service_free(ctx, gamma_param);
+	dm_free(ctx, gamma_param);
 
 gamma_param_fail:
 	return result;
@@ -357,7 +358,7 @@ void dc_target_enable_memory_requests(struct dc_target *target)
 			DC_STREAM_TO_CORE(core_target->public.streams[i])->tg;
 
 		if (!tg->funcs->set_blank(tg, false)) {
-			dal_error("DC: failed to unblank crtc!\n");
+			dm_error("DC: failed to unblank crtc!\n");
 			BREAK_TO_DEBUGGER();
 		}
 	}
@@ -372,13 +373,13 @@ void dc_target_disable_memory_requests(struct dc_target *target)
 		DC_STREAM_TO_CORE(core_target->public.streams[i])->tg;
 
 		if (NULL == tg) {
-			dal_error("DC: timing generator is NULL!\n");
+			dm_error("DC: timing generator is NULL!\n");
 			BREAK_TO_DEBUGGER();
 			continue;
 		}
 
 		if (false == tg->funcs->set_blank(tg, true)) {
-			dal_error("DC: failed to blank crtc!\n");
+			dm_error("DC: failed to blank crtc!\n");
 			BREAK_TO_DEBUGGER();
 		}
 	}
@@ -395,7 +396,7 @@ bool dc_target_set_cursor_attributes(
 	struct input_pixel_processor *ipp;
 
 	if (NULL == dc_target) {
-		dal_error("DC: dc_target is NULL!\n");
+		dm_error("DC: dc_target is NULL!\n");
 			return false;
 
 	}
@@ -404,7 +405,7 @@ bool dc_target_set_cursor_attributes(
 	ipp = DC_STREAM_TO_CORE(core_target->public.streams[0])->ipp;
 
 	if (NULL == ipp) {
-		dal_error("DC: input pixel processor is NULL!\n");
+		dm_error("DC: input pixel processor is NULL!\n");
 		return false;
 	}
 
@@ -422,12 +423,12 @@ bool dc_target_set_cursor_position(
 	struct input_pixel_processor *ipp;
 
 	if (NULL == dc_target) {
-		dal_error("DC: dc_target is NULL!\n");
+		dm_error("DC: dc_target is NULL!\n");
 		return false;
 	}
 
 	if (NULL == position) {
-		dal_error("DC: cursor position is NULL!\n");
+		dm_error("DC: cursor position is NULL!\n");
 		return false;
 	}
 
@@ -435,7 +436,7 @@ bool dc_target_set_cursor_position(
 	ipp = DC_STREAM_TO_CORE(core_target->public.streams[0])->ipp;
 
 	if (NULL == ipp) {
-		dal_error("DC: input pixel processor is NULL!\n");
+		dm_error("DC: input pixel processor is NULL!\n");
 		return false;
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_helpers.h b/drivers/gpu/drm/amd/dal/dc/dc_helpers.h
deleted file mode 100644
index 6bb1160..0000000
--- a/drivers/gpu/drm/amd/dal/dc/dc_helpers.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-/**
- * This file defines helper functions provided by the Display Manager to
- * Display Core.
- */
-#ifndef __DC_HELPERS__
-#define __DC_HELPERS__
-
-#include "dc_types.h"
-#include "dc.h"
-
-struct dp_mst_stream_allocation_table;
-
-enum dc_edid_status dc_helpers_parse_edid_caps(
-	struct dc_context *ctx,
-	const struct dc_edid *edid,
-	struct dc_edid_caps *edid_caps);
-
-/*
- * Writes payload allocation table in immediate downstream device.
- */
-bool dc_helpers_dp_mst_write_payload_allocation_table(
-		struct dc_context *ctx,
-		const struct dc_stream *stream,
-		struct dp_mst_stream_allocation_table *proposed_table,
-		bool enable);
-
-/*
- * Polls for ACT (allocation change trigger) handled and
- */
-bool dc_helpers_dp_mst_poll_for_allocation_change_trigger(
-		struct dc_context *ctx,
-		const struct dc_stream *stream);
-/*
- * Sends ALLOCATE_PAYLOAD message.
- */
-bool dc_helpers_dp_mst_send_payload_allocation(
-		struct dc_context *ctx,
-		const struct dc_stream *stream,
-		bool enable);
-
-void dc_helpers_dp_mst_handle_mst_hpd_rx_irq(
-		void *param);
-
-bool dc_helpers_dp_mst_start_top_mgr(
-		struct dc_context *ctx,
-		const struct dc_link *link,
-		bool boot);
-
-void dc_helpers_dp_mst_stop_top_mgr(
-		struct dc_context *ctx,
-		const struct dc_link *link);
-
-/**
- * OS specific aux read callback.
- */
-bool dc_helper_dp_read_dpcd(
-		struct dc_context *ctx,
-		const struct dc_link *link,
-		uint32_t address,
-		uint8_t *data,
-		uint32_t size);
-
-/**
- * OS specific aux write callback.
- */
-bool dc_helper_dp_write_dpcd(
-		struct dc_context *ctx,
-		const struct dc_link *link,
-		uint32_t address,
-		const uint8_t *data,
-		uint32_t size);
-
-#endif /* __DC_HELPERS__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_services.h b/drivers/gpu/drm/amd/dal/dc/dc_services.h
deleted file mode 100644
index fa1c39d..0000000
--- a/drivers/gpu/drm/amd/dal/dc/dc_services.h
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * Copyright 2015 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-/**
- * This file defines external dependencies of Display Core.
- */
-
-#ifndef __DC_SERVICES_H__
-#define __DC_SERVICES_H__
-
-/* TODO: remove when DC is complete. */
-#include "dc_services_types.h"
-#include "logger_interface.h"
-#include "include/dal_types.h"
-#include "irq_types.h"
-#include "link_service_types.h"
-
-#undef DEPRECATED
-
-/* if the pointer is not NULL, the allocated memory is zeroed */
-void *dc_service_alloc(struct dc_context *ctx, uint32_t size);
-
-/* reallocate memory. The contents will remain unchanged.*/
-void *dc_service_realloc(struct dc_context *ctx, const void *ptr, uint32_t size);
-
-void dc_service_free(struct dc_context *ctx, void *p);
-
-void dc_service_memset(void *p, int32_t c, uint32_t count);
-
-void dc_service_memmove(void *dst, const void *src, uint32_t size);
-
-/* TODO: rename to dc_memcmp*/
-int32_t dal_memcmp(const void *p1, const void *p2, uint32_t count);
-
-int32_t dal_strncmp(const int8_t *p1, const int8_t *p2, uint32_t count);
-
-irq_handler_idx dc_service_register_interrupt(
-	struct dc_context *ctx,
-	struct dc_interrupt_params *int_params,
-	interrupt_handler ih,
-	void *handler_args);
-
-void dc_service_unregister_interrupt(
-	struct dc_context *ctx,
-	enum dc_irq_source irq_source,
-	irq_handler_idx handler_idx);
-
-/*
- *
- * GPU registers access
- *
- */
-static inline uint32_t dal_read_reg(
-	const struct dc_context *ctx,
-	uint32_t address)
-{
-	uint32_t value = cgs_read_register(ctx->cgs_device, address);
-
-#if defined(__DAL_REGISTER_LOGGER__)
-	if (true == dal_reg_logger_should_dump_register()) {
-		dal_reg_logger_rw_count_increment();
-		DRM_INFO("%s 0x%x 0x%x\n", __func__, address, value);
-	}
-#endif
-	return value;
-}
-
-static inline void dal_write_reg(
-	const struct dc_context *ctx,
-	uint32_t address,
-	uint32_t value)
-{
-#if defined(__DAL_REGISTER_LOGGER__)
-	if (true == dal_reg_logger_should_dump_register()) {
-		dal_reg_logger_rw_count_increment();
-		DRM_INFO("%s 0x%x 0x%x\n", __func__, address, value);
-	}
-#endif
-	cgs_write_register(ctx->cgs_device, address, value);
-}
-
-static inline uint32_t dal_read_index_reg(
-	const struct dc_context *ctx,
-	enum cgs_ind_reg addr_space,
-	uint32_t index)
-{
-	return cgs_read_ind_register(ctx->cgs_device, addr_space, index);
-}
-
-static inline void dal_write_index_reg(
-	const struct dc_context *ctx,
-	enum cgs_ind_reg addr_space,
-	uint32_t index,
-	uint32_t value)
-{
-	cgs_write_ind_register(ctx->cgs_device, addr_space, index, value);
-}
-
-static inline uint32_t get_reg_field_value_ex(
-	uint32_t reg_value,
-	uint32_t mask,
-	uint8_t shift)
-{
-	return (mask & reg_value) >> shift;
-}
-
-#define get_reg_field_value(reg_value, reg_name, reg_field)\
-	get_reg_field_value_ex(\
-		(reg_value),\
-		reg_name ## __ ## reg_field ## _MASK,\
-		reg_name ## __ ## reg_field ## __SHIFT)
-
-static inline uint32_t set_reg_field_value_ex(
-	uint32_t reg_value,
-	uint32_t value,
-	uint32_t mask,
-	uint8_t shift)
-{
-	return (reg_value & ~mask) | (mask & (value << shift));
-}
-
-#define set_reg_field_value(reg_value, value, reg_name, reg_field)\
-	(reg_value) = set_reg_field_value_ex(\
-		(reg_value),\
-		(value),\
-		reg_name ## __ ## reg_field ## _MASK,\
-		reg_name ## __ ## reg_field ## __SHIFT)
-
-/*
- * atombios services
- */
-
-bool dal_exec_bios_cmd_table(
-	struct dc_context *ctx,
-	uint32_t index,
-	void *params);
-
-#ifdef BUILD_DAL_TEST
-uint32_t dal_bios_cmd_table_para_revision(
-struct dc_context *ctx,
-	uint32_t index);
-
-bool dal_bios_cmd_table_revision(
-	struct dc_context *ctx,
-	uint32_t index,
-	uint8_t *frev,
-	uint8_t *crev);
-#endif
-
-#ifndef BUILD_DAL_TEST
-static inline uint32_t dal_bios_cmd_table_para_revision(
-	struct dc_context *ctx,
-	uint32_t index)
-{
-	uint8_t frev;
-	uint8_t crev;
-
-	if (cgs_atom_get_cmd_table_revs(
-			ctx->cgs_device,
-			index,
-			&frev,
-			&crev) != 0)
-		return 0;
-
-	return crev;
-}
-#else
-uint32_t dal_bios_cmd_table_para_revision(
-		struct dc_context *ctx,
-		uint32_t index);
-#endif
-
-/**************************************
- * Power Play (PP) interfaces
- **************************************/
-
-enum dal_to_power_clocks_state {
-	PP_CLOCKS_STATE_INVALID,
-	PP_CLOCKS_STATE_ULTRA_LOW,
-	PP_CLOCKS_STATE_LOW,
-	PP_CLOCKS_STATE_NOMINAL,
-	PP_CLOCKS_STATE_PERFORMANCE
-};
-
-/* clocks in khz */
-struct dal_to_power_info {
-	enum dal_to_power_clocks_state required_clock;
-	uint32_t min_sclk;
-	uint32_t min_mclk;
-	uint32_t min_deep_sleep_sclk;
-};
-
-/* clocks in khz */
-struct power_to_dal_info {
-	uint32_t min_sclk;
-	uint32_t max_sclk;
-	uint32_t min_mclk;
-	uint32_t max_mclk;
-};
-
-/* clocks in khz */
-struct dal_system_clock_range {
-	uint32_t min_sclk;
-	uint32_t max_sclk;
-
-	uint32_t min_mclk;
-	uint32_t max_mclk;
-
-	uint32_t min_dclk;
-	uint32_t max_dclk;
-
-	/* Wireless Display */
-	uint32_t min_eclk;
-	uint32_t max_eclk;
-};
-
-/* clocks in khz */
-struct dal_to_power_dclk {
-	uint32_t optimal; /* input: best optimizes for stutter efficiency */
-	uint32_t minimal; /* input: the lowest clk that DAL can support */
-	uint32_t established; /* output: the actually set one */
-};
-
-/* DAL calls this function to notify PP about clocks it needs for the Mode Set.
- * This is done *before* it changes DCE clock.
- *
- * If required clock is higher than current, then PP will increase the voltage.
- *
- * If required clock is lower than current, then PP will defer reduction of
- * voltage until the call to dc_service_pp_post_dce_clock_change().
- *
- * \input - Contains clocks needed for Mode Set.
- *
- * \output - Contains clocks adjusted by PP which DAL should use for Mode Set.
- *		Valid only if function returns zero.
- *
- * \returns	true - call is successful
- *		false - call failed
- */
-bool dc_service_pp_pre_dce_clock_change(
-	struct dc_context *ctx,
-	struct dal_to_power_info *input,
-	struct power_to_dal_info *output);
-
-struct dc_pp_single_disp_config
-{
-	enum signal_type signal;
-	uint8_t transmitter;
-	uint8_t ddi_channel_mapping;
-	uint8_t pipe_idx;
-	uint32_t src_height;
-	uint32_t src_width;
-	uint32_t v_refresh;
-	uint32_t sym_clock; /* HDMI only */
-	struct link_settings link_settings; /* DP only */
-};
-
-struct dc_pp_display_configuration {
-	bool nb_pstate_switch_disable;/* controls NB PState switch */
-	bool cpu_cc6_disable; /* controls CPU CState switch ( on or off) */
-	bool cpu_pstate_disable;
-	uint32_t cpu_pstate_separation_time;
-
-	uint32_t min_memory_clock_khz;
-	uint32_t min_engine_clock_khz;
-	uint32_t min_engine_clock_deep_sleep_khz;
-
-	uint32_t avail_mclk_switch_time_us;
-	uint32_t avail_mclk_switch_time_in_disp_active_us;
-
-	uint32_t disp_clk_khz;
-
-	bool all_displays_in_sync;
-
-	uint8_t display_count;
-	struct dc_pp_single_disp_config disp_configs[3];
-
-	/*Controller Index of primary display - used in MCLK SMC switching hang
-	 * SW Workaround*/
-	uint8_t crtc_index;
-	/*htotal*1000/pixelclk - used in MCLK SMC switching hang SW Workaround*/
-	uint32_t line_time_in_us;
-};
-
-enum dc_pp_clocks_state {
-	DC_PP_CLOCKS_STATE_INVALID = 0,
-	DC_PP_CLOCKS_STATE_ULTRA_LOW,
-	DC_PP_CLOCKS_STATE_LOW,
-	DC_PP_CLOCKS_STATE_NOMINAL,
-	DC_PP_CLOCKS_STATE_PERFORMANCE,
-
-	/* Starting from DCE11, Max 8 levels of DPM state supported. */
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_INVALID = DC_PP_CLOCKS_STATE_INVALID,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_0 = DC_PP_CLOCKS_STATE_ULTRA_LOW,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_1 = DC_PP_CLOCKS_STATE_LOW,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_2 = DC_PP_CLOCKS_STATE_NOMINAL,
-	/* to be backward compatible */
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_3 = DC_PP_CLOCKS_STATE_PERFORMANCE,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_4 = DC_PP_CLOCKS_DPM_STATE_LEVEL_3 + 1,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_5 = DC_PP_CLOCKS_DPM_STATE_LEVEL_4 + 1,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_6 = DC_PP_CLOCKS_DPM_STATE_LEVEL_5 + 1,
-	DC_PP_CLOCKS_DPM_STATE_LEVEL_7 = DC_PP_CLOCKS_DPM_STATE_LEVEL_6 + 1,
-};
-
-struct dc_pp_static_clock_info {
-	uint32_t max_sclk_khz;
-	uint32_t max_mclk_khz;
-
-	 /* max possible display block clocks state */
-	enum dc_pp_clocks_state max_clocks_state;
-};
-
-/* The returned clocks range are 'static' system clocks which will be used for
- * mode validation purposes.
- *
- * \returns	true - call is successful
- *		false - call failed
- */
-bool dc_service_get_system_clocks_range(
-	const struct dc_context *ctx,
-	struct dal_system_clock_range *sys_clks);
-
-enum dc_pp_clock_type {
-	DC_PP_CLOCK_TYPE_DISPLAY_CLK = 1,
-	DC_PP_CLOCK_TYPE_ENGINE_CLK, /* System clock */
-	DC_PP_CLOCK_TYPE_MEMORY_CLK
-};
-
-#define DC_DECODE_PP_CLOCK_TYPE(clk_type) \
-	(clk_type) == DC_PP_CLOCK_TYPE_DISPLAY_CLK ? "Display" : \
-	(clk_type) == DC_PP_CLOCK_TYPE_ENGINE_CLK ? "Engine" : \
-	(clk_type) == DC_PP_CLOCK_TYPE_MEMORY_CLK ? "Memory" : "Invalid"
-
-#define DC_PP_MAX_CLOCK_LEVELS 8
-
-struct dc_pp_clock_levels {
-	uint32_t num_levels;
-	uint32_t clocks_in_khz[DC_PP_MAX_CLOCK_LEVELS];
-
-	/* TODO: add latency
-	 * do we need to know invalid (unsustainable boost) level for watermark
-	 * programming? if not we can just report less elements in array
-	 */
-};
-
-/* Gets valid clocks levels from pplib
- *
- * input: clk_type - display clk / sclk / mem clk
- *
- * output: array of valid clock levels for given type in ascending order,
- * with invalid levels filtered out
- *
- */
-bool dc_service_pp_get_clock_levels_by_type(
-	const struct dc_context *ctx,
-	enum dc_pp_clock_type clk_type,
-	struct dc_pp_clock_levels *clk_level_info);
-
-
-bool dc_service_pp_apply_safe_state(
-		const struct dc_context *ctx);
-
-/* DAL calls this function to notify PP about completion of Mode Set.
- * For PP it means that current DCE clocks are those which were returned
- * by dc_service_pp_pre_dce_clock_change(), in the 'output' parameter.
- *
- * If the clocks are higher than before, then PP does nothing.
- *
- * If the clocks are lower than before, then PP reduces the voltage.
- *
- * \returns	true - call is successful
- *		false - call failed
- */
-bool dc_service_pp_apply_display_requirements(
-	const struct dc_context *ctx,
-	const struct dc_pp_display_configuration *pp_display_cfg);
-
-
-/****** end of PP interfaces ******/
-
-void dc_service_sleep_in_milliseconds(struct dc_context *ctx, uint32_t milliseconds);
-
-void dc_service_delay_in_microseconds(struct dc_context *ctx, uint32_t microseconds);
-
-enum platform_method {
-	PM_GET_AVAILABLE_METHODS = 1 << 0,
-	PM_GET_LID_STATE = 1 << 1,
-	PM_GET_EXTENDED_BRIGHNESS_CAPS = 1 << 2
-};
-
-struct platform_info_params {
-	enum platform_method method;
-	void *data;
-};
-
-struct platform_info_brightness_caps {
-	uint8_t ac_level_percentage;
-	uint8_t dc_level_percentage;
-};
-
-struct platform_info_ext_brightness_caps {
-	struct platform_info_brightness_caps basic_caps;
-	struct data_point {
-		uint8_t luminance;
-		uint8_t	signal_level;
-	} data_points[99];
-
-	uint8_t	data_points_num;
-	uint8_t	min_input_signal;
-	uint8_t	max_input_signal;
-};
-
-bool dal_get_platform_info(
-	struct dc_context *ctx,
-	struct platform_info_params *params);
-
-/*
- *
- * print-out services
- *
- */
-#define dal_log_to_buffer(buffer, size, fmt, args)\
-	vsnprintf(buffer, size, fmt, args)
-
-long dal_get_pid(void);
-long dal_get_tgid(void);
-
-/*
- *
- * general debug capabilities
- *
- */
-#if defined(CONFIG_DEBUG_KERNEL) || defined(CONFIG_DEBUG_DRIVER)
-
-#if defined(CONFIG_HAVE_KGDB) || defined(CONFIG_KGDB)
-#define ASSERT_CRITICAL(expr) do {	\
-	if (WARN_ON(!(expr))) { \
-		kgdb_breakpoint(); \
-	} \
-} while (0)
-#else
-#define ASSERT_CRITICAL(expr) do {	\
-	if (WARN_ON(!(expr))) { \
-		; \
-	} \
-} while (0)
-#endif
-
-#if defined(CONFIG_DEBUG_KERNEL_DAL)
-#define ASSERT(expr) ASSERT_CRITICAL(expr)
-
-#else
-#define ASSERT(expr) WARN_ON(!(expr))
-#endif
-
-#define BREAK_TO_DEBUGGER() ASSERT(0)
-
-#else
-
-#define ASSERT_CRITICAL(expr)  do {if (expr)/* Do nothing */; } while (0)
-
-#define ASSERT(expr) do {if (expr)/* Do nothing */; } while (0)
-
-#define BREAK_TO_DEBUGGER() do {} while (0)
-
-#endif /* CONFIG_DEBUG_KERNEL || CONFIG_DEBUG_DRIVER */
-
-#endif /* __DC_SERVICES_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_services_types.h b/drivers/gpu/drm/amd/dal/dc/dc_services_types.h
deleted file mode 100644
index aded7b1..0000000
--- a/drivers/gpu/drm/amd/dal/dc/dc_services_types.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_SERVICES_TYPES_H__
-#define __DC_SERVICES_TYPES_H__
-
-#define INVALID_DISPLAY_INDEX 0xffffffff
-
-#if defined __KERNEL__
-
-#include <asm/byteorder.h>
-#include <linux/types.h>
-#include <drm/drmP.h>
-
-#include "cgs_linux.h"
-
-#if defined(__BIG_ENDIAN) && !defined(BIGENDIAN_CPU)
-#define BIGENDIAN_CPU
-#elif defined(__LITTLE_ENDIAN) && !defined(LITTLEENDIAN_CPU)
-#define LITTLEENDIAN_CPU
-#endif
-
-#undef READ
-#undef WRITE
-#undef FRAME_SIZE
-
-#define dal_output_to_console(fmt, ...) DRM_INFO(fmt, ##__VA_ARGS__)
-
-#define dal_error(fmt, ...) DRM_ERROR(fmt, ##__VA_ARGS__)
-
-#define dal_debug(fmt, ...) DRM_DEBUG_KMS(fmt, ##__VA_ARGS__)
-
-#define dal_vlog(fmt, args) vprintk(fmt, args)
-
-#define dal_min(x, y) min(x, y)
-#define dal_max(x, y) max(x, y)
-
-#elif defined BUILD_DAL_TEST
-
-#include <inttypes.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <stdio.h>
-
-#include <stdarg.h>
-
-#include "cgs_linux.h"
-
-#define LONG_MAX	((long)(~0UL>>1))
-#define LONG_MIN	(-LONG_MAX - 1)
-#define LLONG_MAX	((long long)(~0ULL>>1))
-#define LLONG_MIN	(-LLONG_MAX - 1)
-#define UINT_MAX	(~0U)
-
-typedef _Bool bool;
-enum { false, true };
-
-#ifndef NULL
-#define NULL ((void *)0)
-#endif
-
-#define LITTLEENDIAN_CPU 1
-
-#include <test_context.h>
-
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-
-#define container_of(ptr, type, member) \
-	((type *)((char *)(ptr) - offsetof(type, member)))
-
-#define dal_test_not_implemented() \
-	printf("[DAL_TEST_NOT_IMPL]:%s\n", __func__)
-
-#define dal_output_to_console(fmt, ...) do { \
-	printf("[DAL_LOG]" fmt, ##__VA_ARGS__); } \
-	while (false)
-
-#define dal_error(fmt, ...) printf("[DAL_ERROR]" fmt, ##__VA_ARGS__)
-
-#define dal_output_to_console(fmt, ...) do { \
-			printf("[DAL_LOG]" fmt, ##__VA_ARGS__); } \
-				while (false)
-
-
-#define dal_debug(fmt, ...) printf("[DAL_DBG]" fmt, ##__VA_ARGS__)
-
-#define dal_vlog(fmt, args) vprintf(fmt, args)
-
-#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
-
-#define dal_min(x, y) ({\
-	typeof(x) _min1 = (x);\
-	typeof(y) _min2 = (y);\
-	(void) (&_min1 == &_min2);\
-	_min1 < _min2 ? _min1 : _min2; })
-
-#define dal_max(x, y) ({\
-	typeof(x) _max1 = (x);\
-	typeof(y) _max2 = (y);\
-	(void) (&_max1 == &_max2);\
-	_max1 > _max2 ? _max1 : _max2; })
-
-/* division functions */
-
-static inline int64_t div64_s64(int64_t x, int64_t y)
-{
-	return x / y;
-}
-
-static inline uint64_t div64_u64(uint64_t x, uint64_t y)
-{
-	return x / y;
-}
-
-static inline uint64_t div_u64(uint64_t x, uint32_t y)
-{
-	return x / y;
-}
-
-static inline uint64_t div64_u64_rem(uint64_t x, uint64_t y, uint64_t *rem)
-{
-	if (rem)
-		*rem = x % y;
-	return x / y;
-}
-
-static inline uint64_t div_u64_rem(uint64_t x, uint32_t y, uint32_t *rem)
-{
-	if (rem)
-		*rem = x % y;
-	return x / y;
-}
-
-#define cpu_to_le16(do_nothing) do_nothing
-
-#define le16_to_cpu(do_nothing) do_nothing
-
-#define cpu_to_le32(do_nothing) do_nothing
-
-#define le32_to_cpu(do_nothing) do_nothing
-
-#endif
-
-#endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_types.h b/drivers/gpu/drm/amd/dal/dc/dc_types.h
index 0a48ef4..c238531 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_types.h
@@ -25,7 +25,7 @@
 #ifndef DC_TYPES_H_
 #define DC_TYPES_H_
 
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 #include "fixed32_32.h"
 #include "fixed31_32.h"
 #include "irq_types.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
index 75aff2a..82c5e15 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dc.h"
 #include "core_dc.h"
 #include "core_types.h"
@@ -88,7 +88,7 @@ static void dce100_enable_fe_clock(
 
 	addr = HW_REG_CRTC(mmDCFE_CLOCK_CONTROL, controller_id);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -96,7 +96,7 @@ static void dce100_enable_fe_clock(
 		DCFE_CLOCK_CONTROL,
 		DCFE_CLOCK_ENABLE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static bool dce100_pipe_control_lock(
@@ -106,7 +106,7 @@ static bool dce100_pipe_control_lock(
 	bool lock)
 {
 	uint32_t addr = HW_REG_BLND(mmBLND_V_UPDATE_LOCK, controller_idx);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 	bool need_to_wait = false;
 
 	if (control_mask & PIPE_LOCK_CONTROL_GRAPHICS)
@@ -146,7 +146,7 @@ static bool dce100_pipe_control_lock(
 			BLND_V_UPDATE_LOCK,
 			BLND_V_UPDATE_LOCK_MODE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	if (!lock && need_to_wait) {
 		uint8_t counter = 0;
@@ -159,7 +159,7 @@ static bool dce100_pipe_control_lock(
 				controller_idx);
 
 		while (counter < counter_limit) {
-			value = dal_read_reg(ctx, addr);
+			value = dm_read_reg(ctx, addr);
 
 			pipe_pending = 0;
 
@@ -214,7 +214,7 @@ static bool dce100_pipe_control_lock(
 				break;
 
 			counter++;
-			dc_service_delay_in_microseconds(ctx, delay_us);
+			dm_delay_in_microseconds(ctx, delay_us);
 		}
 
 		if (counter == counter_limit) {
@@ -267,7 +267,7 @@ static void dce100_set_blender_mode(
 		break;
 	}
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -281,7 +281,7 @@ static void dce100_set_blender_mode(
 		BLND_CONTROL,
 		BLND_MODE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static bool dce100_enable_display_power_gating(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 9d438a9..e67ba81 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -22,7 +22,8 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+
+#include "dm_services.h"
 
 #include "link_encoder.h"
 #include "stream_encoder.h"
@@ -340,7 +341,7 @@ static struct timing_generator *dce100_timing_generator_create(
 		const struct dce110_timing_generator_offsets *offsets)
 {
 	struct dce110_timing_generator *tg110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_timing_generator));
+		dm_alloc(ctx, sizeof(struct dce110_timing_generator));
 
 	if (!tg110)
 		return NULL;
@@ -350,7 +351,7 @@ static struct timing_generator *dce100_timing_generator_create(
 		return &tg110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, tg110);
+	dm_free(ctx, tg110);
 	return NULL;
 }
 
@@ -361,7 +362,7 @@ static struct stream_encoder *dce100_stream_encoder_create(
 	const struct dce110_stream_enc_registers *regs)
 {
 	struct dce110_stream_encoder *enc110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_stream_encoder));
+		dm_alloc(ctx, sizeof(struct dce110_stream_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -370,7 +371,7 @@ static struct stream_encoder *dce100_stream_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, enc110);
+	dm_free(ctx, enc110);
 	return NULL;
 }
 
@@ -380,7 +381,7 @@ static struct mem_input *dce100_mem_input_create(
 	const struct dce110_mem_input_reg_offsets *offset)
 {
 	struct dce110_mem_input *mem_input110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_mem_input));
+		dm_alloc(ctx, sizeof(struct dce110_mem_input));
 
 	if (!mem_input110)
 		return NULL;
@@ -390,13 +391,13 @@ static struct mem_input *dce100_mem_input_create(
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, mem_input110);
+	dm_free(ctx, mem_input110);
 	return NULL;
 }
 
 static void dce100_transform_destroy(struct transform **xfm)
 {
-	dc_service_free((*xfm)->ctx, TO_DCE110_TRANSFORM(*xfm));
+	dm_free((*xfm)->ctx, TO_DCE110_TRANSFORM(*xfm));
 	*xfm = NULL;
 }
 
@@ -406,7 +407,7 @@ static struct transform *dce100_transform_create(
 	const struct dce110_transform_reg_offsets *offsets)
 {
 	struct dce110_transform *transform =
-		dc_service_alloc(ctx, sizeof(struct dce110_transform));
+		dm_alloc(ctx, sizeof(struct dce110_transform));
 
 	if (!transform)
 		return NULL;
@@ -415,7 +416,7 @@ static struct transform *dce100_transform_create(
 		return &transform->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, transform);
+	dm_free(ctx, transform);
 	return NULL;
 }
 
@@ -425,7 +426,7 @@ static struct input_pixel_processor *dce100_ipp_create(
 	const struct dce110_ipp_reg_offsets *offsets)
 {
 	struct dce110_ipp *ipp =
-		dc_service_alloc(ctx, sizeof(struct dce110_ipp));
+		dm_alloc(ctx, sizeof(struct dce110_ipp));
 
 	if (!ipp)
 		return NULL;
@@ -434,7 +435,7 @@ static struct input_pixel_processor *dce100_ipp_create(
 		return &ipp->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, ipp);
+	dm_free(ctx, ipp);
 	return NULL;
 }
 
@@ -442,7 +443,7 @@ struct link_encoder *dce100_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
 	struct dce110_link_encoder *enc110 =
-		dc_service_alloc(
+		dm_alloc(
 			enc_init_data->ctx,
 			sizeof(struct dce110_link_encoder));
 
@@ -458,7 +459,7 @@ struct link_encoder *dce100_link_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(enc_init_data->ctx, enc110);
+	dm_free(enc_init_data->ctx, enc110);
 	return NULL;
 }
 
@@ -469,7 +470,7 @@ struct output_pixel_processor *dce100_opp_create(
 	const struct dce110_opp_reg_offsets *offset)
 {
 	struct dce110_opp *opp =
-		dc_service_alloc(ctx, sizeof(struct dce110_opp));
+		dm_alloc(ctx, sizeof(struct dce110_opp));
 
 	if (!opp)
 		return NULL;
@@ -479,24 +480,24 @@ struct output_pixel_processor *dce100_opp_create(
 		return &opp->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, opp);
+	dm_free(ctx, opp);
 	return NULL;
 }
 
 
 void dce100_opp_destroy(struct output_pixel_processor **opp)
 {
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_dx);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_oem);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_1025);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_256);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coordinates_x);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_regamma);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_resulted);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_oem);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_user);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp));
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_dx);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_oem);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_1025);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_256);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coordinates_x);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_regamma);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_resulted);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_oem);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_user);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp));
 	*opp = NULL;
 }
 
@@ -507,7 +508,7 @@ struct clock_source *dce100_clock_source_create(
 	const struct dce110_clk_src_reg_offsets *offsets)
 {
 	struct dce110_clk_src *clk_src =
-		dc_service_alloc(ctx, sizeof(struct dce110_clk_src));
+		dm_alloc(ctx, sizeof(struct dce110_clk_src));
 
 	if (!clk_src)
 		return NULL;
@@ -521,7 +522,7 @@ struct clock_source *dce100_clock_source_create(
 
 void dce100_clock_source_destroy(struct clock_source **clk_src)
 {
-	dc_service_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
+	dm_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
 	*clk_src = NULL;
 }
 
@@ -540,13 +541,13 @@ void dce100_destruct_resource_pool(struct resource_pool *pool)
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dc_service_free(pool->mis[i]->ctx,
+			dm_free(pool->mis[i]->ctx,
 					TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dc_service_free(pool->timing_generators[i]->ctx,
+			dm_free(pool->timing_generators[i]->ctx,
 					DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
@@ -554,7 +555,7 @@ void dce100_destruct_resource_pool(struct resource_pool *pool)
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dc_service_free(pool->stream_enc[i]->ctx,
+			dm_free(pool->stream_enc[i]->ctx,
 				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
@@ -775,7 +776,6 @@ enum dc_status dce100_validate_bandwidth(
 	/* TODO implement when needed */
 
 	return DC_OK;
-
 }
 
 static void set_target_unchanged(
@@ -942,7 +942,7 @@ bool dce100_construct_resource_pool(
 
 	for (i = 0; i < pool->clk_src_count; i++) {
 		if (pool->clock_sources[i] == NULL) {
-			dal_error("DC: failed to create clock sources!\n");
+			dm_error("DC: failed to create clock sources!\n");
 			BREAK_TO_DEBUGGER();
 			goto clk_src_create_fail;
 		}
@@ -950,7 +950,7 @@ bool dce100_construct_resource_pool(
 
 	pool->display_clock = dal_display_clock_dce110_create(ctx, adapter_serv);
 	if (pool->display_clock == NULL) {
-		dal_error("DC: failed to create display clock!\n");
+		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto disp_clk_create_fail;
 	}
@@ -975,7 +975,7 @@ bool dce100_construct_resource_pool(
 	pool->scaler_filter = dal_scaler_filter_create(ctx);
 	if (pool->scaler_filter == NULL) {
 		BREAK_TO_DEBUGGER();
-		dal_error("DC: failed to create filter!\n");
+		dm_error("DC: failed to create filter!\n");
 		goto filter_create_fail;
 	}
 
@@ -984,7 +984,7 @@ bool dce100_construct_resource_pool(
 				adapter_serv, ctx, i, &dce100_tg_offsets[i]);
 		if (pool->timing_generators[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error("DC: failed to create tg!\n");
+			dm_error("DC: failed to create tg!\n");
 			goto controller_create_fail;
 		}
 
@@ -992,7 +992,7 @@ bool dce100_construct_resource_pool(
 				&dce100_mi_reg_offsets[i]);
 		if (pool->mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create memory input!\n");
 			goto controller_create_fail;
 		}
@@ -1001,7 +1001,7 @@ bool dce100_construct_resource_pool(
 				&dce100_ipp_reg_offsets[i]);
 		if (pool->ipps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create input pixel processor!\n");
 			goto controller_create_fail;
 		}
@@ -1010,7 +1010,7 @@ bool dce100_construct_resource_pool(
 					ctx, i, &dce100_xfm_offsets[i]);
 		if (pool->transforms[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create transform!\n");
 			goto controller_create_fail;
 		}
@@ -1021,7 +1021,7 @@ bool dce100_construct_resource_pool(
 		pool->opps[i] = dce100_opp_create(ctx, i, &dce100_opp_reg_offsets[i]);
 		if (pool->opps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create output pixel processor!\n");
 			goto controller_create_fail;
 		}
@@ -1043,7 +1043,7 @@ bool dce100_construct_resource_pool(
 		pool->audios[i] = dal_audio_create(&audio_init_data);
 		if (pool->audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error("DC: failed to create DPPs!\n");
+			dm_error("DC: failed to create DPPs!\n");
 			goto audio_create_fail;
 		}
 		pool->audio_count++;
@@ -1059,7 +1059,7 @@ bool dce100_construct_resource_pool(
 				&stream_enc_regs[i]);
 			if (pool->stream_enc[i] == NULL) {
 				BREAK_TO_DEBUGGER();
-				dal_error("DC: failed to create stream_encoder!\n");
+				dm_error("DC: failed to create stream_encoder!\n");
 				goto stream_enc_create_fail;
 			}
 		}
@@ -1072,7 +1072,7 @@ bool dce100_construct_resource_pool(
 								adapter_serv));
 		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error("DC: failed to create stream_encoder!\n");
+			dm_error("DC: failed to create stream_encoder!\n");
 			goto stream_enc_create_fail;
 		}
 		pool->stream_enc_count++;
@@ -1083,7 +1083,7 @@ bool dce100_construct_resource_pool(
 stream_enc_create_fail:
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dc_service_free(pool->stream_enc[i]->ctx,
+			dm_free(pool->stream_enc[i]->ctx,
 				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
@@ -1105,13 +1105,13 @@ controller_create_fail:
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dc_service_free(pool->mis[i]->ctx,
+			dm_free(pool->mis[i]->ctx,
 					TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dc_service_free(pool->timing_generators[i]->ctx,
+			dm_free(pool->timing_generators[i]->ctx,
 				DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
index f0cf18f..e1bac1f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -476,7 +476,7 @@ static uint32_t dce110_get_pix_clk_dividers(
 		return pll_calc_error;
 	}
 
-	dc_service_memset(pll_settings, 0, sizeof(*pll_settings));
+	dm_memset(pll_settings, 0, sizeof(*pll_settings));
 
 	if (cs->id == CLOCK_SOURCE_ID_EXTERNAL) {
 		pll_settings->adjusted_pix_clk = clk_src->ext_clk_khz;
@@ -492,7 +492,7 @@ static uint32_t dce110_get_pix_clk_dividers(
 	* 00 - PCIE_REFCLK, 01 - XTALIN,    02 - GENERICA,    03 - GENERICB
 	* 04 - HSYNCA,      05 - GENLK_CLK, 06 - PCIE_REFCLK, 07 - DVOCLK0 */
 	addr = clk_src->offsets.pll_cntl;
-	value = dal_read_reg(clk_src->base.ctx, addr);
+	value = dm_read_reg(clk_src->base.ctx, addr);
 	field = get_reg_field_value(value, PLL_CNTL, PLL_REF_DIV_SRC);
 	pll_settings->use_external_clk = (field > 1);
 
@@ -583,7 +583,7 @@ static bool calculate_ss(
 		return false;
 
 
-	dc_service_memset(ds_data, 0, sizeof(struct delta_sigma_data));
+	dm_memset(ds_data, 0, sizeof(struct delta_sigma_data));
 
 
 
@@ -683,7 +683,7 @@ static void program_pixel_clk_resync(
 {
 	uint32_t value = 0;
 
-	value = dal_read_reg(clk_src->base.ctx, clk_src->offsets.pixclk_resync_cntl);
+	value = dm_read_reg(clk_src->base.ctx, clk_src->offsets.pixclk_resync_cntl);
 
 	set_reg_field_value(
 		value,
@@ -733,7 +733,7 @@ static void program_pixel_clk_resync(
 		break;
 	}
 
-	dal_write_reg(
+	dm_write_reg(
 		clk_src->base.ctx,
 		clk_src->offsets.pixclk_resync_cntl,
 		value);
@@ -868,13 +868,13 @@ static void get_ss_info_from_atombios(
 	if (*ss_entries_num == 0)
 		return;
 
-	ss_info = dc_service_alloc(clk_src->base.ctx, sizeof(struct spread_spectrum_info)
+	ss_info = dm_alloc(clk_src->base.ctx, sizeof(struct spread_spectrum_info)
 				* (*ss_entries_num));
 	ss_info_cur = ss_info;
 	if (ss_info == NULL)
 		return;
 
-	ss_data = dc_service_alloc(clk_src->base.ctx, sizeof(struct spread_spectrum_data) *
+	ss_data = dm_alloc(clk_src->base.ctx, sizeof(struct spread_spectrum_data) *
 							(*ss_entries_num));
 	if (ss_data == NULL)
 		goto out_free_info;
@@ -949,14 +949,14 @@ static void get_ss_info_from_atombios(
 	}
 
 	*spread_spectrum_data = ss_data;
-	dc_service_free(clk_src->base.ctx, ss_info);
+	dm_free(clk_src->base.ctx, ss_info);
 	return;
 
 out_free_data:
-	dc_service_free(clk_src->base.ctx, ss_data);
+	dm_free(clk_src->base.ctx, ss_data);
 	*ss_entries_num = 0;
 out_free_info:
-	dc_service_free(clk_src->base.ctx, ss_info);
+	dm_free(clk_src->base.ctx, ss_info);
 }
 
 static void ss_info_from_atombios_create(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
index 6761b4f..285d544 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -313,13 +313,13 @@ static void wait_for_fbc_state_changed(
 	uint32_t value;
 
 	while (counter < 10) {
-		value = dal_read_reg(cp110->base.ctx, addr);
+		value = dm_read_reg(cp110->base.ctx, addr);
 		if (get_reg_field_value(
 			value,
 			FBC_STATUS,
 			FBC_ENABLE_STATUS) == enabled)
 			break;
-		dc_service_delay_in_microseconds(cp110->base.ctx, 10);
+		dm_delay_in_microseconds(cp110->base.ctx, 10);
 		counter++;
 	}
 
@@ -339,7 +339,7 @@ void dce110_compressor_power_up_fbc(struct compressor *compressor)
 	uint32_t addr;
 
 	addr = mmFBC_CNTL;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
 	set_reg_field_value(value, 1, FBC_CNTL, FBC_EN);
 	set_reg_field_value(value, 2, FBC_CNTL, FBC_COHERENCY_MODE);
@@ -351,32 +351,32 @@ void dce110_compressor_power_up_fbc(struct compressor *compressor)
 			FBC_CNTL,
 			FBC_COMP_CLK_GATE_EN);
 	}
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	addr = mmFBC_COMP_MODE;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(value, 1, FBC_COMP_MODE, FBC_RLE_EN);
 	set_reg_field_value(value, 1, FBC_COMP_MODE, FBC_DPCM4_RGB_EN);
 	set_reg_field_value(value, 1, FBC_COMP_MODE, FBC_IND_EN);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	addr = mmFBC_COMP_CNTL;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(value, 1, FBC_COMP_CNTL, FBC_DEPTH_RGB08_EN);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 	/*FBC_MIN_COMPRESSION 0 ==> 2:1 */
 	/*                    1 ==> 4:1 */
 	/*                    2 ==> 8:1 */
 	/*                  0xF ==> 1:1 */
 	set_reg_field_value(value, 0xF, FBC_COMP_CNTL, FBC_MIN_COMPRESSION);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 	compressor->min_compress_ratio = FBC_COMPRESS_RATIO_1TO1;
 
 	value = 0;
-	dal_write_reg(compressor->ctx, mmFBC_IND_LUT0, value);
+	dm_write_reg(compressor->ctx, mmFBC_IND_LUT0, value);
 
 	value = 0xFFFFFF;
-	dal_write_reg(compressor->ctx, mmFBC_IND_LUT1, value);
+	dm_write_reg(compressor->ctx, mmFBC_IND_LUT1, value);
 }
 
 void dce110_compressor_enable_fbc(
@@ -408,13 +408,13 @@ void dce110_compressor_enable_fbc(
 		}
 
 		addr = mmFBC_CNTL;
-		value = dal_read_reg(compressor->ctx, addr);
+		value = dm_read_reg(compressor->ctx, addr);
 		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
 		set_reg_field_value(
 			value,
 			params->inst,
 			FBC_CNTL, FBC_SRC_SEL);
-		dal_write_reg(compressor->ctx, addr, value);
+		dm_write_reg(compressor->ctx, addr, value);
 
 		/* Keep track of enum controller_id FBC is attached to */
 		compressor->is_enabled = true;
@@ -423,9 +423,9 @@ void dce110_compressor_enable_fbc(
 
 		/*Toggle it as there is bug in HW */
 		set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
-		dal_write_reg(compressor->ctx, addr, value);
+		dm_write_reg(compressor->ctx, addr, value);
 		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
-		dal_write_reg(compressor->ctx, addr, value);
+		dm_write_reg(compressor->ctx, addr, value);
 
 		wait_for_fbc_state_changed(cp110, true);
 	}
@@ -439,9 +439,9 @@ void dce110_compressor_disable_fbc(struct compressor *compressor)
 		dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) {
 		uint32_t reg_data;
 		/* Turn off compression */
-		reg_data = dal_read_reg(compressor->ctx, mmFBC_CNTL);
+		reg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);
 		set_reg_field_value(reg_data, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
-		dal_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);
+		dm_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);
 
 		/* Reset enum controller_id to undefined */
 		compressor->attached_inst = 0;
@@ -463,16 +463,16 @@ bool dce110_compressor_is_fbc_enabled_in_hw(
 	/* Check the hardware register */
 	uint32_t value;
 
-	value = dal_read_reg(compressor->ctx, mmFBC_STATUS);
+	value = dm_read_reg(compressor->ctx, mmFBC_STATUS);
 	if (get_reg_field_value(value, FBC_STATUS, FBC_ENABLE_STATUS)) {
 		if (inst != NULL)
 			*inst = compressor->attached_inst;
 		return true;
 	}
 
-	value = dal_read_reg(compressor->ctx, mmFBC_MISC);
+	value = dm_read_reg(compressor->ctx, mmFBC_MISC);
 	if (get_reg_field_value(value, FBC_MISC, FBC_STOP_ON_HFLIP_EVENT)) {
-		value = dal_read_reg(compressor->ctx, mmFBC_CNTL);
+		value = dm_read_reg(compressor->ctx, mmFBC_CNTL);
 
 		if (get_reg_field_value(value, FBC_CNTL, FBC_GRPH_COMP_EN)) {
 			if (inst != NULL)
@@ -487,7 +487,7 @@ bool dce110_compressor_is_fbc_enabled_in_hw(
 bool dce110_compressor_is_lpt_enabled_in_hw(struct compressor *compressor)
 {
 	/* Check the hardware register */
-	uint32_t value = dal_read_reg(compressor->ctx,
+	uint32_t value = dm_read_reg(compressor->ctx,
 		mmLOW_POWER_TILING_CONTROL);
 
 	return get_reg_field_value(
@@ -507,11 +507,11 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 		compressor->compr_surface_address.addr.low_part;
 
 	/* Clear content first. */
-	dal_write_reg(
+	dm_write_reg(
 		compressor->ctx,
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),
 		0);
-	dal_write_reg(compressor->ctx,
+	dm_write_reg(compressor->ctx,
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS), 0);
 
 	if (compressor->options.bits.LPT_SUPPORT) {
@@ -526,10 +526,10 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 	}
 
 	/* Write address, HIGH has to be first. */
-	dal_write_reg(compressor->ctx,
+	dm_write_reg(compressor->ctx,
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),
 		compressor->compr_surface_address.addr.high_part);
-	dal_write_reg(compressor->ctx,
+	dm_write_reg(compressor->ctx,
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS),
 		compressed_surf_address_low_part);
 
@@ -548,7 +548,7 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 			__func__);
 
 	/* Clear content first. */
-	dal_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), 0);
+	dm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), 0);
 
 	/* Write FBC Pitch. */
 	set_reg_field_value(
@@ -556,7 +556,7 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 		fbc_pitch,
 		GRPH_COMPRESS_PITCH,
 		GRPH_COMPRESS_PITCH);
-	dal_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), value);
+	dm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), value);
 
 }
 
@@ -570,7 +570,7 @@ void dce110_compressor_disable_lpt(struct compressor *compressor)
 	/* Disable all pipes LPT Stutter */
 	for (inx = 0; inx < 3; inx++) {
 		value =
-			dal_read_reg(
+			dm_read_reg(
 				compressor->ctx,
 				DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));
 		set_reg_field_value(
@@ -578,40 +578,40 @@ void dce110_compressor_disable_lpt(struct compressor *compressor)
 			0,
 			DPG_PIPE_STUTTER_CONTROL_NONLPTCH,
 			STUTTER_ENABLE_NONLPTCH);
-		dal_write_reg(
+		dm_write_reg(
 			compressor->ctx,
 			DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH),
 			value);
 	}
 	/* Disable Underlay pipe LPT Stutter */
 	addr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		0,
 		DPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,
 		STUTTER_ENABLE_NONLPTCH);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	/* Disable LPT */
 	addr = mmLOW_POWER_TILING_CONTROL;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		0,
 		LOW_POWER_TILING_CONTROL,
 		LOW_POWER_TILING_ENABLE);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	/* Clear selection of Channel(s) containing Compressed Surface */
 	addr = mmGMCON_LPT_TARGET;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		0xFFFFFFFF,
 		GMCON_LPT_TARGET,
 		STCTRL_LPT_TARGET);
-	dal_write_reg(compressor->ctx, mmGMCON_LPT_TARGET, value);
+	dm_write_reg(compressor->ctx, mmGMCON_LPT_TARGET, value);
 }
 
 void dce110_compressor_enable_lpt(struct compressor *compressor)
@@ -623,54 +623,54 @@ void dce110_compressor_enable_lpt(struct compressor *compressor)
 	uint32_t channels;
 
 	/* Enable LPT Stutter from Display pipe */
-	value = dal_read_reg(compressor->ctx,
+	value = dm_read_reg(compressor->ctx,
 		DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));
 	set_reg_field_value(
 		value,
 		1,
 		DPG_PIPE_STUTTER_CONTROL_NONLPTCH,
 		STUTTER_ENABLE_NONLPTCH);
-	dal_write_reg(compressor->ctx,
+	dm_write_reg(compressor->ctx,
 		DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH), value);
 
 	/* Enable Underlay pipe LPT Stutter */
 	addr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
 		DPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,
 		STUTTER_ENABLE_NONLPTCH);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	/* Selection of Channel(s) containing Compressed Surface: 0xfffffff
 	 * will disable LPT.
 	 * STCTRL_LPT_TARGETn corresponds to channel n. */
 	addr = mmLOW_POWER_TILING_CONTROL;
-	value_control = dal_read_reg(compressor->ctx, addr);
+	value_control = dm_read_reg(compressor->ctx, addr);
 	channels = get_reg_field_value(value_control,
 			LOW_POWER_TILING_CONTROL,
 			LOW_POWER_TILING_MODE);
 
 	addr = mmGMCON_LPT_TARGET;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		channels + 1, /* not mentioned in programming guide,
 				but follow DCE8.1 */
 		GMCON_LPT_TARGET,
 		STCTRL_LPT_TARGET);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	/* Enable LPT */
 	addr = mmLOW_POWER_TILING_CONTROL;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
 		LOW_POWER_TILING_CONTROL,
 		LOW_POWER_TILING_ENABLE);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 }
 
 void dce110_compressor_program_lpt_control(
@@ -687,7 +687,7 @@ void dce110_compressor_program_lpt_control(
 	if (!compressor->options.bits.LPT_SUPPORT)
 		return;
 
-	lpt_control = dal_read_reg(compressor->ctx,
+	lpt_control = dm_read_reg(compressor->ctx,
 		mmLOW_POWER_TILING_CONTROL);
 
 	/* POSSIBLE VALUES for Low Power Tiling Mode:
@@ -745,7 +745,7 @@ void dce110_compressor_program_lpt_control(
 		LOW_POWER_TILING_CONTROL,
 		LOW_POWER_TILING_ROWS_PER_CHAN);
 
-	dal_write_reg(compressor->ctx,
+	dm_write_reg(compressor->ctx,
 		mmLOW_POWER_TILING_CONTROL, lpt_control);
 }
 
@@ -762,14 +762,14 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 	 * for DCE 11 regions cannot be used - does not work with S/G
 	 */
 	uint32_t addr = mmFBC_CLIENT_REGION_MASK;
-	uint32_t value = dal_read_reg(compressor->ctx, addr);
+	uint32_t value = dm_read_reg(compressor->ctx, addr);
 
 	set_reg_field_value(
 		value,
 		0,
 		FBC_CLIENT_REGION_MASK,
 		FBC_MEMORY_REGION_MASK);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 
 	/* Setup events when to clear all CSM entries (effectively marking
 	 * current compressed data invalid)
@@ -796,7 +796,7 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 	 *      - Bit 7 - FBC_FORCE_COPY_TO_COMP_BUF register updated
 	 */
 	addr = mmFBC_IDLE_FORCE_CLEAR_MASK;
-	value = dal_read_reg(compressor->ctx, addr);
+	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
 		fbc_trigger |
@@ -808,7 +808,7 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 		FBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF,
 		FBC_IDLE_FORCE_CLEAR_MASK,
 		FBC_IDLE_FORCE_CLEAR_MASK);
-	dal_write_reg(compressor->ctx, addr, value);
+	dm_write_reg(compressor->ctx, addr, value);
 }
 
 bool dce110_compressor_construct(struct dce110_compressor *compressor,
@@ -866,7 +866,7 @@ struct compressor *dce110_compressor_create(struct dc_context *ctx,
 	struct adapter_service *as)
 {
 	struct dce110_compressor *cp110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_compressor));
+		dm_alloc(ctx, sizeof(struct dce110_compressor));
 
 	if (!cp110)
 		return NULL;
@@ -875,12 +875,12 @@ struct compressor *dce110_compressor_create(struct dc_context *ctx,
 		return &cp110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, cp110);
+	dm_free(ctx, cp110);
 	return NULL;
 }
 
 void dce110_compressor_destroy(struct compressor **compressor)
 {
-	dc_service_free((*compressor)->ctx, TO_DCE110_COMPRESSOR(*compressor));
+	dm_free((*compressor)->ctx, TO_DCE110_COMPRESSOR(*compressor));
 	*compressor = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index e1ed527..89d5c65 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -22,14 +22,14 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dc.h"
 #include "dc_bios_types.h"
 #include "core_types.h"
 #include "core_status.h"
 #include "resource.h"
 #include "hw_sequencer.h"
-#include "dc_helpers.h"
+#include "dm_helpers.h"
 #include "dce110_hw_sequencer.h"
 
 #include "gpu/dce110/dc_clock_gating_dce110.h"
@@ -109,7 +109,7 @@ static void dce110_enable_fe_clock(
 	/*TODO: proper offset*/
 	addr = HW_REG_DCFE(mmDCFE_CLOCK_CONTROL, controller_id);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -117,7 +117,7 @@ static void dce110_enable_fe_clock(
 		DCFE_CLOCK_CONTROL,
 		DCFE_CLOCK_ENABLE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void dce110_init_pte(struct dc_context *ctx)
@@ -128,7 +128,7 @@ static void dce110_init_pte(struct dc_context *ctx)
 	uint32_t chunk_mul = 0;
 
 	addr = mmUNP_DVMM_PTE_CONTROL;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -148,10 +148,10 @@ static void dce110_init_pte(struct dc_context *ctx)
 		DVMM_PTE_CONTROL,
 		DVMM_PTE_BUFFER_MODE1);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = mmDVMM_PTE_REQ;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	chunk_int = get_reg_field_value(
 		value,
@@ -183,7 +183,7 @@ static void dce110_init_pte(struct dc_context *ctx)
 			DVMM_PTE_REQ,
 			HFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 }
 
@@ -196,8 +196,8 @@ static void trigger_write_crtc_h_blank_start_end(
 	uint32_t addr;
 
 	addr =  HW_REG_CRTC(mmCRTC_H_BLANK_START_END, controller_id);
-	value = dal_read_reg(ctx, addr);
-	dal_write_reg(ctx, addr, value);
+	value = dm_read_reg(ctx, addr);
+	dm_write_reg(ctx, addr, value);
 }
 
 static bool dce110_pipe_control_lock(
@@ -207,7 +207,7 @@ static bool dce110_pipe_control_lock(
 	bool lock)
 {
 	uint32_t addr = HW_REG_BLND(mmBLND_V_UPDATE_LOCK, controller_idx);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 	bool need_to_wait = false;
 
 	if (control_mask & PIPE_LOCK_CONTROL_GRAPHICS)
@@ -247,7 +247,7 @@ static bool dce110_pipe_control_lock(
 			BLND_V_UPDATE_LOCK,
 			BLND_V_UPDATE_LOCK_MODE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	if (!lock && need_to_wait) {
 		uint8_t counter = 0;
@@ -260,7 +260,7 @@ static bool dce110_pipe_control_lock(
 				controller_idx);
 
 		while (counter < counter_limit) {
-			value = dal_read_reg(ctx, addr);
+			value = dm_read_reg(ctx, addr);
 
 			pipe_pending = 0;
 
@@ -315,7 +315,7 @@ static bool dce110_pipe_control_lock(
 				break;
 
 			counter++;
-			dc_service_delay_in_microseconds(ctx, delay_us);
+			dm_delay_in_microseconds(ctx, delay_us);
 		}
 
 		if (counter == counter_limit) {
@@ -371,7 +371,7 @@ static void dce110_set_blender_mode(
 		break;
 	}
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -385,7 +385,7 @@ static void dce110_set_blender_mode(
 		BLND_CONTROL,
 		BLND_MODE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void dce110_crtc_switch_to_clk_src(
@@ -397,7 +397,7 @@ static void dce110_crtc_switch_to_clk_src(
 	addr = mmCRTC0_PIXEL_RATE_CNTL + crtc_inst *
 			(mmCRTC1_PIXEL_RATE_CNTL - mmCRTC0_PIXEL_RATE_CNTL);
 
-	pixel_rate_cntl_value = dal_read_reg(clk_src->ctx, addr);
+	pixel_rate_cntl_value = dm_read_reg(clk_src->ctx, addr);
 
 	if (clk_src->id == CLOCK_SOURCE_ID_EXTERNAL)
 		set_reg_field_value(pixel_rate_cntl_value, 1,
@@ -413,7 +413,7 @@ static void dce110_crtc_switch_to_clk_src(
 				CRTC0_PIXEL_RATE_CNTL,
 				CRTC0_PIXEL_RATE_SOURCE);
 	}
-	dal_write_reg(clk_src->ctx, addr, pixel_rate_cntl_value);
+	dm_write_reg(clk_src->ctx, addr, pixel_rate_cntl_value);
 }
 /**************************************************************************/
 
@@ -897,7 +897,7 @@ static void power_down_clock_sources(struct dc *dc)
 	for (i = 0; i < dc->res_pool.clk_src_count; i++) {
 		if (dc->res_pool.clock_sources[i]->funcs->cs_power_down(
 				dc->res_pool.clock_sources[i]) == false)
-			dal_error("Failed to power down pll! (clk src index=%d)\n", i);
+			dm_error("Failed to power down pll! (clk src index=%d)\n", i);
 	}
 }
 
@@ -1011,7 +1011,7 @@ static bool dc_pre_clock_change(
 	}
 
 	if (!dc_service_pp_pre_dce_clock_change(ctx, &input, output)) {
-		dal_error("DC: dc_service_pp_pre_dce_clock_change failed!\n");
+		dm_error("DC: dc_service_pp_pre_dce_clock_change failed!\n");
 		return false;
 	}
 
@@ -1051,7 +1051,7 @@ static bool dc_set_clocks_and_clock_state (
 	if (!dal_display_clock_set_min_clocks_state(
 			disp_clk, context->res_ctx.required_clocks_state)) {
 		BREAK_TO_DEBUGGER();
-		dal_error("DC: failed to set minimum clock state!\n");
+		dm_error("DC: failed to set minimum clock state!\n");
 	}
 
 
@@ -1601,7 +1601,7 @@ static void enable_timing_synchronization(
 
 	/* Reset slave controllers on master VSync */
 	DC_SYNC_INFO("GSL: enabling trigger-reset\n");
-	dc_service_memset(&trigger_params, 0, sizeof(trigger_params));
+	dm_memset(&trigger_params, 0, sizeof(trigger_params));
 
 	trigger_params.edge = TRIGGER_EDGE_DEFAULT;
 	trigger_params.source = SYNC_SOURCE_GSL_GROUP0;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c
index 6cd80ae..6ab3527 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/logger_interface.h"
 
 #include "dce/dce_11_0_d.h"
@@ -60,6 +60,6 @@ bool dce110_ipp_construct(
 
 void dce110_ipp_destroy(struct input_pixel_processor **ipp)
 {
-	dc_service_free((*ipp)->ctx, TO_DCE110_IPP(*ipp));
+	dm_free((*ipp)->ctx, TO_DCE110_IPP(*ipp));
 	*ipp = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c
index 0569fbb..ef91f2d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/logger_interface.h"
 
 #include "dce/dce_11_0_d.h"
@@ -137,9 +137,9 @@ static void enable(
 	uint32_t value = 0;
 	uint32_t addr = DCP_REG(mmCUR_CONTROL);
 
-	value = dal_read_reg(ipp110->base.ctx, addr);
+	value = dm_read_reg(ipp110->base.ctx, addr);
 	set_reg_field_value(value, enable, CUR_CONTROL, CURSOR_EN);
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 static void lock(
@@ -148,9 +148,9 @@ static void lock(
 	uint32_t value = 0;
 	uint32_t addr = DCP_REG(mmCUR_UPDATE);
 
-	value = dal_read_reg(ipp110->base.ctx, addr);
+	value = dm_read_reg(ipp110->base.ctx, addr);
 	set_reg_field_value(value, lock, CUR_UPDATE, CURSOR_UPDATE_LOCK);
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 static void program_position(
@@ -161,10 +161,10 @@ static void program_position(
 	uint32_t value = 0;
 	uint32_t addr = DCP_REG(mmCUR_POSITION);
 
-	value = dal_read_reg(ipp110->base.ctx, addr);
+	value = dm_read_reg(ipp110->base.ctx, addr);
 	set_reg_field_value(value, x, CUR_POSITION, CURSOR_X_POSITION);
 	set_reg_field_value(value, y, CUR_POSITION, CURSOR_Y_POSITION);
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 static bool program_control(
@@ -199,13 +199,13 @@ static bool program_control(
 			CUR_CONTROL, CURSOR_2X_MAGNIFY);
 	set_reg_field_value(value, inverse_transparent_clamping,
 			CUR_CONTROL, CUR_INV_TRANS_CLAMP);
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 
 	if (color_format == CURSOR_MODE_MONO) {
 		addr = DCP_REG(mmCUR_COLOR1);
-		dal_write_reg(ipp110->base.ctx, addr, CURSOR_COLOR_BLACK);
+		dm_write_reg(ipp110->base.ctx, addr, CURSOR_COLOR_BLACK);
 		addr = DCP_REG(mmCUR_COLOR2);
-		dal_write_reg(ipp110->base.ctx, addr, CURSOR_COLOR_WHITE);
+		dm_write_reg(ipp110->base.ctx, addr, CURSOR_COLOR_WHITE);
 	}
 	return true;
 }
@@ -218,10 +218,10 @@ static void program_hotspot(
 	uint32_t value = 0;
 	uint32_t addr = DCP_REG(mmCUR_HOT_SPOT);
 
-	value = dal_read_reg(ipp110->base.ctx, addr);
+	value = dm_read_reg(ipp110->base.ctx, addr);
 	set_reg_field_value(value, x, CUR_HOT_SPOT, CURSOR_HOT_SPOT_X);
 	set_reg_field_value(value, y, CUR_HOT_SPOT, CURSOR_HOT_SPOT_Y);
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 static void program_size(
@@ -232,10 +232,10 @@ static void program_size(
 	uint32_t value = 0;
 	uint32_t addr = DCP_REG(mmCUR_SIZE);
 
-	value = dal_read_reg(ipp110->base.ctx, addr);
+	value = dm_read_reg(ipp110->base.ctx, addr);
 	set_reg_field_value(value, width, CUR_SIZE, CURSOR_WIDTH);
 	set_reg_field_value(value, height, CUR_SIZE, CURSOR_HEIGHT);
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 static void program_address(
@@ -248,9 +248,9 @@ static void program_address(
 	 * The correct way to program cursor surface address is to first write
 	 * to CUR_SURFACE_ADDRESS_HIGH, and then write to CUR_SURFACE_ADDRESS */
 
-	dal_write_reg(ipp110->base.ctx, addr, address.high_part);
+	dm_write_reg(ipp110->base.ctx, addr, address.high_part);
 
 	addr = DCP_REG(mmCUR_SURFACE_ADDRESS);
-	dal_write_reg(ipp110->base.ctx, addr, address.low_part);
+	dm_write_reg(ipp110->base.ctx, addr, address.low_part);
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_gamma.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_gamma.c
index a30c0da..fcf65f1 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_gamma.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_gamma.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/logger_interface.h"
 #include "include/fixed31_32.h"
 #include "basics/conversion.h"
@@ -200,7 +200,7 @@ static void set_lut_inc(
 {
 	const uint32_t addr = DCP_REG(mmDC_LUT_CONTROL);
 
-	uint32_t value = dal_read_reg(ipp110->base.ctx, addr);
+	uint32_t value = dm_read_reg(ipp110->base.ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -256,7 +256,7 @@ static void set_lut_inc(
 		DC_LUT_CONTROL,
 		DC_LUT_DATA_B_SIGNED_EN);
 
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 void dce110_helper_select_lut(struct dce110_ipp *ipp110)
@@ -268,7 +268,7 @@ void dce110_helper_select_lut(struct dce110_ipp *ipp110)
 	{
 		const uint32_t addr = DCP_REG(mmDC_LUT_WRITE_EN_MASK);
 
-		value = dal_read_reg(ipp110->base.ctx, addr);
+		value = dm_read_reg(ipp110->base.ctx, addr);
 
 		/* enable all */
 		set_reg_field_value(
@@ -277,13 +277,13 @@ void dce110_helper_select_lut(struct dce110_ipp *ipp110)
 			DC_LUT_WRITE_EN_MASK,
 			DC_LUT_WRITE_EN_MASK);
 
-		dal_write_reg(ipp110->base.ctx, addr, value);
+		dm_write_reg(ipp110->base.ctx, addr, value);
 	}
 
 	{
 		const uint32_t addr = DCP_REG(mmDC_LUT_RW_MODE);
 
-		value = dal_read_reg(ipp110->base.ctx, addr);
+		value = dm_read_reg(ipp110->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -291,13 +291,13 @@ void dce110_helper_select_lut(struct dce110_ipp *ipp110)
 			DC_LUT_RW_MODE,
 			DC_LUT_RW_MODE);
 
-		dal_write_reg(ipp110->base.ctx, addr, value);
+		dm_write_reg(ipp110->base.ctx, addr, value);
 	}
 
 	{
 		const uint32_t addr = DCP_REG(mmDC_LUT_CONTROL);
 
-		value = dal_read_reg(ipp110->base.ctx, addr);
+		value = dm_read_reg(ipp110->base.ctx, addr);
 
 		/* 00 - new u0.12 */
 		set_reg_field_value(
@@ -318,13 +318,13 @@ void dce110_helper_select_lut(struct dce110_ipp *ipp110)
 			DC_LUT_CONTROL,
 			DC_LUT_DATA_B_FORMAT);
 
-		dal_write_reg(ipp110->base.ctx, addr, value);
+		dm_write_reg(ipp110->base.ctx, addr, value);
 	}
 
 	{
 		const uint32_t addr = DCP_REG(mmDC_LUT_RW_INDEX);
 
-		value = dal_read_reg(ipp110->base.ctx, addr);
+		value = dm_read_reg(ipp110->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -332,7 +332,7 @@ void dce110_helper_select_lut(struct dce110_ipp *ipp110)
 			DC_LUT_RW_INDEX,
 			DC_LUT_RW_INDEX);
 
-		dal_write_reg(ipp110->base.ctx, addr, value);
+		dm_write_reg(ipp110->base.ctx, addr, value);
 	}
 }
 
@@ -340,13 +340,13 @@ static void program_black_offsets(
 	struct dce110_ipp *ipp110,
 	struct dev_c_lut16 *offset)
 {
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		DCP_REG(mmDC_LUT_BLACK_OFFSET_RED),
 		offset->red);
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		DCP_REG(mmDC_LUT_BLACK_OFFSET_GREEN),
 		offset->green);
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		DCP_REG(mmDC_LUT_BLACK_OFFSET_BLUE),
 		offset->blue);
 }
@@ -355,13 +355,13 @@ static void program_white_offsets(
 	struct dce110_ipp *ipp110,
 	struct dev_c_lut16 *offset)
 {
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		DCP_REG(mmDC_LUT_WHITE_OFFSET_RED),
 		offset->red);
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		DCP_REG(mmDC_LUT_WHITE_OFFSET_GREEN),
 		offset->green);
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		DCP_REG(mmDC_LUT_WHITE_OFFSET_BLUE),
 		offset->blue);
 }
@@ -441,7 +441,7 @@ static void program_lut_gamma(
 		uint8_t counter = 0;
 
 		/* Power on LUT memory */
-		value = dal_read_reg(
+		value = dm_read_reg(
 				ipp110->base.ctx, DCP_REG(mmDCFE_MEM_PWR_CTRL));
 
 		set_reg_field_value(
@@ -450,12 +450,12 @@ static void program_lut_gamma(
 			DCFE_MEM_PWR_CTRL,
 			DCP_REGAMMA_MEM_PWR_DIS);
 
-		dal_write_reg(
+		dm_write_reg(
 			ipp110->base.ctx, DCP_REG(mmDCFE_MEM_PWR_CTRL), value);
 
 		while (counter < max_tries) {
 			value =
-				dal_read_reg(
+				dm_read_reg(
 					ipp110->base.ctx,
 					DCP_REG(mmDCFE_MEM_PWR_STATUS));
 
@@ -493,7 +493,7 @@ static void program_lut_gamma(
 				gamma[index->red].red,
 				DC_LUT_SEQ_COLOR,
 				DC_LUT_SEQ_COLOR);
-			dal_write_reg(ipp110->base.ctx, addr, value);
+			dm_write_reg(ipp110->base.ctx, addr, value);
 
 
 			set_reg_field_value(
@@ -501,7 +501,7 @@ static void program_lut_gamma(
 				gamma[index->green].green,
 				DC_LUT_SEQ_COLOR,
 				DC_LUT_SEQ_COLOR);
-			dal_write_reg(ipp110->base.ctx, addr, value);
+			dm_write_reg(ipp110->base.ctx, addr, value);
 
 
 			set_reg_field_value(
@@ -509,7 +509,7 @@ static void program_lut_gamma(
 				gamma[index->blue].blue,
 				DC_LUT_SEQ_COLOR,
 				DC_LUT_SEQ_COLOR);
-			dal_write_reg(ipp110->base.ctx, addr, value);
+			dm_write_reg(ipp110->base.ctx, addr, value);
 
 			++i;
 		} while (i != RGB_256X3X16);
@@ -522,7 +522,7 @@ static void program_lut_gamma(
 				gamma[i].red,
 				DC_LUT_SEQ_COLOR,
 				DC_LUT_SEQ_COLOR);
-			dal_write_reg(ipp110->base.ctx, addr, value);
+			dm_write_reg(ipp110->base.ctx, addr, value);
 
 
 			set_reg_field_value(
@@ -530,7 +530,7 @@ static void program_lut_gamma(
 				gamma[i].green,
 				DC_LUT_SEQ_COLOR,
 				DC_LUT_SEQ_COLOR);
-			dal_write_reg(ipp110->base.ctx, addr, value);
+			dm_write_reg(ipp110->base.ctx, addr, value);
 
 
 			set_reg_field_value(
@@ -538,14 +538,14 @@ static void program_lut_gamma(
 				gamma[i].blue,
 				DC_LUT_SEQ_COLOR,
 				DC_LUT_SEQ_COLOR);
-			dal_write_reg(ipp110->base.ctx, addr, value);
+			dm_write_reg(ipp110->base.ctx, addr, value);
 
 			++i;
 		} while (i != RGB_256X3X16);
 	}
 
 	/*  we are done with DCP LUT memory; re-enable low power mode */
-	value = dal_read_reg(ipp110->base.ctx, DCP_REG(mmDCFE_MEM_PWR_CTRL));
+	value = dm_read_reg(ipp110->base.ctx, DCP_REG(mmDCFE_MEM_PWR_CTRL));
 
 	set_reg_field_value(
 		value,
@@ -553,7 +553,7 @@ static void program_lut_gamma(
 		DCFE_MEM_PWR_CTRL,
 		DCP_REGAMMA_MEM_PWR_DIS);
 
-	dal_write_reg(ipp110->base.ctx, DCP_REG(mmDCFE_MEM_PWR_CTRL), value);
+	dm_write_reg(ipp110->base.ctx, DCP_REG(mmDCFE_MEM_PWR_CTRL), value);
 }
 
 static void program_prescale(
@@ -574,7 +574,7 @@ static void program_prescale(
 
 	const uint32_t addr_control = DCP_REG(mmPRESCALE_GRPH_CONTROL);
 
-	prescale_control = dal_read_reg(ipp110->base.ctx, addr_control);
+	prescale_control = dm_read_reg(ipp110->base.ctx, addr_control);
 
 	set_reg_field_value(
 		prescale_control,
@@ -670,23 +670,23 @@ static void program_prescale(
 		PRESCALE_VALUES_GRPH_B,
 		GRPH_PRESCALE_BIAS_B);
 
-	dal_write_reg(ipp110->base.ctx,
+	dm_write_reg(ipp110->base.ctx,
 		addr_control, prescale_control);
 
 	{
-		dal_write_reg(ipp110->base.ctx,
+		dm_write_reg(ipp110->base.ctx,
 				DCP_REG(mmPRESCALE_VALUES_GRPH_R),
 				prescale_values_grph_r);
 	}
 
 	{
-		dal_write_reg(ipp110->base.ctx,
+		dm_write_reg(ipp110->base.ctx,
 				DCP_REG(mmPRESCALE_VALUES_GRPH_G),
 				prescale_values_grph_g);
 	}
 
 	{
-		dal_write_reg(ipp110->base.ctx,
+		dm_write_reg(ipp110->base.ctx,
 				DCP_REG(mmPRESCALE_VALUES_GRPH_B),
 				prescale_values_grph_b);
 	}
@@ -697,7 +697,7 @@ static void set_legacy_input_gamma_mode(
 	bool is_legacy)
 {
 	const uint32_t addr = DCP_REG(mmINPUT_GAMMA_CONTROL);
-	uint32_t value = dal_read_reg(ipp110->base.ctx, addr);
+	uint32_t value = dm_read_reg(ipp110->base.ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -705,7 +705,7 @@ static void set_legacy_input_gamma_mode(
 		INPUT_GAMMA_CONTROL,
 		GRPH_INPUT_GAMMA_MODE);
 
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
 static bool set_legacy_input_gamma_ramp_rgb256x3x16(
@@ -714,7 +714,7 @@ static bool set_legacy_input_gamma_ramp_rgb256x3x16(
 	const struct gamma_parameters *params)
 {
 	struct dev_c_lut16 *gamma16 =
-		dc_service_alloc(
+		dm_alloc(
 			ipp110->base.ctx,
 			sizeof(struct dev_c_lut16) * MAX_INPUT_LUT_ENTRY);
 
@@ -729,12 +729,12 @@ static bool set_legacy_input_gamma_ramp_rgb256x3x16(
 			PIXEL_FORMAT_ARGB2101010_XRBIAS) &&
 		(params->surface_pixel_format != PIXEL_FORMAT_FP16)) {
 		program_lut_gamma(ipp110, gamma16, params);
-		dc_service_free(ipp110->base.ctx, gamma16);
+		dm_free(ipp110->base.ctx, gamma16);
 		return true;
 	}
 
 	/* TODO process DirectX-specific formats*/
-	dc_service_free(ipp110->base.ctx, gamma16);
+	dm_free(ipp110->base.ctx, gamma16);
 	return false;
 }
 
@@ -744,7 +744,7 @@ static bool set_legacy_input_gamma_ramp_dxgi1(
 	const struct gamma_parameters *params)
 {
 	struct dev_c_lut16 *gamma16 =
-		dc_service_alloc(
+		dm_alloc(
 			ipp110->base.ctx,
 			sizeof(struct dev_c_lut16) * MAX_INPUT_LUT_ENTRY);
 
@@ -759,12 +759,12 @@ static bool set_legacy_input_gamma_ramp_dxgi1(
 			PIXEL_FORMAT_ARGB2101010_XRBIAS) &&
 		(params->surface_pixel_format != PIXEL_FORMAT_FP16)) {
 		program_lut_gamma(ipp110, gamma16, params);
-		dc_service_free(ipp110->base.ctx, gamma16);
+		dm_free(ipp110->base.ctx, gamma16);
 		return true;
 	}
 
 	/* TODO process DirectX-specific formats*/
-	dc_service_free(ipp110->base.ctx, gamma16);
+	dm_free(ipp110->base.ctx, gamma16);
 	return false;
 }
 
@@ -777,17 +777,17 @@ static bool set_default_gamma(
 	struct dev_c_lut16 *gamma16 = NULL;
 	struct gamma_parameters *params = NULL;
 
-	gamma16 = dc_service_alloc(
+	gamma16 = dm_alloc(
 			ipp110->base.ctx,
 			sizeof(struct dev_c_lut16) * MAX_INPUT_LUT_ENTRY);
 
 	if (!gamma16)
 		return false;
 
-	params = dc_service_alloc(ipp110->base.ctx, sizeof(*params));
+	params = dm_alloc(ipp110->base.ctx, sizeof(*params));
 
 	if (!params) {
-		dc_service_free(ipp110->base.ctx, gamma16);
+		dm_free(ipp110->base.ctx, gamma16);
 		return false;
 	}
 
@@ -819,8 +819,8 @@ static bool set_default_gamma(
 
 	program_lut_gamma(ipp110, gamma16, params);
 
-	dc_service_free(ipp110->base.ctx, gamma16);
-	dc_service_free(ipp110->base.ctx, params);
+	dm_free(ipp110->base.ctx, gamma16);
+	dm_free(ipp110->base.ctx, params);
 
 	return true;
 }
@@ -836,7 +836,7 @@ static void set_degamma(
 		params->regamma.features.bits.GRAPHICS_DEGAMMA_SRGB == 1 ?
 			1 : 2;
 
-	value = dal_read_reg(ipp110->base.ctx, addr);
+	value = dm_read_reg(ipp110->base.ctx, addr);
 
 	/* if by pass - no degamma
 	 * when legacy and regamma LUT's we do degamma */
@@ -867,6 +867,6 @@ static void set_degamma(
 		DEGAMMA_CONTROL,
 		CURSOR2_DEGAMMA_MODE);
 
-	dal_write_reg(ipp110->base.ctx, addr, value);
+	dm_write_reg(ipp110->base.ctx, addr, value);
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 2396f15..f714215 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -23,11 +23,12 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "core_types.h"
 #include "link_encoder.h"
 #include "stream_encoder.h"
 #include "dce110_link_encoder.h"
+
 #include "i2caux_interface.h"
 #include "dc_bios_types.h"
 
@@ -130,11 +131,11 @@ static void enable_phy_bypass_mode(
 
 	const uint32_t addr = LINK_REG(DP_DPHY_CNTL);
 
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, enable, DP_DPHY_CNTL, DPHY_BYPASS);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void disable_prbs_symbols(
@@ -147,7 +148,7 @@ static void disable_prbs_symbols(
 
 	const uint32_t addr = LINK_REG(DP_DPHY_CNTL);
 
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, disable,
 			DP_DPHY_CNTL, DPHY_ATEST_SEL_LANE0);
@@ -161,7 +162,7 @@ static void disable_prbs_symbols(
 	set_reg_field_value(value, disable,
 			DP_DPHY_CNTL, DPHY_ATEST_SEL_LANE3);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void disable_prbs_mode(
@@ -174,11 +175,11 @@ static void disable_prbs_mode(
 	const uint32_t addr = LINK_REG(DP_DPHY_PRBS_CNTL);
 	uint32_t value;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, 0, DP_DPHY_PRBS_CNTL, DPHY_PRBS_EN);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void program_pattern_symbols(
@@ -201,7 +202,7 @@ static void program_pattern_symbols(
 			DP_DPHY_SYM0, DPHY_SYM2);
 	set_reg_field_value(value, pattern_symbols[2],
 			DP_DPHY_SYM0, DPHY_SYM3);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* This register resides in DP back end block;
 	 * transmitter is used for the offset */
@@ -215,7 +216,7 @@ static void program_pattern_symbols(
 			DP_DPHY_SYM1, DPHY_SYM5);
 	set_reg_field_value(value, pattern_symbols[5],
 			DP_DPHY_SYM1, DPHY_SYM6);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* This register resides in DP back end block;
 	 * transmitter is used for the offset */
@@ -226,7 +227,7 @@ static void program_pattern_symbols(
 	set_reg_field_value(value, pattern_symbols[6],
 			DP_DPHY_SYM2, DPHY_SYM8);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void set_dp_phy_pattern_d102(
@@ -270,12 +271,12 @@ static void set_link_training_complete(
 	 * transmitter is used for the offset */
 	struct dc_context *ctx = enc110->base.ctx;
 	const uint32_t addr = LINK_REG(DP_LINK_CNTL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, complete,
 			DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void set_dp_phy_pattern_training_pattern(
@@ -286,7 +287,7 @@ static void set_dp_phy_pattern_training_pattern(
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t addr = LINK_REG(DP_DPHY_TRAINING_PATTERN_SEL);
 
-	dal_write_reg(ctx, addr, index);
+	dm_write_reg(ctx, addr, index);
 
 	/* Set HW Register Training Complete to false */
 
@@ -314,7 +315,7 @@ static void set_dp_phy_pattern_symbol_error(
 	{
 		const uint32_t addr = LINK_REG(DP_DPHY_INTERNAL_CTRL);
 		uint32_t value = 0x0;
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* A PRBS23 pattern is used for most DP electrical measurements. */
@@ -326,13 +327,13 @@ static void set_dp_phy_pattern_symbol_error(
 	/* For PRBS23 Set bit DPHY_PRBS_SEL=1 and Set bit DPHY_PRBS_EN=1 */
 	{
 		const uint32_t addr = LINK_REG(DP_DPHY_PRBS_CNTL);
-		uint32_t value = dal_read_reg(ctx, addr);
+		uint32_t value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(value, 1,
 				DP_DPHY_PRBS_CNTL, DPHY_PRBS_SEL);
 		set_reg_field_value(value, 1,
 				DP_DPHY_PRBS_CNTL, DPHY_PRBS_EN);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* Enable phy bypass mode to enable the test pattern */
@@ -358,7 +359,7 @@ static void set_dp_phy_pattern_prbs7(
 	{
 		const uint32_t addr = LINK_REG(DP_DPHY_PRBS_CNTL);
 
-		uint32_t value = dal_read_reg(ctx, addr);
+		uint32_t value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(value, 0,
 				DP_DPHY_PRBS_CNTL, DPHY_PRBS_SEL);
@@ -366,7 +367,7 @@ static void set_dp_phy_pattern_prbs7(
 		set_reg_field_value(value, 1,
 				DP_DPHY_PRBS_CNTL, DPHY_PRBS_EN);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* Enable phy bypass mode to enable the test pattern */
@@ -446,7 +447,7 @@ static void set_dp_phy_pattern_hbr2_compliance(
 	{
 		const uint32_t addr = LINK_REG(DP_DPHY_INTERNAL_CTRL);
 		uint32_t value = 0x0;
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* no vbid after BS (SR)
@@ -462,7 +463,7 @@ static void set_dp_phy_pattern_hbr2_compliance(
 	/* TODO: do we still need this, find out at compliance test
 	addr = mmDP_LINK_FRAMING_CNTL + fe_addr_offset;
 
-	value = dal_read_reg(ctx, addr);
+	value = (ctx, addr);
 
 	set_reg_field_value(value, 0xFC,
 			DP_LINK_FRAMING_CNTL, DP_IDLE_BS_INTERVAL);
@@ -483,11 +484,11 @@ static void set_dp_phy_pattern_hbr2_compliance(
 	/* do not enable video stream */
 	addr = LINK_REG(DP_VID_STREAM_CNTL);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, 0, DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* Disable PHY Bypass mode to setup the test pattern */
 
@@ -506,7 +507,7 @@ static void set_dp_phy_pattern_passthrough_mode(
 
 		uint32_t value;
 
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		switch (panel_mode) {
 		case DP_PANEL_MODE_EDP:
@@ -520,7 +521,7 @@ static void set_dp_phy_pattern_passthrough_mode(
 			break;
 		}
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* set link training complete */
@@ -570,10 +571,10 @@ static void configure_encoder(
 
 	/* set number of lanes */
 	addr = LINK_REG(DP_CONFIG);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, link_settings->lane_count - LANE_COUNT_ONE,
 			DP_CONFIG, DP_UDI_LANES);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 }
 
@@ -583,7 +584,7 @@ static bool is_panel_powered_on(struct dce110_link_encoder *enc110)
 	uint32_t value;
 	bool ret;
 
-	value = dal_read_reg(ctx,
+	value = dm_read_reg(ctx,
 			BL_REG(LVTMA_PWRSEQ_STATE));
 
 	ret = get_reg_field_value(value,
@@ -647,7 +648,7 @@ static void link_encoder_edp_wait_for_hpd_ready(
 			break;
 		}
 
-		dc_service_sleep_in_milliseconds(ctx, HPD_CHECK_INTERVAL);
+		dm_sleep_in_milliseconds(ctx, HPD_CHECK_INTERVAL);
 
 		time_elapsed += HPD_CHECK_INTERVAL;
 	} while (time_elapsed < timeout);
@@ -730,19 +731,19 @@ static void aux_initialize(
 	struct dc_context *ctx = enc110->base.ctx;
 	enum hpd_source_id hpd_source = enc110->base.hpd_source;
 	uint32_t addr = AUX_REG(AUX_CONTROL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, hpd_source, AUX_CONTROL, AUX_HPD_SEL);
 	set_reg_field_value(value, 0, AUX_CONTROL, AUX_LS_READ_EN);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = AUX_REG(AUX_DPHY_RX_CONTROL0);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	/* 1/4 window (the maximum allowed) */
 	set_reg_field_value(value, 1,
 			AUX_DPHY_RX_CONTROL0, AUX_RX_RECEIVE_WINDOW);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 }
 
@@ -752,7 +753,7 @@ static bool is_panel_backlight_on(struct dce110_link_encoder *enc110)
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t value;
 
-	value = dal_read_reg(ctx, BL_REG(LVTMA_PWRSEQ_CNTL));
+	value = dm_read_reg(ctx, BL_REG(LVTMA_PWRSEQ_CNTL));
 
 	return get_reg_field_value(value, LVTMA_PWRSEQ_CNTL, LVTMA_BLON);
 }
@@ -831,7 +832,7 @@ static bool is_dig_enabled(const struct dce110_link_encoder *enc110)
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t value;
 
-	value = dal_read_reg(ctx, LINK_REG(DIG_BE_EN_CNTL));
+	value = dm_read_reg(ctx, LINK_REG(DIG_BE_EN_CNTL));
 
 	return get_reg_field_value(value, DIG_BE_EN_CNTL, DIG_ENABLE);
 }
@@ -844,22 +845,22 @@ static void link_encoder_disable(struct dce110_link_encoder *enc110)
 
 	/* reset training pattern */
 	addr = LINK_REG(DP_DPHY_TRAINING_PATTERN_SEL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 0,
 			DP_DPHY_TRAINING_PATTERN_SEL,
 			DPHY_TRAINING_PATTERN_SEL);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* reset training complete */
 	addr = LINK_REG(DP_LINK_CNTL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 0, DP_LINK_CNTL, DP_LINK_TRAINING_COMPLETE);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* reset panel mode */
 	addr = LINK_REG(DP_DPHY_INTERNAL_CTRL);
 	value = 0;
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void hpd_initialize(
@@ -869,10 +870,10 @@ static void hpd_initialize(
 	struct dc_context *ctx = enc110->base.ctx;
 	enum hpd_source_id hpd_source = enc110->base.hpd_source;
 	const uint32_t addr = LINK_REG(DIG_BE_CNTL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, hpd_source, DIG_BE_CNTL, DIG_HPD_SELECT);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static bool validate_dvi_output(
@@ -1265,7 +1266,7 @@ void dce110_link_encoder_setup(
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 	const uint32_t addr = LINK_REG(DIG_BE_CNTL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	switch (signal) {
 	case SIGNAL_TYPE_EDP:
@@ -1296,7 +1297,7 @@ void dce110_link_encoder_setup(
 		break;
 	}
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 /* TODO: still need depth or just pass in adjusted pixel clock? */
@@ -1629,8 +1630,8 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 	 * to commit payload on both tx and rx side */
 
 	/* we should clean-up table each time */
-	value0 = dal_read_reg(ctx, LINK_REG(DP_MSE_SAT0));
-	value1 = dal_read_reg(ctx, LINK_REG(DP_MSE_SAT1));
+	value0 = dm_read_reg(ctx, LINK_REG(DP_MSE_SAT0));
+	value1 = dm_read_reg(ctx, LINK_REG(DP_MSE_SAT1));
 
 	if (table->stream_count >= 1) {
 		fill_stream_allocation_row_info(
@@ -1699,8 +1700,8 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 		DP_MSE_SAT_SLOT_COUNT2);
 
 	/* update ASIC MSE stream allocation table */
-	dal_write_reg(ctx, LINK_REG(DP_MSE_SAT0), value0);
-	dal_write_reg(ctx, LINK_REG(DP_MSE_SAT1), value1);
+	dm_write_reg(ctx, LINK_REG(DP_MSE_SAT0), value0);
+	dm_write_reg(ctx, LINK_REG(DP_MSE_SAT1), value1);
 
 	/* --- wait for transaction finish */
 
@@ -1709,7 +1710,7 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 	 * then double buffers the SAT into the hardware
 	 * making the new allocation active on the DP MST mode link */
 
-	value0 = dal_read_reg(ctx, LINK_REG(DP_MSE_SAT_UPDATE));
+	value0 = dm_read_reg(ctx, LINK_REG(DP_MSE_SAT_UPDATE));
 
 	/* DP_MSE_SAT_UPDATE:
 	 * 0 - No Action
@@ -1722,7 +1723,7 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 		DP_MSE_SAT_UPDATE,
 		DP_MSE_SAT_UPDATE);
 
-	dal_write_reg(ctx, LINK_REG(DP_MSE_SAT_UPDATE), value0);
+	dm_write_reg(ctx, LINK_REG(DP_MSE_SAT_UPDATE), value0);
 
 	/* wait for update to complete
 	 * (i.e. DP_MSE_SAT_UPDATE field is reset to 0)
@@ -1735,9 +1736,9 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 	 * after this bit is cleared */
 
 	do {
-		dc_service_delay_in_microseconds(ctx, 10);
+		dm_delay_in_microseconds(ctx, 10);
 
-		value0 = dal_read_reg(ctx,
+		value0 = dm_read_reg(ctx,
 				LINK_REG(DP_MSE_SAT_UPDATE));
 
 		value1 = get_reg_field_value(
@@ -1779,9 +1780,9 @@ void dce110_link_encoder_set_lcd_backlight_level(
 	uint8_t bit_count;
 	uint64_t active_duty_cycle;
 
-	backlight = dal_read_reg(ctx, BL_REG(BL_PWM_CNTL));
-	backlight_period = dal_read_reg(ctx, BL_REG(BL_PWM_PERIOD_CNTL));
-	backlight_lock = dal_read_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK));
+	backlight = dm_read_reg(ctx, BL_REG(BL_PWM_CNTL));
+	backlight_period = dm_read_reg(ctx, BL_REG(BL_PWM_PERIOD_CNTL));
+	backlight_lock = dm_read_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK));
 
 	/*
 	 * 1. Convert 8-bit value to 17 bit U1.16 format
@@ -1864,10 +1865,10 @@ void dce110_link_encoder_set_lcd_backlight_level(
 		1,
 		BL_PWM_GRP1_REG_LOCK,
 		BL_PWM_GRP1_REG_LOCK);
-	dal_write_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK), backlight_lock);
+	dm_write_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK), backlight_lock);
 
 	/* 3.2 Write new active duty cycle */
-	dal_write_reg(ctx, BL_REG(BL_PWM_CNTL), backlight);
+	dm_write_reg(ctx, BL_REG(BL_PWM_CNTL), backlight);
 
 	/* 3.3 Unlock group 2 backlight registers */
 	set_reg_field_value(
@@ -1875,18 +1876,18 @@ void dce110_link_encoder_set_lcd_backlight_level(
 		0,
 		BL_PWM_GRP1_REG_LOCK,
 		BL_PWM_GRP1_REG_LOCK);
-	dal_write_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK), backlight_lock);
+	dm_write_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK), backlight_lock);
 
 	/* 5.4.4 Wait for pending bit to be cleared */
 	for (i = 0; i < backlight_update_pending_max_retry; ++i) {
-		backlight_lock = dal_read_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK));
+		backlight_lock = dm_read_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK));
 		if (!get_reg_field_value(
 			backlight_lock,
 			BL_PWM_GRP1_REG_LOCK,
 			BL_PWM_GRP1_REG_UPDATE_PENDING))
 			break;
 
-		dc_service_delay_in_microseconds(ctx, 10);
+		dm_delay_in_microseconds(ctx, 10);
 	}
 }
 
@@ -1903,7 +1904,7 @@ void dce110_link_encoder_connect_dig_be_to_fe(
 
 	if (engine != ENGINE_ID_UNKNOWN) {
 		addr = LINK_REG(DIG_BE_CNTL);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		field = get_reg_field_value(
 				value,
@@ -1920,7 +1921,7 @@ void dce110_link_encoder_connect_dig_be_to_fe(
 			field,
 			DIG_BE_CNTL,
 			DIG_FE_SOURCE_SELECT);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index 5d3d0f7..3a928e6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -49,7 +49,7 @@ static void set_flip_control(
 {
 	uint32_t value = 0;
 
-	value = dal_read_reg(
+	value = dm_read_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmGRPH_FLIP_CONTROL));
 	set_reg_field_value(value, 0,
@@ -63,7 +63,7 @@ static void set_flip_control(
 			GRPH_FLIP_CONTROL,
 			GRPH_SURFACE_UPDATE_IMMEDIATE_EN);
 
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_FLIP_CONTROL),
 		value);
@@ -83,7 +83,7 @@ GRPH_SECONDARY_SURFACE_ADDRESS_HIGH__GRPH_SECONDARY_SURFACE_ADDRESS_HIGH_MASK;
 		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
 		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH);
 
-	dal_write_reg(
+	dm_write_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmGRPH_SECONDARY_SURFACE_ADDRESS_HIGH),
 			value);
@@ -97,7 +97,7 @@ GRPH_SECONDARY_SURFACE_ADDRESS_HIGH__GRPH_SECONDARY_SURFACE_ADDRESS_HIGH_MASK;
 		GRPH_SECONDARY_SURFACE_ADDRESS,
 		GRPH_SECONDARY_SURFACE_ADDRESS);
 
-	dal_write_reg(
+	dm_write_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmGRPH_SECONDARY_SURFACE_ADDRESS),
 			value);
@@ -118,7 +118,7 @@ GRPH_PRIMARY_SURFACE_ADDRESS_HIGH__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_MASK;
 		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
 		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH);
 
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_PRIMARY_SURFACE_ADDRESS_HIGH),
 		value);
@@ -132,7 +132,7 @@ GRPH_PRIMARY_SURFACE_ADDRESS_HIGH__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_MASK;
 		GRPH_PRIMARY_SURFACE_ADDRESS,
 		GRPH_PRIMARY_SURFACE_ADDRESS);
 
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_PRIMARY_SURFACE_ADDRESS),
 		value);
@@ -167,9 +167,9 @@ static void enable(struct dce110_mem_input *mem_input110)
 {
 	uint32_t value = 0;
 
-	value = dal_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_ENABLE));
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_ENABLE));
 	set_reg_field_value(value, 1, GRPH_ENABLE, GRPH_ENABLE);
-	dal_write_reg(mem_input110->base.ctx,
+	dm_write_reg(mem_input110->base.ctx,
 		DCP_REG(mmGRPH_ENABLE),
 		value);
 }
@@ -181,7 +181,7 @@ static void program_tiling(
 {
 	uint32_t value = 0;
 
-	value = dal_read_reg(
+	value = dm_read_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmGRPH_CONTROL));
 
@@ -215,7 +215,7 @@ static void program_tiling(
 	set_reg_field_value(value, 0,
 		GRPH_CONTROL, GRPH_Z);
 
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_CONTROL),
 		value);
@@ -247,7 +247,7 @@ static void program_size_and_rotation(
 
 	set_reg_field_value(value, local_size.grph.surface_size.x,
 			GRPH_X_START, GRPH_X_START);
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_X_START),
 		value);
@@ -255,7 +255,7 @@ static void program_size_and_rotation(
 	value = 0;
 	set_reg_field_value(value, local_size.grph.surface_size.y,
 			GRPH_Y_START, GRPH_Y_START);
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_Y_START),
 		value);
@@ -263,7 +263,7 @@ static void program_size_and_rotation(
 	value = 0;
 	set_reg_field_value(value, local_size.grph.surface_size.width,
 			GRPH_X_END, GRPH_X_END);
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_X_END),
 		value);
@@ -271,7 +271,7 @@ static void program_size_and_rotation(
 	value = 0;
 	set_reg_field_value(value, local_size.grph.surface_size.height,
 			GRPH_Y_END, GRPH_Y_END);
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_Y_END),
 		value);
@@ -279,7 +279,7 @@ static void program_size_and_rotation(
 	value = 0;
 	set_reg_field_value(value, local_size.grph.surface_pitch,
 			GRPH_PITCH, GRPH_PITCH);
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmGRPH_PITCH),
 		value);
@@ -304,7 +304,7 @@ static void program_size_and_rotation(
 			HW_ROTATION, GRPH_ROTATION_ANGLE);
 		break;
 	}
-	dal_write_reg(
+	dm_write_reg(
 		mem_input110->base.ctx,
 		DCP_REG(mmHW_ROTATION),
 		value);
@@ -330,13 +330,13 @@ static void program_pixel_format(
 				value, 2, GRPH_SWAP_CNTL, GRPH_BLUE_CROSSBAR);
 		}
 
-		dal_write_reg(
+		dm_write_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmGRPH_SWAP_CNTL),
 			value);
 
 
-		value =	dal_read_reg(
+		value =	dm_read_reg(
 				mem_input110->base.ctx,
 				DCP_REG(mmGRPH_CONTROL));
 
@@ -378,13 +378,13 @@ static void program_pixel_format(
 		default:
 			break;
 		}
-		dal_write_reg(
+		dm_write_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmGRPH_CONTROL),
 			value);
 
 		/*TODO [hwentlan] MOVE THIS TO CONTROLLER GAMMA!!!!!*/
-		value = dal_read_reg(
+		value = dm_read_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmPRESCALE_GRPH_CONTROL));
 
@@ -415,7 +415,7 @@ static void program_pixel_format(
 				value, 0, PRESCALE_GRPH_CONTROL,
 				GRPH_PRESCALE_B_SIGN);
 		}
-		dal_write_reg(
+		dm_write_reg(
 			mem_input110->base.ctx,
 			DCP_REG(mmPRESCALE_GRPH_CONTROL),
 			value);
@@ -428,7 +428,7 @@ static void wait_for_no_surface_update_pending(
 	uint32_t value;
 
 	do  {
-		value = dal_read_reg(mem_input110->base.ctx,
+		value = dm_read_reg(mem_input110->base.ctx,
 				DCP_REG(mmGRPH_UPDATE));
 
 	} while (get_reg_field_value(value, GRPH_UPDATE,
@@ -483,14 +483,14 @@ static void program_urgency_watermark(
 	uint32_t wm_addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
 
 	/*Write mask to enable reading/writing of watermark set A*/
-	wm_mask_cntl = dal_read_reg(ctx, wm_addr);
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
 	set_reg_field_value(wm_mask_cntl,
 			1,
 			DPG_WATERMARK_MASK_CONTROL,
 			URGENCY_WATERMARK_MASK);
-	dal_write_reg(ctx, wm_addr, wm_mask_cntl);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
 
-	urgency_cntl = dal_read_reg(ctx, urgency_addr);
+	urgency_cntl = dm_read_reg(ctx, urgency_addr);
 
 	set_reg_field_value(
 		urgency_cntl,
@@ -503,18 +503,18 @@ static void program_urgency_watermark(
 		total_dest_line_time_ns,
 		DPG_PIPE_URGENCY_CONTROL,
 		URGENCY_HIGH_WATERMARK);
-	dal_write_reg(ctx, urgency_addr, urgency_cntl);
+	dm_write_reg(ctx, urgency_addr, urgency_cntl);
 
 
 	/*Write mask to enable reading/writing of watermark set B*/
-	wm_mask_cntl = dal_read_reg(ctx, wm_addr);
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
 	set_reg_field_value(wm_mask_cntl,
 			2,
 			DPG_WATERMARK_MASK_CONTROL,
 			URGENCY_WATERMARK_MASK);
-	dal_write_reg(ctx, wm_addr, wm_mask_cntl);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
 
-	urgency_cntl = dal_read_reg(ctx, urgency_addr);
+	urgency_cntl = dm_read_reg(ctx, urgency_addr);
 
 	set_reg_field_value(urgency_cntl,
 		marks_low.b_mark,
@@ -525,7 +525,7 @@ static void program_urgency_watermark(
 		total_dest_line_time_ns,
 		DPG_PIPE_URGENCY_CONTROL,
 		URGENCY_HIGH_WATERMARK);
-	dal_write_reg(ctx, urgency_addr, urgency_cntl);
+	dm_write_reg(ctx, urgency_addr, urgency_cntl);
 }
 
 static void program_stutter_watermark(
@@ -542,14 +542,14 @@ static void program_stutter_watermark(
 
 	/*Write mask to enable reading/writing of watermark set A*/
 
-	wm_mask_cntl = dal_read_reg(ctx, wm_addr);
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
 	set_reg_field_value(wm_mask_cntl,
 		1,
 		DPG_WATERMARK_MASK_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK);
-	dal_write_reg(ctx, wm_addr, wm_mask_cntl);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
 
-	stutter_cntl = dal_read_reg(ctx, stutter_addr);
+	stutter_cntl = dm_read_reg(ctx, stutter_addr);
 
 	set_reg_field_value(stutter_cntl,
 		1,
@@ -565,17 +565,17 @@ static void program_stutter_watermark(
 		marks.a_mark,
 		DPG_PIPE_STUTTER_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK);
-	dal_write_reg(ctx, stutter_addr, stutter_cntl);
+	dm_write_reg(ctx, stutter_addr, stutter_cntl);
 
 	/*Write mask to enable reading/writing of watermark set B*/
-	wm_mask_cntl = dal_read_reg(ctx, wm_addr);
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
 	set_reg_field_value(wm_mask_cntl,
 		2,
 		DPG_WATERMARK_MASK_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK);
-	dal_write_reg(ctx, wm_addr, wm_mask_cntl);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
 
-	stutter_cntl = dal_read_reg(ctx, stutter_addr);
+	stutter_cntl = dm_read_reg(ctx, stutter_addr);
 	set_reg_field_value(stutter_cntl,
 		1,
 		DPG_PIPE_STUTTER_CONTROL,
@@ -590,7 +590,7 @@ static void program_stutter_watermark(
 		marks.b_mark,
 		DPG_PIPE_STUTTER_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK);
-	dal_write_reg(ctx, stutter_addr, stutter_cntl);
+	dm_write_reg(ctx, stutter_addr, stutter_cntl);
 }
 
 static void program_nbp_watermark(
@@ -602,16 +602,16 @@ static void program_nbp_watermark(
 	uint32_t addr;
 	/* Write mask to enable reading/writing of watermark set A */
 	addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
 		DPG_WATERMARK_MASK_CONTROL,
 		NB_PSTATE_CHANGE_WATERMARK_MASK);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = offset + mmDPG_PIPE_NB_PSTATE_CHANGE_CONTROL;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
@@ -627,29 +627,29 @@ static void program_nbp_watermark(
 		1,
 		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
 		NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* Write watermark set A */
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		marks.a_mark,
 		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
 		NB_PSTATE_CHANGE_WATERMARK);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* Write mask to enable reading/writing of watermark set B */
 	addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		2,
 		DPG_WATERMARK_MASK_CONTROL,
 		NB_PSTATE_CHANGE_WATERMARK_MASK);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = offset + mmDPG_PIPE_NB_PSTATE_CHANGE_CONTROL;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
@@ -665,16 +665,16 @@ static void program_nbp_watermark(
 		1,
 		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
 		NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* Write watermark set B */
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		marks.b_mark,
 		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
 		NB_PSTATE_CHANGE_WATERMARK);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_mem_input_program_safe_display_marks(struct mem_input *mi)
@@ -779,7 +779,7 @@ void dce110_mem_input_allocate_dmif_buffer(
 		goto register_underflow_int;
 
 	/*Allocate DMIF buffer*/
-	value = dal_read_reg(mi->ctx, addr);
+	value = dm_read_reg(mi->ctx, addr);
 	field = get_reg_field_value(
 		value, PIPE0_DMIF_BUFFER_CONTROL, DMIF_BUFFERS_ALLOCATED);
 	if (field == 2)
@@ -791,10 +791,10 @@ void dce110_mem_input_allocate_dmif_buffer(
 			PIPE0_DMIF_BUFFER_CONTROL,
 			DMIF_BUFFERS_ALLOCATED);
 
-	dal_write_reg(mi->ctx, addr, value);
+	dm_write_reg(mi->ctx, addr, value);
 
 	do {
-		value = dal_read_reg(mi->ctx, addr);
+		value = dm_read_reg(mi->ctx, addr);
 		field = get_reg_field_value(
 			value,
 			PIPE0_DMIF_BUFFER_CONTROL,
@@ -803,7 +803,7 @@ void dce110_mem_input_allocate_dmif_buffer(
 		if (field)
 			break;
 
-		dc_service_delay_in_microseconds(mi->ctx, retry_delay);
+		dm_delay_in_microseconds(mi->ctx, retry_delay);
 		retry_count--;
 
 	} while (retry_count > 0);
@@ -818,7 +818,7 @@ void dce110_mem_input_allocate_dmif_buffer(
 
 	if (timing->pix_clk_khz != 0) {
 		addr = mmDPG_PIPE_ARBITRATION_CONTROL1 + bm110->offsets.dmif;
-		value = dal_read_reg(mi->ctx, addr);
+		value = dm_read_reg(mi->ctx, addr);
 		pix_dur = 1000000000ULL / timing->pix_clk_khz;
 
 		set_reg_field_value(
@@ -827,7 +827,7 @@ void dce110_mem_input_allocate_dmif_buffer(
 			DPG_PIPE_ARBITRATION_CONTROL1,
 			PIXEL_DURATION);
 
-		dal_write_reg(mi->ctx, addr, value);
+		dm_write_reg(mi->ctx, addr, value);
 	}
 
 	/*
@@ -841,13 +841,13 @@ void dce110_mem_input_allocate_dmif_buffer(
 	 */
 	if (!IS_FPGA_MAXIMUS_DC(mi->ctx->dce_environment)) {
 		addr = mmMC_HUB_RDREQ_DMIF_LIMIT;
-		value = dal_read_reg(mi->ctx, addr);
+		value = dm_read_reg(mi->ctx, addr);
 
 		if (paths_num > 1)
 			set_reg_field_value(value, 0, MC_HUB_RDREQ_DMIF_LIMIT, ENABLE);
 		else
 			set_reg_field_value(value, 3, MC_HUB_RDREQ_DMIF_LIMIT, ENABLE);
-		dal_write_reg(mi->ctx, addr, value);
+		dm_write_reg(mi->ctx, addr, value);
 	}
 
 register_underflow_int:
@@ -861,7 +861,7 @@ static void deallocate_dmif_buffer_helper(
 	uint32_t value;
 	uint32_t count = 0xBB8; /* max retry count */
 
-	value = dal_read_reg(ctx, mmPIPE0_DMIF_BUFFER_CONTROL + offset);
+	value = dm_read_reg(ctx, mmPIPE0_DMIF_BUFFER_CONTROL + offset);
 
 	if (!get_reg_field_value(
 		value, PIPE0_DMIF_BUFFER_CONTROL, DMIF_BUFFERS_ALLOCATED))
@@ -870,12 +870,12 @@ static void deallocate_dmif_buffer_helper(
 	set_reg_field_value(
 		value, 0, PIPE0_DMIF_BUFFER_CONTROL, DMIF_BUFFERS_ALLOCATED);
 
-	dal_write_reg(
+	dm_write_reg(
 		ctx, mmPIPE0_DMIF_BUFFER_CONTROL + offset, value);
 
 	do {
-		value = dal_read_reg(ctx, mmPIPE0_DMIF_BUFFER_CONTROL + offset);
-		dc_service_delay_in_microseconds(ctx, 10);
+		value = dm_read_reg(ctx, mmPIPE0_DMIF_BUFFER_CONTROL + offset);
+		dm_delay_in_microseconds(ctx, 10);
 		count--;
 	} while (count > 0 &&
 		!get_reg_field_value(
@@ -910,13 +910,13 @@ void dce110_mem_input_deallocate_dmif_buffer(
 	 * 03 - force enable dmif rdreq limit, ignore dmif stall/urgent
 	 * Stella Wong proposed this change. */
 	if (!IS_FPGA_MAXIMUS_DC(mi->ctx->dce_environment)) {
-		value = dal_read_reg(mi->ctx, mmMC_HUB_RDREQ_DMIF_LIMIT);
+		value = dm_read_reg(mi->ctx, mmMC_HUB_RDREQ_DMIF_LIMIT);
 		if (paths_num > 1)
 			set_reg_field_value(value, 0, MC_HUB_RDREQ_DMIF_LIMIT, ENABLE);
 		else
 			set_reg_field_value(value, 3, MC_HUB_RDREQ_DMIF_LIMIT, ENABLE);
 
-		dal_write_reg(mi->ctx, mmMC_HUB_RDREQ_DMIF_LIMIT, value);
+		dm_write_reg(mi->ctx, mmMC_HUB_RDREQ_DMIF_LIMIT, value);
 	}
 }
 
@@ -960,6 +960,6 @@ bool dce110_mem_input_construct(
 
 void dce110_mem_input_destroy(struct mem_input **mem_input)
 {
-	dc_service_free((*mem_input)->ctx, TO_DCE110_MEM_INPUT(*mem_input));
+	dm_free((*mem_input)->ctx, TO_DCE110_MEM_INPUT(*mem_input));
 	*mem_input = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c
index 7dcfd2e..acb405e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c
@@ -23,13 +23,14 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 
 #include "dce110_opp.h"
+
 #include "gamma_types.h"
 
 enum {
@@ -129,70 +130,70 @@ bool dce110_opp_construct(struct dce110_opp *opp110,
 	opp110->regamma.divider2 = dal_fixed31_32_from_int(2);
 	opp110->regamma.divider3 = dal_fixed31_32_from_fraction(5, 2);
 
-	opp110->regamma.rgb_user = dc_service_alloc(
+	opp110->regamma.rgb_user = dm_alloc(
 		ctx,
 		sizeof(struct pwl_float_data) *
 		(DX_GAMMA_RAMP_MAX + opp110->regamma.extra_points));
 	if (!opp110->regamma.rgb_user)
 		goto failure_1;
 
-	opp110->regamma.rgb_oem = dc_service_alloc(
+	opp110->regamma.rgb_oem = dm_alloc(
 		ctx,
 		sizeof(struct pwl_float_data) *
 		(DX_GAMMA_RAMP_MAX + opp110->regamma.extra_points));
 	if (!opp110->regamma.rgb_oem)
 		goto failure_2;
 
-	opp110->regamma.rgb_resulted = dc_service_alloc(
+	opp110->regamma.rgb_resulted = dm_alloc(
 		ctx,
 		sizeof(struct pwl_result_data) *
 		(MAX_NUMBER_OF_ENTRIES + opp110->regamma.extra_points));
 	if (!opp110->regamma.rgb_resulted)
 		goto failure_3;
 
-	opp110->regamma.rgb_regamma = dc_service_alloc(
+	opp110->regamma.rgb_regamma = dm_alloc(
 		ctx,
 		sizeof(struct pwl_float_data_ex) *
 		(MAX_NUMBER_OF_ENTRIES + opp110->regamma.extra_points));
 	if (!opp110->regamma.rgb_regamma)
 		goto failure_4;
 
-	opp110->regamma.coordinates_x = dc_service_alloc(
+	opp110->regamma.coordinates_x = dm_alloc(
 		ctx,
 		sizeof(struct hw_x_point) *
 		(MAX_NUMBER_OF_ENTRIES + opp110->regamma.extra_points));
 	if (!opp110->regamma.coordinates_x)
 		goto failure_5;
 
-	opp110->regamma.axis_x_256 = dc_service_alloc(
+	opp110->regamma.axis_x_256 = dm_alloc(
 		ctx,
 		sizeof(struct gamma_pixel) *
 		(MAX_LUT_ENTRY + opp110->regamma.extra_points));
 	if (!opp110->regamma.axis_x_256)
 		goto failure_6;
 
-	opp110->regamma.axis_x_1025 = dc_service_alloc(
+	opp110->regamma.axis_x_1025 = dm_alloc(
 		ctx,
 		sizeof(struct gamma_pixel) *
 		(DX_GAMMA_RAMP_MAX + opp110->regamma.extra_points));
 	if (!opp110->regamma.axis_x_1025)
 		goto failure_7;
 
-	opp110->regamma.coeff128 = dc_service_alloc(
+	opp110->regamma.coeff128 = dm_alloc(
 		ctx,
 		sizeof(struct pixel_gamma_point) *
 		(MAX_NUMBER_OF_ENTRIES + opp110->regamma.extra_points));
 	if (!opp110->regamma.coeff128)
 		goto failure_8;
 
-	opp110->regamma.coeff128_oem = dc_service_alloc(
+	opp110->regamma.coeff128_oem = dm_alloc(
 		ctx,
 		sizeof(struct pixel_gamma_point) *
 		(MAX_NUMBER_OF_ENTRIES + opp110->regamma.extra_points));
 	if (!opp110->regamma.coeff128_oem)
 		goto failure_9;
 
-	opp110->regamma.coeff128_dx = dc_service_alloc(
+	opp110->regamma.coeff128_dx = dm_alloc(
 		ctx,
 		sizeof(struct pixel_gamma_point) *
 		(MAX_NUMBER_OF_ENTRIES + opp110->regamma.extra_points));
@@ -231,23 +232,23 @@ bool dce110_opp_construct(struct dce110_opp *opp110,
 	return true;
 
 failure_10:
-	dc_service_free(ctx, opp110->regamma.coeff128_oem);
+	dm_free(ctx, opp110->regamma.coeff128_oem);
 failure_9:
-	dc_service_free(ctx, opp110->regamma.coeff128);
+	dm_free(ctx, opp110->regamma.coeff128);
 failure_8:
-	dc_service_free(ctx, opp110->regamma.axis_x_1025);
+	dm_free(ctx, opp110->regamma.axis_x_1025);
 failure_7:
-	dc_service_free(ctx, opp110->regamma.axis_x_256);
+	dm_free(ctx, opp110->regamma.axis_x_256);
 failure_6:
-	dc_service_free(ctx, opp110->regamma.coordinates_x);
+	dm_free(ctx, opp110->regamma.coordinates_x);
 failure_5:
-	dc_service_free(ctx, opp110->regamma.rgb_regamma);
+	dm_free(ctx, opp110->regamma.rgb_regamma);
 failure_4:
-	dc_service_free(ctx, opp110->regamma.rgb_resulted);
+	dm_free(ctx, opp110->regamma.rgb_resulted);
 failure_3:
-	dc_service_free(ctx, opp110->regamma.rgb_oem);
+	dm_free(ctx, opp110->regamma.rgb_oem);
 failure_2:
-	dc_service_free(ctx, opp110->regamma.rgb_user);
+	dm_free(ctx, opp110->regamma.rgb_user);
 failure_1:
 
 	return true;
@@ -255,17 +256,17 @@ failure_1:
 
 void dce110_opp_destroy(struct output_pixel_processor **opp)
 {
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_dx);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_oem);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_1025);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_256);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coordinates_x);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_regamma);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_resulted);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_oem);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_user);
-	dc_service_free((*opp)->ctx, FROM_DCE11_OPP(*opp));
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_dx);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_oem);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_1025);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_256);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coordinates_x);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_regamma);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_resulted);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_oem);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_user);
+	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp));
 	*opp = NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
index a96a72a..8f651e9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dce110_opp.h"
 #include "basics/conversion.h"
 
@@ -91,7 +91,7 @@ static void program_color_matrix(
 			OUTPUT_CSC_C11_C12,
 			OUTPUT_CSC_C12);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		uint32_t value = 0;
@@ -109,7 +109,7 @@ static void program_color_matrix(
 			OUTPUT_CSC_C13_C14,
 			OUTPUT_CSC_C14);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		uint32_t value = 0;
@@ -127,7 +127,7 @@ static void program_color_matrix(
 			OUTPUT_CSC_C21_C22,
 			OUTPUT_CSC_C22);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		uint32_t value = 0;
@@ -145,7 +145,7 @@ static void program_color_matrix(
 			OUTPUT_CSC_C23_C24,
 			OUTPUT_CSC_C24);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		uint32_t value = 0;
@@ -163,7 +163,7 @@ static void program_color_matrix(
 			OUTPUT_CSC_C31_C32,
 			OUTPUT_CSC_C32);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		uint32_t value = 0;
@@ -181,7 +181,7 @@ static void program_color_matrix(
 			OUTPUT_CSC_C33_C34,
 			OUTPUT_CSC_C34);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 }
 
@@ -598,7 +598,7 @@ static void set_rgb_limited_range_adjustment(
 
 	calculate_adjustments(ideals, &adjustments, matrix);
 
-	dc_service_memmove(change_matrix, matrix, sizeof(matrix));
+	dm_memmove(change_matrix, matrix, sizeof(matrix));
 
 	/* from 1 -> 3 */
 	matrix[8] = change_matrix[0];
@@ -618,7 +618,7 @@ static void set_rgb_limited_range_adjustment(
 	matrix[6] = change_matrix[10];
 	matrix[7] = change_matrix[11];
 
-	dc_service_memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
+	dm_memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
 
 	setup_reg_format(matrix, reg_matrix.regval);
 
@@ -692,7 +692,7 @@ static void set_yuv_adjustment(
 		calculate_adjustments(
 			ideals, &adjustments, matrix);
 
-	dc_service_memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
+	dm_memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
 
 	setup_reg_format(matrix, reg_matrix.regval);
 
@@ -707,7 +707,7 @@ static bool configure_graphics_mode(
 {
 	struct dc_context *ctx = opp110->base.ctx;
 	uint32_t addr = DCP_REG(mmOUTPUT_CSC_CONTROL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -816,7 +816,7 @@ static bool configure_graphics_mode(
 			OUTPUT_CSC_GRPH_MODE);
 
 	addr = DCP_REG(mmOUTPUT_CSC_CONTROL);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c
index 0224ade..235b92e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -47,7 +47,7 @@ static void set_truncation(
 	uint32_t addr = FMT_REG(mmFMT_BIT_DEPTH_CONTROL);
 
 	/*Disable truncation*/
-	value = dal_read_reg(opp110->base.ctx, addr);
+	value = dm_read_reg(opp110->base.ctx, addr);
 	set_reg_field_value(value, 0,
 		FMT_BIT_DEPTH_CONTROL, FMT_TRUNCATE_EN);
 	set_reg_field_value(value, 0,
@@ -55,7 +55,7 @@ static void set_truncation(
 	set_reg_field_value(value, 0,
 		FMT_BIT_DEPTH_CONTROL, FMT_TRUNCATE_MODE);
 
-	dal_write_reg(opp110->base.ctx, addr, value);
+	dm_write_reg(opp110->base.ctx, addr, value);
 
 	/* no 10bpc trunc on DCE11*/
 	if (params->flags.TRUNCATE_ENABLED == 0 ||
@@ -70,7 +70,7 @@ static void set_truncation(
 	set_reg_field_value(value, params->flags.TRUNCATE_DEPTH,
 		FMT_BIT_DEPTH_CONTROL, FMT_TRUNCATE_DEPTH);
 
-	dal_write_reg(opp110->base.ctx, addr, value);
+	dm_write_reg(opp110->base.ctx, addr, value);
 
 }
 
@@ -101,7 +101,7 @@ static void set_spatial_dither(
 	uint32_t dither_b_value = 0;
 
 	/*Disable spatial (random) dithering*/
-	depth_cntl_value = dal_read_reg(opp110->base.ctx, addr);
+	depth_cntl_value = dm_read_reg(opp110->base.ctx, addr);
 	set_reg_field_value(depth_cntl_value, 0,
 		FMT_BIT_DEPTH_CONTROL, FMT_SPATIAL_DITHER_EN);
 	set_reg_field_value(depth_cntl_value, 0,
@@ -117,7 +117,7 @@ static void set_spatial_dither(
 	set_reg_field_value(depth_cntl_value, 0,
 		FMT_BIT_DEPTH_CONTROL, FMT_RGB_RANDOM_ENABLE);
 
-	dal_write_reg(opp110->base.ctx, addr, depth_cntl_value);
+	dm_write_reg(opp110->base.ctx, addr, depth_cntl_value);
 
 	/* no 10bpc on DCE11*/
 	if (params->flags.SPATIAL_DITHER_ENABLED == 0 ||
@@ -125,7 +125,7 @@ static void set_spatial_dither(
 		return;
 
 	addr = FMT_REG(mmFMT_CONTROL);
-	fmt_cntl_value = dal_read_reg(opp110->base.ctx, addr);
+	fmt_cntl_value = dm_read_reg(opp110->base.ctx, addr);
 	/* only use FRAME_COUNTER_MAX if frameRandom == 1*/
 	if (params->flags.FRAME_RANDOM == 1) {
 		if (params->flags.SPATIAL_DITHER_DEPTH == 0 ||
@@ -154,7 +154,7 @@ static void set_spatial_dither(
 			FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP);
 	}
 
-	dal_write_reg(opp110->base.ctx, addr, fmt_cntl_value);
+	dm_write_reg(opp110->base.ctx, addr, fmt_cntl_value);
 
 	/*Set seed for random values for
 	 * spatial dithering for R,G,B channels*/
@@ -162,20 +162,20 @@ static void set_spatial_dither(
 	set_reg_field_value(dither_r_value, params->r_seed_value,
 		FMT_DITHER_RAND_R_SEED,
 		FMT_RAND_R_SEED);
-	dal_write_reg(opp110->base.ctx, addr, dither_r_value);
+	dm_write_reg(opp110->base.ctx, addr, dither_r_value);
 
 	addr = FMT_REG(mmFMT_DITHER_RAND_G_SEED);
 	set_reg_field_value(dither_g_value,
 		params->g_seed_value,
 		FMT_DITHER_RAND_G_SEED,
 		FMT_RAND_G_SEED);
-	dal_write_reg(opp110->base.ctx, addr, dither_g_value);
+	dm_write_reg(opp110->base.ctx, addr, dither_g_value);
 
 	addr = FMT_REG(mmFMT_DITHER_RAND_B_SEED);
 	set_reg_field_value(dither_b_value, params->b_seed_value,
 		FMT_DITHER_RAND_B_SEED,
 		FMT_RAND_B_SEED);
-	dal_write_reg(opp110->base.ctx, addr, dither_b_value);
+	dm_write_reg(opp110->base.ctx, addr, dither_b_value);
 
 	/* FMT_OFFSET_R_Cr  31:16 0x0 Setting the zero
 	 * offset for the R/Cr channel, lower 4LSB
@@ -232,7 +232,7 @@ static void set_spatial_dither(
 		FMT_SPATIAL_DITHER_EN);
 
 	addr = FMT_REG(mmFMT_BIT_DEPTH_CONTROL);
-	dal_write_reg(opp110->base.ctx, addr, depth_cntl_value);
+	dm_write_reg(opp110->base.ctx, addr, depth_cntl_value);
 
 }
 
@@ -254,7 +254,7 @@ static void set_temporal_dither(
 	uint32_t value;
 
 	/*Disable temporal (frame modulation) dithering first*/
-	value = dal_read_reg(opp110->base.ctx, addr);
+	value = dm_read_reg(opp110->base.ctx, addr);
 
 	set_reg_field_value(value,
 		0,
@@ -292,7 +292,7 @@ static void set_temporal_dither(
 		FMT_BIT_DEPTH_CONTROL,
 		FMT_75FRC_SEL);
 
-	dal_write_reg(opp110->base.ctx, addr, value);
+	dm_write_reg(opp110->base.ctx, addr, value);
 
 	/* no 10bpc dither on DCE11*/
 	if (params->flags.FRAME_MODULATION_ENABLED == 0 ||
@@ -317,15 +317,15 @@ static void set_temporal_dither(
 
 	/*Select legacy pattern based on FRC and Temporal level*/
 	addr = FMT_REG(mmFMT_TEMPORAL_DITHER_PATTERN_CONTROL);
-	dal_write_reg(opp110->base.ctx, addr, 0);
+	dm_write_reg(opp110->base.ctx, addr, 0);
 	/*Set s matrix*/
 	addr = FMT_REG(
 		mmFMT_TEMPORAL_DITHER_PROGRAMMABLE_PATTERN_S_MATRIX);
-	dal_write_reg(opp110->base.ctx, addr, 0);
+	dm_write_reg(opp110->base.ctx, addr, 0);
 	/*Set t matrix*/
 	addr = FMT_REG(
 		mmFMT_TEMPORAL_DITHER_PROGRAMMABLE_PATTERN_T_MATRIX);
-	dal_write_reg(opp110->base.ctx, addr, 0);
+	dm_write_reg(opp110->base.ctx, addr, 0);
 
 	/*Select patterns for 0.25, 0.5 and 0.75 grey level*/
 	set_reg_field_value(value,
@@ -355,7 +355,7 @@ static void set_temporal_dither(
 		FMT_TEMPORAL_DITHER_EN);
 
 	addr = FMT_REG(mmFMT_BIT_DEPTH_CONTROL);
-	dal_write_reg(opp110->base.ctx, addr, value);
+	dm_write_reg(opp110->base.ctx, addr, value);
 
 }
 
@@ -378,7 +378,7 @@ static void set_clamping(
 	uint32_t blue_clamp_value = 0;
 	uint32_t addr = FMT_REG(mmFMT_CLAMP_CNTL);
 
-	clamp_cntl_value = dal_read_reg(opp110->base.ctx, addr);
+	clamp_cntl_value = dm_read_reg(opp110->base.ctx, addr);
 
 	set_reg_field_value(clamp_cntl_value,
 		0,
@@ -454,7 +454,7 @@ static void set_clamping(
 			FMT_CLAMP_UPPER_R);
 
 		addr = FMT_REG(mmFMT_CLAMP_COMPONENT_R);
-		dal_write_reg(opp110->base.ctx, addr, red_clamp_value);
+		dm_write_reg(opp110->base.ctx, addr, red_clamp_value);
 
 		set_reg_field_value(green_clamp_value,
 			0x10,
@@ -467,7 +467,7 @@ static void set_clamping(
 			FMT_CLAMP_UPPER_G);
 
 		addr = FMT_REG(mmFMT_CLAMP_COMPONENT_G);
-		dal_write_reg(opp110->base.ctx, addr, green_clamp_value);
+		dm_write_reg(opp110->base.ctx, addr, green_clamp_value);
 
 		set_reg_field_value(blue_clamp_value,
 			0x10,
@@ -480,7 +480,7 @@ static void set_clamping(
 			FMT_CLAMP_UPPER_B);
 
 		addr = FMT_REG(mmFMT_CLAMP_COMPONENT_B);
-		dal_write_reg(opp110->base.ctx, addr, blue_clamp_value);
+		dm_write_reg(opp110->base.ctx, addr, blue_clamp_value);
 
 		break;
 
@@ -490,7 +490,7 @@ static void set_clamping(
 
 	addr = FMT_REG(mmFMT_CLAMP_CNTL);
 	/*Set clamp control*/
-	dal_write_reg(opp110->base.ctx, addr, clamp_cntl_value);
+	dm_write_reg(opp110->base.ctx, addr, clamp_cntl_value);
 
 }
 
@@ -509,7 +509,7 @@ static void set_pixel_encoding(
 	uint32_t addr = FMT_REG(mmFMT_CONTROL);
 
 	/*RGB 4:4:4 or YCbCr 4:4:4 - 0; YCbCr 4:2:2 -1.*/
-	fmt_cntl_value = dal_read_reg(opp110->base.ctx, addr);
+	fmt_cntl_value = dm_read_reg(opp110->base.ctx, addr);
 
 	set_reg_field_value(fmt_cntl_value,
 		0,
@@ -534,7 +534,7 @@ static void set_pixel_encoding(
 			FMT_CONTROL,
 			FMT_SUBSAMPLING_ORDER);
 	}
-	dal_write_reg(opp110->base.ctx, addr, fmt_cntl_value);
+	dm_write_reg(opp110->base.ctx, addr, fmt_cntl_value);
 
 }
 
@@ -570,7 +570,7 @@ void dce110_opp_set_dyn_expansion(
 	bool enable_dyn_exp = false;
 	uint32_t addr = FMT_REG(mmFMT_DYNAMIC_EXP_CNTL);
 
-	value = dal_read_reg(opp->ctx, addr);
+	value = dm_read_reg(opp->ctx, addr);
 
 	set_reg_field_value(value, 0,
 		FMT_DYNAMIC_EXP_CNTL, FMT_DYNAMIC_EXP_EN);
@@ -606,5 +606,5 @@ void dce110_opp_set_dyn_expansion(
 		}
 	}
 
-	dal_write_reg(opp->ctx, addr, value);
+	dm_write_reg(opp->ctx, addr, value);
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c
index f589025..32cf57d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -1797,7 +1797,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_START_CNTL,
 			REGAMMA_CNTLA_EXP_REGION_START_SEGMENT);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 				DCP_REG(mmREGAMMA_CNTLA_START_CNTL),
 				value);
 	}
@@ -1809,7 +1809,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_SLOPE_CNTL,
 			REGAMMA_CNTLA_EXP_REGION_LINEAR_SLOPE);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_SLOPE_CNTL), value);
 	}
 	{
@@ -1820,7 +1820,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_END_CNTL1,
 			REGAMMA_CNTLA_EXP_REGION_END);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_END_CNTL1), value);
 	}
 	{
@@ -1837,7 +1837,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_END_CNTL2,
 			REGAMMA_CNTLA_EXP_REGION_END_SLOPE);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_END_CNTL2), value);
 	}
 
@@ -1869,7 +1869,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_0_1,
 			REGAMMA_CNTLA_EXP_REGION1_NUM_SEGMENTS);
 
-		dal_write_reg(
+		dm_write_reg(
 			opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_0_1),
 			value);
@@ -1902,7 +1902,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_2_3,
 			REGAMMA_CNTLA_EXP_REGION3_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_2_3),
 			value);
 	}
@@ -1934,7 +1934,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_4_5,
 			REGAMMA_CNTLA_EXP_REGION5_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_4_5),
 			value);
 	}
@@ -1966,7 +1966,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_6_7,
 			REGAMMA_CNTLA_EXP_REGION7_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_6_7),
 			value);
 	}
@@ -1998,7 +1998,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_8_9,
 			REGAMMA_CNTLA_EXP_REGION9_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_8_9),
 			value);
 	}
@@ -2030,7 +2030,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_10_11,
 			REGAMMA_CNTLA_EXP_REGION11_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_10_11),
 			value);
 	}
@@ -2062,7 +2062,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_12_13,
 			REGAMMA_CNTLA_EXP_REGION13_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_12_13),
 			value);
 	}
@@ -2094,7 +2094,7 @@ static void regamma_config_regions_and_segments(
 			REGAMMA_CNTLA_REGION_14_15,
 			REGAMMA_CNTLA_EXP_REGION15_NUM_SEGMENTS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 			DCP_REG(mmREGAMMA_CNTLA_REGION_14_15),
 			value);
 	}
@@ -2111,7 +2111,7 @@ static void program_pwl(
 		uint8_t counter = 0;
 
 		/* Power on LUT memory */
-		value = dal_read_reg(opp110->base.ctx,
+		value = dm_read_reg(opp110->base.ctx,
 				DCFE_REG(mmDCFE_MEM_PWR_CTRL));
 
 		set_reg_field_value(
@@ -2120,12 +2120,12 @@ static void program_pwl(
 			DCFE_MEM_PWR_CTRL,
 			DCP_REGAMMA_MEM_PWR_DIS);
 
-		dal_write_reg(opp110->base.ctx,
+		dm_write_reg(opp110->base.ctx,
 				DCFE_REG(mmDCFE_MEM_PWR_CTRL), value);
 
 		while (counter < max_tries) {
 			value =
-				dal_read_reg(
+				dm_read_reg(
 					opp110->base.ctx,
 					DCFE_REG(mmDCFE_MEM_PWR_STATUS));
 
@@ -2157,9 +2157,9 @@ static void program_pwl(
 		REGAMMA_LUT_WRITE_EN_MASK,
 		REGAMMA_LUT_WRITE_EN_MASK);
 
-	dal_write_reg(opp110->base.ctx,
+	dm_write_reg(opp110->base.ctx,
 		DCP_REG(mmREGAMMA_LUT_WRITE_EN_MASK), value);
-	dal_write_reg(opp110->base.ctx,
+	dm_write_reg(opp110->base.ctx,
 		DCP_REG(mmREGAMMA_LUT_INDEX), 0);
 
 	/* Program REGAMMA_LUT_DATA */
@@ -2172,15 +2172,15 @@ static void program_pwl(
 				opp110->regamma.rgb_resulted;
 
 		while (i != opp110->regamma.hw_points_num) {
-			dal_write_reg(opp110->base.ctx, addr, rgb->red_reg);
-			dal_write_reg(opp110->base.ctx, addr, rgb->green_reg);
-			dal_write_reg(opp110->base.ctx, addr, rgb->blue_reg);
+			dm_write_reg(opp110->base.ctx, addr, rgb->red_reg);
+			dm_write_reg(opp110->base.ctx, addr, rgb->green_reg);
+			dm_write_reg(opp110->base.ctx, addr, rgb->blue_reg);
 
-			dal_write_reg(opp110->base.ctx, addr,
+			dm_write_reg(opp110->base.ctx, addr,
 				rgb->delta_red_reg);
-			dal_write_reg(opp110->base.ctx, addr,
+			dm_write_reg(opp110->base.ctx, addr,
 				rgb->delta_green_reg);
-			dal_write_reg(opp110->base.ctx, addr,
+			dm_write_reg(opp110->base.ctx, addr,
 				rgb->delta_blue_reg);
 
 			++rgb;
@@ -2189,7 +2189,7 @@ static void program_pwl(
 	}
 
 	/*  we are done with DCP LUT memory; re-enable low power mode */
-	value = dal_read_reg(opp110->base.ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL));
+	value = dm_read_reg(opp110->base.ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL));
 
 	set_reg_field_value(
 		value,
@@ -2197,7 +2197,7 @@ static void program_pwl(
 		DCFE_MEM_PWR_CTRL,
 		DCP_REGAMMA_MEM_PWR_DIS);
 
-	dal_write_reg(opp110->base.ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL), value);
+	dm_write_reg(opp110->base.ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL), value);
 }
 
 void dce110_opp_power_on_regamma_lut(
@@ -2207,7 +2207,7 @@ void dce110_opp_power_on_regamma_lut(
 	struct dce110_opp *opp110 = TO_DCE110_OPP(opp);
 
 	uint32_t value =
-		dal_read_reg(opp->ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL));
+		dm_read_reg(opp->ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL));
 
 	set_reg_field_value(
 		value,
@@ -2221,7 +2221,7 @@ void dce110_opp_power_on_regamma_lut(
 		DCFE_MEM_PWR_CTRL,
 		DCP_LUT_MEM_PWR_DIS);
 
-	dal_write_reg(opp->ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL), value);
+	dm_write_reg(opp->ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL), value);
 }
 
 static bool scale_gamma(
@@ -2328,7 +2328,7 @@ static void configure_regamma_mode(
 	enum wide_gamut_regamma_mode mode =
 		WIDE_GAMUT_REGAMMA_MODE_GRAPHICS_MATRIX_A;
 
-	uint32_t value = dal_read_reg(opp110->base.ctx, addr);
+	uint32_t value = dm_read_reg(opp110->base.ctx, addr);
 
 	if (force_bypass) {
 
@@ -2338,7 +2338,7 @@ static void configure_regamma_mode(
 			REGAMMA_CONTROL,
 			GRPH_REGAMMA_MODE);
 
-		dal_write_reg(opp110->base.ctx, addr, value);
+		dm_write_reg(opp110->base.ctx, addr, value);
 
 		return;
 	}
@@ -2392,7 +2392,7 @@ static void configure_regamma_mode(
 		break;
 	}
 
-	dal_write_reg(opp110->base.ctx, addr, value);
+	dm_write_reg(opp110->base.ctx, addr, value);
 }
 
 bool dce110_opp_set_regamma(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 8f5acbd..9e2b5d9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -22,7 +22,8 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+
+#include "dm_services.h"
 
 #include "link_encoder.h"
 #include "stream_encoder.h"
@@ -299,7 +300,7 @@ static struct timing_generator *dce110_timing_generator_create(
 		const struct dce110_timing_generator_offsets *offsets)
 {
 	struct dce110_timing_generator *tg110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_timing_generator));
+		dm_alloc(ctx, sizeof(struct dce110_timing_generator));
 
 	if (!tg110)
 		return NULL;
@@ -308,7 +309,7 @@ static struct timing_generator *dce110_timing_generator_create(
 		return &tg110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, tg110);
+	dm_free(ctx, tg110);
 	return NULL;
 }
 
@@ -319,7 +320,7 @@ static struct stream_encoder *dce110_stream_encoder_create(
 	const struct dce110_stream_enc_registers *regs)
 {
 	struct dce110_stream_encoder *enc110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_stream_encoder));
+		dm_alloc(ctx, sizeof(struct dce110_stream_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -328,7 +329,7 @@ static struct stream_encoder *dce110_stream_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, enc110);
+	dm_free(ctx, enc110);
 	return NULL;
 }
 
@@ -338,7 +339,7 @@ static struct mem_input *dce110_mem_input_create(
 	const struct dce110_mem_input_reg_offsets *offset)
 {
 	struct dce110_mem_input *mem_input110 =
-		dc_service_alloc(ctx, sizeof(struct dce110_mem_input));
+		dm_alloc(ctx, sizeof(struct dce110_mem_input));
 
 	if (!mem_input110)
 		return NULL;
@@ -348,13 +349,13 @@ static struct mem_input *dce110_mem_input_create(
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, mem_input110);
+	dm_free(ctx, mem_input110);
 	return NULL;
 }
 
 static void dce110_transform_destroy(struct transform **xfm)
 {
-	dc_service_free((*xfm)->ctx, TO_DCE110_TRANSFORM(*xfm));
+	dm_free((*xfm)->ctx, TO_DCE110_TRANSFORM(*xfm));
 	*xfm = NULL;
 }
 
@@ -364,7 +365,7 @@ static struct transform *dce110_transform_create(
 	const struct dce110_transform_reg_offsets *offsets)
 {
 	struct dce110_transform *transform =
-		dc_service_alloc(ctx, sizeof(struct dce110_transform));
+		dm_alloc(ctx, sizeof(struct dce110_transform));
 
 	if (!transform)
 		return NULL;
@@ -373,7 +374,7 @@ static struct transform *dce110_transform_create(
 		return &transform->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, transform);
+	dm_free(ctx, transform);
 	return NULL;
 }
 
@@ -383,7 +384,7 @@ static struct input_pixel_processor *dce110_ipp_create(
 	const struct dce110_ipp_reg_offsets *offsets)
 {
 	struct dce110_ipp *ipp =
-		dc_service_alloc(ctx, sizeof(struct dce110_ipp));
+		dm_alloc(ctx, sizeof(struct dce110_ipp));
 
 	if (!ipp)
 		return NULL;
@@ -392,7 +393,7 @@ static struct input_pixel_processor *dce110_ipp_create(
 		return &ipp->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, ipp);
+	dm_free(ctx, ipp);
 	return NULL;
 }
 
@@ -400,7 +401,7 @@ struct link_encoder *dce110_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
 	struct dce110_link_encoder *enc110 =
-		dc_service_alloc(
+		dm_alloc(
 			enc_init_data->ctx,
 			sizeof(struct dce110_link_encoder));
 
@@ -416,13 +417,13 @@ struct link_encoder *dce110_link_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(enc_init_data->ctx, enc110);
+	dm_free(enc_init_data->ctx, enc110);
 	return NULL;
 }
 
 void dce110_link_encoder_destroy(struct link_encoder **enc)
 {
-	dc_service_free((*enc)->ctx, TO_DCE110_LINK_ENC(*enc));
+	dm_free((*enc)->ctx, TO_DCE110_LINK_ENC(*enc));
 	*enc = NULL;
 }
 
@@ -433,7 +434,7 @@ static struct output_pixel_processor *dce110_opp_create(
 	const struct dce110_opp_reg_offsets *offsets)
 {
 	struct dce110_opp *opp =
-		dc_service_alloc(ctx, sizeof(struct dce110_opp));
+		dm_alloc(ctx, sizeof(struct dce110_opp));
 
 	if (!opp)
 		return NULL;
@@ -443,7 +444,7 @@ static struct output_pixel_processor *dce110_opp_create(
 		return &opp->base;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, opp);
+	dm_free(ctx, opp);
 	return NULL;
 }
 
@@ -454,7 +455,7 @@ struct clock_source *dce110_clock_source_create(
 	const struct dce110_clk_src_reg_offsets *offsets)
 {
 	struct dce110_clk_src *clk_src =
-		dc_service_alloc(ctx, sizeof(struct dce110_clk_src));
+		dm_alloc(ctx, sizeof(struct dce110_clk_src));
 
 	if (!clk_src)
 		return NULL;
@@ -468,7 +469,7 @@ struct clock_source *dce110_clock_source_create(
 
 void dce110_clock_source_destroy(struct clock_source **clk_src)
 {
-	dc_service_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
+	dm_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
 	*clk_src = NULL;
 }
 
@@ -487,20 +488,20 @@ void dce110_destruct_resource_pool(struct resource_pool *pool)
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dc_service_free(pool->mis[i]->ctx,
+			dm_free(pool->mis[i]->ctx,
 					TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dc_service_free(pool->timing_generators[i]->ctx, DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(pool->timing_generators[i]->ctx, DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dc_service_free(pool->stream_enc[i]->ctx,
+			dm_free(pool->stream_enc[i]->ctx,
 				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
@@ -787,7 +788,7 @@ enum dc_status dce110_validate_bandwidth(
 			 * the same
 			 */
 			if (number_of_displays != 0 && all_displays_in_sync)
-				if (dal_memcmp(&prev_timing,
+				if (dm_memcmp(&prev_timing,
 					&stream->public.timing,
 					sizeof(struct dc_crtc_timing))!= 0)
 					all_displays_in_sync = false;
@@ -832,7 +833,7 @@ enum dc_status dce110_validate_bandwidth(
 			"%s: Bandwidth validation failed!",
 			__func__);
 
-	if (dal_memcmp(&dc->current_context.bw_results,
+	if (dm_memcmp(&dc->current_context.bw_results,
 			&context->bw_results, sizeof(context->bw_results))) {
 		struct log_entry log_entry;
 		dal_logger_open(
@@ -1047,7 +1048,7 @@ bool dce110_construct_resource_pool(
 
 	for (i = 0; i < pool->clk_src_count; i++) {
 		if (pool->clock_sources[i] == NULL) {
-			dal_error("DC: failed to create clock sources!\n");
+			dm_error("DC: failed to create clock sources!\n");
 			BREAK_TO_DEBUGGER();
 			goto clk_src_create_fail;
 		}
@@ -1055,7 +1056,7 @@ bool dce110_construct_resource_pool(
 
 	pool->display_clock = dal_display_clock_dce110_create(ctx, adapter_serv);
 	if (pool->display_clock == NULL) {
-		dal_error("DC: failed to create display clock!\n");
+		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto disp_clk_create_fail;
 	}
@@ -1079,7 +1080,7 @@ bool dce110_construct_resource_pool(
 	pool->scaler_filter = dal_scaler_filter_create(ctx);
 	if (pool->scaler_filter == NULL) {
 		BREAK_TO_DEBUGGER();
-		dal_error("DC: failed to create filter!\n");
+		dm_error("DC: failed to create filter!\n");
 		goto filter_create_fail;
 	}
 
@@ -1088,7 +1089,7 @@ bool dce110_construct_resource_pool(
 				adapter_serv, ctx, i, &dce110_tg_offsets[i]);
 		if (pool->timing_generators[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error("DC: failed to create tg!\n");
+			dm_error("DC: failed to create tg!\n");
 			goto controller_create_fail;
 		}
 
@@ -1096,7 +1097,7 @@ bool dce110_construct_resource_pool(
 				&dce110_mi_reg_offsets[i]);
 		if (pool->mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create memory input!\n");
 			goto controller_create_fail;
 		}
@@ -1104,7 +1105,7 @@ bool dce110_construct_resource_pool(
 		pool->ipps[i] = dce110_ipp_create(ctx, i, &dce110_ipp_reg_offsets[i]);
 		if (pool->ipps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create input pixel processor!\n");
 			goto controller_create_fail;
 		}
@@ -1113,7 +1114,7 @@ bool dce110_construct_resource_pool(
 					ctx, i, &dce110_xfm_offsets[i]);
 		if (pool->transforms[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create transform!\n");
 			goto controller_create_fail;
 		}
@@ -1124,7 +1125,7 @@ bool dce110_construct_resource_pool(
 		pool->opps[i] = dce110_opp_create(ctx, i, &dce110_opp_reg_offsets[i]);
 		if (pool->opps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error(
+			dm_error(
 				"DC: failed to create output pixel processor!\n");
 			goto controller_create_fail;
 		}
@@ -1146,7 +1147,7 @@ bool dce110_construct_resource_pool(
 		pool->audios[i] = dal_audio_create(&audio_init_data);
 		if (pool->audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error("DC: failed to create DPPs!\n");
+			dm_error("DC: failed to create DPPs!\n");
 			goto audio_create_fail;
 		}
 		pool->audio_count++;
@@ -1162,7 +1163,7 @@ bool dce110_construct_resource_pool(
 				&stream_enc_regs[i]);
 			if (pool->stream_enc[i] == NULL) {
 				BREAK_TO_DEBUGGER();
-				dal_error("DC: failed to create stream_encoder!\n");
+				dm_error("DC: failed to create stream_encoder!\n");
 				goto stream_enc_create_fail;
 			}
 		}
@@ -1175,7 +1176,7 @@ bool dce110_construct_resource_pool(
 								adapter_serv));
 		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
 			BREAK_TO_DEBUGGER();
-			dal_error("DC: failed to create stream_encoder!\n");
+			dm_error("DC: failed to create stream_encoder!\n");
 			goto stream_enc_create_fail;
 		}
 		pool->stream_enc_count++;
@@ -1186,7 +1187,7 @@ bool dce110_construct_resource_pool(
 stream_enc_create_fail:
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dc_service_free(pool->stream_enc[i]->ctx,
+			dm_free(pool->stream_enc[i]->ctx,
 				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
@@ -1208,13 +1209,13 @@ controller_create_fail:
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dc_service_free(pool->mis[i]->ctx,
+			dm_free(pool->mis[i]->ctx,
 					TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dc_service_free(pool->timing_generators[i]->ctx,
+			dm_free(pool->timing_generators[i]->ctx,
 				DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index fadcc06..2107309 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -23,9 +23,10 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dc_bios_types.h"
 #include "dce110_stream_encoder.h"
+
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 #include "dce/dce_11_0_enum.h"
@@ -81,7 +82,7 @@ static void dce110_update_generic_info_packet(
 	{
 		addr = LINK_REG(AFMT_VBI_PACKET_CONTROL);
 
-		regval = dal_read_reg(ctx, addr);
+		regval = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			regval,
@@ -89,7 +90,7 @@ static void dce110_update_generic_info_packet(
 			AFMT_VBI_PACKET_CONTROL,
 			AFMT_GENERIC_INDEX);
 
-		dal_write_reg(ctx, addr, regval);
+		dm_write_reg(ctx, addr, regval);
 	}
 
 	/* write generic packet header
@@ -123,7 +124,7 @@ static void dce110_update_generic_info_packet(
 			AFMT_GENERIC_HDR,
 			AFMT_GENERIC_HB3);
 
-		dal_write_reg(ctx, addr, regval);
+		dm_write_reg(ctx, addr, regval);
 	}
 
 	/* write generic packet contents
@@ -138,7 +139,7 @@ static void dce110_update_generic_info_packet(
 		addr = LINK_REG(AFMT_GENERIC_0);
 
 		do {
-			dal_write_reg(ctx, addr++, *content++);
+			dm_write_reg(ctx, addr++, *content++);
 
 			++counter;
 		} while (counter < 7);
@@ -146,7 +147,7 @@ static void dce110_update_generic_info_packet(
 
 	addr = LINK_REG(AFMT_GENERIC_7);
 
-	dal_write_reg(
+	dm_write_reg(
 		ctx,
 		addr,
 		0);
@@ -155,7 +156,7 @@ static void dce110_update_generic_info_packet(
 	{
 		addr = LINK_REG(AFMT_VBI_PACKET_CONTROL);
 
-		regval = dal_read_reg(ctx, addr);
+		regval = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			regval,
@@ -169,7 +170,7 @@ static void dce110_update_generic_info_packet(
 			AFMT_VBI_PACKET_CONTROL,
 			AFMT_GENERIC2_UPDATE);
 
-		dal_write_reg(ctx, addr, regval);
+		dm_write_reg(ctx, addr, regval);
 	}
 }
 
@@ -224,7 +225,7 @@ static void dce110_update_hdmi_info_packet(
 		return;
 	}
 
-	regval = dal_read_reg(ctx, addr);
+	regval = dm_read_reg(ctx, addr);
 
 	switch (packet_index) {
 	case 0:
@@ -274,7 +275,7 @@ static void dce110_update_hdmi_info_packet(
 		return;
 	}
 
-	dal_write_reg(ctx, addr, regval);
+	dm_write_reg(ctx, addr, regval);
 }
 
 bool dce110_stream_encoder_construct(
@@ -306,7 +307,7 @@ void dce110_stream_encoder_dp_set_stream_attribute(
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 	const uint32_t addr = LINK_REG(DP_PIXEL_FORMAT);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	/* set pixel encoding */
 	switch (crtc_timing->pixel_encoding) {
@@ -385,7 +386,7 @@ void dce110_stream_encoder_dp_set_stream_attribute(
 	set_reg_field_value(value, 0, DP_PIXEL_FORMAT, DP_DYN_RANGE);
 	set_reg_field_value(value, 0, DP_PIXEL_FORMAT, DP_YCBCR_RANGE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 /* setup stream encoder in hdmi mode */
@@ -414,7 +415,7 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 		return;
 
 	addr = LINK_REG(DIG_FE_CNTL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	switch (crtc_timing->pixel_encoding) {
 	case PIXEL_ENCODING_YCBCR422:
@@ -425,11 +426,11 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 		break;
 	}
 	set_reg_field_value(value, 0, DIG_FE_CNTL, TMDS_COLOR_FORMAT);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* setup HDMI engine */
 	addr = LINK_REG(HDMI_CONTROL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 1, HDMI_CONTROL, HDMI_PACKET_GEN_VERSION);
 	set_reg_field_value(value, 1, HDMI_CONTROL, HDMI_KEEPOUT_MODE);
 	set_reg_field_value(value, 0, HDMI_CONTROL, HDMI_DEEP_COLOR_ENABLE);
@@ -523,48 +524,48 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 			HDMI_CLOCK_CHANNEL_RATE);
 	}
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = LINK_REG(HDMI_VBI_PACKET_CONTROL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 1, HDMI_VBI_PACKET_CONTROL, HDMI_GC_CONT);
 	set_reg_field_value(value, 1, HDMI_VBI_PACKET_CONTROL, HDMI_GC_SEND);
 	set_reg_field_value(value, 1, HDMI_VBI_PACKET_CONTROL, HDMI_NULL_SEND);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* following belongs to audio */
 	addr = LINK_REG(HDMI_INFOFRAME_CONTROL0);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
 		HDMI_INFOFRAME_CONTROL0,
 		HDMI_AUDIO_INFO_SEND);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = LINK_REG(AFMT_INFOFRAME_CONTROL0);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		1,
 		AFMT_INFOFRAME_CONTROL0,
 		AFMT_AUDIO_INFO_UPDATE);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = LINK_REG(HDMI_INFOFRAME_CONTROL1);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		VBI_LINE_0 + 2,
 		HDMI_INFOFRAME_CONTROL1,
 		HDMI_AUDIO_INFO_LINE);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = LINK_REG(HDMI_GC);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 0, HDMI_GC, HDMI_GC_AVMUTE);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 /* setup stream encoder in dvi mode */
@@ -576,7 +577,7 @@ void dce110_stream_encoder_dvi_set_stream_attribute(
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t addr = LINK_REG(DIG_FE_CNTL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 	struct bp_encoder_control cntl = {0};
 
 	cntl.action = ENCODER_CONTROL_SETUP;
@@ -622,7 +623,7 @@ void dce110_stream_encoder_dvi_set_stream_attribute(
 		set_reg_field_value(value, 0, DIG_FE_CNTL, TMDS_COLOR_FORMAT);
 		break;
 	}
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_stream_encoder_set_mst_bandwidth(
@@ -646,7 +647,7 @@ void dce110_stream_encoder_set_mst_bandwidth(
 
 	{
 		addr = LINK_REG(DP_MSE_RATE_CNTL);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -660,7 +661,7 @@ void dce110_stream_encoder_set_mst_bandwidth(
 			DP_MSE_RATE_CNTL,
 			DP_MSE_RATE_Y);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* wait for update to be completed on the link */
@@ -670,7 +671,7 @@ void dce110_stream_encoder_set_mst_bandwidth(
 		addr = LINK_REG(DP_MSE_RATE_UPDATE);
 
 		do {
-			value = dal_read_reg(ctx, addr);
+			value = dm_read_reg(ctx, addr);
 
 			field = get_reg_field_value(
 					value,
@@ -681,7 +682,7 @@ void dce110_stream_encoder_set_mst_bandwidth(
 			DP_MSE_RATE_UPDATE__DP_MSE_RATE_UPDATE_PENDING_MASK))
 				break;
 
-			dc_service_delay_in_microseconds(ctx, 10);
+			dm_delay_in_microseconds(ctx, 10);
 
 			++retries;
 		} while (retries < DP_MST_UPDATE_MAX_RETRY);
@@ -705,21 +706,21 @@ void dce110_stream_encoder_update_hdmi_info_packets(
 
 		addr = LINK_REG(AFMT_AVI_INFO0);
 		regval = content[0];
-		dal_write_reg(
+		dm_write_reg(
 			ctx,
 			addr,
 			regval);
 		regval = content[1];
 
 		addr = LINK_REG(AFMT_AVI_INFO1);
-		dal_write_reg(
+		dm_write_reg(
 			ctx,
 			addr,
 			regval);
 		regval = content[2];
 
 		addr = LINK_REG(AFMT_AVI_INFO2);
-		dal_write_reg(
+		dm_write_reg(
 			ctx,
 			addr,
 			regval);
@@ -733,14 +734,14 @@ void dce110_stream_encoder_update_hdmi_info_packets(
 			AFMT_AVI_INFO3,
 			AFMT_AVI_INFO_VERSION);
 
-		dal_write_reg(
+		dm_write_reg(
 			ctx,
 			addr,
 			regval);
 
 		addr = LINK_REG(HDMI_INFOFRAME_CONTROL0);
 
-		control0val = dal_read_reg(ctx, addr);
+		control0val = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			control0val,
@@ -754,11 +755,11 @@ void dce110_stream_encoder_update_hdmi_info_packets(
 			HDMI_INFOFRAME_CONTROL0,
 			HDMI_AVI_INFO_CONT);
 
-		dal_write_reg(ctx, addr, control0val);
+		dm_write_reg(ctx, addr, control0val);
 
 		addr = LINK_REG(HDMI_INFOFRAME_CONTROL1);
 
-		control1val = dal_read_reg(ctx, addr);
+		control1val = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			control1val,
@@ -766,11 +767,11 @@ void dce110_stream_encoder_update_hdmi_info_packets(
 			HDMI_INFOFRAME_CONTROL1,
 			HDMI_AVI_INFO_LINE);
 
-		dal_write_reg(ctx, addr, control1val);
+		dm_write_reg(ctx, addr, control1val);
 	} else {
 		addr = LINK_REG(HDMI_INFOFRAME_CONTROL0);
 
-		regval = dal_read_reg(ctx, addr);
+		regval = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			regval,
@@ -784,7 +785,7 @@ void dce110_stream_encoder_update_hdmi_info_packets(
 			HDMI_INFOFRAME_CONTROL0,
 			HDMI_AVI_INFO_CONT);
 
-		dal_write_reg(ctx, addr, regval);
+		dm_write_reg(ctx, addr, regval);
 	}
 
 	dce110_update_hdmi_info_packet(enc110, 0, &info_frame->vendor);
@@ -803,7 +804,7 @@ void dce110_stream_encoder_stop_hdmi_info_packets(
 	/* stop generic packets 0 & 1 on HDMI */
 	addr = LINK_REG(HDMI_GENERIC_PACKET_CONTROL0);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -836,12 +837,12 @@ void dce110_stream_encoder_stop_hdmi_info_packets(
 		HDMI_GENERIC_PACKET_CONTROL0,
 		HDMI_GENERIC0_SEND);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* stop generic packets 2 & 3 on HDMI */
 	addr = LINK_REG(HDMI_GENERIC_PACKET_CONTROL1);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -874,12 +875,12 @@ void dce110_stream_encoder_stop_hdmi_info_packets(
 		HDMI_GENERIC_PACKET_CONTROL1,
 		HDMI_GENERIC3_SEND);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* stop AVI packet on HDMI */
 	addr = LINK_REG(HDMI_INFOFRAME_CONTROL0);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -892,7 +893,7 @@ void dce110_stream_encoder_stop_hdmi_info_packets(
 		HDMI_INFOFRAME_CONTROL0,
 		HDMI_AVI_INFO_CONT);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 void dce110_stream_encoder_update_dp_info_packets(
 	struct stream_encoder *enc,
@@ -913,7 +914,7 @@ void dce110_stream_encoder_update_dp_info_packets(
 	*  If enabled, packet transmission begins on the next frame
 	*/
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -934,7 +935,7 @@ void dce110_stream_encoder_update_dp_info_packets(
 			DP_SEC_CNTL,
 			DP_SEC_STREAM_ENABLE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_stream_encoder_stop_dp_info_packets(
@@ -944,7 +945,7 @@ void dce110_stream_encoder_stop_dp_info_packets(
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t addr = LINK_REG(DP_SEC_CNTL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(value, 0, DP_SEC_CNTL, DP_SEC_GSP0_ENABLE);
 	set_reg_field_value(value, 0, DP_SEC_CNTL, DP_SEC_GSP1_ENABLE);
@@ -965,7 +966,7 @@ void dce110_stream_encoder_stop_dp_info_packets(
 			DP_SEC_CNTL,
 			DP_SEC_STREAM_ENABLE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_stream_encoder_dp_blank(
@@ -974,7 +975,7 @@ void dce110_stream_encoder_dp_blank(
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t addr = LINK_REG(DP_VID_STREAM_CNTL);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 	uint32_t retries = 0;
 	uint32_t max_retries = DP_BLANK_MAX_RETRY * 10;
 
@@ -1000,7 +1001,7 @@ void dce110_stream_encoder_dp_blank(
 
 	/* disable DP stream */
 	set_reg_field_value(value, 0, DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* the encoder stops sending the video stream
 	* at the start of the vertical blanking.
@@ -1008,7 +1009,7 @@ void dce110_stream_encoder_dp_blank(
 	*/
 
 	do {
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		if (!get_reg_field_value(
 			value,
@@ -1016,7 +1017,7 @@ void dce110_stream_encoder_dp_blank(
 			DP_VID_STREAM_STATUS))
 			break;
 
-		dc_service_delay_in_microseconds(ctx, 10);
+		dm_delay_in_microseconds(ctx, 10);
 
 		++retries;
 	} while (retries < max_retries);
@@ -1029,9 +1030,9 @@ void dce110_stream_encoder_dp_blank(
 	* i.e. DP_VID_STREAM_STATUS stuck at 1.
 	*/
 	addr = LINK_REG(DP_STEER_FIFO);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, true, DP_STEER_FIFO, DP_STEER_FIFO_RESET);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 /* output video stream to link encoder */
@@ -1063,45 +1064,45 @@ void dce110_stream_encoder_dp_unblank(
 
 		/* enable auto measurement */
 		addr = LINK_REG(DP_VID_TIMING);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 		set_reg_field_value(value, 0, DP_VID_TIMING, DP_VID_M_N_GEN_EN);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 
 		/* auto measurement need 1 full 0x8000 symbol cycle to kick in,
 		* therefore program initial value for Mvid and Nvid
 		*/
 		addr = LINK_REG(DP_VID_N);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 		set_reg_field_value(value, n_vid, DP_VID_N, DP_VID_N);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 
 		addr = LINK_REG(DP_VID_M);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 		set_reg_field_value(value, m_vid, DP_VID_M, DP_VID_M);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 
 		addr = LINK_REG(DP_VID_TIMING);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 		set_reg_field_value(value, 1, DP_VID_TIMING, DP_VID_M_N_GEN_EN);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* set DIG_START to 0x1 to resync FIFO */
 	addr = LINK_REG(DIG_FE_CNTL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 1, DIG_FE_CNTL, DIG_START);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* switch DP encoder to CRTC data */
 	addr = LINK_REG(DP_STEER_FIFO);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, 0, DP_STEER_FIFO, DP_STEER_FIFO_RESET);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* wait 100us for DIG/DP logic to prime
 	* (i.e. a few video lines)
 	*/
-	dc_service_delay_in_microseconds(ctx, 100);
+	dm_delay_in_microseconds(ctx, 100);
 
 	/* the hardware would start sending video at the start of the next DP
 	* frame (i.e. rising edge of the vblank).
@@ -1111,12 +1112,12 @@ void dce110_stream_encoder_dp_unblank(
 	* programmable
 	*/
 	addr = LINK_REG(DP_VID_STREAM_CNTL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		true,
 		DP_VID_STREAM_CNTL,
 		DP_VID_STREAM_ENABLE);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index 50b7c70..d7cdd91 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -36,6 +36,7 @@
 #include "include/adapter_service_interface.h"
 #include "include/logger_interface.h"
 #include "dce110_timing_generator.h"
+
 #include "../inc/timing_generator.h"
 
 enum black_color_format {
@@ -250,7 +251,7 @@ static bool dce110_timing_generator_is_in_vertical_blank(
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
 	addr = CRTC_REG(mmCRTC_STATUS);
-	value = dal_read_reg(tg->ctx, addr);
+	value = dm_read_reg(tg->ctx, addr);
 	field = get_reg_field_value(value, CRTC_STATUS, CRTC_V_BLANK);
 	return field == 1;
 }
@@ -263,10 +264,10 @@ void dce110_timing_generator_set_early_control(
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t address = CRTC_REG(mmCRTC_CONTROL);
 
-	regval = dal_read_reg(tg->ctx, address);
+	regval = dm_read_reg(tg->ctx, address);
 	set_reg_field_value(regval, early_cntl,
 			CRTC_CONTROL, CRTC_HBLANK_EARLY_CONTROL);
-	dal_write_reg(tg->ctx, address, regval);
+	dm_write_reg(tg->ctx, address, regval);
 }
 
 /**
@@ -282,11 +283,11 @@ bool dce110_timing_generator_enable_crtc(struct timing_generator *tg)
 	uint32_t value;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	value = dal_read_reg(tg->ctx,
+	value = dm_read_reg(tg->ctx,
 			CRTC_REG(mmCRTC_MASTER_UPDATE_MODE));
 	set_reg_field_value(value, 3,
 			CRTC_MASTER_UPDATE_MODE, MASTER_UPDATE_MODE);
-	dal_write_reg(tg->ctx,
+	dm_write_reg(tg->ctx,
 			CRTC_REG(mmCRTC_MASTER_UPDATE_MODE), value);
 
 	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, true);
@@ -301,7 +302,7 @@ void dce110_timing_generator_program_blank_color(
 	struct crtc_black_color black_color;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_BLACK_COLOR);
-	uint32_t value = dal_read_reg(tg->ctx, addr);
+	uint32_t value = dm_read_reg(tg->ctx, addr);
 
 	dce110_timing_generator_color_space_to_black_color(
 		color_space,
@@ -323,7 +324,7 @@ void dce110_timing_generator_program_blank_color(
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_R_CR);
 
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 }
 
 /**
@@ -335,7 +336,7 @@ bool dce110_timing_generator_blank_crtc(struct timing_generator *tg)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_BLANK_CONTROL);
-	uint32_t value = dal_read_reg(tg->ctx, addr);
+	uint32_t value = dm_read_reg(tg->ctx, addr);
 	uint8_t counter = 100;
 
 	set_reg_field_value(
@@ -350,10 +351,10 @@ bool dce110_timing_generator_blank_crtc(struct timing_generator *tg)
 		CRTC_BLANK_CONTROL,
 		CRTC_BLANK_DE_MODE);
 
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 
 	while (counter > 0) {
-		value = dal_read_reg(tg->ctx, addr);
+		value = dm_read_reg(tg->ctx, addr);
 
 		if (get_reg_field_value(
 			value,
@@ -365,7 +366,7 @@ bool dce110_timing_generator_blank_crtc(struct timing_generator *tg)
 			CRTC_CURRENT_BLANK_STATE) == 1)
 			break;
 
-		dc_service_sleep_in_milliseconds(tg->ctx, 1);
+		dm_sleep_in_milliseconds(tg->ctx, 1);
 		counter--;
 	}
 
@@ -388,7 +389,7 @@ bool dce110_timing_generator_unblank_crtc(struct timing_generator *tg)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_BLANK_CONTROL);
-	uint32_t value = dal_read_reg(tg->ctx, addr);
+	uint32_t value = dm_read_reg(tg->ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -402,7 +403,7 @@ bool dce110_timing_generator_unblank_crtc(struct timing_generator *tg)
 		CRTC_BLANK_CONTROL,
 		CRTC_BLANK_DE_MODE);
 
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 
 	return true;
 }
@@ -428,7 +429,7 @@ static void disable_stereo(struct timing_generator *tg)
 	uint32_t struc_en = 0;
 	uint32_t struc_stereo_sel_ovr = 0;
 
-	value = dal_read_reg(tg->ctx, addr);
+	value = dm_read_reg(tg->ctx, addr);
 	struc_en = get_reg_field_value(
 			value,
 			CRTC_3D_STRUCTURE_CONTROL,
@@ -451,11 +452,11 @@ static void disable_stereo(struct timing_generator *tg)
 	}
 
 	value = 0;
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 
 
 	addr = tg->regs[IDX_CRTC_STEREO_CONTROL];
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 }
 #endif
 
@@ -492,7 +493,7 @@ static void program_horz_count_by_2(
 	uint32_t regval;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	regval = dal_read_reg(tg->ctx,
+	regval = dm_read_reg(tg->ctx,
 			CRTC_REG(mmCRTC_COUNT_CONTROL));
 
 	set_reg_field_value(regval, 0, CRTC_COUNT_CONTROL,
@@ -502,7 +503,7 @@ static void program_horz_count_by_2(
 		set_reg_field_value(regval, 1, CRTC_COUNT_CONTROL,
 					CRTC_HORZ_COUNT_BY2_EN);
 
-	dal_write_reg(tg->ctx,
+	dm_write_reg(tg->ctx,
 			CRTC_REG(mmCRTC_COUNT_CONTROL), regval);
 }
 
@@ -528,7 +529,7 @@ bool dce110_timing_generator_program_timing_generator(
 			dc_crtc_timing->h_front_porch;
 	uint32_t h_sync_start = dc_crtc_timing->h_addressable + hsync_offset;
 
-	dc_service_memset(&bp_params, 0, sizeof(struct bp_hw_crtc_timing_parameters));
+	dm_memset(&bp_params, 0, sizeof(struct bp_hw_crtc_timing_parameters));
 
 	/* Due to an asic bug we need to apply the Front Porch workaround prior
 	 * to programming the timing.
@@ -610,16 +611,16 @@ void dce110_timing_generator_program_drr(
 	uint32_t addr = 0;
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL_MIN);
-	v_total_min = dal_read_reg(tg->ctx, addr);
+	v_total_min = dm_read_reg(tg->ctx, addr);
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL_MAX);
-	v_total_max = dal_read_reg(tg->ctx, addr);
+	v_total_max = dm_read_reg(tg->ctx, addr);
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL_CONTROL);
-	v_total_cntl = dal_read_reg(tg->ctx, addr);
+	v_total_cntl = dm_read_reg(tg->ctx, addr);
 
 	addr = CRTC_REG(mmCRTC_STATIC_SCREEN_CONTROL);
-	static_screen_cntl = dal_read_reg(tg->ctx, addr);
+	static_screen_cntl = dm_read_reg(tg->ctx, addr);
 
 	if (timing != NULL) {
 		/* Set Static Screen trigger events
@@ -741,16 +742,16 @@ void dce110_timing_generator_program_drr(
 	}
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL_MIN);
-	dal_write_reg(tg->ctx, addr, v_total_min);
+	dm_write_reg(tg->ctx, addr, v_total_min);
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL_MAX);
-	dal_write_reg(tg->ctx, addr, v_total_max);
+	dm_write_reg(tg->ctx, addr, v_total_max);
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL_CONTROL);
-	dal_write_reg(tg->ctx, addr, v_total_cntl);
+	dm_write_reg(tg->ctx, addr, v_total_cntl);
 
 	addr = CRTC_REG(mmCRTC_STATIC_SCREEN_CONTROL);
-	dal_write_reg(tg->ctx, addr, static_screen_cntl);
+	dm_write_reg(tg->ctx, addr, static_screen_cntl);
 }
 
 /*
@@ -771,7 +772,7 @@ uint32_t dce110_timing_generator_get_vblank_counter(struct timing_generator *tg)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_STATUS_FRAME_COUNT);
-	uint32_t value = dal_read_reg(tg->ctx, addr);
+	uint32_t value = dm_read_reg(tg->ctx, addr);
 	uint32_t field = get_reg_field_value(
 			value, CRTC_STATUS_FRAME_COUNT, CRTC_FRAME_COUNT);
 
@@ -797,7 +798,7 @@ void dce110_timing_generator_get_crtc_positions(
 	uint32_t value;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	value = dal_read_reg(tg->ctx, CRTC_REG(mmCRTC_STATUS_POSITION));
+	value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_STATUS_POSITION));
 
 	*h_position = get_reg_field_value(
 			value,
@@ -834,10 +835,10 @@ uint32_t dce110_timing_generator_get_crtc_scanoutpos(
 
 	/* TODO 2: re-use dce110_timing_generator_get_crtc_positions() */
 
-	*vbl = dal_read_reg(tg->ctx,
+	*vbl = dm_read_reg(tg->ctx,
 			CRTC_REG(mmCRTC_V_BLANK_START_END));
 
-	*position = dal_read_reg(tg->ctx,
+	*position = dm_read_reg(tg->ctx,
 			CRTC_REG(mmCRTC_STATUS_POSITION));
 
 	/* @TODO: return value should indicate if current
@@ -868,25 +869,25 @@ void dce110_timing_generator_program_blanking(
 	uint32_t tmp = 0;
 
 	addr = CRTC_REG(mmCRTC_H_TOTAL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		timing->h_total - 1,
 		CRTC_H_TOTAL,
 		CRTC_H_TOTAL);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = CRTC_REG(mmCRTC_V_TOTAL);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		timing->v_total - 1,
 		CRTC_V_TOTAL,
 		CRTC_V_TOTAL);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = CRTC_REG(mmCRTC_H_BLANK_START_END);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	tmp = timing->h_total -
 		(h_sync_start + timing->h_border_left);
@@ -906,10 +907,10 @@ void dce110_timing_generator_program_blanking(
 		CRTC_H_BLANK_START_END,
 		CRTC_H_BLANK_START);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = CRTC_REG(mmCRTC_V_BLANK_START_END);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	tmp = timing->v_total - (v_sync_start + timing->v_border_top);
 
@@ -928,7 +929,7 @@ void dce110_timing_generator_program_blanking(
 		CRTC_V_BLANK_START_END,
 		CRTC_V_BLANK_START);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_timing_generator_set_test_pattern(
@@ -961,7 +962,7 @@ void dce110_timing_generator_set_test_pattern(
 			CRTC_TEST_PATTERN_PARAMETERS,
 			CRTC_TEST_PATTERN_HRES);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 
 		addr = CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL);
 		value = 0;
@@ -989,7 +990,7 @@ void dce110_timing_generator_set_test_pattern(
 			1,
 			CRTC_TEST_PATTERN_CONTROL,
 			CRTC_TEST_PATTERN_COLOR_FORMAT);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 		break;
 	} /* switch() */
 }
@@ -1136,7 +1137,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 	uint32_t address = DCP_REG(mmDCP_GSL_CONTROL);
 	uint32_t check_point = FLIP_READY_BACK_LOOKUP;
 
-	value = dal_read_reg(tg->ctx, address);
+	value = dm_read_reg(tg->ctx, address);
 
 	/* This pipe will belong to GSL Group zero. */
 	set_reg_field_value(value,
@@ -1165,7 +1166,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 	{
 		uint32_t value_crtc_vtotal;
 
-		value_crtc_vtotal = dal_read_reg(tg->ctx,
+		value_crtc_vtotal = dm_read_reg(tg->ctx,
 				CRTC_REG(mmCRTC_V_TOTAL));
 
 		set_reg_field_value(value,
@@ -1178,7 +1179,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 				CRTC_V_TOTAL,
 				CRTC_V_TOTAL);
 
-		dal_write_reg(tg->ctx, CRTC_REG(mmCRTC_GSL_WINDOW), 0);
+		dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_GSL_WINDOW), 0);
 	}
 
 	set_reg_field_value(value,
@@ -1186,7 +1187,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 			DCP_GSL_CONTROL,
 			DCP_GSL_DELAY_SURFACE_UPDATE_PENDING);
 
-	dal_write_reg(tg->ctx, address, value);
+	dm_write_reg(tg->ctx, address, value);
 
 	/********************************************************************/
 	address = CRTC_REG(mmCRTC_GSL_CONTROL);
@@ -1202,7 +1203,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 			CRTC_GSL_CONTROL,
 			CRTC_GSL_FORCE_DELAY);
 
-	dal_write_reg(tg->ctx, address, value);
+	dm_write_reg(tg->ctx, address, value);
 }
 
 
@@ -1246,7 +1247,7 @@ void dce110_timing_generator_tear_down_global_swap_lock(
 	{
 		uint32_t value_crtc_vtotal;
 
-		value_crtc_vtotal = dal_read_reg(tg->ctx,
+		value_crtc_vtotal = dm_read_reg(tg->ctx,
 				CRTC_REG(mmCRTC_V_TOTAL));
 
 		set_reg_field_value(value,
@@ -1260,7 +1261,7 @@ void dce110_timing_generator_tear_down_global_swap_lock(
 			DCP_GSL_CONTROL,
 			DCP_GSL_DELAY_SURFACE_UPDATE_PENDING);
 
-	dal_write_reg(tg->ctx, address, value);
+	dm_write_reg(tg->ctx, address, value);
 
 	/********************************************************************/
 	address = CRTC_REG(mmCRTC_GSL_CONTROL);
@@ -1276,7 +1277,7 @@ void dce110_timing_generator_tear_down_global_swap_lock(
 			CRTC_GSL_CONTROL,
 			CRTC_GSL_FORCE_DELAY);
 
-	dal_write_reg(tg->ctx, address, value);
+	dm_write_reg(tg->ctx, address, value);
 }
 /**
  *****************************************************************************
@@ -1313,7 +1314,7 @@ void dce110_timing_generator_enable_advanced_request(
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_START_LINE_CONTROL);
-	uint32_t value = dal_read_reg(tg->ctx, addr);
+	uint32_t value = dm_read_reg(tg->ctx, addr);
 
 	if (enable && !DCE110TG_FROM_TG(tg)->disable_advanced_request) {
 		set_reg_field_value(
@@ -1365,7 +1366,7 @@ void dce110_timing_generator_enable_advanced_request(
 		CRTC_START_LINE_CONTROL,
 		CRTC_INTERLACE_START_LINE_EARLY);
 
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 }
 
 /*TODO: Figure out if we need this function. */
@@ -1375,7 +1376,7 @@ void dce110_timing_generator_set_lock_master(struct timing_generator *tg,
 	struct dc_context *ctx = tg->ctx;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_MASTER_UPDATE_LOCK);
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -1383,7 +1384,7 @@ void dce110_timing_generator_set_lock_master(struct timing_generator *tg,
 		CRTC_MASTER_UPDATE_LOCK,
 		MASTER_UPDATE_LOCK);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_timing_generator_enable_reset_trigger(
@@ -1402,7 +1403,7 @@ void dce110_timing_generator_enable_reset_trigger(
 	/* Default = based on current timing polarity */
 	case TRIGGER_EDGE_DEFAULT:
 		{
-			uint32_t pol_value = dal_read_reg(tg->ctx,
+			uint32_t pol_value = dm_read_reg(tg->ctx,
 					CRTC_REG(mmCRTC_V_SYNC_A_CNTL));
 
 			/* Register spec has reversed definition:
@@ -1431,7 +1432,7 @@ void dce110_timing_generator_enable_reset_trigger(
 		return;
 	}
 
-	value = dal_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));
+	value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));
 
 	switch(trigger_params->source) {
 	/* Currently supporting only a single group, the group zero. */
@@ -1478,11 +1479,11 @@ void dce110_timing_generator_enable_reset_trigger(
 			CRTC_TRIGB_CNTL,
 			CRTC_TRIGB_CLEAR);
 
-	dal_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);
+	dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);
 
 	/**************************************************************/
 
-	value = dal_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));
+	value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));
 
 	set_reg_field_value(value,
 			2, /* force H count to H_TOTAL and V count to V_TOTAL */
@@ -1499,7 +1500,7 @@ void dce110_timing_generator_enable_reset_trigger(
 			CRTC_FORCE_COUNT_NOW_CNTL,
 			CRTC_FORCE_COUNT_NOW_CLEAR);
 
-	dal_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);
+	dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);
 }
 
 void dce110_timing_generator_disable_reset_trigger(
@@ -1508,7 +1509,7 @@ void dce110_timing_generator_disable_reset_trigger(
 	uint32_t value;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	value = dal_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));
+	value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));
 
 	set_reg_field_value(value,
 			0, /* force counter now mode is disabled */
@@ -1520,10 +1521,10 @@ void dce110_timing_generator_disable_reset_trigger(
 			CRTC_FORCE_COUNT_NOW_CNTL,
 			CRTC_FORCE_COUNT_NOW_CLEAR);
 
-	dal_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);
+	dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL), value);
 
 	/********************************************************************/
-	value = dal_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));
+	value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));
 
 	set_reg_field_value(value,
 			TRIGGER_SOURCE_SELECT_LOGIC_ZERO,
@@ -1540,7 +1541,7 @@ void dce110_timing_generator_disable_reset_trigger(
 			CRTC_TRIGB_CNTL,
 			CRTC_TRIGB_CLEAR);
 
-	dal_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);
+	dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL), value);
 }
 
 /**
@@ -1556,7 +1557,7 @@ bool dce110_timing_generator_did_triggered_reset_occur(
 	struct timing_generator *tg)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
-	uint32_t value = dal_read_reg(tg->ctx,
+	uint32_t value = dm_read_reg(tg->ctx,
 			CRTC_REG(mmCRTC_FORCE_COUNT_NOW_CNTL));
 
 	return get_reg_field_value(value,
@@ -1599,7 +1600,7 @@ void dce110_timing_generator_disable_vga(
 	default:
 		break;
 	}
-	value = dal_read_reg(tg->ctx, addr);
+	value = dm_read_reg(tg->ctx, addr);
 
 	set_reg_field_value(value, 0, D1VGA_CONTROL, D1VGA_MODE_ENABLE);
 	set_reg_field_value(value, 0, D1VGA_CONTROL, D1VGA_TIMING_SELECT);
@@ -1607,7 +1608,7 @@ void dce110_timing_generator_disable_vga(
 			value, 0, D1VGA_CONTROL, D1VGA_SYNC_POLARITY_SELECT);
 	set_reg_field_value(value, 0, D1VGA_CONTROL, D1VGA_OVERSCAN_COLOR_EN);
 
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 }
 
 /**
@@ -1724,15 +1725,15 @@ void dce110_timing_generator_set_overscan_color_black(
 		break;
 	}
 	addr = CRTC_REG(mmCRTC_OVERSCAN_COLOR);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 	addr = CRTC_REG(mmCRTC_BLACK_COLOR);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 	/* This is desirable to have a constant DAC output voltage during the
 	 * blank time that is higher than the 0 volt reference level that the
 	 * DAC outputs when the NBLANK signal
 	 * is asserted low, such as for output to an analog TV. */
 	addr = CRTC_REG(mmCRTC_BLANK_DATA_COLOR);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* TO DO we have to program EXT registers and we need to know LB DATA
 	 * format because it is used when more 10 , i.e. 12 bits per color
@@ -1749,7 +1750,7 @@ void dce110_tg_program_blank_color(struct timing_generator *tg,
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_BLACK_COLOR);
-	uint32_t value = dal_read_reg(tg->ctx, addr);
+	uint32_t value = dm_read_reg(tg->ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -1767,10 +1768,10 @@ void dce110_tg_program_blank_color(struct timing_generator *tg,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_R_CR);
 
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 
 	addr = CRTC_REG(mmCRTC_BLANK_DATA_COLOR);
-	dal_write_reg(tg->ctx, addr, value);
+	dm_write_reg(tg->ctx, addr, value);
 }
 
 void dce110_tg_set_overscan_color(struct timing_generator *tg,
@@ -1800,7 +1801,7 @@ void dce110_tg_set_overscan_color(struct timing_generator *tg,
 		CRTC_OVERSCAN_COLOR_RED);
 
 	addr = CRTC_REG(mmCRTC_OVERSCAN_COLOR);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_tg_get_position(struct timing_generator *tg,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
index 16cddb5..2654a96 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -37,6 +37,7 @@
 #include "include/logger_interface.h"
 
 #include "dce110_transform.h"
+
 #include "dce110_transform_bit_depth.h"
 
 static struct transform_funcs dce110_transform_funcs = {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
index a64a507..fb5ef6d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -264,7 +264,7 @@ static bool set_clamp(
 			OUT_CLAMP_CONTROL_B_CB,
 			OUT_CLAMP_MAX_B_CB);
 
-		dal_write_reg(xfm110->base.ctx,
+		dm_write_reg(xfm110->base.ctx,
 			DCP_REG(mmOUT_CLAMP_CONTROL_B_CB),
 			value);
 	}
@@ -284,7 +284,7 @@ static bool set_clamp(
 			OUT_CLAMP_CONTROL_G_Y,
 			OUT_CLAMP_MAX_G_Y);
 
-		dal_write_reg(xfm110->base.ctx,
+		dm_write_reg(xfm110->base.ctx,
 			DCP_REG(mmOUT_CLAMP_CONTROL_G_Y),
 			value);
 	}
@@ -304,7 +304,7 @@ static bool set_clamp(
 			OUT_CLAMP_CONTROL_R_CR,
 			OUT_CLAMP_MAX_R_CR);
 
-		dal_write_reg(xfm110->base.ctx,
+		dm_write_reg(xfm110->base.ctx,
 			DCP_REG(mmOUT_CLAMP_CONTROL_R_CR),
 			value);
 	}
@@ -416,7 +416,7 @@ static bool set_round(
 		OUT_ROUND_TRUNC_MODE);
 
 	/*  write the register */
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 				DCP_REG(mmOUT_ROUND_CONTROL),
 				value);
 
@@ -530,7 +530,7 @@ static bool set_dither(
 			DCP_HIGHPASS_RANDOM_ENABLE);
 
 	/*  write the register */
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 				DCP_REG(mmDCP_SPATIAL_DITHER_CNTL),
 				value);
 
@@ -595,7 +595,7 @@ void dce110_transform_enable_alpha(
 	uint32_t value;
 	uint32_t addr = LB_REG(mmLB_DATA_FORMAT);
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	if (enable == 1)
 		set_reg_field_value(
@@ -610,7 +610,7 @@ void dce110_transform_enable_alpha(
 				LB_DATA_FORMAT,
 				ALPHA_EN);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static enum lb_pixel_depth translate_display_bpp_to_lb_depth(
@@ -658,7 +658,7 @@ bool dce110_transform_get_next_lower_pixel_storage_depth(
 bool dce110_transform_is_prefetch_enabled(
 	struct dce110_transform *xfm110)
 {
-	uint32_t value = dal_read_reg(
+	uint32_t value = dm_read_reg(
 			xfm110->base.ctx, LB_REG(mmLB_DATA_FORMAT));
 
 	if (get_reg_field_value(value, LB_DATA_FORMAT, PREFETCH) == 1)
@@ -677,7 +677,7 @@ bool dce110_transform_get_current_pixel_storage_depth(
 	if (depth == NULL)
 		return false;
 
-	value = dal_read_reg(
+	value = dm_read_reg(
 			xfm->ctx,
 			LB_REG(mmLB_DATA_FORMAT));
 
@@ -711,7 +711,7 @@ static void set_denormalization(
 	struct dce110_transform *xfm110,
 	enum dc_color_depth depth)
 {
-	uint32_t value = dal_read_reg(xfm110->base.ctx,
+	uint32_t value = dm_read_reg(xfm110->base.ctx,
 			DCP_REG(mmDENORM_CONTROL));
 
 	switch (depth) {
@@ -755,7 +755,7 @@ static void set_denormalization(
 		break;
 	}
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			DCP_REG(mmDENORM_CONTROL),
 			value);
 
@@ -771,7 +771,7 @@ bool dce110_transform_set_pixel_storage_depth(
 	uint32_t value;
 	enum dc_color_depth color_depth;
 
-	value = dal_read_reg(
+	value = dm_read_reg(
 			xfm->ctx,
 			LB_REG(mmLB_DATA_FORMAT));
 	switch (depth) {
@@ -806,7 +806,7 @@ bool dce110_transform_set_pixel_storage_depth(
 				bit_depth_params);
 
 		set_reg_field_value(value, 0, LB_DATA_FORMAT, ALPHA_EN);
-		dal_write_reg(
+		dm_write_reg(
 				xfm->ctx, LB_REG(mmLB_DATA_FORMAT), value);
 		if (!(xfm110->lb_pixel_depth_supported & depth)) {
 			/*we should use unsupported capabilities
@@ -836,7 +836,7 @@ bool dce110_transform_power_up_line_buffer(struct transform *xfm)
 	struct dce110_transform *xfm110 = TO_DCE110_TRANSFORM(xfm);
 	uint32_t value;
 
-	value = dal_read_reg(xfm110->base.ctx, LB_REG(mmLB_MEMORY_CTRL));
+	value = dm_read_reg(xfm110->base.ctx, LB_REG(mmLB_MEMORY_CTRL));
 
 	/*Use all three pieces of memory always*/
 	set_reg_field_value(value, 0, LB_MEMORY_CTRL, LB_MEMORY_CONFIG);
@@ -844,7 +844,7 @@ bool dce110_transform_power_up_line_buffer(struct transform *xfm)
 	set_reg_field_value(value, LB_TOTAL_NUMBER_OF_ENTRIES, LB_MEMORY_CTRL,
 			LB_MEMORY_SIZE);
 
-	dal_write_reg(xfm110->base.ctx, LB_REG(mmLB_MEMORY_CTRL), value);
+	dm_write_reg(xfm110->base.ctx, LB_REG(mmLB_MEMORY_CTRL), value);
 
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_gamut.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_gamut.c
index bb3b3cc..05309c9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_gamut.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_gamut.c
@@ -22,7 +22,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "dce110_transform.h"
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -76,7 +76,7 @@ static void program_gamut_remap(
 	uint32_t addr = DCP_REG(mmGAMUT_REMAP_CONTROL);
 
 	/* the register controls ovl also */
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	if (reg_val) {
 		{
@@ -96,7 +96,7 @@ static void program_gamut_remap(
 				GAMUT_REMAP_C11_C12,
 				GAMUT_REMAP_C12);
 
-			dal_write_reg(ctx, addr, reg_data);
+			dm_write_reg(ctx, addr, reg_data);
 		}
 		{
 			uint32_t reg_data = 0;
@@ -116,7 +116,7 @@ static void program_gamut_remap(
 				GAMUT_REMAP_C13_C14,
 				GAMUT_REMAP_C14);
 
-			dal_write_reg(ctx, addr, reg_data);
+			dm_write_reg(ctx, addr, reg_data);
 		}
 		{
 			uint32_t reg_data = 0;
@@ -136,7 +136,7 @@ static void program_gamut_remap(
 				GAMUT_REMAP_C21_C22,
 				GAMUT_REMAP_C22);
 
-			dal_write_reg(ctx, addr, reg_data);
+			dm_write_reg(ctx, addr, reg_data);
 		}
 		{
 			uint32_t reg_data = 0;
@@ -156,7 +156,7 @@ static void program_gamut_remap(
 				GAMUT_REMAP_C23_C24,
 				GAMUT_REMAP_C24);
 
-			dal_write_reg(ctx, addr, reg_data);
+			dm_write_reg(ctx, addr, reg_data);
 		}
 		{
 			uint32_t reg_data = 0;
@@ -176,7 +176,7 @@ static void program_gamut_remap(
 				GAMUT_REMAP_C31_C32,
 				GAMUT_REMAP_C32);
 
-			dal_write_reg(ctx, addr, reg_data);
+			dm_write_reg(ctx, addr, reg_data);
 		}
 		{
 			uint32_t reg_data = 0;
@@ -196,7 +196,7 @@ static void program_gamut_remap(
 				GAMUT_REMAP_C33_C34,
 				GAMUT_REMAP_C34);
 
-			dal_write_reg(ctx, addr, reg_data);
+			dm_write_reg(ctx, addr, reg_data);
 		}
 
 		set_reg_field_value(
@@ -213,7 +213,7 @@ static void program_gamut_remap(
 			GRPH_GAMUT_REMAP_MODE);
 
 	addr = DCP_REG(mmGAMUT_REMAP_CONTROL);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
index 4ba14c2..7c15a13 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -45,7 +45,7 @@ static void disable_enhanced_sharpness(struct dce110_transform *xfm110)
 {
 	uint32_t  value;
 
-	value = dal_read_reg(xfm110->base.ctx,
+	value = dm_read_reg(xfm110->base.ctx,
 			SCL_REG(mmSCL_F_SHARP_CONTROL));
 
 	set_reg_field_value(value, 0,
@@ -60,7 +60,7 @@ static void disable_enhanced_sharpness(struct dce110_transform *xfm110)
 	set_reg_field_value(value, 0,
 			SCL_F_SHARP_CONTROL, SCL_VF_SHARP_SCALE_FACTOR);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			SCL_REG(mmSCL_F_SHARP_CONTROL), value);
 }
 
@@ -89,7 +89,7 @@ static bool setup_scaling_configuration(
 
 	{
 		addr = SCL_REG(mmSCL_MODE);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		if (data->dal_pixel_format <= PIXEL_FORMAT_GRPH_END)
 			set_reg_field_value(value, 1, SCL_MODE, SCL_MODE);
@@ -98,11 +98,11 @@ static bool setup_scaling_configuration(
 
 		set_reg_field_value(value, 1, SCL_MODE, SCL_PSCL_EN);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		addr = SCL_REG(mmSCL_TAP_CONTROL);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(value, data->taps.h_taps - 1,
 				SCL_TAP_CONTROL, SCL_H_NUM_OF_TAPS);
@@ -110,16 +110,16 @@ static bool setup_scaling_configuration(
 		set_reg_field_value(value, data->taps.v_taps - 1,
 				SCL_TAP_CONTROL, SCL_V_NUM_OF_TAPS);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	{
 		addr = SCL_REG(mmSCL_CONTROL);
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 		 /* 1 - Replaced out of bound pixels with edge */
 		set_reg_field_value(value, 1, SCL_CONTROL, SCL_BOUNDARY_MODE);
 
 		/* 1 - Replaced out of bound pixels with the edge pixel. */
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	return true;
@@ -154,11 +154,11 @@ static void program_overscan(
 	set_reg_field_value(overscan_top_bottom, overscan->bottom,
 			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			SCL_REG(mmEXT_OVERSCAN_LEFT_RIGHT),
 			overscan_left_right);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			SCL_REG(mmEXT_OVERSCAN_TOP_BOTTOM),
 			overscan_top_bottom);
 }
@@ -175,7 +175,7 @@ static void program_two_taps_filter(
 	 */
 	if (vertical) {
 		addr = SCL_REG(mmSCL_VERT_FILTER_CONTROL);
-		value = dal_read_reg(xfm110->base.ctx, addr);
+		value = dm_read_reg(xfm110->base.ctx, addr);
 		set_reg_field_value(
 			value,
 			enable ? 1 : 0,
@@ -184,7 +184,7 @@ static void program_two_taps_filter(
 
 	} else {
 		addr = SCL_REG(mmSCL_HORZ_FILTER_CONTROL);
-		value = dal_read_reg(xfm110->base.ctx, addr);
+		value = dm_read_reg(xfm110->base.ctx, addr);
 		set_reg_field_value(
 			value,
 			enable ? 1 : 0,
@@ -192,7 +192,7 @@ static void program_two_taps_filter(
 			SCL_H_2TAP_HARDCODE_COEF_EN);
 	}
 
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 }
 
 static void set_coeff_update_complete(struct dce110_transform *xfm110)
@@ -200,10 +200,10 @@ static void set_coeff_update_complete(struct dce110_transform *xfm110)
 	uint32_t value;
 	uint32_t addr = SCL_REG(mmSCL_UPDATE);
 
-	value = dal_read_reg(xfm110->base.ctx, addr);
+	value = dm_read_reg(xfm110->base.ctx, addr);
 	set_reg_field_value(value, 1,
 			SCL_UPDATE, SCL_COEF_UPDATE_COMPLETE);
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 }
 
 static void program_filter(
@@ -231,30 +231,30 @@ static void program_filter(
 	uint32_t pwr_ctrl_off;
 
 	addr = DCFE_REG(mmDCFE_MEM_PWR_CTRL);
-	pwr_ctrl_orig = dal_read_reg(xfm110->base.ctx, addr);
+	pwr_ctrl_orig = dm_read_reg(xfm110->base.ctx, addr);
 	pwr_ctrl_off = pwr_ctrl_orig;
 	set_reg_field_value(
 		pwr_ctrl_off,
 		1,
 		DCFE_MEM_PWR_CTRL,
 		SCL_COEFF_MEM_PWR_DIS);
-	dal_write_reg(xfm110->base.ctx, addr, pwr_ctrl_off);
+	dm_write_reg(xfm110->base.ctx, addr, pwr_ctrl_off);
 
 	addr = DCFE_REG(mmDCFE_MEM_PWR_STATUS);
 	/* Wait to disable gating: */
 	for (i = 0;
 		i < 10 &&
 		get_reg_field_value(
-			dal_read_reg(xfm110->base.ctx, addr),
+			dm_read_reg(xfm110->base.ctx, addr),
 			DCFE_MEM_PWR_STATUS,
 			SCL_COEFF_MEM_PWR_STATE);
 		i++)
-		dc_service_delay_in_microseconds(xfm110->base.ctx, 1);
+		dm_delay_in_microseconds(xfm110->base.ctx, 1);
 
 	ASSERT(i < 10);
 
 	select_addr = SCL_REG(mmSCL_COEF_RAM_SELECT);
-	select = dal_read_reg(xfm110->base.ctx, select_addr);
+	select = dm_read_reg(xfm110->base.ctx, select_addr);
 
 	set_reg_field_value(
 		select,
@@ -292,7 +292,7 @@ static void program_filter(
 				pair,
 				SCL_COEF_RAM_SELECT,
 				SCL_C_RAM_TAP_PAIR_IDX);
-			dal_write_reg(xfm110->base.ctx, select_addr, select);
+			dm_write_reg(xfm110->base.ctx, select_addr, select);
 
 			/* even tap write enable */
 			set_reg_field_value(
@@ -341,7 +341,7 @@ static void program_filter(
 				array_idx += 2;
 			}
 
-			dal_write_reg(
+			dm_write_reg(
 				xfm110->base.ctx,
 				SCL_REG(mmSCL_COEF_RAM_TAP_DATA),
 				data);
@@ -351,7 +351,7 @@ static void program_filter(
 	ASSERT(coeffs_num == array_idx);
 
 	/* reset the power gating register */
-	dal_write_reg(
+	dm_write_reg(
 		xfm110->base.ctx,
 		DCFE_REG(mmDCFE_MEM_PWR_CTRL),
 		pwr_ctrl_orig);
@@ -505,7 +505,7 @@ static void program_viewport(
 	uint32_t addr = 0;
 
 	addr = SCL_REG(mmVIEWPORT_START);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		view_port->x,
@@ -516,10 +516,10 @@ static void program_viewport(
 		view_port->y,
 		VIEWPORT_START,
 		VIEWPORT_Y_START);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = SCL_REG(mmVIEWPORT_SIZE);
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		view_port->height,
@@ -530,7 +530,7 @@ static void program_viewport(
 		view_port->width,
 		VIEWPORT_SIZE,
 		VIEWPORT_WIDTH);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	/* TODO: add stereo support */
 }
@@ -598,7 +598,7 @@ static void program_scl_ratios_inits(
 		inits->h_int_scale_ratio,
 		SCL_HORZ_FILTER_SCALE_RATIO,
 		SCL_H_SCALE_RATIO);
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 
 	addr = SCL_REG(mmSCL_VERT_FILTER_SCALE_RATIO);
 	value = 0;
@@ -607,7 +607,7 @@ static void program_scl_ratios_inits(
 		inits->v_int_scale_ratio,
 		SCL_VERT_FILTER_SCALE_RATIO,
 		SCL_V_SCALE_RATIO);
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 
 	addr = SCL_REG(mmSCL_HORZ_FILTER_INIT);
 	value = 0;
@@ -621,7 +621,7 @@ static void program_scl_ratios_inits(
 		inits->h_init.fraction,
 		SCL_HORZ_FILTER_INIT,
 		SCL_H_INIT_FRAC);
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 
 	addr = SCL_REG(mmSCL_VERT_FILTER_INIT);
 	value = 0;
@@ -635,7 +635,7 @@ static void program_scl_ratios_inits(
 		inits->v_init.fraction,
 		SCL_VERT_FILTER_INIT,
 		SCL_V_INIT_FRAC);
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 
 	if (inits->bottom_enable) {
 		addr = SCL_REG(mmSCL_VERT_FILTER_INIT_BOT);
@@ -650,7 +650,7 @@ static void program_scl_ratios_inits(
 			inits->v_init_bottom.fraction,
 			SCL_VERT_FILTER_INIT_BOT,
 			SCL_V_INIT_FRAC_BOT);
-		dal_write_reg(xfm110->base.ctx, addr, value);
+		dm_write_reg(xfm110->base.ctx, addr, value);
 	}
 
 	addr = SCL_REG(mmSCL_AUTOMATIC_MODE_CONTROL);
@@ -665,7 +665,7 @@ static void program_scl_ratios_inits(
 		0,
 		SCL_AUTOMATIC_MODE_CONTROL,
 		SCL_H_CALC_AUTO_RATIO_EN);
-	dal_write_reg(xfm110->base.ctx, addr, value);
+	dm_write_reg(xfm110->base.ctx, addr, value);
 }
 
 static void get_viewport(
@@ -678,8 +678,8 @@ static void get_viewport(
 	if (current_view_port == NULL)
 		return;
 
-	value_start = dal_read_reg(xfm110->base.ctx, SCL_REG(mmVIEWPORT_START));
-	value_size = dal_read_reg(xfm110->base.ctx, SCL_REG(mmVIEWPORT_SIZE));
+	value_start = dm_read_reg(xfm110->base.ctx, SCL_REG(mmVIEWPORT_START));
+	value_size = dm_read_reg(xfm110->base.ctx, SCL_REG(mmVIEWPORT_SIZE));
 
 	current_view_port->x = get_reg_field_value(
 			value_start,
@@ -710,14 +710,14 @@ bool dce110_transform_set_scaler(
 
 	{
 		uint32_t addr = SCL_REG(mmSCL_BYPASS_CONTROL);
-		uint32_t value = dal_read_reg(xfm->ctx, addr);
+		uint32_t value = dm_read_reg(xfm->ctx, addr);
 
 		set_reg_field_value(
 			value,
 			0,
 			SCL_BYPASS_CONTROL,
 			SCL_BYPASS_MODE);
-		dal_write_reg(xfm->ctx, addr, value);
+		dm_write_reg(xfm->ctx, addr, value);
 	}
 
 	disable_enhanced_sharpness(xfm110);
@@ -774,10 +774,10 @@ void dce110_transform_set_scaler_bypass(struct transform *xfm)
 
 	disable_enhanced_sharpness(xfm110);
 
-	sclv_mode = dal_read_reg(xfm->ctx, SCL_REG(mmSCL_MODE));
+	sclv_mode = dm_read_reg(xfm->ctx, SCL_REG(mmSCL_MODE));
 	set_reg_field_value(sclv_mode, 0, SCL_MODE, SCL_MODE);
 	set_reg_field_value(sclv_mode, 0, SCL_MODE, SCL_PSCL_EN);
-	dal_write_reg(xfm->ctx, SCL_REG(mmSCL_MODE), sclv_mode);
+	dm_write_reg(xfm->ctx, SCL_REG(mmSCL_MODE), sclv_mode);
 }
 
 bool dce110_transform_update_viewport(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_sclv.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_sclv.c
index 9b25ed7..1968296 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_sclv.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_sclv.c
@@ -22,7 +22,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -101,7 +101,7 @@ static void program_viewport(
 			luma_view_port->y,
 			SCLV_VIEWPORT_START,
 			VIEWPORT_Y_START);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 
 		addr = mmSCLV_VIEWPORT_SIZE;
 		value = 0;
@@ -115,7 +115,7 @@ static void program_viewport(
 			luma_view_port->width,
 			SCLV_VIEWPORT_SIZE,
 			VIEWPORT_WIDTH);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	if (chroma_view_port->width != 0 && chroma_view_port->height != 0) {
@@ -131,7 +131,7 @@ static void program_viewport(
 			chroma_view_port->y,
 			SCLV_VIEWPORT_START_C,
 			VIEWPORT_Y_START_C);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 
 		addr = mmSCLV_VIEWPORT_SIZE_C;
 		value = 0;
@@ -145,7 +145,7 @@ static void program_viewport(
 			chroma_view_port->width,
 			SCLV_VIEWPORT_SIZE_C,
 			VIEWPORT_WIDTH_C);
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 	/* TODO: add stereo support */
 }
@@ -211,10 +211,10 @@ static bool setup_scaling_configuration(
 		set_reg_field_value(value, 0, SCLV_MODE, SCL_MODE_C);
 		set_reg_field_value(value, 0, SCLV_MODE, SCL_PSCL_EN_C);
 	}
-	dal_write_reg(ctx, mmSCLV_MODE, value);
+	dm_write_reg(ctx, mmSCLV_MODE, value);
 
 	{
-		value = dal_read_reg(ctx, mmSCLV_TAP_CONTROL);
+		value = dm_read_reg(ctx, mmSCLV_TAP_CONTROL);
 
 		set_reg_field_value(value, data->taps.h_taps - 1,
 				SCLV_TAP_CONTROL, SCL_H_NUM_OF_TAPS);
@@ -228,19 +228,19 @@ static bool setup_scaling_configuration(
 		set_reg_field_value(value, data->taps.v_taps_c - 1,
 				SCLV_TAP_CONTROL, SCL_V_NUM_OF_TAPS_C);
 
-		dal_write_reg(ctx, mmSCLV_TAP_CONTROL, value);
+		dm_write_reg(ctx, mmSCLV_TAP_CONTROL, value);
 	}
 
 	{
 		/* we can ignore this register because we are ok with hw
 		 * default 0 -- change to 1 according to dal2 code*/
-		value = dal_read_reg(ctx, mmSCLV_CONTROL);
+		value = dm_read_reg(ctx, mmSCLV_CONTROL);
 		 /* 0 - Replaced out of bound pixels with black pixel
 		  * (or any other required color) */
 		set_reg_field_value(value, 1, SCLV_CONTROL, SCL_BOUNDARY_MODE);
 
 		/* 1 - Replaced out of bound pixels with the edge pixel. */
-		dal_write_reg(ctx, mmSCLV_CONTROL, value);
+		dm_write_reg(ctx, mmSCLV_CONTROL, value);
 	}
 
 	return is_scaling_needed;
@@ -275,11 +275,11 @@ static void program_overscan(
 	set_reg_field_value(overscan_top_bottom, overscan->bottom,
 		SCLV_EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			mmSCLV_EXT_OVERSCAN_LEFT_RIGHT,
 			overscan_left_right);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			mmSCLV_EXT_OVERSCAN_TOP_BOTTOM,
 			overscan_top_bottom);
 }
@@ -310,7 +310,7 @@ static void program_two_taps_filter_horz(
 				SCLV_HORZ_FILTER_CONTROL,
 				SCL_H_2TAP_HARDCODE_COEF_EN);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			mmSCLV_HORZ_FILTER_CONTROL,
 			value);
 }
@@ -325,7 +325,7 @@ static void program_two_taps_filter_vert(
 		set_reg_field_value(value, 1, SCLV_VERT_FILTER_CONTROL,
 				SCL_V_2TAP_HARDCODE_COEF_EN);
 
-	dal_write_reg(xfm110->base.ctx,
+	dm_write_reg(xfm110->base.ctx,
 			mmSCLV_VERT_FILTER_CONTROL,
 			value);
 }
@@ -384,58 +384,58 @@ static void program_scl_ratios_inits(
 {
 	struct dc_context *ctx = xfm110->base.ctx;
 	uint32_t addr = mmSCLV_HORZ_FILTER_SCALE_RATIO;
-	uint32_t value = dal_read_reg(ctx, addr);
+	uint32_t value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
 		inits->h_int_scale_ratio_luma,
 		SCLV_HORZ_FILTER_SCALE_RATIO,
 		SCL_H_SCALE_RATIO);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = mmSCLV_VERT_FILTER_SCALE_RATIO;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		inits->v_int_scale_ratio_luma,
 		SCLV_VERT_FILTER_SCALE_RATIO,
 		SCL_V_SCALE_RATIO);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = mmSCLV_HORZ_FILTER_SCALE_RATIO_C;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		inits->h_int_scale_ratio_chroma,
 		SCLV_HORZ_FILTER_SCALE_RATIO_C,
 		SCL_H_SCALE_RATIO_C);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 	addr = mmSCLV_VERT_FILTER_SCALE_RATIO_C;
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(
 		value,
 		inits->v_int_scale_ratio_chroma,
 		SCLV_VERT_FILTER_SCALE_RATIO_C,
 		SCL_V_SCALE_RATIO_C);
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 void dce110_transform_underlay_set_scalerv_bypass(struct transform *xfm)
 {
 	uint32_t addr = mmSCLV_MODE;
-	uint32_t value = dal_read_reg(xfm->ctx, addr);
+	uint32_t value = dm_read_reg(xfm->ctx, addr);
 
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_MODE);
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_MODE_C);
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_PSCL_EN);
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_PSCL_EN_C);
-	dal_write_reg(xfm->ctx, addr, value);
+	dm_write_reg(xfm->ctx, addr, value);
 }
 
 bool dce110_transform_underlay_is_scaling_enabled(struct transform *xfm)
 {
-	uint32_t value = dal_read_reg(xfm->ctx, mmSCLV_MODE);
+	uint32_t value = dm_read_reg(xfm->ctx, mmSCLV_MODE);
 	uint8_t scl_mode = get_reg_field_value(value, SCLV_MODE, SCL_MODE);
 
 	return scl_mode == 0;
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_helpers.h b/drivers/gpu/drm/amd/dal/dc/dm_helpers.h
new file mode 100644
index 0000000..b6ce510
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/dm_helpers.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+/**
+ * This file defines helper functions provided by the Display Manager to
+ * Display Core.
+ */
+#ifndef __DM_HELPERS__
+#define __DM_HELPERS__
+
+#include "dc_types.h"
+#include "dc.h"
+
+struct dp_mst_stream_allocation_table;
+
+enum dc_edid_status dm_helpers_parse_edid_caps(
+	struct dc_context *ctx,
+	const struct dc_edid *edid,
+	struct dc_edid_caps *edid_caps);
+
+/*
+ * Writes payload allocation table in immediate downstream device.
+ */
+bool dm_helpers_dp_mst_write_payload_allocation_table(
+		struct dc_context *ctx,
+		const struct dc_stream *stream,
+		struct dp_mst_stream_allocation_table *proposed_table,
+		bool enable);
+
+/*
+ * Polls for ACT (allocation change trigger) handled and
+ */
+bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
+		struct dc_context *ctx,
+		const struct dc_stream *stream);
+/*
+ * Sends ALLOCATE_PAYLOAD message.
+ */
+bool dm_helpers_dp_mst_send_payload_allocation(
+		struct dc_context *ctx,
+		const struct dc_stream *stream,
+		bool enable);
+
+void dm_helpers_dp_mst_handle_mst_hpd_rx_irq(
+		void *param);
+
+bool dm_helpers_dp_mst_start_top_mgr(
+		struct dc_context *ctx,
+		const struct dc_link *link,
+		bool boot);
+
+void dm_helpers_dp_mst_stop_top_mgr(
+		struct dc_context *ctx,
+		const struct dc_link *link);
+
+/**
+ * OS specific aux read callback.
+ */
+bool dm_helper_dp_read_dpcd(
+		struct dc_context *ctx,
+		const struct dc_link *link,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size);
+
+/**
+ * OS specific aux write callback.
+ */
+bool dm_helper_dp_write_dpcd(
+		struct dc_context *ctx,
+		const struct dc_link *link,
+		uint32_t address,
+		const uint8_t *data,
+		uint32_t size);
+
+#endif /* __DM_HELPERS__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services.h b/drivers/gpu/drm/amd/dal/dc/dm_services.h
new file mode 100644
index 0000000..4112eda
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services.h
@@ -0,0 +1,476 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+/**
+ * This file defines external dependencies of Display Core.
+ */
+
+#ifndef __DM_SERVICES_H__
+
+#define __DM_SERVICES_H__
+
+/* TODO: remove when DC is complete. */
+#include "dm_services_types.h"
+#include "logger_interface.h"
+#include "include/dal_types.h"
+#include "irq_types.h"
+#include "link_service_types.h"
+
+#undef DEPRECATED
+
+/* if the pointer is not NULL, the allocated memory is zeroed */
+void *dm_alloc(struct dc_context *ctx, uint32_t size);
+
+/* reallocate memory. The contents will remain unchanged.*/
+void *dm_realloc(struct dc_context *ctx, const void *ptr, uint32_t size);
+
+void dm_free(struct dc_context *ctx, void *p);
+
+void dm_memset(void *p, int32_t c, uint32_t count);
+
+void dm_memmove(void *dst, const void *src, uint32_t size);
+
+int32_t dm_memcmp(const void *p1, const void *p2, uint32_t count);
+
+int32_t dm_strncmp(const int8_t *p1, const int8_t *p2, uint32_t count);
+
+irq_handler_idx dm_register_interrupt(
+	struct dc_context *ctx,
+	struct dc_interrupt_params *int_params,
+	interrupt_handler ih,
+	void *handler_args);
+
+void dm_unregister_interrupt(
+	struct dc_context *ctx,
+	enum dc_irq_source irq_source,
+	irq_handler_idx handler_idx);
+
+/*
+ *
+ * GPU registers access
+ *
+ */
+static inline uint32_t dm_read_reg(
+	const struct dc_context *ctx,
+	uint32_t address)
+{
+	uint32_t value = cgs_read_register(ctx->cgs_device, address);
+
+#if defined(__DAL_REGISTER_LOGGER__)
+	if (true == dal_reg_logger_should_dump_register()) {
+		dal_reg_logger_rw_count_increment();
+		DRM_INFO("%s 0x%x 0x%x\n", __func__, address, value);
+	}
+#endif
+	return value;
+}
+
+static inline void dm_write_reg(
+	const struct dc_context *ctx,
+	uint32_t address,
+	uint32_t value)
+{
+#if defined(__DAL_REGISTER_LOGGER__)
+	if (true == dal_reg_logger_should_dump_register()) {
+		dal_reg_logger_rw_count_increment();
+		DRM_INFO("%s 0x%x 0x%x\n", __func__, address, value);
+	}
+#endif
+	cgs_write_register(ctx->cgs_device, address, value);
+}
+
+static inline uint32_t dm_read_index_reg(
+	const struct dc_context *ctx,
+	enum cgs_ind_reg addr_space,
+	uint32_t index)
+{
+	return cgs_read_ind_register(ctx->cgs_device, addr_space, index);
+}
+
+static inline void dm_write_index_reg(
+	const struct dc_context *ctx,
+	enum cgs_ind_reg addr_space,
+	uint32_t index,
+	uint32_t value)
+{
+	cgs_write_ind_register(ctx->cgs_device, addr_space, index, value);
+}
+
+static inline uint32_t get_reg_field_value_ex(
+	uint32_t reg_value,
+	uint32_t mask,
+	uint8_t shift)
+{
+	return (mask & reg_value) >> shift;
+}
+
+#define get_reg_field_value(reg_value, reg_name, reg_field)\
+	get_reg_field_value_ex(\
+		(reg_value),\
+		reg_name ## __ ## reg_field ## _MASK,\
+		reg_name ## __ ## reg_field ## __SHIFT)
+
+static inline uint32_t set_reg_field_value_ex(
+	uint32_t reg_value,
+	uint32_t value,
+	uint32_t mask,
+	uint8_t shift)
+{
+	return (reg_value & ~mask) | (mask & (value << shift));
+}
+
+#define set_reg_field_value(reg_value, value, reg_name, reg_field)\
+	(reg_value) = set_reg_field_value_ex(\
+		(reg_value),\
+		(value),\
+		reg_name ## __ ## reg_field ## _MASK,\
+		reg_name ## __ ## reg_field ## __SHIFT)
+
+/*
+ * atombios services
+ */
+
+bool dm_exec_bios_cmd_table(
+	struct dc_context *ctx,
+	uint32_t index,
+	void *params);
+
+#ifdef BUILD_DAL_TEST
+uint32_t dm_bios_cmd_table_para_revision(
+struct dc_context *ctx,
+	uint32_t index);
+
+bool dm_bios_cmd_table_revision(
+	struct dc_context *ctx,
+	uint32_t index,
+	uint8_t *frev,
+	uint8_t *crev);
+#endif
+
+#ifndef BUILD_DAL_TEST
+static inline uint32_t dm_bios_cmd_table_para_revision(
+	struct dc_context *ctx,
+	uint32_t index)
+{
+	uint8_t frev;
+	uint8_t crev;
+
+	if (cgs_atom_get_cmd_table_revs(
+			ctx->cgs_device,
+			index,
+			&frev,
+			&crev) != 0)
+		return 0;
+
+	return crev;
+}
+#else
+uint32_t dm_bios_cmd_table_para_revision(
+		struct dc_context *ctx,
+		uint32_t index);
+#endif
+
+/**************************************
+ * Power Play (PP) interfaces
+ **************************************/
+
+enum dal_to_power_clocks_state {
+	PP_CLOCKS_STATE_INVALID,
+	PP_CLOCKS_STATE_ULTRA_LOW,
+	PP_CLOCKS_STATE_LOW,
+	PP_CLOCKS_STATE_NOMINAL,
+	PP_CLOCKS_STATE_PERFORMANCE
+};
+
+/* clocks in khz */
+struct dal_to_power_info {
+	enum dal_to_power_clocks_state required_clock;
+	uint32_t min_sclk;
+	uint32_t min_mclk;
+	uint32_t min_deep_sleep_sclk;
+};
+
+/* clocks in khz */
+struct power_to_dal_info {
+	uint32_t min_sclk;
+	uint32_t max_sclk;
+	uint32_t min_mclk;
+	uint32_t max_mclk;
+};
+
+/* clocks in khz */
+struct dal_system_clock_range {
+	uint32_t min_sclk;
+	uint32_t max_sclk;
+
+	uint32_t min_mclk;
+	uint32_t max_mclk;
+
+	uint32_t min_dclk;
+	uint32_t max_dclk;
+
+	/* Wireless Display */
+	uint32_t min_eclk;
+	uint32_t max_eclk;
+};
+
+/* clocks in khz */
+struct dal_to_power_dclk {
+	uint32_t optimal; /* input: best optimizes for stutter efficiency */
+	uint32_t minimal; /* input: the lowest clk that DAL can support */
+	uint32_t established; /* output: the actually set one */
+};
+
+/* DAL calls this function to notify PP about clocks it needs for the Mode Set.
+ * This is done *before* it changes DCE clock.
+ *
+ * If required clock is higher than current, then PP will increase the voltage.
+ *
+ * If required clock is lower than current, then PP will defer reduction of
+ * voltage until the call to dc_service_pp_post_dce_clock_change().
+ *
+ * \input - Contains clocks needed for Mode Set.
+ *
+ * \output - Contains clocks adjusted by PP which DAL should use for Mode Set.
+ *		Valid only if function returns zero.
+ *
+ * \returns	true - call is successful
+ *		false - call failed
+ */
+bool dm_pp_pre_dce_clock_change(
+	struct dc_context *ctx,
+	struct dal_to_power_info *input,
+	struct power_to_dal_info *output);
+
+struct dc_pp_single_disp_config {
+	enum signal_type signal;
+	uint8_t transmitter;
+	uint8_t ddi_channel_mapping;
+	uint8_t pipe_idx;
+	uint32_t src_height;
+	uint32_t src_width;
+	uint32_t v_refresh;
+	uint32_t sym_clock; /* HDMI only */
+	struct link_settings link_settings; /* DP only */
+};
+
+struct dc_pp_display_configuration {
+	bool nb_pstate_switch_disable;/* controls NB PState switch */
+	bool cpu_cc6_disable; /* controls CPU CState switch ( on or off) */
+	bool cpu_pstate_disable;
+	uint32_t cpu_pstate_separation_time;
+
+	uint32_t min_memory_clock_khz;
+	uint32_t min_engine_clock_khz;
+	uint32_t min_engine_clock_deep_sleep_khz;
+
+	uint32_t avail_mclk_switch_time_us;
+	uint32_t avail_mclk_switch_time_in_disp_active_us;
+
+	uint32_t disp_clk_khz;
+
+	bool all_displays_in_sync;
+
+	uint8_t display_count;
+	struct dc_pp_single_disp_config disp_configs[3];
+
+	/*Controller Index of primary display - used in MCLK SMC switching hang
+	 * SW Workaround*/
+	uint8_t crtc_index;
+	/*htotal*1000/pixelclk - used in MCLK SMC switching hang SW Workaround*/
+	uint32_t line_time_in_us;
+};
+
+enum dc_pp_clocks_state {
+	DC_PP_CLOCKS_STATE_INVALID = 0,
+	DC_PP_CLOCKS_STATE_ULTRA_LOW,
+	DC_PP_CLOCKS_STATE_LOW,
+	DC_PP_CLOCKS_STATE_NOMINAL,
+	DC_PP_CLOCKS_STATE_PERFORMANCE,
+
+	/* Starting from DCE11, Max 8 levels of DPM state supported. */
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_INVALID = DC_PP_CLOCKS_STATE_INVALID,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_0 = DC_PP_CLOCKS_STATE_ULTRA_LOW,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_1 = DC_PP_CLOCKS_STATE_LOW,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_2 = DC_PP_CLOCKS_STATE_NOMINAL,
+	/* to be backward compatible */
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_3 = DC_PP_CLOCKS_STATE_PERFORMANCE,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_4 = DC_PP_CLOCKS_DPM_STATE_LEVEL_3 + 1,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_5 = DC_PP_CLOCKS_DPM_STATE_LEVEL_4 + 1,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_6 = DC_PP_CLOCKS_DPM_STATE_LEVEL_5 + 1,
+	DC_PP_CLOCKS_DPM_STATE_LEVEL_7 = DC_PP_CLOCKS_DPM_STATE_LEVEL_6 + 1,
+};
+
+struct dc_pp_static_clock_info {
+	uint32_t max_sclk_khz;
+	uint32_t max_mclk_khz;
+
+	 /* max possible display block clocks state */
+	enum dc_pp_clocks_state max_clocks_state;
+};
+
+/* The returned clocks range are 'static' system clocks which will be used for
+ * mode validation purposes.
+ *
+ * \returns	true - call is successful
+ *		false - call failed
+ */
+bool dc_service_get_system_clocks_range(
+	const struct dc_context *ctx,
+	struct dal_system_clock_range *sys_clks);
+
+enum dc_pp_clock_type {
+	DC_PP_CLOCK_TYPE_DISPLAY_CLK = 1,
+	DC_PP_CLOCK_TYPE_ENGINE_CLK, /* System clock */
+	DC_PP_CLOCK_TYPE_MEMORY_CLK
+};
+
+#define DC_DECODE_PP_CLOCK_TYPE(clk_type) \
+	(clk_type) == DC_PP_CLOCK_TYPE_DISPLAY_CLK ? "Display" : \
+	(clk_type) == DC_PP_CLOCK_TYPE_ENGINE_CLK ? "Engine" : \
+	(clk_type) == DC_PP_CLOCK_TYPE_MEMORY_CLK ? "Memory" : "Invalid"
+
+#define DC_PP_MAX_CLOCK_LEVELS 8
+
+struct dc_pp_clock_levels {
+	uint32_t num_levels;
+	uint32_t clocks_in_khz[DC_PP_MAX_CLOCK_LEVELS];
+};
+
+/* Gets valid clocks levels from pplib
+ *
+ * input: clk_type - display clk / sclk / mem clk
+ *
+ * output: array of valid clock levels for given type in ascending order,
+ * with invalid levels filtered out
+ *
+ */
+bool dm_pp_get_clock_levels_by_type(
+	const struct dc_context *ctx,
+	enum dc_pp_clock_type clk_type,
+	struct dc_pp_clock_levels *clk_level_info);
+
+
+bool dm_pp_apply_safe_state(
+		const struct dc_context *ctx);
+
+/* DAL calls this function to notify PP about completion of Mode Set.
+ * For PP it means that current DCE clocks are those which were returned
+ * by dc_service_pp_pre_dce_clock_change(), in the 'output' parameter.
+ *
+ * If the clocks are higher than before, then PP does nothing.
+ *
+ * If the clocks are lower than before, then PP reduces the voltage.
+ *
+ * \returns	true - call is successful
+ *		false - call failed
+ */
+bool dm_pp_apply_display_requirements(
+	const struct dc_context *ctx,
+	const struct dc_pp_display_configuration *pp_display_cfg);
+
+
+/****** end of PP interfaces ******/
+
+void dm_sleep_in_milliseconds(struct dc_context *ctx, uint32_t milliseconds);
+
+void dm_delay_in_microseconds(struct dc_context *ctx, uint32_t microseconds);
+
+enum platform_method {
+	PM_GET_AVAILABLE_METHODS = 1 << 0,
+	PM_GET_LID_STATE = 1 << 1,
+	PM_GET_EXTENDED_BRIGHNESS_CAPS = 1 << 2
+};
+
+struct platform_info_params {
+	enum platform_method method;
+	void *data;
+};
+
+struct platform_info_brightness_caps {
+	uint8_t ac_level_percentage;
+	uint8_t dc_level_percentage;
+};
+
+struct platform_info_ext_brightness_caps {
+	struct platform_info_brightness_caps basic_caps;
+	struct data_point {
+		uint8_t luminance;
+		uint8_t	signal_level;
+	} data_points[99];
+
+	uint8_t	data_points_num;
+	uint8_t	min_input_signal;
+	uint8_t	max_input_signal;
+};
+
+bool dm_get_platform_info(
+	struct dc_context *ctx,
+	struct platform_info_params *params);
+
+/*
+ *
+ * print-out services
+ *
+ */
+#define dm_log_to_buffer(buffer, size, fmt, args)\
+	vsnprintf(buffer, size, fmt, args)
+
+long dm_get_pid(void);
+long dm_get_tgid(void);
+
+/*
+ *
+ * general debug capabilities
+ *
+ */
+#if defined(CONFIG_DEBUG_KERNEL) || defined(CONFIG_DEBUG_DRIVER)
+
+#if defined(CONFIG_HAVE_KGDB) || defined(CONFIG_KGDB)
+#define ASSERT_CRITICAL(expr) do {	\
+	if (WARN_ON(!(expr))) { \
+		kgdb_breakpoint(); \
+	} \
+} while (0)
+#else
+#define ASSERT_CRITICAL(expr) do {	\
+	if (WARN_ON(!(expr))) { \
+		; \
+	} \
+} while (0)
+#endif
+
+#if defined(CONFIG_DEBUG_KERNEL_DAL)
+#define ASSERT(expr) ASSERT_CRITICAL(expr)
+
+#else
+#define ASSERT(expr) WARN_ON(!(expr))
+#endif
+
+#define BREAK_TO_DEBUGGER() ASSERT(0)
+
+#endif /* CONFIG_DEBUG_KERNEL || CONFIG_DEBUG_DRIVER */
+
+#endif /* __DM_SERVICES_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
new file mode 100644
index 0000000..bc458aa
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DM_SERVICES_TYPES_H__
+#define __DM_SERVICES_TYPES_H__
+
+#define INVALID_DISPLAY_INDEX 0xffffffff
+
+#if defined __KERNEL__
+
+#include <asm/byteorder.h>
+#include <linux/types.h>
+#include <drm/drmP.h>
+
+#include "cgs_linux.h"
+
+#if defined(__BIG_ENDIAN) && !defined(BIGENDIAN_CPU)
+#define BIGENDIAN_CPU
+#elif defined(__LITTLE_ENDIAN) && !defined(LITTLEENDIAN_CPU)
+#define LITTLEENDIAN_CPU
+#endif
+
+#undef READ
+#undef WRITE
+#undef FRAME_SIZE
+
+#define dm_output_to_console(fmt, ...) DRM_INFO(fmt, ##__VA_ARGS__)
+
+#define dm_error(fmt, ...) DRM_ERROR(fmt, ##__VA_ARGS__)
+
+#define dm_debug(fmt, ...) DRM_DEBUG_KMS(fmt, ##__VA_ARGS__)
+
+#define dm_vlog(fmt, args) vprintk(fmt, args)
+
+#define dm_min(x, y) min(x, y)
+#define dm_max(x, y) max(x, y)
+
+#elif defined BUILD_DAL_TEST
+
+#include <inttypes.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <stdio.h>
+
+#include <stdarg.h>
+
+#include "cgs_linux.h"
+
+#define LONG_MAX	((long)(~0UL>>1))
+#define LONG_MIN	(-LONG_MAX - 1)
+#define LLONG_MAX	((long long)(~0ULL>>1))
+#define LLONG_MIN	(-LLONG_MAX - 1)
+#define UINT_MAX	(~0U)
+
+typedef _Bool bool;
+enum { false, true };
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#define LITTLEENDIAN_CPU 1
+
+#include <test_context.h>
+
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+#define container_of(ptr, type, member) \
+	((type *)((char *)(ptr) - offsetof(type, member)))
+
+#define dal_test_not_implemented() \
+	printf("[DAL_TEST_NOT_IMPL]:%s\n", __func__)
+
+#define dm_output_to_console(fmt, ...) do { \
+	printf("[DAL_LOG]" fmt, ##__VA_ARGS__); } \
+	while (false)
+
+#define dm_error(fmt, ...) printf("[DAL_ERROR]" fmt, ##__VA_ARGS__)
+
+#define dm_output_to_console(fmt, ...) do { \
+			printf("[DAL_LOG]" fmt, ##__VA_ARGS__); } \
+				while (false)
+
+
+#define dm_debug(fmt, ...) printf("[DAL_DBG]" fmt, ##__VA_ARGS__)
+
+#define dm_vlog(fmt, args) vprintf(fmt, args)
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+#define dm_min(x, y) ({\
+	typeof(x) _min1 = (x);\
+	typeof(y) _min2 = (y);\
+	(void) (&_min1 == &_min2);\
+	_min1 < _min2 ? _min1 : _min2; })
+
+#define dm_max(x, y) ({\
+	typeof(x) _max1 = (x);\
+	typeof(y) _max2 = (y);\
+	(void) (&_max1 == &_max2);\
+	_max1 > _max2 ? _max1 : _max2; })
+
+/* division functions */
+
+static inline int64_t div64_s64(int64_t x, int64_t y)
+{
+	return x / y;
+}
+
+static inline uint64_t div64_u64(uint64_t x, uint64_t y)
+{
+	return x / y;
+}
+
+static inline uint64_t div_u64(uint64_t x, uint32_t y)
+{
+	return x / y;
+}
+
+static inline uint64_t div64_u64_rem(uint64_t x, uint64_t y, uint64_t *rem)
+{
+	if (rem)
+		*rem = x % y;
+	return x / y;
+}
+
+static inline uint64_t div_u64_rem(uint64_t x, uint32_t y, uint32_t *rem)
+{
+	if (rem)
+		*rem = x % y;
+	return x / y;
+}
+
+#define cpu_to_le16(do_nothing) do_nothing
+
+#define le16_to_cpu(do_nothing) do_nothing
+
+#define cpu_to_le32(do_nothing) do_nothing
+
+#define le32_to_cpu(do_nothing) do_nothing
+
+#endif
+
+#endif
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
index b8554aa..8ff899c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "../hw_gpio_pin.h"
 #include "../hw_gpio.h"
@@ -63,7 +62,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dc_service_free((*ptr)->ctx, pin);
+	dm_free((*ptr)->ctx, pin);
 
 	*ptr = NULL;
 }
@@ -602,7 +601,7 @@ static void setup_i2c_polling(
 {
 	uint32_t value;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -623,7 +622,7 @@ static void setup_i2c_polling(
 			DC_I2C_DDC1_SETUP,
 			DC_I2C_DDC1_EDID_DETECT_MODE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static enum gpio_result set_config(
@@ -649,7 +648,7 @@ static enum gpio_result set_config(
 
 	addr = hw_gpio->pin_reg.DC_GPIO_DATA_MASK.addr;
 
-	regval = dal_read_reg(ptr->ctx, addr);
+	regval = dm_read_reg(ptr->ctx, addr);
 
 	ddc_data_pd_en = get_reg_field_value(
 			regval,
@@ -686,14 +685,14 @@ static enum gpio_result set_config(
 					DC_GPIO_DDC1_MASK,
 					DC_GPIO_DDC1CLK_PD_EN);
 
-				dal_write_reg(ptr->ctx, addr, regval);
+				dm_write_reg(ptr->ctx, addr, regval);
 
 				if (config_data->type ==
 					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
 					/* should not affect normal I2C R/W */
 					/* [anaumov] in DAL2, there was
 					 * dc_service_delay_in_microseconds(2500); */
-					dc_service_sleep_in_milliseconds(ptr->ctx, 3);
+					dm_sleep_in_milliseconds(ptr->ctx, 3);
 			}
 		} else {
 			uint32_t reg2 = regval;
@@ -713,27 +712,27 @@ static enum gpio_result set_config(
 			if (sda_pd_dis) {
 				sda_pd_dis = 0;
 
-				dal_write_reg(ptr->ctx, addr, reg2);
+				dm_write_reg(ptr->ctx, addr, reg2);
 
 				if (config_data->type ==
 					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
 					/* should not affect normal I2C R/W */
 					/* [anaumov] in DAL2, there was
 					 * dc_service_delay_in_microseconds(2500); */
-					dc_service_sleep_in_milliseconds(ptr->ctx, 3);
+					dm_sleep_in_milliseconds(ptr->ctx, 3);
 			}
 
 			if (!scl_pd_dis) {
 				scl_pd_dis = 1;
 
-				dal_write_reg(ptr->ctx, addr, reg2);
+				dm_write_reg(ptr->ctx, addr, reg2);
 
 				if (config_data->type ==
 					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
 					/* should not affect normal I2C R/W */
 					/* [anaumov] in DAL2, there was
 					 * dc_service_delay_in_microseconds(2500); */
-					dc_service_sleep_in_milliseconds(ptr->ctx, 3);
+					dm_sleep_in_milliseconds(ptr->ctx, 3);
 			}
 		}
 
@@ -744,12 +743,12 @@ static enum gpio_result set_config(
 				config_data->config.ddc.clock_en_bit_present)
 				/* [anaumov] in DAL2, there was
 				 * dc_service_delay_in_microseconds(2000); */
-				dc_service_sleep_in_milliseconds(ptr->ctx, 2);
+				dm_sleep_in_milliseconds(ptr->ctx, 2);
 
 			/* set the I2C pad mode */
 			/* read the register again,
 			 * some bits may have been changed */
-			regval = dal_read_reg(ptr->ctx, addr);
+			regval = dm_read_reg(ptr->ctx, addr);
 
 			set_reg_field_value(
 				regval,
@@ -757,7 +756,7 @@ static enum gpio_result set_config(
 				DC_GPIO_DDC1_MASK,
 				AUX_PAD1_MODE);
 
-			dal_write_reg(ptr->ctx, addr, regval);
+			dm_write_reg(ptr->ctx, addr, regval);
 		}
 
 		return GPIO_RESULT_OK;
@@ -770,7 +769,7 @@ static enum gpio_result set_config(
 				DC_GPIO_DDC1_MASK,
 				AUX_PAD1_MODE);
 
-			dal_write_reg(ptr->ctx, addr, regval);
+			dm_write_reg(ptr->ctx, addr, regval);
 		}
 
 		return GPIO_RESULT_OK;
@@ -865,7 +864,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc_dce110 *pin = dc_service_alloc(ctx, sizeof(struct hw_ddc_dce110));
+	struct hw_ddc_dce110 *pin = dm_alloc(ctx, sizeof(struct hw_ddc_dce110));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -877,7 +876,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, pin);
+	dm_free(ctx, pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c
index 6a9ee1a..bdeb601 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c
@@ -27,7 +27,7 @@
  * Pre-requisites: headers required by header of this unit
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/gpio_types.h"
 #include "../hw_factory.h"
 
@@ -41,6 +41,7 @@
 #include "../hw_hpd.h"
 
 #include "hw_factory_dce110.h"
+
 #include "hw_hpd_dce110.h"
 #include "hw_ddc_dce110.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
index e427f2c..a90115c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "../hw_gpio_pin.h"
 #include "../hw_gpio.h"
@@ -62,7 +61,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dc_service_free((*ptr)->ctx, pin);
+	dm_free((*ptr)->ctx, pin);
 
 	*ptr = NULL;
 }
@@ -239,7 +238,7 @@ static enum gpio_result get_value(
 		uint32_t hpd_delayed = 0;
 		uint32_t hpd_sense = 0;
 
-		regval = dal_read_reg(
+		regval = dm_read_reg(
 				ptr->ctx,
 				pin->addr.DC_HPD_INT_STATUS);
 
@@ -274,7 +273,7 @@ static enum gpio_result set_config(
 	{
 		uint32_t value;
 
-		value = dal_read_reg(
+		value = dm_read_reg(
 			ptr->ctx,
 			pin->addr.DC_HPD_TOGGLE_FILT_CNTL);
 
@@ -290,7 +289,7 @@ static enum gpio_result set_config(
 			DC_HPD_TOGGLE_FILT_CNTL,
 			DC_HPD_DISCONNECT_INT_DELAY);
 
-		dal_write_reg(
+		dm_write_reg(
 			ptr->ctx,
 			pin->addr.DC_HPD_TOGGLE_FILT_CNTL,
 			value);
@@ -349,7 +348,7 @@ struct hw_gpio_pin *dal_hw_hpd_dce110_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_hpd_dce110 *pin = dc_service_alloc(ctx, sizeof(struct hw_hpd_dce110));
+	struct hw_hpd_dce110 *pin = dm_alloc(ctx, sizeof(struct hw_hpd_dce110));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -361,7 +360,7 @@ struct hw_gpio_pin *dal_hw_hpd_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, pin);
+	dm_free(ctx, pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_translate_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_translate_dce110.c
index 0c87515..b058f4d 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_translate_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_translate_dce110.c
@@ -27,7 +27,7 @@
  * Pre-requisites: headers required by header of this unit
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/gpio_types.h"
 #include "../hw_translate.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c b/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
index ee6a0b0..c3d8cdb 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
@@ -27,7 +27,7 @@
  * Pre-requisites: headers required by header of this unit
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/gpio_interface.h"
 #include "include/ddc_interface.h"
@@ -229,7 +229,7 @@ struct ddc *dal_gpio_create_ddc(
 	if (!service->translate.funcs->offset_to_id(offset, mask, &id, &en))
 		return NULL;
 
-	ddc = dc_service_alloc(service->ctx, sizeof(struct ddc));
+	ddc = dm_alloc(service->ctx, sizeof(struct ddc));
 
 	if (!ddc) {
 		BREAK_TO_DEBUGGER();
@@ -262,7 +262,7 @@ failure_2:
 	dal_gpio_service_destroy_gpio(&ddc->pin_data);
 
 failure_1:
-	dc_service_free(service->ctx, ddc);
+	dm_free(service->ctx, ddc);
 
 	return NULL;
 }
@@ -284,7 +284,7 @@ void dal_gpio_destroy_ddc(
 	}
 
 	destruct(*ddc);
-	dc_service_free((*ddc)->ctx, *ddc);
+	dm_free((*ddc)->ctx, *ddc);
 
 	*ddc = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c
index 282f1fc..1dd31d8 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "../hw_gpio_pin.h"
 #include "../hw_gpio.h"
@@ -50,7 +49,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dc_service_free((*ptr)->ctx, pin);
+	dm_free((*ptr)->ctx, pin);
 
 	*ptr = NULL;
 }
@@ -80,7 +79,7 @@ struct hw_gpio_pin *dal_hw_ddc_diag_fpga_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc *pin = dc_service_alloc(ctx, sizeof(struct hw_ddc));
+	struct hw_ddc *pin = dm_alloc(ctx, sizeof(struct hw_ddc));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -92,7 +91,7 @@ struct hw_gpio_pin *dal_hw_ddc_diag_fpga_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, pin);
+	dm_free(ctx, pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_factory_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_factory_diag.c
index 2349bf7..0690b42 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_factory_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_factory_diag.c
@@ -27,7 +27,7 @@
  * Pre-requisites: headers required by header of this unit
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/gpio_types.h"
 #include "../hw_factory.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c
index f47e56a..019e810 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "../hw_gpio_pin.h"
 #include "../hw_gpio.h"
@@ -48,7 +47,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dc_service_free((*ptr)->ctx, pin);
+	dm_free((*ptr)->ctx, pin);
 
 	*ptr = NULL;
 }
@@ -84,7 +83,7 @@ struct hw_gpio_pin *dal_hw_hpd_diag_fpga_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_hpd *pin = dc_service_alloc(ctx, sizeof(struct hw_hpd));
+	struct hw_hpd *pin = dm_alloc(ctx, sizeof(struct hw_hpd));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -96,7 +95,7 @@ struct hw_gpio_pin *dal_hw_hpd_diag_fpga_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, pin);
+	dm_free(ctx, pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c
index cfcd197..177330a 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c
@@ -23,8 +23,7 @@
  *
  */
 
-
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/gpio_types.h"
 
 #include "../hw_translate.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c
index 9168b2c..7e16d63 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c
@@ -27,7 +27,7 @@
  * Pre-requisites: headers required by header of this unit
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/gpio_interface.h"
 #include "include/gpio_service_interface.h"
@@ -246,7 +246,7 @@ struct gpio *dal_gpio_create(
 	uint32_t en,
 	enum gpio_pin_output_state output_state)
 {
-	struct gpio *gpio = dc_service_alloc(service->ctx, sizeof(struct gpio));
+	struct gpio *gpio = dm_alloc(service->ctx, sizeof(struct gpio));
 
 	if (!gpio) {
 		ASSERT_CRITICAL(false);
@@ -273,7 +273,7 @@ void dal_gpio_destroy(
 
 	dal_gpio_close(*gpio);
 
-	dc_service_free((*gpio)->service->ctx, *gpio);
+	dm_free((*gpio)->service->ctx, *gpio);
 
 	*gpio = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
index b79653c..6837898 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
@@ -27,7 +27,7 @@
  * Pre-requisites: headers required by header of this unit
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/gpio_interface.h"
 #include "include/ddc_interface.h"
 #include "include/irq_interface.h"
@@ -68,7 +68,7 @@ struct gpio_service *dal_gpio_service_create(
 
 	uint32_t index_of_id;
 
-	service = dc_service_alloc(ctx, sizeof(struct gpio_service));
+	service = dm_alloc(ctx, sizeof(struct gpio_service));
 
 	if (!service) {
 		BREAK_TO_DEBUGGER();
@@ -107,7 +107,7 @@ struct gpio_service *dal_gpio_service_create(
 			if (number_of_bits) {
 				uint32_t index_of_uint = 0;
 
-				slot = dc_service_alloc(
+				slot = dm_alloc(
 					ctx,
 					number_of_uints * sizeof(uint32_t));
 
@@ -141,11 +141,11 @@ failure_2:
 		slot = service->busyness[index_of_id];
 
 		if (slot)
-			dc_service_free(ctx, slot);
+			dm_free(ctx, slot);
 	};
 
 failure_1:
-	dc_service_free(ctx, service);
+	dm_free(ctx, service);
 
 	return NULL;
 }
@@ -243,13 +243,13 @@ void dal_gpio_service_destroy(
 			uint32_t *slot = (*ptr)->busyness[index_of_id];
 
 			if (slot)
-				dc_service_free((*ptr)->ctx, slot);
+				dm_free((*ptr)->ctx, slot);
 
 			++index_of_id;
 		} while (index_of_id < GPIO_ID_COUNT);
 	}
 
-	dc_service_free((*ptr)->ctx, *ptr);
+	dm_free((*ptr)->ctx, *ptr);
 
 	*ptr = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c
index e15f3a2..41e46a7 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "hw_gpio_pin.h"
 #include "hw_gpio.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c
index a5fa3aa..e0f6ecf 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 
 /*
@@ -88,7 +87,7 @@ void dal_hw_factory_destroy(
 		return;
 	}
 
-	dc_service_free(ctx, *factory);
+	dm_free(ctx, *factory);
 
 	*factory = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio.c
index 9e231d3..2a2262c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "hw_gpio_pin.h"
 
@@ -51,7 +50,7 @@ enum gpio_result dal_hw_gpio_get_reg_value(
 	const struct addr_mask *reg,
 	uint32_t *value)
 {
-	*value = dal_read_reg(ctx, reg->addr);
+	*value = dm_read_reg(ctx, reg->addr);
 
 	*value &= reg->mask;
 
@@ -70,12 +69,12 @@ enum gpio_result dal_hw_gpio_set_reg_value(
 		return GPIO_RESULT_INVALID_DATA;
 	}
 
-	prev_value = dal_read_reg(ctx, reg->addr);
+	prev_value = dm_read_reg(ctx, reg->addr);
 
 	prev_value &= ~reg->mask;
 	prev_value |= (value & reg->mask);
 
-	dal_write_reg(ctx, reg->addr, prev_value);
+	dm_write_reg(ctx, reg->addr, prev_value);
 
 	return GPIO_RESULT_OK;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pad.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pad.c
index 52757ac..2392f2c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pad.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pad.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "hw_gpio_pin.h"
 #include "hw_gpio.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pin.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pin.c
index 0d3f07f..411ad89 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pin.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_gpio_pin.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.c
index 617d648..f072fd5 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 #include "hw_gpio_pin.h"
 #include "hw_gpio.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_translate.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_translate.c
index 4a894c8..215322e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_translate.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_translate.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_types.h"
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/irq.c b/drivers/gpu/drm/amd/dal/dc/gpio/irq.c
index 04bb69d..debc2ea 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/irq.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/irq.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/gpio_interface.h"
 #include "include/irq_interface.h"
 #include "include/gpio_service_interface.h"
@@ -138,7 +137,7 @@ struct irq *dal_gpio_create_irq(
 		return NULL;
 	}
 
-	irq = dc_service_alloc(service->ctx, sizeof(struct irq));
+	irq = dm_alloc(service->ctx, sizeof(struct irq));
 
 	if (!irq) {
 		ASSERT_CRITICAL(false);
@@ -154,7 +153,7 @@ struct irq *dal_gpio_create_irq(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(service->ctx, irq);
+	dm_free(service->ctx, irq);
 
 	return NULL;
 }
@@ -175,7 +174,7 @@ void dal_gpio_destroy_irq(
 	}
 
 	destruct(*irq);
-	dc_service_free((*irq)->ctx, *irq);
+	dm_free((*irq)->ctx, *irq);
 
 	*irq = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dc_clock_generator.c b/drivers/gpu/drm/amd/dal/dc/gpu/dc_clock_generator.c
index 0ed4f06..b3b0f99 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dc_clock_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dc_clock_generator.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dc_clock_generator.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c
index 6edb5aa..4c307f6 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/logger_interface.h"
 
@@ -50,7 +50,7 @@ static void force_hw_base_light_sleep(struct dc_context *ctx)
 	addr = mmDC_MEM_GLOBAL_PWR_REQ_CNTL;
 	/* Read the mmDC_MEM_GLOBAL_PWR_REQ_CNTL to get the currently
 	 * programmed DC_MEM_GLOBAL_PWR_REQ_DIS*/
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 			value,
@@ -58,7 +58,7 @@ static void force_hw_base_light_sleep(struct dc_context *ctx)
 			DC_MEM_GLOBAL_PWR_REQ_CNTL,
 			DC_MEM_GLOBAL_PWR_REQ_DIS);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index 7ff8a74..15243de 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -165,7 +165,7 @@ static uint32_t get_dp_ref_clk_frequency(struct display_clock *dc)
 	struct display_clock_dce110 *disp_clk = FROM_DISPLAY_CLOCK(dc);
 
 	/* ASSERT DP Reference Clock source is from DFS*/
-	dp_ref_clk_cntl_value = dal_read_reg(dc->ctx,
+	dp_ref_clk_cntl_value = dm_read_reg(dc->ctx,
 			mmDPREFCLK_CNTL);
 
 	dp_ref_clk_cntl_src_sel_value =
@@ -177,7 +177,7 @@ static uint32_t get_dp_ref_clk_frequency(struct display_clock *dc)
 
 	/* Read the mmDENTIST_DISPCLK_CNTL to get the currently
 	 * programmed DID DENTIST_DPREFCLK_WDIVIDER*/
-	dispclk_cntl_value = dal_read_reg(dc->ctx,
+	dispclk_cntl_value = dm_read_reg(dc->ctx,
 			mmDENTIST_DISPCLK_CNTL);
 
 	/* Convert DENTIST_DPREFCLK_WDIVIDERto actual divider*/
@@ -233,7 +233,7 @@ static void destroy(struct display_clock **base)
 
 	dc110 = DCLCK110_FROM_BASE(*base);
 
-	dc_service_free((*base)->ctx, dc110);
+	dm_free((*base)->ctx, dc110);
 
 	*base = NULL;
 }
@@ -652,8 +652,8 @@ static bool display_clock_integrated_info_construct(
 	struct display_clock *base = &disp_clk->disp_clk_base;
 	bool res;
 
-	dc_service_memset(&info, 0, sizeof(struct integrated_info));
-	dc_service_memset(&fw_info, 0, sizeof(struct firmware_info));
+	dm_memset(&info, 0, sizeof(struct integrated_info));
+	dm_memset(&fw_info, 0, sizeof(struct firmware_info));
 
 	res = dal_adapter_service_get_integrated_info(as, &info);
 
@@ -728,7 +728,7 @@ static uint32_t get_clock(struct display_clock *dc)
 
 	/* Read the mmDENTIST_DISPCLK_CNTL to get the currently programmed
 	 DID DENTIST_DISPCLK_WDIVIDER.*/
-	value = dal_read_reg(dc->ctx, addr);
+	value = dm_read_reg(dc->ctx, addr);
 	field = get_reg_field_value(
 			value, DENTIST_DISPCLK_CNTL, DENTIST_DISPCLK_WDIVIDER);
 
@@ -787,7 +787,7 @@ static void set_clock(
 	struct dc_bios *bp = dal_adapter_service_get_bios_parser(base->as);
 
 	/* Prepare to program display clock*/
-	dc_service_memset(&pxl_clk_params, 0, sizeof(pxl_clk_params));
+	dm_memset(&pxl_clk_params, 0, sizeof(pxl_clk_params));
 
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = base->id;
@@ -910,7 +910,7 @@ static bool dal_display_clock_dce110_construct(
 			struct spread_spectrum_info info;
 			bool result;
 
-			dc_service_memset(&info, 0, sizeof(info));
+			dm_memset(&info, 0, sizeof(info));
 
 			result =
 				dal_adapter_service_get_ss_info(
@@ -954,7 +954,7 @@ struct display_clock *dal_display_clock_dce110_create(
 {
 	struct display_clock_dce110 *dc110;
 
-	dc110 = dc_service_alloc(ctx, sizeof(struct display_clock_dce110));
+	dc110 = dm_alloc(ctx, sizeof(struct display_clock_dce110));
 
 	if (dc110 == NULL)
 		return NULL;
@@ -962,7 +962,7 @@ struct display_clock *dal_display_clock_dce110_create(
 	if (dal_display_clock_dce110_construct(dc110, ctx, as))
 		return &dc110->disp_clk_base;
 
-	dc_service_free(ctx, dc110);
+	dm_free(ctx, dc110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.c b/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.c
index 887bd74..1319248 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.c
@@ -23,8 +23,9 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "display_clock.h"
+
 #include "adapter_service_interface.h"
 
 void dal_display_clock_base_set_dp_ref_clock_source(
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.c b/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.c
index b4355f2..59d4400 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-#include "dc_services.h"
+#include "dm_services.h"
 #include "divider_range.h"
 
 bool dal_divider_range_construct(
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/aux_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/aux_engine.c
index b81fbdb..7042d10 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/aux_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/aux_engine.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "engine.h"
 
@@ -204,7 +203,7 @@ static void process_read_request(
 				I2CAUX_TRANSACTION_STATUS_FAILED_PROTOCOL_ERROR;
 			ctx->operation_succeeded = false;
 		} else
-			dc_service_delay_in_microseconds(engine->base.ctx, 400);
+			dm_delay_in_microseconds(engine->base.ctx, 400);
 	break;
 	case AUX_CHANNEL_OPERATION_FAILED_TIMEOUT:
 		++ctx->timed_out_retry_aux;
@@ -265,7 +264,7 @@ static bool read_command(
 	ctx.request.delay = 0;
 
 	do {
-		dc_service_memset(ctx.buffer + ctx.offset, 0, ctx.current_read_length);
+		dm_memset(ctx.buffer + ctx.offset, 0, ctx.current_read_length);
 
 		ctx.request.data = ctx.buffer + ctx.offset;
 		ctx.request.length = ctx.current_read_length;
@@ -276,7 +275,7 @@ static bool read_command(
 
 		if (ctx.operation_succeeded && !ctx.transaction_complete)
 			if (ctx.request.type == AUX_TRANSACTION_TYPE_I2C)
-				dc_service_sleep_in_milliseconds(engine->base.ctx, engine->delay);
+				dm_sleep_in_milliseconds(engine->base.ctx, engine->delay);
 	} while (ctx.operation_succeeded && !ctx.transaction_complete);
 
 	return ctx.operation_succeeded;
@@ -331,7 +330,7 @@ static void process_write_reply(
 				I2CAUX_TRANSACTION_STATUS_FAILED_TIMEOUT;
 				ctx->operation_succeeded = false;
 			} else
-				dc_service_delay_in_microseconds(engine->base.ctx, 300);
+				dm_delay_in_microseconds(engine->base.ctx, 300);
 		} else {
 			ctx->status = I2CAUX_TRANSACTION_STATUS_SUCCEEDED;
 			ctx->defer_retry_aux = 0;
@@ -402,7 +401,7 @@ static void process_write_request(
 				I2CAUX_TRANSACTION_STATUS_FAILED_PROTOCOL_ERROR;
 			ctx->operation_succeeded = false;
 		} else
-			dc_service_delay_in_microseconds(engine->base.ctx, 400);
+			dm_delay_in_microseconds(engine->base.ctx, 400);
 	break;
 	case AUX_CHANNEL_OPERATION_FAILED_TIMEOUT:
 		++ctx->timed_out_retry_aux;
@@ -476,7 +475,7 @@ static bool write_command(
 
 		if (ctx.operation_succeeded && !ctx.transaction_complete)
 			if (ctx.request.type == AUX_TRANSACTION_TYPE_I2C)
-				dc_service_sleep_in_milliseconds(engine->base.ctx, engine->delay);
+				dm_sleep_in_milliseconds(engine->base.ctx, engine->delay);
 	} while (ctx.operation_succeeded && !ctx.transaction_complete);
 
 	return ctx.operation_succeeded;
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
index d0b8288..f9c5543 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "../engine.h"
 #include "../aux_engine.h"
@@ -72,7 +71,7 @@ static void release_engine(
 
 	const uint32_t addr = aux_engine->addr.aux_arb_control;
 
-	uint32_t value = dal_read_reg(engine->ctx, addr);
+	uint32_t value = dm_read_reg(engine->ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -80,7 +79,7 @@ static void release_engine(
 		AUX_ARB_CONTROL,
 		AUX_SW_DONE_USING_AUX_REG);
 
-	dal_write_reg(engine->ctx, addr, value);
+	dm_write_reg(engine->ctx, addr, value);
 }
 
 static void destruct(
@@ -93,7 +92,7 @@ static void destroy(
 
 	destruct(engine);
 
-	dc_service_free((*aux_engine)->base.ctx, engine);
+	dm_free((*aux_engine)->base.ctx, engine);
 
 	*aux_engine = NULL;
 }
@@ -111,7 +110,7 @@ static bool acquire_engine(
 	{
 		const uint32_t addr = aux_engine->addr.aux_control;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		field = get_reg_field_value(
 				value,
@@ -134,13 +133,13 @@ static bool acquire_engine(
 				AUX_CONTROL,
 				AUX_RESET);
 
-			dal_write_reg(engine->base.ctx, addr, value);
+			dm_write_reg(engine->base.ctx, addr, value);
 
 			/*poll HW to make sure reset it done*/
 			do {
-				dc_service_delay_in_microseconds(engine->base.ctx, 1);
+				dm_delay_in_microseconds(engine->base.ctx, 1);
 
-				value = dal_read_reg(engine->base.ctx, addr);
+				value = dm_read_reg(engine->base.ctx, addr);
 
 				field = get_reg_field_value(
 						value,
@@ -157,14 +156,14 @@ static bool acquire_engine(
 				AUX_CONTROL,
 				AUX_RESET);
 
-			dal_write_reg(engine->base.ctx, addr, value);
+			dm_write_reg(engine->base.ctx, addr, value);
 
 			counter = 0;
 
 			do {
-				dc_service_delay_in_microseconds(engine->base.ctx, 1);
+				dm_delay_in_microseconds(engine->base.ctx, 1);
 
-				value = dal_read_reg(engine->base.ctx, addr);
+				value = dm_read_reg(engine->base.ctx, addr);
 
 				field = get_reg_field_value(
 						value,
@@ -181,7 +180,7 @@ static bool acquire_engine(
 	{
 		const uint32_t addr = aux_engine->addr.aux_arb_control;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -189,9 +188,9 @@ static bool acquire_engine(
 			AUX_ARB_CONTROL,
 			AUX_SW_USE_AUX_REG_REQ);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		field = get_reg_field_value(
 				value,
@@ -210,7 +209,7 @@ static void configure(
 
 	const uint32_t addr = aux_engine->addr.aux_control;
 
-	uint32_t value = dal_read_reg(engine->base.ctx, addr);
+	uint32_t value = dm_read_reg(engine->base.ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -218,7 +217,7 @@ static void configure(
 		AUX_CONTROL,
 		AUX_IGNORE_HPD_DISCON);
 
-	dal_write_reg(engine->base.ctx, addr, value);
+	dm_write_reg(engine->base.ctx, addr, value);
 }
 
 static bool start_gtc_sync(
@@ -262,7 +261,7 @@ static void submit_channel_request(
 	{
 		const uint32_t addr = mmAUXN_IMPCAL;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -270,7 +269,7 @@ static void submit_channel_request(
 			AUXN_IMPCAL,
 			AUXN_CALOUT_ERROR_AK);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -278,12 +277,12 @@ static void submit_channel_request(
 			AUXN_IMPCAL,
 			AUXN_CALOUT_ERROR_AK);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 	{
 		const uint32_t addr = mmAUXP_IMPCAL;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -291,7 +290,7 @@ static void submit_channel_request(
 			AUXP_IMPCAL,
 			AUXP_CALOUT_ERROR_AK);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -299,14 +298,14 @@ static void submit_channel_request(
 			AUXP_IMPCAL,
 			AUXP_CALOUT_ERROR_AK);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 
 	/* force_default_calibrate */
 	{
 		const uint32_t addr = mmAUXN_IMPCAL;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -314,7 +313,7 @@ static void submit_channel_request(
 			AUXN_IMPCAL,
 			AUXN_IMPCAL_ENABLE);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -322,12 +321,12 @@ static void submit_channel_request(
 			AUXN_IMPCAL,
 			AUXN_IMPCAL_OVERRIDE_ENABLE);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 	{
 		const uint32_t addr = mmAUXP_IMPCAL;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -335,7 +334,7 @@ static void submit_channel_request(
 			AUXP_IMPCAL,
 			AUXP_IMPCAL_OVERRIDE_ENABLE);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -343,14 +342,14 @@ static void submit_channel_request(
 			AUXP_IMPCAL,
 			AUXP_IMPCAL_OVERRIDE_ENABLE);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 
 	/* set the delay and the number of bytes to write */
 	{
 		const uint32_t addr = aux_engine->addr.aux_sw_control;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -374,14 +373,14 @@ static void submit_channel_request(
 			AUX_SW_CONTROL,
 			AUX_SW_WR_BYTES);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 
 	/* program action and address and payload data (if 'is_write') */
 	{
 		const uint32_t addr = aux_engine->addr.aux_sw_data;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -408,7 +407,7 @@ static void submit_channel_request(
 			AUX_SW_DATA,
 			AUX_SW_DATA);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -422,7 +421,7 @@ static void submit_channel_request(
 			AUX_SW_DATA,
 			AUX_SW_DATA);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -430,7 +429,7 @@ static void submit_channel_request(
 			AUX_SW_DATA,
 			AUX_SW_DATA);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		if (request->length) {
 			set_reg_field_value(
@@ -439,7 +438,7 @@ static void submit_channel_request(
 				AUX_SW_DATA,
 				AUX_SW_DATA);
 
-			dal_write_reg(engine->base.ctx, addr, value);
+			dm_write_reg(engine->base.ctx, addr, value);
 		}
 
 		if (is_write) {
@@ -457,7 +456,7 @@ static void submit_channel_request(
 					AUX_SW_DATA,
 					AUX_SW_DATA);
 
-				dal_write_reg(
+				dm_write_reg(
 					engine->base.ctx, addr, value);
 
 				++i;
@@ -468,7 +467,7 @@ static void submit_channel_request(
 	{
 		const uint32_t addr = aux_engine->addr.aux_interrupt_control;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -476,13 +475,13 @@ static void submit_channel_request(
 			AUX_INTERRUPT_CONTROL,
 			AUX_SW_DONE_ACK);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 
 	{
 		const uint32_t addr = aux_engine->addr.aux_sw_control;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -490,7 +489,7 @@ static void submit_channel_request(
 			AUX_SW_CONTROL,
 			AUX_SW_GO);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 	}
 }
 
@@ -510,7 +509,7 @@ static void process_channel_reply(
 	{
 		const uint32_t addr = aux_engine->addr.aux_sw_status;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		bytes_replied = get_reg_field_value(
 				value,
@@ -523,7 +522,7 @@ static void process_channel_reply(
 
 		const uint32_t addr = aux_engine->addr.aux_sw_data;
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -531,7 +530,7 @@ static void process_channel_reply(
 			AUX_SW_DATA,
 			AUX_SW_INDEX);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -539,7 +538,7 @@ static void process_channel_reply(
 			AUX_SW_DATA,
 			AUX_SW_AUTOINCREMENT_DISABLE);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
 		set_reg_field_value(
 			value,
@@ -547,9 +546,9 @@ static void process_channel_reply(
 			AUX_SW_DATA,
 			AUX_SW_DATA_RW);
 
-		dal_write_reg(engine->base.ctx, addr, value);
+		dm_write_reg(engine->base.ctx, addr, value);
 
-		value = dal_read_reg(engine->base.ctx, addr);
+		value = dm_read_reg(engine->base.ctx, addr);
 
 		reply_result = get_reg_field_value(
 				value,
@@ -567,7 +566,7 @@ static void process_channel_reply(
 			--bytes_replied;
 
 			while (i < bytes_replied) {
-				value = dal_read_reg(
+				value = dm_read_reg(
 					engine->base.ctx, addr);
 
 				reply->data[i] = get_reg_field_value(
@@ -631,7 +630,7 @@ static enum aux_channel_operation_result get_channel_status(
 		uint32_t time_elapsed = 0;
 
 		do {
-			value = dal_read_reg(engine->base.ctx, addr);
+			value = dm_read_reg(engine->base.ctx, addr);
 
 			aux_sw_done = get_reg_field_value(
 					value,
@@ -641,7 +640,7 @@ static enum aux_channel_operation_result get_channel_status(
 			if (aux_sw_done)
 				break;
 
-			dc_service_delay_in_microseconds(engine->base.ctx, 10);
+			dm_delay_in_microseconds(engine->base.ctx, 10);
 
 			time_elapsed += 10;
 		} while (time_elapsed < aux_engine->timeout_period);
@@ -771,7 +770,7 @@ struct aux_engine *dal_aux_engine_dce110_create(
 		return NULL;
 	}
 
-	engine = dc_service_alloc(aux_init_data->ctx, sizeof(*engine));
+	engine = dm_alloc(aux_init_data->ctx, sizeof(*engine));
 
 	if (!engine) {
 		ASSERT_CRITICAL(false);
@@ -783,7 +782,7 @@ struct aux_engine *dal_aux_engine_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(aux_init_data->ctx, engine);
+	dm_free(aux_init_data->ctx, engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
index ce3cc4d..2517f44 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/logger_interface.h"
 /*
  * Pre-requisites: headers required by header of this unit
@@ -102,7 +102,7 @@ static void disable_i2c_hw_engine(
 
 	ctx = engine->base.base.base.ctx;
 
-	value = dal_read_reg(ctx, addr);
+	value = dm_read_reg(ctx, addr);
 
 	set_reg_field_value(
 		value,
@@ -110,7 +110,7 @@ static void disable_i2c_hw_engine(
 		DC_I2C_DDC1_SETUP,
 		DC_I2C_DDC1_ENABLE);
 
-	dal_write_reg(ctx, addr, value);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void release_engine(
@@ -130,7 +130,7 @@ static void release_engine(
 
 	/* Release I2C */
 	{
-		value = dal_read_reg(engine->ctx, mmDC_I2C_ARBITRATION);
+		value = dm_read_reg(engine->ctx, mmDC_I2C_ARBITRATION);
 
 		set_reg_field_value(
 				value,
@@ -138,14 +138,14 @@ static void release_engine(
 				DC_I2C_ARBITRATION,
 				DC_I2C_SW_DONE_USING_I2C_REG);
 
-		dal_write_reg(engine->ctx, mmDC_I2C_ARBITRATION, value);
+		dm_write_reg(engine->ctx, mmDC_I2C_ARBITRATION, value);
 	}
 
 	/* Reset HW engine */
 	{
 		uint32_t i2c_sw_status = 0;
 
-		value = dal_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
+		value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
 
 		i2c_sw_status = get_reg_field_value(
 				value,
@@ -155,7 +155,7 @@ static void release_engine(
 		safe_to_reset = (i2c_sw_status == 1);
 	}
 	{
-		value = dal_read_reg(engine->ctx, mmDC_I2C_CONTROL);
+		value = dm_read_reg(engine->ctx, mmDC_I2C_CONTROL);
 
 		if (safe_to_reset)
 			set_reg_field_value(
@@ -170,7 +170,7 @@ static void release_engine(
 			DC_I2C_CONTROL,
 			DC_I2C_SW_STATUS_RESET);
 
-		dal_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
+		dm_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
 	}
 
 	/* HW I2c engine - clock gating feature */
@@ -204,7 +204,7 @@ static bool setup_engine(
 	{
 		const uint32_t addr = mmDC_I2C_CONTROL;
 
-		value = dal_read_reg(i2c_engine->base.ctx, addr);
+		value = dm_read_reg(i2c_engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -243,14 +243,14 @@ static bool setup_engine(
 			DC_I2C_DDC_SELECT);
 
 
-		dal_write_reg(i2c_engine->base.ctx, addr, value);
+		dm_write_reg(i2c_engine->base.ctx, addr, value);
 	}
 
 	/* Program time limit */
 	{
 		const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
 
-		value = dal_read_reg(i2c_engine->base.ctx, addr);
+		value = dm_read_reg(i2c_engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -264,7 +264,7 @@ static bool setup_engine(
 			DC_I2C_DDC1_SETUP,
 			DC_I2C_DDC1_ENABLE);
 
-		dal_write_reg(i2c_engine->base.ctx, addr, value);
+		dm_write_reg(i2c_engine->base.ctx, addr, value);
 	}
 
 	/* Program HW priority
@@ -272,7 +272,7 @@ static bool setup_engine(
 	 * Enable restart of SW I2C that was interrupted by HW
 	 * disable queuing of software while I2C is in use by HW */
 	{
-		value = dal_read_reg(i2c_engine->base.ctx,
+		value = dm_read_reg(i2c_engine->base.ctx,
 				mmDC_I2C_ARBITRATION);
 
 		set_reg_field_value(
@@ -287,7 +287,7 @@ static bool setup_engine(
 			DC_I2C_ARBITRATION,
 			DC_I2C_SW_PRIORITY);
 
-		dal_write_reg(i2c_engine->base.ctx,
+		dm_write_reg(i2c_engine->base.ctx,
 				mmDC_I2C_ARBITRATION, value);
 	}
 
@@ -303,7 +303,7 @@ static uint32_t get_speed(
 
 	uint32_t pre_scale = 0;
 
-	uint32_t value = dal_read_reg(i2c_engine->base.ctx, addr);
+	uint32_t value = dm_read_reg(i2c_engine->base.ctx, addr);
 
 	pre_scale = get_reg_field_value(
 			value,
@@ -327,7 +327,7 @@ static void set_speed(
 	if (speed) {
 		const uint32_t addr = engine->addr.DC_I2C_DDCX_SPEED;
 
-		uint32_t value = dal_read_reg(i2c_engine->base.ctx, addr);
+		uint32_t value = dm_read_reg(i2c_engine->base.ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -356,13 +356,13 @@ static void set_speed(
 				DC_I2C_DDC1_START_STOP_TIMING_CNTL);
 		}
 
-		dal_write_reg(i2c_engine->base.ctx, addr, value);
+		dm_write_reg(i2c_engine->base.ctx, addr, value);
 	}
 }
 
 static inline void reset_hw_engine(struct engine *engine)
 {
-	uint32_t value = dal_read_reg(engine->ctx, mmDC_I2C_CONTROL);
+	uint32_t value = dm_read_reg(engine->ctx, mmDC_I2C_CONTROL);
 
 	set_reg_field_value(
 		value,
@@ -376,14 +376,14 @@ static inline void reset_hw_engine(struct engine *engine)
 		DC_I2C_CONTROL,
 		DC_I2C_SW_STATUS_RESET);
 
-	dal_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
+	dm_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
 }
 
 static bool is_hw_busy(struct engine *engine)
 {
 	uint32_t i2c_sw_status = 0;
 
-	uint32_t value = dal_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
+	uint32_t value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
 
 	i2c_sw_status = get_reg_field_value(
 			value,
@@ -395,7 +395,7 @@ static bool is_hw_busy(struct engine *engine)
 
 	reset_hw_engine(engine);
 
-	value = dal_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
+	value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
 
 	i2c_sw_status = get_reg_field_value(
 			value,
@@ -434,7 +434,7 @@ static bool process_transaction(
 		const uint32_t addr =
 			transaction_addr[engine->transaction_count];
 
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -480,7 +480,7 @@ static bool process_transaction(
 			DC_I2C_TRANSACTION0,
 			DC_I2C_COUNT0);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* Write the I2C address and I2C data
@@ -522,7 +522,7 @@ static bool process_transaction(
 			engine->buffer_used_write = 0;
 		}
 
-		dal_write_reg(ctx, mmDC_I2C_DATA, value);
+		dm_write_reg(ctx, mmDC_I2C_DATA, value);
 
 		engine->buffer_used_write++;
 
@@ -542,7 +542,7 @@ static bool process_transaction(
 					DC_I2C_DATA,
 					DC_I2C_DATA);
 
-				dal_write_reg(ctx, mmDC_I2C_DATA, value);
+				dm_write_reg(ctx, mmDC_I2C_DATA, value);
 
 				engine->buffer_used_write++;
 				--length;
@@ -567,7 +567,7 @@ static void execute_transaction(
 	{
 		const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
 
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -599,13 +599,13 @@ static void execute_transaction(
 			DC_I2C_DDC1_SETUP,
 			DC_I2C_DDC1_INTRA_BYTE_DELAY);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	{
 		const uint32_t addr = mmDC_I2C_CONTROL;
 
-		value = dal_read_reg(ctx, addr);
+		value = dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -637,14 +637,14 @@ static void execute_transaction(
 			DC_I2C_CONTROL,
 			DC_I2C_TRANSACTION_COUNT);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* start I2C transfer */
 	{
 		const uint32_t addr = mmDC_I2C_CONTROL;
 
-		value	= dal_read_reg(ctx, addr);
+		value	= dm_read_reg(ctx, addr);
 
 		set_reg_field_value(
 			value,
@@ -652,7 +652,7 @@ static void execute_transaction(
 			DC_I2C_CONTROL,
 			DC_I2C_GO);
 
-		dal_write_reg(ctx, addr, value);
+		dm_write_reg(ctx, addr, value);
 	}
 
 	/* all transactions were executed and HW buffer became empty
@@ -709,7 +709,7 @@ static void process_channel_reply(
 		DC_I2C_DATA,
 		DC_I2C_INDEX_WRITE);
 
-	dal_write_reg(engine->base.ctx, mmDC_I2C_DATA, value);
+	dm_write_reg(engine->base.ctx, mmDC_I2C_DATA, value);
 
 	while (length) {
 		/* after reading the status,
@@ -717,7 +717,7 @@ static void process_channel_reply(
 		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
 		 * should read data bytes from I2C circular data buffer */
 
-		value = dal_read_reg(engine->base.ctx, mmDC_I2C_DATA);
+		value = dm_read_reg(engine->base.ctx, mmDC_I2C_DATA);
 
 		*buffer++ = get_reg_field_value(
 				value,
@@ -733,7 +733,7 @@ static enum i2c_channel_operation_result get_channel_status(
 	uint8_t *returned_bytes)
 {
 	uint32_t i2c_sw_status = 0;
-	uint32_t value = dal_read_reg(engine->base.ctx, mmDC_I2C_SW_STATUS);
+	uint32_t value = dm_read_reg(engine->base.ctx, mmDC_I2C_SW_STATUS);
 
 	i2c_sw_status = get_reg_field_value(
 			value,
@@ -792,7 +792,7 @@ static void destroy(
 
 	dal_i2c_hw_engine_destruct(&engine_dce110->base);
 
-	dc_service_free((*i2c_engine)->base.ctx, engine_dce110);
+	dm_free((*i2c_engine)->base.ctx, engine_dce110);
 
 	*i2c_engine = NULL;
 }
@@ -893,7 +893,7 @@ static bool construct(
 		mmDC_I2C_DDC1_SPEED + ddc_speed_offset[arg->engine_id];
 
 
-	value = dal_read_reg(
+	value = dm_read_reg(
 		engine_dce110->base.base.base.ctx,
 		mmMICROSECOND_TIME_BASE_DIV);
 
@@ -936,7 +936,7 @@ struct i2c_engine *dal_i2c_hw_engine_dce110_create(
 		return NULL;
 	}
 
-	engine_dce10 = dc_service_alloc(arg->ctx, sizeof(struct i2c_hw_engine_dce110));
+	engine_dce10 = dm_alloc(arg->ctx, sizeof(struct i2c_hw_engine_dce110));
 
 	if (!engine_dce10) {
 		ASSERT_CRITICAL(false);
@@ -948,7 +948,7 @@ struct i2c_engine *dal_i2c_hw_engine_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(arg->ctx, engine_dce10);
+	dm_free(arg->ctx, engine_dce10);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c
index 2d5a318..f060b25 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "../engine.h"
 #include "../i2c_engine.h"
@@ -39,6 +38,7 @@
  */
 
 #include "i2c_sw_engine_dce110.h"
+
 /*
  * Post-requisites: headers required by this unit
  */
@@ -88,7 +88,7 @@ static void destroy(
 
 	destruct(sw_engine);
 
-	dc_service_free((*engine)->base.ctx, sw_engine);
+	dm_free((*engine)->base.ctx, sw_engine);
 
 	*engine = NULL;
 }
@@ -154,7 +154,7 @@ struct i2c_engine *dal_i2c_sw_engine_dce110_create(
 		return NULL;
 	}
 
-	engine_dce110 = dc_service_alloc(arg->ctx, sizeof(struct i2c_sw_engine_dce110));
+	engine_dce110 = dm_alloc(arg->ctx, sizeof(struct i2c_sw_engine_dce110));
 
 	if (!engine_dce110) {
 		ASSERT_CRITICAL(false);
@@ -166,7 +166,7 @@ struct i2c_engine *dal_i2c_sw_engine_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(arg->ctx, engine_dce110);
+	dm_free(arg->ctx, engine_dce110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
index d2de0f2..9c88762 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "../i2caux.h"
 #include "../engine.h"
@@ -40,6 +39,7 @@
  * Header of this unit
  */
 #include "i2caux_dce110.h"
+
 #include "i2c_sw_engine_dce110.h"
 #include "i2c_hw_engine_dce110.h"
 #include "aux_engine_dce110.h"
@@ -68,7 +68,7 @@ static void destroy(
 
 	destruct(i2caux_dce110);
 
-	dc_service_free((*i2c_engine)->ctx, i2caux_dce110);
+	dm_free((*i2c_engine)->ctx, i2caux_dce110);
 
 	*i2c_engine = NULL;
 }
@@ -248,7 +248,7 @@ struct i2caux *dal_i2caux_dce110_create(
 	struct dc_context *ctx)
 {
 	struct i2caux_dce110 *i2caux_dce110 =
-		dc_service_alloc(ctx, sizeof(struct i2caux_dce110));
+		dm_alloc(ctx, sizeof(struct i2caux_dce110));
 
 	if (!i2caux_dce110) {
 		ASSERT_CRITICAL(false);
@@ -260,7 +260,7 @@ struct i2caux *dal_i2caux_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, i2caux_dce110);
+	dm_free(ctx, i2caux_dce110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c b/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c
index 96b78e7..f4bc39d 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "../i2caux.h"
 #include "../engine.h"
@@ -60,7 +59,7 @@ static void destroy(
 {
 	destruct(*i2c_engine);
 
-	dc_service_free((*i2c_engine)->ctx, *i2c_engine);
+	dm_free((*i2c_engine)->ctx, *i2c_engine);
 
 	*i2c_engine = NULL;
 }
@@ -95,7 +94,7 @@ struct i2caux *dal_i2caux_diag_fpga_create(
 	struct adapter_service *as,
 	struct dc_context *ctx)
 {
-	struct i2caux *i2caux =	dc_service_alloc(ctx, sizeof(struct i2caux));
+	struct i2caux *i2caux =	dm_alloc(ctx, sizeof(struct i2caux));
 
 	if (!i2caux) {
 		ASSERT_CRITICAL(false);
@@ -107,7 +106,7 @@ struct i2caux *dal_i2caux_diag_fpga_create(
 
 	ASSERT_CRITICAL(false);
 
-	dc_service_free(ctx, i2caux);
+	dm_free(ctx, i2caux);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/engine_base.c b/drivers/gpu/drm/amd/dal/dc/i2caux/engine_base.c
index 7a1c78c..9c472b9 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/engine_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/engine_base.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_engine.c
index c8ab1f8..dccb1c5 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_engine.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "engine.h"
 
@@ -67,7 +66,7 @@ bool dal_i2c_engine_acquire(
 
 		/* i2c_engine is busy by VBios, lets wait and retry */
 
-		dc_service_delay_in_microseconds(engine->ctx, 10);
+		dm_delay_in_microseconds(engine->ctx, 10);
 
 		++counter;
 	} while (counter < 2);
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_generic_hw_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_generic_hw_engine.c
index 61df97e..6429b55 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_generic_hw_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_generic_hw_engine.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "engine.h"
 #include "i2c_engine.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_hw_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_hw_engine.c
index cd8aa44..b02ba79 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_hw_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_hw_engine.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "engine.h"
 #include "i2c_engine.h"
@@ -221,7 +220,7 @@ enum i2c_channel_operation_result dal_i2c_hw_engine_wait_on_operation_result(
 		if (result != expected_result)
 			break;
 
-		dc_service_delay_in_microseconds(engine->base.base.ctx, 1);
+		dm_delay_in_microseconds(engine->base.base.ctx, 1);
 
 		++i;
 	} while (i < timeout);
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
index c14c5df..21e8fa2 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 #include "engine.h"
 #include "i2c_engine.h"
@@ -85,7 +84,7 @@ static bool wait_for_scl_high(
 	uint32_t scl_retry = 0;
 	uint32_t scl_retry_max = I2C_SW_TIMEOUT_DELAY / clock_delay_div_4;
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	/* 3 milliseconds delay
 	 * to wake up some displays from "low power" state.
@@ -95,7 +94,7 @@ static bool wait_for_scl_high(
 		if (read_bit_from_ddc(ddc, SCL))
 			return true;
 
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		++scl_retry;
 	} while (scl_retry <= scl_retry_max);
@@ -115,7 +114,7 @@ static bool start_sync(
 
 	write_bit_to_ddc(ddc_handle, SCL, true);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	do {
 		write_bit_to_ddc(ddc_handle, SDA, true);
@@ -125,7 +124,7 @@ static bool start_sync(
 			continue;
 		}
 
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		write_bit_to_ddc(ddc_handle, SCL, true);
 
@@ -134,11 +133,11 @@ static bool start_sync(
 
 		write_bit_to_ddc(ddc_handle, SDA, false);
 
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		write_bit_to_ddc(ddc_handle, SCL, false);
 
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		return true;
 	} while (retry <= I2C_SW_RETRIES);
@@ -158,11 +157,11 @@ static bool stop_sync(
 
 	write_bit_to_ddc(ddc_handle, SCL, false);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	write_bit_to_ddc(ddc_handle, SDA, false);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	write_bit_to_ddc(ddc_handle, SCL, true);
 
@@ -172,7 +171,7 @@ static bool stop_sync(
 	write_bit_to_ddc(ddc_handle, SDA, true);
 
 	do {
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		if (read_bit_from_ddc(ddc_handle, SDA))
 			return true;
@@ -195,11 +194,11 @@ static bool write_byte(
 	/* bits are transmitted serially, starting from MSB */
 
 	do {
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		write_bit_to_ddc(ddc_handle, SDA, (byte >> shift) & 1);
 
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 		write_bit_to_ddc(ddc_handle, SCL, true);
 
@@ -215,11 +214,11 @@ static bool write_byte(
 	 * after the SCL pulse we use to send our last data bit.
 	 * If the SDA goes high after that bit, it's a NACK */
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	write_bit_to_ddc(ddc_handle, SDA, true);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	write_bit_to_ddc(ddc_handle, SCL, true);
 
@@ -230,11 +229,11 @@ static bool write_byte(
 
 	ack = !read_bit_from_ddc(ddc_handle, SDA);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4 << 1);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4 << 1);
 
 	write_bit_to_ddc(ddc_handle, SCL, false);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4 << 1);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4 << 1);
 
 	return ack;
 }
@@ -264,7 +263,7 @@ static bool read_byte(
 
 		write_bit_to_ddc(ddc_handle, SCL, false);
 
-		dc_service_delay_in_microseconds(ctx, clock_delay_div_4 << 1);
+		dm_delay_in_microseconds(ctx, clock_delay_div_4 << 1);
 
 		--shift;
 	} while (shift >= 0);
@@ -273,14 +272,14 @@ static bool read_byte(
 
 	*byte = data;
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	/* send the acknowledge bit:
 	 * SDA low means ACK, SDA high means NACK */
 
 	write_bit_to_ddc(ddc_handle, SDA, !more);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	write_bit_to_ddc(ddc_handle, SCL, true);
 
@@ -289,11 +288,11 @@ static bool read_byte(
 
 	write_bit_to_ddc(ddc_handle, SCL, false);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	write_bit_to_ddc(ddc_handle, SDA, true);
 
-	dc_service_delay_in_microseconds(ctx, clock_delay_div_4);
+	dm_delay_in_microseconds(ctx, clock_delay_div_4);
 
 	return true;
 }
@@ -543,7 +542,7 @@ static void destroy(
 {
 	dal_i2c_sw_engine_destruct(FROM_I2C_ENGINE(*ptr));
 
-	dc_service_free((*ptr)->base.ctx, *ptr);
+	dm_free((*ptr)->base.ctx, *ptr);
 	*ptr = NULL;
 }
 
@@ -597,7 +596,7 @@ struct i2c_engine *dal_i2c_sw_engine_create(
 		return NULL;
 	}
 
-	engine = dc_service_alloc(arg->ctx, sizeof(struct i2c_sw_engine));
+	engine = dm_alloc(arg->ctx, sizeof(struct i2c_sw_engine));
 
 	if (!engine) {
 		BREAK_TO_DEBUGGER();
@@ -609,7 +608,7 @@ struct i2c_engine *dal_i2c_sw_engine_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dc_service_free(arg->ctx, engine);
+	dm_free(arg->ctx, engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c
index 68dff0e..4c2f2cb 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c
@@ -23,12 +23,11 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 /*
  * Pre-requisites: headers required by header of this unit
  */
-
 #include "include/i2caux_interface.h"
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/gamma_types.h b/drivers/gpu/drm/amd/dal/dc/inc/gamma_types.h
index 048303e..17cb10f 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/gamma_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/gamma_types.h
@@ -23,10 +23,11 @@
  *
  */
 #ifndef GAMMA_TYPES_H_
+
 #define GAMMA_TYPES_H_
 
 #include "dc_types.h"
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 
 /* TODO: Used in IPP and OPP */
 struct dev_c_lut {
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/opp.h b/drivers/gpu/drm/amd/dal/dc/inc/opp.h
index f2171de..b097983 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/opp.h
@@ -29,7 +29,7 @@
 #include "dc_types.h"
 #include "grph_object_id.h"
 #include "grph_csc_types.h"
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 
 struct fixed31_32;
 struct gamma_parameters;
diff --git a/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c b/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
index 3caeeed..4085b6f 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/logger_interface.h"
 
@@ -38,7 +38,7 @@ static bool hpd_ack(
 	const struct irq_source_info *info)
 {
 	uint32_t addr = info->status_reg;
-	uint32_t value = dal_read_reg(irq_service->ctx, addr);
+	uint32_t value = dm_read_reg(irq_service->ctx, addr);
 	uint32_t current_status =
 		get_reg_field_value(
 			value,
@@ -47,7 +47,7 @@ static bool hpd_ack(
 
 	dal_irq_service_ack_generic(irq_service, info);
 
-	value = dal_read_reg(irq_service->ctx, info->enable_reg);
+	value = dm_read_reg(irq_service->ctx, info->enable_reg);
 
 	set_reg_field_value(
 		value,
@@ -55,7 +55,7 @@ static bool hpd_ack(
 		DC_HPD_INT_CONTROL,
 		DC_HPD_INT_POLARITY);
 
-	dal_write_reg(irq_service->ctx, info->enable_reg, value);
+	dm_write_reg(irq_service->ctx, info->enable_reg, value);
 
 	return true;
 }
@@ -376,7 +376,7 @@ bool construct(
 struct irq_service *dal_irq_service_dce110_create(
 	struct irq_service_init_data *init_data)
 {
-	struct irq_service *irq_service = dc_service_alloc(init_data->ctx, sizeof(*irq_service));
+	struct irq_service *irq_service = dm_alloc(init_data->ctx, sizeof(*irq_service));
 
 	if (!irq_service)
 		return NULL;
@@ -384,6 +384,6 @@ struct irq_service *dal_irq_service_dce110_create(
 	if (construct(irq_service, init_data))
 		return irq_service;
 
-	dc_service_free(init_data->ctx, irq_service);
+	dm_free(init_data->ctx, irq_service);
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c b/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c
index 6f625dd..1372331 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services.h"
+#include "dm_services.h"
 
 #include "include/irq_service_interface.h"
 #include "include/logger_interface.h"
@@ -70,7 +70,7 @@ void dal_irq_service_destroy(struct irq_service **irq_service)
 		return;
 	}
 
-	dc_service_free((*irq_service)->ctx, *irq_service);
+	dm_free((*irq_service)->ctx, *irq_service);
 
 	*irq_service = NULL;
 }
@@ -91,11 +91,11 @@ void dal_irq_service_set_generic(
 	bool enable)
 {
 	uint32_t addr = info->enable_reg;
-	uint32_t value = dal_read_reg(irq_service->ctx, addr);
+	uint32_t value = dm_read_reg(irq_service->ctx, addr);
 
 	value = (value & ~info->enable_mask) |
 		(info->enable_value[enable ? 0 : 1] & info->enable_mask);
-	dal_write_reg(irq_service->ctx, addr, value);
+	dm_write_reg(irq_service->ctx, addr, value);
 }
 
 bool dal_irq_service_set(
@@ -132,11 +132,11 @@ void dal_irq_service_ack_generic(
 	const struct irq_source_info *info)
 {
 	uint32_t addr = info->ack_reg;
-	uint32_t value = dal_read_reg(irq_service->ctx, addr);
+	uint32_t value = dm_read_reg(irq_service->ctx, addr);
 
 	value = (value & ~info->ack_mask) |
 		(info->ack_value & info->ack_mask);
-	dal_write_reg(irq_service->ctx, addr, value);
+	dm_write_reg(irq_service->ctx, addr, value);
 }
 
 bool dal_irq_service_ack(
diff --git a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c
index 4880341..ade443d 100644
--- a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 
 #include "virtual_link_encoder.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
index 99784be..4f5271b 100644
--- a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
@@ -23,8 +23,7 @@
  *
  */
 
-#include "dc_services.h"
-
+#include "dm_services.h"
 #include "virtual_stream_encoder.h"
 
 static void virtual_stream_encoder_dp_set_stream_attribute(
@@ -110,7 +109,7 @@ bool virtual_stream_encoder_construct(
 struct stream_encoder *virtual_stream_encoder_create(
 	struct dc_context *ctx, struct dc_bios *bp)
 {
-	struct stream_encoder *enc = dc_service_alloc(ctx, sizeof(*enc));
+	struct stream_encoder *enc = dm_alloc(ctx, sizeof(*enc));
 
 	if (!enc)
 		return NULL;
@@ -119,7 +118,7 @@ struct stream_encoder *virtual_stream_encoder_create(
 		return enc;
 
 	BREAK_TO_DEBUGGER();
-	dc_service_free(ctx, enc);
+	dm_free(ctx, enc);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/include/bios_parser_types.h b/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
index 6791866..550ac87 100644
--- a/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
+++ b/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
@@ -24,9 +24,10 @@
  */
 
 #ifndef __DAL_BIOS_PARSER_TYPES_H__
+
 #define __DAL_BIOS_PARSER_TYPES_H__
 
-#include "dc_services.h"
+#include "dm_services.h"
 #include "include/signal_types.h"
 #include "include/grph_object_ctrl_defs.h"
 #include "include/gpio_types.h"
diff --git a/drivers/gpu/drm/amd/dal/include/fixed32_32.h b/drivers/gpu/drm/amd/dal/include/fixed32_32.h
index 1a26eea..f393e95 100644
--- a/drivers/gpu/drm/amd/dal/include/fixed32_32.h
+++ b/drivers/gpu/drm/amd/dal/include/fixed32_32.h
@@ -26,7 +26,7 @@
 #ifndef __DAL_FIXED32_32_H__
 #define __DAL_FIXED32_32_H__
 
-#include "dc_services_types.h"
+#include "dm_services_types.h"
 
 struct fixed32_32 {
 	uint64_t value;
-- 
2.7.4

