From bef1b67330c2da0963e10483d6470e27c62b47af Mon Sep 17 00:00:00 2001
From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Fri, 26 Aug 2016 14:14:50 -0400
Subject: [PATCH 0949/1722] drm/amd/dal: More fine-grained surface update

Update only plane/scaling programming, address, or gamma,
depending on what actually changed.

Change-Id: I3060cfe6a3dfd73348ac342471e0cc7649f688cf
Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 154 ++++++++++++++-------
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  43 ++++--
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  13 +-
 3 files changed, 138 insertions(+), 72 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index dfbff5e..2f1a5c6 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -1382,28 +1382,118 @@ static struct pipe_ctx *find_pipe_ctx_by_surface(struct validate_context *contex
 	return pipe_ctx;
 }
 
-void dc_isr_surface_update(struct dc *dc, struct dc_surface_update *update)
+void dc_surfaces_update(struct dc *dc, struct dc_surface_update *updates,
+		int surface_count, struct dc_target *dc_target)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(update->surface);
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *context = core_dc->current_context;
-	struct pipe_ctx *pipe_ctx = NULL;
+	int i;
 
-	pipe_ctx = find_pipe_ctx_by_surface(context, surface);
+	if (dc_target) {
+		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
+		struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 
-	if (!pipe_ctx) {
-		ASSERT(pipe_ctx);
-		return;
+		if (core_dc->current_context->target_count == 0)
+			return;
+
+		/* Cannot commit surface to a target that is not commited */
+		for (i = 0; i < core_dc->current_context->target_count; i++)
+			if (target == core_dc->current_context->targets[i])
+				break;
+		if (i == core_dc->current_context->target_count)
+			return;
+
+		for (i = 0 ; i < surface_count; i++) {
+			new_surfaces[i] = updates[i].surface;
+		}
+		context = core_dc->temp_flip_context;
+		*context = *core_dc->current_context;
+
+		for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+			struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+
+			if (cur_pipe->top_pipe)
+				cur_pipe->top_pipe =
+					&context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+
+			if (cur_pipe->bottom_pipe)
+				cur_pipe->bottom_pipe =
+					&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+		}
+
+		if (!resource_attach_surfaces_to_context(
+				new_surfaces, surface_count, dc_target, context)) {
+			BREAK_TO_DEBUGGER();
+			return;
+		}
 	}
 
-	if (update->address || update->flip_immediate) {
-		if (update->address)
-			surface->public.address = *update->address;
+	for (i = 0; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+		struct pipe_ctx *pipe_ctx = find_pipe_ctx_by_surface(context, surface);
+
+		if (!pipe_ctx) {
+			ASSERT(pipe_ctx);
+			return;
+		}
+
+		if (updates[i].plane_info || updates[i].scaling_info) {
+
+			surface->public.address = updates[i].flip_addr->address;
+			surface->public.flip_immediate = updates[i].flip_addr->flip_immediate;
+
+			surface->public.color_space = updates[i].plane_info->color_space;
+			surface->public.format = updates[i].plane_info->format;
+			surface->public.plane_size = updates[i].plane_info->plane_size;
+			surface->public.rotation = updates[i].plane_info->rotation;
+			surface->public.stereo_format = updates[i].plane_info->stereo_format;
+			surface->public.tiling_info = updates[i].plane_info->tiling_info;
+			surface->public.visible = updates[i].plane_info->visible;
+
+			surface->public.scaling_quality = updates[i].scaling_info->scaling_quality;
+			surface->public.dst_rect = updates[i].scaling_info->dst_rect;
+			surface->public.src_rect = updates[i].scaling_info->src_rect;
+			surface->public.clip_rect = updates[i].scaling_info->clip_rect;
+
+			resource_build_scaling_params(updates[i].surface, pipe_ctx);
+			if (dc->debug.surface_visual_confirm) {
+				pipe_ctx->scl_data.recout.height -= 2;
+				pipe_ctx->scl_data.recout.width -= 2;
+			}
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_SURFACE,
+					true);
+
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+
+			core_dc->hwss.apply_ctx_to_surface(core_dc, context);
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_GRAPHICS |
+					PIPE_LOCK_CONTROL_SCL |
+					PIPE_LOCK_CONTROL_BLENDER |
+					PIPE_LOCK_CONTROL_SURFACE,
+					false);
+
+		} else if (updates[i].flip_addr) {
+			surface->public.address = updates[i].flip_addr->address;
+			surface->public.flip_immediate = updates[i].flip_addr->flip_immediate;
 
-		if (update->flip_immediate)
-			surface->public.flip_immediate = *update->flip_immediate;
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+		}
+
+		if (updates[i].gamma)
+			core_dc->hwss.prepare_pipe_for_context(core_dc, pipe_ctx, context);
+	}
 
-		core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+	if (dc_target) {
+		core_dc->temp_flip_context = core_dc->current_context;
+		core_dc->current_context = context;
 	}
 }
 
@@ -1454,34 +1544,6 @@ const struct audio **dc_get_audios(struct dc *dc)
 	return (const struct audio **)core_dc->res_pool.audios;
 }
 
-void dc_flip_surface_addrs_on_context(
-                struct dc *dc,
-                struct validate_context *context,
-                const struct dc_surface *const *surfaces,
-                struct dc_flip_addrs flip_addrs[],
-                uint32_t count)
-{
-        int i, j;
-        struct core_dc *core_dc = DC_TO_CORE(dc);
-        int pipe_count = core_dc->res_pool->pipe_count;
- 
-        for (i = 0; i < count; i++)
-                for (j = 0; j < pipe_count; j++) {
-                        struct pipe_ctx *pipe_ctx =
-                                &context->res_ctx.pipe_ctx[j];
-                        struct core_surface *ctx_surface = pipe_ctx->surface;
- 
-                        if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
-                                continue;
- 
-                        ctx_surface->public.address = flip_addrs[i].address;
-                        ctx_surface->public.flip_immediate = flip_addrs[i].flip_immediate;
- 
-                        core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-                }
- 
-}
-
 void dc_flip_surface_addrs(
 		struct dc *dc,
 		const struct dc_surface *const surfaces[],
@@ -1489,14 +1551,12 @@ void dc_flip_surface_addrs(
 		uint32_t count)
 {
         int i;
-
+        struct dc_surface_update updates[MAX_SURFACE_NUM] = { 0 };
         for (i = 0; i < count; i++) {
-                struct dc_surface_update update = { 0 };
-                update.address = &flip_addrs[i].address;
-                update.flip_immediate = &flip_addrs[i].flip_immediate;
-                update.surface = surfaces[i];
-                dc_isr_surface_update(dc, &update);
+                updates[i].flip_addr = &flip_addrs[i];
+                updates[i].surface = surfaces[i];
         }
+        dc_surfaces_update(dc, updates, count, NULL);
 }
 
 enum dc_irq_source dc_interrupt_to_irq_source(
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 408f6a5..b4c09c8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -172,15 +172,35 @@ struct dc_surface {
 	const struct dc_gamma *gamma_correction;
 };
 
+struct dc_plane_info {
+	union plane_size plane_size;
+	union dc_tiling_info tiling_info;
+	enum surface_pixel_format format;
+	enum dc_rotation_angle rotation;
+	enum plane_stereo_format stereo_format;
+	enum dc_color_space color_space;
+	bool visible;
+};
+
+struct dc_scaling_info {
+		struct rect src_rect;
+		struct rect dst_rect;
+		struct rect clip_rect;
+		struct scaling_taps scaling_quality;
+};
+
 struct dc_surface_update {
 	const struct dc_surface *surface;
 
-	/* update parameters.  null means no updates */
-	struct dc_plane_address *address;
-	bool *flip_immediate;
-/*	struct rect *src_rect;
-	struct rect *dst_rect;
-	struct rect *clip_rect;*/
+	/* isr safe update parameters.  null means no updates */
+	struct dc_flip_addrs *flip_addr;
+	struct dc_plane_info *plane_info;
+	struct dc_scaling_info *scaling_info;
+	/* following updates require alloc/sleep/spin that is not isr safe,
+	 * null means no updates
+	 */
+	struct dc_gamma *gamma;
+
 
 };
 /*
@@ -242,14 +262,6 @@ void dc_flip_surface_addrs(struct dc *dc,
  *   This does not trigger a flip.  No surface address is programmed.
  */
 
-
-void dc_flip_surface_addrs_on_context(
-		struct dc *dc,
-		struct validate_context *context,
-		const struct dc_surface *const *surfaces,
-		struct dc_flip_addrs flip_addrs[],
-		uint32_t count);
-
 bool dc_commit_surfaces_to_target(
 		struct dc *dc,
 		const struct dc_surface **dc_surfaces,
@@ -278,7 +290,8 @@ bool dc_update_surfaces_for_target(
 		uint8_t surface_count,
 		struct dc_target *dc_target);
 
-void dc_isr_surface_update(struct dc *dc, struct dc_surface_update *update);
+void dc_surfaces_update(struct dc *dc, struct dc_surface_update *updates,
+		int surface_count, struct dc_target *dc_target);
 /*******************************************************************************
  * Target Interfaces
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index c434906..afbd15d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -424,15 +424,10 @@ static bool set_gamma_ramp(
 	const struct core_gamma *ramp,
 	const struct core_surface *surface)
 {
-	struct ipp_prescale_params *prescale_params;
+	struct ipp_prescale_params prescale_params = { 0 };
 	struct pwl_params *regamma_params;
 	bool result = false;
 
-	prescale_params = dm_alloc(sizeof(struct ipp_prescale_params));
-
-	if (prescale_params == NULL)
-		goto prescale_alloc_fail;
-
 	regamma_params = dm_alloc(sizeof(struct pwl_params));
 	if (regamma_params == NULL)
 		goto regamma_alloc_fail;
@@ -442,8 +437,8 @@ static bool set_gamma_ramp(
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 
 	if (ipp) {
-		build_prescale_params(prescale_params, surface);
-		ipp->funcs->ipp_program_prescale(ipp, prescale_params);
+		build_prescale_params(&prescale_params, surface);
+		ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 	}
 
 	if (ramp && calculate_regamma_params(regamma_params, ramp, surface)) {
@@ -465,8 +460,6 @@ static bool set_gamma_ramp(
 	dm_free(regamma_params);
 
 regamma_alloc_fail:
-	dm_free(prescale_params);
-prescale_alloc_fail:
 	return result;
 }
 
-- 
2.7.4

