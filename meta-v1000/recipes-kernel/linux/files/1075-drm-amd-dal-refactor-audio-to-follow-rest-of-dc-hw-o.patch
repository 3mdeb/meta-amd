From 885e98c3d679826efc12924366fec2f2d5fd961f Mon Sep 17 00:00:00 2001
From: Tony Cheng <tony.cheng@amd.com>
Date: Tue, 13 Sep 2016 14:08:36 -0400
Subject: [PATCH 1075/1722] drm/amd/dal: refactor audio to follow rest of dc hw
 object step 1

- resource instantiate audio following pattern of dc HW objects
- remove AS dependancy from audio

Change-Id: I3beb600bdfb92c2532cde1458b1399f2d856872a
Signed-off-by: Tony Cheng <tony.cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/audio/audio_base.c      |  37 --
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    | 465 ++++++++++---------
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |   4 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    | 497 +++++++++++----------
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  | 469 +++++++++----------
 drivers/gpu/drm/amd/dal/include/audio_interface.h  |   3 -
 6 files changed, 747 insertions(+), 728 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
index 165bfb5..2f30d96 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
@@ -139,8 +139,6 @@ bool dal_audio_construct_base(
 	struct audio *audio,
 	const struct audio_init_data *init_data)
 {
-	ASSERT(init_data->as != NULL);
-
 	/* base hook functions */
 	audio->funcs = &audio_funcs;
 
@@ -158,41 +156,6 @@ void dal_audio_destruct_base(
 {
 }
 
-/***** SCOPE : declare in dal\include  *****/
-
-/* audio object creator triage. memory allocate and release will be
- * done within dal_audio_create_dcexx
- */
-struct audio *dal_audio_create(
-	const struct audio_init_data *init_data)
-{
-	struct adapter_service *as = init_data->as;
-
-	switch (dal_adapter_service_get_dce_version(as)) {
-#if defined(CONFIG_DRM_AMD_DAL_DCE8_0)
-	case DCE_VERSION_8_0:
-		return dal_audio_create_dce80(init_data);
-#endif
-#if defined(CONFIG_DRM_AMD_DAL_DCE10_0)
-	case DCE_VERSION_10_0:
-		return dal_audio_create_dce110(init_data);
-#endif
-#if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
-	case DCE_VERSION_11_0:
-		return dal_audio_create_dce110(init_data);
-#endif
-#if defined(CONFIG_DRM_AMD_DAL_DCE11_2)
-	case DCE_VERSION_11_2:
-		return dal_audio_create_dce110(init_data);
-#endif
-	default:
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	return NULL;
-}
-
 /* audio object creator triage.
  * memory for "struct audio   dal_audio_create_dce8x" allocate
  * will happens within dal_audio_dce8x. memory allocate is done
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 6b40ec33..ed5510c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -42,6 +42,7 @@
 #include "dce110/dce110_stream_encoder.h"
 #include "dce110/dce110_opp.h"
 #include "dce110/dce110_clock_source.h"
+#include "audio/dce110/audio_dce110.h"
 
 #include "dce100/dce100_hw_sequencer.h"
 #include "dce/dce_10_0_d.h"
@@ -775,255 +776,273 @@ static const struct resource_funcs dce100_res_pool_funcs = {ce100_res_pool_funcs
 	.validate_bandwidth = dce100_validate_bandwidth
 };
 
-bool dce100_construct_resource_pool(
-	struct adapter_service *as,
-	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool)
+static bool construct(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc,
+        struct dce110_resource_pool *pool)
 {
-	unsigned int i;
-	struct audio_init_data audio_init_data = { 0 };
-	struct dc_context *ctx = dc->ctx;
-	struct firmware_info info;
-	struct dc_bios *bp;
-
-	pool->adapter_srv = as;
-	pool->funcs = &dce100_res_pool_funcs;
-
-	pool->stream_engines.engine.ENGINE_ID_DIGA = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGB = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGC = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGD = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGE = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-	bp = dal_adapter_service_get_bios_parser(as);
-
-	if (dal_adapter_service_get_firmware_info(as, &info) &&
-		info.external_clock_source_frequency_for_dp != 0) {
-		pool->dp_clock_source =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
-
-		pool->clock_sources[0] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
-		pool->clock_sources[1] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
-		pool->clock_sources[2] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
-		pool->clk_src_count = 3;
-
-	} else {
-		pool->dp_clock_source =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
-		pool->clock_sources[0] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
-		pool->clock_sources[1] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
-		pool->clk_src_count = 2;
-	}
-
-	if (pool->dp_clock_source == NULL) {
-		dm_error("DC: failed to create dp clock source!\n");
-		BREAK_TO_DEBUGGER();
-		goto clk_src_create_fail;
-	}
-
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] == NULL) {
-			dm_error("DC: failed to create clock sources!\n");
-			BREAK_TO_DEBUGGER();
-			goto clk_src_create_fail;
-		}
-	}
-
-	pool->display_clock = dal_display_clock_dce110_create(ctx, as);
-	if (pool->display_clock == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto disp_clk_create_fail;
-	}
-
-	{
-		struct irq_service_init_data init_data;
+        unsigned int i;
+        struct audio_init_data audio_init_data = { 0 };
+        struct dc_context *ctx = dc->ctx;
+        struct firmware_info info;
+        struct dc_bios *bp;
+
+        pool->base.adapter_srv = as;
+        pool->base.funcs = &dce100_res_pool_funcs;
+
+        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+        bp = dal_adapter_service_get_bios_parser(as);
+
+        if (dal_adapter_service_get_firmware_info(as, &info) &&
+                info.external_clock_source_frequency_for_dp != 0) {
+                pool->base.dp_clock_source =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+
+                pool->base.clock_sources[0] =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
+                pool->base.clock_sources[1] =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
+                pool->base.clock_sources[2] =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
+                pool->base.clk_src_count = 3;
+
+        } else {
+                pool->base.dp_clock_source =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
+                pool->base.clock_sources[0] =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
+                pool->base.clock_sources[1] =
+                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
+                pool->base.clk_src_count = 2;
+        }
+
+        if (pool->base.dp_clock_source == NULL) {
+                dm_error("DC: failed to create dp clock source!\n");
+                BREAK_TO_DEBUGGER();
+                goto clk_src_create_fail;
+        }
+
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] == NULL) {
+                        dm_error("DC: failed to create clock sources!\n");
+                        BREAK_TO_DEBUGGER();
+                        goto clk_src_create_fail;
+                }
+        }
+
+        pool->base.display_clock = dal_display_clock_dce110_create(ctx, as);
+        if (pool->base.display_clock == NULL) {
+                dm_error("DC: failed to create display clock!\n");
+                BREAK_TO_DEBUGGER();
+                goto disp_clk_create_fail;
+        }
+
+        {
+                struct irq_service_init_data init_data;
+
+                init_data.ctx = dc->ctx;
+                pool->base.irqs = dal_irq_service_create(
+                                dal_adapter_service_get_dce_version(
+                                        pool->base.adapter_srv),
+                                &init_data);
+                if (!pool->base.irqs)
+                        goto irqs_create_fail;
+
+        }
 
-		init_data.ctx = dc->ctx;
-		pool->irqs = dal_irq_service_create(
-				dal_adapter_service_get_dce_version(
-					dc->res_pool.adapter_srv),
-				&init_data);
-		if (!pool->irqs)
-			goto irqs_create_fail;
-
-	}
         /*************************************************
         *  Resource + asic cap harcoding                *
         *************************************************/
-	pool->pipe_count = dal_adapter_service_get_func_controllers_num(as);
-	pool->stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
-	pool->scaler_filter = dal_scaler_filter_create(ctx);
+        pool->base.pipe_count = dal_adapter_service_get_func_controllers_num(as);
+        pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
+        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
         dc->public.caps.max_downscale_ratio = 200;
         dc->public.caps.i2c_speed_in_khz = 40;
-	
-	if (pool->scaler_filter == NULL) {
-		BREAK_TO_DEBUGGER();
-		dm_error("DC: failed to create filter!\n");
-		goto filter_create_fail;
-	}
 
-	for (i = 0; i < pool->pipe_count; i++) {
-		pool->timing_generators[i] =
-			dce100_timing_generator_create(
-				as,
-				ctx,
-				i,
-				&dce100_tg_offsets[i]);
-		if (pool->timing_generators[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create tg!\n");
-			goto controller_create_fail;
-		}
+        if (pool->base.scaler_filter == NULL) {
+                BREAK_TO_DEBUGGER();
+                dm_error("DC: failed to create filter!\n");
+                goto filter_create_fail;
+        }
+
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                pool->base.timing_generators[i] =
+                        dce100_timing_generator_create(
+                                as,
+                                ctx,
+                                i,
+                                &dce100_tg_offsets[i]);
+                if (pool->base.timing_generators[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create tg!\n");
+                        goto controller_create_fail;
+                }
 
                 pool->base.mis[i] = dce100_mem_input_create(ctx, as, i,
-				&dce100_mi_reg_offsets[i]);
-		if (pool->mis[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create memory input!\n");
-			goto controller_create_fail;
-		}
-
-		pool->ipps[i] = dce100_ipp_create(ctx, i,
-				&dce100_ipp_reg_offsets[i]);
-		if (pool->ipps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create input pixel processor!\n");
-			goto controller_create_fail;
-		}
-
-		pool->transforms[i] = dce100_transform_create(
-					ctx, i, &dce100_xfm_offsets[i]);
-		if (pool->transforms[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create transform!\n");
-			goto controller_create_fail;
-		}
-		pool->transforms[i]->funcs->transform_set_scaler_filter(
-				pool->transforms[i],
-				pool->scaler_filter);
-
-		pool->opps[i] = dce100_opp_create(ctx, i, &dce100_opp_reg_offsets[i]);
-		if (pool->opps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create output pixel processor!\n");
-			goto controller_create_fail;
-		}
-	}
-
-	audio_init_data.as = as;
-	audio_init_data.ctx = ctx;
-	pool->audio_count = 0;
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct graphics_object_id obj_id;
-
-		obj_id = dal_adapter_service_enum_audio_object(as, i);
-		if (false == dal_graphics_object_id_is_valid(obj_id)) {
-			/* no more valid audio objects */
-			break;
-		}
-
-		audio_init_data.audio_stream_id = obj_id;
-		pool->audios[i] = dal_audio_create(&audio_init_data);
-		if (pool->audios[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create DPPs!\n");
-			goto audio_create_fail;
-		}
-		pool->audio_count++;
-	}
-
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		/* TODO: rework fragile code*/
-		if (pool->stream_engines.u_all & 1 << i) {
-			pool->stream_enc[i] = dce100_stream_encoder_create(
-				i, dc->ctx,
-				dal_adapter_service_get_bios_parser(as),
-				&stream_enc_regs[i]);
-			if (pool->stream_enc[i] == NULL) {
-				BREAK_TO_DEBUGGER();
-				dm_error("DC: failed to create stream_encoder!\n");
-				goto stream_enc_create_fail;
-			}
-		}
-	}
-
-	for (i = 0; i < num_virtual_links; i++) {
-		pool->stream_enc[pool->stream_enc_count] =
-			virtual_stream_encoder_create(
-				dc->ctx,
-				dal_adapter_service_get_bios_parser(as));
-		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create stream_encoder!\n");
-			goto stream_enc_create_fail;
-		}
-		pool->stream_enc_count++;
-	}
-
-	/* Create hardware sequencer */
-	if (!dce100_hw_sequencer_construct(dc))
-		goto stream_enc_create_fail;
-
-	return true;
+                                &dce100_mi_reg_offsets[i]);
+                if (pool->base.mis[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create memory input!\n");
+                        goto controller_create_fail;
+                }
+                pool->base.ipps[i] = dce100_ipp_create(ctx, i,
+                                &dce100_ipp_reg_offsets[i]);
+                if (pool->base.ipps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create input pixel processor!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.transforms[i] = dce100_transform_create(
+                                        ctx, i, &dce100_xfm_offsets[i]);
+                if (pool->base.transforms[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create transform!\n");
+                        goto controller_create_fail;
+                }
+                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+                                pool->base.transforms[i],
+                                pool->base.scaler_filter);
+
+                pool->base.opps[i] = dce100_opp_create(ctx, i, &dce100_opp_reg_offsets[i]);
+                if (pool->base.opps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create output pixel processor!\n");
+                        goto controller_create_fail;
+                }
+        }
+
+        audio_init_data.ctx = ctx;
+        pool->base.audio_count = 0;
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                struct graphics_object_id obj_id;
+
+                obj_id = dal_adapter_service_enum_audio_object(as, i);
+                if (false == dal_graphics_object_id_is_valid(obj_id)) {
+                        /* no more valid audio objects */
+                        break;
+                }
+
+                audio_init_data.audio_stream_id = obj_id;
+                pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
+                if (pool->base.audios[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create DPPs!\n");
+                        goto audio_create_fail;
+                }
+                pool->base.audio_count++;
+        }
+
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                /* TODO: rework fragile code*/
+                if (pool->base.stream_engines.u_all & 1 << i) {
+                        pool->base.stream_enc[i] = dce100_stream_encoder_create(
+                                i, dc->ctx,
+                                 dal_adapter_service_get_bios_parser(as),
+                                &stream_enc_regs[i]);
+                        if (pool->base.stream_enc[i] == NULL) {
+                                BREAK_TO_DEBUGGER();
+                                dm_error("DC: failed to create stream_encoder!\n");
+                                goto stream_enc_create_fail;
+                        }
+                }
+        }
+
+        for (i = 0; i < num_virtual_links; i++) {
+                pool->base.stream_enc[pool->base.stream_enc_count] =
+                        virtual_stream_encoder_create(
+                                dc->ctx,
+                                dal_adapter_service_get_bios_parser(as));
+                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create stream_encoder!\n");
+                        goto stream_enc_create_fail;
+                }
+                pool->base.stream_enc_count++;
+        }
+
+        /* Create hardware sequencer */
+        if (!dce100_hw_sequencer_construct(dc))
+                goto stream_enc_create_fail;
+
+        return true;
 
 stream_enc_create_fail:
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
 audio_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->audios[i] != NULL)
-			dal_audio_destroy(&pool->audios[i]);
-	}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.audios[i] != NULL)
+                        dal_audio_destroy(&pool->base.audios[i]);
+        }
 
 controller_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce100_opp_destroy(&pool->opps[i]);
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce100_opp_destroy(&pool->base.opps[i]);
 
-		if (pool->transforms[i] != NULL)
-			dce100_transform_destroy(&pool->transforms[i]);
+                if (pool->base.transforms[i] != NULL)
+                        dce100_transform_destroy(&pool->base.transforms[i]);
 
-		if (pool->ipps[i] != NULL)
-			dce110_ipp_destroy(&pool->ipps[i]);
+                if (pool->base.ipps[i] != NULL)
+                        dce110_ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
 
-		if (pool->timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+                if (pool->base.timing_generators[i] != NULL)    {
+                         dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
 filter_create_fail:
-	dal_irq_service_destroy(&pool->irqs);
+        dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-	dal_display_clock_destroy(&pool->display_clock);
+        dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL)
-			dce100_clock_source_destroy(&pool->clock_sources[i]);
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL)
+                        dce100_clock_source_destroy(&pool->base.clock_sources[i]);
+        }
 
-	return false;
+        return false;
 }
+
+struct resource_pool *dce100_create_resource_pool(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc)
+{
+        struct dce110_resource_pool *pool =
+                dm_alloc(sizeof(struct dce110_resource_pool));
+
+        if (!pool)
+                return NULL;
+
+        if (construct(as, num_virtual_links, dc, pool))
+                return &pool->base;
+
+        BREAK_TO_DEBUGGER();
+        return NULL;
+}
+
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index ea92199..df0df34 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -43,6 +43,7 @@
 #include "dce110/dce110_opp.h"
 #include "dce110/dce110_opp_v.h"
 #include "dce110/dce110_clock_source.h"
+#include "audio/dce110/audio_dce110.h"
 
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_11_0_d.h"
@@ -1276,7 +1277,6 @@ static bool construct(
         /* TODO: failure? */
         underlay_create(ctx, &pool->base);
 
-        audio_init_data.as = as;
         audio_init_data.ctx = ctx;
         pool->base.audio_count = 0;
         for (i = 0; i < pool->base.pipe_count; i++) {
@@ -1289,7 +1289,7 @@ static bool construct(
                 }
 
                 audio_init_data.audio_stream_id = obj_id;
-                pool->base.audios[i] = dal_audio_create(&audio_init_data);
+                pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
                 if (pool->base.audios[i] == NULL) {
                         BREAK_TO_DEBUGGER();
                         dm_error("DC: failed to create DPPs!\n");
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 804909a..ae86620 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -41,8 +41,10 @@
 #include "dce112/dce112_opp.h"
 #include "dce110/dce110_ipp.h"
 #include "dce112/dce112_clock_source.h"
+#include "audio/dce110/audio_dce110.h"
 
 #include "dce112/dce112_hw_sequencer.h"
+
 #include "dce/dce_11_2_d.h"
 
 #ifndef mmDP_DPHY_INTERNAL_CTRL
@@ -1083,266 +1085,283 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 		1000);
 }
 
-
-bool dce112_construct_resource_pool(
-	struct adapter_service *adapter_serv,
-	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool)
+static bool construct(
+        struct adapter_service *adapter_serv,
+        uint8_t num_virtual_links,
+        struct core_dc *dc,
+        struct dce110_resource_pool *pool)
 {
-	unsigned int i;
-	struct audio_init_data audio_init_data = { 0 };
-	struct dc_context *ctx = dc->ctx;
-
-	pool->adapter_srv = adapter_serv;
-	pool->funcs = &dce112_res_pool_funcs;
-
-	/*************************************************
-	 *  Resource + asic cap harcoding                *
-	 *************************************************/
-	pool->pipe_count =
-		dal_adapter_service_get_func_controllers_num(adapter_serv);
-	pool->stream_enc_count = dal_adapter_service_get_stream_engines_num(adapter_serv);
+        unsigned int i;
+        struct audio_init_data audio_init_data = { 0 };
+        struct dc_context *ctx = dc->ctx;
+
+        pool->base.adapter_srv = adapter_serv;
+        pool->base.funcs = &dce112_res_pool_funcs;
+
+        /*************************************************
+         *  Resource + asic cap harcoding                *
+         *************************************************/
+        pool->base.pipe_count =
+                dal_adapter_service_get_func_controllers_num(adapter_serv);
+        pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(adapter_serv);
         dc->public.caps.max_downscale_ratio = 200;
         dc->public.caps.i2c_speed_in_khz = 100;
 
-	/*************************************************
-	 *  Create resources                             *
-	 *************************************************/
-
-	pool->stream_engines.engine.ENGINE_ID_DIGA = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGB = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGC = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGD = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGE = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-	pool->clock_sources[DCE112_CLK_SRC_PLL0] = dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0]);
-	pool->clock_sources[DCE112_CLK_SRC_PLL1] = dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1]);
-	pool->clock_sources[DCE112_CLK_SRC_PLL2] = dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2]);
-	pool->clock_sources[DCE112_CLK_SRC_PLL3] = dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3]);
-	pool->clock_sources[DCE112_CLK_SRC_PLL4] = dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4]);
-	pool->clock_sources[DCE112_CLK_SRC_PLL5] = dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5]);
-	pool->clk_src_count = DCE112_CLK_SRC_TOTAL;
-
-	pool->dp_clock_source =  dce112_clock_source_create(
-		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_ID_DP_DTO, &dce112_clk_src_reg_offsets[0]);
-
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] == NULL) {
-			dm_error("DC: failed to create clock sources!\n");
-			BREAK_TO_DEBUGGER();
-			goto clk_src_create_fail;
-		}
-	}
-
-	pool->display_clock = dal_display_clock_dce112_create(ctx, adapter_serv);
-	if (pool->display_clock == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto disp_clk_create_fail;
-	}
-
-	{
-		struct irq_service_init_data init_data;
-		init_data.ctx = dc->ctx;
-		pool->irqs = dal_irq_service_create(
-				dal_adapter_service_get_dce_version(
-					dc->res_pool.adapter_srv),
-				&init_data);
-		if (!pool->irqs)
-			goto irqs_create_fail;
-
-	}
-
-	pool->scaler_filter = dal_scaler_filter_create(ctx);
-	if (pool->scaler_filter == NULL) {
-		BREAK_TO_DEBUGGER();
-		dm_error("DC: failed to create filter!\n");
-		goto filter_create_fail;
-	}
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		pool->timing_generators[i] = dce112_timing_generator_create(
-				adapter_serv,
-				ctx,
-				i,
-				&dce112_tg_offsets[i]);
-		if (pool->timing_generators[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create tg!\n");
-			goto controller_create_fail;
-		}
-
-		pool->mis[i] = dce112_mem_input_create(
-			ctx,
+        /*************************************************
+         *  Create resources                             *
+         *************************************************/
+
+        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+        pool->base.clock_sources[DCE112_CLK_SRC_PLL0] = dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0]);
+        pool->base.clock_sources[DCE112_CLK_SRC_PLL1] = dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1]);
+        pool->base.clock_sources[DCE112_CLK_SRC_PLL2] = dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2]);
+        pool->base.clock_sources[DCE112_CLK_SRC_PLL3] = dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3]);
+        pool->base.clock_sources[DCE112_CLK_SRC_PLL4] = dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4]);
+        pool->base.clock_sources[DCE112_CLK_SRC_PLL5] = dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5]);
+        pool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;
+
+        pool->base.dp_clock_source =  dce112_clock_source_create(
+                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+                CLOCK_SOURCE_ID_DP_DTO, &dce112_clk_src_reg_offsets[0]);
+
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] == NULL) {
+                        dm_error("DC: failed to create clock sources!\n");
+                        BREAK_TO_DEBUGGER();
+                        goto clk_src_create_fail;
+                }
+        }
+
+        pool->base.display_clock = dal_display_clock_dce112_create(ctx, adapter_serv);
+        if (pool->base.display_clock == NULL) {
+                dm_error("DC: failed to create display clock!\n");
+                BREAK_TO_DEBUGGER();
+                goto disp_clk_create_fail;
+        }
+
+        {
+                struct irq_service_init_data init_data;
+                init_data.ctx = dc->ctx;
+                pool->base.irqs = dal_irq_service_create(
+                                dal_adapter_service_get_dce_version(
+                                        pool->base.adapter_srv),
+                                &init_data);
+                if (!pool->base.irqs)
+                        goto irqs_create_fail;
+
+        }
+
+        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+        if (pool->base.scaler_filter == NULL) {
+                BREAK_TO_DEBUGGER();
+                dm_error("DC: failed to create filter!\n");
+                goto filter_create_fail;
+        }
+
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                pool->base.timing_generators[i] = dce112_timing_generator_create(
+                                adapter_serv,
+                                ctx,
+                                i,
+                                &dce112_tg_offsets[i]);
+                if (pool->base.timing_generators[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create tg!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.mis[i] = dce112_mem_input_create(
+                        ctx,
                         adapter_serv,
-			i,
-			&dce112_mi_reg_offsets[i]);
-		if (pool->mis[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create memory input!\n");
-			goto controller_create_fail;
-		}
-
-		pool->ipps[i] = dce112_ipp_create(
-			ctx,
-			i,
-			&ipp_reg_offsets[i]);
-		if (pool->ipps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create input pixel processor!\n");
-			goto controller_create_fail;
-		}
-
-		pool->transforms[i] = dce112_transform_create(
-				ctx,
-				i,
-				&dce112_xfm_offsets[i]);
-		if (pool->transforms[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create transform!\n");
-			goto controller_create_fail;
-		}
-		pool->transforms[i]->funcs->transform_set_scaler_filter(
-				pool->transforms[i],
-				pool->scaler_filter);
-
-		pool->opps[i] = dce112_opp_create(
-			ctx,
-			i,
-			&dce112_opp_reg_offsets[i]);
-		if (pool->opps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create output pixel processor!\n");
-			goto controller_create_fail;
-		}
-	}
-
-	audio_init_data.as = adapter_serv;
-	audio_init_data.ctx = ctx;
-	pool->audio_count = 0;
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct graphics_object_id obj_id;
-
-		obj_id = dal_adapter_service_enum_audio_object(adapter_serv, i);
-		if (false == dal_graphics_object_id_is_valid(obj_id)) {
-			/* no more valid audio objects */
-			break;
-		}
-
-		audio_init_data.audio_stream_id = obj_id;
-		pool->audios[i] = dal_audio_create(&audio_init_data);
-		if (pool->audios[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create DPPs!\n");
-			goto audio_create_fail;
-		}
-		pool->audio_count++;
-	}
-
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		/* TODO: rework fragile code*/
-		if (pool->stream_engines.u_all & 1 << i) {
-			pool->stream_enc[i] = dce112_stream_encoder_create(
-				i, dc->ctx,
-				dal_adapter_service_get_bios_parser(
-					adapter_serv),
-				&stream_enc_regs[i]);
-			if (pool->stream_enc[i] == NULL) {
-				BREAK_TO_DEBUGGER();
-				dm_error("DC: failed to create stream_encoder!\n");
-				goto stream_enc_create_fail;
-			}
-		}
-	}
-
-	for (i = 0; i < num_virtual_links; i++) {
-		pool->stream_enc[pool->stream_enc_count] =
-			virtual_stream_encoder_create(
-				dc->ctx, dal_adapter_service_get_bios_parser(
-								adapter_serv));
-		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create stream_encoder!\n");
-			goto stream_enc_create_fail;
-		}
-		pool->stream_enc_count++;
-	}
-
-	/* Create hardware sequencer */
-	if (!dce112_hw_sequencer_construct(dc))
-		goto stream_enc_create_fail;
-
-	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_BAFFIN);
-
-	bw_calcs_data_update_from_pplib(dc);
-
-	return true;
+                        i,
+                        &dce112_mi_reg_offsets[i]);
+                if (pool->base.mis[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create memory input!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.ipps[i] = dce112_ipp_create(
+                        ctx,
+                        i,
+                        &ipp_reg_offsets[i]);
+                if (pool->base.ipps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create input pixel processor!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.transforms[i] = dce112_transform_create(
+                                ctx,
+                                i,
+                                &dce112_xfm_offsets[i]);
+                if (pool->base.transforms[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create transform!\n");
+                        goto controller_create_fail;
+                }
+                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+                                pool->base.transforms[i],
+                                pool->base.scaler_filter);
+
+                pool->base.opps[i] = dce112_opp_create(
+                        ctx,
+                        i,
+                        &dce112_opp_reg_offsets[i]);
+                if (pool->base.opps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create output pixel processor!\n");
+                        goto controller_create_fail;
+                }
+        }
+
+        audio_init_data.ctx = ctx;
+        pool->base.audio_count = 0;
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                struct graphics_object_id obj_id;
+
+                obj_id = dal_adapter_service_enum_audio_object(adapter_serv, i);
+                if (false == dal_graphics_object_id_is_valid(obj_id)) {
+                        /* no more valid audio objects */
+                        break;
+                }
+
+                audio_init_data.audio_stream_id = obj_id;
+		pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
+                if (pool->base.audios[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create DPPs!\n");
+                        goto audio_create_fail;
+                }
+                pool->base.audio_count++;
+        }
+
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                /* TODO: rework fragile code*/
+                if (pool->base.stream_engines.u_all & 1 << i) {
+                        pool->base.stream_enc[i] = dce112_stream_encoder_create(
+                                i, dc->ctx,
+                                dal_adapter_service_get_bios_parser(
+                                        adapter_serv),
+                                &stream_enc_regs[i]);
+                        if (pool->base.stream_enc[i] == NULL) {
+                                BREAK_TO_DEBUGGER();
+                                dm_error("DC: failed to create stream_encoder!\n");
+                                goto stream_enc_create_fail;
+                        }
+                }
+        }
+
+        for (i = 0; i < num_virtual_links; i++) {
+                pool->base.stream_enc[pool->base.stream_enc_count] =
+                        virtual_stream_encoder_create(
+                                dc->ctx, dal_adapter_service_get_bios_parser(
+                                                                adapter_serv));
+                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create stream_encoder!\n");
+                        goto stream_enc_create_fail;
+                }
+                pool->base.stream_enc_count++;
+        }
+
+        /* Create hardware sequencer */
+        if (!dce112_hw_sequencer_construct(dc))
+                goto stream_enc_create_fail;
+
+        bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_BAFFIN);
+
+        bw_calcs_data_update_from_pplib(dc);
+
+        return true;
 
 stream_enc_create_fail:
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
 audio_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->audios[i] != NULL)
-			dal_audio_destroy(&pool->audios[i]);
-	}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.audios[i] != NULL)
+                        dal_audio_destroy(&pool->base.audios[i]);
+        }
 
 controller_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce112_opp_destroy(&pool->opps[i]);
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce112_opp_destroy(&pool->base.opps[i]);
 
-		if (pool->transforms[i] != NULL)
-			dce112_transform_destroy(&pool->transforms[i]);
+                if (pool->base.transforms[i] != NULL)
+                        dce112_transform_destroy(&pool->base.transforms[i]);
 
-		if (pool->ipps[i] != NULL)
-			dce112_ipp_destroy(&pool->ipps[i]);
+                if (pool->base.ipps[i] != NULL)
+                        dce112_ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
 
-		if (pool->timing_generators[i] != NULL) {
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+                if (pool->base.timing_generators[i] != NULL) {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
 filter_create_fail:
-	dal_irq_service_destroy(&pool->irqs);
+        dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-	dal_display_clock_destroy(&pool->display_clock);
+        dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL)
-			dce112_clock_source_destroy(&pool->clock_sources[i]);
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL)
+                        dce112_clock_source_destroy(&pool->base.clock_sources[i]);
+        }
 
-	return false;
+        return false;
 }
+
+struct resource_pool *dce112_create_resource_pool(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc)
+{
+        struct dce110_resource_pool *pool =
+                dm_alloc(sizeof(struct dce110_resource_pool));
+
+        if (!pool)
+                return NULL;
+
+        if (construct(as, num_virtual_links, dc, pool))
+                return &pool->base;
+
+        BREAK_TO_DEBUGGER();
+        return NULL;
+}
+
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 5c3dafe..af2dc67 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -45,7 +45,10 @@
 #include "dce80/dce80_opp.h"
 #include "dce110/dce110_ipp.h"
 #include "dce110/dce110_clock_source.h"
+#include "audio/dce80/audio_dce80.h"
+
 #include "dce80/dce80_hw_sequencer.h"
+
 #include "dce/dce_8_0_d.h"
 
 /* TODO remove this include */
@@ -715,251 +718,269 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_bandwidth = dce80_validate_bandwidth
 };
 
-bool dce80_construct_resource_pool(
-	struct adapter_service *as,
-	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool)
+static bool construct(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc,
+        struct dce110_resource_pool *pool)
 {
-	unsigned int i;
-	struct audio_init_data audio_init_data = { 0 };
-	struct dc_context *ctx = dc->ctx;
-	struct firmware_info info;
-	struct dc_bios *bp;
+        unsigned int i;
+        struct audio_init_data audio_init_data = { 0 };
+        struct dc_context *ctx = dc->ctx;
+        struct firmware_info info;
+        struct dc_bios *bp;
 
-	pool->adapter_srv = as;
-	pool->funcs = &dce80_res_pool_funcs;
+        pool->base.adapter_srv = as;
+        pool->base.funcs = &dce80_res_pool_funcs;
 
 
-	/*************************************************
-	 *  Resource + asic cap harcoding                *
-	 *************************************************/
-	pool->pipe_count = dal_adapter_service_get_func_controllers_num(as);
-	pool->stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
+        /*************************************************
+         *  Resource + asic cap harcoding                *
+         *************************************************/
+        pool->base.pipe_count = dal_adapter_service_get_func_controllers_num(as);
+        pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
         dc->public.caps.max_downscale_ratio = 200;
         dc->public.caps.i2c_speed_in_khz = 40;
 
-	/*************************************************
-	 *  Create resources                             *
-	 *************************************************/
-
-	pool->stream_engines.engine.ENGINE_ID_DIGA = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGB = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGC = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGD = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGE = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-	bp = dal_adapter_service_get_bios_parser(as);
-
-	if (dal_adapter_service_get_firmware_info(as, &info) &&
-		info.external_clock_source_frequency_for_dp != 0) {
-		pool->dp_clock_source =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
-
-		pool->clock_sources[0] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
-		pool->clock_sources[1] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
-		pool->clock_sources[2] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
-		pool->clk_src_count = 3;
-
-	} else {
-		pool->dp_clock_source =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
-		pool->clock_sources[0] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
-		pool->clock_sources[1] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
-		pool->clk_src_count = 2;
-	}
-
-	if (pool->dp_clock_source == NULL) {
-		dm_error("DC: failed to create dp clock source!\n");
-		BREAK_TO_DEBUGGER();
-		goto clk_src_create_fail;
-	}
-
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] == NULL) {
-			dm_error("DC: failed to create clock sources!\n");
-			BREAK_TO_DEBUGGER();
-			goto clk_src_create_fail;
-		}
-	}
-
-	pool->display_clock = dal_display_clock_dce80_create(ctx, as);
-	if (pool->display_clock == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto disp_clk_create_fail;
-	}
-
-	{
-		struct irq_service_init_data init_data;
-		init_data.ctx = dc->ctx;
-		pool->irqs = dal_irq_service_create(
-				dal_adapter_service_get_dce_version(
-					dc->res_pool.adapter_srv),
-				&init_data);
-		if (!pool->irqs)
-			goto irqs_create_fail;
-
-	}
-
-	pool->scaler_filter = dal_scaler_filter_create(ctx);
-	if (pool->scaler_filter == NULL) {
-		BREAK_TO_DEBUGGER();
-		dm_error("DC: failed to create filter!\n");
-		goto filter_create_fail;
-	}
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		pool->timing_generators[i] = dce80_timing_generator_create(
-				as, ctx, i, &dce80_tg_offsets[i]);
-		if (pool->timing_generators[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create tg!\n");
-			goto controller_create_fail;
-		}
+        /*************************************************
+         *  Create resources                             *
+         *************************************************/
+
+        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+        bp = dal_adapter_service_get_bios_parser(as);
+
+        if (dal_adapter_service_get_firmware_info(as, &info) &&
+                info.external_clock_source_frequency_for_dp != 0) {
+                pool->base.dp_clock_source =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+
+                pool->base.clock_sources[0] =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
+                pool->base.clock_sources[1] =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
+                pool->base.clock_sources[2] =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
+                pool->base.clk_src_count = 3;
+
+        } else {
+                pool->base.dp_clock_source =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
+                pool->base.clock_sources[0] =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
+                pool->base.clock_sources[1] =
+                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
+                pool->base.clk_src_count = 2;
+        }
+
+        if (pool->base.dp_clock_source == NULL) {
+                dm_error("DC: failed to create dp clock source!\n");
+                BREAK_TO_DEBUGGER();
+                goto clk_src_create_fail;
+        }
+
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] == NULL) {
+                        dm_error("DC: failed to create clock sources!\n");
+                        BREAK_TO_DEBUGGER();
+                        goto clk_src_create_fail;
+                }
+        }
+
+        pool->base.display_clock = dal_display_clock_dce80_create(ctx, as);
+        if (pool->base.display_clock == NULL) {
+                dm_error("DC: failed to create display clock!\n");
+                BREAK_TO_DEBUGGER();
+                goto disp_clk_create_fail;
+        }
+
+        {
+                struct irq_service_init_data init_data;
+                init_data.ctx = dc->ctx;
+                pool->base.irqs = dal_irq_service_create(
+                                dal_adapter_service_get_dce_version(
+                                        pool->base.adapter_srv),
+                                &init_data);
+                if (!pool->base.irqs)
+                        goto irqs_create_fail;
+
+        }
+
+        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+        if (pool->base.scaler_filter == NULL) {
+                BREAK_TO_DEBUGGER();
+                dm_error("DC: failed to create filter!\n");
+                goto filter_create_fail;
+        }
+
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                pool->base.timing_generators[i] = dce80_timing_generator_create(
+                                as, ctx, i, &dce80_tg_offsets[i]);
+                if (pool->base.timing_generators[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create tg!\n");
+                        goto controller_create_fail;
+                }
 
                 pool->base.mis[i] = dce80_mem_input_create(ctx, as, i,
-				&dce80_mi_reg_offsets[i]);
-		if (pool->mis[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create memory input!\n");
-			goto controller_create_fail;
-		}
-
-		pool->ipps[i] = dce80_ipp_create(ctx, i, &ipp_reg_offsets[i]);
-		if (pool->ipps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create input pixel processor!\n");
-			goto controller_create_fail;
-		}
-
-		pool->transforms[i] = dce80_transform_create(
-						ctx, i, &dce80_xfm_offsets[i]);
-		if (pool->transforms[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create transform!\n");
-			goto controller_create_fail;
-		}
-		pool->transforms[i]->funcs->transform_set_scaler_filter(
-				pool->transforms[i],
-				pool->scaler_filter);
-
-		pool->opps[i] = dce80_opp_create(ctx, i);
-		if (pool->opps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create output pixel processor!\n");
-			goto controller_create_fail;
-		}
-	}
-
-	audio_init_data.as = as;
-	audio_init_data.ctx = ctx;
-	pool->audio_count = 0;
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct graphics_object_id obj_id;
-
-		obj_id = dal_adapter_service_enum_audio_object(as, i);
-		if (false == dal_graphics_object_id_is_valid(obj_id)) {
-			/* no more valid audio objects */
-			break;
-		}
-
-		audio_init_data.audio_stream_id = obj_id;
-		pool->audios[i] = dal_audio_create(&audio_init_data);
-		if (pool->audios[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create DPPs!\n");
-			goto audio_create_fail;
-		}
-		pool->audio_count++;
-	}
-
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_engines.u_all & 1 << i) {
-			pool->stream_enc[i] = dce80_stream_encoder_create(
-					i, dc->ctx,
-					dal_adapter_service_get_bios_parser(
-						as),
-					&stream_enc_regs[i]);
-
-			if (pool->stream_enc[i] == NULL) {
-				BREAK_TO_DEBUGGER();
-				dm_error("DC: failed to create stream_encoder!\n");
-				goto stream_enc_create_fail;
-			}
-		}
-	}
-
-	for (i = 0; i < num_virtual_links; i++) {
-		pool->stream_enc[pool->stream_enc_count] =
-			virtual_stream_encoder_create(
-				dc->ctx, dal_adapter_service_get_bios_parser(
-								as));
-		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create stream_encoder!\n");
-			goto stream_enc_create_fail;
-		}
-		pool->stream_enc_count++;
-	}
-
-	/* Create hardware sequencer */
-	if (!dce80_hw_sequencer_construct(dc))
-		goto stream_enc_create_fail;
-
-	return true;
+                                &dce80_mi_reg_offsets[i]);
+                if (pool->base.mis[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create memory input!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.ipps[i] = dce80_ipp_create(ctx, i, &ipp_reg_offsets[i]);
+                if (pool->base.ipps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create input pixel processor!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.transforms[i] = dce80_transform_create(
+                                                ctx, i, &dce80_xfm_offsets[i]);
+                if (pool->base.transforms[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create transform!\n");
+                        goto controller_create_fail;
+                }
+                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+                                pool->base.transforms[i],
+                                pool->base.scaler_filter);
+
+                pool->base.opps[i] = dce80_opp_create(ctx, i);
+                if (pool->base.opps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create output pixel processor!\n");
+                        goto controller_create_fail;
+                }
+        }
+
+        audio_init_data.ctx = ctx;
+        pool->base.audio_count = 0;
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                struct graphics_object_id obj_id;
+
+                obj_id = dal_adapter_service_enum_audio_object(as, i);
+                if (false == dal_graphics_object_id_is_valid(obj_id)) {
+                        /* no more valid audio objects */
+                        break;
+                }
+
+                audio_init_data.audio_stream_id = obj_id;
+		pool->base.audios[i] = dal_audio_create_dce80(&audio_init_data);
+                if (pool->base.audios[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create DPPs!\n");
+                        goto audio_create_fail;
+                }
+                pool->base.audio_count++;
+        }
+
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_engines.u_all & 1 << i) {
+                        pool->base.stream_enc[i] = dce80_stream_encoder_create(
+                                        i, dc->ctx,
+                                        dal_adapter_service_get_bios_parser(
+                                                as),
+                                        &stream_enc_regs[i]);
+
+                        if (pool->base.stream_enc[i] == NULL) {
+                                BREAK_TO_DEBUGGER();
+                                dm_error("DC: failed to create stream_encoder!\n");
+                                goto stream_enc_create_fail;
+                        }
+                }
+        }
+
+        for (i = 0; i < num_virtual_links; i++) {
+                pool->base.stream_enc[pool->base.stream_enc_count] =
+                        virtual_stream_encoder_create(
+                                dc->ctx, dal_adapter_service_get_bios_parser(
+                                                                as));
+                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create stream_encoder!\n");
+                        goto stream_enc_create_fail;
+                }
+                pool->base.stream_enc_count++;
+        }
+
+        /* Create hardware sequencer */
+        if (!dce80_hw_sequencer_construct(dc))
+                goto stream_enc_create_fail;
+
+        return true;
 
 stream_enc_create_fail:
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
 audio_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->audios[i] != NULL)
-			dal_audio_destroy(&pool->audios[i]);
-	}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.audios[i] != NULL)
+                        dal_audio_destroy(&pool->base.audios[i]);
+        }
 
 controller_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce80_opp_destroy(&pool->opps[i]);
-
-		if (pool->transforms[i] != NULL)
-			dce80_transform_destroy(&pool->transforms[i]);
-
-		if (pool->ipps[i] != NULL)
-			dce80_ipp_destroy(&pool->ipps[i]);
-
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
-		if (pool->timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce80_opp_destroy(&pool->base.opps[i]);
+
+                if (pool->base.transforms[i] != NULL)
+                        dce80_transform_destroy(&pool->base.transforms[i]);
+
+                if (pool->base.ipps[i] != NULL)
+                        dce80_ipp_destroy(&pool->base.ipps[i]);
+
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
+                if (pool->base.timing_generators[i] != NULL)    {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
 filter_create_fail:
-	dal_irq_service_destroy(&pool->irqs);
+        dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-	dal_display_clock_destroy(&pool->display_clock);
+        dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL)
-			dce80_clock_source_destroy(&pool->clock_sources[i]);
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL)
+                        dce80_clock_source_destroy(&pool->base.clock_sources[i]);
+        }
+
+        return false;
+}
 
-	return false;
+struct resource_pool *dce80_create_resource_pool(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc)
+{
+        struct dce110_resource_pool *pool =
+                dm_alloc(sizeof(struct dce110_resource_pool));
+
+        if (!pool)
+                return NULL;
+
+        if (construct(as, num_virtual_links, dc, pool))
+                return &pool->base;
+
+        BREAK_TO_DEBUGGER();
+        return NULL;
 }
+
diff --git a/drivers/gpu/drm/amd/dal/include/audio_interface.h b/drivers/gpu/drm/amd/dal/include/audio_interface.h
index 1515bb5..20faf9c 100644
--- a/drivers/gpu/drm/amd/dal/include/audio_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/audio_interface.h
@@ -43,7 +43,6 @@ struct dal_adapter_service;
  * each endpoint
  */
 struct audio_init_data {
-	struct adapter_service *as;
 	struct graphics_object_id audio_stream_id;
 	struct dc_context *ctx;
 };
@@ -54,8 +53,6 @@ enum audio_result {
 };
 
 /****** audio object create, destroy ******/
-struct audio *dal_audio_create(
-	const struct audio_init_data *init_data);
 
 void dal_audio_destroy(
 	struct audio **audio);
-- 
2.7.4

