From ccf8115ce0340d45febd17df31aacbe6570d92cb Mon Sep 17 00:00:00 2001
From: Ayyappa Ch <ayyappa.chandolu@amd.com>
Date: Fri, 27 Jan 2017 17:12:30 +0530
Subject: [PATCH 1668/1722] drm/amd/amdgpu: add power profile sysfs entry

Add the sysfs entries pp_gfx_power_profile and
pp_compute_power_profile which give user a way to set
power profile through parameters minimum sclk, minimum mclk,
activity threshold, up hysteresis and down hysteresis only
when the entry power_dpm_force_performance_level is in
default value "auto". It is read and write. Example:

echo 500 800 20 0 5 > /sys/class/drm/card0/device/pp_*_power_profile

cat /sys/class/drm/card0/device/pp_*_power_profile
500 800 20 0 5

Note: first parameter is sclk in MHz, second is mclk in MHz,
third is activity threshold in percentage, fourth is up hysteresis
in ms and fifth is down hysteresis in ms.

echo set > /sys/class/drm/card0/device/pp_*_power_profile
To set power profile state if it exists.

echo reset > /sys/class/drm/card0/device/pp_*_power_profile
To restore default state and clear previous setting.

Change-Id: I31b484f144a58b0eea21f0c3b9ce682b1c3cf17b
Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
Signed-off-by: Ayyappa Ch <ayyappa.chandolu@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.h           |  16 +++
 drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c            | 167 ++++++++++++++++++++++
 drivers/gpu/drm/amd/powerplay/amd_powerplay.c     | 153 ++++++++++++++++++++
 drivers/gpu/drm/amd/powerplay/inc/amd_powerplay.h |  23 +++
 drivers/gpu/drm/amd/powerplay/inc/hwmgr.h         |   7 +
 5 files changed, 366 insertions(+)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.h
index 955d6f2..08755fc 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.h
@@ -383,6 +383,22 @@ struct amdgpu_dpm_funcs {
 #define amdgpu_dpm_set_mclk_od(adev, value) \
 	((adev)->powerplay.pp_funcs->set_mclk_od((adev)->powerplay.pp_handle, value))
 
+#define amdgpu_dpm_reset_power_profile_state(adev, request) \
+	((adev)->powerplay.pp_funcs->reset_power_profile_state(\
+			(adev)->powerplay.pp_handle, request))
+
+#define amdgpu_dpm_get_power_profile_state(adev, query) \
+	((adev)->powerplay.pp_funcs->get_power_profile_state(\
+			(adev)->powerplay.pp_handle, query))
+
+#define amdgpu_dpm_set_power_profile_state(adev, request) \
+	((adev)->powerplay.pp_funcs->set_power_profile_state(\
+			(adev)->powerplay.pp_handle, request))
+
+#define amdgpu_dpm_switch_power_profile(adev, type) \
+	((adev)->powerplay.pp_funcs->switch_power_profile(\
+			(adev)->powerplay.pp_handle, type))
+
 #define amdgpu_dpm_dispatch_task(adev, event_id, input, output)		\
 	(adev)->powerplay.pp_funcs->dispatch_tasks((adev)->powerplay.pp_handle, (event_id), (input), (output))
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c
index 0f8c747..3cb4213 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c
@@ -576,6 +576,149 @@ fail:
 	return count;
 }
 
+static ssize_t amdgpu_get_pp_power_profile(struct device *dev,
+		char *buf, struct pp_profile *query)
+{
+	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct amdgpu_device *adev = ddev->dev_private;
+	int ret = 0;
+
+	ret = amdgpu_dpm_get_power_profile_state(adev, query);
+
+	if (ret)
+		return ret;
+
+	return snprintf(buf, PAGE_SIZE,
+			"%d %d %d %d %d\n",
+			query->min_sclk / 100,
+			query->min_mclk / 100,
+			query->activity_threshold,
+			query->up_hyst,
+			query->down_hyst);
+}
+
+static ssize_t amdgpu_get_pp_gfx_power_profile(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	struct pp_profile query = {0};
+
+	query.type = PP_GFX_PROFILE;
+
+	return amdgpu_get_pp_power_profile(dev, buf, &query);
+}
+
+static ssize_t amdgpu_get_pp_compute_power_profile(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	struct pp_profile query = {0};
+
+	query.type = PP_COMPUTE_PROFILE;
+
+	return amdgpu_get_pp_power_profile(dev, buf, &query);
+}
+
+static ssize_t amdgpu_set_pp_power_profile(struct device *dev,
+		const char *buf,
+		size_t count,
+		struct pp_profile *request)
+{
+	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct amdgpu_device *adev = ddev->dev_private;
+	uint32_t loop = 0;
+	char *sub_str, buf_cpy[128], *tmp_str;
+	const char delimiter[3] = {' ', '\n', '\0'};
+	long int value;
+	int ret = 0;
+
+	if (strncmp("reset", buf, strlen("reset")) == 0) {
+		ret = amdgpu_dpm_reset_power_profile_state(adev, request);
+		if (ret) {
+			count = -EINVAL;
+			goto fail;
+		}
+		return count;
+	}
+
+	if (strncmp("set", buf, strlen("set")) == 0) {
+		ret = amdgpu_dpm_set_power_profile_state(adev, request);
+		if (ret) {
+			count = -EINVAL;
+			goto fail;
+		}
+		return count;
+	}
+
+	memcpy(buf_cpy, buf, count);
+	tmp_str = buf_cpy;
+
+	while (strlen(tmp_str)) {
+		sub_str = strsep(&tmp_str, delimiter);
+		ret = kstrtol(sub_str, 0, &value);
+		if (ret) {
+			count = -EINVAL;
+			goto fail;
+		}
+
+		switch (loop) {
+		case 0:
+			/* input unit MHz convert to dpm table unit 10KHz*/
+			request->min_sclk = (uint32_t)value * 100;
+			break;
+		case 1:
+			/* input unit MHz convert to dpm table unit 10KHz*/
+			request->min_mclk = (uint32_t)value * 100;
+			break;
+		case 2:
+			request->activity_threshold = (uint16_t)value;
+			break;
+		case 3:
+			request->up_hyst = (uint8_t)value;
+			break;
+		case 4:
+			request->down_hyst = (uint8_t)value;
+			break;
+		default:
+			break;
+		}
+
+		loop++;
+	}
+
+	ret = amdgpu_dpm_set_power_profile_state(adev, request);
+
+	if (ret)
+		count = -EINVAL;
+
+fail:
+	return count;
+}
+
+static ssize_t amdgpu_set_pp_gfx_power_profile(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf,
+		size_t count)
+{
+	struct pp_profile request = {0};
+
+	request.type = PP_GFX_PROFILE;
+
+	return amdgpu_set_pp_power_profile(dev, buf, count, &request);
+}
+
+static ssize_t amdgpu_set_pp_compute_power_profile(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf,
+		size_t count)
+{
+	struct pp_profile request = {0};
+
+	request.type = PP_COMPUTE_PROFILE;
+
+	return amdgpu_set_pp_power_profile(dev, buf, count, &request);
+}
+
 static DEVICE_ATTR(power_dpm_state, S_IRUGO | S_IWUSR, amdgpu_get_dpm_state, amdgpu_set_dpm_state);
 static DEVICE_ATTR(power_dpm_force_performance_level, S_IRUGO | S_IWUSR,
 		   amdgpu_get_dpm_forced_performance_level,
@@ -603,6 +746,12 @@ static DEVICE_ATTR(pp_sclk_od, S_IRUGO | S_IWUSR,
 static DEVICE_ATTR(pp_mclk_od, S_IRUGO | S_IWUSR,
 		amdgpu_get_pp_mclk_od,
 		amdgpu_set_pp_mclk_od);
+static DEVICE_ATTR(pp_gfx_power_profile, S_IRUGO | S_IWUSR,
+		amdgpu_get_pp_gfx_power_profile,
+		amdgpu_set_pp_gfx_power_profile);
+static DEVICE_ATTR(pp_compute_power_profile, S_IRUGO | S_IWUSR,
+		amdgpu_get_pp_compute_power_profile,
+		amdgpu_set_pp_compute_power_profile);
 
 static ssize_t amdgpu_hwmon_show_temp(struct device *dev,
 				      struct device_attribute *attr,
@@ -1184,6 +1333,20 @@ int amdgpu_pm_sysfs_init(struct amdgpu_device *adev)
 			DRM_ERROR("failed to create device file pp_table\n");
 			return ret;
 		}
+		ret = device_create_file(adev->dev,
+				&dev_attr_pp_gfx_power_profile);
+		if (ret) {
+			DRM_ERROR("failed to create device file	"
+					"pp_gfx_power_profile\n");
+			return ret;
+		}
+		ret = device_create_file(adev->dev,
+				&dev_attr_pp_compute_power_profile);
+		if (ret) {
+			DRM_ERROR("failed to create device file	"
+					"pp_compute_power_profile\n");
+			return ret;
+		}
 	}
 
 	ret = device_create_file(adev->dev, &dev_attr_pp_dpm_sclk);
@@ -1234,6 +1397,10 @@ void amdgpu_pm_sysfs_fini(struct amdgpu_device *adev)
 		device_remove_file(adev->dev, &dev_attr_pp_cur_state);
 		device_remove_file(adev->dev, &dev_attr_pp_force_state);
 		device_remove_file(adev->dev, &dev_attr_pp_table);
+		device_remove_file(adev->dev,
+				&dev_attr_pp_gfx_power_profile);
+		device_remove_file(adev->dev,
+				&dev_attr_pp_compute_power_profile);
 	}
 	device_remove_file(adev->dev, &dev_attr_pp_dpm_sclk);
 	device_remove_file(adev->dev, &dev_attr_pp_dpm_mclk);
diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 51a3607..de0f171 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -828,6 +828,155 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 	return hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
 }
 
+static int pp_dpm_reset_power_profile_state(void *handle,
+		struct pp_profile *request)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle || !request)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_power_profile_state == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	if (request->type == PP_GFX_PROFILE)
+		memset(&hwmgr->gfx_power_profile, 0,
+				sizeof(struct pp_profile));
+	else if (request->type == PP_COMPUTE_PROFILE)
+		memset(&hwmgr->compute_power_profile, 0,
+				sizeof(struct pp_profile));
+
+	hwmgr->current_power_profile = PP_DEFAULT_PROFILE;
+
+	return hwmgr->hwmgr_func->set_power_profile_state(hwmgr,
+			&hwmgr->default_power_profile);
+}
+
+static int pp_dpm_get_power_profile_state(void *handle,
+		struct pp_profile *query)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle || !query)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (query->type == PP_GFX_PROFILE)
+		memcpy(query, &hwmgr->gfx_power_profile,
+				sizeof(struct pp_profile));
+	else if (query->type == PP_COMPUTE_PROFILE)
+		memcpy(query, &hwmgr->compute_power_profile,
+				sizeof(struct pp_profile));
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int pp_dpm_set_power_profile_state(void *handle,
+		struct pp_profile *request)
+{
+	struct pp_hwmgr *hwmgr;
+	int ret = -1;
+
+	if (!handle || !request)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_power_profile_state == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	if (request->min_sclk ||
+		request->min_mclk ||
+		request->activity_threshold ||
+		request->up_hyst ||
+		request->down_hyst) {
+		if (request->type == PP_GFX_PROFILE)
+			memcpy(&hwmgr->gfx_power_profile, request,
+					sizeof(struct pp_profile));
+		else if (request->type == PP_COMPUTE_PROFILE)
+			memcpy(&hwmgr->compute_power_profile, request,
+					sizeof(struct pp_profile));
+
+		if (request->type == hwmgr->current_power_profile)
+			ret = hwmgr->hwmgr_func->set_power_profile_state(
+					hwmgr,
+					request);
+	} else {
+		/* set power profile if it exists */
+		switch (request->type) {
+		case PP_GFX_PROFILE:
+			if (hwmgr->gfx_power_profile.type ==
+					PP_GFX_PROFILE)
+				ret = hwmgr->hwmgr_func->
+						set_power_profile_state(
+						hwmgr,
+						&hwmgr->gfx_power_profile);
+			else
+				ret = hwmgr->hwmgr_func->
+						set_power_profile_state(
+						hwmgr,
+						&hwmgr->default_power_profile);
+			break;
+		case PP_COMPUTE_PROFILE:
+			if (hwmgr->compute_power_profile.type ==
+					PP_COMPUTE_PROFILE)
+				ret = hwmgr->hwmgr_func->
+						set_power_profile_state(
+						hwmgr,
+						&hwmgr->compute_power_profile);
+			break;
+		case PP_DEFAULT_PROFILE:
+			ret = hwmgr->hwmgr_func->set_power_profile_state(
+					hwmgr,
+					&hwmgr->default_power_profile);
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (!ret)
+		hwmgr->current_power_profile = request->type;
+
+	return 0;
+}
+
+static int pp_dpm_switch_power_profile(void *handle,
+		enum pp_profile_type type)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_profile request = {0};
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->current_power_profile != type) {
+		request.type = type;
+		pp_dpm_set_power_profile_state(handle, &request);
+	}
+
+	return 0;
+}
+
 static int pp_dpm_read_sensor(void *handle, int idx, int32_t *value)
 {
 	struct pp_hwmgr *hwmgr;
@@ -888,6 +1037,10 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.set_sclk_od = pp_dpm_set_sclk_od,
 	.get_mclk_od = pp_dpm_get_mclk_od,
 	.set_mclk_od = pp_dpm_set_mclk_od,
+	.reset_power_profile_state = pp_dpm_reset_power_profile_state,
+	.get_power_profile_state = pp_dpm_get_power_profile_state,
+	.set_power_profile_state = pp_dpm_set_power_profile_state,
+	.switch_power_profile = pp_dpm_switch_power_profile,	
 	.read_sensor = pp_dpm_read_sensor,
 	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
 };
diff --git a/drivers/gpu/drm/amd/powerplay/inc/amd_powerplay.h b/drivers/gpu/drm/amd/powerplay/inc/amd_powerplay.h
index 639cbad..0dc4e20 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/amd_powerplay.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/amd_powerplay.h
@@ -296,6 +296,21 @@ struct pp_states_info {
 	uint32_t states[16];
 };
 
+enum pp_profile_type {
+	PP_DEFAULT_PROFILE,
+	PP_GFX_PROFILE,
+	PP_COMPUTE_PROFILE,
+};
+
+struct pp_profile {
+	enum pp_profile_type type;
+	uint32_t min_sclk;
+	uint32_t min_mclk;
+	uint16_t activity_threshold;
+	uint8_t up_hyst;
+	uint8_t down_hyst;
+};
+
 #define PP_GROUP_MASK        0xF0000000
 #define PP_GROUP_SHIFT       28
 
@@ -360,6 +375,14 @@ struct amd_powerplay_funcs {
 	int (*set_sclk_od)(void *handle, uint32_t value);
 	int (*get_mclk_od)(void *handle);
 	int (*set_mclk_od)(void *handle, uint32_t value);
+	int (*reset_power_profile_state)(void *handle,
+			struct pp_profile *request);
+	int (*get_power_profile_state)(void *handle,
+			struct pp_profile *query);
+	int (*set_power_profile_state)(void *handle,
+			struct pp_profile *request);
+	int (*switch_power_profile)(void *handle,
+			enum pp_profile_type type);	
 	int (*read_sensor)(void *handle, int idx, int32_t *value);
 	struct amd_vce_state* (*get_vce_clock_state)(void *handle, unsigned idx);
 };
diff --git a/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h b/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h
index 6cdb7cb..9df8276 100644
--- a/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/hwmgr.h
@@ -357,6 +357,8 @@ struct pp_hwmgr_func {
 	int (*set_sclk_od)(struct pp_hwmgr *hwmgr, uint32_t value);
 	int (*get_mclk_od)(struct pp_hwmgr *hwmgr);
 	int (*set_mclk_od)(struct pp_hwmgr *hwmgr, uint32_t value);
+	int (*set_power_profile_state)(struct pp_hwmgr *hwmgr,
+			struct pp_profile *request);	
 	int (*read_sensor)(struct pp_hwmgr *hwmgr, int idx, int32_t *value);
 };
 
@@ -649,6 +651,11 @@ struct pp_hwmgr {
 	struct pp_power_state    *uvd_ps;
 	struct amd_pp_display_configuration display_config;
 	uint32_t feature_mask;
+	/* power profile */
+	struct pp_profile gfx_power_profile;
+	struct pp_profile compute_power_profile;
+	struct pp_profile default_power_profile;
+	enum pp_profile_type current_power_profile;
 };
 
 
-- 
2.7.4

