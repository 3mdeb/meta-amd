From 07e35b3a0d7ae8ce050b17b2391ce17dc0c30826 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Tue, 17 May 2016 14:30:31 -0400
Subject: [PATCH 0496/1722] drm/amd/dal: refactor secondary pipe acquire logic

also fix tree_cfg index used in add/remove dpp in
mpc.c

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/basics/logger.c         |   4 +-
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |   6 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 124 +++++++++++----------
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |   2 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |   2 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |   2 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   5 +-
 8 files changed, 78 insertions(+), 69 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/basics/logger.c b/drivers/gpu/drm/amd/dal/dc/basics/logger.c
index 298354f..4c4d342 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/logger.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/logger.c
@@ -226,7 +226,7 @@ struct log_major_mask_info {
  * Use a mask or zero. */
 #define LG_ERR_MSK 0xffffffff
 #define LG_WRN_MSK 0xffffffff
-#define LG_TM_MSK (1 << LOG_MINOR_TM_INFO)
+#define LG_TM_MSK (1 << LOG_MINOR_TM_RESOURCES)
 #define LG_FO_MSK (1 << LOG_MINOR_FEATURE_OVERRIDE)
 #define LG_EC_MSK ((1 << LOG_MINOR_EC_PPLIB_NOTIFY) | \
 			(1 << LOG_MINOR_EC_PPLIB_QUERY))
@@ -276,7 +276,7 @@ static const struct log_major_mask_info log_major_mask_info_tbl[] = {
 	{{LOG_MAJOR_SYNC,            "Sync"        }, LG_SYNC_MSK,sync_minor_info_tbl,         NUM_ELEMENTS(sync_minor_info_tbl)},
 	{{LOG_MAJOR_BACKLIGHT,       "Backlight"   }, LG_ALL_MSK, backlight_minor_info_tbl,    NUM_ELEMENTS(backlight_minor_info_tbl)},
 	{{LOG_MAJOR_INTERRUPTS,      "Interrupts"  }, LG_ALL_MSK, component_minor_info_tbl,    NUM_ELEMENTS(component_minor_info_tbl)},
-	{{LOG_MAJOR_TM,              "TM"          }, 0,          tm_minor_info_tbl,           NUM_ELEMENTS(tm_minor_info_tbl)},
+	{{LOG_MAJOR_TM,              "TM"          }, LG_TM_MSK,  tm_minor_info_tbl,           NUM_ELEMENTS(tm_minor_info_tbl)},
 	{{LOG_MAJOR_DISPLAY_SERVICE, "DS"          }, LG_ALL_MSK, ds_minor_info_tbl,           NUM_ELEMENTS(ds_minor_info_tbl)},
 	{{LOG_MAJOR_FEATURE_OVERRIDE, "FeatureOverride" }, LG_ALL_MSK, override_feature_minor_info_tbl, NUM_ELEMENTS(override_feature_minor_info_tbl)},
 	{{LOG_MAJOR_DETECTION,       "Detection"   }, LG_ALL_MSK,  detection_minor_info_tbl,    NUM_ELEMENTS(detection_minor_info_tbl)},
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 823d6ca..ed990ac 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -595,14 +595,14 @@ static void target_enable_memory_requests(struct dc_target *dc_target,
 static void target_disable_memory_requests(struct dc_target *dc_target,
 		struct resource_context *res_ctx)
 {
-	uint8_t i, j;
+	int i, j;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 
 	for (i = 0; i < target->public.stream_count; i++) {
-		for (j = 0; j < MAX_PIPES; j++) {
+		for (j = 0; j < res_ctx->pool.pipe_count; j++) {
 			struct timing_generator *tg = res_ctx->pipe_ctx[j].tg;
 
-			if (res_ctx->pipe_ctx[j].parent_pipe != NULL ||
+			if (res_ctx->pipe_ctx[j].primary_pipe != NULL ||
 				res_ctx->pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(target->public.streams[i]))
 				continue;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 437a662..4dbd2f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -490,7 +490,7 @@ bool resource_attach_surfaces_to_context(
 			struct core_surface *surface = NULL;
 
 			/* Skip surface assignment for child pipes */
-			if (context->res_ctx.pipe_ctx[j].parent_pipe != NULL)
+			if (context->res_ctx.pipe_ctx[j].primary_pipe != NULL)
 				continue;
 
 			if (surface_count)
@@ -949,6 +949,40 @@ void validate_guaranteed_copy_target(
 	}
 }
 
+static void split_stream_across_pipes(
+		struct validate_context *context,
+		struct pipe_ctx *primary_pipe,
+		struct pipe_ctx *secondary_pipe)
+{
+	int secondary_pipe_idx = secondary_pipe->pipe_idx;
+	/* Use same back-end as original pipe */
+	*secondary_pipe = *primary_pipe;
+	secondary_pipe->primary_pipe = primary_pipe;
+	secondary_pipe->secondary_pipe = NULL;
+	primary_pipe->secondary_pipe = secondary_pipe;
+	primary_pipe->primary_pipe = NULL;
+	secondary_pipe->pipe_idx = secondary_pipe_idx;
+
+	/* Only acquire different front end objects */
+	secondary_pipe->mi = context->res_ctx.pool.mis[secondary_pipe->pipe_idx];
+	secondary_pipe->ipp = context->res_ctx.pool.ipps[secondary_pipe->pipe_idx];
+	secondary_pipe->xfm = context->res_ctx.pool.transforms[secondary_pipe->pipe_idx];
+	secondary_pipe->opp = context->res_ctx.pool.opps[secondary_pipe->pipe_idx];
+
+	if (primary_pipe->surface) {
+		/* Todo: account for truncation error */
+		primary_pipe->scl_data.viewport.width /= 2;
+		primary_pipe->scl_data.recout.width /= 2;
+
+		secondary_pipe->scl_data = primary_pipe->scl_data;
+		secondary_pipe->scl_data.viewport.x =
+				primary_pipe->scl_data.viewport.width
+				+ primary_pipe->scl_data.viewport.x;
+		secondary_pipe->scl_data.recout.x =
+				primary_pipe->scl_data.recout.width
+				+ primary_pipe->scl_data.recout.x;
+	}
+}
 
 enum dc_status resource_map_vmin_resources(
 		const struct core_dc *dc,
@@ -965,9 +999,9 @@ enum dc_status resource_map_vmin_resources(
 	 */
 	if (context->target_count == 1 && context->targets[0]->public.stream_count == 1) {
 
-		uint8_t i;
-		struct pipe_ctx *parent_pipe_ctx = NULL;
-		struct pipe_ctx *vmin_pipe_ctx = NULL;
+		int i;
+		struct pipe_ctx *primary_pipe = NULL;
+		struct pipe_ctx *secondary_pipe = NULL;
 
 		/* Only enable for 4k@60 displays */
 		struct core_stream *stream = DC_STREAM_TO_CORE(context->targets[0]->public.streams[0]);
@@ -978,78 +1012,41 @@ enum dc_status resource_map_vmin_resources(
 		/* Find first pipe, assume it already has viewport calculated */
 		for (i = 0; i < context->res_ctx.pool.pipe_count; i++) {
 			if (context->res_ctx.pipe_ctx[i].stream) {
-				parent_pipe_ctx = &context->res_ctx.pipe_ctx[i];
+				primary_pipe = &context->res_ctx.pipe_ctx[i];
 				break;
 			}
 		}
 
-		if (parent_pipe_ctx == NULL) {
+		if (primary_pipe == NULL) {
 			BREAK_TO_DEBUGGER();
 			return DC_NO_CONTROLLER_RESOURCE;
 		}
 
 		/* Determine if we've already acquired a vmin pipe previously */
-		for (i = 0; i < context->res_ctx.pool.pipe_count; i++) {
-			struct pipe_ctx *current_pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-			/* TODO: This workaround need rework  */
-			if (parent_pipe_ctx->stream == current_pipe_ctx->stream &&
-					current_pipe_ctx->parent_pipe != NULL) {
-				/* pointer to buffer may change. need update
-				 * when context be re-allocate
-				 */
-				current_pipe_ctx->parent_pipe = parent_pipe_ctx;
-				vmin_pipe_ctx = current_pipe_ctx;
-
-				/* Use same back-end as original pipe */
-				*vmin_pipe_ctx = *parent_pipe_ctx;
-				vmin_pipe_ctx->pipe_idx = i;
-				vmin_pipe_ctx->parent_pipe = parent_pipe_ctx;
-				break;
-
-			}
-		}
-
-		/* Find the first available pipe to use for vmin if not already acquired */
-		if (vmin_pipe_ctx == NULL) {
+		if (primary_pipe->secondary_pipe)
+			secondary_pipe = primary_pipe->secondary_pipe;
+		else {
 			for (i = 0; i < context->res_ctx.pool.pipe_count; i++) {
 				if (context->res_ctx.pipe_ctx[i].stream == NULL) {
-					vmin_pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-					/* Use same back-end as original pipe */
-					*vmin_pipe_ctx = *parent_pipe_ctx;
-					vmin_pipe_ctx->pipe_idx = i;
-					vmin_pipe_ctx->parent_pipe = parent_pipe_ctx;
+					secondary_pipe = &context->res_ctx.pipe_ctx[i];
+					secondary_pipe->pipe_idx = i;
 					break;
 				}
 			}
-		}
 
-		if (vmin_pipe_ctx == NULL) {
-			BREAK_TO_DEBUGGER();
-			return DC_NO_CONTROLLER_RESOURCE;
 		}
 
-		/* Only acquire different front end objects */
-		vmin_pipe_ctx->mi = context->res_ctx.pool.mis[vmin_pipe_ctx->pipe_idx];
-		vmin_pipe_ctx->ipp = context->res_ctx.pool.ipps[vmin_pipe_ctx->pipe_idx];
-		vmin_pipe_ctx->xfm = context->res_ctx.pool.transforms[vmin_pipe_ctx->pipe_idx];
-		vmin_pipe_ctx->opp = context->res_ctx.pool.opps[vmin_pipe_ctx->pipe_idx];
-
-		if (!vmin_pipe_ctx->stream_enc)
-			return DC_NO_STREAM_ENG_RESOURCE;
-
-		/* Todo: account for truncation error */
-		parent_pipe_ctx->scl_data.viewport.width /= 2;
-		parent_pipe_ctx->scl_data.recout.width /= 2;
+		if (secondary_pipe == NULL) {
+			dal_logger_write(dc->ctx->logger,
+						LOG_MAJOR_TM,
+						LOG_MINOR_TM_RESOURCES,
+						"%s: Failed to find additional pipe resource, driving one pipe\n",
+						__func__);
+			return DC_OK;
+		}
 
-		vmin_pipe_ctx->scl_data = parent_pipe_ctx->scl_data;
-		vmin_pipe_ctx->scl_data.viewport.x =
-				parent_pipe_ctx->scl_data.viewport.width
-				+ parent_pipe_ctx->scl_data.viewport.x;
-		vmin_pipe_ctx->scl_data.recout.x =
-				parent_pipe_ctx->scl_data.recout.width
-				+ parent_pipe_ctx->scl_data.recout.x;
+		split_stream_across_pipes(context, primary_pipe,
+				secondary_pipe);
 
 	}
 	return DC_OK;
@@ -1428,6 +1425,17 @@ void resource_validate_ctx_copy_construct(
 
 	*dst_ctx = *src_ctx;
 
+	for (i = 0; i < dst_ctx->res_ctx.pool.pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &dst_ctx->res_ctx.pipe_ctx[i];
+
+		if (cur_pipe->primary_pipe)
+			cur_pipe->primary_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->primary_pipe->pipe_idx];
+
+		if (cur_pipe->secondary_pipe)
+			cur_pipe->secondary_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->secondary_pipe->pipe_idx];
+
+	}
+
 	for (i = 0; i < dst_ctx->target_count; i++) {
 		dc_target_retain(&dst_ctx->targets[i]->public);
 		for (j = 0; j < dst_ctx->target_status[i].surface_count; j++)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index bfd4513..98edb91 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -651,7 +651,7 @@ enum dc_status dce100_validate_bandwidth(
 enum dc_status dce100_validate_with_context(
 		const struct core_dc *dc,
 		const struct dc_validation_set set[],
-		uint8_t set_count,
+		int set_count,
 		struct validate_context *context)
 {
 	struct dc_context *dc_ctx = dc->ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 5826455..de1febd 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -842,7 +842,7 @@ enum dc_status dce110_validate_bandwidth(
 enum dc_status dce110_validate_with_context(
 		const struct core_dc *dc,
 		const struct dc_validation_set set[],
-		uint8_t set_count,
+		int set_count,
 		struct validate_context *context)
 {
 	struct dc_context *dc_ctx = dc->ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 914e408..5b4f52b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -914,7 +914,7 @@ static enum dc_status map_clock_resources(
 enum dc_status dce112_validate_with_context(
 		const struct core_dc *dc,
 		const struct dc_validation_set set[],
-		uint8_t set_count,
+		int set_count,
 		struct validate_context *context)
 {
 	struct dc_context *dc_ctx = dc->ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index d025f44..e12a0e5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -606,7 +606,7 @@ enum dc_status dce80_validate_bandwidth(
 enum dc_status dce80_validate_with_context(
 		const struct core_dc *dc,
 		const struct dc_validation_set set[],
-		uint8_t set_count,
+		int set_count,
 		struct validate_context *context)
 {
 	struct dc_context *dc_ctx = dc->ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 01b276a..5d9af4e 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -222,7 +222,7 @@ struct resource_funcs {
 	enum dc_status (*validate_with_context)(
 					const struct core_dc *dc,
 					const struct dc_validation_set set[],
-					uint8_t set_count,
+					int set_count,
 					struct validate_context *context);
 
 	enum dc_status (*validate_guaranteed)(
@@ -294,7 +294,8 @@ struct pipe_ctx {
 
 	uint8_t pipe_idx;
 
-	struct pipe_ctx *parent_pipe;
+	struct pipe_ctx *primary_pipe;
+	struct pipe_ctx *secondary_pipe;
 };
 
 struct resource_context {
-- 
2.7.4

