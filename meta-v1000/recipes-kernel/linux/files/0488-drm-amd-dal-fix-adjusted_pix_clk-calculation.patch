From e6740cc2c19834b6b4cea6521e5661c62e954dca Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Fri, 13 May 2016 13:39:27 -0400
Subject: [PATCH 0488/1722] drm/amd/dal: fix adjusted_pix_clk calculation

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  2 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  4 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 86 ++++++++++++++--------
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  2 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  2 +-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |  2 +-
 .../drm/amd/dal/dc/dce112/dce112_link_encoder.c    |  2 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |  2 +-
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |  8 +-
 9 files changed, 66 insertions(+), 44 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index d0ff8f7..8e60a1f 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -658,7 +658,7 @@ static void fill_display_configs(
 			cfg->link_settings.lane_count = stream->sink->link->public.cur_link_settings.lane_count;
 			cfg->link_settings.link_rate = stream->sink->link->public.cur_link_settings.link_rate;
 			cfg->link_settings.link_spread = stream->sink->link->public.cur_link_settings.link_spread;
-			cfg->sym_clock = stream->adjusted_pix_clk_khz;
+			cfg->sym_clock = stream->phy_pix_clk;
 			/* Round v_refresh*/
 			cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
 			cfg->v_refresh /= stream->public.timing.h_total;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 6c6ce55..5833eaa 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -1247,7 +1247,7 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 	if (dc_is_hdmi_signal(pipe_ctx->signal))
 		dal_ddc_service_write_scdc_data(
 			stream->sink->link->ddc,
-			stream->adjusted_pix_clk_khz,
+			stream->phy_pix_clk,
 			stream->public.timing.flags.LTE_340MCSC_SCRAMBLE);
 
 	memset(&stream->sink->link->public.cur_link_settings, 0,
@@ -1259,7 +1259,7 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 			stream->public.timing.display_color_depth,
 			pipe_ctx->signal == SIGNAL_TYPE_HDMI_TYPE_A,
 			pipe_ctx->signal == SIGNAL_TYPE_DVI_DUAL_LINK,
-			stream->adjusted_pix_clk_khz);
+			stream->phy_pix_clk);
 
 	if (pipe_ctx->signal == SIGNAL_TYPE_HDMI_TYPE_A)
 		dal_ddc_service_read_scdc_data(link->ddc);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index cd17020..76dcc61 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -86,7 +86,7 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 
 bool dc_construct_resource_pool(struct adapter_service *adapter_serv,
 				struct core_dc *dc,
-				uint8_t num_virtual_links,
+				int num_virtual_links,
 				enum dce_version dc_version)
 {
 
@@ -171,7 +171,21 @@ bool resource_are_streams_clk_sharable(
 	if (stream1->public.timing.v_total != stream2->public.timing.v_total)
 		return false;
 
-	if (stream1->adjusted_pix_clk_khz != stream2->adjusted_pix_clk_khz)
+	if (stream1->public.timing.h_addressable
+				!= stream2->public.timing.h_addressable)
+		return false;
+
+	if (stream1->public.timing.v_addressable
+				!= stream2->public.timing.v_addressable)
+		return false;
+
+	if (stream1->public.timing.pix_clk_khz
+				!= stream2->public.timing.pix_clk_khz)
+		return false;
+
+	if (stream1->phy_pix_clk != stream2->phy_pix_clk
+			&& !dc_is_dp_signal(stream1->public.sink->sink_signal)
+			&& !dc_is_dp_signal(stream2->public.sink->sink_signal))
 		return false;
 
 	return true;
@@ -181,17 +195,6 @@ static bool is_sharable_clk_src(
 	const struct pipe_ctx *pipe_with_clk_src,
 	const struct pipe_ctx *pipe)
 {
-#if defined(CONFIG_DRM_AMD_DAL_DCE10_0)
-	enum dce_version dce_ver = dal_adapter_service_get_dce_version(
-		pipe->stream->sink->link->adapter_srv);
-
-	/* Currently no clocks are shared for DCE 10 until VBIOS behavior
-	 * is verified for this use case
-	 */
-	if (dce_ver == DCE_VERSION_10_0)
-		return false;
-#endif
-
 	if (pipe_with_clk_src->clock_source == NULL)
 		return false;
 
@@ -209,7 +212,7 @@ struct clock_source *resource_find_used_clk_src_for_sharing(
 					struct resource_context *res_ctx,
 					struct pipe_ctx *pipe_ctx)
 {
-	uint8_t i;
+	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (is_sharable_clk_src(&res_ctx->pipe_ctx[i], pipe_ctx))
@@ -429,7 +432,7 @@ void resource_build_scaling_params_for_context(
 	const struct core_dc *dc,
 	struct validate_context *context)
 {
-	uint8_t i;
+	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
@@ -442,11 +445,11 @@ void resource_build_scaling_params_for_context(
 
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *surfaces[],
-		uint8_t surface_count,
+		int surface_count,
 		const struct dc_target *dc_target,
 		struct validate_context *context)
 {
-	uint8_t i, j, k;
+	int i, j, k;
 	struct dc_target_status *target_status = NULL;
 
 	if (surface_count > MAX_SURFACE_NUM) {
@@ -541,11 +544,11 @@ static bool is_target_unchanged(
 
 bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
-		uint8_t set_count,
+		int set_count,
 		const struct validate_context *old_context,
 		struct validate_context *context)
 {
-	uint8_t i, j;
+	int i, j;
 
 	for (i = 0; i < set_count; i++) {
 		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
@@ -606,11 +609,12 @@ static void set_audio_in_use(
 	}
 }
 
-static int8_t acquire_first_free_pipe(
+static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
 		struct core_stream *stream)
 {
-	uint8_t i;
+	int i;
+
 	for (i = 0; i < res_ctx->pool.pipe_count; i++) {
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -634,8 +638,8 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
 		struct core_link *link)
 {
-	uint8_t i;
-	int8_t j = -1;
+	int i;
+	int j = -1;
 	const struct dc_sink *sink = NULL;
 
 	for (i = 0; i < res_ctx->pool.stream_enc_count; i++) {
@@ -751,7 +755,7 @@ static struct core_stream *find_pll_sharable_stream(
 		const struct core_stream *stream_needs_pll,
 		struct validate_context *context)
 {
-	uint8_t i, j;
+	int i, j;
 
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
@@ -803,11 +807,11 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-enum dc_status resource_map_pool_resources(
+static void calculate_phy_pix_clks(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
-	uint8_t i, j, k;
+	int i, j;
 
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
@@ -818,11 +822,29 @@ enum dc_status resource_map_pool_resources(
 
 			/* update actual pixel clock on all streams */
 			if (dc_is_hdmi_signal(stream->sink->public.sink_signal))
-				stream->adjusted_pix_clk_khz = get_norm_pix_clk(
+				stream->phy_pix_clk = get_norm_pix_clk(
 					&stream->public.timing);
 			else
-				stream->adjusted_pix_clk_khz =
-					stream->public.timing.pix_clk_khz;
+				stream->phy_pix_clk =
+						stream->public.timing.pix_clk_khz;
+		}
+	}
+}
+
+enum dc_status resource_map_pool_resources(
+		const struct core_dc *dc,
+		struct validate_context *context)
+{
+	int i, j, k;
+
+	calculate_phy_pix_clks(dc, context);
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
 
 			if (!resource_is_stream_unchanged(&dc->current_context, stream))
 				continue;
@@ -925,9 +947,9 @@ enum dc_status resource_map_pool_resources(
 /* first target in the context is used to populate the rest */
 void validate_guaranteed_copy_target(
 		struct validate_context *context,
-		uint8_t max_targets)
+		int max_targets)
 {
-	uint8_t i;
+	int i;
 
 	for (i = 1; i < max_targets; i++) {
 		context->targets[i] = context->targets[0];
@@ -1367,7 +1389,7 @@ enum dc_status resource_map_clock_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
-	uint8_t i, j, k;
+	int i, j, k;
 
 	/* acquire new resources */
 	for (i = 0; i < context->target_count; i++) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index c14a1c1..7ec68a6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -67,7 +67,7 @@ struct dc_init_data {
 	void *driver; /* ctx */
 	struct cgs_device *cgs_device;
 
-	uint8_t num_virtual_links;
+	int num_virtual_links;
 	/*
 	 * If 'vbios_override' not NULL, it will be called instead
 	 * of the real VBIOS. Intended use is Diagnostics on FPGA.
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 4d02f5a..3376ecc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -783,7 +783,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_enc->funcs->hdmi_set_stream_attribute(
 			pipe_ctx->stream_enc,
 			&stream->public.timing,
-			stream->adjusted_pix_clk_khz,
+			stream->phy_pix_clk,
 			pipe_ctx->audio != NULL);
 
 	if (dc_is_dvi_signal(pipe_ctx->signal))
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index d80ca1c..3dfbb33 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -1148,7 +1148,7 @@ bool dce110_link_encoder_validate_output_with_stream(
 		is_valid = dce110_link_encoder_validate_hdmi_output(
 				enc110,
 				&stream->public.timing,
-				stream->adjusted_pix_clk_khz);
+				stream->phy_pix_clk);
 	break;
 	case SIGNAL_TYPE_RGB:
 		is_valid = dce110_link_encoder_validate_rgb_output(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
index 4fdf33f..79898fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
@@ -118,7 +118,7 @@ bool dce112_link_encoder_validate_output_with_stream(
 		is_valid = dce112_link_encoder_validate_hdmi_output(
 				enc110,
 				&stream->public.timing,
-				stream->adjusted_pix_clk_khz);
+				stream->phy_pix_clk);
 	break;
 	case SIGNAL_TYPE_RGB:
 		is_valid = dce110_link_encoder_validate_rgb_output(
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 0edd902..56a5aee 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -93,7 +93,7 @@ struct core_stream {
 	struct bit_depth_reduction_params bit_depth_params;
 	struct clamping_and_pixel_encoding_params clamping;
 
-	int adjusted_pix_clk_khz;
+	int phy_pix_clk;
 
 	struct dc_stream_status status;
 };
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index 09d27b7..0071d83 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -40,7 +40,7 @@ enum dce_version resource_parse_asic_id(
 bool dc_construct_resource_pool(
 		struct adapter_service *adapter_serv,
 		struct core_dc *dc,
-		uint8_t num_virtual_links,
+		int num_virtual_links,
 		enum dce_version dc_version);
 
 enum dc_status resource_map_pool_resources(
@@ -78,7 +78,7 @@ struct clock_source *dc_resource_find_first_free_pll(
 
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *surfaces[],
-		uint8_t surface_count,
+		int surface_count,
 		const struct dc_target *dc_target,
 		struct validate_context *context);
 
@@ -87,13 +87,13 @@ bool resource_is_stream_unchanged(
 
 bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
-		uint8_t set_count,
+		int set_count,
 		const struct validate_context *old_context,
 		struct validate_context *context);
 
 void validate_guaranteed_copy_target(
 		struct validate_context *context,
-		uint8_t max_targets);
+		int max_targets);
 
 void resource_validate_ctx_copy_construct(
 		const struct validate_context *src_ctx,
-- 
2.7.4

