From 7bbc9fd0e4e67fa58428ed244ae5a1851da8fd36 Mon Sep 17 00:00:00 2001
From: Amy Zhang <Amy.Zhang@amd.com>
Date: Wed, 22 Jun 2016 17:52:54 -0400
Subject: [PATCH 0587/1722] drm/amd/dal: SLS with Mixed Mode HW Rotation

- Fixes for calculate viewport and calculate recout
- Resets rotation flag to 0 degrees
- Fixes cursor disorientation from wrong register setting for hw rotation

Change-Id: Iceeb5b849e1f36e85ed438b0d88ed9454f5a3e71
Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 52 +++++++++++++++++-----
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c   |  4 +-
 .../drm/amd/dal/dc/dce110/dce110_transform_scl.c   |  6 ++-
 3 files changed, 47 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 22eb8d8..5a8a595 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -285,16 +285,37 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 	return dal_pixel_format;
 }
 
+static void rect_swap_helper(struct rect *rect)
+{
+	uint32_t temp = 0;
+
+	temp = rect->height;
+	rect->height = rect->width;
+	rect->width = temp;
+
+	temp = rect->x;
+	rect->x = rect->y;
+	rect->y = temp;
+}
+
 static void calculate_viewport(
 		const struct dc_surface *surface,
 		struct pipe_ctx *pipe_ctx)
 {
 	const struct rect stream_src = pipe_ctx->stream->public.src;
-	const struct rect src = surface->src_rect;
-	const struct rect dst = surface->dst_rect;
-	const struct rect surface_clip = surface->clip_rect;
+	struct rect src = surface->src_rect;
+	struct rect dst = surface->dst_rect;
+	struct rect surface_clip = surface->clip_rect;
 	struct rect clip = {0};
 
+
+	if (surface->rotation == ROTATION_ANGLE_90 ||
+			surface->rotation == ROTATION_ANGLE_270){
+		rect_swap_helper(&src);
+		rect_swap_helper(&dst);
+		rect_swap_helper(&surface_clip);
+	}
+
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
@@ -339,14 +360,20 @@ static void calculate_recout(
 		struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
+	struct rect clip = surface->clip_rect;
+
+	if (surface->rotation == ROTATION_ANGLE_90 ||
+			surface->rotation == ROTATION_ANGLE_270){
+		rect_swap_helper(&clip);
+	}
 
 	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
-	if (stream->public.src.x < surface->clip_rect.x)
-		pipe_ctx->scl_data.recout.x += (surface->clip_rect.x
+	if (stream->public.src.x < clip.x)
+		pipe_ctx->scl_data.recout.x += (clip.x
 			- stream->public.src.x) * stream->public.dst.width
 						/ stream->public.src.width;
 
-	pipe_ctx->scl_data.recout.width = surface->clip_rect.width *
+	pipe_ctx->scl_data.recout.width = clip.width *
 			stream->public.dst.width / stream->public.src.width;
 	if (pipe_ctx->scl_data.recout.width + pipe_ctx->scl_data.recout.x >
 			stream->public.dst.x + stream->public.dst.width)
@@ -355,12 +382,12 @@ static void calculate_recout(
 						- pipe_ctx->scl_data.recout.x;
 
 	pipe_ctx->scl_data.recout.y = stream->public.dst.y;
-	if (stream->public.src.y < surface->clip_rect.y)
-		pipe_ctx->scl_data.recout.y += (surface->clip_rect.y
+	if (stream->public.src.y < clip.y)
+		pipe_ctx->scl_data.recout.y += (clip.y
 			- stream->public.src.y) * stream->public.dst.height
 						/ stream->public.src.height;
 
-	pipe_ctx->scl_data.recout.height = surface->clip_rect.height *
+	pipe_ctx->scl_data.recout.height = clip.height *
 			stream->public.dst.height / stream->public.src.height;
 	if (pipe_ctx->scl_data.recout.height + pipe_ctx->scl_data.recout.y >
 			stream->public.dst.y + stream->public.dst.height)
@@ -412,6 +439,7 @@ void resource_build_scaling_params(
 	const struct dc_surface *surface,
 	struct pipe_ctx *pipe_ctx)
 {
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
 	 */
@@ -423,8 +451,10 @@ void resource_build_scaling_params(
 
 	calculate_recout(surface, pipe_ctx);
 
-	pipe_ctx->scl_data.h_active = pipe_ctx->stream->public.timing.h_addressable;
-	pipe_ctx->scl_data.v_active = pipe_ctx->stream->public.timing.v_addressable;
+	pipe_ctx->scl_data.h_active = timing->h_addressable
+			+ timing->h_border_left + timing->h_border_right;
+	pipe_ctx->scl_data.v_active = timing->v_addressable
+			+ timing->v_border_top + timing->v_border_bottom;
 
 	/* Check if scaling is required update taps if not */
 	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.horz) == 1 << 19)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index d232b4e5..e569eac 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -215,7 +215,7 @@ static void program_size_and_rotation(
 	value = 0;
 	switch (rotation) {
 	case ROTATION_ANGLE_90:
-		set_reg_field_value(value, 3,
+		set_reg_field_value(value, 1,
 			HW_ROTATION, GRPH_ROTATION_ANGLE);
 		break;
 	case ROTATION_ANGLE_180:
@@ -223,7 +223,7 @@ static void program_size_and_rotation(
 			HW_ROTATION, GRPH_ROTATION_ANGLE);
 		break;
 	case ROTATION_ANGLE_270:
-		set_reg_field_value(value, 1,
+		set_reg_field_value(value, 3,
 			HW_ROTATION, GRPH_ROTATION_ANGLE);
 		break;
 	default:
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
index d97ec52..080ca04 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
@@ -137,8 +137,10 @@ static void program_overscan(
 	uint32_t overscan_left_right = 0;
 	uint32_t overscan_top_bottom = 0;
 
-	int overscan_right = data->h_active - data->recout.x - data->recout.width;
-	int overscan_bottom = data->v_active - data->recout.y - data->recout.height;
+	int overscan_right = data->h_active
+			- data->recout.x - data->recout.width;
+	int overscan_bottom = data->v_active
+			- data->recout.y - data->recout.height;
 
 	if (overscan_right < 0) {
 		BREAK_TO_DEBUGGER();
-- 
2.7.4

