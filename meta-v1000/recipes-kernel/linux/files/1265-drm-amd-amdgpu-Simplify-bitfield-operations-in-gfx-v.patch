From 500e5a714f92728c6362625678e06da3731a1af0 Mon Sep 17 00:00:00 2001
From: Tom St Denis <tom.stdenis@amd.com>
Date: Tue, 9 Aug 2016 10:13:21 -0400
Subject: [PATCH 1265/1722] drm/amd/amdgpu: Simplify bitfield operations in gfx
 v8
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This patch introduces a new macro WREG32_FIELD which is used
to write to a register with a new value in a field.  It's designed
to replace the pattern:

tmp = RREG32(mmFoo);
tmp &= ~REG__FIELD_MASK;
tmp |= new_value << REG__FIELD__SHIFT;
WREG32(mmFoo, tmp)

with:

WREG32_FIELD(Foo, FIELD, new_value);

Unlike WREG32_P() it understands offsets/masks and doesn't
require the caller to shift the value (or mask properly).

It's applied where suitable in the gfx_v8_0.c driver to start
with.

Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c | 83 ++++++++++-------------------------
 1 file changed, 24 insertions(+), 59 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
index e1f7044..a0202df 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
@@ -3965,31 +3965,20 @@ static void gfx_v8_0_enable_save_restore_machine(struct amdgpu_device *adev)
 static void gfx_v8_0_init_power_gating(struct amdgpu_device *adev)
 {
 	uint32_t data;
- 
-	if (adev->pg_flags & (AMDGPU_PG_SUPPORT_GFX_PG |
-			      AMDGPU_PG_SUPPORT_GFX_SMG |
-			      AMDGPU_PG_SUPPORT_GFX_DMG)) {
-		data = RREG32(mmCP_RB_WPTR_POLL_CNTL);
-		data &= ~CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT_MASK;
-		data |= (0x60 << CP_RB_WPTR_POLL_CNTL__IDLE_POLL_COUNT__SHIFT);
-		WREG32(mmCP_RB_WPTR_POLL_CNTL, data);
- 
-		data = 0;
-		data |= (0x10 << RLC_PG_DELAY__POWER_UP_DELAY__SHIFT);
-		data |= (0x10 << RLC_PG_DELAY__POWER_DOWN_DELAY__SHIFT);
-		data |= (0x10 << RLC_PG_DELAY__CMD_PROPAGATE_DELAY__SHIFT);
-		data |= (0x10 << RLC_PG_DELAY__MEM_SLEEP_DELAY__SHIFT);
+
+	if (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |
+			      AMD_PG_SUPPORT_GFX_SMG |
+			      AMD_PG_SUPPORT_GFX_DMG)) {
+		WREG32_FIELD(CP_RB_WPTR_POLL_CNTL, IDLE_POLL_COUNT, 0x60);
+
+		data = REG_SET_FIELD(0, RLC_PG_DELAY, POWER_UP_DELAY, 0x10);
+		data = REG_SET_FIELD(data, RLC_PG_DELAY, POWER_DOWN_DELAY, 0x10);
+		data = REG_SET_FIELD(data, RLC_PG_DELAY, CMD_PROPAGATE_DELAY, 0x10);
+		data = REG_SET_FIELD(data, RLC_PG_DELAY, MEM_SLEEP_DELAY, 0x10);
 		WREG32(mmRLC_PG_DELAY, data);
- 
-		data = RREG32(mmRLC_PG_DELAY_2);
-		data &= ~RLC_PG_DELAY_2__SERDES_CMD_DELAY_MASK;
-		data |= (0x3 << RLC_PG_DELAY_2__SERDES_CMD_DELAY__SHIFT);
-		WREG32(mmRLC_PG_DELAY_2, data);
- 
-		data = RREG32(mmRLC_AUTO_PG_CTRL);
-		data &= ~RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD_MASK;
-		data |= (0x55f0 << RLC_AUTO_PG_CTRL__GRBM_REG_SAVE_GFX_IDLE_THRESHOLD__SHIFT);
-		WREG32(mmRLC_AUTO_PG_CTRL, data);
+
+		WREG32_FIELD(RLC_PG_DELAY_2, SERDES_CMD_DELAY, 0x3);
+		WREG32_FIELD(RLC_AUTO_PG_CTRL, GRBM_REG_SAVE_GFX_IDLE_THRESHOLD, 0x55f0);
 	}
  }
 
@@ -4010,27 +3999,6 @@ static void cz_enable_cp_power_gating(struct amdgpu_device *adev, bool enable)
         WREG32_FIELD(RLC_PG_CNTL, CP_PG_DISABLE, enable ? 1 : 0);
 }
 
-static void polaris11_init_power_gating(struct amdgpu_device *adev)
-{
-	uint32_t data;
-
-	if (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |
-			      AMD_PG_SUPPORT_GFX_SMG |
-			      AMD_PG_SUPPORT_GFX_DMG)) {
- 
-                WREG32_FIELD(CP_RB_WPTR_POLL_CNTL, IDLE_POLL_COUNT, 0x60);
-
-                data = REG_SET_FIELD(0, RLC_PG_DELAY, POWER_UP_DELAY, 0x10);
-                data = REG_SET_FIELD(data, RLC_PG_DELAY, POWER_DOWN_DELAY, 0x10);
-                data = REG_SET_FIELD(data, RLC_PG_DELAY, CMD_PROPAGATE_DELAY, 0x10);
-                data = REG_SET_FIELD(data, RLC_PG_DELAY, MEM_SLEEP_DELAY, 0x10);
-                WREG32(mmRLC_PG_DELAY, data);
- 
-                WREG32_FIELD(RLC_PG_DELAY_2, SERDES_CMD_DELAY, 0x3);
-                WREG32_FIELD(RLC_AUTO_PG_CTRL, GRBM_REG_SAVE_GFX_IDLE_THRESHOLD, 0x55f0);
-	}
-}
-
 static void gfx_v8_0_init_pg(struct amdgpu_device *adev)
 {
 	if (adev->pg_flags & (AMD_PG_SUPPORT_GFX_PG |
@@ -4045,14 +4013,11 @@ static void gfx_v8_0_init_pg(struct amdgpu_device *adev)
  
 		if ((adev->asic_type == CHIP_CARRIZO) ||
 		    (adev->asic_type == CHIP_STONEY)) {
-			struct amdgpu_cu_info cu_info;
- 
-			gfx_v8_0_get_cu_info(adev, &cu_info);
  
 			WREG32(mmRLC_JUMP_TABLE_RESTORE, adev->gfx.rlc.cp_table_gpu_addr >> 8);
 			gfx_v8_0_init_power_gating(adev);
-			WREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, cu_info.ao_cu_mask);
-			if (adev->pg_flags & AMDGPU_PG_SUPPORT_RLC_SMU_HS) {
+			WREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, adev->gfx.cu_info.ao_cu_mask);
+			if (adev->pg_flags & AMD_PG_SUPPORT_RLC_SMU_HS) {
 				cz_enable_sck_slow_down_on_power_up(adev, true);
 				cz_enable_sck_slow_down_on_power_down(adev, true);
 			} else {
@@ -4064,7 +4029,7 @@ static void gfx_v8_0_init_pg(struct amdgpu_device *adev)
 			else
 				cz_enable_cp_power_gating(adev, false);
 		} else if (adev->asic_type == CHIP_POLARIS11) {
-			polaris11_init_power_gating(adev);
+			gfx_v8_0_init_power_gating(adev);
 		}
 	}
 }
@@ -5598,9 +5563,9 @@ static void cz_enable_gfx_pipeline_power_gating(struct amdgpu_device *adev,
 static void cz_update_gfx_cg_power_gating(struct amdgpu_device *adev,
 					  bool enable)
 {
-       if ((adev->pg_flags & AMDGPU_PG_SUPPORT_GFX_PG) && enable) {
+       if ((adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) && enable) {
 		cz_enable_gfx_cg_power_gating(adev, true);
-		if (adev->pg_flags & AMDGPU_PG_SUPPORT_GFX_PIPELINE)
+		if (adev->pg_flags & AMD_PG_SUPPORT_GFX_PIPELINE)
 			cz_enable_gfx_pipeline_power_gating(adev, true);
 	} else {
 		cz_enable_gfx_cg_power_gating(adev, false);
@@ -5614,21 +5579,21 @@ static int gfx_v8_0_set_powergating_state(void *handle,
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	bool enable = (state == AMD_PG_STATE_GATE) ? true : false;
  
-	if (!(adev->pg_flags & AMDGPU_PG_SUPPORT_GFX_PG))
+	if (!(adev->pg_flags & AMD_PG_SUPPORT_GFX_PG))
 		return 0;
  
 	switch (adev->asic_type) {
 	case CHIP_CARRIZO:
 	case CHIP_STONEY:
-		if (adev->pg_flags & AMDGPU_PG_SUPPORT_GFX_PG)
+		if (adev->pg_flags & AMD_PG_SUPPORT_GFX_PG)
 			cz_update_gfx_cg_power_gating(adev, enable);
  
-		if ((adev->pg_flags & AMDGPU_PG_SUPPORT_GFX_SMG) && enable)
+		if ((adev->pg_flags & AMD_PG_SUPPORT_GFX_SMG) && enable)
 			gfx_v8_0_enable_gfx_static_mg_power_gating(adev, true);
 		else
 			gfx_v8_0_enable_gfx_static_mg_power_gating(adev, false);
  
-		if ((adev->pg_flags & AMDGPU_PG_SUPPORT_GFX_DMG) && enable)
+		if ((adev->pg_flags & AMD_PG_SUPPORT_GFX_DMG) && enable)
 		       gfx_v8_0_enable_gfx_dynamic_mg_power_gating(adev, true);
 		else
 		       gfx_v8_0_enable_gfx_dynamic_mg_power_gating(adev, false);
@@ -5952,8 +5917,6 @@ static void gfx_v8_0_update_medium_grain_clock_gating(struct amdgpu_device *adev
 		gfx_v8_0_wait_for_rlc_serdes(adev);
 	}
 
-	gfx_v8_0_wait_for_rlc_serdes(adev);
-
 	adev->gfx.rlc.funcs->exit_safe_mode(adev);
 }
 
@@ -6043,6 +6006,8 @@ static void gfx_v8_0_update_coarse_grain_clock_gating(struct amdgpu_device *adev
 			WREG32(mmRLC_CGCG_CGLS_CTRL, data);
 	}
 
+	gfx_v8_0_wait_for_rlc_serdes(adev);
+
 	adev->gfx.rlc.funcs->exit_safe_mode(adev);
 }
 static int gfx_v8_0_update_gfx_clock_gating(struct amdgpu_device *adev,
-- 
2.7.4

