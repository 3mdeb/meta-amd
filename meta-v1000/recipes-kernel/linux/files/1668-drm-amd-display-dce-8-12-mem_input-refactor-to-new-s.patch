From a3f1d3610dacd9bd206058955f08cb553625546c Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Mon, 15 May 2017 08:31:51 -0400
Subject: [PATCH 1668/2094] drm/amd/display: dce 8 - 12 mem_input refactor to
 new style

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
---
 drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c | 306 +++++++++++++--
 drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.h | 115 ++++--
 .../drm/amd/display/dc/dce100/dce100_resource.c    |  78 +---
 drivers/gpu/drm/amd/display/dc/dce110/Makefile     |   3 +-
 .../drm/amd/display/dc/dce110/dce110_mem_input.c   | 437 ---------------------
 .../drm/amd/display/dc/dce110/dce110_mem_input.h   | 121 ------
 .../drm/amd/display/dc/dce110/dce110_mem_input_v.c | 155 +++-----
 .../drm/amd/display/dc/dce110/dce110_mem_input_v.h |  66 +---
 .../drm/amd/display/dc/dce110/dce110_resource.c    |  58 +--
 drivers/gpu/drm/amd/display/dc/dce112/Makefile     |   2 +-
 .../drm/amd/display/dc/dce112/dce112_mem_input.c   |  54 ---
 .../drm/amd/display/dc/dce112/dce112_mem_input.h   |  38 --
 .../drm/amd/display/dc/dce112/dce112_resource.c    |  77 +---
 drivers/gpu/drm/amd/display/dc/dce120/Makefile     |   2 +-
 .../drm/amd/display/dc/dce120/dce120_mem_input.c   | 340 ----------------
 .../drm/amd/display/dc/dce120/dce120_mem_input.h   |  37 --
 .../drm/amd/display/dc/dce120/dce120_resource.c    |  75 +---
 drivers/gpu/drm/amd/display/dc/dce80/Makefile      |   3 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_mem_input.c |  83 ----
 .../gpu/drm/amd/display/dc/dce80/dce80_mem_input.h |  36 --
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |  78 +---
 drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h  |   8 -
 22 files changed, 476 insertions(+), 1696 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.h

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 0552fc5..718688c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -23,18 +23,18 @@
  *
  */
 
-#include "mem_input.h"
+#include "dce_mem_input.h"
 #include "reg_helper.h"
 #include "basics/conversion.h"
 
 #define CTX \
-	mi->ctx
+	dce_mi->base.ctx
 #define REG(reg)\
-	mi->regs->reg
+	dce_mi->regs->reg
 
 #undef FN
 #define FN(reg_name, field_name) \
-	mi->shifts->field_name, mi->masks->field_name
+	dce_mi->shifts->field_name, dce_mi->masks->field_name
 
 struct pte_setting {
 	unsigned int bpp;
@@ -130,11 +130,13 @@ static bool is_vert_scan(enum dc_rotation_angle rotation)
 	}
 }
 
-void dce_mem_input_program_pte_vm(struct mem_input *mi,
+static void dce_mi_program_pte_vm(
+		struct mem_input *mi,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	enum mi_bits_per_pixel mi_bpp = get_mi_bpp(format);
 	enum mi_tiling_format mi_tiling = get_mi_tiling(tiling_info);
 	const struct pte_setting *pte = &pte_settings[mi_tiling][mi_bpp];
@@ -158,7 +160,8 @@ void dce_mem_input_program_pte_vm(struct mem_input *mi,
 			DVMM_MAX_PTE_REQ_OUTSTANDING, 0xff);
 }
 
-static void program_urgency_watermark(struct mem_input *mi,
+static void program_urgency_watermark(
+	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t urgency_low_wm,
 	uint32_t urgency_high_wm)
@@ -171,7 +174,8 @@ static void program_urgency_watermark(struct mem_input *mi,
 		URGENCY_HIGH_WATERMARK, urgency_high_wm);
 }
 
-static void program_nbp_watermark(struct mem_input *mi,
+static void program_nbp_watermark(
+	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t nbp_wm)
 {
@@ -202,7 +206,8 @@ static void program_nbp_watermark(struct mem_input *mi,
 	}
 }
 
-static void program_stutter_watermark(struct mem_input *mi,
+static void program_stutter_watermark(
+	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t stutter_mark)
 {
@@ -217,41 +222,67 @@ static void program_stutter_watermark(struct mem_input *mi,
 				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
 }
 
-void dce_mem_input_program_display_marks(struct mem_input *mi,
+static void dce_mi_program_display_marks(
+	struct mem_input *mi,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
 	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
 
-	program_urgency_watermark(mi, 0, /* set a */
+	program_urgency_watermark(dce_mi, 2, /* set a */
 			urgent.a_mark, total_dest_line_time_ns);
-	program_urgency_watermark(mi, 1, /* set b */
+	program_urgency_watermark(dce_mi, 1, /* set d */
+			urgent.d_mark, total_dest_line_time_ns);
+
+	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
+		STUTTER_ENABLE, stutter_en,
+		STUTTER_IGNORE_FBC, 1);
+	program_nbp_watermark(dce_mi, 2, nbp.a_mark); /* set a */
+	program_nbp_watermark(dce_mi, 1, nbp.d_mark); /* set d */
+
+	program_stutter_watermark(dce_mi, 2, stutter.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter.d_mark); /* set d */
+}
+
+static void dce120_mi_program_display_marks(struct mem_input *mi,
+	struct dce_watermarks nbp,
+	struct dce_watermarks stutter,
+	struct dce_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
+	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
+
+	program_urgency_watermark(dce_mi, 0, /* set a */
+			urgent.a_mark, total_dest_line_time_ns);
+	program_urgency_watermark(dce_mi, 1, /* set b */
 			urgent.b_mark, total_dest_line_time_ns);
-	program_urgency_watermark(mi, 2, /* set c */
+	program_urgency_watermark(dce_mi, 2, /* set c */
 			urgent.c_mark, total_dest_line_time_ns);
-	program_urgency_watermark(mi, 3, /* set d */
+	program_urgency_watermark(dce_mi, 3, /* set d */
 			urgent.d_mark, total_dest_line_time_ns);
 
 	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
 		STUTTER_ENABLE, stutter_en,
 		STUTTER_IGNORE_FBC, 1);
-	program_nbp_watermark(mi, 0, nbp.a_mark); /* set a */
-	program_nbp_watermark(mi, 1, nbp.b_mark); /* set b */
-	program_nbp_watermark(mi, 2, nbp.c_mark); /* set c */
-	program_nbp_watermark(mi, 3, nbp.d_mark); /* set d */
-
-	program_stutter_watermark(mi, 0, stutter.a_mark); /* set a */
-	program_stutter_watermark(mi, 1, stutter.b_mark); /* set b */
-	program_stutter_watermark(mi, 2, stutter.c_mark); /* set c */
-	program_stutter_watermark(mi, 3, stutter.d_mark); /* set d */
+	program_nbp_watermark(dce_mi, 0, nbp.a_mark); /* set a */
+	program_nbp_watermark(dce_mi, 1, nbp.b_mark); /* set b */
+	program_nbp_watermark(dce_mi, 2, nbp.c_mark); /* set c */
+	program_nbp_watermark(dce_mi, 3, nbp.d_mark); /* set d */
+
+	program_stutter_watermark(dce_mi, 0, stutter.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter.b_mark); /* set b */
+	program_stutter_watermark(dce_mi, 2, stutter.c_mark); /* set c */
+	program_stutter_watermark(dce_mi, 3, stutter.d_mark); /* set d */
 }
 
-static void program_tiling(struct mem_input *mi,
-	const union dc_tiling_info *info)
+static void program_tiling(
+	struct dce_mem_input *dce_mi, const union dc_tiling_info *info)
 {
-	if (mi->masks->GRPH_SW_MODE) { /* GFX9 */
+	if (dce_mi->masks->GRPH_SW_MODE) { /* GFX9 */
 		REG_UPDATE_6(GRPH_CONTROL,
 				GRPH_SW_MODE, info->gfx9.swizzle,
 				GRPH_NUM_BANKS, log_2(info->gfx9.num_banks),
@@ -265,7 +296,7 @@ static void program_tiling(struct mem_input *mi,
 		 */
 	}
 
-	if (mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
+	if (dce_mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
 		REG_UPDATE_9(GRPH_CONTROL,
 				GRPH_NUM_BANKS, info->gfx8.num_banks,
 				GRPH_BANK_WIDTH, info->gfx8.bank_width,
@@ -285,7 +316,7 @@ static void program_tiling(struct mem_input *mi,
 
 
 static void program_size_and_rotation(
-	struct mem_input *mi,
+	struct dce_mem_input *dce_mi,
 	enum dc_rotation_angle rotation,
 	const union plane_size *plane_size)
 {
@@ -326,7 +357,7 @@ static void program_size_and_rotation(
 }
 
 static void program_grph_pixel_format(
-	struct mem_input *mi,
+	struct dce_mem_input *dce_mi,
 	enum surface_pixel_format format)
 {
 	uint32_t red_xbar = 0, blue_xbar = 0; /* no swap */
@@ -397,7 +428,8 @@ static void program_grph_pixel_format(
 			GRPH_PRESCALE_B_SIGN, sign);
 }
 
-void dce_mem_input_program_surface_config(struct mem_input *mi,
+static void dce_mi_program_surface_config(
+	struct mem_input *mi,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
 	union plane_size *plane_size,
@@ -405,14 +437,15 @@ void dce_mem_input_program_surface_config(struct mem_input *mi,
 	struct dc_plane_dcc_param *dcc,
 	bool horizontal_mirror)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	REG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);
 
-	program_tiling(mi, tiling_info);
-	program_size_and_rotation(mi, rotation, plane_size);
+	program_tiling(dce_mi, tiling_info);
+	program_size_and_rotation(dce_mi, rotation, plane_size);
 
 	if (format >= SURFACE_PIXEL_FORMAT_GRPH_BEGIN &&
 		format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
-		program_grph_pixel_format(mi, format);
+		program_grph_pixel_format(dce_mi, format);
 }
 
 static uint32_t get_dmif_switch_time_us(
@@ -461,12 +494,14 @@ static uint32_t get_dmif_switch_time_us(
 	return frame_time;
 }
 
-void dce_mem_input_allocate_dmif(struct mem_input *mi,
+static void dce_mi_allocate_dmif(
+	struct mem_input *mi,
 	uint32_t h_total,
 	uint32_t v_total,
 	uint32_t pix_clk_khz,
 	uint32_t total_stream_num)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	const uint32_t retry_delay = 10;
 	uint32_t retry_count = get_dmif_switch_time_us(
 			h_total,
@@ -497,18 +532,20 @@ void dce_mem_input_allocate_dmif(struct mem_input *mi,
 			PIXEL_DURATION, pix_dur);
 	}
 
-	if (mi->wa.single_head_rdreq_dmif_limit) {
+	if (dce_mi->wa.single_head_rdreq_dmif_limit) {
 		uint32_t eanble =  (total_stream_num > 1) ? 0 :
-				mi->wa.single_head_rdreq_dmif_limit;
+				dce_mi->wa.single_head_rdreq_dmif_limit;
 
 		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
 				ENABLE, eanble);
 	}
 }
 
-void dce_mem_input_free_dmif(struct mem_input *mi,
+static void dce_mi_free_dmif(
+		struct mem_input *mi,
 		uint32_t total_stream_num)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	uint32_t buffers_allocated;
 	uint32_t dmif_buffer_control;
 
@@ -525,11 +562,204 @@ void dce_mem_input_free_dmif(struct mem_input *mi,
 			DMIF_BUFFERS_ALLOCATION_COMPLETED, 1,
 			10, 3500);
 
-	if (mi->wa.single_head_rdreq_dmif_limit) {
+	if (dce_mi->wa.single_head_rdreq_dmif_limit) {
 		uint32_t eanble =  (total_stream_num > 1) ? 0 :
-				mi->wa.single_head_rdreq_dmif_limit;
+				dce_mi->wa.single_head_rdreq_dmif_limit;
 
 		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
 				ENABLE, eanble);
 	}
 }
+
+
+static void program_sec_addr(
+	struct dce_mem_input *dce_mi,
+	PHYSICAL_ADDRESS_LOC address)
+{
+	/*high register MUST be programmed first*/
+	REG_SET(GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, 0,
+		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
+		address.high_part);
+
+	REG_SET_2(GRPH_SECONDARY_SURFACE_ADDRESS, 0,
+		GRPH_SECONDARY_SURFACE_ADDRESS, address.low_part >> 8,
+		GRPH_SECONDARY_DFQ_ENABLE, 0);
+}
+
+static void program_pri_addr(
+	struct dce_mem_input *dce_mi,
+	PHYSICAL_ADDRESS_LOC address)
+{
+	/*high register MUST be programmed first*/
+	REG_SET(GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, 0,
+		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
+		address.high_part);
+
+	REG_SET(GRPH_PRIMARY_SURFACE_ADDRESS, 0,
+		GRPH_PRIMARY_SURFACE_ADDRESS,
+		address.low_part >> 8);
+}
+
+
+static bool dce_mi_is_flip_pending(struct mem_input *mem_input)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);
+	uint32_t update_pending;
+
+	REG_GET(GRPH_UPDATE, GRPH_SURFACE_UPDATE_PENDING, &update_pending);
+	if (update_pending)
+		return true;
+
+	mem_input->current_address = mem_input->request_address;
+	return false;
+}
+
+static bool dce_mi_program_surface_flip_and_addr(
+	struct mem_input *mem_input,
+	const struct dc_plane_address *address,
+	bool flip_immediate)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);
+
+	/* TODO: Figure out if two modes are needed:
+	 * non-XDMA Mode: GRPH_SURFACE_UPDATE_IMMEDIATE_EN = 1
+	 * XDMA Mode: GRPH_SURFACE_UPDATE_H_RETRACE_EN = 1
+	 */
+	REG_UPDATE(GRPH_UPDATE,
+			GRPH_UPDATE_LOCK, 1);
+
+	if (flip_immediate) {
+		REG_UPDATE_2(GRPH_FLIP_CONTROL,
+			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
+			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 1);
+	} else {
+		REG_UPDATE_2(GRPH_FLIP_CONTROL,
+			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
+			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 0);
+	}
+
+	switch (address->type) {
+	case PLN_ADDR_TYPE_GRAPHICS:
+		if (address->grph.addr.quad_part == 0)
+			break;
+		program_pri_addr(dce_mi, address->grph.addr);
+		break;
+	case PLN_ADDR_TYPE_GRPH_STEREO:
+		if (address->grph_stereo.left_addr.quad_part == 0
+			|| address->grph_stereo.right_addr.quad_part == 0)
+			break;
+		program_pri_addr(dce_mi, address->grph_stereo.left_addr);
+		program_sec_addr(dce_mi, address->grph_stereo.right_addr);
+		break;
+	default:
+		/* not supported */
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+
+	mem_input->request_address = *address;
+
+	if (flip_immediate)
+		mem_input->current_address = *address;
+
+	REG_UPDATE(GRPH_UPDATE,
+			GRPH_UPDATE_LOCK, 0);
+
+	return true;
+}
+
+static void dce_mi_update_dchub(struct mem_input *mi,
+		struct dchub_init_data *dh_data)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
+	/* TODO: port code from dal2 */
+	switch (dh_data->fb_mode) {
+	case FRAME_BUFFER_MODE_ZFB_ONLY:
+		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
+		REG_UPDATE_2(DCHUB_FB_LOCATION,
+				FB_TOP, 0,
+				FB_BASE, 0x0FFFF);
+
+		REG_UPDATE(DCHUB_AGP_BASE,
+				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUB_AGP_BOT,
+				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUB_AGP_TOP,
+				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUB_AGP_BASE,
+				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUB_AGP_BOT,
+				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUB_AGP_TOP,
+				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_LOCAL_ONLY:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUB_AGP_BASE,
+				AGP_BASE, 0);
+
+		REG_UPDATE(DCHUB_AGP_BOT,
+				AGP_BOT, 0x03FFFF);
+
+		REG_UPDATE(DCHUB_AGP_TOP,
+				AGP_TOP, 0);
+		break;
+	default:
+		break;
+	}
+
+	dh_data->dchub_initialzied = true;
+	dh_data->dchub_info_valid = false;
+}
+
+static struct mem_input_funcs dce_mi_funcs = {
+	.mem_input_program_display_marks = dce_mi_program_display_marks,
+	.allocate_mem_input = dce_mi_allocate_dmif,
+	.free_mem_input = dce_mi_free_dmif,
+	.mem_input_program_surface_flip_and_addr =
+			dce_mi_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm = dce_mi_program_pte_vm,
+	.mem_input_program_surface_config =
+			dce_mi_program_surface_config,
+	.mem_input_is_flip_pending = dce_mi_is_flip_pending,
+	.mem_input_update_dchub = dce_mi_update_dchub
+};
+
+
+void dce_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask)
+{
+	dce_mi->base.ctx = ctx;
+
+	dce_mi->base.inst = inst;
+	dce_mi->base.funcs = &dce_mi_funcs;
+
+	dce_mi->regs = regs;
+	dce_mi->shifts = mi_shift;
+	dce_mi->masks = mi_mask;
+
+}
+
+void dce112_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask)
+{
+	dce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);
+	dce_mi->base.funcs->mem_input_program_display_marks = dce120_mi_program_display_marks;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.h b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.h
index 4977f5f..55481f5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.h
@@ -26,8 +26,10 @@
 #define __DCE_MEM_INPUT_H__
 
 #include "dc_hw_types.h"
-struct dce_watermarks;
-struct mem_input;
+#include "mem_input.h"
+
+#define TO_DCE_MEM_INPUT(mem_input)\
+	container_of(mem_input, struct dce_mem_input, base)
 
 #define MI_DCE_BASE_REG_LIST(id)\
 	SRI(GRPH_ENABLE, DCP, id),\
@@ -40,6 +42,12 @@ struct mem_input;
 	SRI(HW_ROTATION, DCP, id),\
 	SRI(GRPH_SWAP_CNTL, DCP, id),\
 	SRI(PRESCALE_GRPH_CONTROL, DCP, id),\
+	SRI(GRPH_UPDATE, DCP, id),\
+	SRI(GRPH_FLIP_CONTROL, DCP, id),\
+	SRI(GRPH_PRIMARY_SURFACE_ADDRESS, DCP, id),\
+	SRI(GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, DCP, id),\
+	SRI(GRPH_SECONDARY_SURFACE_ADDRESS, DCP, id),\
+	SRI(GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, DCP, id),\
 	SRI(DPG_PIPE_ARBITRATION_CONTROL1, DMIF_PG, id),\
 	SRI(DPG_WATERMARK_MASK_CONTROL, DMIF_PG, id),\
 	SRI(DPG_PIPE_URGENCY_CONTROL, DMIF_PG, id),\
@@ -67,7 +75,11 @@ struct mem_input;
 	MI_DCE_PTE_REG_LIST(id),\
 	SRI(GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, DCP, id),\
 	SRI(DPG_PIPE_STUTTER_CONTROL2, DMIF_PG, id),\
-	SRI(DPG_PIPE_LOW_POWER_CONTROL, DMIF_PG, id)
+	SRI(DPG_PIPE_LOW_POWER_CONTROL, DMIF_PG, id),\
+	SR(DCHUB_FB_LOCATION),\
+	SR(DCHUB_AGP_BASE),\
+	SR(DCHUB_AGP_BOT),\
+	SR(DCHUB_AGP_TOP)
 
 struct dce_mem_input_registers {
 	/* DCP */
@@ -84,6 +96,12 @@ struct dce_mem_input_registers {
 	uint32_t GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT;
 	uint32_t DVMM_PTE_CONTROL;
 	uint32_t DVMM_PTE_ARB_CONTROL;
+	uint32_t GRPH_UPDATE;
+	uint32_t GRPH_FLIP_CONTROL;
+	uint32_t GRPH_PRIMARY_SURFACE_ADDRESS;
+	uint32_t GRPH_PRIMARY_SURFACE_ADDRESS_HIGH;
+	uint32_t GRPH_SECONDARY_SURFACE_ADDRESS;
+	uint32_t GRPH_SECONDARY_SURFACE_ADDRESS_HIGH;
 	/* DMIF_PG */
 	uint32_t DPG_PIPE_ARBITRATION_CONTROL1;
 	uint32_t DPG_WATERMARK_MASK_CONTROL;
@@ -96,6 +114,11 @@ struct dce_mem_input_registers {
 	uint32_t DMIF_BUFFER_CONTROL;
 	/* MC_HUB */
 	uint32_t MC_HUB_RDREQ_DMIF_LIMIT;
+	/*DCHUB*/
+	uint32_t DCHUB_FB_LOCATION;
+	uint32_t DCHUB_AGP_BASE;
+	uint32_t DCHUB_AGP_BOT;
+	uint32_t DCHUB_AGP_TOP;
 };
 
 /* Set_Filed_for_Block */
@@ -129,9 +152,16 @@ struct dce_mem_input_registers {
 	SFB(blk, PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_SELECT, mask_sh),\
 	SFB(blk, PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_R_SIGN, mask_sh),\
 	SFB(blk, PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_G_SIGN, mask_sh),\
-	SFB(blk, PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_B_SIGN, mask_sh)
+	SFB(blk, PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_B_SIGN, mask_sh),\
+	SFB(blk, GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, mask_sh),\
+	SFB(blk, GRPH_SECONDARY_SURFACE_ADDRESS, GRPH_SECONDARY_SURFACE_ADDRESS, mask_sh),\
+	SFB(blk, GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, mask_sh),\
+	SFB(blk, GRPH_PRIMARY_SURFACE_ADDRESS, GRPH_PRIMARY_SURFACE_ADDRESS, mask_sh),\
+	SFB(blk, GRPH_UPDATE, GRPH_SURFACE_UPDATE_PENDING, mask_sh),\
+	SFB(blk, GRPH_FLIP_CONTROL, GRPH_SURFACE_UPDATE_H_RETRACE_EN, mask_sh)
 
 #define MI_DCP_DCE11_MASK_SH_LIST(mask_sh, blk)\
+	SFB(blk, GRPH_FLIP_CONTROL, GRPH_SURFACE_UPDATE_IMMEDIATE_EN, mask_sh),\
 	SFB(blk, GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, mask_sh)
 
 #define MI_DCP_PTE_MASK_SH_LIST(mask_sh, blk)\
@@ -189,13 +219,22 @@ struct dce_mem_input_registers {
 	SFB(blk, DPG_PIPE_LOW_POWER_CONTROL, PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST, mask_sh),\
 	SFB(blk, DPG_PIPE_LOW_POWER_CONTROL, PSTATE_CHANGE_WATERMARK, mask_sh)
 
+#define MI_GFX9_DCHUB_MASK_SH_LIST(mask_sh)\
+	SF(DCHUB_FB_LOCATION, FB_TOP, mask_sh),\
+	SF(DCHUB_FB_LOCATION, FB_BASE, mask_sh),\
+	SF(DCHUB_AGP_BASE, AGP_BASE, mask_sh),\
+	SF(DCHUB_AGP_BOT, AGP_BOT, mask_sh),\
+	SF(DCHUB_AGP_TOP, AGP_TOP, mask_sh)
+
 #define MI_DCE12_MASK_SH_LIST(mask_sh)\
 	MI_DCP_MASK_SH_LIST(mask_sh, DCP0_),\
+	SF(DCP0_GRPH_SECONDARY_SURFACE_ADDRESS, GRPH_SECONDARY_DFQ_ENABLE, mask_sh),\
 	MI_DCP_DCE11_MASK_SH_LIST(mask_sh, DCP0_),\
 	MI_DCP_PTE_MASK_SH_LIST(mask_sh, DCP0_),\
 	MI_DMIF_PG_MASK_SH_LIST(mask_sh, DMIF_PG0_),\
 	MI_DCE12_DMIF_PG_MASK_SH_LIST(mask_sh, DMIF_PG0_),\
-	MI_GFX9_TILE_MASK_SH_LIST(mask_sh, DCP0_)
+	MI_GFX9_TILE_MASK_SH_LIST(mask_sh, DCP0_),\
+	MI_GFX9_DCHUB_MASK_SH_LIST(mask_sh)
 
 #define MI_REG_FIELD_LIST(type) \
 	type GRPH_ENABLE; \
@@ -232,6 +271,15 @@ struct dce_mem_input_registers {
 	type GRPH_SE_ENABLE; \
 	type GRPH_NUM_SHADER_ENGINES; \
 	type GRPH_NUM_PIPES; \
+	type GRPH_SECONDARY_SURFACE_ADDRESS_HIGH; \
+	type GRPH_SECONDARY_SURFACE_ADDRESS; \
+	type GRPH_SECONDARY_DFQ_ENABLE; \
+	type GRPH_PRIMARY_SURFACE_ADDRESS_HIGH; \
+	type GRPH_PRIMARY_SURFACE_ADDRESS; \
+	type GRPH_SURFACE_UPDATE_PENDING; \
+	type GRPH_SURFACE_UPDATE_IMMEDIATE_EN; \
+	type GRPH_SURFACE_UPDATE_H_RETRACE_EN; \
+	type GRPH_UPDATE_LOCK; \
 	type PIXEL_DURATION; \
 	type URGENCY_WATERMARK_MASK; \
 	type PSTATE_CHANGE_WATERMARK_MASK; \
@@ -253,6 +301,11 @@ struct dce_mem_input_registers {
 	type DMIF_BUFFERS_ALLOCATED; \
 	type DMIF_BUFFERS_ALLOCATION_COMPLETED; \
 	type ENABLE; /* MC_HUB_RDREQ_DMIF_LIMIT */\
+	type FB_BASE; \
+	type FB_TOP; \
+	type AGP_BASE; \
+	type AGP_TOP; \
+	type AGP_BOT; \
 
 struct dce_mem_input_shift {
 	MI_REG_FIELD_LIST(uint8_t)
@@ -266,32 +319,30 @@ struct dce_mem_input_wa {
 	uint8_t single_head_rdreq_dmif_limit;
 };
 
-void dce_mem_input_program_pte_vm(struct mem_input *mi,
-	enum surface_pixel_format format,
-	union dc_tiling_info *tiling_info,
-	enum dc_rotation_angle rotation);
-
-void dce_mem_input_program_surface_config(struct mem_input *mi,
-	enum surface_pixel_format format,
-	union dc_tiling_info *tiling_info,
-	union plane_size *plane_size,
-	enum dc_rotation_angle rotation,
-	struct dc_plane_dcc_param *dcc,
-	bool horizontal_mirror);
-
-void dce_mem_input_allocate_dmif(struct mem_input *mi,
-	uint32_t h_total,
-	uint32_t v_total,
-	uint32_t pix_clk_khz,
-	uint32_t total_stream_num);
-
-void dce_mem_input_free_dmif(struct mem_input *mi,
-	uint32_t total_stream_num);
-
-void dce_mem_input_program_display_marks(struct mem_input *mi,
-	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
-	struct dce_watermarks urgent,
-	uint32_t total_dest_line_time_ns);
+struct dce_mem_input {
+	struct mem_input base;
+
+	const struct dce_mem_input_registers *regs;
+	const struct dce_mem_input_shift *shifts;
+	const struct dce_mem_input_mask *masks;
+
+	struct dce_mem_input_wa wa;
+};
+
+void dce_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask);
+
+void dce112_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask);
 
 #endif /*__DCE_MEM_INPUT_H__*/
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index 254f9e4..8f1fe95 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -35,8 +35,8 @@
 #include "irq/dce110/irq_service_dce110.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
-#include "dce110/dce110_mem_input.h"
-#include "dce110/dce110_mem_input_v.h"
+
+#include "dce/dce_mem_input.h"
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_opp.h"
@@ -123,51 +123,6 @@ static const struct dce110_timing_generator_offsets dce100_tg_offsets[] = {
 	}
 };
 
-static const struct dce110_mem_input_reg_offsets dce100_mi_reg_offsets[] = {
-	{
-		.dcp = (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE3_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE4_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE5_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	}
-};
-
 /* set register offset */
 #define SR(reg_name)\
 	.reg_name = mm ## reg_name
@@ -510,28 +465,18 @@ static const struct dce_mem_input_mask mi_masks = {
 
 static struct mem_input *dce100_mem_input_create(
 	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offset)
+	uint32_t inst)
 {
-	struct dce110_mem_input *mem_input110 =
-		dm_alloc(sizeof(struct dce110_mem_input));
+	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
 
-	if (!mem_input110)
+	if (!dce_mi) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
-
-	if (dce110_mem_input_construct(mem_input110, ctx, inst, offset)) {
-		struct mem_input *mi = &mem_input110->base;
-
-		mi->regs = &mi_regs[inst];
-		mi->shifts = &mi_shifts;
-		mi->masks = &mi_masks;
-		mi->wa.single_head_rdreq_dmif_limit = 2;
-		return mi;
 	}
 
-	BREAK_TO_DEBUGGER();
-	dm_free(mem_input110);
-	return NULL;
+	dce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);
+	dce_mi->wa.single_head_rdreq_dmif_limit = 2;
+	return &dce_mi->base;
 }
 
 static void dce100_transform_destroy(struct transform **xfm)
@@ -671,7 +616,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
@@ -986,8 +931,7 @@ static bool construct(
 			goto res_create_fail;
 		}
 
-		pool->base.mis[i] = dce100_mem_input_create(ctx, i,
-				&dce100_mi_reg_offsets[i]);
+		pool->base.mis[i] = dce100_mem_input_create(ctx, i);
 		if (pool->base.mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/Makefile b/drivers/gpu/drm/amd/display/dc/dce110/Makefile
index c54bf03..98d956e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce110/Makefile
@@ -3,8 +3,7 @@
 # It provides the control and status of HW CRTC block.
 
 DCE110 = dce110_timing_generator.o \
-dce110_compressor.o dce110_mem_input.o dce110_hw_sequencer.o \
-dce110_resource.o \
+dce110_compressor.o dce110_hw_sequencer.o dce110_resource.o \
 dce110_opp_regamma_v.o dce110_opp_csc_v.o dce110_timing_generator_v.o \
 dce110_mem_input_v.o dce110_opp_v.o dce110_transform_v.o
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.c
deleted file mode 100644
index 45e1a8d..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.c
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#include "dm_services.h"
-
-#include "dce/dce_11_0_d.h"
-#include "dce/dce_11_0_sh_mask.h"
-/* TODO: this needs to be looked at, used by Stella's workaround*/
-#include "gmc/gmc_8_2_d.h"
-#include "gmc/gmc_8_2_sh_mask.h"
-
-#include "include/logger_interface.h"
-
-#include "dce110_mem_input.h"
-
-#define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
-#define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)
-#define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)
-
-static void program_sec_addr(
-	struct dce110_mem_input *mem_input110,
-	PHYSICAL_ADDRESS_LOC address)
-{
-	uint32_t value = 0;
-	uint32_t temp;
-
-	/*high register MUST be programmed first*/
-	temp = address.high_part &
-		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH__GRPH_SECONDARY_SURFACE_ADDRESS_HIGH_MASK;
-	set_reg_field_value(value, temp,
-		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
-		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH);
-	dm_write_reg(mem_input110->base.ctx,
-				 DCP_REG(mmGRPH_SECONDARY_SURFACE_ADDRESS_HIGH), value);
-
-	value = 0;
-	temp = address.low_part >>
-		GRPH_SECONDARY_SURFACE_ADDRESS__GRPH_SECONDARY_SURFACE_ADDRESS__SHIFT;
-	set_reg_field_value(value, temp,
-		GRPH_SECONDARY_SURFACE_ADDRESS,
-		GRPH_SECONDARY_SURFACE_ADDRESS);
-	dm_write_reg(mem_input110->base.ctx,
-				 DCP_REG(mmGRPH_SECONDARY_SURFACE_ADDRESS), value);
-}
-
-static void program_pri_addr(
-	struct dce110_mem_input *mem_input110,
-	PHYSICAL_ADDRESS_LOC address)
-{
-	uint32_t value = 0;
-	uint32_t temp;
-
-	/*high register MUST be programmed first*/
-	temp = address.high_part &
-		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_MASK;
-	set_reg_field_value(value, temp,
-		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
-		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH);
-	dm_write_reg(mem_input110->base.ctx,
-				 DCP_REG(mmGRPH_PRIMARY_SURFACE_ADDRESS_HIGH), value);
-
-	value = 0;
-	temp = address.low_part >>
-		GRPH_PRIMARY_SURFACE_ADDRESS__GRPH_PRIMARY_SURFACE_ADDRESS__SHIFT;
-	set_reg_field_value(value, temp,
-		GRPH_PRIMARY_SURFACE_ADDRESS,
-		GRPH_PRIMARY_SURFACE_ADDRESS);
-	dm_write_reg(mem_input110->base.ctx,
-				 DCP_REG(mmGRPH_PRIMARY_SURFACE_ADDRESS), value);
-}
-
-bool dce110_mem_input_is_flip_pending(struct mem_input *mem_input)
-{
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
-	uint32_t value;
-
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE));
-
-	if (get_reg_field_value(value, GRPH_UPDATE,
-			GRPH_SURFACE_UPDATE_PENDING))
-		return true;
-
-	mem_input->current_address = mem_input->request_address;
-	return false;
-}
-
-bool dce110_mem_input_program_surface_flip_and_addr(
-	struct mem_input *mem_input,
-	const struct dc_plane_address *address,
-	bool flip_immediate)
-{
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
-
-	uint32_t value = 0;
-	uint32_t value_old = 0;
-	uint32_t lock_value = 0;
-
-	lock_value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE));
-	set_reg_field_value(lock_value, 1, GRPH_UPDATE, GRPH_UPDATE_LOCK);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE), lock_value);
-
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_FLIP_CONTROL));
-	value_old = value;
-	if (flip_immediate) {
-		set_reg_field_value(value, 0, GRPH_FLIP_CONTROL, GRPH_SURFACE_UPDATE_IMMEDIATE_EN);
-		set_reg_field_value(value, 1, GRPH_FLIP_CONTROL, GRPH_SURFACE_UPDATE_H_RETRACE_EN);
-	} else {
-		set_reg_field_value(value, 0, GRPH_FLIP_CONTROL, GRPH_SURFACE_UPDATE_IMMEDIATE_EN);
-		set_reg_field_value(value, 0, GRPH_FLIP_CONTROL, GRPH_SURFACE_UPDATE_H_RETRACE_EN);
-	}
-	if (value != value_old) {
-		dm_write_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_FLIP_CONTROL), value);
-	}
-
-	switch (address->type) {
-	case PLN_ADDR_TYPE_GRAPHICS:
-		if (address->grph.addr.quad_part == 0)
-			break;
-		program_pri_addr(mem_input110, address->grph.addr);
-		break;
-	case PLN_ADDR_TYPE_GRPH_STEREO:
-		if (address->grph_stereo.left_addr.quad_part == 0
-			|| address->grph_stereo.right_addr.quad_part == 0)
-			break;
-		program_pri_addr(mem_input110, address->grph_stereo.left_addr);
-		program_sec_addr(mem_input110, address->grph_stereo.right_addr);
-		break;
-	default:
-		/* not supported */
-		BREAK_TO_DEBUGGER();
-		break;
-	}
-
-	mem_input->request_address = *address;
-	if (flip_immediate)
-		mem_input->current_address = *address;
-
-	lock_value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE));
-	set_reg_field_value(lock_value, 0, GRPH_UPDATE, GRPH_UPDATE_LOCK);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE), lock_value);
-
-	return true;
-}
-
-static void program_urgency_watermark(
-	const struct dc_context *ctx,
-	const uint32_t offset,
-	struct dce_watermarks marks_low,
-	uint32_t total_dest_line_time_ns)
-{
-	/* register value */
-	uint32_t urgency_cntl = 0;
-	uint32_t wm_mask_cntl = 0;
-
-	uint32_t urgency_addr = offset + mmDPG_PIPE_URGENCY_CONTROL;
-	uint32_t wm_addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
-
-	/*Write mask to enable reading/writing of watermark set A*/
-	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
-	set_reg_field_value(wm_mask_cntl,
-			1,
-			DPG_WATERMARK_MASK_CONTROL,
-			URGENCY_WATERMARK_MASK);
-	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
-
-	urgency_cntl = dm_read_reg(ctx, urgency_addr);
-
-	set_reg_field_value(
-		urgency_cntl,
-		marks_low.d_mark,
-		DPG_PIPE_URGENCY_CONTROL,
-		URGENCY_LOW_WATERMARK);
-
-	set_reg_field_value(
-		urgency_cntl,
-		total_dest_line_time_ns,
-		DPG_PIPE_URGENCY_CONTROL,
-		URGENCY_HIGH_WATERMARK);
-	dm_write_reg(ctx, urgency_addr, urgency_cntl);
-
-	/*Write mask to enable reading/writing of watermark set B*/
-	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
-	set_reg_field_value(wm_mask_cntl,
-			2,
-			DPG_WATERMARK_MASK_CONTROL,
-			URGENCY_WATERMARK_MASK);
-	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
-
-	urgency_cntl = dm_read_reg(ctx, urgency_addr);
-
-	set_reg_field_value(urgency_cntl,
-		marks_low.a_mark,
-		DPG_PIPE_URGENCY_CONTROL,
-		URGENCY_LOW_WATERMARK);
-
-	set_reg_field_value(urgency_cntl,
-		total_dest_line_time_ns,
-		DPG_PIPE_URGENCY_CONTROL,
-		URGENCY_HIGH_WATERMARK);
-	dm_write_reg(ctx, urgency_addr, urgency_cntl);
-}
-
-static void program_stutter_watermark(
-	const struct dc_context *ctx,
-	const uint32_t offset,
-	struct dce_watermarks marks)
-{
-	/* register value */
-	uint32_t stutter_cntl = 0;
-	uint32_t wm_mask_cntl = 0;
-
-	uint32_t stutter_addr = offset + mmDPG_PIPE_STUTTER_CONTROL;
-	uint32_t wm_addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
-
-	/*Write mask to enable reading/writing of watermark set A*/
-
-	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
-	set_reg_field_value(wm_mask_cntl,
-		1,
-		DPG_WATERMARK_MASK_CONTROL,
-		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK);
-	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
-
-	stutter_cntl = dm_read_reg(ctx, stutter_addr);
-
-	if (ctx->dc->debug.disable_stutter) {
-		set_reg_field_value(stutter_cntl,
-			0,
-			DPG_PIPE_STUTTER_CONTROL,
-			STUTTER_ENABLE);
-	} else {
-		set_reg_field_value(stutter_cntl,
-			1,
-			DPG_PIPE_STUTTER_CONTROL,
-			STUTTER_ENABLE);
-	}
-
-	set_reg_field_value(stutter_cntl,
-		1,
-		DPG_PIPE_STUTTER_CONTROL,
-		STUTTER_IGNORE_FBC);
-
-	/*Write watermark set A*/
-	set_reg_field_value(stutter_cntl,
-		marks.d_mark,
-		DPG_PIPE_STUTTER_CONTROL,
-		STUTTER_EXIT_SELF_REFRESH_WATERMARK);
-	dm_write_reg(ctx, stutter_addr, stutter_cntl);
-
-	/*Write mask to enable reading/writing of watermark set B*/
-	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
-	set_reg_field_value(wm_mask_cntl,
-		2,
-		DPG_WATERMARK_MASK_CONTROL,
-		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK);
-	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
-
-	stutter_cntl = dm_read_reg(ctx, stutter_addr);
-
-	/*Write watermark set B*/
-	set_reg_field_value(stutter_cntl,
-		marks.a_mark,
-		DPG_PIPE_STUTTER_CONTROL,
-		STUTTER_EXIT_SELF_REFRESH_WATERMARK);
-	dm_write_reg(ctx, stutter_addr, stutter_cntl);
-}
-
-static void program_nbp_watermark(
-	const struct dc_context *ctx,
-	const uint32_t offset,
-	struct dce_watermarks marks)
-{
-	uint32_t value;
-	uint32_t addr;
-	/* Write mask to enable reading/writing of watermark set A */
-	addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
-	value = dm_read_reg(ctx, addr);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_WATERMARK_MASK_CONTROL,
-		NB_PSTATE_CHANGE_WATERMARK_MASK);
-	dm_write_reg(ctx, addr, value);
-
-	addr = offset + mmDPG_PIPE_NB_PSTATE_CHANGE_CONTROL;
-	value = dm_read_reg(ctx, addr);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_ENABLE);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_URGENT_DURING_REQUEST);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST);
-	dm_write_reg(ctx, addr, value);
-
-	/* Write watermark set A */
-	value = dm_read_reg(ctx, addr);
-	set_reg_field_value(
-		value,
-		marks.d_mark,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_WATERMARK);
-	dm_write_reg(ctx, addr, value);
-
-	/* Write mask to enable reading/writing of watermark set B */
-	addr = offset + mmDPG_WATERMARK_MASK_CONTROL;
-	value = dm_read_reg(ctx, addr);
-	set_reg_field_value(
-		value,
-		2,
-		DPG_WATERMARK_MASK_CONTROL,
-		NB_PSTATE_CHANGE_WATERMARK_MASK);
-	dm_write_reg(ctx, addr, value);
-
-	addr = offset + mmDPG_PIPE_NB_PSTATE_CHANGE_CONTROL;
-	value = dm_read_reg(ctx, addr);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_ENABLE);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_URGENT_DURING_REQUEST);
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST);
-	dm_write_reg(ctx, addr, value);
-
-	/* Write watermark set B */
-	value = dm_read_reg(ctx, addr);
-	set_reg_field_value(
-		value,
-		marks.a_mark,
-		DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
-		NB_PSTATE_CHANGE_WATERMARK);
-	dm_write_reg(ctx, addr, value);
-}
-
-void dce110_mem_input_program_display_marks(
-	struct mem_input *mem_input,
-	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
-	struct dce_watermarks urgent,
-	uint32_t total_dest_line_time_ns)
-{
-	struct dce110_mem_input *bm_dce110 = TO_DCE110_MEM_INPUT(mem_input);
-
-	program_urgency_watermark(
-		mem_input->ctx,
-		bm_dce110->offsets.dmif,
-		urgent,
-		total_dest_line_time_ns);
-
-	program_nbp_watermark(
-		mem_input->ctx,
-		bm_dce110->offsets.dmif,
-		nbp);
-
-	program_stutter_watermark(
-		mem_input->ctx,
-		bm_dce110->offsets.dmif,
-		stutter);
-}
-
-static struct mem_input_funcs dce110_mem_input_funcs = {
-	.mem_input_program_display_marks =
-			dce110_mem_input_program_display_marks,
-	.allocate_mem_input = dce_mem_input_allocate_dmif,
-	.free_mem_input = dce_mem_input_free_dmif,
-	.mem_input_program_surface_flip_and_addr =
-			dce110_mem_input_program_surface_flip_and_addr,
-	.mem_input_program_pte_vm =
-			dce_mem_input_program_pte_vm,
-	.mem_input_program_surface_config =
-			dce_mem_input_program_surface_config,
-	.mem_input_is_flip_pending =
-			dce110_mem_input_is_flip_pending,
-	.mem_input_update_dchub = NULL
-};
-/*****************************************/
-/* Constructor, Destructor               */
-/*****************************************/
-
-bool dce110_mem_input_construct(
-	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets)
-{
-	/* supported stutter method
-	 * STUTTER_MODE_ENHANCED
-	 * STUTTER_MODE_QUAD_DMIF_BUFFER
-	 * STUTTER_MODE_WATERMARK_NBP_STATE
-	 */
-	mem_input110->base.funcs = &dce110_mem_input_funcs;
-	mem_input110->base.ctx = ctx;
-
-	mem_input110->base.inst = inst;
-
-	mem_input110->offsets = *offsets;
-
-	return true;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.h b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.h
deleted file mode 100644
index 5f10f26..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/* Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_MEM_INPUT_DCE110_H__
-#define __DC_MEM_INPUT_DCE110_H__
-
-#include "mem_input.h"
-
-#define TO_DCE110_MEM_INPUT(mi)\
-	container_of(mi, struct dce110_mem_input, base)
-
-struct dce110_mem_input_reg_offsets {
-	uint32_t dcp;
-	uint32_t dmif;
-	uint32_t pipe;
-};
-
-struct dce110_mem_input {
-	struct mem_input base;
-	struct dce110_mem_input_reg_offsets offsets;
-};
-
-bool dce110_mem_input_construct(
-	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets);
-
-/*
- * dce110_mem_input_program_display_marks
- *
- * This function will program nbp stutter and urgency watermarks to minimum
- * allowable values
- */
-void dce110_mem_input_program_display_marks(
-	struct mem_input *mem_input,
-	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
-	struct dce_watermarks urgent,
-	uint32_t total_dest_line_time_ns);
-
-/*
- * dce110_allocate_mem_input
- *
- * This function will allocate a dmif buffer and program required
- * pixel duration for pipe
- */
-void dce110_allocate_mem_input(
-	struct mem_input *mem_input,
-	uint32_t h_total,/* for current stream */
-	uint32_t v_total,/* for current stream */
-	uint32_t pix_clk_khz,/* for current stream */
-	uint32_t total_stream_num);
-
-/*
- * dce110_free_mem_input
- *
- * This function will deallocate a dmif buffer from pipe
- */
-void dce110_free_mem_input(
-	struct mem_input *mem_input,
-	uint32_t total_stream_num);
-
-/*
- * dce110_mem_input_program_surface_flip_and_addr
- *
- * This function programs hsync/vsync mode and surface address
- */
-bool dce110_mem_input_program_surface_flip_and_addr(
-	struct mem_input *mem_input,
-	const struct dc_plane_address *address,
-	bool flip_immediate);
-
-/*
- * dce110_mem_input_program_surface_config
- *
- * This function will program surface tiling, size, rotation and pixel format
- * to corresponding dcp registers.
- */
-bool  dce110_mem_input_program_surface_config(
-	struct mem_input *mem_input,
-	enum surface_pixel_format format,
-	union dc_tiling_info *tiling_info,
-	union plane_size *plane_size,
-	enum dc_rotation_angle rotation,
-	struct dc_plane_dcc_param *dcc,
-	bool horizontal_mirror,
-	bool visible);
-
-/*
- * dce110_mem_input_is_flip_pending
- *
- * This function will wait until the surface update-pending bit is cleared.
- * This is necessary when a flip immediate call is requested as we shouldn't
- * return until the flip has actually occurred.
- */
-bool dce110_mem_input_is_flip_pending(
-	struct mem_input *mem_input);
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 78dd3ae..9777a4d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -33,29 +33,17 @@
 #include "include/logger_interface.h"
 #include "inc/dce_calcs.h"
 
-#include "dce110_mem_input.h"
-
-#define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
-/*#define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)*/
-/*#define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)*/
-
-static const struct dce110_mem_input_reg_offsets dce110_mi_v_reg_offsets[] = {
-	{
-		.dcp = 0,
-		.dmif = 0,
-		.pipe = 0,
-	}
-};
+#include "dce/dce_mem_input.h"
 
 static void set_flip_control(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	bool immediate)
 {
 	uint32_t value = 0;
 
 	value = dm_read_reg(
 			mem_input110->base.ctx,
-			DCP_REG(mmUNP_FLIP_CONTROL));
+			mmUNP_FLIP_CONTROL);
 
 	set_reg_field_value(value, 1,
 			UNP_FLIP_CONTROL,
@@ -63,13 +51,13 @@ static void set_flip_control(
 
 	dm_write_reg(
 			mem_input110->base.ctx,
-			DCP_REG(mmUNP_FLIP_CONTROL),
+			mmUNP_FLIP_CONTROL,
 			value);
 }
 
 /* chroma part */
 static void program_pri_addr_c(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	PHYSICAL_ADDRESS_LOC address)
 {
 	uint32_t value = 0;
@@ -84,7 +72,7 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C,
 		value);
 
 	temp = 0;
@@ -98,13 +86,13 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_C),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_C,
 		value);
 }
 
 /* luma part */
 static void program_pri_addr_l(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	PHYSICAL_ADDRESS_LOC address)
 {
 	uint32_t value = 0;
@@ -120,7 +108,7 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L,
 		value);
 
 	temp = 0;
@@ -134,12 +122,12 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_L),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_L,
 		value);
 }
 
 static void program_addr(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	const struct dc_plane_address *addr)
 {
 	switch (addr->type) {
@@ -162,19 +150,19 @@ static void program_addr(
 	}
 }
 
-static void enable(struct dce110_mem_input *mem_input110)
+static void enable(struct dce_mem_input *mem_input110)
 {
 	uint32_t value = 0;
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_ENABLE));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_GRPH_ENABLE);
 	set_reg_field_value(value, 1, UNP_GRPH_ENABLE, GRPH_ENABLE);
 	dm_write_reg(mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_ENABLE),
+		mmUNP_GRPH_ENABLE,
 		value);
 }
 
 static void program_tiling(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	const union dc_tiling_info *info,
 	const enum surface_pixel_format pixel_format)
 {
@@ -239,7 +227,7 @@ static void program_tiling(
 }
 
 static void program_size_and_rotation(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	enum dc_rotation_angle rotation,
 	const union plane_size *plane_size)
 {
@@ -277,7 +265,7 @@ static void program_size_and_rotation(
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PITCH_L),
+		mmUNP_GRPH_PITCH_L,
 		value);
 
 	value = 0;
@@ -285,7 +273,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_PITCH_C, GRPH_PITCH_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PITCH_C),
+		mmUNP_GRPH_PITCH_C,
 		value);
 
 	value = 0;
@@ -293,7 +281,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_START_L, GRPH_X_START_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_START_L),
+		mmUNP_GRPH_X_START_L,
 		value);
 
 	value = 0;
@@ -301,7 +289,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_START_C, GRPH_X_START_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_START_C),
+		mmUNP_GRPH_X_START_C,
 		value);
 
 	value = 0;
@@ -309,7 +297,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_START_L, GRPH_Y_START_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_START_L),
+		mmUNP_GRPH_Y_START_L,
 		value);
 
 	value = 0;
@@ -317,7 +305,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_START_C, GRPH_Y_START_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_START_C),
+		mmUNP_GRPH_Y_START_C,
 		value);
 
 	value = 0;
@@ -326,7 +314,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_END_L, GRPH_X_END_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_END_L),
+		mmUNP_GRPH_X_END_L,
 		value);
 
 	value = 0;
@@ -335,7 +323,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_END_C, GRPH_X_END_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_END_C),
+		mmUNP_GRPH_X_END_C,
 		value);
 
 	value = 0;
@@ -344,7 +332,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_END_L, GRPH_Y_END_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_END_L),
+		mmUNP_GRPH_Y_END_L,
 		value);
 
 	value = 0;
@@ -353,7 +341,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_END_C, GRPH_Y_END_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_END_C),
+		mmUNP_GRPH_Y_END_C,
 		value);
 
 	value = 0;
@@ -378,12 +366,12 @@ static void program_size_and_rotation(
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_HW_ROTATION),
+		mmUNP_HW_ROTATION,
 		value);
 }
 
 static void program_pixel_format(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	enum surface_pixel_format format)
 {
 	if (format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
@@ -393,7 +381,7 @@ static void program_pixel_format(
 
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL));
+				mmUNP_GRPH_CONTROL);
 
 		switch (format) {
 		case SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:
@@ -440,12 +428,12 @@ static void program_pixel_format(
 
 		dm_write_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL),
+				mmUNP_GRPH_CONTROL,
 				value);
 
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL_EXP));
+				mmUNP_GRPH_CONTROL_EXP);
 
 		/* VIDEO FORMAT 0 */
 		set_reg_field_value(
@@ -455,7 +443,7 @@ static void program_pixel_format(
 				VIDEO_FORMAT);
 		dm_write_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL_EXP),
+				mmUNP_GRPH_CONTROL_EXP,
 				value);
 
 	} else {
@@ -465,7 +453,7 @@ static void program_pixel_format(
 
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL_EXP));
+				mmUNP_GRPH_CONTROL_EXP);
 
 		switch (format) {
 		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
@@ -487,17 +475,17 @@ static void program_pixel_format(
 
 		dm_write_reg(
 			mem_input110->base.ctx,
-			DCP_REG(mmUNP_GRPH_CONTROL_EXP),
+			mmUNP_GRPH_CONTROL_EXP,
 			value);
 	}
 }
 
-bool dce110_mem_input_v_is_surface_pending(struct mem_input *mem_input)
+bool dce_mem_input_v_is_surface_pending(struct mem_input *mem_input)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 	uint32_t value;
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_UPDATE));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_GRPH_UPDATE);
 
 	if (get_reg_field_value(value, UNP_GRPH_UPDATE,
 			GRPH_SURFACE_UPDATE_PENDING))
@@ -507,12 +495,12 @@ bool dce110_mem_input_v_is_surface_pending(struct mem_input *mem_input)
 	return false;
 }
 
-bool dce110_mem_input_v_program_surface_flip_and_addr(
+bool dce_mem_input_v_program_surface_flip_and_addr(
 	struct mem_input *mem_input,
 	const struct dc_plane_address *address,
 	bool flip_immediate)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 
 	set_flip_control(mem_input110, flip_immediate);
 	program_addr(mem_input110,
@@ -584,13 +572,13 @@ static const unsigned int *get_dvmm_hw_setting(
 	}
 }
 
-void dce110_mem_input_v_program_pte_vm(
+void dce_mem_input_v_program_pte_vm(
 		struct mem_input *mem_input,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 	const unsigned int *pte = get_dvmm_hw_setting(tiling_info, format, false);
 	const unsigned int *pte_chroma = get_dvmm_hw_setting(tiling_info, format, true);
 
@@ -628,36 +616,36 @@ void dce110_mem_input_v_program_pte_vm(
 		break;
 	}
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT);
 	/* TODO: un-hardcode requestlimit */
 	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_L);
 	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_C);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL);
 	set_reg_field_value(value, page_width, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_WIDTH);
 	set_reg_field_value(value, page_height, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_HEIGHT);
 	set_reg_field_value(value, min_pte_before_flip, UNP_DVMM_PTE_CONTROL, DVMM_MIN_PTE_BEFORE_FLIP);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL);
 	set_reg_field_value(value, pte[5], UNP_DVMM_PTE_ARB_CONTROL, DVMM_PTE_REQ_PER_CHUNK);
 	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL, DVMM_MAX_PTE_REQ_OUTSTANDING);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL_C);
 	set_reg_field_value(value, page_width_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_WIDTH_C);
 	set_reg_field_value(value, page_height_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_HEIGHT_C);
 	set_reg_field_value(value, min_pte_before_flip_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_MIN_PTE_BEFORE_FLIP_C);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL_C, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL_C);
 	set_reg_field_value(value, pte_chroma[5], UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_PTE_REQ_PER_CHUNK_C);
 	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_MAX_PTE_REQ_OUTSTANDING_C);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL_C, value);
 }
 
-void dce110_mem_input_v_program_surface_config(
+void dce_mem_input_v_program_surface_config(
 	struct mem_input *mem_input,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
@@ -666,7 +654,7 @@ void dce110_mem_input_v_program_surface_config(
 	struct dc_plane_dcc_param *dcc,
 	bool horizotal_mirror)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 
 	enable(mem_input110);
 	program_tiling(mem_input110, tiling_info, format);
@@ -943,7 +931,7 @@ static void program_nbp_watermark_c(
 			marks);
 }
 
-void dce110_mem_input_v_program_display_marks(
+void dce_mem_input_v_program_display_marks(
 	struct mem_input *mem_input,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
@@ -965,7 +953,7 @@ void dce110_mem_input_v_program_display_marks(
 
 }
 
-void dce110_mem_input_program_chroma_display_marks(
+void dce_mem_input_program_chroma_display_marks(
 	struct mem_input *mem_input,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
@@ -1036,42 +1024,29 @@ void dce110_free_mem_input_v(
 
 static struct mem_input_funcs dce110_mem_input_v_funcs = {
 	.mem_input_program_display_marks =
-			dce110_mem_input_v_program_display_marks,
+			dce_mem_input_v_program_display_marks,
 	.mem_input_program_chroma_display_marks =
-			dce110_mem_input_program_chroma_display_marks,
+			dce_mem_input_program_chroma_display_marks,
 	.allocate_mem_input = dce110_allocate_mem_input_v,
 	.free_mem_input = dce110_free_mem_input_v,
 	.mem_input_program_surface_flip_and_addr =
-			dce110_mem_input_v_program_surface_flip_and_addr,
+			dce_mem_input_v_program_surface_flip_and_addr,
 	.mem_input_program_pte_vm =
-			dce110_mem_input_v_program_pte_vm,
+			dce_mem_input_v_program_pte_vm,
 	.mem_input_program_surface_config =
-			dce110_mem_input_v_program_surface_config,
+			dce_mem_input_v_program_surface_config,
 	.mem_input_is_flip_pending =
-			dce110_mem_input_v_is_surface_pending
+			dce_mem_input_v_is_surface_pending
 };
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
 
-bool dce110_mem_input_v_construct(
-	struct dce110_mem_input *mem_input110,
+void dce110_mem_input_v_construct(
+	struct dce_mem_input *dce_mi,
 	struct dc_context *ctx)
 {
-	mem_input110->base.funcs = &dce110_mem_input_v_funcs;
-	mem_input110->base.ctx = ctx;
-
-	mem_input110->base.inst = 0;
-
-	mem_input110->offsets = dce110_mi_v_reg_offsets[0];
-
-	return true;
+	dce_mi->base.funcs = &dce110_mem_input_v_funcs;
+	dce_mi->base.ctx = ctx;
 }
 
-#if 0
-void dce110_mem_input_v_destroy(struct mem_input **mem_input)
-{
-	dm_free(TO_DCE110_MEM_INPUT(*mem_input));
-	*mem_input = NULL;
-}
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.h b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.h
index b2667ee..f01d4a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.h
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.h
@@ -26,70 +26,10 @@
 #define __DC_MEM_INPUT_V_DCE110_H__
 
 #include "mem_input.h"
-#include "dce110_mem_input.h"
+#include "dce/dce_mem_input.h"
 
-bool dce110_mem_input_v_construct(
-	struct dce110_mem_input *mem_input110,
+void dce110_mem_input_v_construct(
+	struct dce_mem_input *dce_mi,
 	struct dc_context *ctx);
 
-/*
- * This function will program nbp stutter and urgency watermarks to minimum
- * allowable values
- */
-void dce110_mem_input_v_program_display_marks(
-	struct mem_input *mem_input,
-	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
-	struct dce_watermarks urgent,
-	uint32_t total_dest_line_time_ns);
-
-/*
- * This function will allocate a dmif buffer and program required
- * pixel duration for pipe
- */
-void dce110_allocate_mem_v_input(
-	struct mem_input *mem_input,
-	uint32_t h_total,/* for current stream */
-	uint32_t v_total,/* for current stream */
-	uint32_t pix_clk_khz,/* for current stream */
-	uint32_t total_stream_num);
-
-/*
- * This function will deallocate a dmif buffer from pipe
- */
-void dce110_free_mem_v_input(
-	struct mem_input *mem_input,
-	uint32_t total_stream_num);
-
-/*
- * This function programs hsync/vsync mode and surface address
- */
-bool dce110_mem_input_v_program_surface_flip_and_addr(
-	struct mem_input *mem_input,
-	const struct dc_plane_address *address,
-	bool flip_immediate);
-
-/*
- * dce110_mem_input_v_program_scatter_gather
- *
- * This function will program scatter gather registers.
- */
-bool  dce110_mem_input_v_program_pte_vm(
-	struct mem_input *mem_input,
-	enum surface_pixel_format format,
-	union dc_tiling_info *tiling_info,
-	enum dc_rotation_angle rotation);
-
-/*
- * This function will program surface tiling, size, rotation and pixel format
- * to corresponding dcp registers.
- */
-bool  dce110_mem_input_v_program_surface_config(
-	struct mem_input *mem_input,
-	enum surface_pixel_format format,
-	union dc_tiling_info *tiling_info,
-	union plane_size *plane_size,
-	enum dc_rotation_angle rotation,
-	bool visible);
-
 #endif
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 041d119..3ed5b94 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -38,7 +38,7 @@
 #include "dce110/dce110_timing_generator_v.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
-#include "dce110/dce110_mem_input.h"
+#include "dce/dce_mem_input.h"
 #include "dce110/dce110_mem_input_v.h"
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
@@ -133,30 +133,6 @@ static const struct dce110_timing_generator_offsets dce110_tg_offsets[] = {
 	}
 };
 
-static const struct dce110_mem_input_reg_offsets dce110_mi_reg_offsets[] = {
-	{
-		.dcp = (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	}
-};
-
 /* set register offset */
 #define SR(reg_name)\
 	.reg_name = mm ## reg_name
@@ -520,30 +496,21 @@ static const struct dce_mem_input_mask mi_masks = {
 		.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK
 };
 
+
 static struct mem_input *dce110_mem_input_create(
 	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offset)
+	uint32_t inst)
 {
-	struct dce110_mem_input *mem_input110 =
-		dm_alloc(sizeof(struct dce110_mem_input));
+	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
 
-	if (!mem_input110)
+	if (!dce_mi) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
-
-	if (dce110_mem_input_construct(mem_input110, ctx, inst, offset)) {
-		struct mem_input *mi = &mem_input110->base;
-
-		mi->regs = &mi_regs[inst];
-		mi->shifts = &mi_shifts;
-		mi->masks = &mi_masks;
-		mi->wa.single_head_rdreq_dmif_limit = 3;
-		return mi;
 	}
 
-	BREAK_TO_DEBUGGER();
-	dm_free(mem_input110);
-	return NULL;
+	dce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);
+	dce_mi->wa.single_head_rdreq_dmif_limit = 3;
+	return &dce_mi->base;
 }
 
 static void dce110_transform_destroy(struct transform **xfm)
@@ -698,7 +665,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
@@ -1132,7 +1099,7 @@ static bool underlay_create(struct dc_context *ctx, struct resource_pool *pool)
 {
 	struct dce110_timing_generator *dce110_tgv = dm_alloc(sizeof (*dce110_tgv));
 	struct dce_transform *dce110_xfmv = dm_alloc(sizeof (*dce110_xfmv));
-	struct dce110_mem_input *dce110_miv = dm_alloc(sizeof (*dce110_miv));
+	struct dce_mem_input *dce110_miv = dm_alloc(sizeof (*dce110_miv));
 	struct dce110_opp *dce110_oppv = dm_alloc(sizeof (*dce110_oppv));
 
 	if ((dce110_tgv == NULL) ||
@@ -1345,8 +1312,7 @@ static bool construct(
 			goto res_create_fail;
 		}
 
-		pool->base.mis[i] = dce110_mem_input_create(ctx, i,
-				&dce110_mi_reg_offsets[i]);
+		pool->base.mis[i] = dce110_mem_input_create(ctx, i);
 		if (pool->base.mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/Makefile b/drivers/gpu/drm/amd/display/dc/dce112/Makefile
index 2d536fb..265ac43 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce112/Makefile
@@ -3,7 +3,7 @@
 # It provides the control and status of HW CRTC block.
 
 DCE112 = dce112_compressor.o dce112_hw_sequencer.o \
-dce112_resource.o dce112_mem_input.o
+dce112_resource.o
 
 AMD_DAL_DCE112 = $(addprefix $(AMDDALPATH)/dc/dce112/,$(DCE112))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.c
deleted file mode 100644
index c29007d..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#include "dm_services.h"
-#include "dce112_mem_input.h"
-
-
-#include "dce/dce_11_2_d.h"
-#include "dce/dce_11_2_sh_mask.h"
-
-
-#define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
-#define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)
-#define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)
-
-/*****************************************/
-/* Constructor, Destructor               */
-/*****************************************/
-
-bool dce112_mem_input_construct(
-	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets)
-{
-  if (!dce110_mem_input_construct(mem_input110, ctx, inst, offsets))
-		return false;
-
-	mem_input110->base.funcs->mem_input_program_display_marks =
-			dce_mem_input_program_display_marks;
-
-	return true;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.h b/drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.h
deleted file mode 100644
index de2aaf0..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_mem_input.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_MEM_INPUT_DCE112_H__
-#define __DC_MEM_INPUT_DCE112_H__
-
-#include "mem_input.h"
-#include "dce110/dce110_mem_input.h"
-
-bool dce112_mem_input_construct(
-	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets);
-
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index 0ed2616..f405d6e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -32,9 +32,10 @@
 #include "include/irq_service_interface.h"
 #include "dce110/dce110_resource.h"
 #include "dce110/dce110_timing_generator.h"
-#include "dce112/dce112_mem_input.h"
 
 #include "irq/dce110/irq_service_dce110.h"
+
+#include "dce/dce_mem_input.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
@@ -132,51 +133,6 @@ static const struct dce110_timing_generator_offsets dce112_tg_offsets[] = {
 	}
 };
 
-static const struct dce110_mem_input_reg_offsets dce112_mi_reg_offsets[] = {
-	{
-		.dcp = (mmDCP0_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE3_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE4_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE5_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	}
-};
-
 /* set register offset */
 #define SR(reg_name)\
 	.reg_name = mm ## reg_name
@@ -541,27 +497,17 @@ static const struct dce_mem_input_mask mi_masks = {
 
 static struct mem_input *dce112_mem_input_create(
 	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offset)
+	uint32_t inst)
 {
-	struct dce110_mem_input *mem_input110 =
-		dm_alloc(sizeof(struct dce110_mem_input));
+	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
 
-	if (!mem_input110)
+	if (!dce_mi) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
-
-	if (dce112_mem_input_construct(mem_input110, ctx, inst, offset)) {
-		struct mem_input *mi = &mem_input110->base;
-
-		mi->regs = &mi_regs[inst];
-		mi->shifts = &mi_shifts;
-		mi->masks = &mi_masks;
-		return mi;
 	}
 
-	BREAK_TO_DEBUGGER();
-	dm_free(mem_input110);
-	return NULL;
+	dce112_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);
+	return &dce_mi->base;
 }
 
 static void dce112_transform_destroy(struct transform **xfm)
@@ -705,7 +651,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
@@ -1347,10 +1293,7 @@ static bool construct(
 			goto res_create_fail;
 		}
 
-		pool->base.mis[i] = dce112_mem_input_create(
-			ctx,
-			i,
-			&dce112_mi_reg_offsets[i]);
+		pool->base.mis[i] = dce112_mem_input_create(ctx, i);
 		if (pool->base.mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/Makefile b/drivers/gpu/drm/amd/display/dc/dce120/Makefile
index 826c12e..1779b96 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce120/Makefile
@@ -4,7 +4,7 @@
 
 
 DCE120 = dce120_resource.o dce120_timing_generator.o \
-dce120_mem_input.o dce120_hw_sequencer.o
+dce120_hw_sequencer.o
 
 AMD_DAL_DCE120 = $(addprefix $(AMDDALPATH)/dc/dce120/,$(DCE120))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.c
deleted file mode 100644
index c067721..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.c
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#include "dm_services.h"
-#include "dce120_mem_input.h"
-
-
-#include "vega10/DC/dce_12_0_offset.h"
-#include "vega10/DC/dce_12_0_sh_mask.h"
-#include "vega10/soc15ip.h"
-
-#define GENERAL_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(mem_input110->base.ctx, 0, reg_name, n, __VA_ARGS__)
-
-#define GENERAL_REG_UPDATE(reg, field, val)	\
-		GENERAL_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define GENERAL_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		GENERAL_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-
-
-#define DCP_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(mem_input110->base.ctx, mem_input110->offsets.dcp, reg_name, n, __VA_ARGS__)
-
-#define DCP_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_set_soc15(mem_input110->base.ctx, mem_input110->offsets.dcp, reg_name, n, __VA_ARGS__)
-
-#define DCP_REG_UPDATE(reg, field, val)	\
-		DCP_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define DCP_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		DCP_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DCP_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DCP_REG_UPDATE_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-#define DCP_REG_SET(reg, field, val)	\
-		DCP_REG_SET_N(reg, 1, FD(reg##__##field), val)
-
-#define DCP_REG_SET_2(reg, field1, val1, field2, val2)	\
-		DCP_REG_SET_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DCP_REG_SET_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DCP_REG_SET_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-
-
-#define DMIF_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(mem_input110->base.ctx, mem_input110->offsets.dmif, reg_name, n, __VA_ARGS__)
-
-#define DMIF_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_set_soc15(mem_input110->base.ctx, mem_input110->offsets.dmif, reg_name, n, __VA_ARGS__)
-
-#define DMIF_REG_UPDATE(reg, field, val)	\
-		DMIF_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define DMIF_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		DMIF_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DMIF_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DMIF_REG_UPDATE_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-#define DMIF_REG_SET(reg, field, val)	\
-		DMIF_REG_SET_N(reg, 1, FD(reg##__##field), val)
-
-#define DMIF_REG_SET_2(reg, field1, val1, field2, val2)	\
-		DMIF_REG_SET_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DMIF_REG_SET_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DMIF_REG_SET_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-
-
-#define PIPE_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(mem_input110->base.ctx, mem_input110->offsets.pipe, reg_name, n, __VA_ARGS__)
-
-#define PIPE_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_set_soc15(mem_input110->base.ctx, mem_input110->offsets.pipe, reg_name, n, __VA_ARGS__)
-
-#define PIPE_REG_UPDATE(reg, field, val)	\
-		PIPE_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define PIPE_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		PIPE_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define PIPE_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
-		PIPE_REG_UPDATE_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-#define PIPE_REG_SET(reg, field, val)	\
-		PIPE_REG_SET_N(reg, 1, FD(reg##__##field), val)
-
-#define PIPE_REG_SET_2(reg, field1, val1, field2, val2)	\
-		PIPE_REG_SET_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define PIPE_REG_SET_3(reg, field1, val1, field2, val2, field3, val3)	\
-		PIPE_REG_SET_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-
-
-static void program_sec_addr(
-	struct dce110_mem_input *mem_input110,
-	PHYSICAL_ADDRESS_LOC address)
-{
-	uint32_t temp;
-
-	/*high register MUST be programmed first*/
-	temp = address.high_part &
-		DCP0_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH__GRPH_SECONDARY_SURFACE_ADDRESS_HIGH_MASK;
-
-	DCP_REG_SET(
-		DCP0_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
-		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
-		temp);
-
-	temp = address.low_part >>
-		DCP0_GRPH_SECONDARY_SURFACE_ADDRESS__GRPH_SECONDARY_SURFACE_ADDRESS__SHIFT;
-
-	DCP_REG_SET_2(
-		DCP0_GRPH_SECONDARY_SURFACE_ADDRESS,
-		GRPH_SECONDARY_SURFACE_ADDRESS, temp,
-		GRPH_SECONDARY_DFQ_ENABLE, 0);
-}
-
-static void program_pri_addr(
-	struct dce110_mem_input *mem_input110,
-	PHYSICAL_ADDRESS_LOC address)
-{
-	uint32_t temp;
-
-	/*high register MUST be programmed first*/
-	temp = address.high_part &
-		DCP0_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_MASK;
-
-	DCP_REG_SET(
-		DCP0_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
-		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
-		temp);
-
-	temp = address.low_part >>
-		DCP0_GRPH_PRIMARY_SURFACE_ADDRESS__GRPH_PRIMARY_SURFACE_ADDRESS__SHIFT;
-
-	DCP_REG_SET(
-		DCP0_GRPH_PRIMARY_SURFACE_ADDRESS,
-		GRPH_PRIMARY_SURFACE_ADDRESS,
-		temp);
-}
-
-
-static bool mem_input_is_flip_pending(struct mem_input *mem_input)
-{
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
-	uint32_t value;
-
-	value = dm_read_reg_soc15(mem_input110->base.ctx,
-			mmDCP0_GRPH_UPDATE, mem_input110->offsets.dcp);
-
-	if (get_reg_field_value(value, DCP0_GRPH_UPDATE,
-			GRPH_SURFACE_UPDATE_PENDING))
-		return true;
-
-	mem_input->current_address = mem_input->request_address;
-	return false;
-}
-
-static bool mem_input_program_surface_flip_and_addr(
-	struct mem_input *mem_input,
-	const struct dc_plane_address *address,
-	bool flip_immediate)
-{
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
-
-	/* TODO: Figure out if two modes are needed:
-	 * non-XDMA Mode: GRPH_SURFACE_UPDATE_IMMEDIATE_EN = 1
-	 * XDMA Mode: GRPH_SURFACE_UPDATE_H_RETRACE_EN = 1
-	 */
-	DCP_REG_UPDATE(DCP0_GRPH_UPDATE,
-			GRPH_UPDATE_LOCK, 1);
-
-	if (flip_immediate) {
-		DCP_REG_UPDATE_2(
-			DCP0_GRPH_FLIP_CONTROL,
-			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
-			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 1);
-	} else {
-		DCP_REG_UPDATE_2(
-			DCP0_GRPH_FLIP_CONTROL,
-			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
-			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 0);
-	}
-
-	switch (address->type) {
-	case PLN_ADDR_TYPE_GRAPHICS:
-		if (address->grph.addr.quad_part == 0)
-			break;
-		program_pri_addr(mem_input110, address->grph.addr);
-		break;
-	case PLN_ADDR_TYPE_GRPH_STEREO:
-		if (address->grph_stereo.left_addr.quad_part == 0
-			|| address->grph_stereo.right_addr.quad_part == 0)
-			break;
-		program_pri_addr(mem_input110, address->grph_stereo.left_addr);
-		program_sec_addr(mem_input110, address->grph_stereo.right_addr);
-		break;
-	default:
-		/* not supported */
-		BREAK_TO_DEBUGGER();
-		break;
-	}
-
-	mem_input->request_address = *address;
-
-	if (flip_immediate)
-		mem_input->current_address = *address;
-
-	DCP_REG_UPDATE(DCP0_GRPH_UPDATE,
-			GRPH_UPDATE_LOCK, 0);
-
-	return true;
-}
-
-static void mem_input_update_dchub(struct mem_input *mi,
-		struct dchub_init_data *dh_data)
-{
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mi);
-	/* TODO: port code from dal2 */
-	switch (dh_data->fb_mode) {
-	case FRAME_BUFFER_MODE_ZFB_ONLY:
-		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
-		GENERAL_REG_UPDATE_2(
-				DCHUB_FB_LOCATION,
-				FB_TOP, 0,
-				FB_BASE, 0x0FFFF);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_BASE,
-				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_BOT,
-				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_TOP,
-				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
-		break;
-	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_BASE,
-				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_BOT,
-				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_TOP,
-				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
-		break;
-	case FRAME_BUFFER_MODE_LOCAL_ONLY:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_BASE,
-				AGP_BASE, 0);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_BOT,
-				AGP_BOT, 0x03FFFF);
-
-		GENERAL_REG_UPDATE(
-				DCHUB_AGP_TOP,
-				AGP_TOP, 0);
-		break;
-	default:
-		break;
-	}
-
-	dh_data->dchub_initialzied = true;
-	dh_data->dchub_info_valid = false;
-}
-
-static struct mem_input_funcs dce120_mem_input_funcs = {
-	.mem_input_program_display_marks = dce_mem_input_program_display_marks,
-	.allocate_mem_input = dce_mem_input_allocate_dmif,
-	.free_mem_input = dce_mem_input_free_dmif,
-	.mem_input_program_surface_flip_and_addr =
-			mem_input_program_surface_flip_and_addr,
-	.mem_input_program_pte_vm = dce_mem_input_program_pte_vm,
-	.mem_input_program_surface_config =
-			dce_mem_input_program_surface_config,
-	.mem_input_is_flip_pending = mem_input_is_flip_pending,
-	.mem_input_update_dchub = mem_input_update_dchub
-};
-
-/*****************************************/
-/* Constructor, Destructor               */
-/*****************************************/
-
-bool dce120_mem_input_construct(
-	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets)
-{
-	/* supported stutter method
-	 * STUTTER_MODE_ENHANCED
-	 * STUTTER_MODE_QUAD_DMIF_BUFFER
-	 * STUTTER_MODE_WATERMARK_NBP_STATE
-	 */
-
-	if (!dce110_mem_input_construct(mem_input110, ctx, inst, offsets))
-		return false;
-
-	mem_input110->base.funcs = &dce120_mem_input_funcs;
-	mem_input110->offsets = *offsets;
-
-	return true;
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.h b/drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.h
deleted file mode 100644
index 379fd72..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_mem_input.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_MEM_INPUT_DCE120_H__
-#define __DC_MEM_INPUT_DCE120_H__
-
-#include "mem_input.h"
-#include "dce110/dce110_mem_input.h"
-
-bool dce120_mem_input_construct(
-	struct dce110_mem_input *mem_input110,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets);
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
index b13abb0..1276dab 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
@@ -41,8 +41,7 @@
 #include "dce/dce_clock_source.h"
 #include "dce/dce_clocks.h"
 #include "dce/dce_ipp.h"
-#include "dce110/dce110_mem_input.h"
-#include "dce120/dce120_mem_input.h"
+#include "dce/dce_mem_input.h"
 
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce120/dce120_hw_sequencer.h"
@@ -376,51 +375,6 @@ struct output_pixel_processor *dce120_opp_create(
 	return NULL;
 }
 
-static const struct dce110_mem_input_reg_offsets dce120_mi_reg_offsets[] = {
-	{
-		.dcp = (mmDCP0_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
-		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
-				- mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP1_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
-		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
-				- mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP2_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
-		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
-				- mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP3_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
-		.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
-				- mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE3_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP4_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
-		.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
-				- mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE4_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP5_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
-		.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
-				- mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE5_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	}
-};
-
 static const struct bios_registers bios_regs = {
 	.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6 + NBIO_BASE(mmBIOS_SCRATCH_6_BASE_IDX)
 };
@@ -518,7 +472,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
@@ -708,27 +662,17 @@ static const struct dce_mem_input_mask mi_masks = {
 
 static struct mem_input *dce120_mem_input_create(
 	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offset)
+	uint32_t inst)
 {
-	struct dce110_mem_input *mem_input110 =
-		dm_alloc(sizeof(struct dce110_mem_input));
+	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
 
-	if (!mem_input110)
+	if (!dce_mi) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
-
-	if (dce120_mem_input_construct(mem_input110, ctx, inst, offset)) {
-		struct mem_input *mi = &mem_input110->base;
-
-		mi->regs = &mi_regs[inst];
-		mi->shifts = &mi_shifts;
-		mi->masks = &mi_masks;
-		return mi;
 	}
 
-	BREAK_TO_DEBUGGER();
-	dm_free(mem_input110);
-	return NULL;
+	dce112_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);
+	return &dce_mi->base;
 }
 
 static struct transform *dce120_transform_create(
@@ -1007,8 +951,7 @@ static bool construct(
 			goto controller_create_fail;
 		}
 
-		pool->base.mis[i] = dce120_mem_input_create(ctx,
-				i, &dce120_mi_reg_offsets[i]);
+		pool->base.mis[i] = dce120_mem_input_create(ctx, i);
 
 		if (pool->base.mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/Makefile b/drivers/gpu/drm/amd/display/dc/dce80/Makefile
index 1d54d5f..c110589 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce80/Makefile
@@ -2,8 +2,7 @@
 # Makefile for the 'controller' sub-component of DAL.
 # It provides the control and status of HW CRTC block.
 
-DCE80 = dce80_timing_generator.o \
-	dce80_compressor.o dce80_mem_input.o dce80_hw_sequencer.o \
+DCE80 = dce80_timing_generator.o dce80_compressor.o dce80_hw_sequencer.o \
 	dce80_resource.o
 
 AMD_DAL_DCE80 = $(addprefix $(AMDDALPATH)/dc/dce80/,$(DCE80))
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.c
deleted file mode 100644
index 933e3d8..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#include "dm_services.h"
-
-#include "dce/dce_8_0_d.h"
-#include "dce/dce_8_0_sh_mask.h"
-/* TODO: this needs to be looked at, used by Stella's workaround*/
-#include "gmc/gmc_7_1_d.h"
-#include "gmc/gmc_7_1_sh_mask.h"
-
-#include "include/logger_interface.h"
-#include "inc/dce_calcs.h"
-
-#include "../dce110/dce110_mem_input.h"
-#include "dce80_mem_input.h"
-
-#define MAX_WATERMARK 0xFFFF
-#define SAFE_NBP_MARK 0x7FFF
-
-#define DCP_REG(reg) (reg + mem_input80->offsets.dcp)
-#define DMIF_REG(reg) (reg + mem_input80->offsets.dmif)
-#define PIPE_REG(reg) (reg + mem_input80->offsets.pipe)
-
-static struct mem_input_funcs dce80_mem_input_funcs = {
-	.mem_input_program_display_marks =
-			dce110_mem_input_program_display_marks,
-	.allocate_mem_input = dce_mem_input_allocate_dmif,
-	.free_mem_input = dce_mem_input_free_dmif,
-	.mem_input_program_surface_flip_and_addr =
-			dce110_mem_input_program_surface_flip_and_addr,
-	.mem_input_program_surface_config =
-			dce_mem_input_program_surface_config,
-	.mem_input_is_flip_pending =
-			dce110_mem_input_is_flip_pending,
-	.mem_input_update_dchub = NULL
-};
-
-/*****************************************/
-/* Constructor, Destructor               */
-/*****************************************/
-
-bool dce80_mem_input_construct(
-	struct dce110_mem_input *mem_input80,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets)
-{
-	/* supported stutter method
-	 * STUTTER_MODE_ENHANCED
-	 * STUTTER_MODE_QUAD_DMIF_BUFFER
-	 */
-	mem_input80->base.funcs = &dce80_mem_input_funcs;
-	mem_input80->base.ctx = ctx;
-
-	mem_input80->base.inst = inst;
-
-	mem_input80->offsets = *offsets;
-
-	return true;
-}
-
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.h b/drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.h
deleted file mode 100644
index 357b9e2..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_mem_input.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_MEM_INPUT_DCE80_H__
-#define __DC_MEM_INPUT_DCE80_H__
-
-#include "mem_input.h"
-
-bool dce80_mem_input_construct(
-	struct dce110_mem_input *mem_input80,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets);
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5735914..095e437 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -35,12 +35,12 @@
 #include "include/irq_service_interface.h"
 #include "irq/dce80/irq_service_dce80.h"
 #include "dce110/dce110_timing_generator.h"
-#include "dce110/dce110_mem_input.h"
 #include "dce110/dce110_resource.h"
 #include "dce80/dce80_timing_generator.h"
+#include "dce/dce_mem_input.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
-#include "dce80/dce80_mem_input.h"
+#include "dce/dce_mem_input.h"
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_opp.h"
@@ -141,51 +141,6 @@ static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
 		}
 };
 
-static const struct dce110_mem_input_reg_offsets dce80_mi_reg_offsets[] = {
-	{
-		.dcp = (mmGRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE3_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE4_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE5_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	}
-};
-
 /* set register offset */
 #define SR(reg_name)\
 	.reg_name = mm ## reg_name
@@ -541,28 +496,18 @@ static const struct dce_mem_input_mask mi_masks = {
 
 static struct mem_input *dce80_mem_input_create(
 	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets)
+	uint32_t inst)
 {
-	struct dce110_mem_input *mem_input80 =
-		dm_alloc(sizeof(struct dce110_mem_input));
+	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
 
-	if (!mem_input80)
+	if (!dce_mi) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
-
-	if (dce80_mem_input_construct(mem_input80, ctx, inst, offsets)) {
-		struct mem_input *mi = &mem_input80->base;
-
-		mi->regs = &mi_regs[inst];
-		mi->shifts = &mi_shifts;
-		mi->masks = &mi_masks;
-		mi->wa.single_head_rdreq_dmif_limit = 2;
-		return mi;
 	}
 
-	BREAK_TO_DEBUGGER();
-	dm_free(mem_input80);
-	return NULL;
+	dce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);
+	dce_mi->wa.single_head_rdreq_dmif_limit = 2;
+	return &dce_mi->base;
 }
 
 static void dce80_transform_destroy(struct transform **xfm)
@@ -684,7 +629,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
@@ -1000,8 +945,7 @@ static bool construct(
 			goto res_create_fail;
 		}
 
-		pool->base.mis[i] = dce80_mem_input_create(ctx, i,
-				&dce80_mi_reg_offsets[i]);
+		pool->base.mis[i] = dce80_mem_input_create(ctx, i);
 		if (pool->base.mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error("DC: failed to create memory input!\n");
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h b/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
index 79fbc60..bd0dfeb 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
@@ -28,8 +28,6 @@
 #include "dc.h"
 #include "include/grph_object_id.h"
 
-#include "dce/dce_mem_input.h" /* temporary */
-
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "dml/display_mode_structs.h"
 
@@ -51,7 +49,6 @@ struct dcn_watermark_set {
 	struct dcn_watermarks c;
 	struct dcn_watermarks d;
 };
-
 #endif
 
 struct dce_watermarks {
@@ -74,11 +71,6 @@ struct mem_input {
 	struct dc_plane_address current_address;
 	uint32_t inst;
 	struct stutter_modes stutter_mode;
-
-	const struct dce_mem_input_registers *regs;
-	const struct dce_mem_input_shift *shifts;
-	const struct dce_mem_input_mask *masks;
-	struct dce_mem_input_wa wa;
 };
 
 struct mem_input_funcs {
-- 
2.7.4

