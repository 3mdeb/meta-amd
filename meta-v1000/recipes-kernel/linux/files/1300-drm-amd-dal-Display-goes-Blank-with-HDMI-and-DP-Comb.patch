From e588dc3c8975612e78c76c6a8d360bfa3a7fca2a Mon Sep 17 00:00:00 2001
From: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date: Fri, 7 Oct 2016 13:24:20 -0400
Subject: [PATCH 1300/1722] drm/amd/dal: Display goes Blank with HDMI and DP
 Combination

DP Phy clock (PLL0 for Amythist) was reset after programming PLL1
for pixel clock when doing clock sharing.
Fix by explicitly designating a lock as being dp source clock instead
of relying on signal type being EXTERNAL.

Change-Id: I32843f1dcaa955dc6442575aedb1b045ac4f90ea
Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    | 22 +++++++++++++---------
 .../drm/amd/dal/dc/dce110/dce110_clock_source.c    |  2 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  2 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    | 13 ++++++++-----
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    | 21 ++++++++++++---------
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  | 22 +++++++++++++---------
 drivers/gpu/drm/amd/dal/dc/inc/clock_source.h      |  1 +
 7 files changed, 49 insertions(+), 34 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 6d8c24c..ba8eb49 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -504,7 +504,8 @@ struct clock_source *dce100_clock_source_create(
 	struct dc_context *ctx,
 	struct dc_bios *bios,
 	enum clock_source_id id,
-	const struct dce110_clk_src_reg_offsets *offsets)
+	const struct dce110_clk_src_reg_offsets *offsets,
+	bool dp_clk_src)
 {
 	struct dce110_clk_src *clk_src =
 		dm_alloc(sizeof(struct dce110_clk_src));
@@ -512,8 +513,10 @@ struct clock_source *dce100_clock_source_create(
 	if (!clk_src)
 		return NULL;
 
-	if (dce110_clk_src_construct(clk_src, ctx, bios, id, offsets))
+	if (dce110_clk_src_construct(clk_src, ctx, bios, id, offsets)) {
+		clk_src->base.dp_clk_src = dp_clk_src;
 		return &clk_src->base;
+	}
 
 	BREAK_TO_DEBUGGER();
 	return NULL;
@@ -796,23 +799,24 @@ static bool construct(
 	if (dal_adapter_service_get_firmware_info(as, &info) &&
 		info.external_clock_source_frequency_for_dp != 0) {
 		pool->base.dp_clock_source =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
 
 		pool->base.clock_sources[0] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0], false);
 		pool->base.clock_sources[1] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1], false);
 		pool->base.clock_sources[2] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2], false);
 		pool->base.clk_src_count = 3;
 
 	} else {
 		pool->base.dp_clock_source =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0], true);
+
 		pool->base.clock_sources[0] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1], false);
 		pool->base.clock_sources[1] =
-				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2], false);
 		pool->base.clk_src_count = 2;
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
index 6786815..5bc7f8d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
@@ -801,7 +801,7 @@ static bool dce110_clock_source_power_down(
 	enum bp_result bp_result;
 	struct bp_pixel_clock_parameters bp_pixel_clock_params = {0};
 
-	if (clk_src->id == CLOCK_SOURCE_ID_EXTERNAL)
+	if (clk_src->dp_clk_src)
 		return true;
 
 	/* If Pixel Clock is 0 it means Power Down Pll*/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 5709898..6e63007 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -327,7 +327,7 @@ static void dce110_crtc_switch_to_clk_src(
 
 	pixel_rate_cntl_value = dm_read_reg(clk_src->ctx, addr);
 
-	if (clk_src->id == CLOCK_SOURCE_ID_EXTERNAL)
+	if (clk_src->dp_clk_src)
 		set_reg_field_value(pixel_rate_cntl_value, 1,
 			CRTC0_PIXEL_RATE_CNTL, DP_DTO0_ENABLE);
 	else {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 9187b34..90d1553 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -450,7 +450,8 @@ struct clock_source *dce110_clock_source_create(
 	struct dc_context *ctx,
 	struct dc_bios *bios,
 	enum clock_source_id id,
-	const struct dce110_clk_src_reg_offsets *offsets)
+	const struct dce110_clk_src_reg_offsets *offsets,
+	bool dp_clk_src)
 {
 	struct dce110_clk_src *clk_src =
 		dm_alloc(sizeof(struct dce110_clk_src));
@@ -458,8 +459,10 @@ struct clock_source *dce110_clock_source_create(
 	if (!clk_src)
 		return NULL;
 
-	if (dce110_clk_src_construct(clk_src, ctx, bios, id, offsets))
+	if (dce110_clk_src_construct(clk_src, ctx, bios, id, offsets)) {
+		clk_src->base.dp_clk_src = dp_clk_src;
 		return &clk_src->base;
+	}
 
 	BREAK_TO_DEBUGGER();
 	return NULL;
@@ -1081,12 +1084,12 @@ static bool construct(
 	if (dal_adapter_service_get_firmware_info(as, &info) &&
 		info.external_clock_source_frequency_for_dp != 0) {
 		pool->base.dp_clock_source =
-				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
 
 		pool->base.clock_sources[0] =
-				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce110_clk_src_reg_offsets[0]);
+				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce110_clk_src_reg_offsets[0], false);
 		pool->base.clock_sources[1] =
-				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce110_clk_src_reg_offsets[1]);
+				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce110_clk_src_reg_offsets[1], false);
 
 		pool->base.clk_src_count = 2;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 13c323f..4b95be6a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -528,7 +528,8 @@ struct clock_source *dce112_clock_source_create(
 	struct dc_context *ctx,
 	struct dc_bios *bios,
 	enum clock_source_id id,
-	const struct dce112_clk_src_reg_offsets *offsets)
+	const struct dce112_clk_src_reg_offsets *offsets,
+	bool dp_clk_src)
 {
 	struct dce112_clk_src *clk_src =
 		dm_alloc(sizeof(struct dce112_clk_src));
@@ -536,8 +537,10 @@ struct clock_source *dce112_clock_source_create(
 	if (!clk_src)
 		return NULL;
 
-	if (dce112_clk_src_construct(clk_src, ctx, bios, id, offsets))
+	if (dce112_clk_src_construct(clk_src, ctx, bios, id, offsets)) {
+		clk_src->base.dp_clk_src = dp_clk_src;
 		return &clk_src->base;
+	}
 
 	BREAK_TO_DEBUGGER();
 	return NULL;
@@ -1025,27 +1028,27 @@ static bool construct(
 
 	pool->base.clock_sources[DCE112_CLK_SRC_PLL0] = dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0]);
+		CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0], false);
 	pool->base.clock_sources[DCE112_CLK_SRC_PLL1] = dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1]);
+		CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1], false);
 	pool->base.clock_sources[DCE112_CLK_SRC_PLL2] = dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2]);
+		CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2], false);
 	pool->base.clock_sources[DCE112_CLK_SRC_PLL3] = dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3]);
+		CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3], false);
 	pool->base.clock_sources[DCE112_CLK_SRC_PLL4] = dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4]);
+		CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4], false);
 	pool->base.clock_sources[DCE112_CLK_SRC_PLL5] = dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5]);
+		CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5], false);
 	pool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;
 
 	pool->base.dp_clock_source =  dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_ID_DP_DTO, &dce112_clk_src_reg_offsets[0]);
+		CLOCK_SOURCE_ID_DP_DTO, &dce112_clk_src_reg_offsets[0], true);
 
 	for (i = 0; i < pool->base.clk_src_count; i++) {
 		if (pool->base.clock_sources[i] == NULL) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 483b4c4..ab1078a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -445,7 +445,8 @@ struct clock_source *dce80_clock_source_create(
 	struct dc_context *ctx,
 	struct dc_bios *bios,
 	enum clock_source_id id,
-	const struct dce110_clk_src_reg_offsets *offsets)
+	const struct dce110_clk_src_reg_offsets *offsets,
+	bool dp_clk_src)
 {
 	struct dce110_clk_src *clk_src =
 		dm_alloc(sizeof(struct dce110_clk_src));
@@ -453,8 +454,10 @@ struct clock_source *dce80_clock_source_create(
 	if (!clk_src)
 		return NULL;
 
-	if (dce110_clk_src_construct(clk_src, ctx, bios, id, offsets))
+	if (dce110_clk_src_construct(clk_src, ctx, bios, id, offsets)) {
+		clk_src->base.dp_clk_src = dp_clk_src;
 		return &clk_src->base;
+	}
 
 	BREAK_TO_DEBUGGER();
 	return NULL;
@@ -756,23 +759,24 @@ static bool construct(
 	if (dal_adapter_service_get_firmware_info(as, &info) &&
 		info.external_clock_source_frequency_for_dp != 0) {
 		pool->base.dp_clock_source =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
 
 		pool->base.clock_sources[0] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0], false);
 		pool->base.clock_sources[1] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1], false);
 		pool->base.clock_sources[2] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2], false);
 		pool->base.clk_src_count = 3;
 
 	} else {
 		pool->base.dp_clock_source =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0], true);
+
 		pool->base.clock_sources[0] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1], false);
 		pool->base.clock_sources[1] =
-				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2], false);
 		pool->base.clk_src_count = 2;
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/clock_source.h b/drivers/gpu/drm/amd/dal/dc/inc/clock_source.h
index d67d5ce..c91c781 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/clock_source.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/clock_source.h
@@ -172,6 +172,7 @@ struct clock_source {
 	const struct clock_source_funcs *funcs;
 	struct dc_context *ctx;
 	enum clock_source_id id;
+	bool dp_clk_src;
 };
 
 #endif
-- 
2.7.4

