From aa7c49a21237eba67a34f07db877ec32e35821ca Mon Sep 17 00:00:00 2001
From: Sanjay R Mehta <Sanju.Mehta@amd.com>
Date: Fri, 19 May 2017 02:06:27 +0530
Subject: [PATCH] drm/amd/dal: Add brightness module

- Implemented DMCU interface to load firmware
- Created backlight module to initialize backlight curve
 and call dc link functions
- Created dc link functions to set DMCU backlight registers
- Copied over ACPI Object to retrieve ACPI extended brightness caps

Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      |   2 +-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c |   7 +
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  18 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |   9 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |   5 +-
 .../drm/amd/dal/dc/dce100/dce100_link_encoder.c    |   9 +-
 .../drm/amd/dal/dc/dce100/dce100_link_encoder.h    |   3 +-
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  16 +-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    | 190 +++----
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.h    |  18 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  15 +-
 .../drm/amd/dal/dc/dce112/dce112_link_encoder.c    |   9 +-
 .../drm/amd/dal/dc/dce112/dce112_link_encoder.h    |   3 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  15 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c  |   3 +-
 drivers/gpu/drm/amd/dal/dc/dm_services.h           |   7 +
 drivers/gpu/drm/amd/dal/dc/dm_services_types.h     |  37 ++
 drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h   |   4 +-
 .../drm/amd/dal/dc/virtual/virtual_link_encoder.c  |   8 +-
 .../gpu/drm/amd/dal/modules/backlight/backlight.c  | 565 +++++++++++++++++++++
 .../gpu/drm/amd/dal/modules/inc/mod_backlight.h    |  69 +++
 21 files changed, 867 insertions(+), 145 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/dal/modules/backlight/backlight.c
 create mode 100644 drivers/gpu/drm/amd/dal/modules/inc/mod_backlight.h

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index 20e1f97..9508a7d 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -1116,7 +1116,7 @@ static int amdgpu_dm_backlight_update_status(struct backlight_device *bd)
 	struct amdgpu_display_manager *dm = bl_get_data(bd);
 
 	if (dc_link_set_backlight_level(dm->backlight_link,
-			bd->props.brightness))
+			bd->props.brightness, 0))
 		return 0;
 	else
 		return 1;
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
index dc81357..fd7d93f 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
@@ -112,6 +112,13 @@ bool dm_read_persistent_data(struct dc_context *ctx,
 	return false;
 }
 
+void dm_delay_in_microseconds(struct dc_context *ctx,
+					unsigned int microSeconds)
+{
+	/*TODO implement*/
+	return;
+}
+
 /**** power component interfaces ****/
 
 bool dm_pp_pre_dce_clock_change(
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 9cdb0eb..b7cae5c 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -253,7 +253,6 @@ static bool set_gamut_remap(struct dc *dc,
 	return ret;
 }
 
-
 /* This function is not expected to fail, proper implementation of
  * validation will prevent this from ever being called for unsupported
  * configurations.
@@ -297,6 +296,20 @@ static void stream_update_scaling(
 	}
 }
 
+static bool set_backlight(struct dc *dc, unsigned int backlight_level,
+						unsigned int frame_ramp)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_set_backlight_level(&core_dc->links[i]->public,
+				backlight_level, frame_ramp);
+
+	return true;
+
+}
+
 static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 {
 	core_dc->public.stream_funcs.stream_update_scaling = stream_update_scaling;
@@ -307,6 +320,9 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 
 	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
+
+	core_dc->public.stream_funcs.set_backlight =
+			set_backlight;
 }
 
 static bool construct(struct core_dc *dc,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index b2c53f6..638fb68a 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -1372,7 +1372,8 @@ enum dc_status dc_link_validate_mode_timing(
 	return DC_OK;
 }
 
-bool dc_link_set_backlight_level(const struct dc_link *public, uint32_t level)
+bool dc_link_set_backlight_level(const struct dc_link *public, uint32_t level,
+		uint32_t frame_ramp)
 {
 	struct core_link *link = DC_LINK_TO_CORE(public);
 	struct dc_context *ctx = link->ctx;
@@ -1381,8 +1382,10 @@ bool dc_link_set_backlight_level(const struct dc_link *public, uint32_t level)
 			LOG_MINOR_BACKLIGHT_INTERFACE,
 			"New Backlight level: %d (0x%X)\n", level, level);
 
-	link->link_enc->funcs->set_lcd_backlight_level(link->link_enc, level);
-
+	/* always assume dmcu is running */
+	link->link_enc->funcs->set_dmcu_backlight_level
+						(link->link_enc, level,
+						frame_ramp);
 	return true;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index dff621f..8c31f7b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -69,6 +69,8 @@ struct dc_stream_funcs {
 			const struct rect *dst);
 	bool (*set_gamut_remap)(struct dc *dc,
 			const struct dc_stream **stream, int num_streams);
+	bool (*set_backlight)(struct dc *dc, unsigned int backlight_level,
+			unsigned int frame_ramp);
 };
 
 /* Structure to hold configuration flags set by dm at dc creation. */
@@ -494,7 +496,8 @@ const struct graphics_object_id dc_get_link_id_at_index(
 		struct dc *dc, uint32_t link_index);
 
 /* Set backlight level of an embedded panel (eDP, LVDS). */
-bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level);
+bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
+		uint32_t frame_ramp);
 
 /* Request DC to detect if there is a Panel connected.
  * boot - If this call is during initial boot.
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c
index 70d6755..e430f43 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c
@@ -54,7 +54,8 @@ static const struct link_encoder_funcs dce100_lnk_enc_funcs = {
 	.dp_set_phy_pattern = dce110_link_encoder_dp_set_phy_pattern,
 	.update_mst_stream_allocation_table =
 		dce110_link_encoder_update_mst_stream_allocation_table,
-	.set_lcd_backlight_level = dce110_link_encoder_set_lcd_backlight_level,
+	.set_dmcu_backlight_level =
+		dce110_link_encoder_set_dmcu_backlight_level,
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
@@ -66,14 +67,16 @@ bool dce100_link_encoder_construct(
 		const struct encoder_init_data *init_data,
 		const struct dce110_link_enc_registers *link_regs,
 		const struct dce110_link_enc_aux_registers *aux_regs,
-		const struct dce110_link_enc_bl_registers *bl_regs)
+		const struct dce110_link_enc_bl_registers *bl_regs,
+		const struct dce110_link_enc_dmcu_registers *dmcu_regs)
 {
 	dce110_link_encoder_construct(
 			enc110,
 			init_data,
 			link_regs,
 			aux_regs,
-			bl_regs);
+			bl_regs,
+			dmcu_regs);
 
 	enc110->base.funcs = &dce100_lnk_enc_funcs;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h
index ae0712f..4c6d65a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h
@@ -37,6 +37,7 @@ bool dce100_link_encoder_construct(
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
 	const struct dce110_link_enc_aux_registers *aux_regs,
-	const struct dce110_link_enc_bl_registers *bl_regs);
+	const struct dce110_link_enc_bl_registers *bl_regs,
+	const struct dce110_link_enc_dmcu_registers *dmcu_regs);
 
 #endif /* __DC_LINK_ENCODER__DCE100_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index fd3963b..6b40ec33 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -59,6 +59,10 @@
 	#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7
 #endif
 
+#ifndef mmBIOS_SCRATCH_2
+	#define mmBIOS_SCRATCH_2 0x05CB
+#endif
+
 static const struct dce110_timing_generator_offsets dce100_tg_offsets[] = {
 	{
 		.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),
@@ -210,6 +214,15 @@ static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 		.LVTMA_PWRSEQ_STATE = mmLVTMA_PWRSEQ_STATE
 };
 
+static const struct dce110_link_enc_dmcu_registers link_enc_dmcu_regs = {
+		.BL1_PWM_USER_LEVEL = mmBL1_PWM_USER_LEVEL,
+		.MASTER_COMM_DATA_REG1 = mmMASTER_COMM_DATA_REG1,
+		.MASTER_COMM_CMD_REG = mmMASTER_COMM_CMD_REG,
+		.MASTER_COMM_CNTL_REG = mmMASTER_COMM_CNTL_REG,
+		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2
+};
+
+
 #define aux_regs(id)\
 [id] = {\
 	.AUX_CONTROL = mmDP_AUX ## id ## _AUX_CONTROL,\
@@ -449,7 +462,8 @@ struct link_encoder *dce100_link_encoder_create(
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
 			&link_enc_aux_regs[enc_init_data->channel - 1],
-			&link_enc_bl_regs))
+			&link_enc_bl_regs,
+			&link_enc_dmcu_regs))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 34f0517..9c9c9fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -36,6 +36,14 @@
 #include "dce/dce_11_0_sh_mask.h"
 #include "dce/dce_11_0_enum.h"
 
+#ifndef ATOM_S2_CURRENT_BL_LEVEL_MASK
+#define ATOM_S2_CURRENT_BL_LEVEL_MASK   0x0000FF00L
+#endif
+
+#ifndef ATOM_S2_CURRENT_BL_LEVEL_SHIFT
+#define ATOM_S2_CURRENT_BL_LEVEL_SHIFT  8
+#endif
+
 #define LINK_REG(reg)\
 	(enc110->link_regs->reg)
 
@@ -45,6 +53,9 @@
 #define BL_REG(reg)\
 	(enc110->bl_regs->reg)
 
+#define DMCU_REG(reg)\
+	(enc110->dmcu_regs->reg)
+
 /* For current ASICs pixel clock - 600MHz */
 #define MAX_ENCODER_CLK 600000
 
@@ -102,7 +113,8 @@ static const struct link_encoder_funcs dce110_lnk_enc_funcs = {
 	.dp_set_phy_pattern = dce110_link_encoder_dp_set_phy_pattern,
 	.update_mst_stream_allocation_table =
 		dce110_link_encoder_update_mst_stream_allocation_table,
-	.set_lcd_backlight_level = dce110_link_encoder_set_lcd_backlight_level,
+	.set_dmcu_backlight_level =
+			dce110_link_encoder_set_dmcu_backlight_level,
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
@@ -1013,7 +1025,8 @@ bool dce110_link_encoder_construct(
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
 	const struct dce110_link_enc_aux_registers *aux_regs,
-	const struct dce110_link_enc_bl_registers *bl_regs)
+	const struct dce110_link_enc_bl_registers *bl_regs,
+	const struct dce110_link_enc_dmcu_registers *dmcu_regs)
 {
 	struct graphics_object_encoder_cap_info enc_cap_info = {0};
 	struct adapter_service *as = init_data->adapter_service;
@@ -1076,6 +1089,7 @@ bool dce110_link_encoder_construct(
 	enc110->link_regs = link_regs;
 	enc110->aux_regs = aux_regs;
 	enc110->bl_regs = bl_regs;
+	enc110->dmcu_regs = dmcu_regs;
 
 	switch (enc110->base.transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -1747,138 +1761,76 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 	} while (retries < DP_MST_UPDATE_MAX_RETRY);
 }
 
-/* black light programming */
-void dce110_link_encoder_set_lcd_backlight_level(
+void dce110_link_encoder_set_dmcu_backlight_level(
 	struct link_encoder *enc,
-	uint32_t level)
+	uint32_t level,
+	uint32_t frame_ramp)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
+	unsigned int dmcu_max_retry_on_wait_reg_ready = 801;
+	unsigned int dmcu_wait_reg_ready_interval = 100;
 
-	const uint32_t backlight_update_pending_max_retry = 1000;
-
-	uint32_t backlight;
-	uint32_t backlight_period;
-	uint32_t backlight_lock;
-
-	uint32_t i;
-	uint32_t backlight_24bit;
-	uint32_t backlight_17bit;
-	uint32_t backlight_16bit;
-	uint32_t masked_pwm_period;
-	uint8_t rounding_bit;
-	uint8_t bit_count;
-	uint64_t active_duty_cycle;
-
-	backlight = dm_read_reg(ctx, BL_REG(BL_PWM_CNTL));
-	backlight_period = dm_read_reg(ctx, BL_REG(BL_PWM_PERIOD_CNTL));
-	backlight_lock = dm_read_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK));
-
-	/*
-	 * 1. Convert 8-bit value to 17 bit U1.16 format
-	 * (1 integer, 16 fractional bits)
-	 */
-
-	/* 1.1 multiply 8 bit value by 0x10101 to get a 24 bit value,
-	 * effectively multiplying value by 256/255
-	 * eg. for a level of 0xEF, backlight_24bit = 0xEF * 0x10101 = 0xEFEFEF
-	 */
-	backlight_24bit = level * 0x10101;
-
-	/* 1.2 The upper 16 bits of the 24 bit value is the fraction, lower 8
-	 * used for rounding, take most significant bit of fraction for
-	 * rounding, e.g. for 0xEFEFEF, rounding bit is 1
-	 */
-	rounding_bit = (backlight_24bit >> 7) & 1;
-
-	/* 1.3 Add the upper 16 bits of the 24 bit value with the rounding bit
-	 * resulting in a 17 bit value e.g. 0xEFF0 = (0xEFEFEF >> 8) + 1
-	 */
-	backlight_17bit = (backlight_24bit >> 8) + rounding_bit;
-
-	/*
-	 * 2. Find  16 bit backlight active duty cycle, where 0 <= backlight
-	 * active duty cycle <= backlight period
-	 */
-
-	/* 2.1 Apply bitmask for backlight period value based on value of BITCNT
-	 */
-	{
-		uint32_t pwm_period_bitcnt = get_reg_field_value(
-			backlight_period,
-			BL_PWM_PERIOD_CNTL,
-			BL_PWM_PERIOD_BITCNT);
-		if (pwm_period_bitcnt == 0)
-			bit_count = 16;
-		else
-			bit_count = pwm_period_bitcnt;
-	}
-
-	/* e.g. maskedPwmPeriod = 0x24 when bitCount is 6 */
-	masked_pwm_period =
-	get_reg_field_value(
-		backlight_period,
-		BL_PWM_PERIOD_CNTL,
-		BL_PWM_PERIOD) & ((1 << bit_count) - 1);
+	unsigned int backlight_17bit = level * 0x10101;
+	unsigned char temp_uchar =
+			(unsigned char)(((backlight_17bit & 0x80) >> 7) & 1);
+	unsigned int regValue;
+	uint32_t pwmUserLevel;
+	uint32_t masterCmd;
+	uint32_t masterComCntl;
+	uint32_t s2;
 
-	/* 2.2 Calculate integer active duty cycle required upper 16 bits
-	 * contain integer component, lower 16 bits contain fractional component
-	 * of active duty cycle e.g. 0x21BDC0 = 0xEFF0 * 0x24
-	 */
-	active_duty_cycle = backlight_17bit * masked_pwm_period;
+	backlight_17bit = (backlight_17bit >> 8) + temp_uchar;
 
-	/* 2.3 Calculate 16 bit active duty cycle from integer and fractional
-	 * components shift by bitCount then mask 16 bits and add rounding bit
-	 * from MSB of fraction e.g. 0x86F7 = ((0x21BDC0 >> 6) & 0xFFF) + 0
-	 */
-	backlight_16bit = active_duty_cycle >> bit_count;
-	backlight_16bit &= 0xFFFF;
-	backlight_16bit += (active_duty_cycle >> (bit_count - 1)) & 0x1;
+	/* waitDMCUReadyForCmd */
+	do {
+		dm_delay_in_microseconds(ctx, dmcu_wait_reg_ready_interval);
+		regValue = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
+		dmcu_max_retry_on_wait_reg_ready--;
+	} while
+	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) !=
+		(MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & 0) &&
+		dmcu_max_retry_on_wait_reg_ready > 0);
+
+	/* setDMCUParam_BL */
+	pwmUserLevel = dm_read_reg(ctx, DMCU_REG(BL1_PWM_USER_LEVEL));
 	set_reg_field_value(
-		backlight,
-		backlight_16bit,
-		BL_PWM_CNTL,
-		BL_ACTIVE_INT_FRAC_CNT);
+			pwmUserLevel,
+			backlight_17bit,
+			BL1_PWM_USER_LEVEL,
+			BL1_PWM_USER_LEVEL);
+	dm_write_reg(ctx, DMCU_REG(BL1_PWM_USER_LEVEL), pwmUserLevel);
 
-	/*
-	 * 3. Program register with updated value
-	 */
+	/* write ramp */
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_DATA_REG1), frame_ramp);
 
-	/* 3.1 Lock group 2 backlight registers */
+	/* setDMCUParam_Cmd */
+	masterCmd = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CMD_REG));
 	set_reg_field_value(
-		backlight_lock,
-		1,
-		BL_PWM_GRP1_REG_LOCK,
-		BL_PWM_GRP1_IGNORE_MASTER_LOCK_EN);
+			masterCmd,
+			0x67,
+			MASTER_COMM_CMD_REG,
+			MASTER_COMM_CMD_REG_BYTE0);
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CMD_REG), masterCmd);
+
+	/* notifyDMCUMsg */
+	masterComCntl = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
 	set_reg_field_value(
-		backlight_lock,
-		1,
-		BL_PWM_GRP1_REG_LOCK,
-		BL_PWM_GRP1_REG_LOCK);
-	dm_write_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK), backlight_lock);
+			masterComCntl,
+			1,
+			MASTER_COMM_CNTL_REG,
+			MASTER_COMM_INTERRUPT);
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG), masterComCntl);
 
-	/* 3.2 Write new active duty cycle */
-	dm_write_reg(ctx, BL_REG(BL_PWM_CNTL), backlight);
+	/* UpdateRequestedBacklightLevel */
+	s2 = dm_read_reg(ctx, DMCU_REG(BIOS_SCRATCH_2));
 
-	/* 3.3 Unlock group 2 backlight registers */
-	set_reg_field_value(
-		backlight_lock,
-		0,
-		BL_PWM_GRP1_REG_LOCK,
-		BL_PWM_GRP1_REG_LOCK);
-	dm_write_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK), backlight_lock);
-
-	/* 5.4.4 Wait for pending bit to be cleared */
-	for (i = 0; i < backlight_update_pending_max_retry; ++i) {
-		backlight_lock = dm_read_reg(ctx, BL_REG(BL_PWM_GRP1_REG_LOCK));
-		if (!get_reg_field_value(
-			backlight_lock,
-			BL_PWM_GRP1_REG_LOCK,
-			BL_PWM_GRP1_REG_UPDATE_PENDING))
-			break;
+	s2 &= ~ATOM_S2_CURRENT_BL_LEVEL_MASK;
+	level &= (ATOM_S2_CURRENT_BL_LEVEL_MASK >>
+				ATOM_S2_CURRENT_BL_LEVEL_SHIFT);
+	s2 |= (level << ATOM_S2_CURRENT_BL_LEVEL_SHIFT);
 
-		udelay(10);
-	}
+	dm_write_reg(ctx, DMCU_REG(BIOS_SCRATCH_2), s2);
 }
 
 void dce110_link_encoder_connect_dig_be_to_fe(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
index 7d1625d..6f75335 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
@@ -39,6 +39,14 @@ struct dce110_link_enc_bl_registers {
 	uint32_t LVTMA_PWRSEQ_STATE;
 };
 
+struct dce110_link_enc_dmcu_registers {
+	uint32_t BL1_PWM_USER_LEVEL;
+	uint32_t MASTER_COMM_DATA_REG1;
+	uint32_t MASTER_COMM_CMD_REG;
+	uint32_t MASTER_COMM_CNTL_REG;
+	uint32_t BIOS_SCRATCH_2;
+};
+
 struct dce110_link_enc_aux_registers {
 	uint32_t AUX_CONTROL;
 	uint32_t AUX_DPHY_RX_CONTROL0;
@@ -70,6 +78,7 @@ struct dce110_link_encoder {
 	const struct dce110_link_enc_registers *link_regs;
 	const struct dce110_link_enc_aux_registers *aux_regs;
 	const struct dce110_link_enc_bl_registers *bl_regs;
+	const struct dce110_link_enc_dmcu_registers *dmcu_regs;
 };
 
 bool dce110_link_encoder_construct(
@@ -77,7 +86,9 @@ bool dce110_link_encoder_construct(
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
 	const struct dce110_link_enc_aux_registers *aux_regs,
-	const struct dce110_link_enc_bl_registers *bl_regs);
+	const struct dce110_link_enc_bl_registers *bl_regs,
+	const struct dce110_link_enc_dmcu_registers *dmcu_regs);
+
 bool dce110_link_encoder_validate_dvi_output(
 	const struct dce110_link_encoder *enc110,
 	enum signal_type connector_signal,
@@ -154,9 +165,10 @@ void dce110_link_encoder_update_mst_stream_allocation_table(
 	struct link_encoder *enc,
 	const struct link_mst_stream_allocation_table *table);
 
-void dce110_link_encoder_set_lcd_backlight_level(
+void dce110_link_encoder_set_dmcu_backlight_level(
 	struct link_encoder *enc,
-	uint32_t level);
+	uint32_t level,
+	uint32_t frame_ramp);
 
 void dce110_link_encoder_edp_backlight_control(
 	struct link_encoder *enc,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 4eb383e..e71c47a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -60,6 +60,10 @@
 	#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7
 #endif
 
+#ifndef mmBIOS_SCRATCH_2
+	#define mmBIOS_SCRATCH_2 0x05CB
+#endif
+
 static const struct dce110_timing_generator_offsets dce110_tg_offsets[] = {
 	{
 		.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),
@@ -159,6 +163,14 @@ static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 		.LVTMA_PWRSEQ_STATE = mmLVTMA_PWRSEQ_STATE
 };
 
+static const struct dce110_link_enc_dmcu_registers link_enc_dmcu_regs = {
+		.BL1_PWM_USER_LEVEL = mmBL1_PWM_USER_LEVEL,
+		.MASTER_COMM_DATA_REG1 = mmMASTER_COMM_DATA_REG1,
+		.MASTER_COMM_CMD_REG = mmMASTER_COMM_CMD_REG,
+		.MASTER_COMM_CNTL_REG = mmMASTER_COMM_CNTL_REG,
+		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2
+};
+
 #define aux_regs(id)\
 [id] = {\
 	.AUX_CONTROL = mmDP_AUX ## id ## _AUX_CONTROL,\
@@ -411,7 +423,8 @@ struct link_encoder *dce110_link_encoder_create(
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
 			&link_enc_aux_regs[enc_init_data->channel - 1],
-			&link_enc_bl_regs))
+			&link_enc_bl_regs,
+			&link_enc_dmcu_regs))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
index 915f06f..e0c0ace 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
@@ -155,7 +155,8 @@ static const struct link_encoder_funcs dce112_lnk_enc_funcs = {
 	.dp_set_phy_pattern = dce112_link_encoder_dp_set_phy_pattern,
 	.update_mst_stream_allocation_table =
 		dce110_link_encoder_update_mst_stream_allocation_table,
-	.set_lcd_backlight_level = dce110_link_encoder_set_lcd_backlight_level,
+	.set_dmcu_backlight_level =
+		dce110_link_encoder_set_dmcu_backlight_level,
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
@@ -167,14 +168,16 @@ bool dce112_link_encoder_construct(
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
 	const struct dce110_link_enc_aux_registers *aux_regs,
-	const struct dce110_link_enc_bl_registers *bl_regs)
+	const struct dce110_link_enc_bl_registers *bl_regs,
+	const struct dce110_link_enc_dmcu_registers *dmcu_regs)
 {
 	dce110_link_encoder_construct(
 		enc110,
 		init_data,
 		link_regs,
 		aux_regs,
-		bl_regs);
+		bl_regs,
+		dmcu_regs);
 
 	enc110->base.funcs = &dce112_lnk_enc_funcs;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h
index cfc9cc5..71c04cc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h
@@ -34,7 +34,8 @@ bool dce112_link_encoder_construct(
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
 	const struct dce110_link_enc_aux_registers *aux_regs,
-	const struct dce110_link_enc_bl_registers *bl_regs);
+	const struct dce110_link_enc_bl_registers *bl_regs,
+	const struct dce110_link_enc_dmcu_registers *dmcu_regs);
 
 /****************** HW programming ************************/
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 400dea26..804909a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -58,6 +58,10 @@
 	#define mmDP8_DP_DPHY_INTERNAL_CTRL 0x57a7
 #endif
 
+#ifndef mmBIOS_SCRATCH_2
+	#define mmBIOS_SCRATCH_2 0x05CB
+#endif
+
 enum dce112_clk_src_array_id {
 	DCE112_CLK_SRC_PLL0,
 	DCE112_CLK_SRC_PLL1,
@@ -205,6 +209,14 @@ static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 		.LVTMA_PWRSEQ_STATE = mmLVTMA_PWRSEQ_STATE
 };
 
+static const struct dce110_link_enc_dmcu_registers link_enc_dmcu_regs = {
+		.BL1_PWM_USER_LEVEL = mmBL1_PWM_USER_LEVEL,
+		.MASTER_COMM_DATA_REG1 = mmMASTER_COMM_DATA_REG1,
+		.MASTER_COMM_CMD_REG = mmMASTER_COMM_CMD_REG,
+		.MASTER_COMM_CNTL_REG = mmMASTER_COMM_CNTL_REG,
+		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2
+};
+
 #define aux_regs(id)\
 [id] = {\
 	.AUX_CONTROL = mmDP_AUX ## id ## _AUX_CONTROL,\
@@ -446,7 +458,8 @@ struct link_encoder *dce112_link_encoder_create(
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
 			&link_enc_aux_regs[enc_init_data->channel - 1],
-			&link_enc_bl_regs))
+			&link_enc_bl_regs,
+			&link_enc_dmcu_regs))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
index b65257e..1be8853 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
@@ -206,7 +206,8 @@ static const struct link_encoder_funcs dce80_lnk_enc_funcs = {
 	.dp_set_phy_pattern = dce110_link_encoder_dp_set_phy_pattern,
 	.update_mst_stream_allocation_table =
 		dce110_link_encoder_update_mst_stream_allocation_table,
-	.set_lcd_backlight_level = dce110_link_encoder_set_lcd_backlight_level,
+	.set_dmcu_backlight_level =
+		dce110_link_encoder_set_dmcu_backlight_level,
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services.h b/drivers/gpu/drm/amd/dal/dc/dm_services.h
index 02dfc75..23803f6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services.h
@@ -313,6 +313,13 @@ bool dm_read_persistent_data(struct dc_context *ctx,
 		unsigned int size,
 		struct persistent_data_flag *flag);
 
+void dm_delay_in_microseconds
+	(struct dc_context *ctx, unsigned int microSeconds);
+
+bool dm_query_extended_brightness_caps
+	(struct dc_context *ctx, enum dm_acpi_display_type display,
+			struct dm_acpi_atif_backlight_caps *pCaps);
+
 /*
  *
  * print-out services
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
index fbdecd7..61d59c6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
@@ -156,4 +156,41 @@ struct dm_pp_display_configuration {
 	uint32_t line_time_in_us;
 };
 
+struct dm_bl_data_point {
+		/* Brightness level in percentage */
+		uint8_t luminance;
+		/* Brightness level as effective value in range 0-255,
+		 * corresponding to above percentage
+		 */
+		uint8_t signalLevel;
+};
+
+/* Total size of the structure should not exceed 256 bytes */
+struct dm_acpi_atif_backlight_caps {
+
+
+	uint16_t size; /* Bytes 0-1 (2 bytes) */
+	uint16_t flags; /* Byted 2-3 (2 bytes) */
+	uint8_t  errorCode; /* Byte 4 */
+	uint8_t  acLevelPercentage; /* Byte 5 */
+	uint8_t  dcLevelPercentage; /* Byte 6 */
+	uint8_t  minInputSignal; /* Byte 7 */
+	uint8_t  maxInputSignal; /* Byte 8 */
+	uint8_t  numOfDataPoints; /* Byte 9 */
+	struct dm_bl_data_point dataPoints[99]; /* Bytes 10-207 (198 bytes)*/
+};
+
+enum dm_acpi_display_type {
+	AcpiDisplayType_LCD1 = 0,
+	AcpiDisplayType_CRT1 = 1,
+	AcpiDisplayType_DFP1 = 3,
+	AcpiDisplayType_CRT2 = 4,
+	AcpiDisplayType_LCD2 = 5,
+	AcpiDisplayType_DFP2 = 7,
+	AcpiDisplayType_DFP3 = 9,
+	AcpiDisplayType_DFP4 = 10,
+	AcpiDisplayType_DFP5 = 11,
+	AcpiDisplayType_DFP6 = 12
+};
+
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
index 6db68b9..159f6b5 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
@@ -108,8 +108,8 @@ struct link_encoder_funcs {
 	void (*update_mst_stream_allocation_table)(
 		struct link_encoder *enc,
 		const struct link_mst_stream_allocation_table *table);
-	void (*set_lcd_backlight_level) (struct link_encoder *enc,
-		uint32_t level);
+	void (*set_dmcu_backlight_level)(struct link_encoder *enc,
+		uint32_t level, uint32_t frame_ramp);
 	void (*backlight_control) (struct link_encoder *enc,
 		bool enable);
 	void (*power_control) (struct link_encoder *enc,
diff --git a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c
index 68ad503..55c4259 100644
--- a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.c
@@ -74,9 +74,10 @@ static void virtual_link_encoder_update_mst_stream_allocation_table(
 	struct link_encoder *enc,
 	const struct link_mst_stream_allocation_table *table) {}
 
-static void virtual_link_encoder_set_lcd_backlight_level(
+static void virtual_link_encoder_set_dmcu_backlight_level(
 	struct link_encoder *enc,
-	uint32_t level) {}
+	uint32_t level,
+	uint32_t frame_ramp) {}
 
 static void virtual_link_encoder_edp_backlight_control(
 	struct link_encoder *enc,
@@ -111,7 +112,8 @@ static const struct link_encoder_funcs virtual_lnk_enc_funcs = {
 	.dp_set_phy_pattern = virtual_link_encoder_dp_set_phy_pattern,
 	.update_mst_stream_allocation_table =
 		virtual_link_encoder_update_mst_stream_allocation_table,
-	.set_lcd_backlight_level = virtual_link_encoder_set_lcd_backlight_level,
+	.set_dmcu_backlight_level =
+			virtual_link_encoder_set_dmcu_backlight_level,
 	.backlight_control = virtual_link_encoder_edp_backlight_control,
 	.power_control = virtual_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = virtual_link_encoder_connect_dig_be_to_fe,
diff --git a/drivers/gpu/drm/amd/dal/modules/backlight/backlight.c b/drivers/gpu/drm/amd/dal/modules/backlight/backlight.c
new file mode 100644
index 0000000..e15b02d
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/modules/backlight/backlight.c
@@ -0,0 +1,565 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dc.h"
+#include "mod_backlight.h"
+#include "core_types.h"
+#include "core_dc.h"
+
+#define MOD_BACKLIGHT_MAX_CONCURRENT_SINKS 32
+#define SMOOTH_BRIGHTNESS_ADJUSTMENT_TIME_IN_MS 500
+
+struct sink_caps {
+	const struct dc_sink *sink;
+};
+
+struct backlight_state {
+	unsigned int backlight;
+	unsigned int abm_level;
+	unsigned int frame_ramp;
+	bool smooth_brightness_enabled;
+};
+
+struct core_backlight {
+	struct mod_backlight public;
+	struct dc *dc;
+	int num_sinks;
+	struct sink_caps *caps;
+	struct backlight_state *state;
+};
+
+union dmcu_abm_set_bl_params {
+	struct {
+		unsigned int gradual_change : 1; /* [0:0] */
+		unsigned int reserved : 15; /* [15:1] */
+		unsigned int frame_ramp : 16; /* [31:16] */
+	} bits;
+	unsigned int u32All;
+};
+
+/* Backlight cached properties */
+static unsigned int backlight_8bit_lut_array[101];
+static unsigned int ac_level_percentage;
+static unsigned int dc_level_percentage;
+static bool  backlight_caps_valid;
+/* we use lazy initialization of backlight capabilities cache */
+static bool backlight_caps_initialized;
+/* AC/DC levels initialized later in separate context */
+static bool  backlight_def_levels_valid;
+
+
+/* Defines default backlight curve F(x) = A(x*x) + Bx + C.
+ *
+ * Backlight curve should always  satisfy F(0) = min, F(100) = max,
+ * so polynom coefficients are:
+ * A is 0.0255 - B/100 - min/10000 - (255-max)/10000 = (max - min)/10000 - B/100
+ * B is adjustable factor to modify the curve.
+ * Bigger B results in less concave curve. B range is [0..(max-min)/100]
+ * C is backlight minimum
+ */
+static const unsigned int backlight_curve_coeff_a_factor = 10000;
+static const unsigned int backlight_curve_coeff_b        = 100;
+static const unsigned int backlight_curve_coeff_b_factor = 100;
+
+/* Minimum and maximum backlight input signal levels */
+static const unsigned int default_min_backlight          = 12;
+static const unsigned int default_max_backlight          = 255;
+
+/* Other backlight constants */
+static const unsigned int absolute_backlight_max         = 255;
+
+#define MOD_BACKLIGHT_TO_CORE(mod_backlight)\
+		container_of(mod_backlight, struct core_backlight, public)
+
+static bool check_dc_support(const struct dc *dc)
+{
+	if (dc->stream_funcs.set_backlight == NULL)
+		return false;
+
+	return true;
+}
+
+/* Given a specific dc_sink* this function finds its equivalent
+ * on the dc_sink array and returns the corresponding index
+ */
+static unsigned int sink_index_from_sink(struct core_backlight *core_backlight,
+		const struct dc_sink *sink)
+{
+	unsigned int index = 0;
+
+	for (index = 0; index < core_backlight->num_sinks; index++)
+		if (core_backlight->caps[index].sink == sink)
+			return index;
+
+	/* Could not find sink requested */
+	ASSERT(false);
+	return index;
+}
+
+static unsigned int convertBL8to17(unsigned int backlight_8bit)
+{
+	unsigned int temp_ulong = backlight_8bit * 0x10101;
+	unsigned char temp_uchar =
+			(unsigned char)(((temp_ulong & 0x80) >> 7) & 1);
+
+	temp_ulong = (temp_ulong >> 8) + temp_uchar;
+
+	return temp_ulong;
+}
+
+static uint16_t convertBL8to16(unsigned int backlight_8bit)
+{
+	return (uint16_t)((backlight_8bit * 0x10101) >> 8);
+}
+
+/*This is used when OS wants to retrieve the current BL.
+ * We return the 8bit value to OS.
+ */
+static unsigned int convertBL17to8(unsigned int backlight_17bit)
+{
+	if (backlight_17bit & 0x10000)
+		return default_max_backlight;
+	else
+		return (backlight_17bit >> 8);
+}
+
+struct mod_backlight *mod_backlight_create(struct dc *dc)
+{
+	struct core_backlight *core_backlight =
+			dm_alloc(sizeof(struct core_backlight));
+
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	int i = 0;
+
+	if (core_backlight == NULL)
+		goto fail_alloc_context;
+
+	core_backlight->caps = dm_alloc(sizeof(struct sink_caps) *
+			MOD_BACKLIGHT_MAX_CONCURRENT_SINKS);
+
+	if (core_backlight->caps == NULL)
+		goto fail_alloc_caps;
+
+	for (i = 0; i < MOD_BACKLIGHT_MAX_CONCURRENT_SINKS; i++)
+		core_backlight->caps[i].sink = NULL;
+
+	core_backlight->state = dm_alloc(sizeof(struct backlight_state) *
+				MOD_BACKLIGHT_MAX_CONCURRENT_SINKS);
+
+	if (core_backlight->state == NULL)
+		goto fail_alloc_state;
+
+	core_backlight->num_sinks = 0;
+
+	if (dc == NULL)
+		goto fail_construct;
+
+	core_backlight->dc = dc;
+
+	if (!check_dc_support(dc))
+		goto fail_construct;
+
+	return &core_backlight->public;
+
+fail_construct:
+	dm_free(core_backlight->state);
+
+fail_alloc_state:
+	dm_free(core_backlight->caps);
+
+fail_alloc_caps:
+	dm_free(core_backlight);
+
+fail_alloc_context:
+	return NULL;
+}
+
+
+void mod_backlight_destroy(struct mod_backlight *mod_backlight)
+{
+	if (mod_backlight != NULL) {
+		int i;
+		struct core_backlight *core_backlight =
+				MOD_BACKLIGHT_TO_CORE(mod_backlight);
+
+		dm_free(core_backlight->state);
+
+		for (i = 0; i < core_backlight->num_sinks; i++)
+			dc_sink_release(core_backlight->caps[i].sink);
+
+		dm_free(core_backlight->caps);
+
+		dm_free(core_backlight);
+	}
+}
+
+bool mod_backlight_add_sink(struct mod_backlight *mod_backlight,
+						const struct dc_sink *sink)
+{
+	struct core_backlight *core_backlight =
+				MOD_BACKLIGHT_TO_CORE(mod_backlight);
+	struct core_dc *core_dc = DC_TO_CORE(core_backlight->dc);
+
+	if (core_backlight->num_sinks < MOD_BACKLIGHT_MAX_CONCURRENT_SINKS) {
+		dc_sink_retain(sink);
+		core_backlight->caps[core_backlight->num_sinks].sink = sink;
+		core_backlight->state[core_backlight->num_sinks].
+					smooth_brightness_enabled = false;
+		core_backlight->num_sinks++;
+		return true;
+	}
+
+	return false;
+}
+
+bool mod_backlight_remove_sink(struct mod_backlight *mod_backlight,
+		const struct dc_sink *sink)
+{
+	int i = 0, j = 0;
+	struct core_backlight *core_backlight =
+			MOD_BACKLIGHT_TO_CORE(mod_backlight);
+
+	for (i = 0; i < core_backlight->num_sinks; i++) {
+		if (core_backlight->caps[i].sink == sink) {
+			/* To remove this sink, shift everything after down */
+			for (j = i; j < core_backlight->num_sinks - 1; j++) {
+				core_backlight->caps[j].sink =
+					core_backlight->caps[j + 1].sink;
+
+				memcpy(&core_backlight->state[j],
+					&core_backlight->state[j + 1],
+					sizeof(struct backlight_state));
+			}
+			core_backlight->num_sinks--;
+			dc_sink_release(sink);
+			return true;
+		}
+	}
+	return false;
+}
+
+bool mod_backlight_set_backlight(struct mod_backlight *mod_backlight,
+		const struct dc_stream **streams, int num_streams,
+		unsigned int backlight_8bit)
+{
+	struct core_backlight *core_backlight =
+			MOD_BACKLIGHT_TO_CORE(mod_backlight);
+
+	unsigned int frame_ramp = 0;
+
+	unsigned int stream_index, sink_index, vsync_rate_hz;
+
+	union dmcu_abm_set_bl_params params;
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+		sink_index = sink_index_from_sink(core_backlight,
+				streams[stream_index]->sink);
+
+		vsync_rate_hz = div64_u64(div64_u64((streams[stream_index]->
+				timing.pix_clk_khz * 1000),
+				streams[stream_index]->timing.v_total),
+				streams[stream_index]->timing.h_total);
+
+		core_backlight->state[sink_index].backlight = backlight_8bit;
+
+		if (core_backlight->state[sink_index].smooth_brightness_enabled)
+			frame_ramp = ((vsync_rate_hz *
+				SMOOTH_BRIGHTNESS_ADJUSTMENT_TIME_IN_MS) + 500)
+				/ 1000;
+		else
+			frame_ramp = 0;
+
+		core_backlight->state[sink_index].frame_ramp = frame_ramp;
+	}
+
+	params.u32All = 0;
+	params.bits.gradual_change = (frame_ramp > 0);
+	params.bits.frame_ramp = frame_ramp;
+
+	core_backlight->dc->stream_funcs.set_backlight
+		(core_backlight->dc, backlight_8bit, params.u32All);
+
+	return true;
+}
+
+bool mod_backlight_get_backlight(struct mod_backlight *mod_backlight,
+		const struct dc_sink *sink,
+		unsigned int *backlight_8bit)
+{
+	struct core_backlight *core_backlight =
+				MOD_BACKLIGHT_TO_CORE(mod_backlight);
+
+	unsigned int sink_index = sink_index_from_sink(core_backlight, sink);
+
+	*backlight_8bit = core_backlight->state[sink_index].backlight;
+
+	return true;
+}
+
+/* hard coded to default backlight curve. */
+void mod_backlight_initialize_backlight_caps(struct mod_backlight
+							*mod_backlight)
+{
+	struct core_backlight *core_backlight =
+			MOD_BACKLIGHT_TO_CORE(mod_backlight);
+	struct core_dc *core_dc = DC_TO_CORE(core_backlight->dc);
+	unsigned int i;
+
+	backlight_caps_initialized = true;
+
+	struct dm_acpi_atif_backlight_caps *pExtCaps = NULL;
+	bool customCurvePresent = false;
+	bool customMinMaxPresent = false;
+	bool customDefLevelsPresent = false;
+
+	/* Allocate memory for ATIF output
+	 * (do not want to use 256 bytes on the stack)
+	 */
+	pExtCaps = (struct dm_acpi_atif_backlight_caps *)
+			(dm_alloc(sizeof(struct dm_acpi_atif_backlight_caps)));
+	if (pExtCaps == NULL)
+		return;
+
+	/* Retrieve ACPI extended brightness caps */
+	if (dm_query_extended_brightness_caps
+			(core_dc->ctx, AcpiDisplayType_LCD1, pExtCaps)) {
+		ac_level_percentage    = pExtCaps->acLevelPercentage;
+		dc_level_percentage    = pExtCaps->dcLevelPercentage;
+		customMinMaxPresent    = true;
+		customDefLevelsPresent = true;
+		customCurvePresent     = (pExtCaps->numOfDataPoints > 0);
+
+		ASSERT(pExtCaps->numOfDataPoints <= 99);
+	}
+
+	if (customMinMaxPresent)
+		backlight_8bit_lut_array[0] = pExtCaps->minInputSignal;
+	else
+		backlight_8bit_lut_array[0] = default_min_backlight;
+
+	if (customMinMaxPresent)
+		backlight_8bit_lut_array[100] = pExtCaps->maxInputSignal;
+	else
+		backlight_8bit_lut_array[100] = default_max_backlight;
+
+	ASSERT(backlight_8bit_lut_array[100] <= absolute_backlight_max);
+	ASSERT(backlight_8bit_lut_array[0] <=
+					backlight_8bit_lut_array[100]);
+
+	/* Just to make sure we use valid values */
+	if (backlight_8bit_lut_array[100] > absolute_backlight_max)
+		backlight_8bit_lut_array[100] = absolute_backlight_max;
+	if (backlight_8bit_lut_array[0] > backlight_8bit_lut_array[100]) {
+		unsigned int swap;
+
+		swap = backlight_8bit_lut_array[0];
+		backlight_8bit_lut_array[0] = backlight_8bit_lut_array[100];
+		backlight_8bit_lut_array[100] = swap;
+	}
+
+	/* Build backlight translation table for custom curve */
+	if (customCurvePresent) {
+		unsigned int index = 1;
+		unsigned int numOfDataPoints =
+				(pExtCaps->numOfDataPoints <= 99 ?
+						pExtCaps->numOfDataPoints : 99);
+
+		/* Filling translation table from data points -
+		 * between every two provided data points we
+		 * lineary interpolate missing values
+		 */
+		for (i = 0; i < numOfDataPoints; i++) {
+			/* Clamp signal level between min and max
+			 * (since min and max might come other
+			 * soruce like registry)
+			 */
+			unsigned int luminance =
+					pExtCaps->dataPoints[i].luminance;
+			unsigned int signalLevel =
+					pExtCaps->dataPoints[i].signalLevel;
+
+			if (signalLevel < backlight_8bit_lut_array[0])
+				signalLevel = backlight_8bit_lut_array[0];
+			if (signalLevel > backlight_8bit_lut_array[100])
+				signalLevel = backlight_8bit_lut_array[100];
+
+			/* Lineary interpolate missing values */
+			if (index < luminance) {
+				unsigned int baseValue =
+					backlight_8bit_lut_array[index-1];
+				unsigned int deltaSignal =
+					signalLevel - baseValue;
+				unsigned int deltaLuma =
+					luminance - index + 1;
+				unsigned int step  = deltaSignal;
+
+				for (; index < luminance; index++) {
+					backlight_8bit_lut_array[index] =
+						baseValue + (step / deltaLuma);
+					step += deltaSignal;
+				}
+			}
+
+			/* Now [index == luminance],
+			 * so we can add data point to the translation table
+			 */
+			backlight_8bit_lut_array[index++] = signalLevel;
+		}
+
+		/* Complete the final segment of interpolation -
+		 * between last datapoint and maximum value
+		 */
+		if (index < 100) {
+			unsigned int baseValue =
+					backlight_8bit_lut_array[index-1];
+			unsigned int deltaSignal =
+					backlight_8bit_lut_array[100] -
+								baseValue;
+			unsigned int deltaLuma = 100 - index + 1;
+			unsigned int step = deltaSignal;
+
+			for (; index < 100; index++) {
+				backlight_8bit_lut_array[index] =
+						baseValue + (step / deltaLuma);
+				step += deltaSignal;
+			}
+		}
+	/* Build backlight translation table based on default curve */
+	} else {
+		unsigned int delta =
+				backlight_8bit_lut_array[100] -
+					backlight_8bit_lut_array[0];
+		unsigned int coeffC = backlight_8bit_lut_array[0];
+		unsigned int coeffB =
+				(backlight_curve_coeff_b < delta ?
+					backlight_curve_coeff_b : delta);
+		unsigned int coeffA = delta - coeffB; /* coeffB is B*100 */
+
+		for (i = 1; i < 100; i++) {
+			backlight_8bit_lut_array[i] =
+				(coeffA * i * i) /
+				backlight_curve_coeff_a_factor +
+				(coeffB * i) /
+				backlight_curve_coeff_b_factor +
+				coeffC;
+		}
+	}
+
+	if (pExtCaps != NULL)
+		dm_free(pExtCaps);
+
+	/* Successfully initialized */
+	backlight_caps_valid = true;
+	backlight_def_levels_valid = customDefLevelsPresent;
+}
+
+unsigned int mod_backlight_backlight_level_percentage_to_signal(
+		struct mod_backlight *mod_backlight, unsigned int percentage)
+{
+	/* Do lazy initialization of backlight capabilities*/
+	if (!backlight_caps_initialized)
+		mod_backlight_initialize_backlight_caps(mod_backlight);
+
+	/* Since the translation table is indexed by percentage,
+	* we simply return backlight value at given percent
+	*/
+	if (backlight_caps_valid && percentage <= 100)
+		return backlight_8bit_lut_array[percentage];
+
+	return -1;
+}
+
+unsigned int mod_backlight_backlight_level_signal_to_percentage(
+		struct mod_backlight *mod_backlight,
+		unsigned int signalLevel8bit)
+{
+	/* Do lazy initialization of backlight capabilities */
+	if (!backlight_caps_initialized)
+		mod_backlight_initialize_backlight_caps(mod_backlight);
+
+	/* If customer curve cannot convert to differentiated value near min
+	* it is important to report 0 for min signal to pass setting "Dimmed"
+	* setting in HCK brightness2 tests.
+	*/
+	if (signalLevel8bit == backlight_8bit_lut_array[0])
+		return 0;
+
+	/* Since the translation table is indexed by percentage
+	 * we need to do a binary search over the array
+	 * Another option would be to guess entry based on linear distribution
+	 * and then do linear search in correct direction
+	 */
+	if (backlight_caps_valid && signalLevel8bit <=
+					absolute_backlight_max) {
+		unsigned int min = 0;
+		unsigned int max = 100;
+		unsigned int mid = -1;
+
+		while (max >= min) {
+			mid = (min + max) / 2; /* floor of half range */
+
+			if (backlight_8bit_lut_array[mid] < signalLevel8bit)
+				min = mid + 1;
+			else if (backlight_8bit_lut_array[mid] >
+							signalLevel8bit)
+				max = mid - 1;
+			else
+				break;
+		}
+		return mid;
+	}
+
+	return -1;
+}
+
+
+bool mod_backlight_get_panel_backlight_boundaries(
+				struct mod_backlight *mod_backlight,
+				unsigned int *min_backlight,
+				unsigned int *max_backlight,
+				unsigned int *output_ac_level_percentage,
+				unsigned int *output_dc_level_percentage)
+{
+	/* Do lazy initialization of backlight capabilities */
+	if (!backlight_caps_initialized)
+		mod_backlight_initialize_backlight_caps(mod_backlight);
+
+	/* If cache was successfully updated,
+	 * copy the values to output structure and return success
+	 */
+	if (backlight_caps_valid) {
+		*min_backlight = backlight_8bit_lut_array[0];
+		*max_backlight = backlight_8bit_lut_array[100];
+
+		*output_ac_level_percentage = ac_level_percentage;
+		*output_dc_level_percentage = dc_level_percentage;
+
+		return true;
+	}
+
+	return false;
+}
diff --git a/drivers/gpu/drm/amd/dal/modules/inc/mod_backlight.h b/drivers/gpu/drm/amd/dal/modules/inc/mod_backlight.h
new file mode 100644
index 0000000..6bad1d4
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/modules/inc/mod_backlight.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef MODULES_INC_MOD_BACKLIGHT_H_
+#define MODULES_INC_MOD_BACKLIGHT_H_
+
+#include "dm_services.h"
+
+struct mod_backlight {
+	int dummy;
+};
+
+struct mod_backlight *mod_backlight_create(struct dc *dc);
+
+void mod_backlight_destroy(struct mod_backlight *mod_backlight);
+
+bool mod_backlight_add_sink(struct mod_backlight *mod_backlight,
+		const struct dc_sink *sink);
+
+bool mod_backlight_remove_sink(struct mod_backlight *mod_backlight,
+		const struct dc_sink *sink);
+
+bool mod_backlight_set_backlight(struct mod_backlight *mod_backlight,
+		const struct dc_stream **streams, int num_streams,
+		unsigned int backlight_8bit);
+
+bool mod_backlight_get_backlight(struct mod_backlight *mod_backlight,
+		const struct dc_sink *sink,
+		unsigned int *backlight_8bit);
+
+void mod_backlight_initialize_backlight_caps
+		(struct mod_backlight *mod_backlight);
+
+unsigned int mod_backlight_backlight_level_percentage_to_signal
+		(struct mod_backlight *mod_backlight, unsigned int percentage);
+
+unsigned int mod_backlight_backlight_level_signal_to_percentage
+	(struct mod_backlight *mod_backlight, unsigned int signalLevel8bit);
+
+bool mod_backlight_get_panel_backlight_boundaries
+				(struct mod_backlight *mod_backlight,
+				unsigned int *min_backlight,
+				unsigned int *max_backlight,
+				unsigned int *output_ac_level_percentage,
+				unsigned int *output_dc_level_percentage);
+
+#endif /* MODULES_INC_MOD_BACKLIGHT_H_ */
-- 
2.7.4

