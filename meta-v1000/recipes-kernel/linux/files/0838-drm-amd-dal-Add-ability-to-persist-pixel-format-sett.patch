From e91f04520f71e910fd39e595c71e80b918b58e53 Mon Sep 17 00:00:00 2001
From: Wenjing Liu <Wenjing.Liu@amd.com>
Date: Wed, 17 Aug 2016 18:16:20 -0400
Subject: [PATCH 0838/1722] drm/amd/dal: Add ability to persist pixel format
 settings

Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/dc_hw_types.h        |  6 +++
 drivers/gpu/drm/amd/dal/modules/color/color.c   | 60 +++++++++++++++++++++++--
 drivers/gpu/drm/amd/dal/modules/inc/mod_color.h |  6 +++
 3 files changed, 68 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
index ac7fbc0..f6b3c00 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
@@ -396,6 +396,12 @@ enum dc_color_space {
 	COLOR_SPACE_YCBCR709_LIMITED
 };
 
+enum dc_rgb_range {
+	RGB_RANGE_UNKNOWN,
+	RGB_RANGE_FULL,
+	RGB_RANGE_LIMITED
+};
+
 /* XFM */
 
 /* used in  struct dc_surface */
diff --git a/drivers/gpu/drm/amd/dal/modules/color/color.c b/drivers/gpu/drm/amd/dal/modules/color/color.c
index 1e5d270..f4196fb 100644
--- a/drivers/gpu/drm/amd/dal/modules/color/color.c
+++ b/drivers/gpu/drm/amd/dal/modules/color/color.c
@@ -69,6 +69,7 @@ struct color_state {
 	struct color_range saturation;
 	struct color_range brightness;
 	struct color_range hue;
+	enum dc_rgb_range rgb_range;
 };
 
 struct core_color {
@@ -1259,7 +1260,7 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 	int persistent_contrast;
 	int persistent_hue;
 	int persistent_saturation;
-
+	enum dc_rgb_range persistent_rgb_range;
 	struct persistent_data_flag flag;
 
 	if (core_color->num_sinks < MOD_COLOR_MAX_CONCURRENT_SINKS) {
@@ -1273,7 +1274,8 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 		flag.save_per_link = false;
 
 
-		if (dm_read_persistent_data(core_dc->ctx, sink, COLOR_REGISTRY_NAME,
+		if (dm_read_persistent_data(core_dc->ctx, sink,
+						COLOR_REGISTRY_NAME,
 						"enablecolortempadj",
 						&persistent_color_temp_enable,
 						sizeof(bool), &flag))
@@ -1284,7 +1286,8 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 			core_color->state[core_color->num_sinks].
 				user_enable_color_temperature = true;
 
-		if (dm_read_persistent_data(core_dc->ctx, sink, COLOR_REGISTRY_NAME,
+		if (dm_read_persistent_data(core_dc->ctx, sink,
+						COLOR_REGISTRY_NAME,
 						"customcolortemp",
 						&persistent_custom_color_temp,
 						sizeof(int), &flag))
@@ -1295,7 +1298,8 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 			core_color->state[core_color->num_sinks].
 					custom_color_temperature = 6500;
 
-		if (dm_read_persistent_data(core_dc->ctx, sink, COLOR_REGISTRY_NAME,
+		if (dm_read_persistent_data(core_dc->ctx, sink,
+					COLOR_REGISTRY_NAME,
 					"sourcegamut",
 					&persistent_source_gamut,
 					sizeof(struct color_space_coordinates),
@@ -1390,6 +1394,17 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 			core_color->state[core_color->num_sinks].
 				saturation.current = 100;
 
+		if (dm_read_persistent_data(core_dc->ctx, sink,
+						COLOR_REGISTRY_NAME,
+						"rgb_range",
+						&persistent_rgb_range,
+						sizeof(int), &flag))
+			core_color->state[core_color->num_sinks].rgb_range =
+					persistent_rgb_range;
+		else
+			core_color->state[core_color->num_sinks].rgb_range =
+					RGB_RANGE_FULL;
+
 		core_color->num_sinks++;
 		return true;
 	}
@@ -2036,3 +2051,40 @@ bool mod_color_set_saturation(struct mod_color *mod_color,
 	return true;
 }
 
+bool mod_color_set_rgb_range(struct mod_color *mod_color,
+		const struct dc_sink *sink, enum dc_rgb_range rgb_range)
+{
+	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
+	struct core_dc *core_dc = DC_TO_CORE(core_color->dc);
+	struct persistent_data_flag flag;
+	unsigned int sink_index;
+
+	sink_index = sink_index_from_sink(core_color, sink);
+	if (core_color->state[sink_index].
+			rgb_range != rgb_range) {
+		core_color->state[sink_index].rgb_range =
+				rgb_range;
+		flag.save_per_edid = true;
+		flag.save_per_link = false;
+		dm_write_persistent_data(core_dc->ctx,
+					sink,
+					COLOR_REGISTRY_NAME,
+					"rgb_range",
+					&rgb_range,
+					sizeof(int),
+					&flag);
+	}
+
+	return true;
+}
+
+bool mod_color_get_rgb_range(struct mod_color *mod_color,
+		const struct dc_sink *sink, enum dc_rgb_range *rgb_range)
+{
+	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
+	unsigned int sink_index;
+
+	sink_index = sink_index_from_sink(core_color, sink);
+	*rgb_range = core_color->state[sink_index].rgb_range;
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h b/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
index 82881e1..b941160 100644
--- a/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
+++ b/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
@@ -168,4 +168,10 @@ bool mod_color_set_saturation(struct mod_color *mod_color,
 		const struct dc_stream **streams, int num_streams,
 		int saturation_value);
 
+bool mod_color_set_rgb_range(struct mod_color *mod_color,
+		const struct dc_sink *sink, enum dc_rgb_range rgb_range);
+
+bool mod_color_get_rgb_range(struct mod_color *mod_color,
+		const struct dc_sink *sink, enum dc_rgb_range *rgb_range);
+
 #endif /* MOD_COLOR_H_ */
-- 
2.7.4

