From 60a4a49d8cbf72fc7e3c7b88ffe993eca55f2fa0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 26 Jun 2015 21:58:17 +0200
Subject: [PATCH 50/67] drm/amdgpu: allow passing absolute timeouts to
 amdgpu_cs_query_fence_status

Useful when Mesa wants to wait for a lot of fences at the same time and
doesn't want to recalculate the relative timeout after every call.

Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Arindam Nath <arindam.nath@amd.com>
---
 amdgpu/amdgpu.h    |  7 ++++++-
 amdgpu/amdgpu_cs.c | 10 ++++++++--
 2 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/amdgpu/amdgpu.h b/amdgpu/amdgpu.h
index daeebbe..9d16430 100644
--- a/amdgpu/amdgpu.h
+++ b/amdgpu/amdgpu.h
@@ -52,10 +52,15 @@ struct drm_amdgpu_info_hw_ip;
 #define AMDGPU_CS_MAX_IBS_PER_SUBMIT		4
 
 /**
- *
+ * Special timeout value meaning that the timeout is infinite.
  */
 #define AMDGPU_TIMEOUT_INFINITE			0xffffffffffffffffull
 
+/**
+ * Used in amdgpu_cs_query_fence::flags, meaning that the given timeout
+ * is absolute.
+ */
+#define AMDGPU_QUERY_FENCE_TIMEOUT_IS_ABSOLUTE     (1 << 0)
 
 /*--------------------------------------------------------------------------*/
 /* ----------------------------- Enums ------------------------------------ */
diff --git a/amdgpu/amdgpu_cs.c b/amdgpu/amdgpu_cs.c
index 5a24708..b3f5170 100644
--- a/amdgpu/amdgpu_cs.c
+++ b/amdgpu/amdgpu_cs.c
@@ -348,6 +348,7 @@ static int amdgpu_ioctl_wait_cs(amdgpu_context_handle context,
 				uint32_t ring,
 				uint64_t handle,
 				uint64_t timeout_ns,
+				uint64_t flags,
 				bool *busy)
 {
 	amdgpu_device_handle dev = context->dev;
@@ -359,9 +360,13 @@ static int amdgpu_ioctl_wait_cs(amdgpu_context_handle context,
 	args.in.ip_type = ip;
 	args.in.ip_instance = ip_instance;
 	args.in.ring = ring;
-	args.in.timeout = amdgpu_cs_calculate_timeout(timeout_ns);
 	args.in.ctx_id = context->id;
 
+	if (flags & AMDGPU_QUERY_FENCE_TIMEOUT_IS_ABSOLUTE)
+		args.in.timeout = timeout_ns;
+	else
+		args.in.timeout = amdgpu_cs_calculate_timeout(timeout_ns);
+
 	/* Handle errors manually here because of timeout */
 	r = ioctl(dev->fd, DRM_IOCTL_AMDGPU_WAIT_CS, &args);
 	if (r == -1 && (errno == EINTR || errno == EAGAIN)) {
@@ -429,7 +434,8 @@ int amdgpu_cs_query_fence_status(struct amdgpu_cs_query_fence *fence,
 	pthread_mutex_unlock(&context->sequence_mutex);
 
 	r = amdgpu_ioctl_wait_cs(context, ip_type, ip_instance, ring,
-				 fence->fence, fence->timeout_ns, &busy);
+				 fence->fence, fence->timeout_ns,
+				 fence->flags, &busy);
 	if (!r && !busy) {
 		*expired = true;
 		pthread_mutex_lock(&context->sequence_mutex);
-- 
1.9.1

