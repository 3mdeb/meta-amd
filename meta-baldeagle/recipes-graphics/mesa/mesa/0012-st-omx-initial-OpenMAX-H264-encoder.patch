From f510a59f3984a5bc2024911c2b509f119aa0b188 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Mon, 5 Aug 2013 11:41:27 -0600
Subject: [PATCH 12/27] st/omx: initial OpenMAX H264 encoder
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Christian König <christian.koenig@amd.com>
Signed-off-by: Leo Liu <leo.liu@amd.com>
---
 src/gallium/state_trackers/omx/Makefile.am  |    3 +-
 src/gallium/state_trackers/omx/entrypoint.c |    9 +-
 src/gallium/state_trackers/omx/vid_dec.c    |   15 +-
 src/gallium/state_trackers/omx/vid_enc.c    |  739 +++++++++++++++++++++++++++
 src/gallium/state_trackers/omx/vid_enc.h    |   71 +++
 5 files changed, 829 insertions(+), 8 deletions(-)
 create mode 100644 src/gallium/state_trackers/omx/vid_enc.c
 create mode 100644 src/gallium/state_trackers/omx/vid_enc.h

diff --git a/src/gallium/state_trackers/omx/Makefile.am b/src/gallium/state_trackers/omx/Makefile.am
index 1983248..53839d9 100644
--- a/src/gallium/state_trackers/omx/Makefile.am
+++ b/src/gallium/state_trackers/omx/Makefile.am
@@ -32,4 +32,5 @@ libomxtracker_la_SOURCES = \
 	entrypoint.c \
 	vid_dec.c \
 	vid_dec_mpeg12.c \
-	vid_dec_h264.c
+	vid_dec_h264.c \
+	vid_enc.c
diff --git a/src/gallium/state_trackers/omx/entrypoint.c b/src/gallium/state_trackers/omx/entrypoint.c
index bc8664b..c67b8c9 100644
--- a/src/gallium/state_trackers/omx/entrypoint.c
+++ b/src/gallium/state_trackers/omx/entrypoint.c
@@ -41,6 +41,7 @@
 
 #include "entrypoint.h"
 #include "vid_dec.h"
+#include "vid_enc.h"
 
 pipe_static_mutex(omx_lock);
 static Display *omx_display = NULL;
@@ -52,13 +53,17 @@ int omx_component_library_Setup(stLoaderComponentType **stComponents)
    OMX_ERRORTYPE r;
 
    if (stComponents == NULL)
-      return 1;
+      return 2;
 
    r = vid_dec_LoaderComponent(stComponents[0]);
    if (r != OMX_ErrorNone)
       return r;
 
-   return 1;
+   r = vid_enc_LoaderComponent(stComponents[1]);
+   if (r != OMX_ErrorNone)
+      return r;
+
+   return 2;
 }
 
 struct vl_screen *omx_get_screen(void)
diff --git a/src/gallium/state_trackers/omx/vid_dec.c b/src/gallium/state_trackers/omx/vid_dec.c
index 7be1dad..b8b519e 100644
--- a/src/gallium/state_trackers/omx/vid_dec.c
+++ b/src/gallium/state_trackers/omx/vid_dec.c
@@ -534,7 +534,6 @@ static void vid_dec_FillOutput(vid_dec_PrivateType *priv, struct pipe_video_buff
    struct pipe_sampler_view **views;
    struct pipe_transfer *transfer;
    struct pipe_box box = { };
-
    uint8_t *src, *dst;
 
    views = buf->get_sampler_view_planes(buf);
@@ -561,8 +560,6 @@ static void vid_dec_FillOutput(vid_dec_PrivateType *priv, struct pipe_video_buff
    util_copy_rect(dst, views[1]->texture->format, def->nStride, 0, 0,
                   box.width, box.height, src, transfer->stride, 0, 0);
    pipe_transfer_unmap(priv->pipe, transfer);
-
-   output->nFilledLen = output->nAllocLen;
 }
 
 static void vid_dec_FrameDecoded(OMX_COMPONENTTYPE *comp, OMX_BUFFERHEADERTYPE* input,
@@ -574,8 +571,16 @@ static void vid_dec_FrameDecoded(OMX_COMPONENTTYPE *comp, OMX_BUFFERHEADERTYPE*
    if (!input->pInputPortPrivate)
       input->pInputPortPrivate = priv->Flush(priv);
 
-   if (input->pInputPortPrivate)
-      vid_dec_FillOutput(priv, input->pInputPortPrivate, output);
+   if (input->pInputPortPrivate) {
+      if (output->pInputPortPrivate) {
+         struct pipe_video_buffer *tmp = output->pOutputPortPrivate;
+         output->pOutputPortPrivate = input->pInputPortPrivate;
+         input->pInputPortPrivate = tmp;
+      } else {
+         vid_dec_FillOutput(priv, input->pInputPortPrivate, output);
+      }
+      output->nFilledLen = output->nAllocLen;
+   }
 
    if (eos && input->pInputPortPrivate)
       vid_dec_FreeInputPortPrivate(input);
diff --git a/src/gallium/state_trackers/omx/vid_enc.c b/src/gallium/state_trackers/omx/vid_enc.c
new file mode 100644
index 0000000..926d29c
--- /dev/null
+++ b/src/gallium/state_trackers/omx/vid_enc.c
@@ -0,0 +1,739 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+/*
+ * Authors:
+ *      Christian König <christian.koenig@amd.com>
+ *
+ */
+
+
+#include <assert.h>
+
+#include <OMX_Video.h>
+
+/* bellagio defines a DEBUG macro that we don't want */
+#ifndef DEBUG
+#include <bellagio/omxcore.h>
+#undef DEBUG
+#else
+#include <bellagio/omxcore.h>
+#endif
+
+#include <bellagio/omx_base_video_port.h>
+
+#include "pipe/p_screen.h"
+#include "pipe/p_video_codec.h"
+#include "state_tracker/drm_driver.h"
+#include "util/u_memory.h"
+
+#include "entrypoint.h"
+#include "vid_enc.h"
+
+struct input_buf_private {
+   struct pipe_video_buffer *buf;
+   struct pipe_resource *bitstream;
+   void *feedback;
+};
+
+struct output_buf_private {
+   struct pipe_resource *bitstream;
+   struct pipe_transfer *transfer;
+};
+
+static OMX_ERRORTYPE vid_enc_Constructor(OMX_COMPONENTTYPE *comp, OMX_STRING name);
+static OMX_ERRORTYPE vid_enc_Destructor(OMX_COMPONENTTYPE *comp);
+static OMX_ERRORTYPE vid_enc_SetParameter(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR param);
+static OMX_ERRORTYPE vid_enc_GetParameter(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR param);
+static OMX_ERRORTYPE vid_enc_SetConfig(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR config);
+static OMX_ERRORTYPE vid_enc_GetConfig(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR config);
+static OMX_ERRORTYPE vid_enc_MessageHandler(OMX_COMPONENTTYPE *comp, internalRequestMessageType *msg);
+static OMX_ERRORTYPE vid_enc_AllocateInBuffer(omx_base_PortType *port, OMX_INOUT OMX_BUFFERHEADERTYPE **buf,
+                                              OMX_IN OMX_U32 idx, OMX_IN OMX_PTR private, OMX_IN OMX_U32 size);
+static OMX_ERRORTYPE vid_enc_UseInBuffer(omx_base_PortType *port, OMX_BUFFERHEADERTYPE **buf, OMX_U32 idx,
+                                         OMX_PTR private, OMX_U32 size, OMX_U8 *mem);
+static OMX_ERRORTYPE vid_enc_FreeInBuffer(omx_base_PortType *port, OMX_U32 idx, OMX_BUFFERHEADERTYPE *buf);
+static OMX_ERRORTYPE vid_enc_EncodeFrame(omx_base_PortType *port, OMX_BUFFERHEADERTYPE *buf);
+static OMX_ERRORTYPE vid_enc_AllocateOutBuffer(omx_base_PortType *comp, OMX_INOUT OMX_BUFFERHEADERTYPE **buf,
+                                               OMX_IN OMX_U32 idx, OMX_IN OMX_PTR private, OMX_IN OMX_U32 size);
+static OMX_ERRORTYPE vid_enc_FreeOutBuffer(omx_base_PortType *port, OMX_U32 idx, OMX_BUFFERHEADERTYPE *buf);
+static void vid_enc_BufferEncoded(OMX_COMPONENTTYPE *comp, OMX_BUFFERHEADERTYPE* input, OMX_BUFFERHEADERTYPE* output);
+
+static void vid_enc_name(char str[OMX_MAX_STRINGNAME_SIZE])
+{
+   snprintf(str, OMX_MAX_STRINGNAME_SIZE, OMX_VID_ENC_BASE_NAME, driver_descriptor.name);
+}
+
+static void vid_enc_name_avc(char str[OMX_MAX_STRINGNAME_SIZE])
+{
+   snprintf(str, OMX_MAX_STRINGNAME_SIZE, OMX_VID_ENC_AVC_NAME, driver_descriptor.name);
+}
+
+OMX_ERRORTYPE vid_enc_LoaderComponent(stLoaderComponentType *comp)
+{
+   /* component 1 - video encoder */
+   comp->componentVersion.s.nVersionMajor = 0;
+   comp->componentVersion.s.nVersionMinor = 0;
+   comp->componentVersion.s.nRevision = 0;
+   comp->componentVersion.s.nStep = 1;
+   comp->name_specific_length = 1;
+
+   comp->name = CALLOC(1, OMX_MAX_STRINGNAME_SIZE);
+   if (comp->name == NULL)
+      goto error;
+
+   comp->name_specific = CALLOC(comp->name_specific_length, sizeof(char *));
+   if (comp->name_specific == NULL)
+      goto error;
+
+   comp->name_specific[0] = CALLOC(1, OMX_MAX_STRINGNAME_SIZE);
+   if (comp->name_specific[0] == NULL)
+      goto error;
+
+   comp->role_specific = CALLOC(comp->name_specific_length, sizeof(char *));
+   if (comp->role_specific == NULL)
+      goto error;
+
+   comp->role_specific[0] = CALLOC(1, OMX_MAX_STRINGNAME_SIZE);
+   if (comp->role_specific[0] == NULL)
+      goto error;
+
+   vid_enc_name(comp->name);
+   vid_enc_name_avc(comp->name_specific[0]);
+
+   strcpy(comp->role_specific[0], OMX_VID_ENC_AVC_ROLE);
+
+   comp->constructor = vid_enc_Constructor;
+
+   return 2;
+
+error:
+   FREE(comp->name);
+
+   if (comp->name_specific) {
+      FREE(comp->name_specific[0]);
+      FREE(comp->name_specific);
+   }
+
+   if (comp->role_specific) {
+      FREE(comp->role_specific[0]);
+      FREE(comp->role_specific);
+   }
+
+   return OMX_ErrorInsufficientResources;
+}
+
+static OMX_ERRORTYPE vid_enc_Constructor(OMX_COMPONENTTYPE *comp, OMX_STRING name)
+{
+   vid_enc_PrivateType *priv;
+   omx_base_video_PortType *port;
+   struct pipe_screen *screen;
+   OMX_ERRORTYPE r;
+   int i;
+
+   assert(!comp->pComponentPrivate);
+
+   priv = comp->pComponentPrivate = CALLOC(1, sizeof(vid_enc_PrivateType));
+   if (!priv)
+      return OMX_ErrorInsufficientResources;
+
+   r = omx_base_filter_Constructor(comp, name);
+   if (r)
+	return r;
+
+   priv->BufferMgmtCallback = vid_enc_BufferEncoded;
+   priv->messageHandler = vid_enc_MessageHandler;
+   priv->destructor = vid_enc_Destructor;
+
+   comp->SetParameter = vid_enc_SetParameter;
+   comp->GetParameter = vid_enc_GetParameter;
+   comp->GetConfig = vid_enc_GetConfig;
+   comp->SetConfig = vid_enc_SetConfig;
+
+   priv->screen = omx_get_screen();
+   if (!priv->screen)
+      return OMX_ErrorInsufficientResources;
+
+   screen = priv->screen->pscreen;
+   priv->pipe = screen->context_create(screen, priv->screen);
+   if (!priv->pipe)
+      return OMX_ErrorInsufficientResources;
+
+   priv->sPortTypesParam[OMX_PortDomainVideo].nStartPortNumber = 0;
+   priv->sPortTypesParam[OMX_PortDomainVideo].nPorts = 2;
+   priv->ports = CALLOC(2, sizeof(omx_base_PortType *));
+   if (!priv->ports)
+      return OMX_ErrorInsufficientResources;
+
+   for (i = 0; i < 2; ++i) {
+      priv->ports[i] = CALLOC(1, sizeof(omx_base_video_PortType));
+      if (!priv->ports[i])
+         return OMX_ErrorInsufficientResources;
+
+      base_video_port_Constructor(comp, &priv->ports[i], i, i == 0);
+   }
+
+   port = (omx_base_video_PortType *)priv->ports[OMX_BASE_FILTER_INPUTPORT_INDEX];
+   port->sPortParam.format.video.nFrameWidth = 176;
+   port->sPortParam.format.video.nFrameHeight = 144;
+   port->sPortParam.format.video.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+   port->sVideoParam.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+   port->sPortParam.nBufferCountActual = 8;
+   port->sPortParam.nBufferCountMin = 4;
+
+   port->Port_SendBufferFunction = vid_enc_EncodeFrame;
+   port->Port_AllocateBuffer = vid_enc_AllocateInBuffer;
+   port->Port_UseBuffer = vid_enc_UseInBuffer;
+   port->Port_FreeBuffer = vid_enc_FreeInBuffer;
+
+   port = (omx_base_video_PortType *)priv->ports[OMX_BASE_FILTER_OUTPUTPORT_INDEX];
+   strcpy(port->sPortParam.format.video.cMIMEType,"video/H264");
+   port->sPortParam.format.video.nFrameWidth = 176;
+   port->sPortParam.format.video.nFrameHeight = 144;
+   port->sPortParam.format.video.eCompressionFormat = OMX_VIDEO_CodingAVC;
+   port->sVideoParam.eCompressionFormat = OMX_VIDEO_CodingAVC;
+
+   port->Port_AllocateBuffer = vid_enc_AllocateOutBuffer;
+   port->Port_FreeBuffer = vid_enc_FreeOutBuffer;
+ 
+   priv->bitrate.eControlRate = OMX_Video_ControlRateDisable;
+   priv->bitrate.nTargetBitrate = 0;
+
+   priv->quant.nQpI = OMX_VID_ENC_QUANT_I_FRAMES_DEFAULT;
+   priv->quant.nQpP = OMX_VID_ENC_QUANT_P_FRAMES_DEFAULT;
+   priv->quant.nQpB = OMX_VID_ENC_QUANT_B_FRAMES_DEFAULT;
+
+   priv->force_pic_type.IntraRefreshVOP = OMX_FALSE; 
+   priv->frame_num = 0;
+
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_Destructor(OMX_COMPONENTTYPE *comp)
+{
+   vid_enc_PrivateType* priv = comp->pComponentPrivate;
+   int i;
+
+   if (priv->ports) {
+      for (i = 0; i < priv->sPortTypesParam[OMX_PortDomainVideo].nPorts; ++i) {
+         if(priv->ports[i])
+            priv->ports[i]->PortDestructor(priv->ports[i]);
+      }
+      FREE(priv->ports);
+      priv->ports=NULL;
+   }
+
+   if (priv->pipe)
+      priv->pipe->destroy(priv->pipe);
+
+   if (priv->screen)
+      omx_put_screen();
+
+   omx_base_filter_Destructor(comp);
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_SetParameter(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR param)
+{
+   OMX_COMPONENTTYPE *comp = handle;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   OMX_ERRORTYPE r;
+
+   if (!param)
+      return OMX_ErrorBadParameter;
+
+   switch(idx) {
+   case OMX_IndexParamPortDefinition: {
+      OMX_PARAM_PORTDEFINITIONTYPE *def = param;
+
+      r = omx_base_component_SetParameter(handle, idx, param);
+      if (r)
+         return r;
+
+      if (def->nPortIndex == OMX_BASE_FILTER_INPUTPORT_INDEX) {
+         omx_base_video_PortType *port;
+         unsigned framesize;
+
+         port = (omx_base_video_PortType *)priv->ports[OMX_BASE_FILTER_INPUTPORT_INDEX];
+         framesize = port->sPortParam.format.video.nFrameWidth*
+                     port->sPortParam.format.video.nFrameHeight;
+         port->sPortParam.format.video.nSliceHeight = port->sPortParam.format.video.nFrameHeight;
+         port->sPortParam.nBufferSize = framesize*3/2;
+
+         port = (omx_base_video_PortType *)priv->ports[OMX_BASE_FILTER_OUTPUTPORT_INDEX];
+         port->sPortParam.nBufferSize = framesize * 512 / (16*16);
+      
+         priv->frame_rate = def->format.video.xFramerate;
+
+         priv->callbacks->EventHandler(comp, priv->callbackData, OMX_EventPortSettingsChanged,
+                                       OMX_BASE_FILTER_OUTPUTPORT_INDEX, 0, NULL);
+      }
+      break;
+   }
+   case OMX_IndexParamStandardComponentRole: {
+      OMX_PARAM_COMPONENTROLETYPE *role = param;
+
+      r = checkHeader(param, sizeof(OMX_PARAM_COMPONENTROLETYPE));
+      if (r)
+         return r;
+
+      if (strcmp((char *)role->cRole, OMX_VID_ENC_AVC_ROLE)) {
+         return OMX_ErrorBadParameter;
+      }
+
+      break;
+   }
+   case OMX_IndexParamVideoBitrate: {
+      OMX_VIDEO_PARAM_BITRATETYPE *bitrate = param;
+
+      r = checkHeader(param, sizeof(OMX_VIDEO_PARAM_BITRATETYPE));
+      if (r)
+         return r;
+
+      priv->bitrate = *bitrate;
+
+      break;
+   }
+   case OMX_IndexParamVideoQuantization: {
+      OMX_VIDEO_PARAM_QUANTIZATIONTYPE *quant = param;
+
+      r = checkHeader(param, sizeof(OMX_VIDEO_PARAM_QUANTIZATIONTYPE));
+      if (r)
+         return r;
+
+      priv->quant = *quant;
+
+      break;
+   }
+   default:
+      return omx_base_component_SetParameter(handle, idx, param);
+   }
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_GetParameter(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR param)
+{
+   OMX_COMPONENTTYPE *comp = handle;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   OMX_ERRORTYPE r;
+
+   if (!param)
+      return OMX_ErrorBadParameter;
+
+   switch(idx) {
+   case OMX_IndexParamStandardComponentRole: {
+      OMX_PARAM_COMPONENTROLETYPE *role = param;
+
+      r = checkHeader(param, sizeof(OMX_PARAM_COMPONENTROLETYPE));
+      if (r)
+         return r;
+
+      strcpy((char *)role->cRole, OMX_VID_ENC_AVC_ROLE);
+      break;
+   }
+   case OMX_IndexParamVideoInit:
+      r = checkHeader(param, sizeof(OMX_PORT_PARAM_TYPE));
+      if (r)
+         return r;
+
+      memcpy(param, &priv->sPortTypesParam[OMX_PortDomainVideo], sizeof(OMX_PORT_PARAM_TYPE));
+      break;
+
+   case OMX_IndexParamVideoPortFormat: {
+      OMX_VIDEO_PARAM_PORTFORMATTYPE *format = param;
+      omx_base_video_PortType *port;
+
+      r = checkHeader(param, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
+      if (r)
+         return r;
+
+      if (format->nPortIndex > 1)
+         return OMX_ErrorBadPortIndex;
+
+      port = (omx_base_video_PortType *)priv->ports[format->nPortIndex];
+      memcpy(format, &port->sVideoParam, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
+      break;
+   }
+   case OMX_IndexParamVideoBitrate: {
+      OMX_VIDEO_PARAM_BITRATETYPE *bitrate = param;
+
+      r = checkHeader(param, sizeof(OMX_VIDEO_PARAM_BITRATETYPE));
+      if (r)
+         return r;
+
+      bitrate->eControlRate = priv->bitrate.eControlRate;
+      bitrate->nTargetBitrate = priv->bitrate.nTargetBitrate;
+
+      break;
+   }
+   case OMX_IndexParamVideoQuantization: {
+      OMX_VIDEO_PARAM_QUANTIZATIONTYPE *quant = param;
+
+      r = checkHeader(param, sizeof(OMX_VIDEO_PARAM_QUANTIZATIONTYPE));
+      if (r)
+         return r;
+
+      quant->nQpI = priv->quant.nQpI;
+      quant->nQpP = priv->quant.nQpP;
+      quant->nQpB = priv->quant.nQpB;
+
+      break;
+   }
+
+   default:
+      return omx_base_component_GetParameter(handle, idx, param);
+
+   }
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_SetConfig(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR config)
+{
+   OMX_COMPONENTTYPE *comp = handle;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   OMX_ERRORTYPE r;
+    
+   if (!config)
+      return OMX_ErrorBadParameter;
+                         
+   switch(idx) {
+   case OMX_IndexConfigVideoIntraVOPRefresh: {
+      OMX_CONFIG_INTRAREFRESHVOPTYPE *type = config;
+
+      r = checkHeader(config, sizeof(OMX_CONFIG_INTRAREFRESHVOPTYPE));
+      if (r)
+         return r;
+      
+      priv->force_pic_type = *type;
+      
+      break;
+   }
+   default:
+      return omx_base_component_SetConfig(handle, idx, config);
+   }
+
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_GetConfig(OMX_HANDLETYPE handle, OMX_INDEXTYPE idx, OMX_PTR config)
+{
+   //TODO
+   return omx_base_component_GetConfig(handle, idx, config);
+}
+
+static OMX_ERRORTYPE vid_enc_MessageHandler(OMX_COMPONENTTYPE* comp, internalRequestMessageType *msg)
+{
+   vid_enc_PrivateType* priv = comp->pComponentPrivate;
+
+   if (msg->messageType == OMX_CommandStateSet) {
+      if ((msg->messageParam == OMX_StateIdle ) && (priv->state == OMX_StateLoaded)) {
+
+         struct pipe_video_codec templat = {};
+         omx_base_video_PortType *port;
+
+         port = (omx_base_video_PortType *)priv->ports[OMX_BASE_FILTER_INPUTPORT_INDEX];
+
+         templat.profile = PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE;
+         templat.entrypoint = PIPE_VIDEO_ENTRYPOINT_ENCODE;
+         templat.chroma_format = PIPE_VIDEO_CHROMA_FORMAT_420;
+         templat.width = port->sPortParam.format.video.nFrameWidth;
+         templat.height = port->sPortParam.format.video.nFrameHeight;
+         templat.max_references = 1;
+
+         priv->codec = priv->pipe->create_video_codec(priv->pipe, &templat);
+
+      } else if ((msg->messageParam == OMX_StateLoaded) && (priv->state == OMX_StateIdle)) {
+         if (priv->codec) {
+            priv->codec->destroy(priv->codec);
+            priv->codec = NULL;
+         }
+      }
+   }
+
+   return omx_base_component_MessageHandler(comp, msg);
+}
+
+static OMX_ERRORTYPE vid_enc_AllocateInBuffer(omx_base_PortType *port, OMX_INOUT OMX_BUFFERHEADERTYPE **buf,
+                                              OMX_IN OMX_U32 idx, OMX_IN OMX_PTR private, OMX_IN OMX_U32 size)
+{
+   OMX_VIDEO_PORTDEFINITIONTYPE *def = &port->sPortParam.format.video;
+   OMX_COMPONENTTYPE* comp = port->standCompContainer;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   struct pipe_video_buffer templat = {};
+   struct input_buf_private *inp;
+   OMX_ERRORTYPE r;
+
+   r = base_port_AllocateBuffer(port, buf, idx, private, size);
+   if (r)
+      return r;
+
+   inp = (*buf)->pInputPortPrivate = CALLOC(1, sizeof(struct input_buf_private));
+   if (!inp) {
+      base_port_FreeBuffer(port, idx, *buf);
+      return OMX_ErrorInsufficientResources;
+   }
+
+   templat.buffer_format = PIPE_FORMAT_NV12;
+   templat.chroma_format = PIPE_VIDEO_CHROMA_FORMAT_420;
+   templat.width = def->nFrameWidth;
+   templat.height = def->nFrameHeight;
+   templat.interlaced = false;
+
+   inp->buf = priv->pipe->create_video_buffer(priv->pipe, &templat);
+   if (!inp->buf) {
+      FREE(inp);
+      base_port_FreeBuffer(port, idx, *buf);
+      return OMX_ErrorInsufficientResources;
+   }
+
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_UseInBuffer(omx_base_PortType *port, OMX_BUFFERHEADERTYPE **buf, OMX_U32 idx,
+                                         OMX_PTR private, OMX_U32 size, OMX_U8 *mem)
+{
+   OMX_VIDEO_PORTDEFINITIONTYPE *def = &port->sPortParam.format.video;
+   OMX_COMPONENTTYPE* comp = port->standCompContainer;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   struct pipe_video_buffer templat = {};
+   struct input_buf_private *inp;
+   OMX_ERRORTYPE r;
+
+   r = base_port_UseBuffer(port, buf, idx, private, size, mem);
+   if (r)
+      return r;
+
+   inp = (*buf)->pInputPortPrivate = CALLOC(1, sizeof(struct input_buf_private));
+   if (!inp) {
+      base_port_FreeBuffer(port, idx, *buf);
+      return OMX_ErrorInsufficientResources;
+   }
+
+   templat.buffer_format = PIPE_FORMAT_NV12;
+   templat.chroma_format = PIPE_VIDEO_CHROMA_FORMAT_420;
+   templat.width = def->nFrameWidth;
+   templat.height = def->nFrameHeight;
+   templat.interlaced = false;
+
+   inp->buf = priv->pipe->create_video_buffer(priv->pipe, &templat);
+   if (!inp->buf) {
+      FREE(inp);
+      base_port_FreeBuffer(port, idx, *buf);
+      return OMX_ErrorInsufficientResources;
+   }
+
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_FreeInBuffer(omx_base_PortType *port, OMX_U32 idx, OMX_BUFFERHEADERTYPE *buf)
+{
+   struct input_buf_private *inp = buf->pInputPortPrivate;
+   pipe_resource_reference(&inp->bitstream, NULL);
+   inp->buf->destroy(inp->buf);
+   FREE(inp);
+   return base_port_FreeBuffer(port, idx, buf);
+}
+
+static OMX_ERRORTYPE vid_enc_AllocateOutBuffer(omx_base_PortType *port, OMX_INOUT OMX_BUFFERHEADERTYPE **buf,
+                                               OMX_IN OMX_U32 idx, OMX_IN OMX_PTR private, OMX_IN OMX_U32 size)
+{
+   OMX_ERRORTYPE r;
+
+   r = base_port_AllocateBuffer(port, buf, idx, private, size);
+   if (r)
+      return r;
+
+   FREE((*buf)->pBuffer);
+   (*buf)->pBuffer = NULL;
+   (*buf)->pOutputPortPrivate = CALLOC(1, sizeof(struct output_buf_private));
+
+   return OMX_ErrorNone;
+}
+
+static OMX_ERRORTYPE vid_enc_FreeOutBuffer(omx_base_PortType *port, OMX_U32 idx, OMX_BUFFERHEADERTYPE *buf)
+{
+   OMX_COMPONENTTYPE* comp = port->standCompContainer;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+
+   if (buf->pOutputPortPrivate) {
+      struct output_buf_private *outp = buf->pOutputPortPrivate;
+      if (outp->transfer)
+         pipe_transfer_unmap(priv->pipe, outp->transfer);
+      pipe_resource_reference(&outp->bitstream, NULL);
+      FREE(outp);
+      buf->pOutputPortPrivate = NULL;
+   }
+   buf->pBuffer = NULL;
+
+   return base_port_FreeBuffer(port, idx, buf);
+}
+
+static OMX_ERRORTYPE vid_enc_EncodeFrame(omx_base_PortType *port, OMX_BUFFERHEADERTYPE *buf)
+{
+   OMX_COMPONENTTYPE* comp = port->standCompContainer;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   struct input_buf_private *inp = buf->pInputPortPrivate;
+   unsigned size = priv->ports[OMX_BASE_FILTER_OUTPUTPORT_INDEX]->sPortParam.nBufferSize;
+   OMX_VIDEO_PORTDEFINITIONTYPE *def = &port->sPortParam.format.video;
+   struct pipe_h264_enc_picture_desc picture;
+   struct pipe_video_buffer *vbuf = inp->buf;
+
+   if (buf->pOutputPortPrivate) {
+      vbuf = buf->pOutputPortPrivate;
+   } else {
+      /* ------- load input image into video buffer ---- */
+      struct pipe_sampler_view **views;
+      struct pipe_box box = {};
+      void *ptr;
+
+      views = inp->buf->get_sampler_view_planes(vbuf);
+      if (!views)
+         return OMX_ErrorInsufficientResources;
+
+      ptr = buf->pBuffer;
+
+      box.width = def->nFrameWidth;
+      box.height = def->nFrameHeight;
+      box.depth = 1;
+
+      priv->pipe->transfer_inline_write(priv->pipe, views[0]->texture, 0,
+                                        PIPE_TRANSFER_WRITE, &box,
+                                        ptr, def->nStride, 0);
+
+
+      ptr = ((uint8_t*)buf->pBuffer) + (def->nStride * box.height);
+
+      box.width = def->nFrameWidth / 2;
+      box.height = def->nFrameHeight / 2;
+      box.depth = 1;
+
+      priv->pipe->transfer_inline_write(priv->pipe, views[1]->texture, 0,
+                                        PIPE_TRANSFER_WRITE, &box,
+                                        ptr, def->nStride, 0);
+   }
+
+   /* -------------- allocate output buffer --------- */
+
+   pipe_resource_reference(&inp->bitstream, NULL);
+   inp->bitstream = pipe_buffer_create(priv->pipe->screen, PIPE_BIND_VERTEX_BUFFER,
+                                       PIPE_USAGE_STREAM, size);
+
+   /* -------------- decode frame --------- */
+
+   switch (priv->bitrate.eControlRate) {
+   case OMX_Video_ControlRateVariable:
+      picture.rate_ctrl.rate_ctrl_method = PIPE_H264_ENC_RATE_CONTROL_METHOD_VARIABLE;
+      break; 
+   case OMX_Video_ControlRateConstant:
+      picture.rate_ctrl.rate_ctrl_method = PIPE_H264_ENC_RATE_CONTROL_METHOD_CONSTANT;
+      break; 
+   case OMX_Video_ControlRateVariableSkipFrames:
+      picture.rate_ctrl.rate_ctrl_method = PIPE_H264_ENC_RATE_CONTROL_METHOD_VARIABLE_SKIP;
+      break;
+   case OMX_Video_ControlRateConstantSkipFrames:
+      picture.rate_ctrl.rate_ctrl_method = PIPE_H264_ENC_RATE_CONTROL_METHOD_CONSTANT_SKIP;
+      break;
+   default:
+      picture.rate_ctrl.rate_ctrl_method = PIPE_H264_ENC_RATE_CONTROL_METHOD_DISABLE;
+      break;
+   } 
+      
+   if (picture.rate_ctrl.rate_ctrl_method != PIPE_H264_ENC_RATE_CONTROL_METHOD_DISABLE) {
+      if (priv->bitrate.nTargetBitrate < OMX_VID_ENC_BITRATE_MIN)
+         picture.rate_ctrl.target_bitrate = OMX_VID_ENC_BITRATE_MIN;
+      else if (priv->bitrate.nTargetBitrate < OMX_VID_ENC_BITRATE_MAX)
+         picture.rate_ctrl.target_bitrate = priv->bitrate.nTargetBitrate;
+      else
+         picture.rate_ctrl.target_bitrate = OMX_VID_ENC_BITRATE_MAX;
+      picture.rate_ctrl.peak_bitrate = picture.rate_ctrl.target_bitrate;    
+      picture.rate_ctrl.frame_rate_den = OMX_VID_ENC_CONTROL_FRAME_RATE_DEN_DEFAULT;
+      picture.rate_ctrl.frame_rate_num = ((priv->frame_rate) >> 16) * picture.rate_ctrl.frame_rate_den;
+      if (picture.rate_ctrl.target_bitrate < OMX_VID_ENC_BITRATE_MEDIAN)
+         picture.rate_ctrl.vbv_buffer_size = MIN2((picture.rate_ctrl.target_bitrate * 2.75), OMX_VID_ENC_BITRATE_MEDIAN);
+      else
+         picture.rate_ctrl.vbv_buffer_size = picture.rate_ctrl.target_bitrate;
+
+      unsigned long long t = picture.rate_ctrl.target_bitrate;
+      t *= picture.rate_ctrl.frame_rate_den;
+      picture.rate_ctrl.target_bits_picture = t / picture.rate_ctrl.frame_rate_num;               
+      picture.rate_ctrl.peak_bits_picture_integer = picture.rate_ctrl.target_bits_picture;
+      picture.rate_ctrl.peak_bits_picture_fraction = 0;
+   } else
+      memset(&picture.rate_ctrl, 0, sizeof(struct pipe_h264_enc_rate_control));
+   
+   picture.quant_i_frames = priv->quant.nQpI;
+   picture.quant_p_frames = priv->quant.nQpP;
+   picture.quant_b_frames = priv->quant.nQpB;
+
+   if (!(priv->frame_num % OMX_VID_ENC_IDR_PERIOD_DEFAULT) || priv->force_pic_type.IntraRefreshVOP) {
+      picture.picture_type = PIPE_H264_ENC_PICTURE_TYPE_IDR;
+      priv->frame_num = 0;
+   } else
+      picture.picture_type = PIPE_H264_ENC_PICTURE_TYPE_P;	
+   
+   picture.frame_num = priv->frame_num++;
+   priv->force_pic_type.IntraRefreshVOP = OMX_FALSE; 
+
+   priv->codec->begin_frame(priv->codec, vbuf, &picture.base);
+   priv->codec->encode_bitstream(priv->codec, vbuf, inp->bitstream, &inp->feedback);
+   priv->codec->end_frame(priv->codec, vbuf, &picture.base);
+ 
+   return base_port_SendBufferFunction(port, buf);
+}
+
+static void vid_enc_BufferEncoded(OMX_COMPONENTTYPE *comp, OMX_BUFFERHEADERTYPE* input, OMX_BUFFERHEADERTYPE* output)
+{
+   struct input_buf_private *inp = input->pInputPortPrivate;
+   vid_enc_PrivateType *priv = comp->pComponentPrivate;
+   struct output_buf_private *outp = output->pOutputPortPrivate;
+   struct pipe_box box = {};
+   unsigned size;
+
+   /* ------------- map result buffer ----------------- */
+
+   if (outp->transfer)
+      pipe_transfer_unmap(priv->pipe, outp->transfer);
+
+   pipe_resource_reference(&outp->bitstream, inp->bitstream);
+
+   box.width = inp->bitstream->width0;
+   box.height = inp->bitstream->height0;
+   box.depth = inp->bitstream->depth0;
+
+   output->pBuffer = priv->pipe->transfer_map(priv->pipe, outp->bitstream, 0,
+                                              PIPE_TRANSFER_READ_WRITE,
+                                              &box, &outp->transfer);
+ 
+   /* ------------- get size of result ----------------- */
+
+   priv->codec->get_feedback(priv->codec, inp->feedback, &size);
+
+   input->nFilledLen = 0; /* mark buffer as empty */
+
+   output->nOffset = 0;
+   output->nFilledLen = size; /* mark buffer as full */
+}
diff --git a/src/gallium/state_trackers/omx/vid_enc.h b/src/gallium/state_trackers/omx/vid_enc.h
new file mode 100644
index 0000000..3f245d2
--- /dev/null
+++ b/src/gallium/state_trackers/omx/vid_enc.h
@@ -0,0 +1,71 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+/*
+ * Authors:
+ *      Christian König <christian.koenig@amd.com>
+ *
+ */
+
+#ifndef OMX_VID_ENC_H
+#define OMX_VID_ENC_H
+
+#include <OMX_Types.h>
+#include <OMX_Component.h>
+#include <OMX_Core.h>
+
+#include <bellagio/st_static_component_loader.h>
+#include <bellagio/omx_base_filter.h>
+
+#define OMX_VID_ENC_BASE_NAME "OMX.%s.video_encoder"
+#define OMX_VID_ENC_AVC_NAME "OMX.%s.video_encoder.avc"
+#define OMX_VID_ENC_AVC_ROLE "video_encoder.avc"
+
+#define OMX_VID_ENC_BITRATE_MIN 64000
+#define OMX_VID_ENC_BITRATE_MEDIAN 2000000
+#define OMX_VID_ENC_BITRATE_MAX 240000000
+#define OMX_VID_ENC_CONTROL_FRAME_RATE_DEN_DEFAULT 1001
+#define OMX_VID_ENC_QUANT_I_FRAMES_DEFAULT 0x1c
+#define OMX_VID_ENC_QUANT_P_FRAMES_DEFAULT 0x1c
+#define OMX_VID_ENC_QUANT_B_FRAMES_DEFAULT 0
+#define OMX_VID_ENC_IDR_PERIOD_DEFAULT 1000
+
+DERIVEDCLASS(vid_enc_PrivateType, omx_base_filter_PrivateType)
+#define vid_enc_PrivateType_FIELDS omx_base_filter_PrivateType_FIELDS \
+	struct vl_screen *screen; \
+	struct pipe_context *pipe; \
+	struct pipe_video_codec *codec; \
+	OMX_U32 frame_rate; \
+	OMX_U32 frame_num; \
+	OMX_VIDEO_PARAM_BITRATETYPE bitrate; \
+	OMX_VIDEO_PARAM_QUANTIZATIONTYPE quant; \
+	OMX_CONFIG_INTRAREFRESHVOPTYPE force_pic_type;
+ENDCLASS(vid_enc_PrivateType)
+
+OMX_ERRORTYPE vid_enc_LoaderComponent(stLoaderComponentType *comp);
+
+#endif
-- 
1.7.9.5

