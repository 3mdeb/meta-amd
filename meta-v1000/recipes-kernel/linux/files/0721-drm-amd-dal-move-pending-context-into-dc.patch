From 283c33a2c459e1340ab78330b2a1f77279b954ce Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Fri, 5 Aug 2016 17:22:30 -0400
Subject: [PATCH 0721/1722] drm/amd/dal: move pending context into dc

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c         | 121 +++++++++++++++++++++------
 drivers/gpu/drm/amd/dal/dc/core/dc_surface.c |   5 +-
 drivers/gpu/drm/amd/dal/dc/dc.h              |  10 +--
 drivers/gpu/drm/amd/dal/dc/inc/core_dc.h     |   5 +-
 4 files changed, 109 insertions(+), 32 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index a48bb57..0454c40 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -890,6 +890,12 @@ bool dc_commit_targets(
 	dm_free(core_dc->current_context);
 	core_dc->current_context = context;
 
+	/* Any pending context is no longer valid once a setmode happens*/
+	if (core_dc->pending_context) {
+		resource_validate_ctx_destruct(core_dc->pending_context);
+		core_dc->pending_context = NULL;
+	}
+
 	return (result == DC_OK);
 
 fail:
@@ -899,13 +905,12 @@ context_alloc_fail:
 	return (result == DC_OK);
 }
 
-struct validate_context *dc_pre_commit_surfaces_to_target(
+bool dc_pre_commit_surfaces_to_target(
 		struct dc *dc,
 		struct dc_surface *new_surfaces[],
 		uint8_t new_surface_count,
 		struct dc_target *dc_target)
 {
-
 	int i, j;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
@@ -918,6 +923,9 @@ struct validate_context *dc_pre_commit_surfaces_to_target(
 	int current_enabled_surface_count = 0;
 	int new_enabled_surface_count = 0;
 
+	if (core_dc->pending_context)
+		dc_post_commit_surfaces_to_target(dc);
+
 	if (core_dc->current_context->target_count == 0)
 		return NULL;
 
@@ -1016,57 +1024,123 @@ struct validate_context *dc_pre_commit_surfaces_to_target(
         if (bw_increased)
                 core_dc->current_context->bw_results = context->bw_results;
  
-        return context;
+        core_dc->pending_context = context; 
+ 
+        return true;
  
 unexpected_fail:
         resource_validate_ctx_destruct(context);
         dm_free(context);
 val_ctx_fail:
-        return NULL;
+        return false;
 }
 
 bool dc_isr_commit_surfaces_to_target(
                 struct dc *dc,
-                struct validate_context *context)
+                struct dc_flip_addrs flip_addrs[],
+                struct dc_surface *new_surfaces[],
+                int new_surface_count)
 {
+        int i, j;
+        enum dc_status status = DC_OK;
         struct core_dc *core_dc = DC_TO_CORE(dc);
-        enum dc_status status;
+        int pipe_count = core_dc->res_pool->pipe_count;
+        struct validate_context *context = core_dc->pending_context ?
+                        core_dc->pending_context : core_dc->current_context;
+ 
+ 
+        for (j = 0; j < pipe_count; j++) {
+                struct pipe_ctx *pipe_ctx =
+                        &context->res_ctx.pipe_ctx[j];
+                struct core_surface *ctx_surface = pipe_ctx->surface;
+ 
+                if (!ctx_surface)
+                        continue;
+ 
+                if (flip_addrs) {
+                        for (i = 0; i < new_surface_count; i++) {
+                                        /*
+                                         * Temporary hack, allow address to be filled into
+                                         * the surface directly and programmed here.
+                                         * TODO: Unify how address is passed into DC
+                                         */
+ 
+                                        if (DC_SURFACE_TO_CORE(new_surfaces[i]) != ctx_surface)
+                                                continue;
+                                ctx_surface->public.address = flip_addrs[i].address;
+                                ctx_surface->public.flip_immediate = flip_addrs[i].flip_immediate;
+                        }
+                }
  
-        status = core_dc->hwss.apply_ctx_to_surface_unlock(core_dc, context);
-        context->locked = false;
+                if (!ctx_surface->public.flip_immediate)
+                        core_dc->hwss.pipe_control_lock(
+                                        core_dc->ctx,
+                                        pipe_ctx->pipe_idx,
+                                        PIPE_LOCK_CONTROL_SURFACE |
+                                        PIPE_LOCK_CONTROL_MODE,
+                                        true);
+ 
+                core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+ 
+        } 
+
+        for (j = pipe_count - 1; j >= 0; j--)
+                for (i = new_surface_count - 1; i >= 0; i--) {
+                        struct pipe_ctx *pipe_ctx =
+                                &context->res_ctx.pipe_ctx[j];
+                        struct core_surface *ctx_surface = pipe_ctx->surface;
+ 
+                        if (!ctx_surface)
+                                continue;
+ 
+                        if (!ctx_surface->public.flip_immediate)
+                                core_dc->hwss.pipe_control_lock(
+                                                core_dc->ctx,
+                                                pipe_ctx->pipe_idx,
+                                                PIPE_LOCK_CONTROL_SURFACE,
+                                                false);
+                }
+ 
+        if (core_dc->pending_context && core_dc->pending_context->locked) {
+                status = core_dc->hwss.apply_ctx_to_surface_unlock(core_dc, core_dc->pending_context);
+                core_dc->pending_context->locked = false;
+        }
  
         return status == DC_OK;
 }
 
 bool dc_post_commit_surfaces_to_target(
-                struct dc *dc,
-                struct validate_context *context)
+                struct dc *dc)
 {
         int i;
         struct core_dc *core_dc = DC_TO_CORE(dc);
  
-        if (context->locked)
-                dc_isr_commit_surfaces_to_target(dc, context);
+        if (!core_dc->pending_context)
+                return true;
  
-        for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+        if (core_dc->pending_context->locked)
+                dc_isr_commit_surfaces_to_target(dc, NULL, NULL, 0);
+ 
+        for (i = 0; i < core_dc->pending_context->res_ctx.pool->pipe_count; i++) {
                 if (core_dc->current_context->res_ctx.pipe_ctx[i].stream != NULL
-                                && context->res_ctx.pipe_ctx[i].stream == NULL) {
+                                && core_dc->pending_context->res_ctx.pipe_ctx[i].stream == NULL) {
                         core_dc->hwss.enable_display_power_gating(
                                 core_dc->ctx, i, core_dc->ctx->dc_bios,
                                 PIPE_GATING_CONTROL_ENABLE);
                         core_dc->current_context->res_ctx.pipe_ctx[i].xfm->funcs->transform_reset(
                                         core_dc->current_context->res_ctx.pipe_ctx[i].xfm);
-                        memset(&context->res_ctx.pipe_ctx[i], 0, sizeof(struct pipe_ctx));
+                        memset(&core_dc->pending_context->res_ctx.pipe_ctx[i], 0, sizeof(struct pipe_ctx));
                 }
         }
  
-        if (core_dc->hwss.decrease_bandwidth(core_dc, context))
+        if (core_dc->hwss.decrease_bandwidth(core_dc, core_dc->pending_context))
                 pplib_apply_display_requirements(
-                                core_dc, context, &context->pp_display_cfg);
+                                core_dc, core_dc->pending_context, &core_dc->pending_context->pp_display_cfg);
   
 	resource_validate_ctx_destruct(core_dc->current_context);
 	dm_free(core_dc->current_context);
-	core_dc->current_context = context;
+        core_dc->current_context = core_dc->pending_context;
+        core_dc->pending_context = NULL;
 	return true;
 }
 
@@ -1076,18 +1150,17 @@ bool dc_commit_surfaces_to_target(
                 uint8_t new_surface_count,
                 struct dc_target *dc_target)
 {
-        struct validate_context *context = dc_pre_commit_surfaces_to_target(
+        if (!dc_pre_commit_surfaces_to_target(
                         dc,
                         new_surfaces,
                         new_surface_count,
-                        dc_target);
-        if (!context)
+                        dc_target))
                 return false;
  
-        if (!dc_isr_commit_surfaces_to_target(dc, context))
+        if (!dc_isr_commit_surfaces_to_target(dc, NULL, new_surfaces, new_surface_count))
                 return false;
  
-        if (!dc_post_commit_surfaces_to_target(dc, context))
+        if (!dc_post_commit_surfaces_to_target(dc))
                 return false;
  
         return true;
@@ -1201,8 +1274,8 @@ void dc_flip_surface_addrs_on_context(
                 struct dc_flip_addrs flip_addrs[],
                 uint32_t count)
 {
-        struct core_dc *core_dc = DC_TO_CORE(dc);
         int i, j;
+        struct core_dc *core_dc = DC_TO_CORE(dc);
         int pipe_count = core_dc->res_pool->pipe_count;
  
         for (i = 0; i < count; i++)
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
index 158ccf4..c43150f 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
@@ -103,7 +103,6 @@ alloc_fail:
 }
 
 const struct dc_surface_status *dc_surface_get_status(
-		struct validate_context *context,
 		struct dc_surface *dc_surface)
 {
 	struct dc_surface_status *surface_status;
@@ -111,6 +110,8 @@ const struct dc_surface_status *dc_surface_get_status(
 	struct core_dc *core_dc;
 	int i;
 
+	struct validate_context *context;
+
 	if (dc_surface == NULL)
 		return NULL;
 
@@ -126,6 +127,8 @@ const struct dc_surface_status *dc_surface_get_status(
 
 	core_dc = DC_TO_CORE(core_surface->ctx->dc);
 
+	context = core_dc->pending_context;
+
 	if (!context)
 		context = core_dc->current_context;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 4a5a4f9..44c7f15 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -176,7 +176,6 @@ struct dc_surface_status {
  */
 struct dc_surface *dc_create_surface(const struct dc *dc);
 const struct dc_surface_status *dc_surface_get_status(
-		struct validate_context *context,
 		struct dc_surface *dc_surface);
 
 void dc_surface_retain(const struct dc_surface *dc_surface);
@@ -234,7 +233,7 @@ bool dc_commit_surfaces_to_target(
 		uint8_t surface_count,
 		struct dc_target *dc_target);
 
-struct validate_context *dc_pre_commit_surfaces_to_target(
+bool dc_pre_commit_surfaces_to_target(
 		struct dc *dc,
 		struct dc_surface *new_surfaces[],
 		uint8_t new_surface_count,
@@ -242,11 +241,12 @@ struct validate_context *dc_pre_commit_surfaces_to_target(
 
 bool dc_isr_commit_surfaces_to_target(
 		struct dc *dc,
-		struct validate_context *context);
+		struct dc_flip_addrs flip_addrs[],
+		struct dc_surface *new_surfaces[],
+		int new_surface_count);
 
 bool dc_post_commit_surfaces_to_target(
-		struct dc *dc,
-		struct validate_context *context);
+		struct dc *dc);
 
 
 bool dc_update_surfaces_for_target(
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
index 813e05a..4c29595 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
@@ -1,5 +1,5 @@
 /*
- * core_dc.h
+ * rore_dc.h
  *
  *  Created on: Nov 13, 2015
  *      Author: yonsun
@@ -14,7 +14,7 @@
 #define DC_TO_CORE(dc)\
 	container_of(dc, struct core_dc, public)
 
-struct core_dc {
+struct coe_dc {
 	struct dc public;
 	struct dc_context *ctx;
 
@@ -23,6 +23,7 @@ struct core_dc {
 
 	/* TODO: determine max number of targets*/
 	struct validate_context *current_context;
+        struct validate_context *pending_context;
 	struct resource_pool res_pool;
 
 	/*Power State*/
-- 
2.7.4

