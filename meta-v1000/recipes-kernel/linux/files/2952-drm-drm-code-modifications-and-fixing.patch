From 400af7f7bd8a363ed73597c31843783eba2e4956 Mon Sep 17 00:00:00 2001
From: Kalyan Alle <kalyan.alle@amd.com>
Date: Sat, 13 May 2017 17:49:20 +0530
Subject: [PATCH 2952/3082] drm: drm code modifications and fixing

build errors between commits.

Adding the required common drm code changes from the
4.9 kernel on raven-hybrid  branch to 4.4.11 kernel.This includes
the raven specific modifications as well.

Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/drm_atomic_helper.c        |  94 +++++
 drivers/gpu/drm/drm_bridge.c               |  26 ++
 drivers/gpu/drm/drm_crtc_helper_internal.h |  65 ++++
 drivers/gpu/drm/drm_dp_dual_mode_helper.c  | 366 +++++++++++++++++++
 drivers/gpu/drm/drm_fb_helper.c            |  13 +-
 drivers/gpu/drm/drm_fops.c                 |   2 +
 drivers/gpu/drm/drm_irq.c                  |  31 ++
 drivers/gpu/drm/drm_kms_helper_common.c    |  61 ++++
 drivers/gpu/drm/drm_modeset_helper.c       |  67 ++++
 drivers/gpu/drm/drm_plane_helper.c         |  98 +++++
 drivers/gpu/drm/drm_simple_kms_helper.c    | 270 ++++++++++++++
 drivers/gpu/drm/radeon/radeon_drv.c        |  14 +-
 drivers/gpu/drm/radeon/radeon_object.c     |   1 +
 drivers/gpu/drm/radeon/radeon_object.h     |   1 +
 drivers/gpu/drm/radeon/radeon_ttm.c        |   2 +
 drivers/gpu/drm/radeon/si.c                | 552 ++++++++++++++++-------------
 drivers/gpu/drm/radeon/si_dpm.c            | 383 +++++++++-----------
 drivers/gpu/drm/radeon/vce_v1_0.c          |   3 +-
 drivers/gpu/drm/ttm/ttm_agp_backend.c      |   1 +
 drivers/gpu/drm/ttm/ttm_bo.c               | 451 ++++++++++++++++++++---
 drivers/gpu/drm/ttm/ttm_bo_util.c          | 110 ++++++
 drivers/gpu/drm/ttm/ttm_bo_vm.c            |  16 +-
 drivers/gpu/drm/ttm/ttm_memory.c           |   1 +
 drivers/gpu/drm/ttm/ttm_object.c           |   1 +
 drivers/gpu/drm/ttm/ttm_page_alloc.c       |   1 +
 drivers/gpu/drm/ttm/ttm_page_alloc_dma.c   |   1 +
 drivers/gpu/drm/ttm/ttm_tt.c               |   1 +
 include/drm/drmP.h                         |   5 +
 include/drm/drm_bridge.h                   |  36 ++
 include/drm/drm_crtc.h                     | 105 +++++-
 include/drm/drm_dp_dual_mode_helper.h      |  92 +++++
 include/drm/drm_dp_helper.h                |   2 +-
 include/drm/drm_mode_object.h              |  48 +++
 include/drm/drm_modeset_helper.h           |  36 ++
 include/drm/drm_plane_helper.h             |   6 +
 include/drm/drm_simple_kms_helper.h        | 125 +++++++
 include/drm/ttm/ttm_bo_api.h               |  55 +++
 include/drm/ttm/ttm_bo_driver.h            |  23 +-
 include/drm/ttm/ttm_placement.h            |   1 +
 include/linux/pci.h                        |   1 +
 40 files changed, 2651 insertions(+), 516 deletions(-)
 create mode 100644 drivers/gpu/drm/drm_crtc_helper_internal.h
 create mode 100644 drivers/gpu/drm/drm_dp_dual_mode_helper.c
 create mode 100644 drivers/gpu/drm/drm_kms_helper_common.c
 create mode 100644 drivers/gpu/drm/drm_modeset_helper.c
 create mode 100644 drivers/gpu/drm/drm_simple_kms_helper.c
 create mode 100644 include/drm/drm_bridge.h
 create mode 100644 include/drm/drm_dp_dual_mode_helper.h
 create mode 100644 include/drm/drm_mode_object.h
 create mode 100644 include/drm/drm_modeset_helper.h
 create mode 100644 include/drm/drm_simple_kms_helper.h

diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c
index 6691755..13151fd 100644
--- a/drivers/gpu/drm/drm_atomic_helper.c
+++ b/drivers/gpu/drm/drm_atomic_helper.c
@@ -2680,6 +2680,100 @@ __drm_atomic_helper_connector_destroy_state(struct drm_connector *connector,
 EXPORT_SYMBOL(__drm_atomic_helper_connector_destroy_state);
 
 /**
+ * drm_atomic_helper_legacy_gamma_set - set the legacy gamma correction table
+ * @crtc: CRTC object
+ * @red: red correction table
+ * @green: green correction table
+ * @blue: green correction table
+ * @size: size of the tables
+ *
+ * Implements support for legacy gamma correction table for drivers
+ * that support color management through the DEGAMMA_LUT/GAMMA_LUT
+ * properties.
+ */
+int drm_atomic_helper_legacy_gamma_set(struct drm_crtc *crtc,
+                                       u16 *red, u16 *green, u16 *blue,
+                                       uint32_t size)
+{
+        struct drm_device *dev = crtc->dev;
+        struct drm_mode_config *config = &dev->mode_config;
+        struct drm_atomic_state *state;
+        struct drm_crtc_state *crtc_state;
+        struct drm_property_blob *blob = NULL;
+        struct drm_color_lut *blob_data;
+        int i, ret = 0;
+
+        state = drm_atomic_state_alloc(crtc->dev);
+        if (!state)
+                return -ENOMEM;
+
+        blob = drm_property_create_blob(dev,
+                                        sizeof(struct drm_color_lut) * size,
+                                        NULL);
+        if (IS_ERR(blob)) {
+                ret = PTR_ERR(blob);
+                blob = NULL;
+                goto fail;
+        }
+
+        /* Prepare GAMMA_LUT with the legacy values. */
+        blob_data = (struct drm_color_lut *) blob->data;
+        for (i = 0; i < size; i++) {
+                blob_data[i].red = red[i];
+                blob_data[i].green = green[i];
+                blob_data[i].blue = blue[i];
+        }
+
+        state->acquire_ctx = crtc->dev->mode_config.acquire_ctx;
+retry:
+        crtc_state = drm_atomic_get_crtc_state(state, crtc);
+        if (IS_ERR(crtc_state)) {
+                ret = PTR_ERR(crtc_state);
+                goto fail;
+        }
+
+        /* Reset DEGAMMA_LUT and CTM properties. */
+        ret = drm_atomic_crtc_set_property(crtc, crtc_state,
+                        config->degamma_lut_property, 0);
+        if (ret)
+                goto fail;
+
+        ret = drm_atomic_crtc_set_property(crtc, crtc_state,
+                        config->ctm_property, 0);
+        if (ret)
+                goto fail;
+
+        ret = drm_atomic_crtc_set_property(crtc, crtc_state,
+                        config->gamma_lut_property, blob->base.id);
+        if (ret)
+                goto fail;
+
+        ret = drm_atomic_commit(state);
+        if (ret)
+                goto fail;
+
+        /* Driver takes ownership of state on successful commit. */
+
+        drm_property_unreference_blob(blob);
+
+        return 0;
+fail:
+        if (ret == -EDEADLK)
+                goto backoff;
+
+        drm_atomic_state_free(state);
+        drm_property_unreference_blob(blob);
+
+        return ret;
+backoff:
+        drm_atomic_state_clear(state);
+        drm_atomic_legacy_backoff(state);
+
+        goto retry;
+}
+EXPORT_SYMBOL(drm_atomic_helper_legacy_gamma_set);
+
+/**
  * drm_atomic_helper_connector_destroy_state - default state destroy hook
  * @connector: drm connector
  * @state: connector state object to release
diff --git a/drivers/gpu/drm/drm_bridge.c b/drivers/gpu/drm/drm_bridge.c
index 6b8f721..cd63529 100644
--- a/drivers/gpu/drm/drm_bridge.c
+++ b/drivers/gpu/drm/drm_bridge.c
@@ -120,6 +120,32 @@ int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge)
 EXPORT_SYMBOL(drm_bridge_attach);
 
 /**
+ * drm_bridge_detach - deassociate given bridge from its DRM device
+ *
+ * @bridge: bridge control structure
+ *
+ * Called by a kms driver to unlink the given bridge from its DRM device.
+ *
+ * Note that tearing down links between the bridge and our encoder/bridge
+ * objects needs to be handled by the kms driver itself.
+ */
+void drm_bridge_detach(struct drm_bridge *bridge)
+{
+        if (WARN_ON(!bridge))
+                return;
+
+        if (WARN_ON(!bridge->dev))
+                return;
+
+        if (bridge->funcs->detach)
+                bridge->funcs->detach(bridge);
+
+        bridge->dev = NULL;
+}
+EXPORT_SYMBOL(drm_bridge_detach);
+
+
+/**
  * DOC: bridge callbacks
  *
  * The drm_bridge_funcs ops are populated by the bridge driver. The drm
diff --git a/drivers/gpu/drm/drm_crtc_helper_internal.h b/drivers/gpu/drm/drm_crtc_helper_internal.h
new file mode 100644
index 0000000..28295e5
--- /dev/null
+++ b/drivers/gpu/drm/drm_crtc_helper_internal.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright Â© 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This header file contains mode setting related functions and definitions
+ * which are only used within the drm kms helper module as internal
+ * implementation details and are not exported to drivers.
+ */
+
+#include <drm/drm_dp_helper.h>
+
+/* drm_fb_helper.c */
+#ifdef CONFIG_DRM_FBDEV_EMULATION
+int drm_fb_helper_modinit(void);
+#else
+static inline int drm_fb_helper_modinit(void)
+{
+	return 0;
+}
+#endif
+
+/* drm_dp_aux_dev.c */
+#ifdef CONFIG_DRM_DP_AUX_CHARDEV
+int drm_dp_aux_dev_init(void);
+void drm_dp_aux_dev_exit(void);
+int drm_dp_aux_register_devnode(struct drm_dp_aux *aux);
+void drm_dp_aux_unregister_devnode(struct drm_dp_aux *aux);
+#else
+static inline int drm_dp_aux_dev_init(void)
+{
+	return 0;
+}
+
+static inline void drm_dp_aux_dev_exit(void)
+{
+}
+
+static inline int drm_dp_aux_register_devnode(struct drm_dp_aux *aux)
+{
+	return 0;
+}
+
+static inline void drm_dp_aux_unregister_devnode(struct drm_dp_aux *aux)
+{
+}
+#endif
diff --git a/drivers/gpu/drm/drm_dp_dual_mode_helper.c b/drivers/gpu/drm/drm_dp_dual_mode_helper.c
new file mode 100644
index 0000000..a7b2a75
--- /dev/null
+++ b/drivers/gpu/drm/drm_dp_dual_mode_helper.c
@@ -0,0 +1,366 @@
+/*
+ * Copyright Â© 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/errno.h>
+#include <linux/export.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <drm/drm_dp_dual_mode_helper.h>
+#include <drm/drmP.h>
+
+/**
+ * DOC: dp dual mode helpers
+ *
+ * Helper functions to deal with DP dual mode (aka. DP++) adaptors.
+ *
+ * Type 1:
+ * Adaptor registers (if any) and the sink DDC bus may be accessed via I2C.
+ *
+ * Type 2:
+ * Adaptor registers and sink DDC bus can be accessed either via I2C or
+ * I2C-over-AUX. Source devices may choose to implement either of these
+ * access methods.
+ */
+
+#define DP_DUAL_MODE_SLAVE_ADDRESS 0x40
+
+/**
+ * drm_dp_dual_mode_read - Read from the DP dual mode adaptor register(s)
+ * @adapter: I2C adapter for the DDC bus
+ * @offset: register offset
+ * @buffer: buffer for return data
+ * @size: sizo of the buffer
+ *
+ * Reads @size bytes from the DP dual mode adaptor registers
+ * starting at @offset.
+ *
+ * Returns:
+ * 0 on success, negative error code on failure
+ */
+ssize_t drm_dp_dual_mode_read(struct i2c_adapter *adapter,
+			      u8 offset, void *buffer, size_t size)
+{
+	struct i2c_msg msgs[] = {
+		{
+			.addr = DP_DUAL_MODE_SLAVE_ADDRESS,
+			.flags = 0,
+			.len = 1,
+			.buf = &offset,
+		},
+		{
+			.addr = DP_DUAL_MODE_SLAVE_ADDRESS,
+			.flags = I2C_M_RD,
+			.len = size,
+			.buf = buffer,
+		},
+	};
+	int ret;
+
+	ret = i2c_transfer(adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0)
+		return ret;
+	if (ret != ARRAY_SIZE(msgs))
+		return -EPROTO;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dual_mode_read);
+
+/**
+ * drm_dp_dual_mode_write - Write to the DP dual mode adaptor register(s)
+ * @adapter: I2C adapter for the DDC bus
+ * @offset: register offset
+ * @buffer: buffer for write data
+ * @size: sizo of the buffer
+ *
+ * Writes @size bytes to the DP dual mode adaptor registers
+ * starting at @offset.
+ *
+ * Returns:
+ * 0 on success, negative error code on failure
+ */
+ssize_t drm_dp_dual_mode_write(struct i2c_adapter *adapter,
+			       u8 offset, const void *buffer, size_t size)
+{
+	struct i2c_msg msg = {
+		.addr = DP_DUAL_MODE_SLAVE_ADDRESS,
+		.flags = 0,
+		.len = 1 + size,
+		.buf = NULL,
+	};
+	void *data;
+	int ret;
+
+	data = kmalloc(msg.len, GFP_TEMPORARY);
+	if (!data)
+		return -ENOMEM;
+
+	msg.buf = data;
+
+	memcpy(data, &offset, 1);
+	memcpy(data + 1, buffer, size);
+
+	ret = i2c_transfer(adapter, &msg, 1);
+
+	kfree(data);
+
+	if (ret < 0)
+		return ret;
+	if (ret != 1)
+		return -EPROTO;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dual_mode_write);
+
+static bool is_hdmi_adaptor(const char hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN])
+{
+	static const char dp_dual_mode_hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN] =
+		"DP-HDMI ADAPTOR\x04";
+
+	return memcmp(hdmi_id, dp_dual_mode_hdmi_id,
+		      sizeof(dp_dual_mode_hdmi_id)) == 0;
+}
+
+static bool is_type2_adaptor(uint8_t adaptor_id)
+{
+	return adaptor_id == (DP_DUAL_MODE_TYPE_TYPE2 |
+			      DP_DUAL_MODE_REV_TYPE2);
+}
+
+/**
+ * drm_dp_dual_mode_detect - Identify the DP dual mode adaptor
+ * @adapter: I2C adapter for the DDC bus
+ *
+ * Attempt to identify the type of the DP dual mode adaptor used.
+ *
+ * Note that when the answer is @DRM_DP_DUAL_MODE_UNKNOWN it's not
+ * certain whether we're dealing with a native HDMI port or
+ * a type 1 DVI dual mode adaptor. The driver will have to use
+ * some other hardware/driver specific mechanism to make that
+ * distinction.
+ *
+ * Returns:
+ * The type of the DP dual mode adaptor used
+ */
+enum drm_dp_dual_mode_type drm_dp_dual_mode_detect(struct i2c_adapter *adapter)
+{
+	char hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN] = {};
+	uint8_t adaptor_id = 0x00;
+	ssize_t ret;
+
+	/*
+	 * Let's see if the adaptor is there the by reading the
+	 * HDMI ID registers.
+	 *
+	 * Note that type 1 DVI adaptors are not required to implemnt
+	 * any registers, and that presents a problem for detection.
+	 * If the i2c transfer is nacked, we may or may not be dealing
+	 * with a type 1 DVI adaptor. Some other mechanism of detecting
+	 * the presence of the adaptor is required. One way would be
+	 * to check the state of the CONFIG1 pin, Another method would
+	 * simply require the driver to know whether the port is a DP++
+	 * port or a native HDMI port. Both of these methods are entirely
+	 * hardware/driver specific so we can't deal with them here.
+	 */
+	ret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_HDMI_ID,
+				    hdmi_id, sizeof(hdmi_id));
+	if (ret)
+		return DRM_DP_DUAL_MODE_UNKNOWN;
+
+	/*
+	 * Sigh. Some (maybe all?) type 1 adaptors are broken and ack
+	 * the offset but ignore it, and instead they just always return
+	 * data from the start of the HDMI ID buffer. So for a broken
+	 * type 1 HDMI adaptor a single byte read will always give us
+	 * 0x44, and for a type 1 DVI adaptor it should give 0x00
+	 * (assuming it implements any registers). Fortunately neither
+	 * of those values will match the type 2 signature of the
+	 * DP_DUAL_MODE_ADAPTOR_ID register so we can proceed with
+	 * the type 2 adaptor detection safely even in the presence
+	 * of broken type 1 adaptors.
+	 */
+	ret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_ADAPTOR_ID,
+				    &adaptor_id, sizeof(adaptor_id));
+	if (ret == 0) {
+		if (is_type2_adaptor(adaptor_id)) {
+			if (is_hdmi_adaptor(hdmi_id))
+				return DRM_DP_DUAL_MODE_TYPE2_HDMI;
+			else
+				return DRM_DP_DUAL_MODE_TYPE2_DVI;
+		}
+	}
+
+	if (is_hdmi_adaptor(hdmi_id))
+		return DRM_DP_DUAL_MODE_TYPE1_HDMI;
+	else
+		return DRM_DP_DUAL_MODE_TYPE1_DVI;
+}
+EXPORT_SYMBOL(drm_dp_dual_mode_detect);
+
+/**
+ * drm_dp_dual_mode_max_tmds_clock - Max TMDS clock for DP dual mode adaptor
+ * @type: DP dual mode adaptor type
+ * @adapter: I2C adapter for the DDC bus
+ *
+ * Determine the max TMDS clock the adaptor supports based on the
+ * type of the dual mode adaptor and the DP_DUAL_MODE_MAX_TMDS_CLOCK
+ * register (on type2 adaptors). As some type 1 adaptors have
+ * problems with registers (see comments in drm_dp_dual_mode_detect())
+ * we don't read the register on those, instead we simply assume
+ * a 165 MHz limit based on the specification.
+ *
+ * Returns:
+ * Maximum supported TMDS clock rate for the DP dual mode adaptor in kHz.
+ */
+int drm_dp_dual_mode_max_tmds_clock(enum drm_dp_dual_mode_type type,
+				    struct i2c_adapter *adapter)
+{
+	uint8_t max_tmds_clock;
+	ssize_t ret;
+
+	/* native HDMI so no limit */
+	if (type == DRM_DP_DUAL_MODE_NONE)
+		return 0;
+
+	/*
+	 * Type 1 adaptors are limited to 165MHz
+	 * Type 2 adaptors can tells us their limit
+	 */
+	if (type < DRM_DP_DUAL_MODE_TYPE2_DVI)
+		return 165000;
+
+	ret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_MAX_TMDS_CLOCK,
+				    &max_tmds_clock, sizeof(max_tmds_clock));
+	if (ret || max_tmds_clock == 0x00 || max_tmds_clock == 0xff) {
+		DRM_DEBUG_KMS("Failed to query max TMDS clock\n");
+		return 165000;
+	}
+
+	return max_tmds_clock * 5000 / 2;
+}
+EXPORT_SYMBOL(drm_dp_dual_mode_max_tmds_clock);
+
+/**
+ * drm_dp_dual_mode_get_tmds_output - Get the state of the TMDS output buffers in the DP dual mode adaptor
+ * @type: DP dual mode adaptor type
+ * @adapter: I2C adapter for the DDC bus
+ * @enabled: current state of the TMDS output buffers
+ *
+ * Get the state of the TMDS output buffers in the adaptor. For
+ * type2 adaptors this is queried from the DP_DUAL_MODE_TMDS_OEN
+ * register. As some type 1 adaptors have problems with registers
+ * (see comments in drm_dp_dual_mode_detect()) we don't read the
+ * register on those, instead we simply assume that the buffers
+ * are always enabled.
+ *
+ * Returns:
+ * 0 on success, negative error code on failure
+ */
+int drm_dp_dual_mode_get_tmds_output(enum drm_dp_dual_mode_type type,
+				     struct i2c_adapter *adapter,
+				     bool *enabled)
+{
+	uint8_t tmds_oen;
+	ssize_t ret;
+
+	if (type < DRM_DP_DUAL_MODE_TYPE2_DVI) {
+		*enabled = true;
+		return 0;
+	}
+
+	ret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_TMDS_OEN,
+				    &tmds_oen, sizeof(tmds_oen));
+	if (ret) {
+		DRM_DEBUG_KMS("Failed to query state of TMDS output buffers\n");
+		return ret;
+	}
+
+	*enabled = !(tmds_oen & DP_DUAL_MODE_TMDS_DISABLE);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dual_mode_get_tmds_output);
+
+/**
+ * drm_dp_dual_mode_set_tmds_output - Enable/disable TMDS output buffers in the DP dual mode adaptor
+ * @type: DP dual mode adaptor type
+ * @adapter: I2C adapter for the DDC bus
+ * @enable: enable (as opposed to disable) the TMDS output buffers
+ *
+ * Set the state of the TMDS output buffers in the adaptor. For
+ * type2 this is set via the DP_DUAL_MODE_TMDS_OEN register. As
+ * some type 1 adaptors have problems with registers (see comments
+ * in drm_dp_dual_mode_detect()) we avoid touching the register,
+ * making this function a no-op on type 1 adaptors.
+ *
+ * Returns:
+ * 0 on success, negative error code on failure
+ */
+int drm_dp_dual_mode_set_tmds_output(enum drm_dp_dual_mode_type type,
+				     struct i2c_adapter *adapter, bool enable)
+{
+	uint8_t tmds_oen = enable ? 0 : DP_DUAL_MODE_TMDS_DISABLE;
+	ssize_t ret;
+
+	if (type < DRM_DP_DUAL_MODE_TYPE2_DVI)
+		return 0;
+
+	ret = drm_dp_dual_mode_write(adapter, DP_DUAL_MODE_TMDS_OEN,
+				     &tmds_oen, sizeof(tmds_oen));
+	if (ret) {
+		DRM_DEBUG_KMS("Failed to %s TMDS output buffers\n",
+			      enable ? "enable" : "disable");
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_dp_dual_mode_set_tmds_output);
+
+/**
+ * drm_dp_get_dual_mode_type_name - Get the name of the DP dual mode adaptor type as a string
+ * @type: DP dual mode adaptor type
+ *
+ * Returns:
+ * String representation of the DP dual mode adaptor type
+ */
+const char *drm_dp_get_dual_mode_type_name(enum drm_dp_dual_mode_type type)
+{
+	switch (type) {
+	case DRM_DP_DUAL_MODE_NONE:
+		return "none";
+	case DRM_DP_DUAL_MODE_TYPE1_DVI:
+		return "type 1 DVI";
+	case DRM_DP_DUAL_MODE_TYPE1_HDMI:
+		return "type 1 HDMI";
+	case DRM_DP_DUAL_MODE_TYPE2_DVI:
+		return "type 2 DVI";
+	case DRM_DP_DUAL_MODE_TYPE2_HDMI:
+		return "type 2 HDMI";
+	default:
+		WARN_ON(type != DRM_DP_DUAL_MODE_UNKNOWN);
+		return "unknown";
+	}
+}
+EXPORT_SYMBOL(drm_dp_get_dual_mode_type_name);
diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index 69cbab5..4f927a6 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -29,6 +29,7 @@
  */
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/console.h>
 #include <linux/kernel.h>
 #include <linux/sysrq.h>
 #include <linux/slab.h>
@@ -41,6 +42,8 @@
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 
+#include "drm_crtc_helper_internal.h"
+
 static bool drm_fbdev_emulation = true;
 module_param_named(fbdev_emulation, drm_fbdev_emulation, bool, 0600);
 MODULE_PARM_DESC(fbdev_emulation,
@@ -2175,9 +2178,9 @@ EXPORT_SYMBOL(drm_fb_helper_hotplug_event);
  * but the module doesn't depend on any fb console symbols.  At least
  * attempt to load fbcon to avoid leaving the system without a usable console.
  */
-#if defined(CONFIG_FRAMEBUFFER_CONSOLE_MODULE) && !defined(CONFIG_EXPERT)
-static int __init drm_fb_helper_modinit(void)
+int __init drm_fb_helper_modinit(void)
 {
+#if defined(CONFIG_FRAMEBUFFER_CONSOLE_MODULE) && !defined(CONFIG_EXPERT)
 	const char *name = "fbcon";
 	struct module *fbcon;
 
@@ -2187,8 +2190,8 @@ static int __init drm_fb_helper_modinit(void)
 
 	if (!fbcon)
 		request_module_nowait(name);
+#endif
 	return 0;
 }
-
-module_init(drm_fb_helper_modinit);
-#endif
+EXPORT_SYMBOL(drm_fb_helper_modinit);
+//module_init(drm_fb_helper_modinit);
diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c
index 6b5625e..ddc8d6f 100644
--- a/drivers/gpu/drm/drm_fops.c
+++ b/drivers/gpu/drm/drm_fops.c
@@ -575,3 +575,5 @@ unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)
 	return mask;
 }
 EXPORT_SYMBOL(drm_poll);
+
+
diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c
index 8090989..d90b4f8 100644
--- a/drivers/gpu/drm/drm_irq.c
+++ b/drivers/gpu/drm/drm_irq.c
@@ -300,6 +300,37 @@ static void drm_update_vblank_count(struct drm_device *dev, unsigned int pipe,
 	store_vblank(dev, pipe, diff, &t_vblank, cur_vblank);
 }
 
+/**
+ * drm_accurate_vblank_count - retrieve the master vblank counter
+ * @crtc: which counter to retrieve
+ *
+ * This function is similar to @drm_crtc_vblank_count but this
+ * function interpolates to handle a race with vblank irq's.
+ *
+ * This is mostly useful for hardware that can obtain the scanout
+ * position, but doesn't have a frame counter.
+ */
+u32 drm_accurate_vblank_count(struct drm_crtc *crtc)
+{
+        struct drm_device *dev = crtc->dev;
+        unsigned int pipe = drm_crtc_index(crtc);
+        u32 vblank;
+        unsigned long flags;
+
+        WARN(!dev->driver->get_vblank_timestamp,
+             "This function requires support for accurate vblank timestamps.");
+
+        spin_lock_irqsave(&dev->vblank_time_lock, flags);
+
+        drm_update_vblank_count(dev, pipe, 0);
+        vblank = drm_vblank_count(dev, pipe);
+
+        spin_unlock_irqrestore(&dev->vblank_time_lock, flags);
+
+        return vblank;
+}
+EXPORT_SYMBOL(drm_accurate_vblank_count);
+
 /*
  * Disable vblank irq's on crtc, make sure that last vblank count
  * of hardware and corresponding consistent software vblank counter
diff --git a/drivers/gpu/drm/drm_kms_helper_common.c b/drivers/gpu/drm/drm_kms_helper_common.c
new file mode 100644
index 0000000..45db36c
--- /dev/null
+++ b/drivers/gpu/drm/drm_kms_helper_common.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright Â© 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rafael Antognolli <rafael.antognolli@intel.com>
+ *
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_fb_helper.h>
+
+#include "drm_crtc_helper_internal.h"
+
+MODULE_AUTHOR("David Airlie, Jesse Barnes");
+MODULE_DESCRIPTION("DRM KMS helper");
+MODULE_LICENSE("GPL and additional rights");
+
+static int __init drm_kms_helper_init(void)
+{
+	int ret;
+
+	/* Call init functions from specific kms helpers here */
+	ret = drm_fb_helper_modinit();
+	if (ret < 0)
+		goto out;
+
+	ret = drm_dp_aux_dev_init();
+	if (ret < 0)
+		goto out;
+
+out:
+	return ret;
+}
+
+static void __exit drm_kms_helper_exit(void)
+{
+	/* Call exit functions from specific kms helpers here */
+	drm_dp_aux_dev_exit();
+}
+
+module_init(drm_kms_helper_init);
+module_exit(drm_kms_helper_exit);
diff --git a/drivers/gpu/drm/drm_modeset_helper.c b/drivers/gpu/drm/drm_modeset_helper.c
new file mode 100644
index 0000000..ad40696
--- /dev/null
+++ b/drivers/gpu/drm/drm_modeset_helper.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <drm/drm_modeset_helper.h>
+#include <drm/drm_plane_helper.h>
+
+/*
+ * This is the minimal list of formats that seem to be safe for modeset use
+ * with all current DRM drivers.  Most hardware can actually support more
+ * formats than this and drivers may specify a more accurate list when
+ * creating the primary plane.  However drivers that still call
+ * drm_plane_init() will use this minimal format list as the default.
+ */
+static const uint32_t safe_modeset_formats[] = {
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+};
+
+static struct drm_plane *create_primary_plane(struct drm_device *dev)
+{
+	struct drm_plane *primary;
+	int ret;
+
+	primary = kzalloc(sizeof(*primary), GFP_KERNEL);
+	if (primary == NULL) {
+		DRM_DEBUG_KMS("Failed to allocate primary plane\n");
+		return NULL;
+	}
+
+	/*
+	 * Remove the format_default field from drm_plane when dropping
+	 * this helper.
+	 */
+	primary->format_default = true;
+
+	/* possible_crtc's will be filled in later by crtc_init */
+	ret = drm_universal_plane_init(dev, primary, 0,
+				       &drm_primary_helper_funcs,
+				       safe_modeset_formats,
+				       ARRAY_SIZE(safe_modeset_formats),
+				       DRM_PLANE_TYPE_PRIMARY);
+	if (ret) {
+		kfree(primary);
+		primary = NULL;
+	}
+
+	return primary;
+}
diff --git a/drivers/gpu/drm/drm_plane_helper.c b/drivers/gpu/drm/drm_plane_helper.c
index d384ebc..2a1e6b9 100644
--- a/drivers/gpu/drm/drm_plane_helper.c
+++ b/drivers/gpu/drm/drm_plane_helper.c
@@ -104,6 +104,104 @@ static int get_connectors_for_crtc(struct drm_crtc *crtc,
 }
 
 /**
+ * drm_plane_helper_check_state() - Check plane state for validity
+ * @state: plane state to check
+ * @clip: integer clipping coordinates
+ * @min_scale: minimum @src:@dest scaling factor in 16.16 fixed point
+ * @max_scale: maximum @src:@dest scaling factor in 16.16 fixed point
+ * @can_position: is it legal to position the plane such that it
+ *                doesn't cover the entire crtc?  This will generally
+ *                only be false for primary planes.
+ * @can_update_disabled: can the plane be updated while the crtc
+ *                       is disabled?
+ *
+ * Checks that a desired plane update is valid, and updates various
+ * bits of derived state (clipped coordinates etc.). Drivers that provide
+ * their own plane handling rather than helper-provided implementations may
+ * still wish to call this function to avoid duplication of error checking
+ * code.
+ *
+ * RETURNS:
+ * Zero if update appears valid, error code on failure
+ */
+int drm_plane_helper_check_state(struct drm_plane_state *state,
+                                 const struct drm_rect *clip,
+                                 int min_scale,
+                                 int max_scale,
+                                 bool can_position,
+                                 bool can_update_disabled)
+{
+        struct drm_crtc *crtc = state->crtc;
+        struct drm_framebuffer *fb = state->fb;
+        struct drm_rect *src = &state->src;
+        struct drm_rect *dst = &state->dst;
+        unsigned int rotation = state->rotation;
+        int hscale, vscale;
+
+        src->x1 = state->src_x;
+        src->y1 = state->src_y;
+        src->x2 = state->src_x + state->src_w;
+        src->y2 = state->src_y + state->src_h;
+
+        dst->x1 = state->crtc_x;
+        dst->y1 = state->crtc_y;
+        dst->x2 = state->crtc_x + state->crtc_w;
+        dst->y2 = state->crtc_y + state->crtc_h;
+
+        if (!fb) {
+                state->visible = false;
+                return 0;
+        }
+
+        /* crtc should only be NULL when disabling (i.e., !fb) */
+        if (WARN_ON(!crtc)) {
+                state->visible = false;
+                return 0;
+        }
+
+        if (!crtc->enabled && !can_update_disabled) {
+                DRM_DEBUG_KMS("Cannot update plane of a disabled CRTC.\n");
+                return -EINVAL;
+        }
+
+        drm_rect_rotate(src, fb->width << 16, fb->height << 16, rotation);
+
+        /* Check scaling */
+        hscale = drm_rect_calc_hscale(src, dst, min_scale, max_scale);
+        vscale = drm_rect_calc_vscale(src, dst, min_scale, max_scale);
+        if (hscale < 0 || vscale < 0) {
+                DRM_DEBUG_KMS("Invalid scaling of plane\n");
+                //drm_rect_debug_print("src: ", &state->src, true);
+                //drm_rect_debug_print("dst: ", &state->dst, false);
+                return -ERANGE;
+        }
+
+        state->visible = drm_rect_clip_scaled(src, dst, clip, hscale, vscale);
+
+        drm_rect_rotate_inv(src, fb->width << 16, fb->height << 16, rotation);
+
+        if (!state->visible)
+                /*
+                 * Plane isn't visible; some drivers can handle this
+                 * so we just return success here.  Drivers that can't
+                 * (including those that use the primary plane helper's
+                 * update function) will return an error from their
+                 * update_plane handler.
+                 */
+                return 0;
+
+        if (!can_position && !drm_rect_equals(dst, clip)) {
+                DRM_DEBUG_KMS("Plane must cover entire CRTC\n");
+                //drm_rect_debug_print("dst: ", dst, false);
+                //drm_rect_debug_print("clip: ", clip, false);
+                return -EINVAL;
+        }
+
+        return 0;
+}
+EXPORT_SYMBOL(drm_plane_helper_check_state);
+
+/**
  * drm_plane_helper_check_update() - Check plane update for validity
  * @plane: plane object to update
  * @crtc: owning CRTC of owning plane
diff --git a/drivers/gpu/drm/drm_simple_kms_helper.c b/drivers/gpu/drm/drm_simple_kms_helper.c
new file mode 100644
index 0000000..23894bd
--- /dev/null
+++ b/drivers/gpu/drm/drm_simple_kms_helper.c
@@ -0,0 +1,270 @@
+/*
+ * Copyright (C) 2016 Noralf TrÃ¸nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+#include <linux/slab.h>
+#include <drm/drm_bridge.h>
+
+/**
+ * DOC: overview
+ *
+ * This helper library provides helpers for drivers for simple display
+ * hardware.
+ *
+ * drm_simple_display_pipe_init() initializes a simple display pipeline
+ * which has only one full-screen scanout buffer feeding one output. The
+ * pipeline is represented by struct &drm_simple_display_pipe and binds
+ * together &drm_plane, &drm_crtc and &drm_encoder structures into one fixed
+ * entity. Some flexibility for code reuse is provided through a separately
+ * allocated &drm_connector object and supporting optional &drm_bridge
+ * encoder drivers.
+ */
+
+static const struct drm_encoder_funcs drm_simple_kms_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static int drm_simple_kms_crtc_check(struct drm_crtc *crtc,
+				     struct drm_crtc_state *state)
+{
+	return drm_atomic_add_affected_planes(state->state, crtc);
+}
+
+static void drm_simple_kms_crtc_enable(struct drm_crtc *crtc)
+{
+	struct drm_simple_display_pipe *pipe;
+
+	pipe = container_of(crtc, struct drm_simple_display_pipe, crtc);
+	if (!pipe->funcs || !pipe->funcs->enable)
+		return;
+
+	pipe->funcs->enable(pipe, crtc->state);
+}
+
+static void drm_simple_kms_crtc_disable(struct drm_crtc *crtc)
+{
+	struct drm_simple_display_pipe *pipe;
+
+	pipe = container_of(crtc, struct drm_simple_display_pipe, crtc);
+	if (!pipe->funcs || !pipe->funcs->disable)
+		return;
+
+	pipe->funcs->disable(pipe);
+}
+
+static const struct drm_crtc_helper_funcs drm_simple_kms_crtc_helper_funcs = {
+	.atomic_check = drm_simple_kms_crtc_check,
+	.disable = drm_simple_kms_crtc_disable,
+	.enable = drm_simple_kms_crtc_enable,
+};
+
+static const struct drm_crtc_funcs drm_simple_kms_crtc_funcs = {
+	.reset = drm_atomic_helper_crtc_reset,
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+};
+
+static int drm_simple_kms_plane_atomic_check(struct drm_plane *plane,
+					struct drm_plane_state *plane_state)
+{
+	struct drm_rect clip = { 0 };
+	struct drm_simple_display_pipe *pipe;
+	struct drm_crtc_state *crtc_state;
+	int ret;
+
+	pipe = container_of(plane, struct drm_simple_display_pipe, plane);
+	crtc_state = drm_atomic_get_existing_crtc_state(plane_state->state,
+							&pipe->crtc);
+	if (crtc_state->enable != !!plane_state->crtc)
+		return -EINVAL; /* plane must match crtc enable state */
+
+	if (!crtc_state->enable)
+		return 0; /* nothing to check when disabling or disabled */
+
+	clip.x2 = crtc_state->adjusted_mode.hdisplay;
+	clip.y2 = crtc_state->adjusted_mode.vdisplay;
+
+	ret = drm_plane_helper_check_state(plane_state, &clip,
+					   DRM_PLANE_HELPER_NO_SCALING,
+					   DRM_PLANE_HELPER_NO_SCALING,
+					   false, true);
+	if (ret)
+		return ret;
+
+	if (!plane_state->visible)
+		return -EINVAL;
+
+	if (!pipe->funcs || !pipe->funcs->check)
+		return 0;
+
+	return pipe->funcs->check(pipe, plane_state, crtc_state);
+}
+
+static void drm_simple_kms_plane_atomic_update(struct drm_plane *plane,
+					struct drm_plane_state *pstate)
+{
+	struct drm_simple_display_pipe *pipe;
+
+	pipe = container_of(plane, struct drm_simple_display_pipe, plane);
+	if (!pipe->funcs || !pipe->funcs->update)
+		return;
+
+	pipe->funcs->update(pipe, pstate);
+}
+
+static int drm_simple_kms_plane_prepare_fb(struct drm_plane *plane,
+					   struct drm_plane_state *state)
+{
+	struct drm_simple_display_pipe *pipe;
+
+	pipe = container_of(plane, struct drm_simple_display_pipe, plane);
+	if (!pipe->funcs || !pipe->funcs->prepare_fb)
+		return 0;
+
+	return pipe->funcs->prepare_fb(pipe, state);
+}
+
+static void drm_simple_kms_plane_cleanup_fb(struct drm_plane *plane,
+					    struct drm_plane_state *state)
+{
+	struct drm_simple_display_pipe *pipe;
+
+	pipe = container_of(plane, struct drm_simple_display_pipe, plane);
+	if (!pipe->funcs || !pipe->funcs->cleanup_fb)
+		return;
+
+	pipe->funcs->cleanup_fb(pipe, state);
+}
+
+static const struct drm_plane_helper_funcs drm_simple_kms_plane_helper_funcs = {
+	.prepare_fb = drm_simple_kms_plane_prepare_fb,
+	.cleanup_fb = drm_simple_kms_plane_cleanup_fb,
+	.atomic_check = drm_simple_kms_plane_atomic_check,
+	.atomic_update = drm_simple_kms_plane_atomic_update,
+};
+
+static const struct drm_plane_funcs drm_simple_kms_plane_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
+};
+
+/**
+ * drm_simple_display_pipe_attach_bridge - Attach a bridge to the display pipe
+ * @pipe: simple display pipe object
+ * @bridge: bridge to attach
+ *
+ * Makes it possible to still use the drm_simple_display_pipe helpers when
+ * a DRM bridge has to be used.
+ *
+ * Note that you probably want to initialize the pipe by passing a NULL
+ * connector to drm_simple_display_pipe_init().
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int drm_simple_display_pipe_attach_bridge(struct drm_simple_display_pipe *pipe,
+					  struct drm_bridge *bridge)
+{
+	bridge->encoder = &pipe->encoder;
+	pipe->encoder.bridge = bridge;
+	return drm_bridge_attach(pipe->encoder.dev, bridge);
+}
+EXPORT_SYMBOL(drm_simple_display_pipe_attach_bridge);
+
+/**
+ * drm_simple_display_pipe_detach_bridge - Detach the bridge from the display pipe
+ * @pipe: simple display pipe object
+ *
+ * Detaches the drm bridge previously attached with
+ * drm_simple_display_pipe_attach_bridge()
+ */
+void drm_simple_display_pipe_detach_bridge(struct drm_simple_display_pipe *pipe)
+{
+	if (WARN_ON(!pipe->encoder.bridge))
+		return;
+
+	drm_bridge_detach(pipe->encoder.bridge);
+	pipe->encoder.bridge = NULL;
+}
+EXPORT_SYMBOL(drm_simple_display_pipe_detach_bridge);
+
+/**
+ * drm_simple_display_pipe_init - Initialize a simple display pipeline
+ * @dev: DRM device
+ * @pipe: simple display pipe object to initialize
+ * @funcs: callbacks for the display pipe (optional)
+ * @formats: array of supported formats (DRM_FORMAT\_\*)
+ * @format_count: number of elements in @formats
+ * @connector: connector to attach and register (optional)
+ *
+ * Sets up a display pipeline which consist of a really simple
+ * plane-crtc-encoder pipe.
+ *
+ * If a connector is supplied, the pipe will be coupled with the provided
+ * connector. You may supply a NULL connector when using drm bridges, that
+ * handle connectors themselves (see drm_simple_display_pipe_attach_bridge()).
+ *
+ * Teardown of a simple display pipe is all handled automatically by the drm
+ * core through calling drm_mode_config_cleanup(). Drivers afterwards need to
+ * release the memory for the structure themselves.
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+int drm_simple_display_pipe_init(struct drm_device *dev,
+			struct drm_simple_display_pipe *pipe,
+			const struct drm_simple_display_pipe_funcs *funcs,
+			const uint32_t *formats, unsigned int format_count,
+			struct drm_connector *connector)
+{
+	struct drm_encoder *encoder = &pipe->encoder;
+	struct drm_plane *plane = &pipe->plane;
+	struct drm_crtc *crtc = &pipe->crtc;
+	int ret;
+
+	pipe->connector = connector;
+	pipe->funcs = funcs;
+
+	drm_plane_helper_add(plane, &drm_simple_kms_plane_helper_funcs);
+	ret = drm_universal_plane_init(dev, plane, 0,
+				       &drm_simple_kms_plane_funcs,
+				       formats, format_count,
+				       DRM_PLANE_TYPE_PRIMARY);
+	if (ret)
+		return ret;
+
+	drm_crtc_helper_add(crtc, &drm_simple_kms_crtc_helper_funcs);
+	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
+					&drm_simple_kms_crtc_funcs);
+	if (ret)
+		return ret;
+
+	encoder->possible_crtcs = 1 << drm_crtc_index(crtc);
+	ret = drm_encoder_init(dev, encoder, &drm_simple_kms_encoder_funcs,
+			       DRM_MODE_ENCODER_NONE);
+	if (ret || !connector)
+		return ret;
+
+	return drm_mode_connector_attach_encoder(connector, encoder);
+}
+EXPORT_SYMBOL(drm_simple_display_pipe_init);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index 5b6a6f5..f4d9018 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
@@ -93,7 +93,7 @@
  *   2.43.0 - RADEON_INFO_GPU_RESET_COUNTER
  */
 #define KMS_DRIVER_MAJOR	2
-#define KMS_DRIVER_MINOR	43
+#define KMS_DRIVER_MINOR	49
 #define KMS_DRIVER_PATCHLEVEL	0
 int radeon_driver_load_kms(struct drm_device *dev, unsigned long flags);
 int radeon_driver_unload_kms(struct drm_device *dev);
@@ -375,6 +375,8 @@ static struct drm_driver driver_old = {
 
 static struct drm_driver kms_driver;
 
+bool radeon_device_is_virtual(void);
+
 static int radeon_kick_out_firmware_fb(struct pci_dev *pdev)
 {
 	struct apertures_struct *ap;
@@ -417,6 +419,16 @@ radeon_pci_remove(struct pci_dev *pdev)
 	drm_put_dev(dev);
 }
 
+static void
+radeon_pci_shutdown(struct pci_dev *pdev)
+{
+        /* if we are running in a VM, make sure the device
+         * torn down properly on reboot/shutdown
+         */
+        if (radeon_device_is_virtual())
+                radeon_pci_remove(pdev);
+}
+
 static int radeon_pmops_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
diff --git a/drivers/gpu/drm/radeon/radeon_object.c b/drivers/gpu/drm/radeon/radeon_object.c
index fb6ad14..c45cbbe 100644
--- a/drivers/gpu/drm/radeon/radeon_object.c
+++ b/drivers/gpu/drm/radeon/radeon_object.c
@@ -760,6 +760,7 @@ int radeon_bo_check_tiling(struct radeon_bo *bo, bool has_moved,
 }
 
 void radeon_bo_move_notify(struct ttm_buffer_object *bo,
+			   bool evict,
 			   struct ttm_mem_reg *new_mem)
 {
 	struct radeon_bo *rbo;
diff --git a/drivers/gpu/drm/radeon/radeon_object.h b/drivers/gpu/drm/radeon/radeon_object.h
index d8d295e..5e06ed4 100644
--- a/drivers/gpu/drm/radeon/radeon_object.h
+++ b/drivers/gpu/drm/radeon/radeon_object.h
@@ -150,6 +150,7 @@ extern void radeon_bo_get_tiling_flags(struct radeon_bo *bo,
 extern int radeon_bo_check_tiling(struct radeon_bo *bo, bool has_moved,
 				bool force_drop);
 extern void radeon_bo_move_notify(struct ttm_buffer_object *bo,
+				  bool evict,
 				  struct ttm_mem_reg *new_mem);
 extern int radeon_bo_fault_reserve_notify(struct ttm_buffer_object *bo);
 extern int radeon_bo_get_surface_reg(struct radeon_bo *bo);
diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c
index f342aad..0c20a50 100644
--- a/drivers/gpu/drm/radeon/radeon_ttm.c
+++ b/drivers/gpu/drm/radeon/radeon_ttm.c
@@ -492,6 +492,8 @@ static int radeon_ttm_io_mem_reserve(struct ttm_bo_device *bdev, struct ttm_mem_
 			mem->bus.addr =
 				ioremap_nocache(mem->bus.base + mem->bus.offset,
 						mem->bus.size);
+		if (!mem->bus.addr)
+			return -ENOMEM;
 
 		/*
 		 * Alpha: Use just the bus offset plus
diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c
index f878d69..2a1af71 100644
--- a/drivers/gpu/drm/radeon/si.c
+++ b/drivers/gpu/drm/radeon/si.c
@@ -111,6 +111,8 @@ MODULE_FIRMWARE("radeon/hainan_mc.bin");
 MODULE_FIRMWARE("radeon/hainan_rlc.bin");
 MODULE_FIRMWARE("radeon/hainan_smc.bin");
 
+MODULE_FIRMWARE("radeon/si58_mc.bin");
+
 static u32 si_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh);
 static void si_pcie_gen3_enable(struct radeon_device *rdev);
 static void si_program_aspm(struct radeon_device *rdev);
@@ -1646,265 +1648,313 @@ int si_mc_load_microcode(struct radeon_device *rdev)
 
 static int si_init_microcode(struct radeon_device *rdev)
 {
-	const char *chip_name;
-	const char *new_chip_name;
-	size_t pfp_req_size, me_req_size, ce_req_size, rlc_req_size, mc_req_size;
-	size_t smc_req_size, mc2_req_size;
-	char fw_name[30];
-	int err;
-	int new_fw = 0;
-
-	DRM_DEBUG("\n");
+        const char *chip_name;
+        const char *new_chip_name;
+        size_t pfp_req_size, me_req_size, ce_req_size, rlc_req_size, mc_req_size;
+        size_t smc_req_size, mc2_req_size;
+        char fw_name[30];
+        int err;
+        int new_fw = 0;
+        bool new_smc = false;
+        bool si58_fw = false;
+        bool banks2_fw = false;
+
+        DRM_DEBUG("\n");
+
+        switch (rdev->family) {
+        case CHIP_TAHITI:
+                chip_name = "TAHITI";
+                new_chip_name = "tahiti";
+                pfp_req_size = SI_PFP_UCODE_SIZE * 4;
+                me_req_size = SI_PM4_UCODE_SIZE * 4;
+                ce_req_size = SI_CE_UCODE_SIZE * 4;
+                rlc_req_size = SI_RLC_UCODE_SIZE * 4;
+                mc_req_size = SI_MC_UCODE_SIZE * 4;
+                mc2_req_size = TAHITI_MC_UCODE_SIZE * 4;
+                smc_req_size = ALIGN(TAHITI_SMC_UCODE_SIZE, 4);
+                break;
+        case CHIP_PITCAIRN:
+                chip_name = "PITCAIRN";
+                if ((rdev->pdev->revision == 0x81) &&
+                    ((rdev->pdev->device == 0x6810) ||
+                     (rdev->pdev->device == 0x6811)))
+                        new_smc = true;
+                new_chip_name = "pitcairn";
+                pfp_req_size = SI_PFP_UCODE_SIZE * 4;
+                me_req_size = SI_PM4_UCODE_SIZE * 4;
+                ce_req_size = SI_CE_UCODE_SIZE * 4;
+                rlc_req_size = SI_RLC_UCODE_SIZE * 4;
+                mc_req_size = SI_MC_UCODE_SIZE * 4;
+                mc2_req_size = PITCAIRN_MC_UCODE_SIZE * 4;
+                smc_req_size = ALIGN(PITCAIRN_SMC_UCODE_SIZE, 4);
+                break;
+        case CHIP_VERDE:
+                chip_name = "VERDE";
+                if (((rdev->pdev->device == 0x6820) &&
+                     ((rdev->pdev->revision == 0x81) ||
+                      (rdev->pdev->revision == 0x83))) ||
+                    ((rdev->pdev->device == 0x6821) &&
+                     ((rdev->pdev->revision == 0x83) ||
+                      (rdev->pdev->revision == 0x87))) ||
+                    ((rdev->pdev->revision == 0x87) &&
+                     ((rdev->pdev->device == 0x6823) ||
+                      (rdev->pdev->device == 0x682b))))
+                        new_smc = true;
+                new_chip_name = "verde";
+                pfp_req_size = SI_PFP_UCODE_SIZE * 4;
+                me_req_size = SI_PM4_UCODE_SIZE * 4;
+                ce_req_size = SI_CE_UCODE_SIZE * 4;
+                rlc_req_size = SI_RLC_UCODE_SIZE * 4;
+                mc_req_size = SI_MC_UCODE_SIZE * 4;
+                mc2_req_size = VERDE_MC_UCODE_SIZE * 4;
+                smc_req_size = ALIGN(VERDE_SMC_UCODE_SIZE, 4);
+                break;
+        case CHIP_OLAND:
+                chip_name = "OLAND";
+                if (((rdev->pdev->revision == 0x81) &&
+                     ((rdev->pdev->device == 0x6600) ||
+                      (rdev->pdev->device == 0x6604) ||
+                      (rdev->pdev->device == 0x6605) ||
+                      (rdev->pdev->device == 0x6610))) ||
+                    ((rdev->pdev->revision == 0x83) &&
+                     (rdev->pdev->device == 0x6610)))
+                        new_smc = true;
+                new_chip_name = "oland";
+                pfp_req_size = SI_PFP_UCODE_SIZE * 4;
+                me_req_size = SI_PM4_UCODE_SIZE * 4;
+                ce_req_size = SI_CE_UCODE_SIZE * 4;
+                rlc_req_size = SI_RLC_UCODE_SIZE * 4;
+                mc_req_size = mc2_req_size = OLAND_MC_UCODE_SIZE * 4;
+                smc_req_size = ALIGN(OLAND_SMC_UCODE_SIZE, 4);
+                break;
+        case CHIP_HAINAN:
+                chip_name = "HAINAN";
+                if (((rdev->pdev->revision == 0x81) &&
+                     (rdev->pdev->device == 0x6660)) ||
+                    ((rdev->pdev->revision == 0x83) &&
+                     ((rdev->pdev->device == 0x6660) ||
+                      (rdev->pdev->device == 0x6663) ||
+                      (rdev->pdev->device == 0x6665) ||
+                      (rdev->pdev->device == 0x6667))))
+                        new_smc = true;
+                else if ((rdev->pdev->revision == 0xc3) &&
+                         (rdev->pdev->device == 0x6665))
+                        banks2_fw = true;
+                new_chip_name = "hainan";
+                pfp_req_size = SI_PFP_UCODE_SIZE * 4;
+                me_req_size = SI_PM4_UCODE_SIZE * 4;
+                ce_req_size = SI_CE_UCODE_SIZE * 4;
+                rlc_req_size = SI_RLC_UCODE_SIZE * 4;
+                mc_req_size = mc2_req_size = OLAND_MC_UCODE_SIZE * 4;
+                smc_req_size = ALIGN(HAINAN_SMC_UCODE_SIZE, 4);
+                break;
+        default: BUG();
+        }
 
-	switch (rdev->family) {
-	case CHIP_TAHITI:
-		chip_name = "TAHITI";
-		new_chip_name = "tahiti";
-		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
-		me_req_size = SI_PM4_UCODE_SIZE * 4;
-		ce_req_size = SI_CE_UCODE_SIZE * 4;
-		rlc_req_size = SI_RLC_UCODE_SIZE * 4;
-		mc_req_size = SI_MC_UCODE_SIZE * 4;
-		mc2_req_size = TAHITI_MC_UCODE_SIZE * 4;
-		smc_req_size = ALIGN(TAHITI_SMC_UCODE_SIZE, 4);
-		break;
-	case CHIP_PITCAIRN:
-		chip_name = "PITCAIRN";
-		new_chip_name = "pitcairn";
-		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
-		me_req_size = SI_PM4_UCODE_SIZE * 4;
-		ce_req_size = SI_CE_UCODE_SIZE * 4;
-		rlc_req_size = SI_RLC_UCODE_SIZE * 4;
-		mc_req_size = SI_MC_UCODE_SIZE * 4;
-		mc2_req_size = PITCAIRN_MC_UCODE_SIZE * 4;
-		smc_req_size = ALIGN(PITCAIRN_SMC_UCODE_SIZE, 4);
-		break;
-	case CHIP_VERDE:
-		chip_name = "VERDE";
-		new_chip_name = "verde";
-		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
-		me_req_size = SI_PM4_UCODE_SIZE * 4;
-		ce_req_size = SI_CE_UCODE_SIZE * 4;
-		rlc_req_size = SI_RLC_UCODE_SIZE * 4;
-		mc_req_size = SI_MC_UCODE_SIZE * 4;
-		mc2_req_size = VERDE_MC_UCODE_SIZE * 4;
-		smc_req_size = ALIGN(VERDE_SMC_UCODE_SIZE, 4);
-		break;
-	case CHIP_OLAND:
-		chip_name = "OLAND";
-		new_chip_name = "oland";
-		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
-		me_req_size = SI_PM4_UCODE_SIZE * 4;
-		ce_req_size = SI_CE_UCODE_SIZE * 4;
-		rlc_req_size = SI_RLC_UCODE_SIZE * 4;
-		mc_req_size = mc2_req_size = OLAND_MC_UCODE_SIZE * 4;
-		smc_req_size = ALIGN(OLAND_SMC_UCODE_SIZE, 4);
-		break;
-	case CHIP_HAINAN:
-		chip_name = "HAINAN";
-		new_chip_name = "hainan";
-		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
-		me_req_size = SI_PM4_UCODE_SIZE * 4;
-		ce_req_size = SI_CE_UCODE_SIZE * 4;
-		rlc_req_size = SI_RLC_UCODE_SIZE * 4;
-		mc_req_size = mc2_req_size = OLAND_MC_UCODE_SIZE * 4;
-		smc_req_size = ALIGN(HAINAN_SMC_UCODE_SIZE, 4);
-		break;
-	default: BUG();
-	}
-
-	DRM_INFO("Loading %s Microcode\n", new_chip_name);
-
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_pfp.bin", new_chip_name);
-	err = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);
-	if (err) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_pfp.bin", chip_name);
-		err = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);
-		if (err)
-			goto out;
-		if (rdev->pfp_fw->size != pfp_req_size) {
-			printk(KERN_ERR
-			       "si_cp: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->pfp_fw->size, fw_name);
-			err = -EINVAL;
-			goto out;
-		}
-	} else {
-		err = radeon_ucode_validate(rdev->pfp_fw);
-		if (err) {
-			printk(KERN_ERR
-			       "si_cp: validation failed for firmware \"%s\"\n",
-			       fw_name);
-			goto out;
-		} else {
-			new_fw++;
-		}
-	}
+        /* this memory configuration requires special firmware */
+        if (((RREG32(MC_SEQ_MISC0) & 0xff000000) >> 24) == 0x58)
+                si58_fw = true;
+
+        DRM_INFO("Loading %s Microcode\n", new_chip_name);
+
+        snprintf(fw_name, sizeof(fw_name), "radeon/%s_pfp.bin", new_chip_name);
+        err = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);
+        if (err) {
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_pfp.bin", chip_name);
+                err = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);
+                if (err)
+                        goto out;
+                if (rdev->pfp_fw->size != pfp_req_size) {
+                        printk(KERN_ERR
+                               "si_cp: Bogus length %zu in firmware \"%s\"\n",
+                               rdev->pfp_fw->size, fw_name);
+                        err = -EINVAL;
+                        goto out;
+                }
+        } else {
+                err = radeon_ucode_validate(rdev->pfp_fw);
+                if (err) {
+                        printk(KERN_ERR
+                               "si_cp: validation failed for firmware \"%s\"\n",
+                               fw_name);
+                        goto out;
+                } else {
+                        new_fw++;
+                }
+        }
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_me.bin", new_chip_name);
-	err = request_firmware(&rdev->me_fw, fw_name, rdev->dev);
-	if (err) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_me.bin", chip_name);
-		err = request_firmware(&rdev->me_fw, fw_name, rdev->dev);
-		if (err)
-			goto out;
-		if (rdev->me_fw->size != me_req_size) {
-			printk(KERN_ERR
-			       "si_cp: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->me_fw->size, fw_name);
-			err = -EINVAL;
-		}
-	} else {
-		err = radeon_ucode_validate(rdev->me_fw);
-		if (err) {
-			printk(KERN_ERR
-			       "si_cp: validation failed for firmware \"%s\"\n",
-			       fw_name);
-			goto out;
-		} else {
-			new_fw++;
-		}
-	}
+        snprintf(fw_name, sizeof(fw_name), "radeon/%s_me.bin", new_chip_name);
+        err = request_firmware(&rdev->me_fw, fw_name, rdev->dev);
+        if (err) {
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_me.bin", chip_name);
+                err = request_firmware(&rdev->me_fw, fw_name, rdev->dev);
+                if (err)
+                        goto out;
+                if (rdev->me_fw->size != me_req_size) {
+                        printk(KERN_ERR
+                               "si_cp: Bogus length %zu in firmware \"%s\"\n",
+                               rdev->me_fw->size, fw_name);
+                        err = -EINVAL;
+                }
+        } else {
+                err = radeon_ucode_validate(rdev->me_fw);
+                if (err) {
+                        printk(KERN_ERR
+                               "si_cp: validation failed for firmware \"%s\"\n",
+                               fw_name);
+                        goto out;
+                } else {
+                        new_fw++;
+                }
+        }
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_ce.bin", new_chip_name);
-	err = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);
-	if (err) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_ce.bin", chip_name);
-		err = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);
-		if (err)
-			goto out;
-		if (rdev->ce_fw->size != ce_req_size) {
-			printk(KERN_ERR
-			       "si_cp: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->ce_fw->size, fw_name);
-			err = -EINVAL;
-		}
-	} else {
-		err = radeon_ucode_validate(rdev->ce_fw);
-		if (err) {
-			printk(KERN_ERR
-			       "si_cp: validation failed for firmware \"%s\"\n",
-			       fw_name);
-			goto out;
-		} else {
-			new_fw++;
-		}
-	}
+        snprintf(fw_name, sizeof(fw_name), "radeon/%s_ce.bin", new_chip_name);
+        err = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);
+        if (err) {
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_ce.bin", chip_name);
+                err = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);
+                if (err)
+                        goto out;
+                if (rdev->ce_fw->size != ce_req_size) {
+                        printk(KERN_ERR
+                               "si_cp: Bogus length %zu in firmware \"%s\"\n",
+                               rdev->ce_fw->size, fw_name);
+                        err = -EINVAL;
+                }
+        } else {
+                err = radeon_ucode_validate(rdev->ce_fw);
+                if (err) {
+                        printk(KERN_ERR
+                               "si_cp: validation failed for firmware \"%s\"\n",
+                               fw_name);
+                        goto out;
+                } else {
+                        new_fw++;
+                }
+        }
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_rlc.bin", new_chip_name);
-	err = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);
-	if (err) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_rlc.bin", chip_name);
-		err = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);
-		if (err)
-			goto out;
-		if (rdev->rlc_fw->size != rlc_req_size) {
-			printk(KERN_ERR
-			       "si_rlc: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->rlc_fw->size, fw_name);
-			err = -EINVAL;
-		}
-	} else {
-		err = radeon_ucode_validate(rdev->rlc_fw);
-		if (err) {
-			printk(KERN_ERR
-			       "si_cp: validation failed for firmware \"%s\"\n",
-			       fw_name);
-			goto out;
-		} else {
-			new_fw++;
-		}
-	}
+        snprintf(fw_name, sizeof(fw_name), "radeon/%s_rlc.bin", new_chip_name);
+        err = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);
+        if (err) {
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_rlc.bin", chip_name);
+                err = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);
+                if (err)
+                        goto out;
+                if (rdev->rlc_fw->size != rlc_req_size) {
+                        printk(KERN_ERR
+                               "si_rlc: Bogus length %zu in firmware \"%s\"\n",
+                               rdev->rlc_fw->size, fw_name);
+                        err = -EINVAL;
+                }
+        } else {
+                err = radeon_ucode_validate(rdev->rlc_fw);
+                if (err) {
+                        printk(KERN_ERR
+                               "si_cp: validation failed for firmware \"%s\"\n",
+                               fw_name);
+                        goto out;
+                } else {
+                        new_fw++;
+                }
+        }
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_mc.bin", new_chip_name);
-	err = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);
-	if (err) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_mc2.bin", chip_name);
-		err = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);
-		if (err) {
-			snprintf(fw_name, sizeof(fw_name), "radeon/%s_mc.bin", chip_name);
-			err = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);
-			if (err)
-				goto out;
-		}
-		if ((rdev->mc_fw->size != mc_req_size) &&
-		    (rdev->mc_fw->size != mc2_req_size)) {
-			printk(KERN_ERR
-			       "si_mc: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->mc_fw->size, fw_name);
-			err = -EINVAL;
-		}
-		DRM_INFO("%s: %zu bytes\n", fw_name, rdev->mc_fw->size);
-	} else {
-		err = radeon_ucode_validate(rdev->mc_fw);
-		if (err) {
-			printk(KERN_ERR
-			       "si_cp: validation failed for firmware \"%s\"\n",
-			       fw_name);
-			goto out;
-		} else {
-			new_fw++;
-		}
-	}
+        if (si58_fw)
+                snprintf(fw_name, sizeof(fw_name), "radeon/si58_mc.bin");
+        else
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_mc.bin", new_chip_name);
+        err = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);
+        if (err) {
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_mc2.bin", chip_name);
+                err = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);
+                if (err) {
+                        snprintf(fw_name, sizeof(fw_name), "radeon/%s_mc.bin", chip_name);
+                        err = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);
+                        if (err)
+                                goto out;
+                }
+                if ((rdev->mc_fw->size != mc_req_size) &&
+                    (rdev->mc_fw->size != mc2_req_size)) {
+                        printk(KERN_ERR
+                               "si_mc: Bogus length %zu in firmware \"%s\"\n",
+                               rdev->mc_fw->size, fw_name);
+                        err = -EINVAL;
+                }
+                DRM_INFO("%s: %zu bytes\n", fw_name, rdev->mc_fw->size);
+        } else {
+                err = radeon_ucode_validate(rdev->mc_fw);
+                if (err) {
+                        printk(KERN_ERR
+                               "si_cp: validation failed for firmware \"%s\"\n",
+                               fw_name);
+                        goto out;
+                } else {
+                        new_fw++;
+                }
+        }
 
-	snprintf(fw_name, sizeof(fw_name), "radeon/%s_smc.bin", new_chip_name);
-	err = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);
-	if (err) {
-		snprintf(fw_name, sizeof(fw_name), "radeon/%s_smc.bin", chip_name);
-		err = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);
-		if (err) {
-			printk(KERN_ERR
-			       "smc: error loading firmware \"%s\"\n",
-			       fw_name);
-			release_firmware(rdev->smc_fw);
-			rdev->smc_fw = NULL;
-			err = 0;
-		} else if (rdev->smc_fw->size != smc_req_size) {
-			printk(KERN_ERR
-			       "si_smc: Bogus length %zu in firmware \"%s\"\n",
-			       rdev->smc_fw->size, fw_name);
-			err = -EINVAL;
-		}
-	} else {
-		err = radeon_ucode_validate(rdev->smc_fw);
-		if (err) {
-			printk(KERN_ERR
-			       "si_cp: validation failed for firmware \"%s\"\n",
-			       fw_name);
-			goto out;
-		} else {
-			new_fw++;
-		}
-	}
+        if (banks2_fw)
+                snprintf(fw_name, sizeof(fw_name), "radeon/banks_k_2_smc.bin");
+        else if (new_smc)
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_k_smc.bin", new_chip_name);
+        else
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_smc.bin", new_chip_name);
+        err = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);
+        if (err) {
+                snprintf(fw_name, sizeof(fw_name), "radeon/%s_smc.bin", chip_name);
+                err = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);
+                if (err) {
+                        printk(KERN_ERR
+                               "smc: error loading firmware \"%s\"\n",
+                               fw_name);
+                        release_firmware(rdev->smc_fw);
+                        rdev->smc_fw = NULL;
+                        err = 0;
+                } else if (rdev->smc_fw->size != smc_req_size) {
+                        printk(KERN_ERR
+                               "si_smc: Bogus length %zu in firmware \"%s\"\n",
+                               rdev->smc_fw->size, fw_name);
+                        err = -EINVAL;
+                }
+        } else {
+                err = radeon_ucode_validate(rdev->smc_fw);
+                if (err) {
+                        printk(KERN_ERR
+                               "si_cp: validation failed for firmware \"%s\"\n",
+                               fw_name);
+                        goto out;
+                } else {
+                        new_fw++;
+                }
+        }
 
-	if (new_fw == 0) {
-		rdev->new_fw = false;
-	} else if (new_fw < 6) {
-		printk(KERN_ERR "si_fw: mixing new and old firmware!\n");
-		err = -EINVAL;
-	} else {
-		rdev->new_fw = true;
-	}
+        if (new_fw == 0) {
+                rdev->new_fw = false;
+        } else if (new_fw < 6) {
+                printk(KERN_ERR "si_fw: mixing new and old firmware!\n");
+                err = -EINVAL;
+        } else {
+                rdev->new_fw = true;
+        }
 out:
-	if (err) {
-		if (err != -EINVAL)
-			printk(KERN_ERR
-			       "si_cp: Failed to load firmware \"%s\"\n",
-			       fw_name);
-		release_firmware(rdev->pfp_fw);
-		rdev->pfp_fw = NULL;
-		release_firmware(rdev->me_fw);
-		rdev->me_fw = NULL;
-		release_firmware(rdev->ce_fw);
-		rdev->ce_fw = NULL;
-		release_firmware(rdev->rlc_fw);
-		rdev->rlc_fw = NULL;
-		release_firmware(rdev->mc_fw);
-		rdev->mc_fw = NULL;
-		release_firmware(rdev->smc_fw);
-		rdev->smc_fw = NULL;
-	}
-	return err;
+        if (err) {
+                if (err != -EINVAL)
+                        printk(KERN_ERR
+                               "si_cp: Failed to load firmware \"%s\"\n",
+                               fw_name);
+                release_firmware(rdev->pfp_fw);
+                rdev->pfp_fw = NULL;
+                release_firmware(rdev->me_fw);
+                rdev->me_fw = NULL;
+                release_firmware(rdev->ce_fw);
+                rdev->ce_fw = NULL;
+                release_firmware(rdev->rlc_fw);
+                rdev->rlc_fw = NULL;
+                release_firmware(rdev->mc_fw);
+                rdev->mc_fw = NULL;
+                release_firmware(rdev->smc_fw);
+                rdev->smc_fw = NULL;
+        }
+        return err;
 }
 
 /* watermark setup */
diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c
index caa73de..d5249b2 100644
--- a/drivers/gpu/drm/radeon/si_dpm.c
+++ b/drivers/gpu/drm/radeon/si_dpm.c
@@ -2912,29 +2912,6 @@ static int si_init_smc_spll_table(struct radeon_device *rdev)
 	return ret;
 }
 
-struct si_dpm_quirk {
-	u32 chip_vendor;
-	u32 chip_device;
-	u32 subsys_vendor;
-	u32 subsys_device;
-	u32 max_sclk;
-	u32 max_mclk;
-};
-
-/* cards with dpm stability problems */
-static struct si_dpm_quirk si_dpm_quirk_list[] = {
-	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
-	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
-	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },
-	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0x2015, 0, 120000 },
-	{ PCI_VENDOR_ID_ATI, 0x6810, 0x174b, 0xe271, 85000, 90000 },
-	{ PCI_VENDOR_ID_ATI, 0x6811, 0x1462, 0x2015, 0, 120000 },
-	{ PCI_VENDOR_ID_ATI, 0x6811, 0x1043, 0x2015, 0, 120000 },
-	{ PCI_VENDOR_ID_ATI, 0x6811, 0x148c, 0x2015, 0, 120000 },
-	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1682, 0x9275, 0, 120000 },
-	{ 0, 0, 0, 0 },
-};
-
 static u16 si_get_lower_of_leakage_and_vce_voltage(struct radeon_device *rdev,
 						   u16 vce_voltage)
 {
@@ -2988,210 +2965,204 @@ static int si_get_vce_clock_voltage(struct radeon_device *rdev,
 static void si_apply_state_adjust_rules(struct radeon_device *rdev,
 					struct radeon_ps *rps)
 {
-	struct ni_ps *ps = ni_get_ps(rps);
-	struct radeon_clock_and_voltage_limits *max_limits;
-	bool disable_mclk_switching = false;
-	bool disable_sclk_switching = false;
-	u32 mclk, sclk;
-	u16 vddc, vddci, min_vce_voltage = 0;
-	u32 max_sclk_vddc, max_mclk_vddci, max_mclk_vddc;
-	u32 max_sclk = 0, max_mclk = 0;
-	int i;
-	struct si_dpm_quirk *p = si_dpm_quirk_list;
-
-	/* Apply dpm quirks */
-	while (p && p->chip_device != 0) {
-		if (rdev->pdev->vendor == p->chip_vendor &&
-		    rdev->pdev->device == p->chip_device &&
-		    rdev->pdev->subsystem_vendor == p->subsys_vendor &&
-		    rdev->pdev->subsystem_device == p->subsys_device) {
-			max_sclk = p->max_sclk;
-			max_mclk = p->max_mclk;
-			break;
-		}
-		++p;
-	}
-	/* limit mclk on all R7 370 parts for stability */
-	if (rdev->pdev->device == 0x6811 &&
-	    rdev->pdev->revision == 0x81)
-		max_mclk = 120000;
-
-	if (rps->vce_active) {
-		rps->evclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].evclk;
-		rps->ecclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].ecclk;
-		si_get_vce_clock_voltage(rdev, rps->evclk, rps->ecclk,
-					 &min_vce_voltage);
-	} else {
-		rps->evclk = 0;
-		rps->ecclk = 0;
-	}
+        struct ni_ps *ps = ni_get_ps(rps);
+        struct radeon_clock_and_voltage_limits *max_limits;
+        bool disable_mclk_switching = false;
+        bool disable_sclk_switching = false;
+        u32 mclk, sclk;
+        u16 vddc, vddci, min_vce_voltage = 0;
+        u32 max_sclk_vddc, max_mclk_vddci, max_mclk_vddc;
+        u32 max_sclk = 0, max_mclk = 0;
+        int i;
+
+        if (rdev->family == CHIP_HAINAN) {
+                if ((rdev->pdev->revision == 0x81) ||
+                    (rdev->pdev->revision == 0x83) ||
+                    (rdev->pdev->revision == 0xC3) ||
+                    (rdev->pdev->device == 0x6664) ||
+                    (rdev->pdev->device == 0x6665) ||
+                    (rdev->pdev->device == 0x6667)) {
+                        max_sclk = 75000;
+                }
+        }
 
-	if ((rdev->pm.dpm.new_active_crtc_count > 1) ||
-	    ni_dpm_vblank_too_short(rdev))
-		disable_mclk_switching = true;
+        if (rps->vce_active) {
+                rps->evclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].evclk;
+                rps->ecclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].ecclk;
+                si_get_vce_clock_voltage(rdev, rps->evclk, rps->ecclk,
+                                         &min_vce_voltage);
+        } else {
+                rps->evclk = 0;
+                rps->ecclk = 0;
+        }
 
-	if (rps->vclk || rps->dclk) {
-		disable_mclk_switching = true;
-		disable_sclk_switching = true;
-	}
+        if ((rdev->pm.dpm.new_active_crtc_count > 1) ||
+            ni_dpm_vblank_too_short(rdev))
+                disable_mclk_switching = true;
 
-	if (rdev->pm.dpm.ac_power)
-		max_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;
-	else
-		max_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;
-
-	for (i = ps->performance_level_count - 2; i >= 0; i--) {
-		if (ps->performance_levels[i].vddc > ps->performance_levels[i+1].vddc)
-			ps->performance_levels[i].vddc = ps->performance_levels[i+1].vddc;
-	}
-	if (rdev->pm.dpm.ac_power == false) {
-		for (i = 0; i < ps->performance_level_count; i++) {
-			if (ps->performance_levels[i].mclk > max_limits->mclk)
-				ps->performance_levels[i].mclk = max_limits->mclk;
-			if (ps->performance_levels[i].sclk > max_limits->sclk)
-				ps->performance_levels[i].sclk = max_limits->sclk;
-			if (ps->performance_levels[i].vddc > max_limits->vddc)
-				ps->performance_levels[i].vddc = max_limits->vddc;
-			if (ps->performance_levels[i].vddci > max_limits->vddci)
-				ps->performance_levels[i].vddci = max_limits->vddci;
-		}
-	}
+        if (rps->vclk || rps->dclk) {
+                disable_mclk_switching = true;
+                disable_sclk_switching = true;
+        }
 
-	/* limit clocks to max supported clocks based on voltage dependency tables */
-	btc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,
-							&max_sclk_vddc);
-	btc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
-							&max_mclk_vddci);
-	btc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
-							&max_mclk_vddc);
+        if (rdev->pm.dpm.ac_power)
+                max_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;
+        else
+                max_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;
 
-	for (i = 0; i < ps->performance_level_count; i++) {
-		if (max_sclk_vddc) {
-			if (ps->performance_levels[i].sclk > max_sclk_vddc)
-				ps->performance_levels[i].sclk = max_sclk_vddc;
-		}
-		if (max_mclk_vddci) {
-			if (ps->performance_levels[i].mclk > max_mclk_vddci)
-				ps->performance_levels[i].mclk = max_mclk_vddci;
-		}
-		if (max_mclk_vddc) {
-			if (ps->performance_levels[i].mclk > max_mclk_vddc)
-				ps->performance_levels[i].mclk = max_mclk_vddc;
-		}
-		if (max_mclk) {
-			if (ps->performance_levels[i].mclk > max_mclk)
-				ps->performance_levels[i].mclk = max_mclk;
-		}
-		if (max_sclk) {
-			if (ps->performance_levels[i].sclk > max_sclk)
-				ps->performance_levels[i].sclk = max_sclk;
-		}
-	}
+        for (i = ps->performance_level_count - 2; i >= 0; i--) {
+                if (ps->performance_levels[i].vddc > ps->performance_levels[i+1].vddc)
+                        ps->performance_levels[i].vddc = ps->performance_levels[i+1].vddc;
+        }
+        if (rdev->pm.dpm.ac_power == false) {
+                for (i = 0; i < ps->performance_level_count; i++) {
+                        if (ps->performance_levels[i].mclk > max_limits->mclk)
+                                ps->performance_levels[i].mclk = max_limits->mclk;
+                        if (ps->performance_levels[i].sclk > max_limits->sclk)
+                                ps->performance_levels[i].sclk = max_limits->sclk;
+                        if (ps->performance_levels[i].vddc > max_limits->vddc)
+                                ps->performance_levels[i].vddc = max_limits->vddc;
+                        if (ps->performance_levels[i].vddci > max_limits->vddci)
+                                ps->performance_levels[i].vddci = max_limits->vddci;
+                }
+        }
 
-	/* XXX validate the min clocks required for display */
+        /* limit clocks to max supported clocks based on voltage dependency tables */
+        btc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,
+                                                        &max_sclk_vddc);
+        btc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
+                                                        &max_mclk_vddci);
+        btc_get_max_clock_from_voltage_dependency_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
+                                                        &max_mclk_vddc);
+
+        for (i = 0; i < ps->performance_level_count; i++) {
+                if (max_sclk_vddc) {
+                        if (ps->performance_levels[i].sclk > max_sclk_vddc)
+                                ps->performance_levels[i].sclk = max_sclk_vddc;
+                }
+                if (max_mclk_vddci) {
+                        if (ps->performance_levels[i].mclk > max_mclk_vddci)
+                                ps->performance_levels[i].mclk = max_mclk_vddci;
+                }
+                if (max_mclk_vddc) {
+                        if (ps->performance_levels[i].mclk > max_mclk_vddc)
+                                ps->performance_levels[i].mclk = max_mclk_vddc;
+                }
+                if (max_mclk) {
+                        if (ps->performance_levels[i].mclk > max_mclk)
+                                ps->performance_levels[i].mclk = max_mclk;
+                }
+                if (max_sclk) {
+                        if (ps->performance_levels[i].sclk > max_sclk)
+                                ps->performance_levels[i].sclk = max_sclk;
+                }
+        }
 
-	if (disable_mclk_switching) {
-		mclk  = ps->performance_levels[ps->performance_level_count - 1].mclk;
-		vddci = ps->performance_levels[ps->performance_level_count - 1].vddci;
-	} else {
-		mclk = ps->performance_levels[0].mclk;
-		vddci = ps->performance_levels[0].vddci;
-	}
+        /* XXX validate the min clocks required for display */
 
-	if (disable_sclk_switching) {
-		sclk = ps->performance_levels[ps->performance_level_count - 1].sclk;
-		vddc = ps->performance_levels[ps->performance_level_count - 1].vddc;
-	} else {
-		sclk = ps->performance_levels[0].sclk;
-		vddc = ps->performance_levels[0].vddc;
-	}
+        if (disable_mclk_switching) {
+                mclk  = ps->performance_levels[ps->performance_level_count - 1].mclk;
+                vddci = ps->performance_levels[ps->performance_level_count - 1].vddci;
+        } else {
+                mclk = ps->performance_levels[0].mclk;
+                vddci = ps->performance_levels[0].vddci;
+        }
 
-	if (rps->vce_active) {
-		if (sclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk)
-			sclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk;
-		if (mclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk)
-			mclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk;
-	}
+        if (disable_sclk_switching) {
+                sclk = ps->performance_levels[ps->performance_level_count - 1].sclk;
+                vddc = ps->performance_levels[ps->performance_level_count - 1].vddc;
+        } else {
+                sclk = ps->performance_levels[0].sclk;
+                vddc = ps->performance_levels[0].vddc;
+        }
 
-	/* adjusted low state */
-	ps->performance_levels[0].sclk = sclk;
-	ps->performance_levels[0].mclk = mclk;
-	ps->performance_levels[0].vddc = vddc;
-	ps->performance_levels[0].vddci = vddci;
+        if (rps->vce_active) {
+                if (sclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk)
+                        sclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk;
+                if (mclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk)
+                        mclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk;
+        }
 
-	if (disable_sclk_switching) {
-		sclk = ps->performance_levels[0].sclk;
-		for (i = 1; i < ps->performance_level_count; i++) {
-			if (sclk < ps->performance_levels[i].sclk)
-				sclk = ps->performance_levels[i].sclk;
-		}
-		for (i = 0; i < ps->performance_level_count; i++) {
-			ps->performance_levels[i].sclk = sclk;
-			ps->performance_levels[i].vddc = vddc;
-		}
-	} else {
-		for (i = 1; i < ps->performance_level_count; i++) {
-			if (ps->performance_levels[i].sclk < ps->performance_levels[i - 1].sclk)
-				ps->performance_levels[i].sclk = ps->performance_levels[i - 1].sclk;
-			if (ps->performance_levels[i].vddc < ps->performance_levels[i - 1].vddc)
-				ps->performance_levels[i].vddc = ps->performance_levels[i - 1].vddc;
-		}
-	}
+        /* adjusted low state */
+        ps->performance_levels[0].sclk = sclk;
+        ps->performance_levels[0].mclk = mclk;
+        ps->performance_levels[0].vddc = vddc;
+        ps->performance_levels[0].vddci = vddci;
+
+        if (disable_sclk_switching) {
+                sclk = ps->performance_levels[0].sclk;
+                for (i = 1; i < ps->performance_level_count; i++) {
+                        if (sclk < ps->performance_levels[i].sclk)
+                                sclk = ps->performance_levels[i].sclk;
+                }
+                for (i = 0; i < ps->performance_level_count; i++) {
+                        ps->performance_levels[i].sclk = sclk;
+                        ps->performance_levels[i].vddc = vddc;
+                }
+        } else {
+                for (i = 1; i < ps->performance_level_count; i++) {
+                        if (ps->performance_levels[i].sclk < ps->performance_levels[i - 1].sclk)
+                                ps->performance_levels[i].sclk = ps->performance_levels[i - 1].sclk;
+                        if (ps->performance_levels[i].vddc < ps->performance_levels[i - 1].vddc)
+                                ps->performance_levels[i].vddc = ps->performance_levels[i - 1].vddc;
+                }
+        }
 
-	if (disable_mclk_switching) {
-		mclk = ps->performance_levels[0].mclk;
-		for (i = 1; i < ps->performance_level_count; i++) {
-			if (mclk < ps->performance_levels[i].mclk)
-				mclk = ps->performance_levels[i].mclk;
-		}
-		for (i = 0; i < ps->performance_level_count; i++) {
-			ps->performance_levels[i].mclk = mclk;
-			ps->performance_levels[i].vddci = vddci;
-		}
-	} else {
-		for (i = 1; i < ps->performance_level_count; i++) {
-			if (ps->performance_levels[i].mclk < ps->performance_levels[i - 1].mclk)
-				ps->performance_levels[i].mclk = ps->performance_levels[i - 1].mclk;
-			if (ps->performance_levels[i].vddci < ps->performance_levels[i - 1].vddci)
-				ps->performance_levels[i].vddci = ps->performance_levels[i - 1].vddci;
-		}
-	}
+        if (disable_mclk_switching) {
+                mclk = ps->performance_levels[0].mclk;
+                for (i = 1; i < ps->performance_level_count; i++) {
+                        if (mclk < ps->performance_levels[i].mclk)
+                                mclk = ps->performance_levels[i].mclk;
+                }
+                for (i = 0; i < ps->performance_level_count; i++) {
+                        ps->performance_levels[i].mclk = mclk;
+                        ps->performance_levels[i].vddci = vddci;
+                }
+        } else {
+                for (i = 1; i < ps->performance_level_count; i++) {
+                        if (ps->performance_levels[i].mclk < ps->performance_levels[i - 1].mclk)
+                                ps->performance_levels[i].mclk = ps->performance_levels[i - 1].mclk;
+                        if (ps->performance_levels[i].vddci < ps->performance_levels[i - 1].vddci)
+                                ps->performance_levels[i].vddci = ps->performance_levels[i - 1].vddci;
+                }
+        }
 
         for (i = 0; i < ps->performance_level_count; i++)
                 btc_adjust_clock_combinations(rdev, max_limits,
                                               &ps->performance_levels[i]);
 
-	for (i = 0; i < ps->performance_level_count; i++) {
-		if (ps->performance_levels[i].vddc < min_vce_voltage)
-			ps->performance_levels[i].vddc = min_vce_voltage;
-		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,
-						   ps->performance_levels[i].sclk,
-						   max_limits->vddc,  &ps->performance_levels[i].vddc);
-		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
-						   ps->performance_levels[i].mclk,
-						   max_limits->vddci, &ps->performance_levels[i].vddci);
-		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
-						   ps->performance_levels[i].mclk,
-						   max_limits->vddc,  &ps->performance_levels[i].vddc);
-		btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,
-						   rdev->clock.current_dispclk,
-						   max_limits->vddc,  &ps->performance_levels[i].vddc);
-	}
+        for (i = 0; i < ps->performance_level_count; i++) {
+                if (ps->performance_levels[i].vddc < min_vce_voltage)
+                        ps->performance_levels[i].vddc = min_vce_voltage;
+                btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,
+                                                   ps->performance_levels[i].sclk,
+                                                   max_limits->vddc,  &ps->performance_levels[i].vddc);
+                btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,
+                                                   ps->performance_levels[i].mclk,
+                                                   max_limits->vddci, &ps->performance_levels[i].vddci);
+                btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,
+                                                   ps->performance_levels[i].mclk,
+                                                   max_limits->vddc,  &ps->performance_levels[i].vddc);
+                btc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,
+                                                   rdev->clock.current_dispclk,
+                                                   max_limits->vddc,  &ps->performance_levels[i].vddc);
+        }
 
-	for (i = 0; i < ps->performance_level_count; i++) {
-		btc_apply_voltage_delta_rules(rdev,
-					      max_limits->vddc, max_limits->vddci,
-					      &ps->performance_levels[i].vddc,
-					      &ps->performance_levels[i].vddci);
-	}
+        for (i = 0; i < ps->performance_level_count; i++) {
+                btc_apply_voltage_delta_rules(rdev,
+                                              max_limits->vddc, max_limits->vddci,
+                                              &ps->performance_levels[i].vddc,
+                                              &ps->performance_levels[i].vddci);
+        }
 
-	ps->dc_compatible = true;
-	for (i = 0; i < ps->performance_level_count; i++) {
-		if (ps->performance_levels[i].vddc > rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc)
-			ps->dc_compatible = false;
-	}
+        ps->dc_compatible = true;
+        for (i = 0; i < ps->performance_level_count; i++) {
+                if (ps->performance_levels[i].vddc > rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc)
+                        ps->dc_compatible = false;
+        }
 }
 
+
 #if 0
 static int si_read_smc_soft_register(struct radeon_device *rdev,
 				     u16 reg_offset, u32 *value)
diff --git a/drivers/gpu/drm/radeon/vce_v1_0.c b/drivers/gpu/drm/radeon/vce_v1_0.c
index a01efe3..cf9dd20 100644
--- a/drivers/gpu/drm/radeon/vce_v1_0.c
+++ b/drivers/gpu/drm/radeon/vce_v1_0.c
@@ -196,7 +196,8 @@ int vce_v1_0_load_fw(struct radeon_device *rdev, uint32_t *data)
 	memset(&data[5], 0, 44);
 	memcpy(&data[16], &sign[1], rdev->vce_fw->size - sizeof(*sign));
 
-	data += le32_to_cpu(data[4]) / 4;
+//	data += le32_to_cpu(data[4]) / 4;
+	data += (le32_to_cpu(sign->len) + 64) / 4;
 	data[0] = sign->val[i].sigval[0];
 	data[1] = sign->val[i].sigval[1];
 	data[2] = sign->val[i].sigval[2];
diff --git a/drivers/gpu/drm/ttm/ttm_agp_backend.c b/drivers/gpu/drm/ttm/ttm_agp_backend.c
index 764be36..c50059d 100644
--- a/drivers/gpu/drm/ttm/ttm_agp_backend.c
+++ b/drivers/gpu/drm/ttm/ttm_agp_backend.c
@@ -29,6 +29,7 @@
  *          Keith Packard.
  */
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <drm/ttm/ttm_module.h>
diff --git a/drivers/gpu/drm/ttm/ttm_bo.c b/drivers/gpu/drm/ttm/ttm_bo.c
index 4ecd863f..8da82bb 100644
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@ -28,6 +28,7 @@
  * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
  */
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <drm/ttm/ttm_module.h>
@@ -176,8 +177,9 @@ void ttm_bo_add_to_lru(struct ttm_buffer_object *bo)
 		list_add_tail(&bo->lru, &man->lru);
 		kref_get(&bo->list_kref);
 
-		if (bo->ttm != NULL) {
-			list_add_tail(&bo->swap, &bo->glob->swap_lru);
+		if (bo->ttm && !(bo->ttm->page_flags & TTM_PAGE_FLAG_SG)) {
+			list_add_tail(&bo->swap,
+					&bo->glob->swap_lru[bo->priority]);
 			kref_get(&bo->list_kref);
 		}
 	}
@@ -330,7 +332,7 @@ static int ttm_bo_handle_move_mem(struct ttm_buffer_object *bo,
 
 		if (bo->mem.mem_type == TTM_PL_SYSTEM) {
 			if (bdev->driver->move_notify)
-				bdev->driver->move_notify(bo, mem);
+				bdev->driver->move_notify(bo, evict, mem);
 			bo->mem = *mem;
 			mem->mm_node = NULL;
 			goto moved;
@@ -338,23 +340,25 @@ static int ttm_bo_handle_move_mem(struct ttm_buffer_object *bo,
 	}
 
 	if (bdev->driver->move_notify)
-		bdev->driver->move_notify(bo, mem);
+		bdev->driver->move_notify(bo, evict, mem);
 
 	if (!(old_man->flags & TTM_MEMTYPE_FLAG_FIXED) &&
 	    !(new_man->flags & TTM_MEMTYPE_FLAG_FIXED))
-		ret = ttm_bo_move_ttm(bo, evict, no_wait_gpu, mem);
+	//	ret = ttm_bo_move_ttm(bo, evict, no_wait_gpu, mem);
+		ret = ttm_bo_move_ttm(bo, interruptible, no_wait_gpu, mem);
 	else if (bdev->driver->move)
 		ret = bdev->driver->move(bo, evict, interruptible,
 					 no_wait_gpu, mem);
 	else
-		ret = ttm_bo_move_memcpy(bo, evict, no_wait_gpu, mem);
+		//ret = ttm_bo_move_memcpy(bo, evict, no_wait_gpu, mem);
+		ret = ttm_bo_move_memcpy(bo, interruptible, no_wait_gpu, mem);
 
 	if (ret) {
 		if (bdev->driver->move_notify) {
 			struct ttm_mem_reg tmp_mem = *mem;
 			*mem = bo->mem;
 			bo->mem = tmp_mem;
-			bdev->driver->move_notify(bo, mem);
+			bdev->driver->move_notify(bo, false, mem);
 			bo->mem = *mem;
 			*mem = tmp_mem;
 		}
@@ -403,7 +407,7 @@ out_err:
 static void ttm_bo_cleanup_memtype_use(struct ttm_buffer_object *bo)
 {
 	if (bo->bdev->driver->move_notify)
-		bo->bdev->driver->move_notify(bo, NULL);
+                bo->bdev->driver->move_notify(bo, false, NULL);
 
 	if (bo->ttm) {
 		ttm_tt_unbind(bo->ttm);
@@ -734,6 +738,67 @@ bool ttm_bo_eviction_valuable(struct ttm_buffer_object *bo,
 EXPORT_SYMBOL(ttm_bo_eviction_valuable);
 
 static int ttm_mem_evict_first(struct ttm_bo_device *bdev,
+                                uint32_t mem_type,
+                                const struct ttm_place *place,
+                                bool interruptible,
+                                bool no_wait_gpu)
+{
+        struct ttm_bo_global *glob = bdev->glob;
+        struct ttm_mem_type_manager *man = &bdev->man[mem_type];
+        struct ttm_buffer_object *bo;
+        int ret = -EBUSY, put_count;
+        unsigned i;
+
+        spin_lock(&glob->lru_lock);
+        for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+                list_for_each_entry(bo, &man->lru[i], lru) {
+                        ret = __ttm_bo_reserve(bo, false, true, false, NULL);
+                        if (ret)
+                                continue;
+
+                        if (place && !bdev->driver->eviction_valuable(bo,
+                                                                      place)) {
+                                __ttm_bo_unreserve(bo);
+                                ret = -EBUSY;
+                                continue;
+                        }
+
+                        break;
+                }
+
+                if (!ret)
+                        break;
+        }
+
+        if (ret) {
+                spin_unlock(&glob->lru_lock);
+                return ret;
+        }
+
+        kref_get(&bo->list_kref);
+
+        if (!list_empty(&bo->ddestroy)) {
+                ret = ttm_bo_cleanup_refs_and_unlock(bo, interruptible,
+                                                     no_wait_gpu);
+                kref_put(&bo->list_kref, ttm_bo_release_list);
+                return ret;
+        }
+
+        put_count = ttm_bo_del_from_lru(bo);
+        spin_unlock(&glob->lru_lock);
+
+        BUG_ON(ret != 0);
+
+        ttm_bo_list_ref_sub(bo, put_count, true);
+
+        ret = ttm_bo_evict(bo, interruptible, no_wait_gpu);
+        ttm_bo_unreserve(bo);
+
+        kref_put(&bo->list_kref, ttm_bo_release_list);
+        return ret;
+}
+#if 0
+static int ttm_mem_evict_first(struct ttm_bo_device *bdev,
 				uint32_t mem_type,
 				const struct ttm_place *place,
 				bool interruptible,
@@ -743,18 +808,15 @@ static int ttm_mem_evict_first(struct ttm_bo_device *bdev,
 	struct ttm_mem_type_manager *man = &bdev->man[mem_type];
 	struct ttm_buffer_object *bo;
 	int ret = -EBUSY, put_count;
+	unsigned i;
 
 	spin_lock(&glob->lru_lock);
-	list_for_each_entry(bo, &man->lru, lru) {
-		ret = __ttm_bo_reserve(bo, false, true, false, NULL);
-		if (!ret) {
-			if(bdev->driver->eviction_valuable){
-				if (place && !bdev->driver->eviction_valuable(bo, place)) {
-					__ttm_bo_unreserve(bo);
-					ret = -EBUSY;
-					continue;
- 				}
-			}
+	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+		list_for_each_entry(bo, &man->lru[i], lru) {
+			ret = __ttm_bo_reserve(bo, false, true, false, NULL);
+			if (!ret) 
+				continue;
+ 				
 			else if (place && (place->fpfn || place->lpfn)) {
 				/* Don't evict this BO if it's outside of the
 				 * requested placement range
@@ -798,7 +860,7 @@ static int ttm_mem_evict_first(struct ttm_bo_device *bdev,
 	kref_put(&bo->list_kref, ttm_bo_release_list);
 	return ret;
 }
-
+#endif
 void ttm_bo_mem_put(struct ttm_buffer_object *bo, struct ttm_mem_reg *mem)
 {
 	struct ttm_mem_type_manager *man = &bo->bdev->man[mem->mem_type];
@@ -809,6 +871,34 @@ void ttm_bo_mem_put(struct ttm_buffer_object *bo, struct ttm_mem_reg *mem)
 EXPORT_SYMBOL(ttm_bo_mem_put);
 
 /**
+ * Add the last move fence to the BO and reserve a new shared slot.
+ */
+static int ttm_bo_add_move_fence(struct ttm_buffer_object *bo,
+                                 struct ttm_mem_type_manager *man,
+                                 struct ttm_mem_reg *mem)
+{
+        struct fence *fence;
+        int ret;
+
+        spin_lock(&man->move_lock);
+        fence = fence_get(man->move);
+        spin_unlock(&man->move_lock);
+
+        if (fence) {
+                reservation_object_add_shared_fence(bo->resv, fence);
+
+                ret = reservation_object_reserve_shared(bo->resv);
+                if (unlikely(ret))
+                        return ret;
+
+                fence_put(bo->moving);
+                bo->moving = fence;
+        }
+
+        return 0;
+}
+
+/**
  * Repeatedly evict memory from the LRU for @mem_type until we create enough
  * space, or we've evicted everything and there isn't enough space.
  */
@@ -892,6 +982,7 @@ static bool ttm_bo_mt_compatible(struct ttm_mem_type_manager *man,
  * ttm_bo_mem_force_space is attempted in priority order to evict and find
  * space.
  */
+#if 0
 int ttm_bo_mem_space(struct ttm_buffer_object *bo,
 			struct ttm_placement *placement,
 			struct ttm_mem_reg *mem,
@@ -998,6 +1089,124 @@ int ttm_bo_mem_space(struct ttm_buffer_object *bo,
 	return (has_erestartsys) ? -ERESTARTSYS : -ENOMEM;
 }
 EXPORT_SYMBOL(ttm_bo_mem_space);
+#endif
+
+int ttm_bo_mem_space(struct ttm_buffer_object *bo,
+                        struct ttm_placement *placement,
+                        struct ttm_mem_reg *mem,
+                        bool interruptible,
+                        bool no_wait_gpu)
+{
+        struct ttm_bo_device *bdev = bo->bdev;
+        struct ttm_mem_type_manager *man;
+        uint32_t mem_type = TTM_PL_SYSTEM;
+        uint32_t cur_flags = 0;
+        bool type_found = false;
+        bool type_ok = false;
+        bool has_erestartsys = false;
+        int i, ret;
+
+        ret = reservation_object_reserve_shared(bo->resv);
+        if (unlikely(ret))
+                return ret;
+
+        mem->mm_node = NULL;
+        for (i = 0; i < placement->num_placement; ++i) {
+                const struct ttm_place *place = &placement->placement[i];
+
+                ret = ttm_mem_type_from_place(place, &mem_type);
+                if (ret)
+                        return ret;
+                man = &bdev->man[mem_type];
+                if (!man->has_type || !man->use_type)
+                        continue;
+
+                type_ok = ttm_bo_mt_compatible(man, mem_type, place,
+                                                &cur_flags);
+
+                if (!type_ok)
+                        continue;
+
+                type_found = true;
+                cur_flags = ttm_bo_select_caching(man, bo->mem.placement,
+                                                  cur_flags);
+                /*
+                 * Use the access and other non-mapping-related flag bits from
+                 * the memory placement flags to the current flags
+                 */
+                ttm_flag_masked(&cur_flags, place->flags,
+                                ~TTM_PL_MASK_MEMTYPE);
+
+                if (mem_type == TTM_PL_SYSTEM)
+                        break;
+
+                ret = (*man->func->get_node)(man, bo, place, mem);
+                if (unlikely(ret))
+                        return ret;
+
+                if (mem->mm_node) {
+                        ret = ttm_bo_add_move_fence(bo, man, mem);
+                        if (unlikely(ret)) {
+                                (*man->func->put_node)(man, mem);
+                                return ret;
+                        }
+                        break;
+                }
+        }
+
+        if ((type_ok && (mem_type == TTM_PL_SYSTEM)) || mem->mm_node) {
+                mem->mem_type = mem_type;
+                mem->placement = cur_flags;
+                return 0;
+        }
+
+        for (i = 0; i < placement->num_busy_placement; ++i) {
+                const struct ttm_place *place = &placement->busy_placement[i];
+
+                ret = ttm_mem_type_from_place(place, &mem_type);
+                if (ret)
+                        return ret;
+                man = &bdev->man[mem_type];
+                if (!man->has_type || !man->use_type)
+                        continue;
+                if (!ttm_bo_mt_compatible(man, mem_type, place, &cur_flags))
+                        continue;
+
+                type_found = true;
+                cur_flags = ttm_bo_select_caching(man, bo->mem.placement,
+                                                  cur_flags);
+                /*
+                 * Use the access and other non-mapping-related flag bits from
+                 * the memory placement flags to the current flags
+                 */
+                ttm_flag_masked(&cur_flags, place->flags,
+                                ~TTM_PL_MASK_MEMTYPE);
+
+                if (mem_type == TTM_PL_SYSTEM) {
+                        mem->mem_type = mem_type;
+                        mem->placement = cur_flags;
+                        mem->mm_node = NULL;
+                        return 0;
+                }
+
+                ret = ttm_bo_mem_force_space(bo, mem_type, place, mem,
+                                                interruptible, no_wait_gpu);
+                if (ret == 0 && mem->mm_node) {
+                        mem->placement = cur_flags;
+                        return 0;
+                }
+                if (ret == -ERESTARTSYS)
+                        has_erestartsys = true;
+        }
+
+        if (!type_found) {
+                printk(KERN_ERR TTM_PFX "No compatible memory type found.\n");
+                return -EINVAL;
+        }
+
+        return (has_erestartsys) ? -ERESTARTSYS : -ENOMEM;
+}
+EXPORT_SYMBOL(ttm_bo_mem_space);
 
 static int ttm_bo_move_buffer(struct ttm_buffer_object *bo,
 			struct ttm_placement *placement,
@@ -1109,6 +1318,119 @@ int ttm_bo_validate(struct ttm_buffer_object *bo,
 }
 EXPORT_SYMBOL(ttm_bo_validate);
 
+int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
+                         struct ttm_buffer_object *bo,
+                         unsigned long size,
+                         enum ttm_bo_type type,
+                         struct ttm_placement *placement,
+                         uint32_t page_alignment,
+                         bool interruptible,
+                         struct file *persistent_swap_storage,
+                         size_t acc_size,
+                         struct sg_table *sg,
+                         struct reservation_object *resv,
+                         void (*destroy) (struct ttm_buffer_object *))
+{
+        int ret = 0;
+        unsigned long num_pages;
+        struct ttm_mem_global *mem_glob = bdev->glob->mem_glob;
+        bool locked;
+
+        ret = ttm_mem_global_alloc(mem_glob, acc_size, false, false);
+        if (ret) {
+                pr_err("Out of kernel memory\n");
+                if (destroy)
+                        (*destroy)(bo);
+                else
+                        kfree(bo);
+                return -ENOMEM;
+        }
+
+        num_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+        if (num_pages == 0) {
+                pr_err("Illegal buffer object size\n");
+                if (destroy)
+                        (*destroy)(bo);
+                else
+                        kfree(bo);
+                ttm_mem_global_free(mem_glob, acc_size);
+                return -EINVAL;
+        }
+        bo->destroy = destroy;
+
+        kref_init(&bo->kref);
+        kref_init(&bo->list_kref);
+        atomic_set(&bo->cpu_writers, 0);
+        INIT_LIST_HEAD(&bo->lru);
+        INIT_LIST_HEAD(&bo->ddestroy);
+        INIT_LIST_HEAD(&bo->swap);
+        INIT_LIST_HEAD(&bo->io_reserve_lru);
+        mutex_init(&bo->wu_mutex);
+        bo->bdev = bdev;
+        bo->glob = bdev->glob;
+        bo->type = type;
+        bo->num_pages = num_pages;
+        bo->mem.size = num_pages << PAGE_SHIFT;
+        bo->mem.mem_type = TTM_PL_SYSTEM;
+        bo->mem.num_pages = bo->num_pages;
+        bo->mem.mm_node = NULL;
+        bo->mem.page_alignment = page_alignment;
+        bo->mem.bus.io_reserved_vm = false;
+        bo->mem.bus.io_reserved_count = 0;
+        bo->moving = NULL;
+        bo->mem.placement = (TTM_PL_FLAG_SYSTEM | TTM_PL_FLAG_CACHED);
+        bo->persistent_swap_storage = persistent_swap_storage;
+        bo->acc_size = acc_size;
+        bo->sg = sg;
+        if (resv) {
+                bo->resv = resv;
+                lockdep_assert_held(&bo->resv->lock.base);
+        } else {
+                bo->resv = &bo->ttm_resv;
+                reservation_object_init(&bo->ttm_resv);
+        }
+        atomic_inc(&bo->glob->bo_count);
+        drm_vma_node_reset(&bo->vma_node);
+        bo->priority = 0;
+
+        /*
+         * For ttm_bo_type_device buffers, allocate
+         * address space from the device.
+         */
+        if (bo->type == ttm_bo_type_device ||
+            bo->type == ttm_bo_type_sg)
+                ret = drm_vma_offset_add(&bdev->vma_manager, &bo->vma_node,
+                                         bo->mem.num_pages);
+
+        /* passed reservation objects should already be locked,
+         * since otherwise lockdep will be angered in radeon.
+         */
+        if (!resv) {
+                locked = ww_mutex_trylock(&bo->resv->lock);
+                WARN_ON(!locked);
+        }
+
+        if (likely(!ret))
+                ret = ttm_bo_validate(bo, placement, interruptible, false);
+
+        if (unlikely(ret)) {
+                if (!resv)
+                        ttm_bo_unreserve(bo);
+
+                ttm_bo_unref(&bo);
+                return ret;
+        }
+
+        if (resv && !(bo->mem.placement & TTM_PL_FLAG_NO_EVICT)) {
+                spin_lock(&bo->glob->lru_lock);
+                ttm_bo_add_to_lru(bo);
+                spin_unlock(&bo->glob->lru_lock);
+        }
+
+        return ret;
+}
+EXPORT_SYMBOL(ttm_bo_init_reserved);
+
 int ttm_bo_init(struct ttm_bo_device *bdev,
 		struct ttm_buffer_object *bo,
 		unsigned long size,
@@ -1168,7 +1490,7 @@ int ttm_bo_init(struct ttm_bo_device *bdev,
 	bo->mem.page_alignment = page_alignment;
 	bo->mem.bus.io_reserved_vm = false;
 	bo->mem.bus.io_reserved_count = 0;
-	bo->priv_flags = 0;
+	bo->moving = NULL;
 	bo->mem.placement = (TTM_PL_FLAG_SYSTEM | TTM_PL_FLAG_CACHED);
 	bo->persistent_swap_storage = persistent_swap_storage;
 	bo->acc_size = acc_size;
@@ -1182,6 +1504,7 @@ int ttm_bo_init(struct ttm_bo_device *bdev,
 	}
 	atomic_inc(&bo->glob->bo_count);
 	drm_vma_node_reset(&bo->vma_node);
+	bo->priority = 0;
 
 	/*
 	 * For ttm_bo_type_device buffers, allocate
@@ -1203,8 +1526,14 @@ int ttm_bo_init(struct ttm_bo_device *bdev,
 	if (likely(!ret))
 		ret = ttm_bo_validate(bo, placement, interruptible, false);
 
-	if (!resv)
+	if (!resv) {
 		ttm_bo_unreserve(bo);
+	
+	} else if (!(bo->mem.placement & TTM_PL_FLAG_NO_EVICT)) {
+                spin_lock(&bo->glob->lru_lock);
+                ttm_bo_add_to_lru(bo);
+                spin_unlock(&bo->glob->lru_lock);
+        }
 
 	if (unlikely(ret))
 		ttm_bo_unref(&bo);
@@ -1271,30 +1600,42 @@ int ttm_bo_create(struct ttm_bo_device *bdev,
 EXPORT_SYMBOL(ttm_bo_create);
 
 static int ttm_bo_force_list_clean(struct ttm_bo_device *bdev,
-					unsigned mem_type, bool allow_errors)
+                                   unsigned mem_type)
 {
 	struct ttm_mem_type_manager *man = &bdev->man[mem_type];
 	struct ttm_bo_global *glob = bdev->glob;
+	struct fence *fence;
 	int ret;
+	unsigned i;
 
 	/*
 	 * Can't use standard list traversal since we're unlocking.
 	 */
 
 	spin_lock(&glob->lru_lock);
-	while (!list_empty(&man->lru)) {
-		spin_unlock(&glob->lru_lock);
-		ret = ttm_mem_evict_first(bdev, mem_type, NULL, false, false);
-		if (ret) {
-			if (allow_errors) {
-				return ret;
-			} else {
-				pr_err("Cleanup eviction failed\n");
-			}
+	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+		while (!list_empty(&man->lru)) {
+			spin_unlock(&glob->lru_lock);
+			ret = ttm_mem_evict_first(bdev, mem_type, NULL, false, false);
+                	if (ret)
+                        	return ret;
+
+			spin_lock(&glob->lru_lock);
 		}
-		spin_lock(&glob->lru_lock);
 	}
 	spin_unlock(&glob->lru_lock);
+
+	spin_lock(&man->move_lock);
+        fence = fence_get(man->move);
+        spin_unlock(&man->move_lock);
+
+        if (fence) {
+                ret = fence_wait(fence, false);
+                fence_put(fence);
+                if (ret)
+                        return ret;
+        }
+
 	return 0;
 }
 
@@ -1315,12 +1656,18 @@ int ttm_bo_clean_mm(struct ttm_bo_device *bdev, unsigned mem_type)
 		return ret;
 	}
 
+	fence_put(man->move);
+
 	man->use_type = false;
 	man->has_type = false;
 
 	ret = 0;
 	if (mem_type > 0) {
-		ttm_bo_force_list_clean(bdev, mem_type, false);
+		ttm_bo_force_list_clean(bdev, mem_type);
+ 		if (ret) {
+                        pr_err("Cleanup eviction failed\n");
+                        return ret;
+                }
 
 		ret = (*man->func->takedown)(man);
 	}
@@ -1343,7 +1690,7 @@ int ttm_bo_evict_mm(struct ttm_bo_device *bdev, unsigned mem_type)
 		return 0;
 	}
 
-	return ttm_bo_force_list_clean(bdev, mem_type, true);
+	return ttm_bo_force_list_clean(bdev, mem_type);
 }
 EXPORT_SYMBOL(ttm_bo_evict_mm);
 
@@ -1352,6 +1699,7 @@ int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
 {
 	int ret = -EINVAL;
 	struct ttm_mem_type_manager *man;
+	unsigned i;
 
 	BUG_ON(type >= TTM_NUM_MEM_TYPES);
 	man = &bdev->man[type];
@@ -1359,6 +1707,7 @@ int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
 	man->io_reserve_fastpath = true;
 	man->use_io_reserve_lru = false;
 	mutex_init(&man->io_reserve_mutex);
+	spin_lock_init(&man->move_lock);
 	INIT_LIST_HEAD(&man->io_reserve_lru);
 
 	ret = bdev->driver->init_mem_type(bdev, type, man);
@@ -1376,8 +1725,10 @@ int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
 	man->use_type = true;
 	man->size = p_size;
 
+	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i)
 	INIT_LIST_HEAD(&man->lru);
 
+	man->move = NULL;
 	return 0;
 }
 EXPORT_SYMBOL(ttm_bo_init_mm);
@@ -1407,6 +1758,7 @@ int ttm_bo_global_init(struct drm_global_reference *ref)
 		container_of(ref, struct ttm_bo_global_ref, ref);
 	struct ttm_bo_global *glob = ref->object;
 	int ret;
+	unsigned i;
 
 	mutex_init(&glob->device_list_mutex);
 	spin_lock_init(&glob->lru_lock);
@@ -1418,7 +1770,8 @@ int ttm_bo_global_init(struct drm_global_reference *ref)
 		goto out_no_drp;
 	}
 
-	INIT_LIST_HEAD(&glob->swap_lru);
+	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i)
+                INIT_LIST_HEAD(&glob->swap_lru[i]);
 	INIT_LIST_HEAD(&glob->device_list);
 
 	ttm_mem_init_shrink(&glob->shrink, ttm_bo_swapout);
@@ -1477,8 +1830,9 @@ int ttm_bo_device_release(struct ttm_bo_device *bdev)
 	if (list_empty(&bdev->ddestroy))
 		TTM_DEBUG("Delayed destroy list was clean\n");
 
-	if (list_empty(&bdev->man[0].lru))
-		TTM_DEBUG("Swap list was clean\n");
+	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i)
+                if (list_empty(&bdev->man[0].lru[0]))
+                        TTM_DEBUG("Swap list %d was clean\n", i);
 	spin_unlock(&glob->lru_lock);
 
 	drm_vma_offset_manager_destroy(&bdev->vma_manager);
@@ -1654,12 +2008,17 @@ static int ttm_bo_swapout(struct ttm_mem_shrink *shrink)
 	int ret = -EBUSY;
 	int put_count;
 	uint32_t swap_placement = (TTM_PL_FLAG_CACHED | TTM_PL_FLAG_SYSTEM);
+	unsigned i;
 
 	spin_lock(&glob->lru_lock);
-	list_for_each_entry(bo, &glob->swap_lru, swap) {
-		ret = __ttm_bo_reserve(bo, false, true, false, NULL);
+	for (i = 0; i < TTM_MAX_BO_PRIORITY; ++i) {
+		list_for_each_entry(bo, &glob->swap_lru[i], swap) {
+			ret = __ttm_bo_reserve(bo, false, true, false, NULL);
+			if (!ret)
+				break;
+		}
 		if (!ret)
-			break;
+       		        break;
 	}
 
 	if (ret) {
@@ -1684,10 +2043,10 @@ static int ttm_bo_swapout(struct ttm_mem_shrink *shrink)
 	 * Wait for GPU, then move to system cached.
 	 */
 
-	ret = ttm_bo_wait(bo, false, false, false);
+//	ret = ttm_bo_wait(bo, false, false, false);
 
-	if (unlikely(ret != 0))
-		goto out;
+//	if (unlikely(ret != 0))
+//		goto out;
 
 	if ((bo->mem.placement & swap_placement) != swap_placement) {
 		struct ttm_mem_reg evict_mem;
@@ -1702,8 +2061,12 @@ static int ttm_bo_swapout(struct ttm_mem_shrink *shrink)
 		if (unlikely(ret != 0))
 			goto out;
 	}
+	
+	ret = ttm_bo_wait(bo, false, false, false);
+        if (unlikely(ret != 0))
+                goto out;
 
-	ttm_bo_unmap_virtual(bo);
+        ttm_bo_unmap_virtual(bo);
 
 	/**
 	 * Swap out. Buffer will be swapped in again as soon as
diff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c
index ac6fe40..c6807b1 100644
--- a/drivers/gpu/drm/ttm/ttm_bo_util.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c
@@ -32,6 +32,7 @@
 #include <drm/ttm/ttm_placement.h>
 #include <drm/drm_vma_manager.h>
 #include <linux/io.h>
+#include <linux/version.h>
 #include <linux/highmem.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
@@ -260,7 +261,11 @@ static int ttm_copy_io_ttm_page(struct ttm_tt *ttm, void *src,
 	src = (void *)((unsigned long)src + (page << PAGE_SHIFT));
 
 #ifdef CONFIG_X86
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
+	dst = kmap_atomic_prot(d, KM_USER0, prot);
+#else
 	dst = kmap_atomic_prot(d, prot);
+#endif
 #else
 	if (pgprot_val(prot) != pgprot_val(PAGE_KERNEL))
 		dst = vmap(&d, 1, 0, prot);
@@ -273,7 +278,11 @@ static int ttm_copy_io_ttm_page(struct ttm_tt *ttm, void *src,
 	memcpy_fromio(dst, src, PAGE_SIZE);
 
 #ifdef CONFIG_X86
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
+	kunmap_atomic(dst, KM_USER0);
+#else
 	kunmap_atomic(dst);
+#endif
 #else
 	if (pgprot_val(prot) != pgprot_val(PAGE_KERNEL))
 		vunmap(dst);
@@ -296,7 +305,11 @@ static int ttm_copy_ttm_io_page(struct ttm_tt *ttm, void *dst,
 
 	dst = (void *)((unsigned long)dst + (page << PAGE_SHIFT));
 #ifdef CONFIG_X86
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
+	src = kmap_atomic_prot(s, KM_USER0, prot);
+#else
 	src = kmap_atomic_prot(s, prot);
+#endif
 #else
 	if (pgprot_val(prot) != pgprot_val(PAGE_KERNEL))
 		src = vmap(&s, 1, 0, prot);
@@ -309,7 +322,11 @@ static int ttm_copy_ttm_io_page(struct ttm_tt *ttm, void *dst,
 	memcpy_toio(dst, src, PAGE_SIZE);
 
 #ifdef CONFIG_X86
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
+	kunmap_atomic(src, KM_USER0);
+#else
 	kunmap_atomic(src);
+#endif
 #else
 	if (pgprot_val(prot) != pgprot_val(PAGE_KERNEL))
 		vunmap(src);
@@ -694,3 +711,96 @@ int ttm_bo_move_accel_cleanup(struct ttm_buffer_object *bo,
 	return 0;
 }
 EXPORT_SYMBOL(ttm_bo_move_accel_cleanup);
+
+int ttm_bo_pipeline_move(struct ttm_buffer_object *bo,
+                         struct fence *fence, bool evict,
+                         struct ttm_mem_reg *new_mem)
+{
+        struct ttm_bo_device *bdev = bo->bdev;
+        struct ttm_mem_reg *old_mem = &bo->mem;
+
+        struct ttm_mem_type_manager *from = &bdev->man[old_mem->mem_type];
+        struct ttm_mem_type_manager *to = &bdev->man[new_mem->mem_type];
+
+        int ret;
+
+        reservation_object_add_excl_fence(bo->resv, fence);
+
+        if (!evict) {
+                struct ttm_buffer_object *ghost_obj;
+
+                /**
+                 * This should help pipeline ordinary buffer moves.
+                 *
+                 * Hang old buffer memory on a new buffer object,
+                 * and leave it to be released when the GPU
+                 * operation has completed.
+                 */
+
+                fence_put(bo->moving);
+                bo->moving = fence_get(fence);
+
+                ret = ttm_buffer_object_transfer(bo, &ghost_obj);
+                if (ret)
+                        return ret;
+
+                reservation_object_add_excl_fence(ghost_obj->resv, fence);
+
+                /**
+                 * If we're not moving to fixed memory, the TTM object
+                 * needs to stay alive. Otherwhise hang it on the ghost
+                 * bo to be unbound and destroyed.
+                 */
+
+                if (!(to->flags & TTM_MEMTYPE_FLAG_FIXED))
+                        ghost_obj->ttm = NULL;
+                else
+                        bo->ttm = NULL;
+
+                ttm_bo_unreserve(ghost_obj);
+                ttm_bo_unref(&ghost_obj);
+
+        } else if (from->flags & TTM_MEMTYPE_FLAG_FIXED) {
+
+                /**
+                 * BO doesn't have a TTM we need to bind/unbind. Just remember
+                 * this eviction and free up the allocation
+                 */
+
+                spin_lock(&from->move_lock);
+                if (!from->move || fence_is_later(fence, from->move)) {
+                        fence_put(from->move);
+                        from->move = fence_get(fence);
+                }
+                spin_unlock(&from->move_lock);
+
+                ttm_bo_free_old_node(bo);
+
+                fence_put(bo->moving);
+                bo->moving = fence_get(fence);
+
+        } else {
+                /**
+                 * Last resort, wait for the move to be completed.
+                 *
+                 * Should never happen in pratice.
+                 */
+
+                ret = ttm_bo_wait(bo, false, false, false);
+                if (ret)
+                        return ret;
+
+                if (to->flags & TTM_MEMTYPE_FLAG_FIXED) {
+                        ttm_tt_destroy(bo->ttm);
+                        bo->ttm = NULL;
+                }
+                ttm_bo_free_old_node(bo);
+        }
+
+        *old_mem = *new_mem;
+        new_mem->mm_node = NULL;
+
+        return 0;
+}
+EXPORT_SYMBOL(ttm_bo_pipeline_move);
+                                                                        
diff --git a/drivers/gpu/drm/ttm/ttm_bo_vm.c b/drivers/gpu/drm/ttm/ttm_bo_vm.c
index 8fb7213..161703b 100644
--- a/drivers/gpu/drm/ttm/ttm_bo_vm.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_vm.c
@@ -28,13 +28,18 @@
  * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
  */
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
+#include <linux/version.h>
 #include <ttm/ttm_module.h>
 #include <ttm/ttm_bo_driver.h>
 #include <ttm/ttm_placement.h>
 #include <drm/drm_vma_manager.h>
 #include <linux/mm.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0) || defined(OS_NAME_RHEL_7_3) || defined(OS_NAME_SLE)
+#include <linux/pfn_t.h>
+#endif
 #include <linux/rbtree.h>
 #include <linux/module.h>
 #include <linux/uaccess.h>
@@ -63,9 +68,10 @@ static int ttm_bo_vm_fault_idle(struct ttm_buffer_object *bo,
 	 */
 	if (vmf->flags & FAULT_FLAG_ALLOW_RETRY) {
 		ret = VM_FAULT_RETRY;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 		if (vmf->flags & FAULT_FLAG_RETRY_NOWAIT)
 			goto out_unlock;
-
+#endif
 		up_read(&vma->vm_mm->mmap_sem);
 		(void) ttm_bo_wait(bo, false, true, false);
 		goto out_unlock;
@@ -229,7 +235,13 @@ static int ttm_bo_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 		}
 
 		if (vma->vm_flags & VM_MIXEDMAP)
-			ret = vm_insert_mixed(&cvma, address, pfn);
+			ret = vm_insert_mixed(&cvma, address,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0) || defined(OS_NAME_RHEL_7_3) || defined(OS_NAME_SLE)
+                                       __pfn_to_pfn_t(pfn, PFN_DEV));
+#else
+                                       pfn);
+#endif
+
 		else
 			ret = vm_insert_pfn(&cvma, address, pfn);
 
diff --git a/drivers/gpu/drm/ttm/ttm_memory.c b/drivers/gpu/drm/ttm/ttm_memory.c
index 8fb778e..34cd59f 100644
--- a/drivers/gpu/drm/ttm/ttm_memory.c
+++ b/drivers/gpu/drm/ttm/ttm_memory.c
@@ -25,6 +25,7 @@
  *
  **************************************************************************/
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <drm/ttm/ttm_memory.h>
diff --git a/drivers/gpu/drm/ttm/ttm_object.c b/drivers/gpu/drm/ttm/ttm_object.c
index 4f5fa8d..50f6fad 100644
--- a/drivers/gpu/drm/ttm/ttm_object.c
+++ b/drivers/gpu/drm/ttm/ttm_object.c
@@ -56,6 +56,7 @@
  * for fast lookup of ref objects given a base object.
  */
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <drm/ttm/ttm_object.h>
diff --git a/drivers/gpu/drm/ttm/ttm_page_alloc.c b/drivers/gpu/drm/ttm/ttm_page_alloc.c
index 025c429..3d2d7ba 100644
--- a/drivers/gpu/drm/ttm/ttm_page_alloc.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc.c
@@ -31,6 +31,7 @@
  * - doesn't track currently in use pages
  */
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <linux/list.h>
diff --git a/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c b/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
index 624d941..5530aae 100644
--- a/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
@@ -34,6 +34,7 @@
  */
 
 #if defined(CONFIG_SWIOTLB) || defined(CONFIG_INTEL_IOMMU)
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <linux/dma-mapping.h>
diff --git a/drivers/gpu/drm/ttm/ttm_tt.c b/drivers/gpu/drm/ttm/ttm_tt.c
index 4e19d0f..894a91e 100644
--- a/drivers/gpu/drm/ttm/ttm_tt.c
+++ b/drivers/gpu/drm/ttm/ttm_tt.c
@@ -28,6 +28,7 @@
  * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
  */
 
+#undef pr_fmt
 #define pr_fmt(fmt) "[TTM] " fmt
 
 #include <linux/sched.h>
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index 23a76de..26f8f9d 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -281,8 +281,11 @@ struct drm_ioctl_desc {
 
 /* Event queued up for userspace to read */
 struct drm_pending_event {
+        struct completion *completion;
 	struct drm_event *event;
+        struct fence *fence;
 	struct list_head link;
+        struct list_head pending_link;
 	struct drm_file *file_priv;
 	pid_t pid; /* pid of requester, no guarantee it's valid by the time
 		      we deliver the event, for tracing only */
@@ -929,6 +932,7 @@ extern int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv);
 
 				/* Mapping support (drm_vm.h) */
 extern unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
+void drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e);
 
 /* Misc. IOCTL support (drm_ioctl.c) */
 int drm_noop(struct drm_device *dev, void *data,
@@ -981,6 +985,7 @@ extern void drm_crtc_vblank_off(struct drm_crtc *crtc);
 extern void drm_crtc_vblank_reset(struct drm_crtc *crtc);
 extern void drm_crtc_vblank_on(struct drm_crtc *crtc);
 extern void drm_vblank_cleanup(struct drm_device *dev);
+extern u32 drm_accurate_vblank_count(struct drm_crtc *crtc);
 extern u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);
 
 extern int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
diff --git a/include/drm/drm_bridge.h b/include/drm/drm_bridge.h
new file mode 100644
index 0000000..f1ff64b
--- /dev/null
+++ b/include/drm/drm_bridge.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef __DRM_BRIDGE_H__
+#define __DRM_BRIDGE_H__
+
+#include <linux/list.h>
+#include <linux/ctype.h>
+#include <drm/drm_mode_object.h>
+#include <drm/drm_modes.h>
+
+struct drm_bridge;
+
+void drm_bridge_detach(struct drm_bridge *bridge);
+
+
+#endif
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index bd27364..de4ed81 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -36,6 +36,8 @@
 #include <uapi/drm/drm_fourcc.h>
 #include <drm/drm_modeset_lock.h>
 
+#include <drm/drm_rect.h>
+
 struct drm_device;
 struct drm_mode_set;
 struct drm_framebuffer;
@@ -143,7 +145,30 @@ struct drm_display_info {
 
 	const u32 *bus_formats;
 	unsigned int num_bus_formats;
-
+#define DRM_BUS_FLAG_DE_LOW             (1<<0)
+#define DRM_BUS_FLAG_DE_HIGH            (1<<1)
+/* drive data on pos. edge */
+#define DRM_BUS_FLAG_PIXDATA_POSEDGE    (1<<2)
+/* drive data on neg. edge */
+#define DRM_BUS_FLAG_PIXDATA_NEGEDGE    (1<<3)
+
+        /**
+         * @bus_flags: Additional information (like pixel signal polarity) for
+         * the pixel data on the bus, using DRM_BUS_FLAGS\_ defines.
+         */
+        u32 bus_flags;
+
+        /**
+         * @max_tmds_clock: Maximum TMDS clock rate supported by the
+         * sink in kHz. 0 means undefined.
+         */
+        int max_tmds_clock;
+
+        /**
+         * @dvi_dual: Dual-link DVI sink?
+         */
+        bool dvi_dual;
+	
 	/* Mask of supported hdmi deep color modes */
 	u8 edid_hdmi_dc_modes;
 
@@ -376,6 +401,25 @@ struct drm_crtc_funcs {
 			 struct drm_pending_vblank_event *event,
 			 uint32_t flags);
 
+        /**
+         * @page_flip_target:
+         *
+         * Same as @page_flip but with an additional parameter specifying the
+         * absolute target vertical blank period (as reported by
+         * drm_crtc_vblank_count()) when the flip should take effect.
+         *
+         * Note that the core code calls drm_crtc_vblank_get before this entry
+         * point, and will call drm_crtc_vblank_put if this entry point returns
+         * any non-0 error code. It's the driver's responsibility to call
+         * drm_crtc_vblank_put after this entry point returns 0, typically when
+         * the flip completes.
+         */
+        int (*page_flip_target)(struct drm_crtc *crtc,
+                                struct drm_framebuffer *fb,
+                                struct drm_pending_vblank_event *event,
+                                uint32_t flags, uint32_t target);
+
+
 	int (*set_property)(struct drm_crtc *crtc,
 			    struct drm_property *property, uint64_t val);
 
@@ -469,6 +513,24 @@ struct drm_crtc {
 
 	struct drm_crtc_state *state;
 
+        /**
+         * @commit_list:
+         *
+         * List of &drm_crtc_commit structures tracking pending commits.
+         * Protected by @commit_lock. This list doesn't hold its own full
+         * reference, but burrows it from the ongoing commit. Commit entries
+         * must be removed from this list once the commit is fully completed,
+         * but before it's correspoding &drm_atomic_state gets destroyed.
+         */
+        struct list_head commit_list;
+
+        /**
+         * @commit_lock:
+         *
+         * Spinlock to protect @commit_list.
+         */
+        spinlock_t commit_lock;
+
 	/*
 	 * For legacy crtc ioctls so that atomic drivers can get at the locking
 	 * acquire context.
@@ -532,6 +594,33 @@ struct drm_connector_funcs {
 	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
 	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
 			     uint64_t val);
+        /**
+         * @late_register:
+         *
+         * This optional hook can be used to register additional userspace
+         * interfaces attached to the connector, light backlight control, i2c,
+         * DP aux or similar interfaces. It is called late in the driver load
+         * sequence from drm_connector_register() when registering all the
+         * core drm connector interfaces. Everything added from this callback
+         * should be unregistered in the early_unregister callback.
+         *
+         * Returns:
+         *
+         * 0 on success, or a negative error code on failure.
+         */
+        int (*late_register)(struct drm_connector *connector);
+
+        /**
+         * @early_unregister:
+         *
+         * This optional hook should be used to unregister the additional
+         * userspace interfaces attached to the connector from
+         * late_register(). It is called from drm_connector_unregister(),
+         * early in the driver unload sequence to disable userspace access
+         * before data structures are torndown.
+         */
+        void (*early_unregister)(struct drm_connector *connector);
+
 	void (*destroy)(struct drm_connector *connector);
 	void (*force)(struct drm_connector *connector);
 
@@ -771,6 +860,18 @@ struct drm_plane_state {
 
 	/* Plane rotation */
 	unsigned int rotation;
+        unsigned int zpos;
+        unsigned int normalized_zpos;
+	/* Clipped coordinates */
+        struct drm_rect src, dst;
+
+
+
+        /*
+         * Is the plane actually visible? Can be false even
+         * if fb!=NULL and crtc!=NULL, due to clipping.
+         */
+        bool visible;
 
 	struct drm_atomic_state *state;
 };
@@ -883,6 +984,7 @@ struct drm_plane {
  */
 struct drm_bridge_funcs {
 	int (*attach)(struct drm_bridge *bridge);
+        void (*detach)(struct drm_bridge *bridge);
 	bool (*mode_fixup)(struct drm_bridge *bridge,
 			   const struct drm_display_mode *mode,
 			   struct drm_display_mode *adjusted_mode);
@@ -1154,6 +1256,7 @@ struct drm_mode_config {
 
 	/* cursor size */
 	uint32_t cursor_width, cursor_height;
+        struct drm_mode_config_helper_funcs *helper_private;
 };
 
 /**
diff --git a/include/drm/drm_dp_dual_mode_helper.h b/include/drm/drm_dp_dual_mode_helper.h
new file mode 100644
index 0000000..e8a9dfd
--- /dev/null
+++ b/include/drm/drm_dp_dual_mode_helper.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright Â© 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef DRM_DP_DUAL_MODE_HELPER_H
+#define DRM_DP_DUAL_MODE_HELPER_H
+
+#include <linux/types.h>
+
+/*
+ * Optional for type 1 DVI adaptors
+ * Mandatory for type 1 HDMI and type 2 adaptors
+ */
+#define DP_DUAL_MODE_HDMI_ID 0x00 /* 00-0f */
+#define  DP_DUAL_MODE_HDMI_ID_LEN 16
+/*
+ * Optional for type 1 adaptors
+ * Mandatory for type 2 adaptors
+ */
+#define DP_DUAL_MODE_ADAPTOR_ID 0x10
+#define  DP_DUAL_MODE_REV_MASK 0x07
+#define  DP_DUAL_MODE_REV_TYPE2 0x00
+#define  DP_DUAL_MODE_TYPE_MASK 0xf0
+#define  DP_DUAL_MODE_TYPE_TYPE2 0xa0
+#define DP_DUAL_MODE_IEEE_OUI 0x11 /* 11-13*/
+#define  DP_DUAL_IEEE_OUI_LEN 3
+#define DP_DUAL_DEVICE_ID 0x14 /* 14-19 */
+#define  DP_DUAL_DEVICE_ID_LEN 6
+#define DP_DUAL_MODE_HARDWARE_REV 0x1a
+#define DP_DUAL_MODE_FIRMWARE_MAJOR_REV 0x1b
+#define DP_DUAL_MODE_FIRMWARE_MINOR_REV 0x1c
+#define DP_DUAL_MODE_MAX_TMDS_CLOCK 0x1d
+#define DP_DUAL_MODE_I2C_SPEED_CAP 0x1e
+#define DP_DUAL_MODE_TMDS_OEN 0x20
+#define  DP_DUAL_MODE_TMDS_DISABLE 0x01
+#define DP_DUAL_MODE_HDMI_PIN_CTRL 0x21
+#define  DP_DUAL_MODE_CEC_ENABLE 0x01
+#define DP_DUAL_MODE_I2C_SPEED_CTRL 0x22
+
+struct i2c_adapter;
+
+ssize_t drm_dp_dual_mode_read(struct i2c_adapter *adapter,
+			      u8 offset, void *buffer, size_t size);
+ssize_t drm_dp_dual_mode_write(struct i2c_adapter *adapter,
+			       u8 offset, const void *buffer, size_t size);
+
+/**
+ * enum drm_dp_dual_mode_type - Type of the DP dual mode adaptor
+ * @DRM_DP_DUAL_MODE_NONE: No DP dual mode adaptor
+ * @DRM_DP_DUAL_MODE_UNKNOWN: Could be either none or type 1 DVI adaptor
+ * @DRM_DP_DUAL_MODE_TYPE1_DVI: Type 1 DVI adaptor
+ * @DRM_DP_DUAL_MODE_TYPE1_HDMI: Type 1 HDMI adaptor
+ * @DRM_DP_DUAL_MODE_TYPE2_DVI: Type 2 DVI adaptor
+ * @DRM_DP_DUAL_MODE_TYPE2_HDMI: Type 2 HDMI adaptor
+ */
+enum drm_dp_dual_mode_type {
+	DRM_DP_DUAL_MODE_NONE,
+	DRM_DP_DUAL_MODE_UNKNOWN,
+	DRM_DP_DUAL_MODE_TYPE1_DVI,
+	DRM_DP_DUAL_MODE_TYPE1_HDMI,
+	DRM_DP_DUAL_MODE_TYPE2_DVI,
+	DRM_DP_DUAL_MODE_TYPE2_HDMI,
+};
+
+enum drm_dp_dual_mode_type drm_dp_dual_mode_detect(struct i2c_adapter *adapter);
+int drm_dp_dual_mode_max_tmds_clock(enum drm_dp_dual_mode_type type,
+				    struct i2c_adapter *adapter);
+int drm_dp_dual_mode_get_tmds_output(enum drm_dp_dual_mode_type type,
+				     struct i2c_adapter *adapter, bool *enabled);
+int drm_dp_dual_mode_set_tmds_output(enum drm_dp_dual_mode_type type,
+				     struct i2c_adapter *adapter, bool enable);
+const char *drm_dp_get_dual_mode_type_name(enum drm_dp_dual_mode_type type);
+
+#endif
diff --git a/include/drm/drm_dp_helper.h b/include/drm/drm_dp_helper.h
index e815278..f666a59 100644
--- a/include/drm/drm_dp_helper.h
+++ b/include/drm/drm_dp_helper.h
@@ -416,7 +416,7 @@
 
 #define DP_TEST_PATTERN			    0x221
 
-#define DP_TEST_MISC1                       0x232
+#define DP_TEST_MISC0                       0x232
 
 #define DP_TEST_CRC_R_CR		    0x240
 #define DP_TEST_CRC_G_Y			    0x242
diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
new file mode 100644
index 0000000..16d9e86
--- /dev/null
+++ b/include/drm/drm_mode_object.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef __DRM_MODESET_H__
+#define __DRM_MODESET_H__
+
+#include <linux/kref.h>
+struct drm_object_properties;
+struct drm_property;
+struct drm_device;
+
+#define DRM_OBJECT_MAX_PROPERTY 24
+
+/* Avoid boilerplate.  I'm tired of typing. */
+#define DRM_ENUM_NAME_FN(fnname, list)				\
+	const char *fnname(int val)				\
+	{							\
+		int i;						\
+		for (i = 0; i < ARRAY_SIZE(list); i++) {	\
+			if (list[i].type == val)		\
+				return list[i].name;		\
+		}						\
+		return "(unknown)";				\
+	}
+
+void drm_mode_object_reference(struct drm_mode_object *obj);
+void drm_mode_object_unreference(struct drm_mode_object *obj);
+
+#endif
diff --git a/include/drm/drm_modeset_helper.h b/include/drm/drm_modeset_helper.h
new file mode 100644
index 0000000..b8051d5
--- /dev/null
+++ b/include/drm/drm_modeset_helper.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef __DRM_KMS_HELPER_H__
+#define __DRM_KMS_HELPER_H__
+
+#include <drm/drmP.h>
+
+void drm_helper_move_panel_connectors_to_head(struct drm_device *);
+
+void drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
+				    const struct drm_mode_fb_cmd2 *mode_cmd);
+
+int drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
+		  const struct drm_crtc_funcs *funcs);
+
+#endif
diff --git a/include/drm/drm_plane_helper.h b/include/drm/drm_plane_helper.h
index 5a7f9d4..f7a502b 100644
--- a/include/drm/drm_plane_helper.h
+++ b/include/drm/drm_plane_helper.h
@@ -36,6 +36,12 @@
  */
 #define DRM_PLANE_HELPER_NO_SCALING (1<<16)
 
+int drm_plane_helper_check_state(struct drm_plane_state *state,
+                                 const struct drm_rect *clip,
+                                 int min_scale, int max_scale,
+                                 bool can_position,
+                                 bool can_update_disabled);
+
 /**
  * DOC: plane helpers
  *
diff --git a/include/drm/drm_simple_kms_helper.h b/include/drm/drm_simple_kms_helper.h
new file mode 100644
index 0000000..01a8436
--- /dev/null
+++ b/include/drm/drm_simple_kms_helper.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Noralf TrÃ¸nnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_DRM_SIMPLE_KMS_HELPER_H
+#define __LINUX_DRM_SIMPLE_KMS_HELPER_H
+
+struct drm_simple_display_pipe;
+
+/**
+ * struct drm_simple_display_pipe_funcs - helper operations for a simple
+ *                                        display pipeline
+ */
+struct drm_simple_display_pipe_funcs {
+	/**
+	 * @enable:
+	 *
+	 * This function should be used to enable the pipeline.
+	 * It is called when the underlying crtc is enabled.
+	 * This hook is optional.
+	 */
+	void (*enable)(struct drm_simple_display_pipe *pipe,
+		       struct drm_crtc_state *crtc_state);
+	/**
+	 * @disable:
+	 *
+	 * This function should be used to disable the pipeline.
+	 * It is called when the underlying crtc is disabled.
+	 * This hook is optional.
+	 */
+	void (*disable)(struct drm_simple_display_pipe *pipe);
+
+	/**
+	 * @check:
+	 *
+	 * This function is called in the check phase of an atomic update,
+	 * specifically when the underlying plane is checked.
+	 * The simple display pipeline helpers already check that the plane is
+	 * not scaled, fills the entire visible area and is always enabled
+	 * when the crtc is also enabled.
+	 * This hook is optional.
+	 *
+	 * RETURNS:
+	 *
+	 * 0 on success, -EINVAL if the state or the transition can't be
+	 * supported, -ENOMEM on memory allocation failure and -EDEADLK if an
+	 * attempt to obtain another state object ran into a &drm_modeset_lock
+	 * deadlock.
+	 */
+	int (*check)(struct drm_simple_display_pipe *pipe,
+		     struct drm_plane_state *plane_state,
+		     struct drm_crtc_state *crtc_state);
+	/**
+	 * @update:
+	 *
+	 * This function is called when the underlying plane state is updated.
+	 * This hook is optional.
+	 *
+	 * This is the function drivers should submit the
+	 * &drm_pending_vblank_event from. Using either
+	 * drm_crtc_arm_vblank_event(), when the driver supports vblank
+	 * interrupt handling, or drm_crtc_send_vblank_event() directly in case
+	 * the hardware lacks vblank support entirely.
+	 */
+	void (*update)(struct drm_simple_display_pipe *pipe,
+		       struct drm_plane_state *plane_state);
+
+	/**
+	 * @prepare_fb:
+	 *
+	 * Optional, called by struct &drm_plane_helper_funcs ->prepare_fb .
+	 * Please read the documentation for the ->prepare_fb hook in
+	 * struct &drm_plane_helper_funcs for more details.
+	 */
+	int (*prepare_fb)(struct drm_simple_display_pipe *pipe,
+			  struct drm_plane_state *plane_state);
+
+	/**
+	 * @cleanup_fb:
+	 *
+	 * Optional, called by struct &drm_plane_helper_funcs ->cleanup_fb .
+	 * Please read the documentation for the ->cleanup_fb hook in
+	 * struct &drm_plane_helper_funcs for more details.
+	 */
+	void (*cleanup_fb)(struct drm_simple_display_pipe *pipe,
+			   struct drm_plane_state *plane_state);
+};
+
+/**
+ * struct drm_simple_display_pipe - simple display pipeline
+ * @crtc: CRTC control structure
+ * @plane: Plane control structure
+ * @encoder: Encoder control structure
+ * @connector: Connector control structure
+ * @funcs: Pipeline control functions (optional)
+ *
+ * Simple display pipeline with plane, crtc and encoder collapsed into one
+ * entity. It should be initialized by calling drm_simple_display_pipe_init().
+ */
+struct drm_simple_display_pipe {
+	struct drm_crtc crtc;
+	struct drm_plane plane;
+	struct drm_encoder encoder;
+	struct drm_connector *connector;
+
+	const struct drm_simple_display_pipe_funcs *funcs;
+};
+
+int drm_simple_display_pipe_attach_bridge(struct drm_simple_display_pipe *pipe,
+					  struct drm_bridge *bridge);
+
+void drm_simple_display_pipe_detach_bridge(struct drm_simple_display_pipe *pipe);
+
+int drm_simple_display_pipe_init(struct drm_device *dev,
+			struct drm_simple_display_pipe *pipe,
+			const struct drm_simple_display_pipe_funcs *funcs,
+			const uint32_t *formats, unsigned int format_count,
+			struct drm_connector *connector);
+
+#endif /* __LINUX_DRM_SIMPLE_KMS_HELPER_H */
diff --git a/include/drm/ttm/ttm_bo_api.h b/include/drm/ttm/ttm_bo_api.h
index 1828c11..b44090a 100644
--- a/include/drm/ttm/ttm_bo_api.h
+++ b/include/drm/ttm/ttm_bo_api.h
@@ -247,6 +247,7 @@ struct ttm_buffer_object {
 
 	struct drm_vma_offset_node vma_node;
 
+        unsigned priority;
 	/**
 	 * Special members that are protected by the reserve lock
 	 * and the bo::lock when written to. Can be read with
@@ -469,6 +470,60 @@ size_t ttm_bo_dma_acc_size(struct ttm_bo_device *bdev,
 			   unsigned struct_size);
 
 /**
+ * ttm_bo_init_reserved
+ *
+ * @bdev: Pointer to a ttm_bo_device struct.
+ * @bo: Pointer to a ttm_buffer_object to be initialized.
+ * @size: Requested size of buffer object.
+ * @type: Requested type of buffer object.
+ * @flags: Initial placement flags.
+ * @page_alignment: Data alignment in pages.
+ * @interruptible: If needing to sleep to wait for GPU resources,
+ * sleep interruptible.
+ * @persistent_swap_storage: Usually the swap storage is deleted for buffers
+ * pinned in physical memory. If this behaviour is not desired, this member
+ * holds a pointer to a persistent shmem object. Typically, this would
+ * point to the shmem object backing a GEM object if TTM is used to back a
+ * GEM user interface.
+ * @acc_size: Accounted size for this object.
+ * @resv: Pointer to a reservation_object, or NULL to let ttm allocate one.
+ * @destroy: Destroy function. Use NULL for kfree().
+ *
+ * This function initializes a pre-allocated struct ttm_buffer_object.
+ * As this object may be part of a larger structure, this function,
+ * together with the @destroy function,
+ * enables driver-specific objects derived from a ttm_buffer_object.
+ *
+ * On successful return, the caller owns an object kref to @bo. The kref and
+ * list_kref are usually set to 1, but note that in some situations, other
+ * tasks may already be holding references to @bo as well.
+ * Furthermore, if resv == NULL, the buffer's reservation lock will be held,
+ * and it is the caller's responsibility to call ttm_bo_unreserve.
+ *
+ * If a failure occurs, the function will call the @destroy function, or
+ * kfree() if @destroy is NULL. Thus, after a failure, dereferencing @bo is
+ * illegal and will likely cause memory corruption.
+ *
+ * Returns
+ * -ENOMEM: Out of memory.
+ * -EINVAL: Invalid placement flags.
+ * -ERESTARTSYS: Interrupted by signal while sleeping waiting for resources.
+ */
+
+extern int ttm_bo_init_reserved(struct ttm_bo_device *bdev,
+                                struct ttm_buffer_object *bo,
+                                unsigned long size,
+                                enum ttm_bo_type type,
+                                struct ttm_placement *placement,
+                                uint32_t page_alignment,
+                                bool interrubtible,
+                                struct file *persistent_swap_storage,
+                                size_t acc_size,
+                                struct sg_table *sg,
+                                struct reservation_object *resv,
+                                void (*destroy) (struct ttm_buffer_object *));
+
+/**
  * ttm_bo_init
  *
  * @bdev: Pointer to a ttm_bo_device struct.
diff --git a/include/drm/ttm/ttm_bo_driver.h b/include/drm/ttm/ttm_bo_driver.h
index 45d5715..9efb491 100644
--- a/include/drm/ttm/ttm_bo_driver.h
+++ b/include/drm/ttm/ttm_bo_driver.h
@@ -42,6 +42,8 @@
 #include <linux/spinlock.h>
 #include <linux/reservation.h>
 
+#define TTM_MAX_BO_PRIORITY     16
+
 struct ttm_backend_func {
 	/**
 	 * struct ttm_backend_func member bind
@@ -286,6 +288,7 @@ struct ttm_mem_type_manager {
 	struct mutex io_reserve_mutex;
 	bool use_io_reserve_lru;
 	bool io_reserve_fastpath;
+        spinlock_t move_lock;
 
 	/*
 	 * Protected by @io_reserve_mutex:
@@ -297,7 +300,11 @@ struct ttm_mem_type_manager {
 	 * Protected by the global->lru_lock.
 	 */
 
-	struct list_head lru;
+        struct list_head lru[TTM_MAX_BO_PRIORITY];
+        /*
+         * Protected by @move_lock.
+         */
+        struct fence *move;
 };
 
 /**
@@ -428,7 +435,8 @@ struct ttm_bo_driver {
 	/* hook to notify driver about a driver move so it
 	 * can do tiling things */
 	void (*move_notify)(struct ttm_buffer_object *bo,
-			    struct ttm_mem_reg *new_mem);
+                            bool evict,
+                            struct ttm_mem_reg *new_mem);
 	/* notify the driver we are taking a fault on this BO
 	 * and have reserved it */
 	int (*fault_reserve_notify)(struct ttm_buffer_object *bo);
@@ -446,7 +454,14 @@ struct ttm_bo_driver {
 	 */
 	int (*io_mem_reserve)(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem);
 	void (*io_mem_free)(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem);
-
+        /**
+         * Return the pfn for a given page_offset inside the BO.
+         *
+         * @bo: the BO to look up the pfn for
+         * @page_offset: the offset to look up
+         */
+        unsigned long (*io_mem_pfn)(struct ttm_buffer_object *bo,
+                                    unsigned long page_offset);
 	 /**
          * Optional driver callback for when BO is removed from the LRU.
          * Called with LRU lock held immediately before the removal.
@@ -504,7 +519,7 @@ struct ttm_bo_global {
 	/**
 	 * Protected by the lru_lock.
 	 */
-	struct list_head swap_lru;
+	struct list_head swap_lru[TTM_MAX_BO_PRIORITY];
 
 	/**
 	 * Internal protection.
diff --git a/include/drm/ttm/ttm_placement.h b/include/drm/ttm/ttm_placement.h
index 8ed44f9..bfdeac6 100644
--- a/include/drm/ttm/ttm_placement.h
+++ b/include/drm/ttm/ttm_placement.h
@@ -72,6 +72,7 @@
 #define TTM_PL_FLAG_CACHED      (1 << 16)
 #define TTM_PL_FLAG_UNCACHED    (1 << 17)
 #define TTM_PL_FLAG_WC          (1 << 18)
+#define TTM_PL_FLAG_CONTIGUOUS  (1 << 19)
 #define TTM_PL_FLAG_SHARED      (1 << 20)
 #define TTM_PL_FLAG_NO_EVICT    (1 << 21)
 #define TTM_PL_FLAG_TOPDOWN     (1 << 22)
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 3643189..e1855ce 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -302,6 +302,7 @@ struct pci_dev {
 	unsigned int	d2_support:1;	/* Low power state D2 is supported */
 	unsigned int	no_d1d2:1;	/* D1 and D2 are forbidden */
 	unsigned int	no_d3cold:1;	/* D3cold is forbidden */
+        unsigned int    bridge_d3:1;    /* Allow D3 for bridge */
 	unsigned int	d3cold_allowed:1;	/* D3cold is allowed by user */
 	unsigned int	mmio_always_on:1;	/* disallow turning off io/mem
 						   decoding during bar sizing */
-- 
2.7.4

