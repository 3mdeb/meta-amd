From 1ea7cb5c462bd5e4c33ece5da52cb1a4d4adc30e Mon Sep 17 00:00:00 2001
From: Mykola Lysenko <mykola.lysenko@amd.com>
Date: Fri, 12 Jun 2015 10:18:04 -0400
Subject: [PATCH 276/343] amd/dal: added LVDS encoder implementation

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Yeh, Eagle <Eagle.Yeh@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/dal/adapter/adapter_service.c  |  13 +-
 .../dal/bios/dce110/bios_parser_helper_dce110.c    |  69 +++-
 drivers/gpu/drm/amd/dal/dcs/edid/edid13.c          |   2 +-
 drivers/gpu/drm/amd/dal/dcs/edid/edid20.c          |   2 +-
 drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c    |   2 +-
 drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c     |   2 +-
 .../gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c    |   2 +-
 drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c    |   2 +-
 .../dal/display_service/ds_dispatch_mode_setting.c |  12 +-
 drivers/gpu/drm/amd/dal/encoder/Makefile           |   3 +-
 drivers/gpu/drm/amd/dal/encoder/encoder.c          |  29 +-
 .../drm/amd/dal/encoder/external_digital_encoder.c |   6 +
 .../drm/amd/dal/encoder/external_digital_encoder.h |   5 +
 .../drm/amd/dal/encoder/hw_ctx_digital_encoder.h   |   2 +
 .../encoder/hw_ctx_external_digital_encoder_hal.c  |  34 --
 .../encoder/hw_ctx_external_digital_encoder_hal.h  |  13 +-
 .../hw_ctx_external_digital_encoder_travis.c       | 320 +++++++++++++++++
 .../hw_ctx_external_digital_encoder_travis.h       |  65 ++++
 .../gpu/drm/amd/dal/encoder/travis_encoder_lvds.c  | 395 +++++++++++++++++++++
 .../gpu/drm/amd/dal/encoder/travis_encoder_lvds.h  |  36 ++
 drivers/gpu/drm/amd/dal/include/dpcd_defs.h        |   5 +
 .../gpu/drm/amd/dal/topology/tm_detection_mgr.c    |   8 +-
 22 files changed, 934 insertions(+), 93 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.c
 create mode 100644 drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.h
 create mode 100644 drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.c
 create mode 100644 drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.h

diff --git a/drivers/gpu/drm/amd/dal/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
index a86a4ec..e41ee0f 100644
--- a/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
@@ -127,7 +127,7 @@ struct feature_source_entry feature_entry_table[] = {
 	{FEATURE_TMDS_DISABLE_DITHERING, false, true},
 	{FEATURE_HDMI_DISABLE_DITHERING, false, true},
 	{FEATURE_DP_DISABLE_DITHERING, false, true},
-	{FEATURE_EMBEDDED_DISABLE_DITHERING, false, true},
+	{FEATURE_EMBEDDED_DISABLE_DITHERING, true, true},
 	{FEATURE_ALLOW_SELF_REFRESH, false, true},
 	{FEATURE_ALLOW_DYNAMIC_PIXEL_ENCODING_CHANGE, false, true},
 	{FEATURE_ALLOW_HSYNC_VSYNC_ADJUSTMENT, false, true},
@@ -1950,16 +1950,11 @@ bool dal_adapter_service_is_lid_open(struct adapter_service *as)
 	bool is_lid_open = false;
 	struct platform_info_params params;
 
-	if (!(PM_GET_LID_STATE & as->platform_methods_mask)) {
-				dal_logger_write(as->dal_context->logger,
-						LOG_MAJOR_BACKLIGHT,
-						LOG_MINOR_BACKLIGHT_LID,
-						"This method is not support\n");
-				return false;
-	}
 	params.data = &is_lid_open;
 	params.method = PM_GET_LID_STATE;
-	if (dal_get_platform_info(as->dal_context, &params))
+
+	if ((PM_GET_LID_STATE & as->platform_methods_mask) &&
+		dal_get_platform_info(as->dal_context, &params))
 		return is_lid_open;
 	else {
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
diff --git a/drivers/gpu/drm/amd/dal/bios/dce110/bios_parser_helper_dce110.c b/drivers/gpu/drm/amd/dal/bios/dce110/bios_parser_helper_dce110.c
index 05cb4757..20c05dd 100644
--- a/drivers/gpu/drm/amd/dal/bios/dce110/bios_parser_helper_dce110.c
+++ b/drivers/gpu/drm/amd/dal/bios/dce110/bios_parser_helper_dce110.c
@@ -248,6 +248,8 @@ static bool is_accelerated_mode(
 	return (value & ATOM_S6_ACC_MODE) ? true : false;
 }
 
+#define BIOS_SCRATCH0_DAC_B_SHIFT 8
+
 /**
  * detect_sink
  *
@@ -271,11 +273,50 @@ static enum signal_type detect_sink(
 	struct graphics_object_id connector,
 	enum signal_type signal)
 {
-/* Need implementation for eDP */
-	DAL_LOGGER_NOT_IMPL(
-		LOG_MINOR_COMPONENT_BIOS,
-		"Bios Parser:%s\n",
-		__func__);
+	uint32_t bios_scratch0;
+	uint32_t encoder_id = encoder.id;
+	/* after DCE 10.x does not support DAC2, so assert and return
+	 * SIGNAL_TYPE_NONE */
+	if (encoder_id == ENCODER_ID_INTERNAL_DAC2
+		|| encoder_id == ENCODER_ID_INTERNAL_KLDSCP_DAC2) {
+		ASSERT(false);
+		return SIGNAL_TYPE_NONE;
+	}
+
+	bios_scratch0 = dal_read_reg(dal_context,
+		mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF);
+
+	/* In further processing we use DACB masks. If we want detect load on
+	 * DACA, we need to shift the register so DACA bits will be in place of
+	 * DACB bits
+	 */
+	if (encoder_id == ENCODER_ID_INTERNAL_DAC1
+		|| encoder_id == ENCODER_ID_INTERNAL_KLDSCP_DAC1
+		|| encoder_id == ENCODER_ID_EXTERNAL_NUTMEG
+		|| encoder_id == ENCODER_ID_EXTERNAL_TRAVIS) {
+		bios_scratch0 <<= BIOS_SCRATCH0_DAC_B_SHIFT;
+	}
+
+	switch (signal) {
+	case SIGNAL_TYPE_RGB: {
+		if (bios_scratch0 & ATOM_S0_CRT2_MASK)
+			return SIGNAL_TYPE_RGB;
+		break;
+	}
+	case SIGNAL_TYPE_LVDS: {
+		if (bios_scratch0 & ATOM_S0_LCD1)
+			return SIGNAL_TYPE_LVDS;
+		break;
+	}
+	case SIGNAL_TYPE_EDP: {
+		if (bios_scratch0 & ATOM_S0_LCD1)
+			return SIGNAL_TYPE_EDP;
+		break;
+	}
+	default:
+		break;
+	}
+
 	return SIGNAL_TYPE_NONE;
 }
 
@@ -392,6 +433,22 @@ static void set_scratch_lcd_scale(
 		__func__);
 }
 
+static bool is_lid_open(struct dal_context *dal_context)
+{
+	uint32_t bios_scratch6;
+
+	bios_scratch6 =
+		dal_read_reg(
+			dal_context,
+			mmBIOS_SCRATCH_0 + ATOM_ACC_CHANGE_INFO_DEF);
+
+	/* lid is open if the bit is not set */
+	if (!(bios_scratch6 & ATOM_S6_LID_STATE))
+		return true;
+
+	return false;
+}
+
 /* function table */
 static const struct bios_parser_helper bios_parser_helper_funcs = {
 	.detect_sink = detect_sink,
@@ -405,7 +462,7 @@ static const struct bios_parser_helper bios_parser_helper_funcs = {
 	.is_accelerated_mode = is_accelerated_mode,
 	.is_active_display = NULL,
 	.is_display_config_changed = NULL,
-	.is_lid_open = NULL,
+	.is_lid_open = is_lid_open,
 	.is_lid_status_changed = NULL,
 	.prepare_scratch_active_and_requested =
 			prepare_scratch_active_and_requested,
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c
index abeb859..4b5f483 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c
@@ -780,7 +780,7 @@ static const struct edid_funcs funcs = {
 	.destroy = destroy,
 	.get_display_tile_info = dal_edid_base_get_display_tile_info,
 	.get_min_drr_fps = dal_edid_base_get_min_drr_fps,
-	.get_drr_pixel_clk_khz = dal_edid_get_drr_pixel_clk_khz,
+	.get_drr_pixel_clk_khz = dal_edid_base_get_drr_pixel_clk_khz,
 	.is_non_continuous_frequency =
 		dal_edid_base_is_non_continuous_frequency,
 	.get_stereo_3d_support = dal_edid_base_get_stereo_3d_support,
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c
index 889d939..3e99387 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c
@@ -557,7 +557,7 @@ static const struct edid_funcs funcs = {
 	.destroy = destroy,
 	.get_display_tile_info = dal_edid_base_get_display_tile_info,
 	.get_min_drr_fps = dal_edid_base_get_min_drr_fps,
-	.get_drr_pixel_clk_khz = dal_edid_get_drr_pixel_clk_khz,
+	.get_drr_pixel_clk_khz = dal_edid_base_get_drr_pixel_clk_khz,
 	.is_non_continuous_frequency =
 		dal_edid_base_is_non_continuous_frequency,
 	.get_stereo_3d_support = dal_edid_base_get_stereo_3d_support,
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c
index 2a59318..f536ae4 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c
@@ -1670,7 +1670,7 @@ static const struct edid_funcs funcs = {
 	.destroy = destroy,
 	.get_display_tile_info = dal_edid_base_get_display_tile_info,
 	.get_min_drr_fps = dal_edid_base_get_min_drr_fps,
-	.get_drr_pixel_clk_khz = dal_edid_get_drr_pixel_clk_khz,
+	.get_drr_pixel_clk_khz = dal_edid_base_get_drr_pixel_clk_khz,
 	.is_non_continuous_frequency =
 		dal_edid_base_is_non_continuous_frequency,
 	.get_stereo_3d_support = dal_edid_base_get_stereo_3d_support,
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c
index b2a1129..866400a 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c
@@ -251,7 +251,7 @@ static const struct edid_funcs funcs = {
 	.destroy = destroy,
 	.get_display_tile_info = dal_edid_base_get_display_tile_info,
 	.get_min_drr_fps = dal_edid_base_get_min_drr_fps,
-	.get_drr_pixel_clk_khz = dal_edid_get_drr_pixel_clk_khz,
+	.get_drr_pixel_clk_khz = dal_edid_base_get_drr_pixel_clk_khz,
 	.is_non_continuous_frequency =
 		dal_edid_base_is_non_continuous_frequency,
 	.get_stereo_3d_support = dal_edid_base_get_stereo_3d_support,
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c
index 571c7e7..03cb368 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c
@@ -62,7 +62,7 @@ static const struct edid_funcs funcs = {
 	.destroy = destroy,
 	.get_display_tile_info = dal_edid_base_get_display_tile_info,
 	.get_min_drr_fps = dal_edid_base_get_min_drr_fps,
-	.get_drr_pixel_clk_khz = dal_edid_get_drr_pixel_clk_khz,
+	.get_drr_pixel_clk_khz = dal_edid_base_get_drr_pixel_clk_khz,
 	.is_non_continuous_frequency =
 		dal_edid_base_is_non_continuous_frequency,
 	.get_stereo_3d_support = dal_edid_base_get_stereo_3d_support,
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c
index 303d46d..af291a2 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c
@@ -345,7 +345,7 @@ static const struct edid_funcs funcs = {
 	.destroy = destroy,
 	.get_display_tile_info = dal_edid_base_get_display_tile_info,
 	.get_min_drr_fps = dal_edid_base_get_min_drr_fps,
-	.get_drr_pixel_clk_khz = dal_edid_get_drr_pixel_clk_khz,
+	.get_drr_pixel_clk_khz = dal_edid_base_get_drr_pixel_clk_khz,
 	.is_non_continuous_frequency =
 		dal_edid_base_is_non_continuous_frequency,
 	.get_stereo_3d_support = dal_edid_base_get_stereo_3d_support,
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
index 7b3f3d7..5421bb4 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
@@ -2147,9 +2147,11 @@ static void set_dithering_options(
 		DISPLAY_COLOR_DEPTH_101010) &&
 		(dal_dcs_get_enabled_packed_pixel_format(
 			dal_display_path_get_dcs(display_path)) ==
-		DCS_PACKED_PIXEL_FORMAT_NOT_PACKED)) {
+		DCS_PACKED_PIXEL_FORMAT_NOT_PACKED))
 		info->dithering = HW_DITHERING_OPTION_ENABLE;
-	}
+	else
+		info->dithering = HW_DITHERING_OPTION_SKIP_PROGRAMMING;
+
 
 	signal = dal_display_path_get_config_signal(
 		display_path, ASIC_LINK_INDEX);
@@ -2185,6 +2187,12 @@ static void set_dithering_options(
 		 * due to randomness of pixel data, so we should disable it */
 		info->dithering = HW_DITHERING_OPTION_DISABLE;
 		break;
+	case SIGNAL_TYPE_LVDS:
+	case SIGNAL_TYPE_EDP:
+		if (dal_adapter_service_is_feature_supported(
+			FEATURE_EMBEDDED_DISABLE_DITHERING))
+			info->dithering = HW_DITHERING_OPTION_SKIP_PROGRAMMING;
+		break;
 	default:
 		/* Dithering should be applied (usually due to incompatible
 		 * or unsupported signal).
diff --git a/drivers/gpu/drm/amd/dal/encoder/Makefile b/drivers/gpu/drm/amd/dal/encoder/Makefile
index f68412b..72707ea 100644
--- a/drivers/gpu/drm/amd/dal/encoder/Makefile
+++ b/drivers/gpu/drm/amd/dal/encoder/Makefile
@@ -12,7 +12,8 @@ ENCODER = encoder_impl.o encoder.o hw_ctx_analog_encoder.o \
 		hw_ctx_external_digital_encoder_hal.o \
 		digital_encoder.o digital_encoder_dp.o \
 		external_digital_encoder.o \
-		wireless_encoder.o
+		hw_ctx_external_digital_encoder_travis.o \
+		wireless_encoder.o travis_encoder_lvds.o wireless_encoder.o
 
 AMD_DAL_ENCODER = $(addprefix $(AMDDALPATH)/encoder/,$(ENCODER))
 
diff --git a/drivers/gpu/drm/amd/dal/encoder/encoder.c b/drivers/gpu/drm/amd/dal/encoder/encoder.c
index cefeb01..f231ce9 100644
--- a/drivers/gpu/drm/amd/dal/encoder/encoder.c
+++ b/drivers/gpu/drm/amd/dal/encoder/encoder.c
@@ -51,6 +51,7 @@
 #include "digital_encoder_dp.h"
 #include "wireless_encoder.h"
 #include "external_digital_encoder.h"
+#include "travis_encoder_lvds.h"
 
 #if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
 #include "dce110/digital_encoder_dp_dce110.h"
@@ -203,26 +204,6 @@ struct encoder_impl *dal_nutmeg_encoder_create(
 	return NULL;
 }
 
-struct encoder_impl *dal_encoder_create_travis_encoder_vga(
-	const struct encoder_init_data *init)
-{
-	dal_logger_write(init->ctx->logger,
-			LOG_MAJOR_ERROR, LOG_MINOR_COMPONENT_ENCODER,
-			"TRAVIS-VGA encoder not supported\n");
-
-	return NULL;
-}
-
-struct encoder_impl *dal_encoder_create_travis_encoder_lvds(
-	const struct encoder_init_data *init)
-{
-	dal_logger_write(init->ctx->logger,
-			LOG_MAJOR_ERROR, LOG_MINOR_COMPONENT_ENCODER,
-			"TRAVIS-LVDS encoder not supported\n");
-
-	return NULL;
-}
-
 static struct encoder_impl *create_digital_encoder_impl(
 	enum signal_type signal,
 	const struct encoder_init_data *init)
@@ -360,9 +341,13 @@ static struct encoder_impl *create_travis_encoder_impl(
 {
 	switch (init->encoder.enum_id) {
 	case ENUM_ID_1:
-		return dal_encoder_create_travis_encoder_vga(init);
+		dal_logger_write(init->ctx->logger,
+				LOG_MAJOR_ERROR, LOG_MINOR_COMPONENT_ENCODER,
+				"TRAVIS-VGA encoder not supported\n");
+
+		return NULL;
 	case ENUM_ID_2:
-		return dal_encoder_create_travis_encoder_lvds(init);
+		return dal_travis_encoder_lvds_create(init);
 	default:
 		BREAK_TO_DEBUGGER();
 		return NULL;
diff --git a/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c b/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c
index 491db71..2b92b69 100644
--- a/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c
+++ b/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c
@@ -40,6 +40,7 @@
  */
 
 #include "external_digital_encoder.h"
+#include "hw_ctx_external_digital_encoder_travis.h"
 
 /*
  * This unit
@@ -144,6 +145,11 @@ static enum encoder_result create_hw_ctx(
 		return ENCODER_RESULT_OK;
 
 	switch (enc->base.id.id) {
+	case ENCODER_ID_EXTERNAL_TRAVIS:
+		enc->hw_ctx =
+			dal_hw_ctx_external_digital_encoder_travis_create(
+				init->dal_ctx);
+	break;
 	default:
 		BREAK_TO_DEBUGGER();
 	}
diff --git a/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.h b/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.h
index 052081b..ab97b89 100644
--- a/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.h
+++ b/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.h
@@ -26,6 +26,8 @@
 #ifndef __DAL_EXTERNAL_DIGITAL_ENCODER_H__
 #define __DAL_EXTERNAL_DIGITAL_ENCODER_H__
 
+#include "encoder_impl.h"
+
 struct external_digital_encoder;
 
 struct external_digital_encoder_funcs {
@@ -41,6 +43,9 @@ struct external_digital_encoder {
 	struct hw_ctx_external_digital_encoder_hal *hw_ctx;
 };
 
+#define FROM_ENCODER_IMPL(ptr) \
+	container_of((ptr), struct external_digital_encoder, base)
+
 bool dal_external_digital_encoder_construct(
 	struct external_digital_encoder *enc,
 	const struct encoder_init_data *init_data);
diff --git a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_digital_encoder.h b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_digital_encoder.h
index 44d9629..94ce9e6 100644
--- a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_digital_encoder.h
+++ b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_digital_encoder.h
@@ -26,6 +26,8 @@
 #ifndef __DAL_HW_CTX_DIGITAL_ENCODER_H__
 #define __DAL_HW_CTX_DIGITAL_ENCODER_H__
 
+#include "include/hw_sequencer_types.h"
+
 struct hw_ctx_init {
 	struct adapter_service *adapter_service;
 	struct graphics_object_id connector;
diff --git a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.c b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.c
index 14334a5..d81c683 100644
--- a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.c
+++ b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.c
@@ -30,8 +30,6 @@
  */
 
 #include "include/encoder_types.h"
-#include "include/fixed31_32.h"
-#include "hw_ctx_digital_encoder.h"
 
 /*
  * Header of this unit
@@ -46,38 +44,6 @@
 /*
  * This unit
  */
-bool dal_hw_ctx_external_digital_encoder_hal_get_link_cap(
-	const struct hw_ctx_external_digital_encoder_hal *ctx,
-	enum channel_id channel_id,
-	struct link_settings *link_settings)
-{
-	uint8_t buffer[DPCD_ADDRESS_RECEIVE_PORT1_CAP1 -
-			DPCD_ADDRESS_DPCD_REV + 1] = {0};
-
-	if (!link_settings) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-
-	if (!ctx->base.funcs->dpcd_read_registers(
-		&ctx->base, channel_id,
-		DPCD_ADDRESS_DPCD_REV, buffer, sizeof(buffer))) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-
-	link_settings->link_rate = buffer[DPCD_ADDRESS_MAX_LINK_RATE];
-
-	link_settings->lane_count =
-		(DPCD_VALUE_MASK_MAX_LANE_COUNT_LANE_COUNT &
-		buffer[DPCD_ADDRESS_MAX_LANE_COUNT]);
-
-	link_settings->link_spread = (DPCD_VALUE_MASK_MAX_DOWNSPREAD &
-		buffer[DPCD_ADDRESS_MAX_DOWNSPREAD]) ?
-			LINK_SPREAD_05_DOWNSPREAD_30KHZ : LINK_SPREAD_DISABLED;
-
-	return true;
-}
 
 bool dal_hw_ctx_external_digital_encoder_hal_requires_authentication(
 	const struct hw_ctx_external_digital_encoder_hal *ctx,
diff --git a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.h b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.h
index 9f7694b..aeac953 100644
--- a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.h
+++ b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_hal.h
@@ -26,13 +26,17 @@
 #ifndef __DAL_HW_CTX_EXTERNAL_DIGITAL_ENCODER_HAL_H__
 #define __DAL_HW_CTX_EXTERNAL_DIGITAL_ENCODER_HAL_H__
 
+#include "hw_ctx_digital_encoder.h"
+
 struct display_ppll_divider {
 	uint32_t ref_div;
 	uint32_t post_div;
 	uint32_t feedback_div_integer;
 	uint32_t feedback_div_fraction;
 };
+
 struct hw_ctx_external_digital_encoder_hal;
+struct hw_crtc_timing;
 
 struct hw_ctx_external_digital_encoder_hal_funcs {
 	void (*power_up)(
@@ -73,10 +77,6 @@ struct hw_ctx_external_digital_encoder_hal_funcs {
 	void (*post_ddc)(
 		struct hw_ctx_external_digital_encoder_hal *ctx,
 		enum channel_id channel_id);
-	bool (*get_link_cap)(
-		const struct hw_ctx_external_digital_encoder_hal *ctx,
-		enum channel_id channel_id,
-		struct link_settings *link_settings);
 	bool (*requires_authentication)(
 		const struct hw_ctx_external_digital_encoder_hal *ctx,
 		enum channel_id channel_id);
@@ -87,11 +87,6 @@ struct hw_ctx_external_digital_encoder_hal {
 	const struct hw_ctx_external_digital_encoder_hal_funcs *funcs;
 };
 
-bool dal_hw_ctx_external_digital_encoder_hal_get_link_cap(
-	const struct hw_ctx_external_digital_encoder_hal *ctx,
-	enum channel_id channel_id,
-	struct link_settings *link_settings);
-
 bool dal_hw_ctx_external_digital_encoder_hal_requires_authentication(
 	const struct hw_ctx_external_digital_encoder_hal *ctx,
 	enum channel_id channel_id);
diff --git a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.c b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.c
new file mode 100644
index 0000000..232f84b
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.c
@@ -0,0 +1,320 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dal_services.h"
+
+#include "include/dpcd_defs.h"
+#include "include/link_service_types.h"
+#include "include/signal_types.h"
+#include "include/grph_object_defs.h"
+
+#include "hw_ctx_external_digital_encoder_travis.h"
+
+#define TO_HW_CTX_EXTERNAL_DIGITAL_ENCODER_HAL(ptr) \
+	(container_of(\
+		(ptr),\
+		struct hw_ctx_external_digital_encoder_hal,\
+		base))
+
+static void power_up(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* Initialize external encoder during boot up and s3 resume */
+	ctx->base.funcs->dpcd_write_register(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_POWER_STATE,
+		DP_POWER_STATE_D0);
+}
+
+static void power_down(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* force initiate Travis power down by writing DPCD 600h = 2
+	 * @note DPCD 600h = 2 is also done by DP encoder before killing the
+	 * PHY, however with Travis we want to wait until travis is ready before
+	 * we kill the PHY, so we trigger power down here, and wait for travis
+	 * to complete before return
+	 */
+	ctx->base.funcs->dpcd_write_register(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_POWER_STATE,
+		DP_POWER_STATE_D3);
+}
+
+static void enable_output(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id,
+	const struct link_settings *link_settings,
+	const struct hw_crtc_timing *timing)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+static void disable_output(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* force initiate Travis power down by writing DPCD 600h = 2
+	 * @note DPCD 600h = 2 is also done by DP encoder before killing the
+	 * PHY, however with Travis we want to wait until travis is ready before
+	 * we kill the PHY, so we trigger power down here, and wait for travis
+	 * to complete before return
+	 */
+	ctx->base.funcs->dpcd_write_register(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_POWER_STATE,
+		DP_POWER_STATE_D3);
+}
+
+static void blank(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+static void unblank(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+static enum signal_type detect_load(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id,
+	enum signal_type display_signal)
+{
+	union dpcd_sink_count sink_count;
+
+	sink_count.raw = 0;
+
+	ctx->base.funcs->dpcd_write_registers(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_SINK_COUNT,
+		&sink_count.raw, sizeof(sink_count));
+
+	if (sink_count.bits.SINK_COUNT > 0)
+		return SIGNAL_TYPE_RGB;
+
+	return SIGNAL_TYPE_NONE;
+}
+
+static void pre_ddc(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+static void post_ddc(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+static void setup_frontend_phy(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id,
+	const struct link_settings *link_settings)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+static void setup_display_engine(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id,
+	const struct display_ppll_divider *display_ppll_divider)
+{
+	/* NOTHING TO DO FOR TRAVIS */
+}
+
+/* some definitions needed for Travis communication */
+enum {
+	TRAVIS_DPCD_CHIPID1 = 0x503,
+	TRAVISL_CHIPID = '2',
+	TRAVISSL_CHIPID = 'n',
+	TRAVIS_DEV_SEL_8C = 1,
+	TRAVIS_PWRSEQ_STATUS = 0xbc
+};
+
+static bool requires_authentication(
+	const struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	uint8_t uc_travis_data = 0;
+
+	ctx->base.funcs->dpcd_read_register(
+			&ctx->base,
+			channel_id,
+			DPCD_ADDRESS_POWER_STATE,
+			&uc_travis_data);
+
+	if (TRAVISL_CHIPID == uc_travis_data ||
+		TRAVISSL_CHIPID == uc_travis_data) {
+		/* Travis L does not have authentication regs */
+		return false;
+	}
+
+	return true;
+}
+
+static bool read_travis_reg(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id,
+	uint8_t address,
+	uint8_t *value)
+{
+	/* TODO: if other threads can access Travis will need to implement
+	 * locking mechanism since must perform 3 register access sequence below
+	 * for a proper read/write cycle.
+	 */
+
+	if (!ctx->base.funcs->dpcd_write_register(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_TRAVIS_SINK_DEV_SEL,
+		TRAVIS_DEV_SEL_8C)) {
+		ASSERT(false);
+		return false;
+	}
+
+	if (!ctx->base.funcs->dpcd_write_register(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_TRAVIS_SINK_ACCESS_OFFSET,
+		address)) {
+		ASSERT(false);
+		return false;
+	}
+
+	if (!ctx->base.funcs->dpcd_read_register(
+		&ctx->base,
+		channel_id,
+		DPCD_ADDRESS_TRAVIS_SINK_ACCESS_REG,
+		value)) {
+		ASSERT(false);
+		return false;
+	}
+
+	return true;
+}
+
+union travis_pwrseq_status
+	dal_hw_ctx_external_digital_encoder_travis_get_pwrseq_status(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id)
+{
+	union travis_pwrseq_status status;
+
+	read_travis_reg(ctx, channel_id, TRAVIS_PWRSEQ_STATUS, &status.raw);
+	return status;
+}
+
+static const struct hw_ctx_external_digital_encoder_hal_funcs funcs = {
+	.power_up = power_up,
+	.power_down = power_down,
+	.setup_frontend_phy = setup_frontend_phy,
+	.setup_display_engine = setup_display_engine,
+	.enable_output = enable_output,
+	.disable_output = disable_output,
+	.blank = blank,
+	.unblank = unblank,
+	.detect_load = detect_load,
+	.pre_ddc = pre_ddc,
+	.post_ddc = post_ddc,
+	.requires_authentication = requires_authentication,
+};
+
+static void destruct(struct hw_ctx_external_digital_encoder_hal *ctx)
+{
+	dal_hw_ctx_external_digital_encoder_hal_destruct(ctx);
+}
+
+static void destroy(struct hw_ctx_digital_encoder **ctx)
+{
+	destruct(TO_HW_CTX_EXTERNAL_DIGITAL_ENCODER_HAL(*ctx));
+
+	dal_free(*ctx);
+	*ctx = NULL;
+}
+
+static const struct hw_ctx_digital_encoder_funcs de_funcs = {
+	.destroy = destroy,
+	.initialize = dal_encoder_hw_ctx_digital_encoder_initialize,
+	.submit_command = dal_encoder_hw_ctx_digital_encoder_submit_command,
+	.dpcd_read_register =
+		dal_encoder_hw_ctx_digital_encoder_dpcd_read_register,
+	.dpcd_write_register =
+		dal_encoder_hw_ctx_digital_encoder_dpcd_write_register,
+	.dpcd_read_registers =
+		dal_encoder_hw_ctx_digital_encoder_dpcd_read_registers,
+	.dpcd_write_registers =
+		dal_encoder_hw_ctx_digital_encoder_dpcd_write_registers
+};
+
+static bool construct(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	struct dal_context *dal_ctx)
+{
+	if (!dal_hw_ctx_external_digital_encoder_hal_construct(ctx,
+			dal_ctx)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	ctx->funcs = &funcs;
+	ctx->base.funcs = &de_funcs;
+	return true;
+}
+
+struct hw_ctx_external_digital_encoder_hal *
+	dal_hw_ctx_external_digital_encoder_travis_create(
+		struct dal_context *dal_ctx)
+{
+	struct hw_ctx_external_digital_encoder_hal *ctx =
+		dal_alloc(sizeof(*ctx));
+
+	if (!ctx) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	if (construct(ctx, dal_ctx))
+		return ctx;
+
+	BREAK_TO_DEBUGGER();
+
+	dal_free(ctx);
+
+	return NULL;
+}
diff --git a/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.h b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.h
new file mode 100644
index 0000000..ee81836
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/encoder/hw_ctx_external_digital_encoder_travis.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DAL_HW_CTX_EXTERNAL_DIGITAL_ENCODER_TRAVIS_H__
+#define __DAL_HW_CTX_EXTERNAL_DIGITAL_ENCODER_TRAVIS_H__
+
+#include "hw_ctx_external_digital_encoder_hal.h"
+
+enum lvds_pwrseq_state {
+	LVDS_PWRSEQ_STATE_DISABLED = 0,
+	LVDS_PWRSEQ_STATE_POWER_UP0 = 1,
+	LVDS_PWRSEQ_STATE_POWER_UP1 = 2,
+	LVDS_PWRSEQ_STATE_POWER_UP2 = 3,
+	LVDS_PWRSEQ_STATE_POWER_UP_DONE = 4,
+	LVDS_PWRSEQ_STATE_POWER_DOWN0 = 5,
+	LVDS_PWRSEQ_STATE_POWER_DOWN1 = 6,
+	LVDS_PWRSEQ_STATE_POWER_DOWN2 = 7,
+	LVDS_PWRSEQ_STATE_DELAY = 8,
+	LVDS_PWRSEQ_STATE_POWER_DOWN_DONE = 9,
+	LVDS_PWRSEQ_STATE_INVALID,
+};
+
+union travis_pwrseq_status {
+	struct {
+		uint8_t DIG_ON:1;
+		uint8_t SYNC_EN:1;
+		uint8_t BL_ON:1;
+		uint8_t DONE:1;
+		uint8_t STATE:4;
+	} bits;
+	uint8_t raw;
+};
+
+struct hw_ctx_external_digital_encoder_hal *
+	dal_hw_ctx_external_digital_encoder_travis_create(
+		struct dal_context *dal_ctx);
+
+union travis_pwrseq_status
+	dal_hw_ctx_external_digital_encoder_travis_get_pwrseq_status(
+	struct hw_ctx_external_digital_encoder_hal *ctx,
+	enum channel_id channel_id);
+
+#endif
diff --git a/drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.c b/drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.c
new file mode 100644
index 0000000..a2ea375
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.c
@@ -0,0 +1,395 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dal_services.h"
+
+#include "hw_ctx_external_digital_encoder_travis.h"
+
+#include "travis_encoder_lvds.h"
+
+static void destroy(struct encoder_impl **ptr)
+{
+	struct external_digital_encoder *enc = FROM_ENCODER_IMPL(*ptr);
+
+	dal_external_digital_encoder_destruct(enc);
+	dal_free(enc);
+	*ptr = NULL;
+}
+
+static enum encoder_result initialize(
+	struct encoder_impl *impl,
+	const struct encoder_context *ctx)
+{
+	enum encoder_result result =
+		dal_external_digital_encoder_initialize(impl, ctx);
+
+	if (result != ENCODER_RESULT_OK)
+		return result;
+
+	impl->features.flags.bits.CPLIB_DP_AUTHENTICATION =
+		FROM_ENCODER_IMPL(impl)->hw_ctx->funcs->
+		requires_authentication(
+			FROM_ENCODER_IMPL(impl)->hw_ctx,
+			ctx->channel);
+
+	return ENCODER_RESULT_OK;
+}
+
+/* check whether sink is present based on SENSE detection,
+ * analog encoders will return true */
+static bool is_sink_present(
+	struct encoder_impl *impl,
+	struct graphics_object_id downstream)
+{
+	return dal_adapter_service_is_lid_open(impl->adapter_service);
+}
+
+static inline enum encoder_result blank_helper(
+	struct encoder_impl *impl,
+	bool blank)
+{
+	struct bp_external_encoder_control cntl;
+	enum bp_result result;
+
+	dal_memset(&cntl, 0, sizeof(cntl));
+
+	cntl.encoder_id = impl->id;
+	cntl.action =
+		blank ?
+			EXTERNAL_ENCODER_CONTROL_BLANK :
+			EXTERNAL_ENCODER_CONTROL_UNBLANK;
+
+	result = dal_bios_parser_external_encoder_control(
+		dal_adapter_service_get_bios_parser(impl->adapter_service),
+		&cntl);
+
+	if (result != BP_RESULT_OK)
+		return ENCODER_RESULT_ERROR;
+
+	return ENCODER_RESULT_OK;
+}
+
+static enum encoder_result blank(
+	struct encoder_impl *impl,
+	const struct encoder_context *ctx)
+{
+	return	blank_helper(impl, true);
+}
+
+static enum encoder_result unblank(
+	struct encoder_impl *impl,
+	const struct encoder_unblank_param *param)
+{
+	return blank_helper(impl, false);
+}
+
+static enum signal_type detect_sink(
+	struct encoder_impl *impl,
+	struct graphics_object_id downstream)
+{
+	return SIGNAL_TYPE_LVDS;
+}
+
+#define TRAVIS_LVDS_MAX_PIX_CLK 162000
+
+static enum encoder_result validate_output(
+	struct encoder_impl *impl,
+	const struct encoder_output *output)
+{
+	if (SIGNAL_TYPE_LVDS == output->ctx.signal &&
+		output->crtc_timing.pixel_clock <= TRAVIS_LVDS_MAX_PIX_CLK &&
+		output->crtc_timing.flags.PIXEL_ENCODING ==
+			HW_PIXEL_ENCODING_RGB)
+		return ENCODER_RESULT_OK;
+
+	return ENCODER_RESULT_ERROR;
+}
+
+/* 20ms delay between TravisPwr status poll */
+#define TRAVIS_PWR_POLL_INT 20
+/* up to 100 polls, max 2 sec */
+#define TRAVIS_PWR_POLL_TIMEOUT 100
+
+static void wait_for_pwr_down_completed(
+	struct hw_ctx_external_digital_encoder_hal *hw_ctx,
+	enum channel_id channel,
+	bool wait_done,
+	bool pwr_down)
+{
+	/*
+	 * #### Travis WA ####
+	 *
+	 * Travis LVDS is deriving clock from DP main link, and if we turn of DP
+	 * PHY before travis is finish with powering down, some panel
+	 * will show flash
+	 *
+	 * the solution is to poll for POWERDOWN2 after DPCD600=2, before
+	 * turning off DP PHY
+	 */
+	uint32_t i;
+
+	for (i = 0; i < TRAVIS_PWR_POLL_TIMEOUT; i++) {
+		union travis_pwrseq_status status =
+		dal_hw_ctx_external_digital_encoder_travis_get_pwrseq_status(
+			hw_ctx,
+			channel);
+
+		/* If we do encoder PowerDown, wait for PowerDownDone otherwise
+		 * wait for PowerDown2 to make sure that for powerdown case
+		 * VBIOS can succeed to set mode later with enabled VGA driver
+		 */
+
+		if (!wait_done && pwr_down) {
+			if (status.bits.STATE >=
+				LVDS_PWRSEQ_STATE_POWER_DOWN_DONE)
+				break;
+		} else if (!wait_done) {
+			if (status.bits.STATE >=
+				LVDS_PWRSEQ_STATE_POWER_DOWN2) {
+				/* check the value of bit 7:4 (7 = POWERDOWN2:
+				 * D=1 S=0 B=0). At this point, LVDS and BLEN
+				 * have been powered down and DP link can turn
+				 * off
+				 */
+				break;
+			}
+		}
+
+		if (status.bits.DONE)
+			break;
+
+		dal_sleep_in_milliseconds(TRAVIS_PWR_POLL_INT);
+	}
+
+}
+
+static enum encoder_result power_down(
+	struct encoder_impl *impl,
+	const struct encoder_output *output)
+{
+	FROM_ENCODER_IMPL(impl)->hw_ctx->funcs->
+		power_down(
+			FROM_ENCODER_IMPL(impl)->hw_ctx,
+			output->ctx.channel);
+
+	wait_for_pwr_down_completed(
+		FROM_ENCODER_IMPL(impl)->hw_ctx,
+		output->ctx.channel,
+		false,
+		true);
+
+	return ENCODER_RESULT_OK;
+}
+
+static bool is_link_settings_supported(
+	struct encoder_impl *impl,
+	const struct link_settings *link_settings)
+{
+	if (link_settings->link_rate == LINK_RATE_HIGH ||
+		link_settings->link_rate == LINK_RATE_LOW)
+		return true;
+
+	return false;
+}
+
+static enum encoder_result pre_enable_output(
+	struct encoder_impl *impl,
+	const struct encoder_pre_enable_output_param *param)
+{
+	wait_for_pwr_down_completed(
+		FROM_ENCODER_IMPL(impl)->hw_ctx,
+		param->ctx.channel,
+		true,
+		false);
+
+	return ENCODER_RESULT_OK;
+}
+
+static enum encoder_result enable_output(
+	struct encoder_impl *impl,
+	const struct encoder_output *output)
+{
+	struct bp_external_encoder_control cntl;
+	enum bp_result result;
+
+	dal_memset(&cntl, 0, sizeof(cntl));
+
+	cntl.encoder_id = impl->id;
+	cntl.action = EXTERNAL_ENCODER_CONTROL_ENABLE;
+	cntl.pixel_clock = output->crtc_timing.pixel_clock;
+	cntl.link_rate = output->link_settings.link_rate;
+	cntl.lanes_number = output->link_settings.lane_count;
+	cntl.signal = output->ctx.signal;
+	cntl.color_depth = output->crtc_timing.flags.COLOR_DEPTH;
+
+	result = dal_bios_parser_external_encoder_control(
+		dal_adapter_service_get_bios_parser(impl->adapter_service),
+		&cntl);
+
+	if (result != BP_RESULT_OK)
+		return ENCODER_RESULT_ERROR;
+
+	return ENCODER_RESULT_OK;
+}
+
+static enum encoder_result disable_output(
+	struct encoder_impl *impl,
+	const struct encoder_output *output)
+{
+	struct bp_external_encoder_control cntl;
+	enum bp_result result;
+
+	/* [Travis WA]
+	 * Travis LVDS is deriving clock from DP main link, and if we turn of
+	 * DP PHY before travis is finish with powering down, some panel
+	 * will show flash
+	 *
+	 * the recommended solution is to keep DP PHY on until
+	 * travis is done with power down.
+	 * Here we wait for travis to finish powering down
+	 *
+	 * ASSUMPTION
+	 * in disable sequence, output is blanked first, which would switch DP
+	 * stream from video to idle pattern (noVid, bit 3 of VBID), so power
+	 * down sequence is already initiated when this method is called.
+	 * The next in the sequence is disabling DP output, which would kill
+	 * the PHY.
+	 */
+
+	wait_for_pwr_down_completed(
+		FROM_ENCODER_IMPL(impl)->hw_ctx,
+		output->ctx.channel,
+		false,
+		false);
+
+	dal_memset(&cntl, 0, sizeof(cntl));
+
+	cntl.encoder_id = impl->id;
+	cntl.action = EXTERNAL_ENCODER_CONTROL_DISABLE;
+
+	result = dal_bios_parser_external_encoder_control(
+		dal_adapter_service_get_bios_parser(impl->adapter_service),
+		&cntl);
+
+	if (result != BP_RESULT_OK)
+		return ENCODER_RESULT_ERROR;
+
+	return ENCODER_RESULT_OK;
+}
+
+static const struct encoder_impl_funcs funcs = {
+	.destroy = destroy,
+	.power_up = dal_external_digital_encoder_power_up,
+	.power_down = power_down,
+	.setup = dal_encoder_impl_setup,
+	.pre_enable_output = pre_enable_output,
+	.enable_output = enable_output,
+	.disable_output = disable_output,
+	.blank = blank,
+	.unblank = unblank,
+	.setup_stereo = dal_encoder_impl_setup_stereo,
+	.enable_sync_output = dal_encoder_impl_enable_sync_output,
+	.disable_sync_output = dal_encoder_impl_disable_sync_output,
+	.pre_ddc = dal_encoder_impl_pre_ddc,
+	.post_ddc = dal_encoder_impl_post_ddc,
+	.set_dp_phy_pattern = dal_encoder_impl_set_dp_phy_pattern,
+	.is_sink_present = is_sink_present,
+	.detect_load = dal_encoder_impl_detect_load,
+	.detect_sink = detect_sink,
+	.get_paired_transmitter_id = dal_encoder_impl_get_paired_transmitter_id,
+	.get_phy_id = dal_encoder_impl_get_phy_id,
+	.get_paired_phy_id = dal_encoder_impl_get_paired_phy_id,
+	.is_link_settings_supported = is_link_settings_supported,
+	.get_supported_stream_engines =
+		dal_encoder_impl_get_supported_stream_engines,
+	.is_clock_source_supported =
+		dal_encoder_impl_is_clock_source_supported,
+	.validate_output = validate_output,
+	.update_info_frame = dal_encoder_impl_update_info_frame,
+	.stop_info_frame = dal_encoder_impl_stop_info_frame,
+	.set_lcd_backlight_level =
+			dal_encoder_impl_set_lcd_backlight_level,
+	.backlight_control = dal_encoder_impl_backlight_control,
+	.update_mst_alloc_table =
+		dal_encoder_impl_update_mst_alloc_table,
+	.enable_stream = dal_encoder_impl_enable_stream,
+	.disable_stream = dal_encoder_impl_disable_stream,
+	.is_test_pattern_enabled =
+			dal_encoder_impl_is_test_pattern_enabled,
+	.set_lane_settings = dal_encoder_impl_set_lane_settings,
+	.get_lane_settings = dal_encoder_impl_get_lane_settings,
+	.enable_hpd = dal_encoder_impl_enable_hpd,
+	.disable_hpd = dal_encoder_impl_disable_hpd,
+	.get_active_clock_source =
+			dal_encoder_impl_get_active_clock_source,
+	.get_active_engine = dal_encoder_impl_get_active_engine,
+	.initialize = initialize,
+	.set_stereo_gpio = dal_encoder_impl_set_stereo_gpio,
+	.set_hsync_output_gpio = dal_encoder_impl_set_hsync_output_gpio,
+	.set_vsync_output_gpio = dal_encoder_impl_set_vsync_output_gpio,
+	.release_hw = dal_encoder_impl_release_hw,
+};
+
+static bool construct(
+	struct external_digital_encoder *enc,
+	const struct encoder_init_data *init_data)
+{
+	struct encoder_impl *base = &enc->base;
+
+	if (!dal_external_digital_encoder_construct(enc, init_data)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	base->funcs = &funcs;
+	base->input_signals = SIGNAL_TYPE_DISPLAY_PORT;
+	base->output_signals = SIGNAL_TYPE_LVDS;
+
+	base->features.flags.bits.DP_RX_REQ_ALT_SCRAMBLE = 1;
+	base->features.flags.bits.CPLIB_DP_AUTHENTICATION = 1;
+
+	return true;
+}
+
+struct encoder_impl *dal_travis_encoder_lvds_create(
+	const struct encoder_init_data *init_data)
+{
+	struct external_digital_encoder *enc =
+		dal_alloc(sizeof(struct external_digital_encoder));
+
+	if (!enc) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	if (construct(enc, init_data))
+		return &enc->base;
+
+	BREAK_TO_DEBUGGER();
+
+	dal_free(enc);
+
+	return NULL;
+}
diff --git a/drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.h b/drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.h
new file mode 100644
index 0000000..0f95bc1
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/encoder/travis_encoder_lvds.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DAL_TRAVIS_ENCODER_LVDS_H__
+#define __DAL_TRAVIS_ENCODER_LVDS_H__
+
+#include "include/encoder_interface.h"
+
+#include "external_digital_encoder.h"
+
+struct encoder_impl *dal_travis_encoder_lvds_create(
+	const struct encoder_init_data *init_data);
+
+#endif
diff --git a/drivers/gpu/drm/amd/dal/include/dpcd_defs.h b/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
index 6cfcf73..468772d 100644
--- a/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
+++ b/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
@@ -227,6 +227,11 @@ enum dpcd_address {
 	DPCD_ADDRESS_PSR_SINK_STATUS = 0x2008,
 	DPCD_ADDRESS_PSR_DBG_REGISTER0 = 0x2009,
 	DPCD_ADDRESS_PSR_DBG_REGISTER1 = 0x200A,
+
+	/* Travis specific addresses */
+	DPCD_ADDRESS_TRAVIS_SINK_DEV_SEL = 0x5f0,
+	DPCD_ADDRESS_TRAVIS_SINK_ACCESS_OFFSET  = 0x5f1,
+	DPCD_ADDRESS_TRAVIS_SINK_ACCESS_REG = 0x5f2,
 };
 
 enum dpcd_revision {
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
index d418a11..e0b25cb 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
@@ -750,14 +750,14 @@ static bool read_edid(
 	/*On successful Edid read we need to update detection status*/
 	if (status == EDID_RETRIEVE_SUCCESS ||
 		status == EDID_RETRIEVE_SAME_EDID) {
-		enum dcs_edid_connector_type connectorType;
+		enum dcs_edid_connector_type connector_type;
 		enum display_dongle_type dongle;
 		enum signal_type signal;
 		/*apply EDID-based sink capability patches*/
 		apply_detection_status_patches(
 				tm_dm, display_path, detection_status);
 
-		connectorType = dal_dcs_get_connector_type(
+		connector_type = dal_dcs_get_connector_type(
 				dal_display_path_get_dcs(display_path));
 
 		signal = detection_status->detected_signal;
@@ -767,13 +767,13 @@ static bool read_edid(
 		/*check whether EDID connector is right for the signal*/
 		if (tm_utils_is_edid_connector_type_valid_with_signal_type(
 				dongle,
-				connectorType, signal)) {
+				connector_type, signal)) {
 			/*downgrade signal in case it has
 			 *  changed but EDID hasn't*/
 			detection_status->detected_signal =
 				tm_utils_get_downgraded_signal_type(
 						signal,
-						connectorType);
+						connector_type);
 
 			/* report connected since edid successfully detected*/
 			connected = true;
-- 
1.9.1

