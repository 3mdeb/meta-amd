From a09e916e9ce73785d081811fd9955d05f20d5b92 Mon Sep 17 00:00:00 2001
From: Amy Zhang <Amy.Zhang@amd.com>
Date: Wed, 14 Sep 2016 14:25:25 -0400
Subject: [PATCH 1086/1722] drm/amd/dal: PSR dc functions

- Created link encoder functions for PSR setup,and enable/disable
- Created PSR waitloop function in display clock
- Created timing generator function to set static screen control
event mask
- Set vsc info frame packet information values for PSR
- Retrieve PSR link caps

Change-Id: Ibef2d4bad164c98ebd1be2b94e1942ec999e047a
Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  43 +++
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          | 134 ++++++++
 drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c       |  31 ++
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  44 +++
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  11 +-
 drivers/gpu/drm/amd/dal/dc/dc_types.h              |  15 +
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  21 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  12 +-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    | 360 ++++++++++++++++++++-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.h    |  77 +++++
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  27 +-
 .../amd/dal/dc/dce110/dce110_timing_generator.c    |  24 +-
 .../amd/dal/dc/dce110/dce110_timing_generator.h    |   4 +
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  21 +-
 drivers/gpu/drm/amd/dal/dc/dm_services.h           |   1 +
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |  55 ++++
 drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h   | 119 +++++++
 .../gpu/drm/amd/dal/dc/inc/hw/timing_generator.h   |   2 +
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |   3 +
 19 files changed, 993 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 4815657..0e6e143 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -316,6 +316,43 @@ static bool set_abm_level(struct dc *dc, unsigned int abm_level)
 	return true;
 }
 
+static bool set_psr_enable(struct dc *dc, bool enable)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_set_psr_enable(&core_dc->links[i]->public,
+				enable);
+
+	return true;
+}
+
+
+static bool setup_psr(struct dc *dc, const struct dc_stream *stream)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
+	struct pipe_ctx *pipes;
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_setup_psr(&core_dc->links[i]->public,
+				stream);
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
+			== core_stream) {
+
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.set_static_screen_control(&pipes, 1,
+					0x182);
+		}
+	}
+
+	return true;
+}
+
 static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 {
 	core_dc->public.stream_funcs.stream_update_scaling = stream_update_scaling;
@@ -332,6 +369,12 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 
 	core_dc->public.stream_funcs.set_abm_level =
 			set_abm_level;
+
+	core_dc->public.stream_funcs.set_psr_enable =
+			set_psr_enable;
+
+	core_dc->public.stream_funcs.setup_psr =
+			setup_psr;
 }
 
 static bool construct(struct core_dc *dc,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index ae34228..0f395ca 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -38,6 +38,8 @@
 #include "link_encoder.h"
 #include "hw_sequencer.h"
 #include "fixed31_32.h"
+#include "adapter/adapter_service.h"
+#include "include/asic_capability_interface.h"
 
 #define LINK_INFO(...) \
 	dal_logger_write(dc_ctx->logger, \
@@ -1417,6 +1419,138 @@ bool dc_link_set_abm_level(const struct dc_link *dc_link, uint32_t level)
 	return true;
 }
 
+bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable)
+{
+	struct core_link *link = DC_LINK_TO_CORE(dc_link);
+	struct dc_context *ctx = link->ctx;
+
+	if (dc_link != NULL && dc_link->psr_caps.psr_version > 0)
+		link->link_enc->funcs->set_dmcu_psr_enable(link->link_enc,
+								enable);
+	return true;
+}
+
+bool dc_link_setup_psr(const struct dc_link *dc_link,
+		const struct dc_stream *stream)
+{
+
+	struct core_link *link = DC_LINK_TO_CORE(dc_link);
+	struct dc_context *ctx = link->ctx;
+	struct core_dc *core_dc = DC_TO_CORE(ctx->dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
+
+	struct psr_dmcu_context psr_context = {0};
+
+	psr_context.controllerId = CONTROLLER_ID_UNDEFINED;
+	int i;
+
+	if (dc_link != NULL && dc_link->psr_caps.psr_version > 0) {
+		/* updateSinkPsrDpcdConfig*/
+		union dpcd_psr_configuration psr_configuration = {0};
+
+		psr_configuration.bits.ENABLE                    = 1;
+		psr_configuration.bits.CRC_VERIFICATION          = 1;
+		psr_configuration.bits.FRAME_CAPTURE_INDICATION  =
+			dc_link->psr_caps.psr_frame_capture_indication_req;
+
+		/* Check for PSR v2*/
+		if (dc_link->psr_caps.psr_version == 0x2) {
+			/* For PSR v2 selective update.
+			 * Indicates whether sink should start capturing
+			 * immediately following active scan line,
+			 * or starting with the 2nd active scan line.
+			 */
+			psr_configuration.bits.LINE_CAPTURE_INDICATION = 0;
+			/*For PSR v2, determines whether Sink should generate
+			 * IRQ_HPD when CRC mismatch is detected.
+			 */
+			psr_configuration.bits.IRQ_HPD_WITH_CRC_ERROR    = 1;
+		}
+		dal_ddc_service_write_dpcd_data(
+					link->ddc,
+					368,
+					&psr_configuration.raw,
+					sizeof(psr_configuration.raw));
+
+		psr_context.channel = link->ddc->ddc_pin->hw_info.ddc_channel;
+		if (psr_context.channel == 0)
+			psr_context.channel = 1;
+		psr_context.transmitterId = link->link_enc->transmitter;
+		psr_context.engineId = link->link_enc->preferred_engine;
+
+		for (i = 0; i < MAX_PIPES; i++) {
+			if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
+					== core_stream) {
+				/* dmcu -1 for all controller id values,
+				 * therefore +1 here
+				 */
+				psr_context.controllerId =
+					core_dc->current_context->res_ctx.
+					pipe_ctx[i].tg->inst + 1;
+				break;
+			}
+		}
+
+		/* Hardcoded for now.  Can be Pcie or Uniphy (or Unknown)*/
+		psr_context.phyType = PHY_TYPE_UNIPHY;
+		/*PhyId is associated with the transmitter id*/
+		psr_context.smuPhyId = link->link_enc->transmitter;
+
+		psr_context.crtcTimingVerticalTotal = stream->timing.v_total;
+		psr_context.vsyncRateHz = div64_u64(div64_u64((stream->
+						timing.pix_clk_khz * 1000),
+						stream->timing.v_total),
+						stream->timing.h_total);
+
+		psr_context.psrSupportedDisplayConfig =
+			(dc_link->psr_caps.psr_version > 0) ? true : false;
+		psr_context.psrExitLinkTrainingRequired =
+			dc_link->psr_caps.psr_exit_link_training_required;
+		psr_context.sdpTransmitLineNumDeadline =
+			dc_link->psr_caps.psr_sdp_transmit_line_num_deadline;
+		psr_context.psrFrameCaptureIndicationReq =
+			dc_link->psr_caps.psr_frame_capture_indication_req;
+
+		psr_context.skipPsrWaitForPllLock =
+				link->link_enc->adapter_service->
+				asic_cap->caps.SKIP_PSR_WAIT_FOR_PLL_LOCK_BIT;
+
+		psr_context.numberOfControllers =
+				link->link_enc->adapter_service->asic_cap->
+				data[ASIC_DATA_CONTROLLERS_NUM];
+
+		psr_context.rfb_update_auto_en = true;
+
+		/* 2 frames before enter PSR. */
+		psr_context.timehyst_frames = 2;
+		/* half a frame
+		 * (units in 100 lines, i.e. a value of 1 represents 100 lines)
+		 */
+		psr_context.hyst_lines = stream->timing.v_total / 2 / 100;
+		psr_context.aux_repeats = 10;
+
+		psr_context.psr_level.u32all = 0;
+
+		/* SMU will perform additional powerdown sequence.
+		 * For unsupported ASICs, set psr_level flag to skip PSR
+		 *  static screen notification to SMU.
+		 *  (Always set for DAL2, did not check ASIC)
+		 */
+		psr_context.psr_level.bits.SKIP_SMU_NOTIFICATION = 1;
+
+		/* Controls additional delay after remote frame capture before
+		 * continuing power down, default = 0
+		 */
+		psr_context.frame_delay = 0;
+
+		link->link_enc->funcs->setup_dmcu_psr
+			(link->link_enc, &psr_context);
+		return true;
+	} else
+		return false;
+
+}
+
 const struct dc_link_status *dc_link_get_status(const struct dc_link *dc_link)
 {
 	struct core_link *link = DC_LINK_TO_CORE(dc_link);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
index 05e755b..8472aa7 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
@@ -1738,6 +1738,36 @@ static void dp_wa_power_up_0010FA(struct core_link *link, uint8_t *dpcd_data,
 		link->wa_flags.dp_keep_receiver_powered = false;
 }
 
+static void retrieve_psr_link_cap(struct core_link *link,
+		enum edp_revision edp_revision)
+{
+	if (edp_revision >= EDP_REVISION_13) {
+		core_link_read_dpcd(link,
+				DPCD_ADDRESS_PSR_SUPPORT_VER,
+				(uint8_t *)(&link->public.psr_caps),
+				sizeof(link->public.psr_caps));
+		if (link->public.psr_caps.psr_version != 0) {
+			unsigned char psr_capability = 0;
+
+			core_link_read_dpcd(link,
+					DPCD_ADDRESS_PSR_CAPABILITY,
+						&psr_capability,
+						sizeof(psr_capability));
+			/* Bit 0 determines whether fast link training is
+			 * required on PSR exit. If set to 0, link training
+			 * is required. If set to 1, sink must lock within
+			 * five Idle Patterns after Main Link is turned on.
+			 */
+			link->public.psr_caps.psr_exit_link_training_required
+						= !(psr_capability & 0x1);
+
+			psr_capability = (psr_capability >> 1) & 0x7;
+			link->public.psr_caps.psr_rfb_setup_time =
+					55 * (6 - psr_capability);
+		}
+	}
+}
+
 static void retrieve_link_cap(struct core_link *link)
 {
 	uint8_t dpcd_data[DPCD_ADDRESS_TRAINING_AUX_RD_INTERVAL - DPCD_ADDRESS_DPCD_REV + 1];
@@ -1827,6 +1857,7 @@ static void retrieve_link_cap(struct core_link *link)
 	CONN_DATA_DETECT(link, dpcd_data, sizeof(dpcd_data), "Rx Caps: ");
 
 	/* TODO: Confirm if need retrieve_psr_link_cap */
+	retrieve_psr_link_cap(link, link->edp_revision);
 }
 
 void detect_dp_sink_caps(struct core_link *link)
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index c914876..6c23e75c 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -1678,6 +1678,49 @@ static void set_spd_info_packet(struct core_stream *stream,
 	info_packet->valid = true;
 }
 
+static void set_vsc_info_packet(struct core_stream *stream,
+		struct hw_info_packet *info_packet)
+{
+	unsigned int vscPacketRevision = 0;
+	unsigned int i;
+	bool psrPanelSupport = false;
+
+	if (stream->sink->link->public.psr_caps.psr_version != 0) {
+		psrPanelSupport = true;
+		vscPacketRevision = 2;
+	}
+
+	/* VSC packet not needed based on the features
+	 * supported by this DP display
+	 */
+	if (vscPacketRevision == 0)
+		return;
+
+	if (vscPacketRevision == 0x2) {
+		/* Secondary-data Packet ID = 0*/
+		info_packet->hb0 = 0x00;
+		/* 07h - Packet Type Value indicating Video
+		 * Stream Configuration packet
+		 */
+		info_packet->hb1 = 0x07;
+		/* 02h = VSC SDP supporting 3D stereo and PSR
+		 * (applies to eDP v1.3 or higher).
+		 */
+		info_packet->hb2 = 0x02;
+		/* 08h = VSC packet supporting 3D stereo + PSR
+		 * (HB2 = 02h).
+		 */
+		info_packet->hb3 = 0x08;
+
+		for (i = 0; i < 28; i++)
+			info_packet->sb[i] = 0;
+
+		info_packet->valid = true;
+	}
+
+	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
+}
+
 void resource_validate_ctx_destruct(struct validate_context *context)
 {
 	int i, j;
@@ -1760,6 +1803,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 	}
 
 	else if (dc_is_dp_signal(signal))
+		set_vsc_info_packet(pipe_ctx->stream, &info_frame.vsc_packet);
 		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
 
 	translate_info_frame(&info_frame,
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 67b8350..c28ba93 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -70,8 +70,10 @@ struct dc_stream_funcs {
 	bool (*set_gamut_remap)(struct dc *dc,
 			const struct dc_stream **stream, int num_streams);
 	bool (*set_backlight)(struct dc *dc, unsigned int backlight_level,
-			unsigned int frame_ramp, const struct dc_stream *stream);
+		unsigned int frame_ramp, const struct dc_stream *stream);
 	bool (*set_abm_level)(struct dc *dc, unsigned int abm_level);
+	bool (*set_psr_enable)(struct dc *dc, bool enable);
+	bool (*setup_psr)(struct dc *dc, const struct dc_stream *stream);
 };
 
 /* Structure to hold configuration flags set by dm at dc creation. */
@@ -456,6 +458,8 @@ struct dc_link {
 
 	uint8_t ddc_hw_inst;
 	uint8_t link_enc_hw_inst;
+
+	struct psr_caps psr_caps;
 };
 
 struct dpcd_caps {
@@ -502,6 +506,11 @@ bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
 
 bool dc_link_set_abm_level(const struct dc_link *dc_link, uint32_t level);
 
+bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable);
+
+bool dc_link_setup_psr(const struct dc_link *dc_link,
+		const struct dc_stream *stream);
+
 /* Request DC to detect if there is a Panel connected.
  * boot - If this call is during initial boot.
  * Return false for any type of detection failure or MST detection
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_types.h b/drivers/gpu/drm/amd/dal/dc/dc_types.h
index d84657f..c6561d3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_types.h
@@ -537,4 +537,19 @@ struct csc_transform {
 	bool enable_adjustment;
 };
 
+struct psr_caps {
+	/* These parameters are from PSR capabilities reported by Sink DPCD */
+	unsigned char psr_version;
+	unsigned int psr_rfb_setup_time;
+	bool psr_exit_link_training_required;
+
+	/* These parameters are calculated in Driver,
+	 * based on display timing and Sink capabilities.
+	 * If VBLANK region is too small and Sink takes a long time
+	 * to set up RFB, it may take an extra frame to enter PSR state.
+	 */
+	bool psr_frame_capture_indication_req;
+	unsigned int psr_sdp_transmit_line_num_deadline;
+};
+
 #endif /* DC_TYPES_H_ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 083a0f0..6a95960 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -63,6 +63,14 @@
 	#define mmBIOS_SCRATCH_2 0x05CB
 #endif
 
+#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL
+	#define mmDP_DPHY_BS_SR_SWAP_CNTL 0x4ADC
+#endif
+
+#ifndef mmDP0_DP_DPHY_FAST_TRAINING
+	#define mmDP0_DP_DPHY_FAST_TRAINING 0x193A
+#endif
+
 static const struct dce110_timing_generator_offsets dce100_tg_offsets[] = {
 	{
 		.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),
@@ -217,9 +225,20 @@ static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 static const struct dce110_link_enc_dmcu_registers link_enc_dmcu_regs = {
 		.BL1_PWM_USER_LEVEL = mmBL1_PWM_USER_LEVEL,
 		.MASTER_COMM_DATA_REG1 = mmMASTER_COMM_DATA_REG1,
+		.MASTER_COMM_DATA_REG2 = mmMASTER_COMM_DATA_REG2,
+		.MASTER_COMM_DATA_REG3 = mmMASTER_COMM_DATA_REG3,
 		.MASTER_COMM_CMD_REG = mmMASTER_COMM_CMD_REG,
 		.MASTER_COMM_CNTL_REG = mmMASTER_COMM_CNTL_REG,
-		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2
+		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2,
+		.DMCU_RAM_ACCESS_CTRL = mmDMCU_RAM_ACCESS_CTRL,
+		.DCI_MEM_PWR_STATUS = mmDCI_MEM_PWR_STATUS,
+		.DMCU_IRAM_RD_CTRL = mmDMCU_IRAM_RD_CTRL,
+		.DMCU_IRAM_RD_DATA = mmDMCU_IRAM_RD_DATA,
+		.DP_DPHY_FAST_TRAINING = mmDP_DPHY_FAST_TRAINING,
+		.DP_DPHY_BS_SR_SWAP_CNTL = mmDP_DPHY_BS_SR_SWAP_CNTL,
+		.DMCU_INTERRUPT_TO_UC_EN_MASK = mmDMCU_INTERRUPT_TO_UC_EN_MASK,
+		.DP_SEC_CNTL1 = mmDP_SEC_CNTL1,
+		.SMU_INTERRUPT_CONTROL = mmSMU_INTERRUPT_CONTROL
 };
 
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 5cf86fc..04a73a1 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1340,6 +1340,15 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	}
 }
 
+static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
+		int num_pipes, int value)
+{
+	unsigned int i;
+
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->
+			set_static_screen_control(pipe_ctx[i]->tg, value);
+}
 /*TODO: const validate_context*/
 static enum dc_status apply_ctx_to_hw(
 		struct core_dc *dc,
@@ -2098,7 +2107,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_displaymarks = set_displaymarks,
 	.increase_watermarks_for_pipe = dce110_increase_watermarks_for_pipe,
 	.set_bandwidth = dce110_set_bandwidth,
-	.set_drr = set_drr
+	.set_drr = set_drr,
+	.set_static_screen_control = set_static_screen_control
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 1dc4794..f5835a5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -97,6 +97,14 @@
 /* Set backlight level */
 #define MCP_BL_SET 0x67
 
+/* PSR related commands */
+#define PSR_ENABLE 0x20
+#define PSR_EXIT 0x21
+#define PSR_SET 0x23
+
+/*TODO: Used for psr wakeup for set backlight level*/
+static unsigned int psr_crtc_offset;
+
 enum {
 	DP_MST_UPDATE_MAX_RETRY = 50
 };
@@ -123,6 +131,8 @@ static const struct link_encoder_funcs dce110_lnk_enc_funcs = {
 	.set_dmcu_backlight_level =
 			dce110_link_encoder_set_dmcu_backlight_level,
 	.set_dmcu_abm_level = dce110_link_encoder_set_dmcu_abm_level,
+	.set_dmcu_psr_enable = dce110_link_encoder_set_dmcu_psr_enable,
+	.setup_dmcu_psr = dce110_link_encoder_setup_dmcu_psr,
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
@@ -1823,8 +1833,8 @@ void dce110_link_encoder_set_dmcu_backlight_level(
 		regValue = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
 		dmcu_max_retry_on_wait_reg_ready--;
 	} while
-	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) !=
-		(MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & 0) &&
+	/* expected value is 0, loop while not 0*/
+	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) &&
 		dmcu_max_retry_on_wait_reg_ready > 0);
 
 	/* setDMCUParam_BL */
@@ -1888,8 +1898,8 @@ void dce110_link_encoder_set_dmcu_abm_level(
 		regValue = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
 		dmcu_max_retry_on_wait_reg_ready--;
 	} while
-	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) !=
-		(MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & 0) &&
+	/* expected value is 0, loop while not 0*/
+	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) &&
 		dmcu_max_retry_on_wait_reg_ready > 0);
 
 	/* setDMCUParam_ABMLevel */
@@ -1916,6 +1926,348 @@ void dce110_link_encoder_set_dmcu_abm_level(
 	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG), masterComCntl);
 }
 
+static void get_dmcu_psr_state(struct link_encoder *enc, uint32_t *psr_state)
+{
+	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
+	struct dc_context *ctx = enc110->base.ctx;
+
+	uint32_t ramAccessCntrl;
+	uint32_t powerStatus;
+
+	uint32_t count = 0;
+	uint32_t psrStateOffset = 0xf0;
+
+	/* Enable write access to IRAM */
+	ramAccessCntrl = dm_read_reg(ctx, DMCU_REG(DMCU_RAM_ACCESS_CTRL));
+	set_reg_field_value(
+				ramAccessCntrl,
+				1,
+				DMCU_RAM_ACCESS_CTRL,
+				IRAM_HOST_ACCESS_EN);
+	dm_write_reg(ctx, DMCU_REG(DMCU_RAM_ACCESS_CTRL), ramAccessCntrl);
+
+	do {
+		dm_delay_in_microseconds(ctx, 2);
+		powerStatus = dm_read_reg(ctx, DMCU_REG(DCI_MEM_PWR_STATUS));
+	} while
+		(get_reg_field_value(powerStatus, DCI_MEM_PWR_STATUS,
+				DMCU_IRAM_MEM_PWR_STATE) != 0 && count++ < 10);
+
+	/* Write address to IRAM_RD_ADDR in DMCU_IRAM_RD_CTRL */
+	dm_write_reg(ctx, DMCU_REG(DMCU_IRAM_RD_CTRL), psrStateOffset);
+
+	/* Read data from IRAM_RD_DATA in DMCU_IRAM_RD_DATA*/
+	*psr_state = dm_read_reg(ctx, DMCU_REG(DMCU_IRAM_RD_DATA));
+
+	/* Disable write access to IRAM after finished using IRAM
+	 * in order to allow dynamic sleep state
+	 */
+	set_reg_field_value(
+				ramAccessCntrl,
+				0,
+				DMCU_RAM_ACCESS_CTRL,
+				IRAM_HOST_ACCESS_EN);
+	dm_write_reg(ctx, DMCU_REG(DMCU_RAM_ACCESS_CTRL), ramAccessCntrl);
+}
+
+void dce110_link_encoder_set_dmcu_psr_enable(struct link_encoder *enc,
+								bool enable)
+{
+	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
+	struct dc_context *ctx = enc110->base.ctx;
+
+	unsigned int dmcu_max_retry_on_wait_reg_ready = 801;
+	unsigned int dmcu_wait_reg_ready_interval = 100;
+
+	unsigned int regValue;
+	uint32_t masterCmd;
+	uint32_t masterComCntl;
+
+	unsigned int retryCount;
+	uint32_t psr_state = 0;
+
+	/* waitDMCUReadyForCmd */
+	do {
+		dm_delay_in_microseconds(ctx, dmcu_wait_reg_ready_interval);
+		regValue = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
+		dmcu_max_retry_on_wait_reg_ready--;
+	} while
+	/* expected value is 0, loop while not 0*/
+	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) &&
+		dmcu_max_retry_on_wait_reg_ready > 0);
+
+	/* setDMCUParam_Cmd */
+	masterCmd = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CMD_REG));
+	if (enable)
+		set_reg_field_value(
+				masterCmd,
+				PSR_ENABLE,
+				MASTER_COMM_CMD_REG,
+				MASTER_COMM_CMD_REG_BYTE0);
+	else
+		set_reg_field_value(
+				masterCmd,
+				PSR_EXIT,
+				MASTER_COMM_CMD_REG,
+				MASTER_COMM_CMD_REG_BYTE0);
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CMD_REG), masterCmd);
+
+	/* notifyDMCUMsg */
+	masterComCntl = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
+	set_reg_field_value(
+			masterComCntl,
+			1,
+			MASTER_COMM_CNTL_REG,
+			MASTER_COMM_INTERRUPT);
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG), masterComCntl);
+
+	for (retryCount = 0; retryCount <= 100; retryCount++) {
+		get_dmcu_psr_state(enc, &psr_state);
+		if (enable) {
+			if (psr_state != 0)
+				break;
+		} else {
+			if (psr_state == 0)
+				break;
+		}
+		dm_delay_in_microseconds(ctx, 10);
+	}
+}
+
+void dce110_link_encoder_setup_dmcu_psr(struct link_encoder *enc,
+			struct psr_dmcu_context *psr_context)
+{
+	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
+	struct dc_context *ctx = enc110->base.ctx;
+
+	unsigned int dmcu_max_retry_on_wait_reg_ready = 801;
+	unsigned int dmcu_wait_reg_ready_interval = 100;
+	unsigned int regValue;
+
+	uint32_t dphyFastTraining;
+	uint32_t dpDphyBsSrSwapCntl;
+	uint32_t interruptEnableMask;
+	uint32_t dpSecCntl1;
+	uint32_t smuInterruptControl;
+	uint32_t masterCmd;
+	uint32_t masterComCntl;
+	union dce110_dmcu_psr_config_data_reg1 masterCmdData1;
+	union dce110_dmcu_psr_config_data_reg2 masterCmdData2;
+	union dce110_dmcu_psr_config_data_reg3 masterCmdData3;
+
+	dphyFastTraining = dm_read_reg(ctx, LINK_REG(DP_DPHY_FAST_TRAINING));
+	if (psr_context->psrExitLinkTrainingRequired)
+		set_reg_field_value(
+					dphyFastTraining,
+					1,
+					DP_DPHY_FAST_TRAINING,
+					DPHY_RX_FAST_TRAINING_CAPABLE);
+	else {
+		set_reg_field_value(
+					dphyFastTraining,
+					0,
+					DP_DPHY_FAST_TRAINING,
+					DPHY_RX_FAST_TRAINING_CAPABLE);
+		/*In DCE 11, we are able to pre-program a Force SR register
+		 * to be able to trigger SR symbol after 5 idle patterns
+		 * transmitted. Upon PSR Exit, DMCU can trigger
+		 * DPHY_LOAD_BS_COUNT_START = 1. Upon writing 1 to
+		 * DPHY_LOAD_BS_COUNT_START and the internal counter
+		 * reaches DPHY_LOAD_BS_COUNT, the next BS symbol will be
+		 * replaced by SR symbol once.
+		 */
+		dpDphyBsSrSwapCntl =
+			dm_read_reg(ctx, LINK_REG(DP_DPHY_BS_SR_SWAP_CNTL));
+		set_reg_field_value(
+					dpDphyBsSrSwapCntl,
+					0x5,
+					DP_DPHY_BS_SR_SWAP_CNTL,
+					DPHY_LOAD_BS_COUNT);
+		dm_write_reg(ctx, LINK_REG(DP_DPHY_BS_SR_SWAP_CNTL),
+						dpDphyBsSrSwapCntl);
+	}
+	dm_write_reg(ctx, LINK_REG(DP_DPHY_FAST_TRAINING), dphyFastTraining);
+
+	/* Enable static screen interrupts for PSR supported display */
+	interruptEnableMask =
+		dm_read_reg(ctx, DMCU_REG(DMCU_INTERRUPT_TO_UC_EN_MASK));
+	/* Disable the interrupt coming from other displays. */
+	set_reg_field_value(
+				interruptEnableMask,
+				0,
+				DMCU_INTERRUPT_TO_UC_EN_MASK,
+				STATIC_SCREEN1_INT_TO_UC_EN);
+	set_reg_field_value(
+				interruptEnableMask,
+				0,
+				DMCU_INTERRUPT_TO_UC_EN_MASK,
+				STATIC_SCREEN2_INT_TO_UC_EN);
+	set_reg_field_value(
+				interruptEnableMask,
+				0,
+				DMCU_INTERRUPT_TO_UC_EN_MASK,
+				STATIC_SCREEN3_INT_TO_UC_EN);
+	set_reg_field_value(
+				interruptEnableMask,
+				0,
+				DMCU_INTERRUPT_TO_UC_EN_MASK,
+				STATIC_SCREEN4_INT_TO_UC_EN);
+
+	switch (psr_context->controllerId) {
+	/* Driver uses case 1 for unconfigured */
+	case 1:
+		psr_crtc_offset = mmCRTC0_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		set_reg_field_value(
+					interruptEnableMask,
+					1,
+					DMCU_INTERRUPT_TO_UC_EN_MASK,
+					STATIC_SCREEN1_INT_TO_UC_EN);
+		break;
+	case 2:
+		psr_crtc_offset = mmCRTC1_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		set_reg_field_value(
+					interruptEnableMask,
+					1,
+					DMCU_INTERRUPT_TO_UC_EN_MASK,
+					STATIC_SCREEN2_INT_TO_UC_EN);
+		break;
+	case 3:
+		psr_crtc_offset = mmCRTC2_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		set_reg_field_value(
+					interruptEnableMask,
+					1,
+					DMCU_INTERRUPT_TO_UC_EN_MASK,
+					STATIC_SCREEN3_INT_TO_UC_EN);
+		break;
+	case 4:
+		psr_crtc_offset = mmCRTC3_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		set_reg_field_value(
+					interruptEnableMask,
+					1,
+					DMCU_INTERRUPT_TO_UC_EN_MASK,
+					STATIC_SCREEN4_INT_TO_UC_EN);
+		break;
+	case 5:
+		psr_crtc_offset = mmCRTC4_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		/* CZ/NL only has 4 CRTC!!
+		 * really valid.
+		 * There is no interrupt enable mask for these instances.
+		 */
+		break;
+	case 6:
+		psr_crtc_offset = mmCRTC5_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		/* CZ/NL only has 4 CRTC!!
+		 * These are here because they are defined in HW regspec,
+		 * but not really valid. There is no interrupt enable mask
+		 * for these instances.
+		 */
+		break;
+	default:
+		psr_crtc_offset = mmCRTC0_CRTC_STATIC_SCREEN_CONTROL -
+				mmCRTC0_CRTC_STATIC_SCREEN_CONTROL;
+		set_reg_field_value(
+					interruptEnableMask,
+					1,
+					DMCU_INTERRUPT_TO_UC_EN_MASK,
+					STATIC_SCREEN1_INT_TO_UC_EN);
+		break;
+	}
+	dm_write_reg(ctx, DMCU_REG(DMCU_INTERRUPT_TO_UC_EN_MASK),
+							interruptEnableMask);
+
+	dpSecCntl1 = dm_read_reg(ctx, LINK_REG(DP_SEC_CNTL1));
+	set_reg_field_value(
+				dpSecCntl1,
+				psr_context->sdpTransmitLineNumDeadline,
+				DP_SEC_CNTL1,
+				DP_SEC_GSP0_LINE_NUM);
+	set_reg_field_value(
+				dpSecCntl1,
+				1,
+				DP_SEC_CNTL1,
+				DP_SEC_GSP0_PRIORITY);
+	dm_write_reg(ctx, LINK_REG(DP_SEC_CNTL1), dpSecCntl1);
+
+	if (psr_context->psr_level.bits.SKIP_SMU_NOTIFICATION) {
+		smuInterruptControl =
+			dm_read_reg(ctx, DMCU_REG(SMU_INTERRUPT_CONTROL));
+		set_reg_field_value(
+					smuInterruptControl,
+					1,
+					SMU_INTERRUPT_CONTROL,
+					DC_SMU_INT_ENABLE);
+		dm_write_reg(ctx, DMCU_REG(SMU_INTERRUPT_CONTROL),
+						smuInterruptControl);
+	}
+
+	/* waitDMCUReadyForCmd */
+	do {
+		dm_delay_in_microseconds(ctx, dmcu_wait_reg_ready_interval);
+		regValue = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
+		dmcu_max_retry_on_wait_reg_ready--;
+	} while
+	/* expected value is 0, loop while not 0*/
+	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) &&
+		dmcu_max_retry_on_wait_reg_ready > 0);
+
+	/* setDMCUParam_PSRHostConfigData */
+	masterCmdData1.u32All = 0;
+	masterCmdData1.bits.timehyst_frames = psr_context->timehyst_frames;
+	masterCmdData1.bits.hyst_lines = psr_context->hyst_lines;
+	masterCmdData1.bits.rfb_update_auto_en =
+			psr_context->rfb_update_auto_en;
+	masterCmdData1.bits.dp_port_num = psr_context->transmitterId;
+	masterCmdData1.bits.dcp_sel = psr_context->controllerId;
+	masterCmdData1.bits.phy_type  = psr_context->phyType;
+	masterCmdData1.bits.frame_cap_ind =
+			psr_context->psrFrameCaptureIndicationReq;
+	masterCmdData1.bits.aux_chan = psr_context->channel;
+	masterCmdData1.bits.aux_repeat = psr_context->aux_repeats;
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_DATA_REG1),
+					masterCmdData1.u32All);
+
+	masterCmdData2.u32All = 0;
+	masterCmdData2.bits.dig_fe = psr_context->engineId;
+	masterCmdData2.bits.dig_be = psr_context->transmitterId;
+	masterCmdData2.bits.skip_wait_for_pll_lock =
+			psr_context->skipPsrWaitForPllLock;
+	masterCmdData2.bits.frame_delay = psr_context->frame_delay;
+	masterCmdData2.bits.smu_phy_id = psr_context->smuPhyId;
+	masterCmdData2.bits.num_of_controllers =
+			psr_context->numberOfControllers;
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_DATA_REG2),
+			masterCmdData2.u32All);
+
+	masterCmdData3.u32All = 0;
+	masterCmdData3.bits.psr_level = psr_context->psr_level.u32all;
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_DATA_REG3),
+			masterCmdData3.u32All);
+
+	/* setDMCUParam_Cmd */
+	masterCmd = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CMD_REG));
+	set_reg_field_value(
+			masterCmd,
+			PSR_SET,
+			MASTER_COMM_CMD_REG,
+			MASTER_COMM_CMD_REG_BYTE0);
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CMD_REG), masterCmd);
+
+	/* notifyDMCUMsg */
+	masterComCntl = dm_read_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG));
+	set_reg_field_value(
+			masterComCntl,
+			1,
+			MASTER_COMM_CNTL_REG,
+			MASTER_COMM_INTERRUPT);
+	dm_write_reg(ctx, DMCU_REG(MASTER_COMM_CNTL_REG), masterComCntl);
+}
+
 void dce110_link_encoder_connect_dig_be_to_fe(
 	struct link_encoder *enc,
 	enum engine_id engine,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
index 2534b4d..709d3c6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
@@ -42,9 +42,20 @@ struct dce110_link_enc_bl_registers {
 struct dce110_link_enc_dmcu_registers {
 	uint32_t BL1_PWM_USER_LEVEL;
 	uint32_t MASTER_COMM_DATA_REG1;
+	uint32_t MASTER_COMM_DATA_REG2;
+	uint32_t MASTER_COMM_DATA_REG3;
 	uint32_t MASTER_COMM_CMD_REG;
 	uint32_t MASTER_COMM_CNTL_REG;
 	uint32_t BIOS_SCRATCH_2;
+	uint32_t DMCU_RAM_ACCESS_CTRL;
+	uint32_t DCI_MEM_PWR_STATUS;
+	uint32_t DMCU_IRAM_RD_CTRL;
+	uint32_t DMCU_IRAM_RD_DATA;
+	uint32_t DP_DPHY_FAST_TRAINING;
+	uint32_t DP_DPHY_BS_SR_SWAP_CNTL;
+	uint32_t DMCU_INTERRUPT_TO_UC_EN_MASK;
+	uint32_t DP_SEC_CNTL1;
+	uint32_t SMU_INTERRUPT_CONTROL;
 };
 
 struct dce110_link_enc_aux_registers {
@@ -71,6 +82,9 @@ struct dce110_link_enc_registers {
 	uint32_t DP_MSE_SAT_UPDATE;
 	uint32_t DP_SEC_CNTL;
 	uint32_t DP_VID_STREAM_CNTL;
+	uint32_t DP_DPHY_FAST_TRAINING;
+	uint32_t DP_DPHY_BS_SR_SWAP_CNTL;
+	uint32_t DP_SEC_CNTL1;
 };
 
 struct dce110_link_encoder {
@@ -81,6 +95,63 @@ struct dce110_link_encoder {
 	const struct dce110_link_enc_dmcu_registers *dmcu_regs;
 };
 
+/*******************************************************************
+*   MASTER_COMM_DATA_REG1   Bit position    Data
+*                           7:0	            hyst_frames[7:0]
+*                           14:8	        hyst_lines[6:0]
+*                           15	            RFB_UPDATE_AUTO_EN
+*                           18:16	        phy_num[2:0]
+*                           21:19	        dcp_sel[2:0]
+*                           22	            phy_type
+*                           23	            frame_cap_ind
+*                           26:24	        aux_chan[2:0]
+*                           30:27	        aux_repeat[3:0]
+*                           31:31	        reserved[31:31]
+*******************************************************************/
+union dce110_dmcu_psr_config_data_reg1 {
+	struct {
+		unsigned int timehyst_frames:8;    /*[7:0]*/
+		unsigned int hyst_lines:7;         /*[14:8]*/
+		unsigned int rfb_update_auto_en:1; /*[15:15]*/
+		unsigned int dp_port_num:3;        /*[18:16]*/
+		unsigned int dcp_sel:3;            /*[21:19]*/
+		unsigned int phy_type:1;           /*[22:22]*/
+		unsigned int frame_cap_ind:1;      /*[23:23]*/
+		unsigned int aux_chan:3;           /*[26:24]*/
+		unsigned int aux_repeat:4;         /*[30:27]*/
+		unsigned int reserved:1;           /*[31:31]*/
+	} bits;
+	unsigned int u32All;
+};
+
+/*******************************************************************
+*   MASTER_COMM_DATA_REG2
+*******************************************************************/
+union dce110_dmcu_psr_config_data_reg2 {
+	struct {
+		unsigned int dig_fe:3;                  /*[2:0]*/
+		unsigned int dig_be:3;                  /*[5:3]*/
+		unsigned int skip_wait_for_pll_lock:1;  /*[6:6]*/
+		unsigned int reserved:9;                /*[15:7]*/
+		unsigned int frame_delay:8;             /*[23:16]*/
+		unsigned int smu_phy_id:4;              /*[27:24]*/
+		unsigned int num_of_controllers:4;      /*[31:28]*/
+	} bits;
+	unsigned int u32All;
+};
+
+/*******************************************************************
+*   MASTER_COMM_DATA_REG3
+*******************************************************************/
+union dce110_dmcu_psr_config_data_reg3 {
+	struct {
+		unsigned int psr_level:16;      /*[15:0]*/
+		unsigned int link_rate:4;       /*[19:16]*/
+		unsigned int reserved:12;       /*[31:20]*/
+	} bits;
+	unsigned int u32All;
+};
+
 bool dce110_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
@@ -175,6 +246,12 @@ void dce110_link_encoder_set_dmcu_abm_level(
 	struct link_encoder *enc,
 	uint32_t level);
 
+void dce110_link_encoder_set_dmcu_psr_enable(
+		struct link_encoder *enc, bool enable);
+
+void dce110_link_encoder_setup_dmcu_psr(struct link_encoder *enc,
+			struct psr_dmcu_context *psr_context);
+
 void dce110_link_encoder_edp_backlight_control(
 	struct link_encoder *enc,
 	bool enable);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index ca12e53..548e78a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -65,6 +65,18 @@
 	#define mmBIOS_SCRATCH_2 0x05CB
 #endif
 
+#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL
+	#define mmDP_DPHY_BS_SR_SWAP_CNTL 0x4ADC
+#endif
+
+#ifndef mmDP0_DP_DPHY_FAST_TRAINING
+	#define mmDP0_DP_DPHY_FAST_TRAINING 0x193A
+#endif
+
+#ifndef DPHY_RX_FAST_TRAINING_CAPABLE
+	#define DPHY_RX_FAST_TRAINING_CAPABLE 0x1
+#endif
+
 static const struct dce110_timing_generator_offsets dce110_tg_offsets[] = {
 	{
 		.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),
@@ -167,9 +179,17 @@ static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 static const struct dce110_link_enc_dmcu_registers link_enc_dmcu_regs = {
 		.BL1_PWM_USER_LEVEL = mmBL1_PWM_USER_LEVEL,
 		.MASTER_COMM_DATA_REG1 = mmMASTER_COMM_DATA_REG1,
+		.MASTER_COMM_DATA_REG2 = mmMASTER_COMM_DATA_REG2,
+		.MASTER_COMM_DATA_REG3 = mmMASTER_COMM_DATA_REG3,
 		.MASTER_COMM_CMD_REG = mmMASTER_COMM_CMD_REG,
 		.MASTER_COMM_CNTL_REG = mmMASTER_COMM_CNTL_REG,
-		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2
+		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2,
+		.DMCU_RAM_ACCESS_CTRL = mmDMCU_RAM_ACCESS_CTRL,
+		.DCI_MEM_PWR_STATUS = mmDCI_MEM_PWR_STATUS,
+		.DMCU_IRAM_RD_CTRL = mmDMCU_IRAM_RD_CTRL,
+		.DMCU_IRAM_RD_DATA = mmDMCU_IRAM_RD_DATA,
+		.DMCU_INTERRUPT_TO_UC_EN_MASK = mmDMCU_INTERRUPT_TO_UC_EN_MASK,
+		.SMU_INTERRUPT_CONTROL = mmSMU_INTERRUPT_CONTROL
 };
 
 #define aux_regs(id)\
@@ -206,7 +226,10 @@ static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
 	.DP_MSE_SAT2 = mmDP ## id ## _DP_MSE_SAT2,\
 	.DP_MSE_SAT_UPDATE = mmDP ## id ## _DP_MSE_SAT_UPDATE,\
 	.DP_SEC_CNTL = mmDP ## id ## _DP_SEC_CNTL,\
-	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL\
+	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL,\
+	.DP_DPHY_FAST_TRAINING = mmDP ## id ## _DP_DPHY_FAST_TRAINING,\
+	.DP_DPHY_BS_SR_SWAP_CNTL = mmDP ## id ## _DP_DPHY_BS_SR_SWAP_CNTL,\
+	.DP_SEC_CNTL1  = mmDP ## id ## _DP_SEC_CNTL1\
 }
 
 static const struct dce110_link_enc_registers link_enc_regs[] = {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index 8af0462..17bd65b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -484,6 +484,26 @@ void dce110_timing_generator_set_drr(
 	dm_write_reg(tg->ctx, addr, static_screen_cntl);
 }
 
+void dce110_timing_generator_set_static_screen_control(
+	struct timing_generator *tg,
+	uint32_t value)
+{
+	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
+	uint32_t static_screen_cntl = 0;
+	uint32_t addr = 0;
+
+	addr = CRTC_REG(mmCRTC_STATIC_SCREEN_CONTROL);
+	static_screen_cntl = dm_read_reg(tg->ctx, addr);
+
+	set_reg_field_value(static_screen_cntl,
+				value,
+				CRTC_STATIC_SCREEN_CONTROL,
+				CRTC_STATIC_SCREEN_EVENT_MASK);
+
+
+	dm_write_reg(tg->ctx, addr, static_screen_cntl);
+}
+
 /*
  * get_vblank_counter
  *
@@ -1552,7 +1572,9 @@ static const struct timing_generator_funcs dce110_tg_funcs = {
 		.enable_advanced_request =
 				dce110_timing_generator_enable_advanced_request,
 		.set_drr =
-				dce110_timing_generator_set_drr
+				dce110_timing_generator_set_drr,
+		.set_static_screen_control =
+			dce110_timing_generator_set_static_screen_control
 
 };
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
index 12d24b7..86ba373 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
@@ -226,6 +226,10 @@ void dce110_timing_generator_set_drr(
 	struct timing_generator *tg,
 	const struct drr_params *params);
 
+void dce110_timing_generator_set_static_screen_control(
+	struct timing_generator *tg,
+	uint32_t value);
+
 uint32_t dce110_timing_generator_get_crtc_scanoutpos(
 	struct timing_generator *tg,
 	uint32_t *vbl,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index c40bbce..3484646 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -65,6 +65,14 @@
 	#define mmBIOS_SCRATCH_2 0x05CB
 #endif
 
+#ifndef mmDP_DPHY_BS_SR_SWAP_CNTL
+	#define mmDP_DPHY_BS_SR_SWAP_CNTL 0x4ADC
+#endif
+
+#ifndef mmDP0_DP_DPHY_FAST_TRAINING
+	#define mmDP0_DP_DPHY_FAST_TRAINING 0x193A
+#endif
+
 enum dce112_clk_src_array_id {
 	DCE112_CLK_SRC_PLL0,
 	DCE112_CLK_SRC_PLL1,
@@ -215,9 +223,20 @@ static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 static const struct dce110_link_enc_dmcu_registers link_enc_dmcu_regs = {
 		.BL1_PWM_USER_LEVEL = mmBL1_PWM_USER_LEVEL,
 		.MASTER_COMM_DATA_REG1 = mmMASTER_COMM_DATA_REG1,
+		.MASTER_COMM_DATA_REG2 = mmMASTER_COMM_DATA_REG2,
+		.MASTER_COMM_DATA_REG3 = mmMASTER_COMM_DATA_REG3,
 		.MASTER_COMM_CMD_REG = mmMASTER_COMM_CMD_REG,
 		.MASTER_COMM_CNTL_REG = mmMASTER_COMM_CNTL_REG,
-		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2
+		.BIOS_SCRATCH_2 = mmBIOS_SCRATCH_2,
+		.DMCU_RAM_ACCESS_CTRL = mmDMCU_RAM_ACCESS_CTRL,
+		.DCI_MEM_PWR_STATUS = mmDCI_MEM_PWR_STATUS,
+		.DMCU_IRAM_RD_CTRL = mmDMCU_IRAM_RD_CTRL,
+		.DMCU_IRAM_RD_DATA = mmDMCU_IRAM_RD_DATA,
+		.DP_DPHY_FAST_TRAINING = mmDP_DPHY_FAST_TRAINING,
+		.DP_DPHY_BS_SR_SWAP_CNTL = mmDP_DPHY_BS_SR_SWAP_CNTL,
+		.DMCU_INTERRUPT_TO_UC_EN_MASK = mmDMCU_INTERRUPT_TO_UC_EN_MASK,
+		.DP_SEC_CNTL1 = mmDP_SEC_CNTL1,
+		.SMU_INTERRUPT_CONTROL = mmSMU_INTERRUPT_CONTROL
 };
 
 #define aux_regs(id)\
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services.h b/drivers/gpu/drm/amd/dal/dc/dm_services.h
index ca5fb9b..8176dce 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services.h
@@ -335,6 +335,7 @@ bool dm_query_extended_brightness_caps
 			struct dm_acpi_atif_backlight_caps *pCaps);
 
 bool dm_dmcu_set_pipe(struct dc_context *ctx, unsigned int controller_id);
+
 /*
  *
  * print-out services
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index b499d8e..dfe875d 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -40,6 +40,8 @@
 #define FROM_DISPLAY_CLOCK(base) \
 	container_of(base, struct display_clock_dce110, disp_clk_base)
 
+#define PSR_SET_WAITLOOP 0x31
+
 static struct state_dependent_clocks max_clks_by_state[] = {
 /*ClocksStateInvalid - should not be used*/
 { .display_clk_khz = 0, .pixel_clk_khz = 0 },
@@ -86,6 +88,14 @@ enum divider_range_step_size {
 	DIVIDER_RANGE_03_STEP_SIZE = 100 /* 1.00 */
 };
 
+union dce110_dmcu_psr_config_data_wait_loop_reg1 {
+	struct {
+		unsigned int waitLoop:16; /* [15:0] */
+		unsigned int reserved:16; /* [31:16] */
+	} bits;
+	unsigned int u32All;
+};
+
 static struct divider_range divider_ranges[DIVIDER_RANGE_MAX];
 
 #define DCE110_DFS_BYPASS_THRESHOLD_KHZ 400000
@@ -775,6 +785,49 @@ static enum clocks_state get_required_clocks_state(
 	return low_req_clk;
 }
 
+static void psr_wait_loop(struct dc_context *ctx, unsigned int display_clk_khz)
+{
+	unsigned int dmcu_max_retry_on_wait_reg_ready = 801;
+	unsigned int dmcu_wait_reg_ready_interval = 100;
+	unsigned int regValue;
+	uint32_t masterCmd;
+	uint32_t masterComCntl;
+	union dce110_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;
+
+	/* waitDMCUReadyForCmd */
+	do {
+		dm_delay_in_microseconds(ctx, dmcu_wait_reg_ready_interval);
+		regValue = dm_read_reg(ctx, mmMASTER_COMM_CNTL_REG);
+		dmcu_max_retry_on_wait_reg_ready--;
+	} while
+	/* expected value is 0, loop while not 0*/
+	((MASTER_COMM_CNTL_REG__MASTER_COMM_INTERRUPT_MASK & regValue) &&
+		dmcu_max_retry_on_wait_reg_ready > 0);
+
+	masterCmdData1.u32All = 0;
+	masterCmdData1.bits.waitLoop = display_clk_khz / 1000 / 7;
+	dm_write_reg(ctx, mmMASTER_COMM_DATA_REG1, masterCmdData1.u32All);
+
+	/* setDMCUParam_Cmd */
+	masterCmd = dm_read_reg(ctx, mmMASTER_COMM_CMD_REG);
+	set_reg_field_value(
+		masterCmd,
+		PSR_SET_WAITLOOP,
+		MASTER_COMM_CMD_REG,
+		MASTER_COMM_CMD_REG_BYTE0);
+
+	dm_write_reg(ctx, mmMASTER_COMM_CMD_REG, masterCmd);
+
+	/* notifyDMCUMsg */
+	masterComCntl = dm_read_reg(ctx, mmMASTER_COMM_CNTL_REG);
+	set_reg_field_value(
+		masterComCntl,
+		1,
+		MASTER_COMM_CNTL_REG,
+		MASTER_COMM_INTERRUPT);
+	dm_write_reg(ctx, mmMASTER_COMM_CNTL_REG, masterComCntl);
+}
+
 static void set_clock(
 	struct display_clock *base,
 	uint32_t requested_clk_khz)
@@ -807,6 +860,8 @@ static void set_clock(
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
 	if (requested_clk_khz == 0)
 		base->cur_min_clks_state = CLOCKS_STATE_NOMINAL;
+
+	psr_wait_loop(base->ctx, requested_clk_khz);
 }
 
 static void set_clock_state(
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
index 962520c..403cef8 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
@@ -111,6 +111,9 @@ struct link_encoder_funcs {
 	void (*set_dmcu_backlight_level)(struct link_encoder *enc,
 		uint32_t level, uint32_t frame_ramp, uint32_t controller_id);
 	void (*set_dmcu_abm_level)(struct link_encoder *enc, uint32_t level);
+	void (*set_dmcu_psr_enable)(struct link_encoder *enc, bool enable);
+	void (*setup_dmcu_psr)(struct link_encoder *enc,
+			struct psr_dmcu_context *psr_context);
 	void (*backlight_control) (struct link_encoder *enc,
 		bool enable);
 	void (*power_control) (struct link_encoder *enc,
@@ -121,4 +124,120 @@ struct link_encoder_funcs {
 	void (*destroy)(struct link_encoder **enc);
 };
 
+
+enum physical_phy_id {
+	PHYLD_0,
+	PHYLD_1,
+	PHYLD_2,
+	PHYLD_3,
+	PHYLD_4,
+	PHYLD_5,
+	PHYLD_6,
+	PHYLD_7,
+	PHYLD_8,
+	PHYLD_9,
+	PHYLD_COUNT,
+	PHYLD_UNKNOWN = (-1L)
+};
+
+enum phy_type {
+	PHY_TYPE_UNKNOWN  = 1,
+	PHY_TYPE_PCIE_PHY = 2,
+	PHY_TYPE_UNIPHY = 3,
+};
+
+union dmcu_psr_level {
+	struct {
+		unsigned int SKIP_CRC:1;
+		unsigned int SKIP_DP_VID_STREAM_DISABLE:1;
+		unsigned int SKIP_PHY_POWER_DOWN:1;
+		unsigned int SKIP_AUX_ACK_CHECK:1;
+		unsigned int SKIP_CRTC_DISABLE:1;
+		unsigned int SKIP_AUX_RFB_CAPTURE_CHECK:1;
+		unsigned int SKIP_SMU_NOTIFICATION:1;
+		unsigned int SKIP_AUTO_STATE_ADVANCE:1;
+		unsigned int DISABLE_PSR_ENTRY_ABORT:1;
+		unsigned int RESERVED:23;
+	} bits;
+	unsigned int u32all;
+};
+
+union dpcd_psr_configuration {
+	struct {
+		unsigned char ENABLE                    : 1;
+		unsigned char TRANSMITTER_ACTIVE_IN_PSR : 1;
+		unsigned char CRC_VERIFICATION          : 1;
+		unsigned char FRAME_CAPTURE_INDICATION  : 1;
+		/* For eDP 1.4, PSR v2*/
+		unsigned char LINE_CAPTURE_INDICATION   : 1;
+		/* For eDP 1.4, PSR v2*/
+		unsigned char IRQ_HPD_WITH_CRC_ERROR    : 1;
+		unsigned char RESERVED                  : 2;
+	} bits;
+	unsigned char raw;
+};
+
+struct psr_dmcu_context {
+	/* ddc line */
+	enum channel_id channel;
+	/* Transmitter id */
+	enum transmitter transmitterId;
+	/* Engine Id is used for Dig Be source select */
+	enum engine_id engineId;
+	/* Controller Id used for Dig Fe source select */
+	enum controller_id controllerId;
+	/* Pcie or Uniphy */
+	enum phy_type phyType;
+	/* Physical PHY Id used by SMU interpretation */
+	enum physical_phy_id smuPhyId;
+	/* Vertical total pixels from crtc timing.
+	 * This is used for static screen detection.
+	 * ie. If we want to detect half a frame,
+	 * we use this to determine the hyst lines.
+	 */
+	unsigned int crtcTimingVerticalTotal;
+	/* PSR supported from panel capabilities and
+	 * current display configuration
+	 */
+	bool psrSupportedDisplayConfig;
+	/* Whether fast link training is supported by the panel */
+	bool psrExitLinkTrainingRequired;
+	/* If RFB setup time is greater than the total VBLANK time,
+	 * it is not possible for the sink to capture the video frame
+	 * in the same frame the SDP is sent. In this case,
+	 * the frame capture indication bit should be set and an extra
+	 * static frame should be transmitted to the sink.
+	 */
+	bool psrFrameCaptureIndicationReq;
+	/* Set the last possible line SDP may be transmitted without violating
+	 * the RFB setup time or entering the active video frame.
+	 */
+	unsigned int sdpTransmitLineNumDeadline;
+	/* The VSync rate in Hz used to calculate the
+	 * step size for smooth brightness feature
+	 */
+	unsigned int vsyncRateHz;
+	unsigned int skipPsrWaitForPllLock;
+	unsigned int numberOfControllers;
+	/* Unused, for future use. To indicate that first changed frame from
+	 * state3 shouldn't result in psr_inactive, but rather to perform
+	 * an automatic single frame rfb_update.
+	 */
+	bool rfb_update_auto_en;
+	/* Number of frame before entering static screen */
+	unsigned int timehyst_frames;
+	/* Partial frames before entering static screen */
+	unsigned int hyst_lines;
+	/* # of repeated AUX transaction attempts to make before
+	 * indicating failure to the driver
+	 */
+	unsigned int aux_repeats;
+	/* Controls hw blocks to power down during PSR active state */
+	union dmcu_psr_level psr_level;
+	/* Controls additional delay after remote frame capture before
+	 * continuing powerd own
+	 */
+	unsigned int frame_delay;
+};
+
 #endif /* LINK_ENCODER_H_ */
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
index 8e79b88..334a6ab 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
@@ -150,6 +150,8 @@ struct timing_generator_funcs {
 	void (*enable_advanced_request)(struct timing_generator *tg,
 					bool enable, const struct dc_crtc_timing *timing);
 	void (*set_drr)(struct timing_generator *tg, const struct drr_params *params);
+	void (*set_static_screen_control)(struct timing_generator *tg,
+							uint32_t value);
 };
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index befb801..20b0ece 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -142,6 +142,9 @@ struct hw_sequencer_funcs {
 
 	void (*set_drr)(struct pipe_ctx **pipe_ctx, int num_pipes,
 			int vmin, int vmax);
+
+	void (*set_static_screen_control)(struct pipe_ctx **pipe_ctx,
+			int num_pipes, int value);
 };
 
 void color_space_to_black_color(
-- 
2.7.4

