From dce20b10128c060c117718744ba66a59c885ab62 Mon Sep 17 00:00:00 2001
From: Mykola Lysenko <mykola.lysenko@amd.com>
Date: Fri, 10 Jul 2015 05:46:40 -0400
Subject: [PATCH 370/401] amd/dal: add ranges for tm_resource

This will simplify debugging

Reviewed-By: David Rokhvarg <David.Rokhvarg@amd.com>
Signed-off-by: Mykola Lysenko <mykola.lysenko@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c | 133 +++++++++-------
 drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h |  13 +-
 drivers/gpu/drm/amd/dal/topology/topology.c        | 168 ++++++++++-----------
 3 files changed, 171 insertions(+), 143 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
index 7ae6361..9cff5e0 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
@@ -58,6 +58,8 @@ struct tm_resource_mgr {
 
 	struct flat_set *resources;
 
+	struct tm_resource_range resources_range[OBJECT_TYPE_COUNT];
+
 	/* This lookup will be used to translate IRQ source to Display Index.
 	 * The translation will occur on every Vblank interrupt. */
 	uint32_t controller_to_display_path_lookup[CONTROLLER_ID_MAX + 1];
@@ -707,8 +709,7 @@ struct tm_resource *tm_resource_mgr_add_engine(
 	if (engine >= ENGINE_ID_COUNT)
 		return NULL;
 
-	id = dal_graphics_object_id_init(engine, ENUM_ID_1,
-		OBJECT_TYPE_ENGINE);
+	id = dal_graphics_object_id_init(engine, ENUM_ID_1, OBJECT_TYPE_ENGINE);
 
 	return dal_tm_resource_mgr_add_resource(tm_rm,
 		dal_tm_resource_engine_create(id));
@@ -731,12 +732,12 @@ void tm_resource_mgr_relink_encoders(struct tm_resource_mgr *tm_rm)
 	struct encoder *encoder;
 	struct encoder *paired_encoder;
 
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	const struct tm_resource_range *range =
+		dal_tmrm_get_resource_range_by_type(tm_rm, OBJECT_TYPE_ENCODER);
 
-		encoder_rsrc = tm_resource_mgr_enum_resource(tm_rm, i);
+	for (i = range->start; i < range->end; i++) {
 
-		if (GRPH_ID(encoder_rsrc).type != OBJECT_TYPE_ENCODER)
-			continue;
+		encoder_rsrc = tm_resource_mgr_enum_resource(tm_rm, i);
 
 		encoder = TO_ENCODER(encoder_rsrc);
 
@@ -753,17 +754,11 @@ void tm_resource_mgr_relink_encoders(struct tm_resource_mgr *tm_rm)
 			continue;
 		}
 
-		for (pair = 0;
-			pair < tm_resource_mgr_get_total_resources_num(tm_rm);
-			pair++) {
+		for (pair = range->start; pair < range->end; pair++) {
 
 			paired_encoder_rsrc = tm_resource_mgr_enum_resource(
 					tm_rm, pair);
 
-			if (GRPH_ID(paired_encoder_rsrc).type !=
-					OBJECT_TYPE_ENCODER)
-				continue;
-
 			paired_encoder = TO_ENCODER(paired_encoder_rsrc);
 
 			if (dal_encoder_get_transmitter(paired_encoder)
@@ -899,13 +894,14 @@ tm_resource_mgr_find_engine_resource(
 	struct dal_context *dal_context = tm_rm->dal_context;
 	uint32_t i;
 	struct tm_resource *tm_resource;
+	const struct tm_resource_range *engines =
+		dal_tmrm_get_resource_range_by_type(tm_rm, OBJECT_TYPE_ENGINE);
 
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	for (i = engines->start; i < engines->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(tm_resource).id == engine_id &&
-			GRPH_ID(tm_resource).type == OBJECT_TYPE_ENGINE) {
+		if (GRPH_ID(tm_resource).id == engine_id) {
 			/* We can ignore 'id.enum' for engine
 			 * because it is not used. */
 			return tm_resource;
@@ -1049,7 +1045,7 @@ static bool tmrm_resources_available(struct tm_resource_mgr *tm_rm,
  *
  * \return index if available controller, RESOURCE_INVALID_INDEX otherwise
  */
-static uint32_t tmrm_find_controller_for_display_path(
+static uint32_t dal_tmrm_find_controller_for_display_path(
 		struct tm_resource_mgr *tm_rm,
 		uint32_t exclude_mask)
 {
@@ -1057,14 +1053,15 @@ static uint32_t tmrm_find_controller_for_display_path(
 	uint32_t controller_res_ind = RESOURCE_INVALID_INDEX;
 	uint32_t i;
 	struct tm_resource *tm_resource;
+	const struct tm_resource_range *controllers =
+		dal_tmrm_get_resource_range_by_type(
+			tm_rm,
+			OBJECT_TYPE_CONTROLLER);
 
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	for (i = controllers->start; i < controllers->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-			continue;
-
 		if (tm_utils_test_bit(&exclude_mask, GRPH_ID(tm_resource).id))
 			continue;
 
@@ -1109,6 +1106,7 @@ static uint32_t tmrm_get_available_clock_source(
 	enum clock_sharing_group clock_sharing_group;
 	enum signal_type signal;
 	enum clock_sharing_level clock_sharing_level;
+	const struct tm_resource_range *clock_sources;
 
 	TM_ASSERT(display_path != NULL);
 
@@ -1123,19 +1121,18 @@ static uint32_t tmrm_get_available_clock_source(
 	clock_sharing_group = dal_display_path_get_clock_sharing_group(
 			display_path);
 
+	clock_sources =
+		dal_tmrm_get_resource_range_by_type(
+			tm_rm,
+			OBJECT_TYPE_CLOCK_SOURCE);
+
 	/* Round 1: Try to find already used (in shared mode) Clock Source */
 	if (clock_sharing_group != CLOCK_SHARING_GROUP_EXCLUSIVE) {
 
-		for (i = 0;
-			i < tm_resource_mgr_get_total_resources_num(tm_rm);
-			i++) {
+		for (i = clock_sources->start; i < clock_sources->end; i++) {
 
 			tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-			if (GRPH_ID(tm_resource).type !=
-				OBJECT_TYPE_CLOCK_SOURCE)
-				continue;
-
 			clock_source = TO_CLOCK_SOURCE(tm_resource);
 
 			clock_source_id = dal_clock_source_get_id(clock_source);
@@ -1158,13 +1155,10 @@ static uint32_t tmrm_get_available_clock_source(
 
 	/* Round 2: If shared Clock Source was not found - try to find
 	 *	available Clock Source */
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	for (i = clock_sources->start; i < clock_sources->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CLOCK_SOURCE)
-			continue;
-
 		if (false == is_resource_available(tm_resource))
 			continue;
 
@@ -1222,6 +1216,8 @@ enum engine_id tmrm_get_available_stream_engine(
 	union supported_stream_engines supported_stream_engines;
 	uint32_t i;
 	struct dal_context *dal_context = tm_rm->dal_context;
+	const struct tm_resource_range *engines =
+		dal_tmrm_get_resource_range_by_type(tm_rm, OBJECT_TYPE_ENGINE);
 
 	TM_ASSERT(display_path != NULL);
 
@@ -1252,18 +1248,14 @@ enum engine_id tmrm_get_available_stream_engine(
 	preferred_engine_id = dal_encoder_get_preferred_stream_engine(encoder);
 
 	if (preferred_engine_id != ENGINE_ID_UNKNOWN) {
+
 		/* Use preferred engine as available engine for now */
 		available_engine_id = preferred_engine_id;
 
-		for (i = 0;
-			i < tm_resource_mgr_get_total_resources_num(tm_rm);
-			i++) {
+		for (i = engines->start; i < engines->end; i++) {
 
 			tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-			if (GRPH_ID(tm_resource).type != OBJECT_TYPE_ENGINE)
-				continue;
-
 			if (GRPH_ID(tm_resource).id == preferred_engine_id)
 				break;
 		}
@@ -1284,15 +1276,9 @@ enum engine_id tmrm_get_available_stream_engine(
 				dal_encoder_get_supported_stream_engines(
 							encoder);
 
-		for (i = 0;
-			i < tm_resource_mgr_get_total_resources_num(tm_rm);
-			i++) {
-
+		for (i = engines->start; i < engines->end; i++) {
 			tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-			if (GRPH_ID(tm_resource).type != OBJECT_TYPE_ENGINE)
-				continue;
-
 			if (false == tm_utils_is_supported_engine(
 					supported_stream_engines,
 					GRPH_ID(tm_resource).id))
@@ -2006,7 +1992,7 @@ enum tm_result tm_resource_mgr_acquire_resources(
 
 	/* Obtain indexes of available resources which are NOT permanent
 	 * to display path. */
-	controller_index = tmrm_find_controller_for_display_path(tm_rm, 0);
+	controller_index = dal_tmrm_find_controller_for_display_path(tm_rm, 0);
 	if (controller_index == RESOURCE_INVALID_INDEX)
 		return TM_RESULT_FAILURE;
 
@@ -2507,6 +2493,8 @@ tm_resource_mgr_get_available_sync_output_for_display_path(
 	enum sync_source current_sync_source;
 	bool path_contains_obj;
 	uint32_t i;
+	const struct tm_resource_range *encoders =
+		dal_tmrm_get_resource_range_by_type(tm_rm, OBJECT_TYPE_ENCODER);
 
 	if (display_path == NULL ||
 		!dal_display_path_is_acquired(display_path)) {
@@ -2516,13 +2504,9 @@ tm_resource_mgr_get_available_sync_output_for_display_path(
 	}
 
 	/* Loop over all encoders */
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
-
+	for (i = encoders->start; i < encoders->end; i++) {
 		encoder_rsrc = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(encoder_rsrc).type != OBJECT_TYPE_ENCODER)
-			continue;
-
 		/* We are looking for an encoder with the requested sync-output
 		 * capabilities, that satisfies one of these:
 		 * 1. Encoder acquired on issued display path (as encoder or
@@ -2584,6 +2568,7 @@ enum tm_result tm_resource_mgr_attach_audio_to_display_path(
 	union display_path_properties path_props;
 	uint32_t i;
 	struct tm_resource *tm_audio_resource = NULL;
+	const struct tm_resource_range *audios;
 
 	/* First we check if the display path already has an audio assigned,
 	 * and if so, we print a warning (should never happen) and
@@ -2608,15 +2593,14 @@ enum tm_result tm_resource_mgr_attach_audio_to_display_path(
 		return TM_RESULT_FAILURE;
 	}
 
+	audios = dal_tmrm_get_resource_range_by_type(tm_rm, OBJECT_TYPE_AUDIO);
+
 	/* Loop over all audio resources, and assign the first free audio
 	 * which supports the signal. */
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	for (i = audios->start; i < audios->end; i++) {
 
 		tm_audio_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(tm_audio_resource).type != OBJECT_TYPE_AUDIO)
-			continue;
-
 		/* Allow at most ONE display path to use an audio resource. */
 		if (is_resource_available(tm_audio_resource) == false) {
 			/* This audio is in-use, continue the search. */
@@ -3114,10 +3098,42 @@ void tm_resource_mgr_associate_link_services(
 	}
 }
 
+void dal_tmrm_set_resources_range_by_type(struct tm_resource_mgr *tm_rm)
+{
+	uint32_t index;
+	struct tm_resource *tm_resource;
+	uint32_t count = tm_resource_mgr_get_total_resources_num(tm_rm);
+	struct tm_resource_range *resources;
+
+	for (index = 0; index < count; index++) {
+		tm_resource = tm_resource_mgr_enum_resource(tm_rm, index);
+		resources = &tm_rm->resources_range[GRPH_ID(tm_resource).type];
+
+		if (resources->end == 0) {
+			resources->end = index;
+			resources->start = index;
+		}
+
+		resources->end++;
+	}
+}
+
+const struct tm_resource_range *dal_tmrm_get_resource_range_by_type(
+	struct tm_resource_mgr *tm_rm,
+	enum object_type type)
+{
+	if (type <= OBJECT_TYPE_UNKNOWN ||
+		type >= OBJECT_TYPE_COUNT)
+		return NULL;
+
+	return &tm_rm->resources_range[type];
+}
+
+
 /**
  * Debug output of all resources
  */
-void tm_resource_mgr_dump(struct tm_resource_mgr *tm_rm)
+void dal_tmrm_dump(struct tm_resource_mgr *tm_rm)
 {
 	uint32_t index;
 	struct tm_resource *tm_resource;
@@ -3149,7 +3165,10 @@ struct controller *dal_tmrm_get_free_controller(
 	uint32_t res_ind;
 	struct tm_resource *tm_resource_tmp = NULL;
 
-	res_ind = tmrm_find_controller_for_display_path(tm_rm, exclude_mask);
+	res_ind =
+		dal_tmrm_find_controller_for_display_path(
+			tm_rm,
+			exclude_mask);
 
 	if (RESOURCE_INVALID_INDEX == res_ind) {
 		TM_MPO("%s: failed to find controller!\n", __func__);
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h
index aafc303..8105a87 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h
@@ -74,6 +74,11 @@ struct tm_resource_mgr_init_data {
 
 #define RESOURCE_INVALID_INDEX ((uint32_t)(-1))
 
+struct tm_resource_range {
+	uint32_t start;
+	uint32_t end;
+};
+
 /****************************
   Public interface functions
 *****************************/
@@ -229,7 +234,7 @@ void tm_resource_mgr_associate_link_services(
 		struct tm_resource_mgr *tm_rm,
 		struct display_path *path);
 
-void tm_resource_mgr_dump(struct tm_resource_mgr *tm_rm);
+void dal_tmrm_dump(struct tm_resource_mgr *tm_rm);
 
 uint32_t tm_resource_mgr_get_display_path_index_for_controller(
 		struct tm_resource_mgr *tm_rm,
@@ -260,4 +265,10 @@ void dal_tmrm_release_non_root_controllers(
 		struct display_path *display_path,
 		enum tm_acquire_method method);
 
+void dal_tmrm_set_resources_range_by_type(struct tm_resource_mgr *tm_rm);
+
+const struct tm_resource_range *dal_tmrm_get_resource_range_by_type(
+	struct tm_resource_mgr *tm_rm,
+	enum object_type type);
+
 #endif /* __DAL_TM_RESOURCE_MGR_H__ */
diff --git a/drivers/gpu/drm/amd/dal/topology/topology.c b/drivers/gpu/drm/amd/dal/topology/topology.c
index 0ebce7a..aa920ed 100644
--- a/drivers/gpu/drm/amd/dal/topology/topology.c
+++ b/drivers/gpu/drm/amd/dal/topology/topology.c
@@ -1193,6 +1193,7 @@ static uint32_t get_number_of_audio_capable_display_paths(
 	struct tm_resource *tm_resource;
 	union audio_support audio_support;
 	struct dal_context *dal_context = tm->dal_context;
+	const struct tm_resource_range *connectors;
 
 	paths_per_mst_connector =
 		dal_adapter_service_get_num_of_path_per_dp_mst_connector(
@@ -1203,18 +1204,18 @@ static uint32_t get_number_of_audio_capable_display_paths(
 		paths_per_mst_connector = 1;
 	}
 
-	for (i = 0;
-		i < tm_resource_mgr_get_total_resources_num(tm->tm_rm);
-		i++) {
+	connectors =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CONNECTOR);
+
+	for (i = connectors->start; i < connectors->end; i++) {
 		struct graphics_object_id object_id;
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
 		object_id = GRPH_ID(tm_resource);
 
-		if (object_id.type != OBJECT_TYPE_CONNECTOR)
-			continue;
-
 		switch (object_id.id) {
 		case CONNECTOR_ID_HDMI_TYPE_A:
 			audio_capable_path_num++;
@@ -1304,18 +1305,19 @@ static void tm_reset_controllers(struct topology_mgr *tm)
 	struct tm_resource_controller_info *controller_info;
 	struct controller *controller;
 	struct dal_asic_runtime_flags asic_runtime_flags;
+	const struct tm_resource_range *controllers;
 
 	asic_runtime_flags = dal_adapter_service_get_asic_runtime_flags(
 		tm->adapter_srv);
 
-	for (i = 0;
-		i < tm_resource_mgr_get_total_resources_num(tm->tm_rm);
-		i++) {
+	controllers =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CONTROLLER);
 
-		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
+	for (i = controllers->start; i < controllers->end; i++) {
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-			continue;
+		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
 		controller_info = TO_CONTROLLER_INFO(tm_resource);
 
@@ -1556,24 +1558,22 @@ static void tm_power_up_encoder(struct topology_mgr *tm,
 static void tm_power_up_encoders(struct topology_mgr *tm)
 {
 	uint32_t i;
-	uint32_t resource_num;
 	struct tm_resource *tm_resource;
 	struct encoder_context context;
 	struct encoder *encoder;
 	struct dal_context *dal_context = tm->dal_context;
-
-	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
+	const struct tm_resource_range *encoders =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_ENCODER);
 
 	/* Power Up encoders.
 	 * Order is important - from first (internal) to last (external).
 	 * The order is enforced by resource list being sorted according to
 	 * priorities (in tm_rm_add_tm_resource()). */
-	for (i = 0; i < resource_num; i++) {
+	for (i = encoders->start; i < encoders->end; i++) {
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_ENCODER)
-			continue;
-
 		if (!tm_resource->flags.resource_active)
 			continue;
 
@@ -1816,20 +1816,22 @@ static void tm_power_down_encoders(struct topology_mgr *tm)
 	struct tm_resource *tm_resource;
 	bool turn_off_vcc = true;
 
+	const struct tm_resource_range *encoders =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_ENCODER);
+
 	/* Power Down encoders.
 	 * Order is important - from last (external) to first (internal).
 	 * The order is enforced by resource list being sorted according to
 	 * priorities (in tm_rm_add_tm_resource()). */
-	i = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
+	i = encoders->end;
 
 	do {
 		i--;
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_ENCODER)
-			continue;
-
 		if (!tm_resource->flags.resource_active)
 			continue;
 
@@ -1841,7 +1843,7 @@ static void tm_power_down_encoders(struct topology_mgr *tm)
 			TO_ENCODER(tm_resource),
 			turn_off_vcc);
 
-	} while(i != 0);
+	} while (i != encoders->start);
 }
 
 static void tm_power_down_controller(struct topology_mgr *tm,
@@ -1870,18 +1872,17 @@ static void tm_power_down_controller(struct topology_mgr *tm,
 static void tm_power_down_controllers(struct topology_mgr *tm)
 {
 	uint32_t i;
-	uint32_t resource_num;
 	struct tm_resource *tm_resource;
 
-	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
+	const struct tm_resource_range *controllers =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CONTROLLER);
 
-	for (i = 0; i < resource_num; i++) {
+	for (i = controllers->start; i < controllers->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-			continue;
-
 		tm_power_down_controller(tm, tm_resource);
 
 	} /* for () */
@@ -1890,29 +1891,26 @@ static void tm_power_down_controllers(struct topology_mgr *tm)
 static void tm_power_down_clock_sources(struct topology_mgr *tm)
 {
 	uint32_t i;
-	uint32_t resource_num;
 	struct tm_resource *tm_resource;
 	enum controller_id first_controller_id = CONTROLLER_ID_UNDEFINED;
+	const struct tm_resource_range *resources =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CONTROLLER);
 
-	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
-
-	for (i = 0; i < resource_num; i++) {
+	tm_resource =
+		tm_resource_mgr_enum_resource(tm->tm_rm, resources->start);
+	first_controller_id = GRPH_ID(tm_resource).id;
 
-		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
-
-		if (GRPH_ID(tm_resource).type == OBJECT_TYPE_CONTROLLER) {
-			first_controller_id = GRPH_ID(tm_resource).id;
-			break;
-		}
-	}
+	resources =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CLOCK_SOURCE);
 
-	for (i = 0; i < resource_num; i++) {
+	for (i = resources->start; i < resources->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CLOCK_SOURCE)
-			continue;
-
 		dal_clock_source_power_down_pll(
 			TO_CLOCK_SOURCE(tm_resource),
 			first_controller_id);
@@ -1975,20 +1973,18 @@ static bool tm_can_optimize_resume_sequence(
 static void power_up_audio_objects(struct topology_mgr *tm)
 {
 	uint32_t i;
-	uint32_t resource_num;
 	struct tm_resource *tm_resource;
 	struct audio *audio;
 	struct dal_context *dal_context = tm->dal_context;
+	const struct tm_resource_range *audios =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_AUDIO);
 
-	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
-
-	for (i = 0; i < resource_num; i++) {
+	for (i = audios->start; i < audios->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_AUDIO)
-			continue;
-
 		if (!tm_resource->flags.resource_active)
 			continue;
 
@@ -2072,17 +2068,19 @@ enum tm_result dal_tm_init_hw(struct topology_mgr *tm)
 enum tm_result dal_tm_power_down_hw(struct topology_mgr *tm)
 {
 	uint32_t i;
-	uint32_t resource_num;
 	struct tm_resource *tm_resource = NULL;
 	struct display_path *display_path = NULL;
 	struct dal_context *dal_context = tm->dal_context;
 	uint32_t display_paths_num = tm_get_display_path_count(tm);
 	struct bios_parser *bp = NULL;
+	const struct tm_resource_range *controllers =
+		dal_tmrm_get_resource_range_by_type(
+				tm->tm_rm,
+				OBJECT_TYPE_CONTROLLER);
 
 	enum dal_video_power_state power_state =
 		dal_tm_get_current_power_state(tm);
 
-	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
 	/*1. PowerDown GLSync Connectors*/
 	/*TODO: Power Down GLSyncConnector*/
 	TM_NOT_IMPLEMENTED();
@@ -2095,13 +2093,11 @@ enum tm_result dal_tm_power_down_hw(struct topology_mgr *tm)
 	if (power_state == DAL_VIDEO_POWER_HIBERNATE ||
 		power_state == DAL_VIDEO_POWER_ULPS) {
 
-		for (i = 0; i < resource_num; i++) {
+		for (i = controllers->start; i < controllers->end; i++) {
 
 			tm_resource =
 				tm_resource_mgr_enum_resource(
 					tm->tm_rm, i);
-			if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-				continue;
 
 			TO_CONTROLLER_INFO(tm_resource)->power_gating_state =
 				TM_POWER_GATE_STATE_ON;
@@ -2136,14 +2132,12 @@ enum tm_result dal_tm_power_down_hw(struct topology_mgr *tm)
 		/* 3.1.2 Power gating enable for all controllers
 		 * We could move this into GPU object
 		 */
-		for (i = 0; i < resource_num; i++) {
+		for (i = controllers->start; i < controllers->end; i++) {
 
 			struct controller *controller = NULL;
 			tm_resource =
 				tm_resource_mgr_enum_resource(
 					tm->tm_rm, i);
-			if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-				continue;
 
 			controller =
 				TO_CONTROLLER_INFO(tm_resource)->controller;
@@ -3412,6 +3406,10 @@ void dal_tm_enable_accelerated_mode(struct topology_mgr *tm)
 	struct controller *controller;
 	struct bios_parser *bp;
 	struct dal_context *dal_context = tm->dal_context;
+	const struct tm_resource_range *controllers =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CONTROLLER);
 
 	TM_IFACE_TRACE();
 
@@ -3423,13 +3421,10 @@ void dal_tm_enable_accelerated_mode(struct topology_mgr *tm)
 	/* 2. Disable VGA engine on all controllers. */
 	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
 
-	for (i = 0; i < resource_num; i++) {
+	for (i = controllers->start; i < controllers->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-			continue;
-
 		controller = TO_CONTROLLER_INFO(tm_resource)->controller;
 
 		/* we should call DisableVGA for each pipe */
@@ -3962,18 +3957,17 @@ void dal_tm_disable_all_dcp_pipes(struct topology_mgr *tm)
 	struct tm_resource *tm_resource;
 	struct controller *controller;
 	struct dal_context *dal_context = tm->dal_context;
+	const struct tm_resource_range *controllers =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CONTROLLER);
 
 	TM_IFACE_TRACE();
 
-	for (i = 0;
-		i < tm_resource_mgr_get_total_resources_num(tm->tm_rm);
-		i++) {
+	for (i = controllers->start; i < controllers->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CONTROLLER)
-			continue;
-
 		controller = TO_CONTROLLER_INFO(tm_resource)->controller;
 
 		dal_controller_disable_vga(controller);
@@ -4092,6 +4086,8 @@ static enum tm_result tm_init_during_construct(struct topology_mgr *tm)
 
 		tm_init_features(tm);
 
+		dal_tmrm_set_resources_range_by_type(tm->tm_rm);
+
 		rc = tm_update_internal_database(tm);
 		if (TM_RESULT_FAILURE == rc)
 			break;
@@ -4116,7 +4112,7 @@ static enum tm_result tm_init_during_construct(struct topology_mgr *tm)
 
 		dal_tm_dump(tm);
 
-		tm_resource_mgr_dump(tm->tm_rm);
+		dal_tmrm_dump(tm->tm_rm);
 
 	} while (0);
 
@@ -4277,6 +4273,10 @@ static void tm_init_features(struct topology_mgr *tm)
 	struct tm_resource *tm_resource;
 	struct clock_source *clock_source;
 	enum clock_sharing_level clock_sharing_level;
+	const struct tm_resource_range *clock_sources =
+		dal_tmrm_get_resource_range_by_type(
+			tm->tm_rm,
+			OBJECT_TYPE_CLOCK_SOURCE);
 
 	/* TODO: is there a 'force-connect' or 'always connected' Display
 	 * Path feature, as in DAL2? */
@@ -4294,11 +4294,9 @@ static void tm_init_features(struct topology_mgr *tm)
 
 	resource_num = tm_resource_mgr_get_total_resources_num(tm->tm_rm);
 
-	for (i = 0; i < resource_num; i++) {
+	for (i = clock_sources->start; i < clock_sources->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm->tm_rm, i);
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_CLOCK_SOURCE)
-			continue;
 
 		clock_source = TO_CLOCK_SOURCE_INFO(tm_resource)->clock_source;
 
@@ -4512,7 +4510,6 @@ static void tm_update_stream_engine_priorities_for_path(
 		struct display_path *display_path)
 {
 	uint32_t i;
-	struct tm_resource_mgr *tm_rm;
 	struct tm_resource *tm_resource;
 	struct tm_resource_engine_info *engine_info;
 	struct encoder *encoder;
@@ -4521,9 +4518,12 @@ static void tm_update_stream_engine_priorities_for_path(
 	bool is_preferred_engine;
 	enum tm_engine_priority priority;
 	uint32_t engine_id;
+	struct tm_resource_mgr *tm_rm = tm->tm_rm;
 	struct dal_context *dal_context = tm->dal_context;
-
-	tm_rm = tm->tm_rm;
+	const struct tm_resource_range *engines =
+		dal_tmrm_get_resource_range_by_type(
+			tm_rm,
+			OBJECT_TYPE_ENGINE);
 
 	/* We check engine only to first encoder - most close to GPU. */
 	encoder = dal_display_path_get_upstream_object(display_path,
@@ -4539,13 +4539,10 @@ static void tm_update_stream_engine_priorities_for_path(
 
 	preferred_engine_id = dal_encoder_get_preferred_stream_engine(encoder);
 
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	for (i = engines->start; i < engines->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_ENGINE)
-			continue;
-
 		engine_id = GRPH_ID(tm_resource).id;
 
 		if (!tm_utils_is_supported_engine(supported_stream_engines,
@@ -4597,16 +4594,17 @@ static void tm_update_stream_engine_priorities(struct topology_mgr *tm)
 	uint32_t i;
 	uint32_t paths_num;
 	struct dal_context *dal_context = tm->dal_context;
+	const struct tm_resource_range *engines =
+		dal_tmrm_get_resource_range_by_type(
+			tm_rm,
+			OBJECT_TYPE_ENGINE);
 
 	TM_ENG_ASN("%s() - Start\n", __func__);
 
-	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
+	for (i = engines->start; i < engines->end; i++) {
 
 		tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 
-		if (GRPH_ID(tm_resource).type != OBJECT_TYPE_ENGINE)
-			continue;
-
 		TO_ENGINE_INFO(tm_resource)->priority =
 			TM_ENGINE_PRIORITY_UNKNOWN;
 	}
-- 
1.9.1

