From b737ba2fcd57db6b3287672ff53a051e2ccb4e49 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Thu, 17 Oct 2013 06:21:40 -0600
Subject: [PATCH 07/27] radeon/video: seperate common video functions
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Christian KÃ¶nig <christian.koenig@amd.com>
---
 src/gallium/drivers/r600/r600_pipe.c        |    5 +-
 src/gallium/drivers/r600/r600_uvd.c         |    3 +-
 src/gallium/drivers/radeon/Makefile.sources |    1 +
 src/gallium/drivers/radeon/radeon_uvd.c     |  318 +++------------------------
 src/gallium/drivers/radeon/radeon_uvd.h     |   19 --
 src/gallium/drivers/radeon/radeon_video.c   |  293 ++++++++++++++++++++++++
 src/gallium/drivers/radeon/radeon_video.h   |   81 +++++++
 src/gallium/drivers/radeonsi/si_pipe.c      |    5 +-
 src/gallium/drivers/radeonsi/si_uvd.c       |    3 +-
 9 files changed, 412 insertions(+), 316 deletions(-)
 create mode 100644 src/gallium/drivers/radeon/radeon_video.c
 create mode 100644 src/gallium/drivers/radeon/radeon_video.h

diff --git a/src/gallium/drivers/r600/r600_pipe.c b/src/gallium/drivers/r600/r600_pipe.c
index e7d5862..9a4b470 100644
--- a/src/gallium/drivers/r600/r600_pipe.c
+++ b/src/gallium/drivers/r600/r600_pipe.c
@@ -38,6 +38,7 @@
 #include "util/u_math.h"
 #include "vl/vl_decoder.h"
 #include "vl/vl_video_buffer.h"
+#include "radeon/radeon_video.h"
 #include "radeon/radeon_uvd.h"
 #include "os/os_time.h"
 
@@ -859,8 +860,8 @@ struct pipe_screen *r600_screen_create(struct radeon_winsys *ws)
 	}
 	rscreen->b.b.get_driver_query_info = r600_get_driver_query_info;
 	if (rscreen->b.info.has_uvd) {
-		rscreen->b.b.get_video_param = ruvd_get_video_param;
-		rscreen->b.b.is_video_format_supported = ruvd_is_format_supported;
+		rscreen->b.b.get_video_param = rvid_get_video_param;
+		rscreen->b.b.is_video_format_supported = rvid_is_format_supported;
 	} else {
 		rscreen->b.b.get_video_param = r600_get_video_param;
 		rscreen->b.b.is_video_format_supported = vl_video_buffer_is_format_supported;
diff --git a/src/gallium/drivers/r600/r600_uvd.c b/src/gallium/drivers/r600/r600_uvd.c
index 300bccb..e0db492 100644
--- a/src/gallium/drivers/r600/r600_uvd.c
+++ b/src/gallium/drivers/r600/r600_uvd.c
@@ -45,6 +45,7 @@
 #include "vl/vl_mpeg12_decoder.h"
 
 #include "r600_pipe.h"
+#include "radeon/radeon_video.h"
 #include "radeon/radeon_uvd.h"
 #include "r600d.h"
 
@@ -111,7 +112,7 @@ struct pipe_video_buffer *r600_video_buffer_create(struct pipe_context *pipe,
 		surfaces[i] = &resources[i]->surface;
 	}
 
-	ruvd_join_surfaces(ctx->b.ws, templ.bind, pbs, surfaces);
+	rvid_join_surfaces(ctx->b.ws, templ.bind, pbs, surfaces);
 
 	for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
 		if (!resources[i])
diff --git a/src/gallium/drivers/radeon/Makefile.sources b/src/gallium/drivers/radeon/Makefile.sources
index 540ac05..4653d7a 100644
--- a/src/gallium/drivers/radeon/Makefile.sources
+++ b/src/gallium/drivers/radeon/Makefile.sources
@@ -3,6 +3,7 @@ C_SOURCES := \
 	r600_pipe_common.c \
 	r600_streamout.c \
         r600_texture.c \
+	radeon_video.c \
 	radeon_uvd.c
 
 LLVM_C_FILES := \
diff --git a/src/gallium/drivers/radeon/radeon_uvd.c b/src/gallium/drivers/radeon/radeon_uvd.c
index 95757e3..e59a08d 100644
--- a/src/gallium/drivers/radeon/radeon_uvd.c
+++ b/src/gallium/drivers/radeon/radeon_uvd.c
@@ -47,24 +47,15 @@
 
 #include "../../winsys/radeon/drm/radeon_winsys.h"
 #include "r600_pipe_common.h"
+#include "radeon_video.h"
 #include "radeon_uvd.h"
 
-#define RUVD_ERR(fmt, args...) \
-	fprintf(stderr, "EE %s:%d %s UVD - "fmt, __FILE__, __LINE__, __func__, ##args)
-
 #define NUM_BUFFERS 4
 
 #define NUM_MPEG2_REFS 6
 #define NUM_H264_REFS 17
 #define NUM_VC1_REFS 5
 
-/* UVD buffer representation */
-struct ruvd_buffer
-{
-	struct pb_buffer*		buf;
-	struct radeon_winsys_cs_handle*	cs_handle;
-};
-
 /* UVD decoder representation */
 struct ruvd_decoder {
 	struct pipe_video_codec		base;
@@ -79,31 +70,16 @@ struct ruvd_decoder {
 
 	unsigned			cur_buffer;
 
-	struct ruvd_buffer		msg_fb_buffers[NUM_BUFFERS];
+	struct rvid_buffer		msg_fb_buffers[NUM_BUFFERS];
 	struct ruvd_msg			*msg;
 
-	struct ruvd_buffer		bs_buffers[NUM_BUFFERS];
+	struct rvid_buffer		bs_buffers[NUM_BUFFERS];
 	void*				bs_ptr;
 	unsigned			bs_size;
 
-	struct ruvd_buffer		dpb;
+	struct rvid_buffer		dpb;
 };
 
-/* generate an UVD stream handle */
-static unsigned alloc_stream_handle()
-{
-	static unsigned counter = 0;
-	unsigned stream_handle = 0;
-	unsigned pid = getpid();
-	int i;
-
-	for (i = 0; i < 32; ++i)
-		stream_handle |= ((pid >> i) & 1) << (31 - i);
-
-	stream_handle ^= ++counter;
-	return stream_handle;
-}
-
 /* flush IB to the hardware */
 static void flush(struct ruvd_decoder *dec)
 {
@@ -134,7 +110,7 @@ static void send_cmd(struct ruvd_decoder *dec, unsigned cmd,
 /* map the next available message buffer */
 static void map_msg_buf(struct ruvd_decoder *dec)
 {
-	struct ruvd_buffer* buf;
+	struct rvid_buffer* buf;
 
 	/* grap the current message buffer */
 	buf = &dec->msg_fb_buffers[dec->cur_buffer];
@@ -146,7 +122,7 @@ static void map_msg_buf(struct ruvd_decoder *dec)
 /* unmap and send a message command to the VCPU */
 static void send_msg_buf(struct ruvd_decoder *dec)
 {
-	struct ruvd_buffer* buf;
+	struct rvid_buffer* buf;
 
 	/* ignore the request if message buffer isn't mapped */
 	if (!dec->msg)
@@ -163,82 +139,6 @@ static void send_msg_buf(struct ruvd_decoder *dec)
 		 RADEON_USAGE_READ, RADEON_DOMAIN_GTT);
 }
 
-/* create a buffer in the winsys */
-static bool create_buffer(struct ruvd_decoder *dec,
-			  struct ruvd_buffer *buffer,
-			  unsigned size)
-{
-	buffer->buf = dec->ws->buffer_create(dec->ws, size, 4096, false,
-					     RADEON_DOMAIN_GTT | RADEON_DOMAIN_VRAM);
-	if (!buffer->buf)
-		return false;
-
-	buffer->cs_handle = dec->ws->buffer_get_cs_handle(buffer->buf);
-	if (!buffer->cs_handle)
-		return false;
-
-	return true;
-}
-
-/* destroy a buffer */
-static void destroy_buffer(struct ruvd_buffer *buffer)
-{
-	pb_reference(&buffer->buf, NULL);
-	buffer->cs_handle = NULL;
-}
-
-/* reallocate a buffer, preserving its content */
-static bool resize_buffer(struct ruvd_decoder *dec,
-			  struct ruvd_buffer *new_buf,
-			  unsigned new_size)
-{
-	unsigned bytes = MIN2(new_buf->buf->size, new_size);
-	struct ruvd_buffer old_buf = *new_buf;
-	void *src = NULL, *dst = NULL;
-
-	if (!create_buffer(dec, new_buf, new_size))
-		goto error;
-
-	src = dec->ws->buffer_map(old_buf.cs_handle, dec->cs, PIPE_TRANSFER_READ);
-	if (!src)
-		goto error;
-
-	dst = dec->ws->buffer_map(new_buf->cs_handle, dec->cs, PIPE_TRANSFER_WRITE);
-	if (!dst)
-		goto error;
-
-	memcpy(dst, src, bytes);
-	if (new_size > bytes) {
-		new_size -= bytes;
-		dst += bytes;
-		memset(dst, 0, new_size);
-	}
-	dec->ws->buffer_unmap(new_buf->cs_handle);
-	dec->ws->buffer_unmap(old_buf.cs_handle);
-	destroy_buffer(&old_buf);
-	return true;
-
-error:
-	if (src) dec->ws->buffer_unmap(old_buf.cs_handle);
-	destroy_buffer(new_buf);
-	*new_buf = old_buf;
-	return false;
-}
-
-/* clear the buffer with zeros */
-static void clear_buffer(struct ruvd_decoder *dec,
-			 struct ruvd_buffer* buffer)
-{
-	//TODO: let the GPU do the job
-	void *ptr = dec->ws->buffer_map(buffer->cs_handle, dec->cs,
-					PIPE_TRANSFER_WRITE);
-	if (!ptr)
-		return;
-
-	memset(ptr, 0, buffer->buf->size);
-	dec->ws->buffer_unmap(buffer->cs_handle);
-}
-
 /* cycle to the next set of buffers */
 static void next_buffer(struct ruvd_decoder *dec)
 {
@@ -656,11 +556,11 @@ static void ruvd_destroy(struct pipe_video_codec *decoder)
 	dec->ws->cs_destroy(dec->cs);
 
 	for (i = 0; i < NUM_BUFFERS; ++i) {
-		destroy_buffer(&dec->msg_fb_buffers[i]);
-		destroy_buffer(&dec->bs_buffers[i]);
+		rvid_destroy_buffer(&dec->msg_fb_buffers[i]);
+		rvid_destroy_buffer(&dec->bs_buffers[i]);
 	}
 
-	destroy_buffer(&dec->dpb);
+	rvid_destroy_buffer(&dec->dpb);
 
 	FREE(dec);
 }
@@ -725,13 +625,13 @@ static void ruvd_decode_bitstream(struct pipe_video_codec *decoder,
 		return;
 
 	for (i = 0; i < num_buffers; ++i) {
-		struct ruvd_buffer *buf = &dec->bs_buffers[dec->cur_buffer];
+		struct rvid_buffer *buf = &dec->bs_buffers[dec->cur_buffer];
 		unsigned new_size = dec->bs_size + sizes[i];
 
 		if (new_size > buf->buf->size) {
 			dec->ws->buffer_unmap(buf->cs_handle);
-			if (!resize_buffer(dec, buf, new_size)) {
-				RUVD_ERR("Can't resize bitstream buffer!");
+			if (!rvid_resize_buffer(dec->ws, dec->cs, buf, new_size)) {
+				RVID_ERR("Can't resize bitstream buffer!");
 				return;
 			}
 
@@ -758,7 +658,7 @@ static void ruvd_end_frame(struct pipe_video_codec *decoder,
 {
 	struct ruvd_decoder *dec = (struct ruvd_decoder*)decoder;
 	struct radeon_winsys_cs_handle *dt;
-	struct ruvd_buffer *msg_fb_buf, *bs_buf;
+	struct rvid_buffer *msg_fb_buf, *bs_buf;
 	unsigned bs_size;
 
 	assert(decoder);
@@ -888,37 +788,37 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 	dec->base.flush = ruvd_flush;
 
 	dec->set_dtb = set_dtb;
-	dec->stream_handle = alloc_stream_handle();
+	dec->stream_handle = rvid_alloc_stream_handle();
 	dec->ws = ws;
 	dec->cs = ws->cs_create(ws, RING_UVD, NULL);
 	if (!dec->cs) {
-		RUVD_ERR("Can't get command submission context.\n");
+		RVID_ERR("Can't get command submission context.\n");
 		goto error;
 	}
 
 	bs_buf_size = width * height * 512 / (16 * 16);
 	for (i = 0; i < NUM_BUFFERS; ++i) {
 		unsigned msg_fb_size = align(sizeof(struct ruvd_msg), 0x1000) + 0x1000;
-		if (!create_buffer(dec, &dec->msg_fb_buffers[i], msg_fb_size)) {
-			RUVD_ERR("Can't allocated message buffers.\n");
+		if (!rvid_create_buffer(dec->ws, &dec->msg_fb_buffers[i], msg_fb_size)) {
+			RVID_ERR("Can't allocated message buffers.\n");
 			goto error;
 		}
 
-		if (!create_buffer(dec, &dec->bs_buffers[i], bs_buf_size)) {
-			RUVD_ERR("Can't allocated bitstream buffers.\n");
+		if (!rvid_create_buffer(dec->ws, &dec->bs_buffers[i], bs_buf_size)) {
+			RVID_ERR("Can't allocated bitstream buffers.\n");
 			goto error;
 		}
 
-		clear_buffer(dec, &dec->msg_fb_buffers[i]);
-		clear_buffer(dec, &dec->bs_buffers[i]);
+		rvid_clear_buffer(dec->ws, dec->cs, &dec->msg_fb_buffers[i]);
+		rvid_clear_buffer(dec->ws, dec->cs, &dec->bs_buffers[i]);
 	}
 
-	if (!create_buffer(dec, &dec->dpb, dpb_size)) {
-		RUVD_ERR("Can't allocated dpb.\n");
+	if (!rvid_create_buffer(dec->ws, &dec->dpb, dpb_size)) {
+		RVID_ERR("Can't allocated dpb.\n");
 		goto error;
 	}
 
-	clear_buffer(dec, &dec->dpb);
+	rvid_clear_buffer(dec->ws, dec->cs, &dec->dpb);
 
 	map_msg_buf(dec);
 	dec->msg->size = sizeof(*dec->msg);
@@ -938,90 +838,17 @@ error:
 	if (dec->cs) dec->ws->cs_destroy(dec->cs);
 
 	for (i = 0; i < NUM_BUFFERS; ++i) {
-		destroy_buffer(&dec->msg_fb_buffers[i]);
-		destroy_buffer(&dec->bs_buffers[i]);
+		rvid_destroy_buffer(&dec->msg_fb_buffers[i]);
+		rvid_destroy_buffer(&dec->bs_buffers[i]);
 	}
 
-	destroy_buffer(&dec->dpb);
+	rvid_destroy_buffer(&dec->dpb);
 
 	FREE(dec);
 
 	return NULL;
 }
 
-/**
- * join surfaces into the same buffer with identical tiling params
- * sumup their sizes and replace the backend buffers with a single bo
- */
-void ruvd_join_surfaces(struct radeon_winsys* ws, unsigned bind,
-			struct pb_buffer** buffers[VL_NUM_COMPONENTS],
-			struct radeon_surface *surfaces[VL_NUM_COMPONENTS])
-{
-	unsigned best_tiling, best_wh, off;
-	unsigned size, alignment;
-	struct pb_buffer *pb;
-	unsigned i, j;
-
-	for (i = 0, best_tiling = 0, best_wh = ~0; i < VL_NUM_COMPONENTS; ++i) {
-		unsigned wh;
-
-		if (!surfaces[i])
-			continue;
-
-		/* choose the smallest bank w/h for now */
-		wh = surfaces[i]->bankw * surfaces[i]->bankh;
-		if (wh < best_wh) {
-			best_wh = wh;
-			best_tiling = i;
-		}
-	}
-
-	for (i = 0, off = 0; i < VL_NUM_COMPONENTS; ++i) {
-		if (!surfaces[i])
-			continue;
-
-		/* copy the tiling parameters */
-		surfaces[i]->bankw = surfaces[best_tiling]->bankw;
-		surfaces[i]->bankh = surfaces[best_tiling]->bankh;
-		surfaces[i]->mtilea = surfaces[best_tiling]->mtilea;
-		surfaces[i]->tile_split = surfaces[best_tiling]->tile_split;
-
-		/* adjust the texture layer offsets */
-		off = align(off, surfaces[i]->bo_alignment);
-		for (j = 0; j < Elements(surfaces[i]->level); ++j)
-			surfaces[i]->level[j].offset += off;
-		off += surfaces[i]->bo_size;
-	}
-
-	for (i = 0, size = 0, alignment = 0; i < VL_NUM_COMPONENTS; ++i) {
-		if (!buffers[i] || !*buffers[i])
-			continue;
-
-		size = align(size, (*buffers[i])->alignment);
-		size += (*buffers[i])->size;
-		alignment = MAX2(alignment, (*buffers[i])->alignment * 1);
-	}
-
-	if (!size)
-		return;
-
-	/* TODO: 2D tiling workaround */
-	alignment *= 2;
-
-	pb = ws->buffer_create(ws, size, alignment, bind, RADEON_DOMAIN_VRAM);
-	if (!pb)
-		return;
-
-	for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
-		if (!buffers[i] || !*buffers[i])
-			continue;
-
-		pb_reference(buffers[i], pb);
-	}
-
-	pb_reference(&pb, NULL);
-}
-
 /* calculate top/bottom offset */
 static unsigned texture_offset(struct radeon_surface *surface, unsigned layer)
 {
@@ -1098,94 +925,3 @@ void ruvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surface *luma,
 	msg->body.decode.dt_surf_tile_config |= RUVD_BANK_HEIGHT(bank_wh(luma->bankh));
 	msg->body.decode.dt_surf_tile_config |= RUVD_MACRO_TILE_ASPECT_RATIO(macro_tile_aspect(luma->mtilea));
 }
-
-int ruvd_get_video_param(struct pipe_screen *screen,
-			 enum pipe_video_profile profile,
-			 enum pipe_video_entrypoint entrypoint,
-			 enum pipe_video_cap param)
-{
-	struct r600_common_screen *rscreen = (struct r600_common_screen *)screen;
-
-	/* UVD 2.x limits */
-	if (rscreen->family < CHIP_PALM) {
-		enum pipe_video_format codec = u_reduce_video_profile(profile);
-		switch (param) {
-		case PIPE_VIDEO_CAP_SUPPORTED:
-			/* no support for MPEG4 */
-			return codec != PIPE_VIDEO_FORMAT_MPEG4;
-		case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
-		case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
-			/* and MPEG2 only with shaders */
-			return codec != PIPE_VIDEO_FORMAT_MPEG12;
-		default:
-			break;
-		}
-	}
-
-	switch (param) {
-	case PIPE_VIDEO_CAP_SUPPORTED:
-		switch (u_reduce_video_profile(profile)) {
-		case PIPE_VIDEO_FORMAT_MPEG12:
-		case PIPE_VIDEO_FORMAT_MPEG4:
-		case PIPE_VIDEO_FORMAT_MPEG4_AVC:
-			return true;
-		case PIPE_VIDEO_FORMAT_VC1:
-			/* FIXME: VC-1 simple/main profile is broken */
-			return profile == PIPE_VIDEO_PROFILE_VC1_ADVANCED;
-		default:
-			return false;
-		}
-	case PIPE_VIDEO_CAP_NPOT_TEXTURES:
-		return 1;
-	case PIPE_VIDEO_CAP_MAX_WIDTH:
-		return 2048;
-	case PIPE_VIDEO_CAP_MAX_HEIGHT:
-		return 1152;
-	case PIPE_VIDEO_CAP_PREFERED_FORMAT:
-		return PIPE_FORMAT_NV12;
-	case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
-		return true;
-	case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
-		return true;
-	case PIPE_VIDEO_CAP_SUPPORTS_PROGRESSIVE:
-		return true;
-	case PIPE_VIDEO_CAP_MAX_LEVEL:
-		switch (profile) {
-		case PIPE_VIDEO_PROFILE_MPEG1:
-			return 0;
-		case PIPE_VIDEO_PROFILE_MPEG2_SIMPLE:
-		case PIPE_VIDEO_PROFILE_MPEG2_MAIN:
-			return 3;
-		case PIPE_VIDEO_PROFILE_MPEG4_SIMPLE:
-			return 3;
-		case PIPE_VIDEO_PROFILE_MPEG4_ADVANCED_SIMPLE:
-			return 5;
-		case PIPE_VIDEO_PROFILE_VC1_SIMPLE:
-			return 1;
-		case PIPE_VIDEO_PROFILE_VC1_MAIN:
-			return 2;
-		case PIPE_VIDEO_PROFILE_VC1_ADVANCED:
-			return 4;
-		case PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE:
-		case PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN:
-		case PIPE_VIDEO_PROFILE_MPEG4_AVC_HIGH:
-			return 41;
-		default:
-			return 0;
-		}
-	default:
-		return 0;
-	}
-}
-
-boolean ruvd_is_format_supported(struct pipe_screen *screen,
-				 enum pipe_format format,
-				 enum pipe_video_profile profile,
-				 enum pipe_video_entrypoint entrypoint)
-{
-	/* we can only handle this one with UVD */
-	if (profile != PIPE_VIDEO_PROFILE_UNKNOWN)
-		return format == PIPE_FORMAT_NV12;
-
-	return vl_video_buffer_is_format_supported(screen, format, profile, entrypoint);
-}
diff --git a/src/gallium/drivers/radeon/radeon_uvd.h b/src/gallium/drivers/radeon/radeon_uvd.h
index b0135ba..b4b8790 100644
--- a/src/gallium/drivers/radeon/radeon_uvd.h
+++ b/src/gallium/drivers/radeon/radeon_uvd.h
@@ -349,26 +349,7 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 					     const struct pipe_video_codec *templat,
 					     ruvd_set_dtb set_dtb);
 
-/* join surfaces into the same buffer with identical tiling params
-   sumup their sizes and replace the backend buffers with a single bo */
-void ruvd_join_surfaces(struct radeon_winsys* ws, unsigned bind,
-			struct pb_buffer** buffers[VL_NUM_COMPONENTS],
-			struct radeon_surface *surfaces[VL_NUM_COMPONENTS]);
-
 /* fill decoding target field from the luma and chroma surfaces */
 void ruvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surface *luma,
 			  struct radeon_surface *chroma);
-
-/* returns supported codecs and other parameters */
-int ruvd_get_video_param(struct pipe_screen *screen,
-			 enum pipe_video_profile profile,
-			 enum pipe_video_entrypoint entrypoint,
-			 enum pipe_video_cap param);
-
-/* the hardware only supports NV12 */
-boolean ruvd_is_format_supported(struct pipe_screen *screen,
-				 enum pipe_format format,
-				 enum pipe_video_profile profile,
-				 enum pipe_video_entrypoint entrypoint);
-
 #endif
diff --git a/src/gallium/drivers/radeon/radeon_video.c b/src/gallium/drivers/radeon/radeon_video.c
new file mode 100644
index 0000000..3471202
--- /dev/null
+++ b/src/gallium/drivers/radeon/radeon_video.c
@@ -0,0 +1,293 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+/*
+ * Authors:
+ *      Christian KÃ¶nig <christian.koenig@amd.com>
+ *
+ */
+
+#include <unistd.h>
+
+#include "util/u_memory.h"
+#include "util/u_video.h"
+
+#include "vl/vl_defines.h"
+#include "vl/vl_video_buffer.h"
+
+#include "../../winsys/radeon/drm/radeon_winsys.h"
+#include "r600_pipe_common.h"
+#include "radeon_video.h"
+
+/* generate an stream handle */
+unsigned rvid_alloc_stream_handle()
+{
+	static unsigned counter = 0;
+	unsigned stream_handle = 0;
+	unsigned pid = getpid();
+	int i;
+
+	for (i = 0; i < 32; ++i)
+		stream_handle |= ((pid >> i) & 1) << (31 - i);
+
+	stream_handle ^= ++counter;
+	return stream_handle;
+}
+
+/* create a buffer in the winsys */
+bool rvid_create_buffer(struct radeon_winsys *ws, struct rvid_buffer *buffer, unsigned size)
+{
+	buffer->buf = ws->buffer_create(ws, size, 4096, false, RADEON_DOMAIN_GTT | RADEON_DOMAIN_VRAM);
+	if (!buffer->buf)
+		return false;
+
+	buffer->cs_handle = ws->buffer_get_cs_handle(buffer->buf);
+	if (!buffer->cs_handle)
+		return false;
+
+	return true;
+}
+
+/* destroy a buffer */
+void rvid_destroy_buffer(struct rvid_buffer *buffer)
+{
+	pb_reference(&buffer->buf, NULL);
+	buffer->cs_handle = NULL;
+}
+
+/* reallocate a buffer, preserving its content */
+bool rvid_resize_buffer(struct radeon_winsys *ws, struct radeon_winsys_cs *cs,
+			struct rvid_buffer *new_buf, unsigned new_size)
+{
+	unsigned bytes = MIN2(new_buf->buf->size, new_size);
+	struct rvid_buffer old_buf = *new_buf;
+	void *src = NULL, *dst = NULL;
+
+	if (!rvid_create_buffer(ws, new_buf, new_size))
+		goto error;
+
+	src = ws->buffer_map(old_buf.cs_handle, cs, PIPE_TRANSFER_READ);
+	if (!src)
+		goto error;
+
+	dst = ws->buffer_map(new_buf->cs_handle, cs, PIPE_TRANSFER_WRITE);
+	if (!dst)
+		goto error;
+
+	memcpy(dst, src, bytes);
+	if (new_size > bytes) {
+		new_size -= bytes;
+		dst += bytes;
+		memset(dst, 0, new_size);
+	}
+	ws->buffer_unmap(new_buf->cs_handle);
+	ws->buffer_unmap(old_buf.cs_handle);
+	rvid_destroy_buffer(&old_buf);
+	return true;
+
+error:
+	if (src)
+		ws->buffer_unmap(old_buf.cs_handle);
+	rvid_destroy_buffer(new_buf);
+	*new_buf = old_buf;
+	return false;
+}
+
+/* clear the buffer with zeros */
+void rvid_clear_buffer(struct radeon_winsys *ws, struct radeon_winsys_cs *cs, struct rvid_buffer* buffer)
+{
+        void *ptr = ws->buffer_map(buffer->cs_handle, cs, PIPE_TRANSFER_WRITE);
+        if (!ptr)
+                return;
+
+        memset(ptr, 0, buffer->buf->size);
+        ws->buffer_unmap(buffer->cs_handle);
+}
+
+/**
+ * join surfaces into the same buffer with identical tiling params
+ * sumup their sizes and replace the backend buffers with a single bo
+ */
+void rvid_join_surfaces(struct radeon_winsys* ws, unsigned bind,
+			struct pb_buffer** buffers[VL_NUM_COMPONENTS],
+			struct radeon_surface *surfaces[VL_NUM_COMPONENTS])
+{
+	unsigned best_tiling, best_wh, off;
+	unsigned size, alignment;
+	struct pb_buffer *pb;
+	unsigned i, j;
+
+	for (i = 0, best_tiling = 0, best_wh = ~0; i < VL_NUM_COMPONENTS; ++i) {
+		unsigned wh;
+
+		if (!surfaces[i])
+			continue;
+
+		/* choose the smallest bank w/h for now */
+		wh = surfaces[i]->bankw * surfaces[i]->bankh;
+		if (wh < best_wh) {
+			best_wh = wh;
+			best_tiling = i;
+		}
+	}
+
+	for (i = 0, off = 0; i < VL_NUM_COMPONENTS; ++i) {
+		if (!surfaces[i])
+			continue;
+
+		/* copy the tiling parameters */
+		surfaces[i]->bankw = surfaces[best_tiling]->bankw;
+		surfaces[i]->bankh = surfaces[best_tiling]->bankh;
+		surfaces[i]->mtilea = surfaces[best_tiling]->mtilea;
+		surfaces[i]->tile_split = surfaces[best_tiling]->tile_split;
+
+		/* adjust the texture layer offsets */
+		off = align(off, surfaces[i]->bo_alignment);
+		for (j = 0; j < Elements(surfaces[i]->level); ++j)
+			surfaces[i]->level[j].offset += off;
+		off += surfaces[i]->bo_size;
+	}
+
+	for (i = 0, size = 0, alignment = 0; i < VL_NUM_COMPONENTS; ++i) {
+		if (!buffers[i] || !*buffers[i])
+			continue;
+
+		size = align(size, (*buffers[i])->alignment);
+		size += (*buffers[i])->size;
+		alignment = MAX2(alignment, (*buffers[i])->alignment * 1);
+	}
+
+	if (!size)
+		return;
+
+	/* TODO: 2D tiling workaround */
+	alignment *= 2;
+
+	pb = ws->buffer_create(ws, size, alignment, bind, RADEON_DOMAIN_VRAM);
+	if (!pb)
+		return;
+
+	for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
+		if (!buffers[i] || !*buffers[i])
+			continue;
+
+		pb_reference(buffers[i], pb);
+	}
+
+	pb_reference(&pb, NULL);
+}
+
+int rvid_get_video_param(struct pipe_screen *screen,
+			 enum pipe_video_profile profile,
+			 enum pipe_video_entrypoint entrypoint,
+			 enum pipe_video_cap param)
+{
+	struct r600_common_screen *rscreen = (struct r600_common_screen *)screen;
+
+	/* UVD 2.x limits */
+	if (rscreen->family < CHIP_PALM) {
+		enum pipe_video_format codec = u_reduce_video_profile(profile);
+		switch (param) {
+		case PIPE_VIDEO_CAP_SUPPORTED:
+			/* no support for MPEG4 */
+			return codec != PIPE_VIDEO_FORMAT_MPEG4;
+		case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
+		case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
+			/* and MPEG2 only with shaders */
+			return codec != PIPE_VIDEO_FORMAT_MPEG12;
+		default:
+			break;
+		}
+	}
+
+	switch (param) {
+	case PIPE_VIDEO_CAP_SUPPORTED:
+		switch (u_reduce_video_profile(profile)) {
+		case PIPE_VIDEO_FORMAT_MPEG12:
+		case PIPE_VIDEO_FORMAT_MPEG4:
+		case PIPE_VIDEO_FORMAT_MPEG4_AVC:
+			return true;
+		case PIPE_VIDEO_FORMAT_VC1:
+			/* FIXME: VC-1 simple/main profile is broken */
+			return profile == PIPE_VIDEO_PROFILE_VC1_ADVANCED;
+		default:
+			return false;
+		}
+	case PIPE_VIDEO_CAP_NPOT_TEXTURES:
+		return 1;
+	case PIPE_VIDEO_CAP_MAX_WIDTH:
+		return 2048;
+	case PIPE_VIDEO_CAP_MAX_HEIGHT:
+		return 1152;
+	case PIPE_VIDEO_CAP_PREFERED_FORMAT:
+		return PIPE_FORMAT_NV12;
+	case PIPE_VIDEO_CAP_PREFERS_INTERLACED:
+		return true;
+	case PIPE_VIDEO_CAP_SUPPORTS_INTERLACED:
+		return true;
+	case PIPE_VIDEO_CAP_SUPPORTS_PROGRESSIVE:
+		return true;
+	case PIPE_VIDEO_CAP_MAX_LEVEL:
+		switch (profile) {
+		case PIPE_VIDEO_PROFILE_MPEG1:
+			return 0;
+		case PIPE_VIDEO_PROFILE_MPEG2_SIMPLE:
+		case PIPE_VIDEO_PROFILE_MPEG2_MAIN:
+			return 3;
+		case PIPE_VIDEO_PROFILE_MPEG4_SIMPLE:
+			return 3;
+		case PIPE_VIDEO_PROFILE_MPEG4_ADVANCED_SIMPLE:
+			return 5;
+		case PIPE_VIDEO_PROFILE_VC1_SIMPLE:
+			return 1;
+		case PIPE_VIDEO_PROFILE_VC1_MAIN:
+			return 2;
+		case PIPE_VIDEO_PROFILE_VC1_ADVANCED:
+			return 4;
+		case PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE:
+		case PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN:
+		case PIPE_VIDEO_PROFILE_MPEG4_AVC_HIGH:
+			return 41;
+		default:
+			return 0;
+		}
+	default:
+		return 0;
+	}
+}
+
+boolean rvid_is_format_supported(struct pipe_screen *screen,
+				 enum pipe_format format,
+				 enum pipe_video_profile profile,
+				 enum pipe_video_entrypoint entrypoint)
+{
+	/* we can only handle this one with UVD */
+	if (profile != PIPE_VIDEO_PROFILE_UNKNOWN)
+		return format == PIPE_FORMAT_NV12;
+
+	return vl_video_buffer_is_format_supported(screen, format, profile, entrypoint);
+}
diff --git a/src/gallium/drivers/radeon/radeon_video.h b/src/gallium/drivers/radeon/radeon_video.h
new file mode 100644
index 0000000..85bdb78
--- /dev/null
+++ b/src/gallium/drivers/radeon/radeon_video.h
@@ -0,0 +1,81 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+/*
+ * Authors:
+ *      Christian KÃ¶nig <christian.koenig@amd.com>
+ *
+ */
+
+#ifndef RADEON_VIDEO_H
+#define RADEON_VIDEO_H
+
+#define RVID_ERR(fmt, args...) \
+	fprintf(stderr, "EE %s:%d %s UVD - "fmt, __FILE__, __LINE__, __func__, ##args)
+
+/* video buffer representation */
+struct rvid_buffer
+{
+	struct pb_buffer*		buf;
+	struct radeon_winsys_cs_handle*	cs_handle;
+};
+
+/* generate an stream handle */
+unsigned rvid_alloc_stream_handle(void);
+
+/* create a buffer in the winsys */
+bool rvid_create_buffer(struct radeon_winsys *ws, struct rvid_buffer *buffer, unsigned size);
+
+/* destroy a buffer */
+void rvid_destroy_buffer(struct rvid_buffer *buffer);
+
+/* reallocate a buffer, preserving its content */
+bool rvid_resize_buffer(struct radeon_winsys *ws, struct radeon_winsys_cs *cs,
+			struct rvid_buffer *new_buf, unsigned new_size);
+
+/* clear the buffer with zeros */
+void rvid_clear_buffer(struct radeon_winsys *ws, struct radeon_winsys_cs *cs, struct rvid_buffer* buffer);
+
+/* join surfaces into the same buffer with identical tiling params
+   sumup their sizes and replace the backend buffers with a single bo */
+void rvid_join_surfaces(struct radeon_winsys* ws, unsigned bind,
+                        struct pb_buffer** buffers[VL_NUM_COMPONENTS],
+                        struct radeon_surface *surfaces[VL_NUM_COMPONENTS]);
+
+/* returns supported codecs and other parameters */
+int rvid_get_video_param(struct pipe_screen *screen,
+                         enum pipe_video_profile profile,
+                         enum pipe_video_entrypoint entrypoint,
+                         enum pipe_video_cap param);
+
+/* the hardware only supports NV12 */
+boolean rvid_is_format_supported(struct pipe_screen *screen,
+                                 enum pipe_format format,
+                                 enum pipe_video_profile profile,
+                                 enum pipe_video_entrypoint entrypoint);
+
+#endif // RADEON_VIDEO_H
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 6b74b18..586f441 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -43,6 +43,7 @@
 #include "os/os_time.h"
 #include "pipebuffer/pb_buffer.h"
 #include "si_pipe.h"
+#include "radeon/radeon_video.h"
 #include "radeon/radeon_uvd.h"
 #include "si.h"
 #include "sid.h"
@@ -637,8 +638,8 @@ struct pipe_screen *radeonsi_screen_create(struct radeon_winsys *ws)
 	sscreen->b.b.get_timestamp = si_get_timestamp;
 	sscreen->b.b.is_format_supported = si_is_format_supported;
 	if (sscreen->b.info.has_uvd) {
-		sscreen->b.b.get_video_param = ruvd_get_video_param;
-		sscreen->b.b.is_video_format_supported = ruvd_is_format_supported;
+		sscreen->b.b.get_video_param = rvid_get_video_param;
+		sscreen->b.b.is_video_format_supported = rvid_is_format_supported;
 	} else {
 		sscreen->b.b.get_video_param = si_get_video_param;
 		sscreen->b.b.is_video_format_supported = vl_video_buffer_is_format_supported;
diff --git a/src/gallium/drivers/radeonsi/si_uvd.c b/src/gallium/drivers/radeonsi/si_uvd.c
index 5a7cbd3..2f8e933 100644
--- a/src/gallium/drivers/radeonsi/si_uvd.c
+++ b/src/gallium/drivers/radeonsi/si_uvd.c
@@ -45,6 +45,7 @@
 #include "vl/vl_mpeg12_decoder.h"
 
 #include "si_pipe.h"
+#include "radeon/radeon_video.h"
 #include "radeon/radeon_uvd.h"
 #include "sid.h"
 
@@ -109,7 +110,7 @@ struct pipe_video_buffer *si_video_buffer_create(struct pipe_context *pipe,
 		pbs[i] = &resources[i]->resource.buf;
 	}
 
-	ruvd_join_surfaces(ctx->b.ws, templ.bind, pbs, surfaces);
+	rvid_join_surfaces(ctx->b.ws, templ.bind, pbs, surfaces);
 
 	for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
 		if (!resources[i])
-- 
1.7.9.5

