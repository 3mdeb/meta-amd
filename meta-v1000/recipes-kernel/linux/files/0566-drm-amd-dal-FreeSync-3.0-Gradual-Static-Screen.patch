From 8895685875081c4bf4bc54e52df4f817844a65ef Mon Sep 17 00:00:00 2001
From: Prokhar Bhowal <Prokhar.Bhowal@amd.com>
Date: Wed, 8 Jun 2016 17:00:13 -0400
Subject: [PATCH 0566/1722] drm/amd/dal: FreeSync 3.0 Gradual Static Screen

- Added freesync static ramp core variables for use in
ramp calculations
- Freesync Module function to handle v-sync interrupt
- Function to calculate and program v_total in accordance
to the refresh rate ramp during static screen on/off cases
- Removed unused irq sources from the map and conversion
table. Ordered the rest according to frequency of usage.
- Fix and refactor set freesync function
- Implement freesync module function to reapply freesync states,
called after mode set
- Fix calculation issues caused by incorrect use of div64_u64

Signed-off-by: Prokhar Bhowal <Prokhar.Bhowal@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../drm/amd/dal/dc/irq/dce110/irq_service_dce110.c |  18 -
 .../drm/amd/dal/dc/irq/dce80/irq_service_dce80.c   |  18 -
 drivers/gpu/drm/amd/dal/dc/irq_types.h             |  13 -
 .../gpu/drm/amd/dal/modules/freesync/freesync.c    | 362 +++++++++++++++------
 drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h |  14 +-
 5 files changed, 273 insertions(+), 152 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c b/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
index 19bdfd9..32af9b45 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
@@ -123,9 +123,6 @@ static const struct irq_source_info_funcs vblank_irq_info_funcs = {
 		.funcs = &pflip_irq_info_funcs\
 	}
 
-#define vsync_int_entry(reg_num) \
-	[DC_IRQ_SOURCE_CRTC ## reg_num ## VSYNC] = dummy_irq_entry()
-
 #define vupdate_int_entry(reg_num)\
 	[DC_IRQ_SOURCE_VUPDATE1 + reg_num] = {\
 		.enable_reg = mmCRTC ## reg_num ## _CRTC_INTERRUPT_CONTROL,\
@@ -150,9 +147,6 @@ static const struct irq_source_info_funcs vblank_irq_info_funcs = {
 #define i2c_int_entry(reg_num) \
 	[DC_IRQ_SOURCE_I2C_DDC ## reg_num] = dummy_irq_entry()
 
-#define azalia_int_entry(reg_num) \
-	[DC_IRQ_SOURCE_AZALIA ## reg_num] = dummy_irq_entry()
-
 #define dp_sink_int_entry(reg_num) \
 	[DC_IRQ_SOURCE_DPSINK ## reg_num] = dummy_irq_entry()
 
@@ -215,24 +209,12 @@ irq_source_info_dce110[DAL_IRQ_SOURCES_NUMBER] = {
 	i2c_int_entry(4),
 	i2c_int_entry(5),
 	i2c_int_entry(6),
-	azalia_int_entry(0),
-	azalia_int_entry(1),
-	azalia_int_entry(2),
-	azalia_int_entry(3),
-	azalia_int_entry(4),
-	azalia_int_entry(5),
 	dp_sink_int_entry(1),
 	dp_sink_int_entry(2),
 	dp_sink_int_entry(3),
 	dp_sink_int_entry(4),
 	dp_sink_int_entry(5),
 	dp_sink_int_entry(6),
-	vsync_int_entry(1),
-	vsync_int_entry(2),
-	vsync_int_entry(3),
-	vsync_int_entry(3),
-	vsync_int_entry(4),
-	vsync_int_entry(5),
 	[DC_IRQ_SOURCE_TIMER] = dummy_irq_entry(),
 	pflip_int_entry(0),
 	pflip_int_entry(1),
diff --git a/drivers/gpu/drm/amd/dal/dc/irq/dce80/irq_service_dce80.c b/drivers/gpu/drm/amd/dal/dc/irq/dce80/irq_service_dce80.c
index dca5fee..8b4f453 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq/dce80/irq_service_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/irq/dce80/irq_service_dce80.c
@@ -127,9 +127,6 @@ static const struct irq_source_info_funcs vblank_irq_info_funcs = {
 		.funcs = &pflip_irq_info_funcs\
  	}
 
-#define vsync_int_entry(reg_num) \
-	[DC_IRQ_SOURCE_CRTC ## reg_num ## VSYNC] = dummy_irq_entry()
-
 #define vupdate_int_entry(reg_num)\
 	[DC_IRQ_SOURCE_VUPDATE1 + reg_num] = {\
 		.enable_reg = mmCRTC ## reg_num ## _CRTC_INTERRUPT_CONTROL,\
@@ -154,9 +151,6 @@ static const struct irq_source_info_funcs vblank_irq_info_funcs = {
 #define i2c_int_entry(reg_num) \
 	[DC_IRQ_SOURCE_I2C_DDC ## reg_num] = dummy_irq_entry()
 
-#define azalia_int_entry(reg_num) \
-	[DC_IRQ_SOURCE_AZALIA ## reg_num] = dummy_irq_entry()
-
 #define dp_sink_int_entry(reg_num) \
 	[DC_IRQ_SOURCE_DPSINK ## reg_num] = dummy_irq_entry()
 
@@ -193,24 +187,12 @@ irq_source_info_dce80[DAL_IRQ_SOURCES_NUMBER] = {
 	i2c_int_entry(4),
 	i2c_int_entry(5),
 	i2c_int_entry(6),
-	azalia_int_entry(0),
-	azalia_int_entry(1),
-	azalia_int_entry(2),
-	azalia_int_entry(3),
-	azalia_int_entry(4),
-	azalia_int_entry(5),
 	dp_sink_int_entry(1),
 	dp_sink_int_entry(2),
 	dp_sink_int_entry(3),
 	dp_sink_int_entry(4),
 	dp_sink_int_entry(5),
 	dp_sink_int_entry(6),
-	vsync_int_entry(1),
-	vsync_int_entry(2),
-	vsync_int_entry(3),
-	vsync_int_entry(3),
-	vsync_int_entry(4),
-	vsync_int_entry(5),
 	[DC_IRQ_SOURCE_TIMER] = dummy_irq_entry(),
 	pflip_int_entry(0),
 	pflip_int_entry(1),
diff --git a/drivers/gpu/drm/amd/dal/dc/irq_types.h b/drivers/gpu/drm/amd/dal/dc/irq_types.h
index 1f62e52..e4b4b99 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/irq_types.h
@@ -60,13 +60,6 @@ enum dc_irq_source {
 	DC_IRQ_SOURCE_I2C_DDC5,
 	DC_IRQ_SOURCE_I2C_DDC6,
 
-	DC_IRQ_SOURCE_AZALIA0,
-	DC_IRQ_SOURCE_AZALIA1,
-	DC_IRQ_SOURCE_AZALIA2,
-	DC_IRQ_SOURCE_AZALIA3,
-	DC_IRQ_SOURCE_AZALIA4,
-	DC_IRQ_SOURCE_AZALIA5,
-
 	DC_IRQ_SOURCE_DPSINK1,
 	DC_IRQ_SOURCE_DPSINK2,
 	DC_IRQ_SOURCE_DPSINK3,
@@ -74,12 +67,6 @@ enum dc_irq_source {
 	DC_IRQ_SOURCE_DPSINK5,
 	DC_IRQ_SOURCE_DPSINK6,
 
-	DC_IRQ_SOURCE_CRTC1VSYNC,
-	DC_IRQ_SOURCE_CRTC2VSYNC,
-	DC_IRQ_SOURCE_CRTC3VSYNC,
-	DC_IRQ_SOURCE_CRTC4VSYNC,
-	DC_IRQ_SOURCE_CRTC5VSYNC,
-	DC_IRQ_SOURCE_CRTC6VSYNC,
 	DC_IRQ_SOURCE_TIMER,
 
 	DC_IRQ_SOURCE_PFLIP_FIRST,
diff --git a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
index 099284c..d84d852 100644
--- a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
@@ -29,16 +29,27 @@
 
 #define MOD_FREESYNC_MAX_CONCURRENT_SINKS  32
 
+/* Refresh rate ramp at a fixed rate of 65 Hz/second */
+#define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
+
 struct sink_caps {
         const struct dc_sink *sink;
         struct mod_freesync_caps caps;
 };
 
+struct gradual_static_ramp {
+        bool ramp_is_active;
+        bool ramp_direction_is_up;
+        unsigned int ramp_current_frame_duration_in_ns;
+};
+
 struct freesync_state {
         bool fullscreen;
         bool static_screen;
         bool video;
+
         unsigned int duration_in_ns;
+        struct gradual_static_ramp static_ramp;
 };
 
 struct core_freesync {
@@ -200,6 +211,23 @@ void mod_freesync_update_stream(struct mod_freesync *mod_freesync,
 			stream->ignore_msa_timing_param = 1;
 }
 
+/* Given a specific dc_sink* this function finds its equivalent
+ * on the dc_sink array and returns the corresponding index
+ */
+static unsigned int sink_index_from_sink(struct core_freesync *core_freesync,
+		const struct dc_sink *sink)
+{
+	unsigned int index = 0;
+
+	for (index = 0; index < core_freesync->num_sinks; index++)
+		if (core_freesync->caps[index].sink == sink)
+			return index;
+
+	/* Could not find sink requested */
+	ASSERT(false);
+	return index;
+}
+
 static void calc_vmin_vmax (const struct dc_stream *stream,
 		struct mod_freesync_caps *caps, int *vmin, int *vmax)
 {
@@ -207,21 +235,19 @@ static void calc_vmin_vmax (const struct dc_stream *stream,
 
 	unsigned int min_frame_duration_in_ns = 0, max_frame_duration_in_ns = 0;
 
-	min_frame_duration_in_ns = (unsigned int)
-		div64_u64((1000000000ULL * 1000000), caps->max_refresh_in_micro_hz);
-	max_frame_duration_in_ns = (unsigned int)
-		div64_u64((1000000000ULL * 1000000), caps->min_refresh_in_micro_hz);
-
-	*vmax = (unsigned long long)(max_frame_duration_in_ns) *
-		div64_u64(
-			div64_u64(stream->timing.pix_clk_khz,
-					stream->timing.h_total),
-			1000000);
-	*vmin = (unsigned long long)(min_frame_duration_in_ns) *
-		div64_u64(
-			div64_u64(stream->timing.pix_clk_khz,
-					stream->timing.h_total),
-			1000000);
+	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					caps->max_refresh_in_micro_hz)));
+	max_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					caps->min_refresh_in_micro_hz)));
+
+	*vmax = div64_u64(div64_u64(((unsigned long long)(
+			max_frame_duration_in_ns) * stream->timing.pix_clk_khz),
+			stream->timing.h_total), 1000000);
+	*vmin = div64_u64(div64_u64(((unsigned long long)(
+			min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
+			stream->timing.h_total), 1000000);
 
 	/* Field rate might not be the maximum rate
 	 * in which case we should adjust our vmin
@@ -233,12 +259,125 @@ static void calc_vmin_vmax (const struct dc_stream *stream,
 static void calc_v_total_from_duration(const struct dc_stream *stream,
 		unsigned int duration_in_ns, int *v_total_nominal)
 {
-	*v_total_nominal = (unsigned long long)(duration_in_ns) *
-		div64_u64(
-			div64_u64(stream->timing.pix_clk_khz,
-					stream->timing.h_total),
-				1000000);
+	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
+				duration_in_ns) * stream->timing.pix_clk_khz),
+				stream->timing.h_total), 1000000);
+}
+
+static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
+		const struct dc_stream *stream,
+		unsigned int sink_index, int *v_total)
+{
+	unsigned int frame_duration = 0;
+
+	struct gradual_static_ramp *static_ramp_variables =
+				&core_freesync->state[sink_index].static_ramp;
+
+	/* Calc ratio between new and current frame duration with 3 digit */
+	unsigned int frame_duration_ratio = div64_u64(1000000,
+		(1000 +  div64_u64(((unsigned long long)(
+		STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME) *
+		static_ramp_variables->ramp_current_frame_duration_in_ns),
+		1000000000)));
+
+	/* Calculate delta between new and current frame duration in ns */
+	unsigned int frame_duration_delta = div64_u64(((unsigned long long)(
+		static_ramp_variables->ramp_current_frame_duration_in_ns) *
+		(1000 - frame_duration_ratio)), 1000);
+
+	/* Adjust frame duration delta based on ratio between current and
+	 * standard frame duration (frame duration at 60 Hz refresh rate).
+	 */
+	unsigned int ramp_rate_interpolated = div64_u64(((unsigned long long)(
+		frame_duration_delta) * static_ramp_variables->
+		ramp_current_frame_duration_in_ns), 16666666);
+
+	/* Going to a higher refresh rate (lower frame duration) */
+	if (static_ramp_variables->ramp_direction_is_up) {
+		/* reduce frame duration */
+		static_ramp_variables->ramp_current_frame_duration_in_ns -=
+			ramp_rate_interpolated;
+
+		/* min frame duration */
+		frame_duration = ((unsigned int) (div64_u64(
+			(1000000000ULL * 1000000),
+			core_freesync->caps[sink_index].
+			caps.max_refresh_in_micro_hz)));
+
+		/* adjust for frame duration below min */
+		if (static_ramp_variables->ramp_current_frame_duration_in_ns <=
+			frame_duration) {
+
+			static_ramp_variables->ramp_is_active = false;
+			static_ramp_variables->
+				ramp_current_frame_duration_in_ns =
+				frame_duration;
+		}
+	/* Going to a lower refresh rate (larger frame duration) */
+	} else {
+		/* increase frame duration */
+		static_ramp_variables->ramp_current_frame_duration_in_ns +=
+			ramp_rate_interpolated;
+
+		/* max frame duration */
+		frame_duration = ((unsigned int) (div64_u64(
+			(1000000000ULL * 1000000),
+			core_freesync->caps[sink_index].
+			caps.min_refresh_in_micro_hz)));
+
+		/* adjust for frame duration above max */
+		if (static_ramp_variables->ramp_current_frame_duration_in_ns >=
+			frame_duration) {
+
+			static_ramp_variables->ramp_is_active = false;
+			static_ramp_variables->
+				ramp_current_frame_duration_in_ns =
+				frame_duration;
+		}
+	}
 
+	calc_v_total_from_duration(stream, static_ramp_variables->
+		ramp_current_frame_duration_in_ns, v_total);
+}
+
+void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams)
+{
+	/* Currently we are only doing static screen ramping on v_update */
+
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int sink_index = sink_index_from_sink(core_freesync,
+				streams[0]->sink);
+
+	unsigned int v_total = 0;
+
+	/* If in fullscreen freesync mode or in video, do not program
+	 * static screen ramp values
+	 */
+	if (core_freesync->state[sink_index].fullscreen == true ||
+		core_freesync->state[sink_index].video == true) {
+
+		core_freesync->state[sink_index].static_ramp.
+			ramp_is_active = false;
+		return;
+	}
+
+
+	/* Execute if ramp is active and user enabled freesync static screen*/
+	if (core_freesync->state[sink_index].static_ramp.ramp_is_active &&
+			core_freesync->user_enable->enable_for_static)	{
+
+		calc_v_total_for_static_ramp(core_freesync, streams[0],
+				sink_index, &v_total);
+
+		/* Program static screen ramp values */
+		core_freesync->dc->stream_funcs.dc_stream_adjust_vmin_vmax(
+					core_freesync->dc, streams,
+					num_streams, v_total,
+					v_total);
+	}
 }
 /*
  * Sets freesync mode on a stream depending on current freesync state.
@@ -248,71 +387,54 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 {
 	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
 	int i = 0;
+	unsigned int stream_idx, sink_index = 0;
 
 	if (num_streams == 0 || streams == NULL || num_streams > 1)
 		return false;
 
-	/* TODO: Multi-stream support */
+	for (stream_idx = 0; stream_idx < num_streams; stream_idx++) {
 
-	/* Fullscreen has the topmost priority. If the fullscreen bit is
-	 * set, we are in a fullscreen application where it should not
-	 * matter if it is static screen. We should not check the
-	 * static_screen bit - we want to enable freesync regardless.
-	 */
-	if (core_freesync->user_enable->enable_for_gaming == true &&
-			core_freesync->state->fullscreen == true) {
-		/* Enable freesync */
-		for (i = 0; i < core_freesync->num_sinks; i++) {
-			if (core_freesync->caps[i].sink == streams[0]->sink &&
-					core_freesync->caps[i].caps.supported) {
-
-				calc_vmin_vmax(streams[0],
-						&core_freesync->caps[i].caps,
-						&v_total_min, &v_total_max);
+		sink_index = sink_index_from_sink(core_freesync,
+				streams[stream_idx]->sink);
 
-				core_freesync->dc->stream_funcs.
-				dc_stream_adjust_vmin_vmax(
-						core_freesync->dc, streams,
-						num_streams, v_total_min,
-						v_total_max);
+		if (core_freesync->caps[sink_index].caps.supported) {
 
-				return true;
-			}
-		}
-	} else if ( core_freesync->user_enable->enable_for_static == true &&
-			core_freesync->state->static_screen == true)	{
-		/* Enable Static Screen */
-		for (i = 0; i < core_freesync->num_sinks; i++) {
-			if (core_freesync->caps[i].sink == streams[0]->sink &&
-					core_freesync->caps[i].caps.supported) {
-
-				calc_vmin_vmax(streams[0],
+			/* Fullscreen has the topmost priority. If the
+			 * fullscreen bit is set, we are in a fullscreen
+			 * application where it should not matter if it is
+			 * static screen. We should not check the static_screen
+			 * bit - we want to enable freesync regardless.
+			 */
+			if (core_freesync->user_enable[sink_index].
+				enable_for_gaming && core_freesync->
+				state[sink_index].fullscreen == true) {
+				/* Enable freesync */
+
+				calc_vmin_vmax(streams[stream_idx],
 						&core_freesync->caps[i].caps,
 						&v_total_min, &v_total_max);
 
 				core_freesync->dc->stream_funcs.
 				dc_stream_adjust_vmin_vmax(
 						core_freesync->dc, streams,
-						num_streams, v_total_max,
+						num_streams, v_total_min,
 						v_total_max);
 
 				return true;
-			}
-		}
-	}  else if ( core_freesync->user_enable->enable_for_video == true &&
-			core_freesync->state->video == true)	{
-		/* Enable 48Hz feature */
-		for (i = 0; i < core_freesync->num_sinks; i++) {
-			if (core_freesync->caps[i].sink == streams[0]->sink &&
-					core_freesync->caps[i].caps.supported) {
 
-				calc_v_total_from_duration(streams[0],
-					core_freesync->state->duration_in_ns,
-					&v_total_nominal);
+			} else if (core_freesync->user_enable[sink_index].
+				enable_for_video && core_freesync->
+				state[sink_index].video == true) {
+				/* Enable 48Hz feature */
+
+				calc_v_total_from_duration(streams[stream_idx],
+					core_freesync->state[sink_index].
+					duration_in_ns, &v_total_nominal);
 
 				/* Program only if v_total_nominal is in range*/
 				if (v_total_nominal >=
-						streams[0]->timing.v_total)
+					streams[stream_idx]->timing.v_total)
+
 					core_freesync->dc->stream_funcs.
 					dc_stream_adjust_vmin_vmax(
 						core_freesync->dc, streams,
@@ -320,39 +442,71 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 						v_total_nominal);
 
 				return true;
+
+			} else {
+				/* Disable freesync */
+				v_total_nominal = streams[stream_idx]->
+					timing.v_total;
+
+				core_freesync->dc->stream_funcs.
+						dc_stream_adjust_vmin_vmax(
+						core_freesync->dc, streams,
+						num_streams, v_total_nominal,
+						v_total_nominal);
+
+				return true;
 			}
 		}
-	} else {
-		/* Disable freesync */
-		v_total_nominal = streams[0]->timing.v_total;
-
-		core_freesync->dc->stream_funcs.
-		dc_stream_adjust_vmin_vmax(
-				core_freesync->dc, streams, num_streams,
-				v_total_nominal, v_total_nominal);
 
-		return true;
 	}
 
 	return false;
 }
 
-
-/* Given a specific dc_sink* this function finds its equivalent
- * on the dc_sink array and returns the corresponding index
- */
-static unsigned int sink_index_from_sink(struct core_freesync *core_freesync,
-		const struct dc_sink * sink)
+static void set_static_ramp_variables(struct core_freesync *core_freesync,
+		unsigned int sink_index, bool enable_static_screen)
 {
-	unsigned int index;
+	unsigned int frame_duration = 0;
 
-	for(index = 0; index < core_freesync->num_sinks; index++)
-		if(core_freesync->caps[index].sink == sink)
-			break;
+	struct gradual_static_ramp *static_ramp_variables =
+			&core_freesync->state[sink_index].static_ramp;
 
-	return index;
-}
+	/* If ramp is not active, set initial frame duration depending on
+	 * whether we are enabling/disabling static screen mode. If the ramp is
+	 * already active, ramp should continue in the opposite direction
+	 * starting with the current frame duration
+	 */
+	if (!static_ramp_variables->ramp_is_active) {
+
+		static_ramp_variables->ramp_is_active = true;
+
+		if (enable_static_screen == true) {
+			/* Going to lower refresh rate, so start from max
+			 * refresh rate (min frame duration)
+			 */
+			frame_duration = ((unsigned int) (div64_u64(
+				(1000000000ULL * 1000000),
+				core_freesync->caps[sink_index].
+				caps.max_refresh_in_micro_hz)));
+		} else {
+			/* Going to higher refresh rate, so start from min
+			 * refresh rate (max frame duration)
+			 */
+			frame_duration = ((unsigned int) (div64_u64(
+				(1000000000ULL * 1000000),
+				core_freesync->caps[sink_index].
+				caps.min_refresh_in_micro_hz)));
+		}
 
+		static_ramp_variables->
+			ramp_current_frame_duration_in_ns = frame_duration;
+	}
+
+	/* If we are ENABLING static screen, refresh rate should go DOWN.
+	 * If we are DISABLING static screen, refresh rate should go UP.
+	 */
+	static_ramp_variables->ramp_direction_is_up = !enable_static_screen;
+}
 
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams,
@@ -364,6 +518,7 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 	unsigned int stream_index;
 
 	for(stream_index = 0; stream_index < num_streams; stream_index++) {
+
 		unsigned int sink_index = sink_index_from_sink(core_freesync,
 				streams[stream_index]->sink);
 
@@ -374,18 +529,32 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 			freesync_program_required = true;
 			break;
 		case FREESYNC_STATE_STATIC_SCREEN:
-			core_freesync->state[sink_index].static_screen =
+			/* Change core variables only if there is a change*/
+			if (core_freesync->state[sink_index].static_screen !=
+				freesync_params->enable) {
+
+				/* Change the state flag */
+				core_freesync->state[sink_index].static_screen =
 					freesync_params->enable;
-			freesync_program_required = true;
+
+				/* Change static screen ramp variables */
+				set_static_ramp_variables(core_freesync,
+						sink_index,
+						freesync_params->enable);
+			}
+			/* We program the ramp starting next VUpdate */
 			break;
 		case FREESYNC_STATE_VIDEO:
+			/* Change core variables only if there is a change*/
 			if(freesync_params->duration_in_ns != core_freesync->
 					state[sink_index].duration_in_ns) {
+
 				core_freesync->state[sink_index].video =
 						freesync_params->enable;
 				core_freesync->
 					state[sink_index].duration_in_ns =
 					freesync_params->duration_in_ns;
+
 				freesync_program_required = true;
 			}
 			break;
@@ -397,13 +566,6 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		set_freesync_on_streams(core_freesync, streams, num_streams);
 }
 
-void mod_freesync_vupdate_callback(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream)
-{
-
-}
-
-
 bool mod_freesync_get_freesync_caps(struct mod_freesync *mod_freesync,
 		const struct dc_sink *sink, struct mod_freesync_caps *caps)
 {
@@ -453,3 +615,13 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 
 	return true;
 }
+
+void mod_freesync_reapply_current_state(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	/* Program freesync according to current state*/
+	set_freesync_on_streams(core_freesync, streams, num_streams);
+}
diff --git a/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h b/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h
index 77739db..50ce1d9 100644
--- a/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h
+++ b/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h
@@ -92,14 +92,6 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams,
 		struct mod_freesync_params *freesync_params);
 
-/*
- * This interface must be called for on every VUPDATE event for every stream
- * which is not FREESYNC_MODE_DISABLED.  Calling this for a stream that is in
- * FREESYNC_MODE_DISABLED has no effect.
- */
-void mod_freesync_vupdate_callback(struct mod_freesync *mod_freesync,
-	struct dc_stream *stream);
-
 bool mod_freesync_get_freesync_caps(struct mod_freesync *mod_freesync,
 		const struct dc_sink *sink, struct mod_freesync_caps *caps);
 
@@ -111,4 +103,10 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 		const struct dc_sink *sink,
 		struct mod_freesync_user_enable *user_enable);
 
+void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams);
+
+void mod_freesync_reapply_current_state(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams);
+
 #endif
-- 
2.7.4

