From 8820504bbbbfd950f080208b481806ff2275e082 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Mon, 22 Feb 2016 14:10:19 -0500
Subject: [PATCH 0854/1110] drm/amd/dal: Remove ctx from dm_alloc/free

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      |  9 ---
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h      |  1 -
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c  |  2 -
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c  |  3 -
 .../drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c    |  3 -
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c | 27 +-------
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    |  5 --
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.h    |  1 -
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c   | 15 +---
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.h   |  1 -
 .../adapter/dce110/hw_ctx_adapter_service_dce110.c |  8 +--
 .../adapter/dce110/hw_ctx_adapter_service_dce110.h |  1 -
 .../adapter/dce80/hw_ctx_adapter_service_dce80.c   |  6 +-
 .../adapter/dce80/hw_ctx_adapter_service_dce80.h   |  1 -
 .../diagnostics/hw_ctx_adapter_service_diag.c      |  5 +-
 .../diagnostics/hw_ctx_adapter_service_diag.h      |  1 -
 .../drm/amd/dal/dc/adapter/wireless_data_source.h  |  1 -
 .../amd/dal/dc/asic_capability/asic_capability.c   |  6 +-
 .../dc/asic_capability/carrizo_asic_capability.c   |  1 -
 .../dc/asic_capability/hawaii_asic_capability.c    |  2 -
 .../dal/dc/asic_capability/tonga_asic_capability.c |  2 -
 drivers/gpu/drm/amd/dal/dc/audio/audio.h           |  2 -
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c |  8 +--
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h |  2 -
 .../amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c  | 15 +---
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c   |  8 +--
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h   |  1 -
 .../amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c    | 40 +----------
 .../amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h    |  3 -
 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c    | 11 ---
 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h    |  7 --
 drivers/gpu/drm/amd/dal/dc/basics/conversion.c     |  1 -
 drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c     |  2 -
 drivers/gpu/drm/amd/dal/dc/basics/logger.c         | 39 +++--------
 drivers/gpu/drm/amd/dal/dc/basics/logger.h         |  1 -
 drivers/gpu/drm/amd/dal/dc/basics/vector.c         | 20 +++---
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c      | 24 +++----
 drivers/gpu/drm/amd/dal/dc/bios/command_table.c    |  5 --
 .../dc/bios/dce110/command_table_helper_dce110.c   |  1 -
 .../dal/dc/bios/dce80/bios_parser_helper_dce80.c   |  1 -
 drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c | 10 ++-
 drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c        |  2 -
 drivers/gpu/drm/amd/dal/dc/calcs/gamma_calcs.c     |  3 -
 drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c   | 63 +++++++----------
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 37 ++++------
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          | 15 +---
 drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c      | 25 +++----
 drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c       | 13 +---
 drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c     |  2 -
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  7 --
 drivers/gpu/drm/amd/dal/dc/core/dc_sink.c          |  9 +--
 drivers/gpu/drm/amd/dal/dc/core/dc_stream.c        |  7 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_surface.c       | 14 ++--
 drivers/gpu/drm/amd/dal/dc/core/dc_target.c        |  4 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  4 --
 drivers/gpu/drm/amd/dal/dc/dc_bios_types.h         |  1 -
 drivers/gpu/drm/amd/dal/dc/dc_ddc_types.h          |  1 -
 drivers/gpu/drm/amd/dal/dc/dc_hw_types.h           |  1 -
 drivers/gpu/drm/amd/dal/dc/dc_types.h              |  3 -
 .../drm/amd/dal/dc/dce100/dce100_hw_sequencer.c    |  1 -
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    | 81 +++++++++-------------
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.h    |  1 -
 .../drm/amd/dal/dc/dce110/dce110_clock_source.c    | 19 ++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_compressor.c  |  9 +--
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 23 ++----
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c     |  2 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.h     |  1 -
 .../gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c  |  1 -
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.h    |  1 -
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c   |  7 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h   |  2 -
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c |  7 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h |  1 -
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c     |  2 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h     |  1 -
 .../gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c |  1 -
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c   |  3 -
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    | 66 ++++++++----------
 .../amd/dal/dc/dce110/dce110_timing_generator.c    |  4 --
 .../amd/dal/dc/dce110/dce110_timing_generator.h    |  4 --
 .../amd/dal/dc/dce110/dce110_timing_generator_v.c  |  4 --
 .../drm/amd/dal/dc/dce110/dce110_transform_scl.c   |  2 -
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c |  8 ---
 .../gpu/drm/amd/dal/dc/dce80/dce80_compressor.c    |  9 +--
 .../gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c  |  2 -
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.c       |  2 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.h       |  2 -
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp_gamma.c |  9 ---
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c  |  1 -
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c |  1 -
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.c       |  8 +--
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h       |  1 -
 .../gpu/drm/amd/dal/dc/dce80/dce80_opp_regamma.c   |  1 -
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  | 51 ++++++--------
 .../drm/amd/dal/dc/dce80/dce80_stream_encoder.h    |  1 -
 .../drm/amd/dal/dc/dce80/dce80_timing_generator.h  |  3 -
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h |  1 -
 drivers/gpu/drm/amd/dal/dc/dm_services.h           | 12 +---
 drivers/gpu/drm/amd/dal/dc/dm_services_types.h     |  1 -
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c |  7 +-
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c |  6 +-
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c   |  6 +-
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c   |  7 +-
 drivers/gpu/drm/amd/dal/dc/gpio/ddc.c              |  6 +-
 .../drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c  |  6 +-
 .../drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c  |  7 +-
 .../drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.h  |  1 -
 .../dal/dc/gpio/diagnostics/hw_translate_diag.c    |  1 -
 drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c        |  4 +-
 drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c     | 14 ++--
 drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c       |  2 +-
 drivers/gpu/drm/amd/dal/dc/gpio/irq.c              |  6 +-
 .../amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c |  1 -
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |  9 +--
 .../drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c | 12 +---
 drivers/gpu/drm/amd/dal/dc/gpu/divider_range.h     |  1 -
 .../amd/dal/dc/i2caux/dce110/aux_engine_dce110.c   |  7 +-
 .../dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c    | 11 +--
 .../dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c    |  6 +-
 .../drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c   |  6 +-
 .../drm/amd/dal/dc/i2caux/dce80/aux_engine_dce80.c |  8 +--
 .../amd/dal/dc/i2caux/dce80/i2c_hw_engine_dce80.c  |  8 +--
 .../amd/dal/dc/i2caux/dce80/i2c_sw_engine_dce80.c  |  8 +--
 .../gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c |  7 +-
 .../amd/dal/dc/i2caux/diagnostics/i2caux_diag.c    |  8 +--
 drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c  |  8 +--
 drivers/gpu/drm/amd/dal/dc/inc/bandwidth_calcs.h   |  3 -
 drivers/gpu/drm/amd/dal/dc/inc/bw_fixed.h          |  1 -
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |  3 -
 drivers/gpu/drm/amd/dal/dc/inc/hw/ipp.h            |  2 -
 drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h            |  4 --
 drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h |  2 -
 .../gpu/drm/amd/dal/dc/inc/hw/timing_generator.h   |  2 -
 drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h      |  1 -
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |  3 -
 .../drm/amd/dal/dc/irq/dce110/irq_service_dce110.c |  4 +-
 drivers/gpu/drm/amd/dal/dc/irq/irq_service.c       |  2 +-
 drivers/gpu/drm/amd/dal/dc/irq_types.h             |  1 -
 .../drm/amd/dal/dc/virtual/virtual_link_encoder.h  |  1 -
 .../amd/dal/dc/virtual/virtual_stream_encoder.c    |  4 +-
 .../amd/dal/include/adapter_service_interface.h    |  3 -
 .../amd/dal/include/asic_capability_interface.h    |  2 -
 .../drm/amd/dal/include/asic_capability_types.h    |  4 --
 drivers/gpu/drm/amd/dal/include/audio_interface.h  |  2 -
 drivers/gpu/drm/amd/dal/include/audio_types.h      |  2 -
 drivers/gpu/drm/amd/dal/include/dal_asic_id.h      |  1 -
 .../gpu/drm/amd/dal/include/dal_register_logger.h  |  1 -
 .../gpu/drm/amd/dal/include/ddc_service_types.h    |  2 -
 .../drm/amd/dal/include/display_clock_interface.h  |  1 -
 drivers/gpu/drm/amd/dal/include/dpcd_defs.h        |  1 -
 drivers/gpu/drm/amd/dal/include/fixed31_32.h       |  1 -
 drivers/gpu/drm/amd/dal/include/gpio_types.h       |  1 -
 .../drm/amd/dal/include/grph_object_ctrl_defs.h    |  2 -
 drivers/gpu/drm/amd/dal/include/grph_object_defs.h |  1 -
 drivers/gpu/drm/amd/dal/include/grph_object_id.h   |  3 -
 .../gpu/drm/amd/dal/include/hw_sequencer_types.h   |  4 --
 drivers/gpu/drm/amd/dal/include/i2caux_interface.h |  1 -
 drivers/gpu/drm/amd/dal/include/logger_interface.h |  1 -
 drivers/gpu/drm/amd/dal/include/logger_types.h     |  3 -
 drivers/gpu/drm/amd/dal/include/set_mode_types.h   |  3 -
 160 files changed, 311 insertions(+), 803 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index 0f60db4..257969f 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -382,7 +382,6 @@ static int dm_sw_fini(void *handle)
 	return 0;
 }
 
-
 static void detect_link_for_all_connectors(struct drm_device *dev)
 {
 	struct amdgpu_connector *aconnector;
@@ -406,7 +405,6 @@ static void detect_link_for_all_connectors(struct drm_device *dev)
 	drm_modeset_unlock(&dev->mode_config.connection_mutex);
 }
 
-
 static int dm_hw_init(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
@@ -417,8 +415,6 @@ static int dm_hw_init(void *handle)
 
 	detect_link_for_all_connectors(adev->ddev);
 
-
-
 	return 0;
 }
 
@@ -601,7 +597,6 @@ int amdgpu_dm_display_resume(struct amdgpu_device *adev )
 		amdgpu_dm_update_connector_after_detect(aconnector);
 	}
 
-
 	drm_modeset_lock_all(ddev);
 	ret = dm_display_resume(ddev);
 	drm_modeset_unlock_all(ddev);
@@ -639,7 +634,6 @@ static struct drm_mode_config_funcs amdgpu_dm_mode_funcs = {
 	.atomic_commit = amdgpu_dm_atomic_commit
 };
 
-
 void amdgpu_dm_update_connector_after_detect(
 	struct amdgpu_connector *aconnector)
 {
@@ -1276,12 +1270,9 @@ static int dm_early_init(void *handle)
 	 * adev->audio_endpt_wreg because they are initialised in
 	 * amdgpu_device_init() */
 
-
-
 	return 0;
 }
 
-
 bool amdgpu_dm_acquire_dal_lock(struct amdgpu_display_manager *dm)
 {
 	/* TODO */
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h
index 0da8530..4f3bf97 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h
@@ -128,7 +128,6 @@ struct amdgpu_display_manager {
 	struct work_struct mst_hotplug_work;
 };
 
-
 /* basic init/fini API */
 int amdgpu_dm_init(struct amdgpu_device *adev);
 
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
index 17240e0..e442318 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
@@ -164,7 +164,6 @@ static struct amdgpu_connector *get_connector_for_link(
 	return aconnector;
 }
 
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 static void get_payload_table(
 		struct amdgpu_connector *aconnector,
@@ -469,7 +468,6 @@ bool dm_helpers_dp_read_dpcd(
 		uint32_t size)
 {
 
-
 	struct amdgpu_device *adev = ctx->driver_context;
 	struct drm_device *dev = adev->ddev;
 	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c
index d04ed18..2757c5c 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.c
@@ -32,7 +32,6 @@
 #include "amdgpu_dm.h"
 #include "amdgpu_dm_irq.h"
 
-
 /******************************************************************************
  * Private declarations.
  *****************************************************************************/
@@ -57,7 +56,6 @@ struct amdgpu_dm_timer_handler_data {
 	struct delayed_work d_work;
 };
 
-
 #define DM_IRQ_TABLE_LOCK(adev, flags) \
 	spin_lock_irqsave(&adev->dm.irq_handler_list_table_lock, flags)
 
@@ -548,7 +546,6 @@ int amdgpu_dm_irq_resume(
 	return 0;
 }
 
-
 /**
  * amdgpu_dm_irq_schedule_work - schedule all work items registered for the
  * "irq_source".
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
index a8b489f..6876643 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -33,7 +33,6 @@
 #include "dc.h"
 #include "dm_helpers.h"
 
-
 /* #define TRACE_DPCD */
 
 #ifdef TRACE_DPCD
@@ -342,7 +341,6 @@ static struct drm_connector *dm_dp_add_mst_connector(struct drm_dp_mst_topology_
 	}
 	drm_modeset_unlock(&dev->mode_config.connection_mutex);
 
-
 	aconnector = kzalloc(sizeof(*aconnector), GFP_KERNEL);
 	if (!aconnector)
 		return NULL;
@@ -459,7 +457,6 @@ struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 };
 #endif
 
-
 void amdgpu_dm_initialize_mst_connector(
 	struct amdgpu_display_manager *dm,
 	struct amdgpu_connector *aconnector)
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
index 116d34d..26208eb 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
@@ -36,35 +36,15 @@
 #include "amdgpu_dm_types.h"
 #include "amdgpu_pm.h"
 
-/*
-#include "logger_interface.h"
-#include "acpimethod_atif.h"
-#include "amdgpu_powerplay.h"
-#include "amdgpu_notifications.h"
-*/
-
-/* if the pointer is not NULL, the allocated memory is zeroed */
-void *dm_alloc(struct dc_context *ctx, uint32_t size)
-{
-	return kzalloc(size, GFP_KERNEL);
-}
-
-/* Reallocate memory. The contents will remain unchanged.*/
-void *dm_realloc(struct dc_context *ctx, const void *ptr, uint32_t size)
-{
-	return krealloc(ptr, size, GFP_KERNEL);
-}
+#define dm_alloc(size) kzalloc(size, GFP_KERNEL)
+#define dm_realloc(ptr, size) krealloc(ptr, size, GFP_KERNEL)
+#define dm_free(ptr) kfree(ptr)
 
 void dm_memmove(void *dst, const void *src, uint32_t size)
 {
 	memmove(dst, src, size);
 }
 
-void dm_free(struct dc_context *ctx, void *p)
-{
-	kfree(p);
-}
-
 void dm_memset(void *p, int32_t c, uint32_t count)
 {
 	memset(p, c, count);
@@ -432,7 +412,6 @@ bool dm_pp_get_clock_levels_by_type(
 
 /**** end of power component interfaces ****/
 
-
 /* Calls to notification */
 
 void dal_notify_setmode_complete(struct dc_context *ctx,
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index f8c423a..1c767f3 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -397,7 +397,6 @@ static bool get_fb_info(
 		return false;
 	}
 
-
 	if (fb_location)
 		*fb_location = amdgpu_bo_gpu_offset(rbo);
 
@@ -453,7 +452,6 @@ static void fill_plane_attributes_from_fb(
 		tile_split = AMDGPU_TILING_GET(tiling_flags, TILE_SPLIT);
 		num_banks = AMDGPU_TILING_GET(tiling_flags, NUM_BANKS);
 
-
 		/* XXX fix me for VI */
 		surface->tiling_info.num_banks = num_banks;
 		surface->tiling_info.array_mode =
@@ -848,7 +846,6 @@ static void decide_crtc_timing_for_drm_display_mode(
 	}
 }
 
-
 static struct dc_target *create_target_for_sink(
 		const struct amdgpu_connector *aconnector,
 		struct drm_display_mode *drm_mode)
@@ -1282,7 +1279,6 @@ stream_create_fail:
 	return result;
 }
 
-
 static const struct drm_connector_helper_funcs
 amdgpu_dm_connector_helper_funcs = {
 	/*
@@ -2598,7 +2594,6 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 		}
 	}
 
-
 	for (i = 0; i < set_count; i++) {
 		for_each_plane_in_state(state, plane, plane_state, j) {
 			struct drm_plane_state *old_plane_state = plane->state;
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.h b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.h
index 0481075..2cf7cd2 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.h
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.h
@@ -23,7 +23,6 @@
  *
  */
 
-
 #ifndef __AMDGPU_DM_TYPES_H__
 #define __AMDGPU_DM_TYPES_H__
 
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index 0fd1050..99ba0c7 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -179,7 +179,6 @@ static struct feature_source_entry feature_entry_table[] = {
 	{FEATURE_8BPP_SUPPORTED, false, true}
 };
 
-
 /* Stores entire ASIC features by sets */
 uint32_t adapter_feature_set[FEATURE_MAXIMUM/32];
 
@@ -210,7 +209,6 @@ static void get_platform_info_methods(
 	if (dm_get_platform_info(as->ctx, &params))
 		as->platform_methods_mask = mask;
 
-
 }
 
 static void initialize_backlight_caps(
@@ -602,7 +600,6 @@ static bool generate_feature_set(
 	dm_memset(adapter_feature_set, 0, sizeof(adapter_feature_set));
 	entry_num = get_feature_entries_num();
 
-
 	while (i != entry_num) {
 		entry = &feature_entry_table[i];
 
@@ -641,7 +638,6 @@ static bool generate_feature_set(
 	return true;
 }
 
-
 /*
  * create_hw_ctx
  *
@@ -845,7 +841,7 @@ struct adapter_service *dal_adapter_service_create(
 {
 	struct adapter_service *as;
 
-	as = dm_alloc(init_data->ctx, sizeof(struct adapter_service));
+	as = dm_alloc(sizeof(struct adapter_service));
 
 	if (!as) {
 		ASSERT_CRITICAL(false);
@@ -857,7 +853,7 @@ struct adapter_service *dal_adapter_service_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(init_data->ctx, as);
+	dm_free(as);
 
 	return NULL;
 }
@@ -882,7 +878,7 @@ void dal_adapter_service_destroy(
 
 	adapter_service_destruct(*as);
 
-	dm_free((*as)->ctx, *as);
+	dm_free(*as);
 
 	*as = NULL;
 }
@@ -923,7 +919,6 @@ enum dce_environment dal_adapter_service_get_dce_environment(
 	return as->dce_environment;
 }
 
-
 /*
  * dal_adapter_service_get_controllers_num
  *
@@ -1257,7 +1252,6 @@ struct ddc *dal_adapter_service_obtain_ddc(
 	struct graphics_object_i2c_info i2c_info;
 	struct gpio_ddc_hw_info hw_info;
 
-
 	if (!dal_adapter_service_get_i2c_info(as, id, &i2c_info))
 		return NULL;
 
@@ -1451,7 +1445,6 @@ struct asic_bugs dal_adapter_service_get_asic_bugs(
 	return as->asic_cap->bugs;
 }
 
-
 struct dal_asic_runtime_flags dal_adapter_service_get_asic_runtime_flags(
 		struct adapter_service *as)
 {
@@ -1754,7 +1747,6 @@ struct graphics_object_id dal_adapter_service_enum_audio_object(
 	return as->hw_ctx->funcs->enum_audio_object(as->hw_ctx, index);
 }
 
-
 void dal_adapter_service_update_audio_connectivity(
 	struct adapter_service *as,
 	uint32_t number_of_audio_capable_display_path)
@@ -2015,7 +2007,6 @@ bool dal_adapter_service_get_panel_backlight_boundaries(
 	return false;
 }
 
-
 uint32_t dal_adapter_service_get_view_port_pixel_granularity(
 	struct adapter_service *as)
 {
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h
index 60464e8..7cc8991 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.h
@@ -37,7 +37,6 @@
 struct gpio_service;
 struct asic_cap;
 
-
 /* Adapter service */
 struct adapter_service {
 	struct dc_context *ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c b/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c
index f10bee6..73eb816 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.c
@@ -87,7 +87,7 @@ static void destroy(
 
 	destruct(hw_ctx);
 
-	dm_free(ptr->ctx, hw_ctx);
+	dm_free(hw_ctx);
 }
 
 /*
@@ -191,7 +191,6 @@ static uint32_t get_number_of_connected_audio_endpoints(
 	return field;
 }
 
-
 /*
  * power_up
  *
@@ -212,7 +211,6 @@ static bool power_up(
 	/* Allow DP audio all the time
 	 * without additional pinstrap check on Fusion */
 
-
 	{
 		uint32_t value = 0;
 		uint32_t field = 0;
@@ -286,7 +284,7 @@ struct hw_ctx_adapter_service *
 			struct dc_context *ctx)
 {
 	struct hw_ctx_adapter_service_dce110 *hw_ctx =
-			dm_alloc(ctx, sizeof(struct hw_ctx_adapter_service_dce110));
+			dm_alloc(sizeof(struct hw_ctx_adapter_service_dce110));
 
 	if (!hw_ctx) {
 		ASSERT_CRITICAL(false);
@@ -298,7 +296,7 @@ struct hw_ctx_adapter_service *
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, hw_ctx);
+	dm_free(hw_ctx);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.h b/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.h
index 092b671..72b2103 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/dce110/hw_ctx_adapter_service_dce110.h
@@ -37,4 +37,3 @@ struct hw_ctx_adapter_service *
 
 #endif /* __DAL_HW_CTX_ADAPTER_SERVICE_DCE110_H__ */
 
-
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.c b/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.c
index 9d6505c..95d0d00 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.c
@@ -89,7 +89,7 @@ static void destroy(
 
 	destruct(hw_ctx);
 
-	dm_free(ptr->ctx, hw_ctx);
+	dm_free(hw_ctx);
 }
 
 static uint32_t get_number_of_connected_audio_endpoints_multistream(
@@ -304,7 +304,7 @@ struct hw_ctx_adapter_service *
 	dal_adapter_service_create_hw_ctx_dce80(struct dc_context *ctx)
 {
 	struct hw_ctx_adapter_service_dce80 *hw_ctx =
-			dm_alloc(ctx, sizeof(struct hw_ctx_adapter_service_dce80));
+			dm_alloc(sizeof(struct hw_ctx_adapter_service_dce80));
 
 	if (!hw_ctx) {
 		BREAK_TO_DEBUGGER();
@@ -316,7 +316,7 @@ struct hw_ctx_adapter_service *
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, hw_ctx);
+	dm_free(hw_ctx);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.h b/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.h
index a735eaf..9fddbe0 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/dce80/hw_ctx_adapter_service_dce80.h
@@ -37,4 +37,3 @@ struct hw_ctx_adapter_service *
 
 #endif /* __DAL_HW_CTX_ADAPTER_SERVICE_DCE80_H__ */
 
-
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c b/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c
index 4f5f040..363564f 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.c
@@ -112,8 +112,7 @@ static bool construct(
 struct hw_ctx_adapter_service *dal_adapter_service_create_hw_ctx_diag(
 	struct dc_context *ctx)
 {
-	struct hw_ctx_adapter_service *hw_ctx = dm_alloc(ctx,
-			sizeof(*hw_ctx));
+	struct hw_ctx_adapter_service *hw_ctx = dm_alloc(sizeof(*hw_ctx));
 
 	if (!hw_ctx) {
 		ASSERT_CRITICAL(false);
@@ -125,7 +124,7 @@ struct hw_ctx_adapter_service *dal_adapter_service_create_hw_ctx_diag(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, hw_ctx);
+	dm_free(hw_ctx);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.h b/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.h
index 39ae752..d939bef 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/diagnostics/hw_ctx_adapter_service_diag.h
@@ -26,7 +26,6 @@
 #ifndef __DAL_HW_CTX_ADAPTER_SERVICE_DIAG_H__
 #define __DAL_HW_CTX_ADAPTER_SERVICE_DIAG_H__
 
-
 struct hw_ctx_adapter_service *dal_adapter_service_create_hw_ctx_diag(
 		struct dc_context *ctx);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h
index b64089e..972ada8 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.h
@@ -51,7 +51,6 @@ struct wireless_data {
 	bool miracast_connector_enable;
 };
 
-
 /*construct wireless data*/
 bool wireless_data_init(
 	struct wireless_data *data,
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c
index 69909dd..f7fa96c 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/asic_capability.c
@@ -155,7 +155,7 @@ struct asic_capability *dal_asic_capability_create(
 		return NULL;
 	}
 
-	cap = dm_alloc(ctx, sizeof(struct asic_capability));
+	cap = dm_alloc(sizeof(struct asic_capability));
 
 	if (!cap) {
 		BREAK_TO_DEBUGGER();
@@ -167,7 +167,7 @@ struct asic_capability *dal_asic_capability_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, cap);
+	dm_free(cap);
 
 	return NULL;
 }
@@ -192,7 +192,7 @@ void dal_asic_capability_destroy(
 
 	destruct(*cap);
 
-	dm_free((*cap)->ctx, *cap);
+	dm_free(*cap);
 
 	*cap = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c
index 4aa8c30..4f2e6b8 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/carrizo_asic_capability.c
@@ -143,5 +143,4 @@ void carrizo_asic_capability_create(struct asic_capability *cap,
 
 	}
 
-
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/hawaii_asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/hawaii_asic_capability.c
index 2745ac1..2913e57 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/hawaii_asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/hawaii_asic_capability.c
@@ -41,7 +41,6 @@
 #include "dce/dce_8_0_d.h"
 #include "gmc/gmc_7_1_d.h"
 
-
 /*
  * Sea Islands (CI) ASIC capability.
  *
@@ -124,7 +123,6 @@ void dal_hawaii_asic_capability_create(struct asic_capability *cap,
 	/* Report headless if no OPM attached (with MXM connectors present). */
 	cap->caps.HEADLESS_NO_OPM_SUPPORTED = true;
 
-
 	cap->caps.HPD_CHECK_FOR_EDID = true;
 	cap->caps.NO_VCC_OFF_HPD_POLLING = true;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
index af669c8..880820c 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
@@ -70,7 +70,6 @@ void tonga_asic_capability_create(struct asic_capability *cap,
 	cap->data[ASIC_DATA_DEFAULT_I2C_SPEED_IN_KHZ] = 40;
 	cap->data[ASIC_DATA_NUM_OF_VIDEO_PLANES] = 1;
 
-
 	/* ASIC basic capability */
 	cap->caps.IS_FUSION = true;
 	cap->caps.DP_MST_SUPPORTED = true;
@@ -142,5 +141,4 @@ void tonga_asic_capability_create(struct asic_capability *cap,
 		break;
 	}
 
-
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio.h b/drivers/gpu/drm/amd/dal/dc/audio/audio.h
index ad2dc18..7ca71eb 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/audio.h
@@ -191,5 +191,3 @@ void dal_audio_release_hw_base(
 
 #endif  /* __DAL_AUDIO__ */
 
-
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
index 1aa0c1e..9f311b2 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
@@ -53,11 +53,10 @@ static void destroy(struct audio **ptr)
 	destruct(audio);
 
 	/* release memory allocated for audio_dce110*/
-	dm_free((*ptr)->ctx, audio);
+	dm_free(audio);
 	*ptr = NULL;
 }
 
-
 /* The inital call of hook function comes from audio object level.
  *The passing object handle "struct audio *audio" point to base object
  *already.There is not need to get base object from audio_dce110.
@@ -419,14 +418,13 @@ static bool construct(
 	return true;
 }
 
-
 /* --- audio scope functions  --- */
 
 struct audio *dal_audio_create_dce110(
 	const struct audio_init_data *init_data)
 {
 	/*allocate memory for audio_dce110 */
-	struct audio_dce110 *audio = dm_alloc(init_data->ctx, sizeof(*audio));
+	struct audio_dce110 *audio = dm_alloc(sizeof(*audio));
 
 	if (audio == NULL) {
 		ASSERT_CRITICAL(audio);
@@ -443,7 +441,7 @@ struct audio *dal_audio_create_dce110(
 		"Failed to create audio object for DCE11\n");
 
 	 /*release memory allocated if fail */
-	dm_free(init_data->ctx, audio);
+	dm_free(audio);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
index e5ff823..efd441e 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
@@ -29,8 +29,6 @@
 #include "audio/hw_ctx_audio.h"
 #include "audio/dce110/hw_ctx_audio_dce110.h"
 
-
-
 struct audio_dce110 {
 	struct audio base;
 	/* dce-specific members are following */
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
index 50f2e66..64d3dbf 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
@@ -73,7 +73,7 @@ static void destroy(
 
 	destruct(hw_ctx_dce110);
 	/* release memory allocated for struct hw_ctx_audio_dce110 */
-	dm_free((*ptr)->ctx, hw_ctx_dce110);
+	dm_free(hw_ctx_dce110);
 
 	*ptr = NULL;
 }
@@ -128,7 +128,6 @@ static uint32_t read_indirect_azalia_reg(
 	uint32_t addr = 0;
 	uint32_t value = 0;
 
-
 	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
 	{
 		addr =
@@ -238,7 +237,6 @@ static void set_video_latency(
 	if ((latency_in_ms < 0) || (latency_in_ms > 255))
 		return;
 
-
 	value = read_indirect_azalia_reg(
 		hw_ctx,
 		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
@@ -775,7 +773,6 @@ static void setup_dp_audio(
 	/* --- The following are the registers
 	 *  copied from the SetupHDMI --- */
 
-
 	/* AFMT_AUDIO_PACKET_CONTROL */
 	{
 		addr = mmAFMT_AUDIO_PACKET_CONTROL +
@@ -1269,7 +1266,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
 		value);
 
-
 	value = 0;
 
 	/*get display name string length */
@@ -1287,7 +1283,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
 		value);
 
-
 	/*
 	*write the port ID:
 	*PORT_ID0 = display index
@@ -1340,7 +1335,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
 		value);
 
-
 	value = 0;
 	set_reg_field_value(value, audio_info->display_name[4],
 		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
@@ -1407,7 +1401,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
 		value);
 
-
 	value = 0;
 	set_reg_field_value(value, audio_info->display_name[16],
 		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
@@ -1526,7 +1519,6 @@ static void setup_channel_splitting_mapping(
 	if ((audio_mapping == NULL || audio_mapping->u32all == 0) && enable)
 		return;
 
-
 	value = audio_mapping->u32all;
 
 	if (enable == false)
@@ -1907,7 +1899,7 @@ struct hw_ctx_audio *dal_hw_ctx_audio_dce110_create(
 {
 	/* allocate memory for struc hw_ctx_audio_dce110 */
 	struct hw_ctx_audio_dce110 *hw_ctx_dce110 =
-			dm_alloc(ctx, sizeof(struct hw_ctx_audio_dce110));
+			dm_alloc(sizeof(struct hw_ctx_audio_dce110));
 
 	if (!hw_ctx_dce110) {
 		ASSERT_CRITICAL(hw_ctx_dce110);
@@ -1925,8 +1917,7 @@ struct hw_ctx_audio *dal_hw_ctx_audio_dce110_create(
 		LOG_MINOR_COMPONENT_AUDIO,
 		"Failed to create hw_ctx_audio for DCE11\n");
 
-
-	dm_free(ctx, hw_ctx_dce110);
+	dm_free(hw_ctx_dce110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
index d6f437c..8b9ad02 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
@@ -53,11 +53,10 @@ static void destroy(struct audio **ptr)
 	destruct(audio);
 
 	/* release memory allocated for audio_dce80*/
-	dm_free(audio->base.ctx, audio);
+	dm_free(audio);
 	*ptr = NULL;
 }
 
-
 /* The inital call of hook function comes from audio object level.
  *The passing object handle "struct audio *audio" point to base object
  *already.There is not need to get base object from audio_dce80.
@@ -407,14 +406,13 @@ static bool construct(
 	return true;
 }
 
-
 /* --- audio scope functions  --- */
 
 struct audio *dal_audio_create_dce80(
 	const struct audio_init_data *init_data)
 {
 	/*allocate memory for audio_dce80 */
-	struct audio_dce80 *audio = dm_alloc(init_data->ctx, sizeof(struct audio_dce80));
+	struct audio_dce80 *audio = dm_alloc(sizeof(struct audio_dce80));
 
 	if (audio == NULL)
 		return NULL;
@@ -424,7 +422,7 @@ struct audio *dal_audio_create_dce80(
 		return &audio->base;
 
 	 /*release memory allocated if fail */
-	dm_free(init_data->ctx, audio);
+	dm_free(audio);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
index 4fef455..4779fac 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
@@ -29,7 +29,6 @@
 #include "audio/hw_ctx_audio.h"
 #include "audio/dce80/hw_ctx_audio_dce80.h"
 
-
 struct audio_dce80 {
 	struct audio base;
 	/* dce-specific members are following */
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
index 521ad07..5f6a433 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
@@ -58,7 +58,6 @@ static const uint32_t engine_offset[] = {
 /* static void dal_audio_destruct_hw_ctx_audio_dce80(
 	struct hw_ctx_audio_dce80 *ctx);*/
 
-
 static void destroy(
 	struct hw_ctx_audio **ptr)
 {
@@ -69,13 +68,11 @@ static void destroy(
 
 	dal_audio_destruct_hw_ctx_audio_dce80(hw_ctx_dce80);
 	/* release memory allocated for struct hw_ctx_audio_dce80 */
-	dm_free((*ptr)->ctx, hw_ctx_dce80);
+	dm_free(hw_ctx_dce80);
 
 	*ptr = NULL;
 }
 
-
-
 /* ---  helpers --- */
 
 static void write_indirect_azalia_reg(
@@ -127,7 +124,6 @@ static uint32_t read_indirect_azalia_reg(
 	uint32_t addr = 0;
 	uint32_t value = 0;
 
-
 	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
 	{
 		addr =
@@ -183,8 +179,6 @@ static void set_high_bit_rate_capable(
 		value);
 }
 
-
-
 /* set HBR channnel count */
 /*static void set_hbr_channel_count(
 	const struct hw_ctx_audio *hw_ctx,
@@ -235,7 +229,6 @@ static void set_video_latency(
 	if ((latency_in_ms < 0) || (latency_in_ms > 255))
 		return;
 
-
 	value = read_indirect_azalia_reg(
 		hw_ctx,
 		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
@@ -250,9 +243,6 @@ static void set_video_latency(
 		value);
 }
 
-
-
-
 /* set audio latency in in ms/2+1 */
 static void set_audio_latency(
 	const struct hw_ctx_audio *hw_ctx,
@@ -280,8 +270,6 @@ static void set_audio_latency(
 		value);
 }
 
-
-
 /* enable HW/SW Sync */
 /*static void enable_hw_sw_sync(
 	const struct hw_ctx_audio *hw_ctx)
@@ -293,8 +281,6 @@ static void set_audio_latency(
 	dal_write_reg(mmAZALIA_CYCLIC_BUFFER_SYNC, value.u32All);
 }*/
 
-
-
 /* disable HW/SW Sync */
 /*static void disable_hw_sw_sync(
 	const struct hw_ctx_audio *hw_ctx)
@@ -308,7 +294,6 @@ static void set_audio_latency(
 		mmAZALIA_CYCLIC_BUFFER_SYNC, value.u32All);
 }*/
 
-
 /* update hardware with software's current position in cyclic buffer */
 /*static void update_sw_write_ptr(
 	const struct hw_ctx_audio *hw_ctx,
@@ -324,7 +309,6 @@ static void set_audio_latency(
 		value.u32All);
 }*/
 
-
 /* update Audio/Video association */
 /*static void update_av_association(
 	const struct hw_ctx_audio *hw_ctx,
@@ -335,10 +319,6 @@ static void set_audio_latency(
 
 }*/
 
-
-
-
-
 /* ---  hook functions --- */
 
 static bool get_azalia_clock_info_hdmi(
@@ -353,8 +333,6 @@ static bool get_azalia_clock_info_dp(
 	const struct audio_pll_info *pll_info,
 	struct azalia_clock_info *azalia_clock_info);
 
-
-
 static void setup_audio_wall_dto(
 	const struct hw_ctx_audio *hw_ctx,
 	enum signal_type signal,
@@ -785,7 +763,6 @@ static void setup_dp_audio(
 	/* --- The following are the registers
 	 *  copied from the SetupHDMI --- */
 
-
 	/* AFMT_AUDIO_PACKET_CONTROL */
 	{
 		addr = mmAFMT_AUDIO_PACKET_CONTROL +
@@ -900,7 +877,6 @@ static void enable_azalia_audio(
 		value);
 }
 
-
 /* disable Azalia audio */
 static void disable_azalia_audio(
 	const struct hw_ctx_audio *hw_ctx,
@@ -1218,7 +1194,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
 		value);
 
-
 	value = 0;
 
 	/*get display name string length */
@@ -1236,7 +1211,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
 		value);
 
-
 	/*
 	*write the port ID:
 	*PORT_ID0 = display index
@@ -1289,7 +1263,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
 		value);
 
-
 	value = 0;
 	set_reg_field_value(value, audio_info->display_name[4],
 		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
@@ -1356,7 +1329,6 @@ static void configure_azalia(
 		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
 		value);
 
-
 	value = 0;
 	set_reg_field_value(value, audio_info->display_name[16],
 		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
@@ -1475,7 +1447,6 @@ static void setup_channel_splitting_mapping(
 	if ((audio_mapping == NULL || audio_mapping->u32all == 0) && enable)
 		return;
 
-
 	value = audio_mapping->u32all;
 
 	if (enable == false)
@@ -1726,8 +1697,6 @@ static bool get_azalia_clock_info_hdmi(
 	return true;
 }
 
-
-
 /* search pixel clock value for Azalia DP Audio */
 static bool get_azalia_clock_info_dp(
 	const struct hw_ctx_audio *hw_ctx,
@@ -1888,7 +1857,6 @@ bool dal_audio_construct_hw_ctx_audio_dce80(
 	return true;
 }
 
-
 /* audio_dce80 is derived from audio directly, not via dce80  */
 
 void dal_audio_destruct_hw_ctx_audio_dce80(
@@ -1903,7 +1871,7 @@ struct hw_ctx_audio *dal_audio_create_hw_ctx_audio_dce80(
 {
 	/* allocate memory for struc hw_ctx_audio_dce80 */
 	struct hw_ctx_audio_dce80 *hw_ctx_dce80 =
-			dm_alloc(ctx, sizeof(struct hw_ctx_audio_dce80));
+			dm_alloc(sizeof(struct hw_ctx_audio_dce80));
 
 	if (!hw_ctx_dce80) {
 		BREAK_TO_DEBUGGER();
@@ -1917,10 +1885,8 @@ struct hw_ctx_audio *dal_audio_create_hw_ctx_audio_dce80(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, hw_ctx_dce80);
+	dm_free(hw_ctx_dce80);
 
 	return NULL;
 }
 
-
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h
index 1d0e00d..51b467b 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h
@@ -40,7 +40,6 @@ struct hw_ctx_audio_dce80 {
 	/* audio encoder block MM register offset -- associate with DIG FRONT */
 };
 
-
 /* ---  helpers ---  all static functions*/
 /*set_high_bit_rate_capable
 set_hbr_channel_count
@@ -71,5 +70,3 @@ struct hw_ctx_audio *dal_audio_create_hw_ctx_audio_dce80(
 
 #endif  /* __DAL_HW_CTX_AUDIO_DCE80_H__ */
 
-
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
index 58207f5..6d88771 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
@@ -85,7 +85,6 @@ static const struct audio_clock_info audio_clock_info_table_48bpc[12] = {
 	{14850, 4096, 297000, 6272, 330000, 6144, 297000}
 };
 
-
 /***** static function *****/
 
 /*
@@ -298,17 +297,8 @@ static bool get_azalia_clock_info_dp(
 	return false;
 }
 
-
-
-
-
-
-
-
-
 /*****SCOPE : within audio hw context dal-audio-hw-ctx *****/
 
-
 /* check whether specified sample rates can fit into a given timing */
 void dal_hw_ctx_audio_check_audio_bandwidth(
 	const struct hw_ctx_audio *hw_ctx,
@@ -691,7 +681,6 @@ bool dal_audio_hw_ctx_get_audio_clock_info(
 		}
 	}
 
-
 	/* not found */
 	if (actual_pixel_clock_in_khz == 0)
 		actual_pixel_clock_in_khz = crtc_pixel_clock_in_khz;
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
index 8ab2e58..52865c8 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
@@ -31,7 +31,6 @@
 
 struct hw_ctx_audio;
 
-
 struct azalia_reg_offsets {
 	uint32_t azf0endpointx_azalia_f0_codec_endpoint_index;
 	uint32_t azf0endpointx_azalia_f0_codec_endpoint_data;
@@ -184,7 +183,6 @@ struct hw_ctx_audio_funcs {
 
 };
 
-
 struct hw_ctx_audio {
 	const struct hw_ctx_audio_funcs *funcs;
 	struct dc_context *ctx;
@@ -199,8 +197,6 @@ struct hw_ctx_audio {
 	 */
 };
 
-
-
 /* --- object construct, destruct --- */
 
 /*
@@ -218,14 +214,12 @@ void dal_audio_destruct_hw_ctx_audio(
  *Top base or interface object does not have implementation of creator.
  */
 
-
 /* --- functions called by audio hw context itself --- */
 
 /* MM register access */
 /*read_register  - dal_read_reg */
 /*write_register - dal_write_reg*/
 
-
 /*check whether specified sample rates can fit into a given timing */
 void dal_hw_ctx_audio_check_audio_bandwidth(
 	const struct hw_ctx_audio *hw_ctx,
@@ -280,6 +274,5 @@ bool dal_audio_hw_ctx_get_audio_clock_info(
 	uint32_t actual_pixel_clock_in_khz,
 	struct audio_clock_info *audio_clock_info);
 
-
 #endif  /* __DAL_HW_CTX_AUDIO_H__ */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/conversion.c b/drivers/gpu/drm/amd/dal/dc/basics/conversion.c
index 2f1f3d4..ebe14e1 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/conversion.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/conversion.c
@@ -23,7 +23,6 @@
  *
  */
 
-
 #include "dm_services.h"
 
 #define DIVIDER 10000
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c b/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c
index 74e6d75..911e90b 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/fixpt32_32.c
@@ -137,8 +137,6 @@ struct fixed32_32 dal_fixed32_32_mul_int(struct fixed32_32 lhs, uint32_t rhs)
 	return fx;
 }
 
-
-
 struct fixed32_32 dal_fixed32_32_div(
 	struct fixed32_32 lhs,
 	struct fixed32_32 rhs)
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/logger.c b/drivers/gpu/drm/amd/dal/dc/basics/logger.c
index e7938ec..60c13fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/logger.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/logger.c
@@ -116,7 +116,6 @@ static const struct log_minor_info info_packet_minor_info_tbl[] = {
 	{LOG_MINOR_INFO_PACKETS_HDMI, "Hdmi"},
 };
 
-
 static const struct log_minor_info dsat_minor_info_tbl[] = {
 	{LOG_MINOR_DSAT_LOGGER, "Logger"},
 	{LOG_MINOR_DSAT_EDID_OVERRIDE, "EDID_Override"},
@@ -180,7 +179,6 @@ static const struct log_minor_info backlight_minor_info_tbl[] = {
 	{LOG_MINOR_BACKLIGHT_LID, "Lid Status"}
 };
 
-
 static const struct log_minor_info override_feature_minor_info_tbl[] = {
 	{LOG_MINOR_FEATURE_OVERRIDE, "overriden feature"},
 };
@@ -209,7 +207,6 @@ static const struct log_minor_info ds_minor_info_tbl[] = {
 	{LOG_MINOR_DS_MODE_SETTING, "Mode_Setting"},
 };
 
-
 struct log_major_mask_info {
 	struct log_major_info major_info;
 	uint32_t default_mask;
@@ -231,7 +228,6 @@ struct log_major_mask_info {
 /* IFT - InterFaceTrace */
 #define LG_IFT_MSK (1 << LOG_MINOR_COMPONENT_DC)
 
-
 #define LG_HW_TR_AUD_MSK (1 << LOG_MINOR_HW_TRACE_AUDIO)
 #define LG_HW_TR_INTERRUPT_MSK (1 << LOG_MINOR_HW_TRACE_INTERRUPT) | \
 		(1 << LOG_MINOR_HW_TRACE_HPD_IRQ)
@@ -283,8 +279,7 @@ static bool construct(struct dc_context *ctx, struct dal_logger *logger)
 	/* malloc buffer and init offsets */
 
 	logger->log_buffer_size = DAL_LOGGER_BUFFER_MAX_SIZE;
-	logger->log_buffer = (char *)dm_alloc(ctx,
-		logger->log_buffer_size *
+	logger->log_buffer = (char *)dm_alloc(logger->log_buffer_size *
 		sizeof(char));
 
 	if (!logger->log_buffer)
@@ -307,14 +302,11 @@ static bool construct(struct dc_context *ctx, struct dal_logger *logger)
 
 	/* malloc and init minor mask array */
 	logger->log_enable_mask_minors =
-			(uint32_t *)dm_alloc(
-				ctx,
-				NUM_ELEMENTS(log_major_mask_info_tbl)
+			(uint32_t *)dm_alloc(NUM_ELEMENTS(log_major_mask_info_tbl)
 				* sizeof(uint32_t));
 	if (!logger->log_enable_mask_minors)
 		return false;
 
-
 	/* Set default values for mask */
 	for (i = 0; i < NUM_ELEMENTS(log_major_mask_info_tbl); i++) {
 
@@ -329,12 +321,12 @@ static bool construct(struct dc_context *ctx, struct dal_logger *logger)
 static void destruct(struct dal_logger *logger)
 {
 	if (logger->log_buffer) {
-		dm_free(logger->ctx, logger->log_buffer);
+		dm_free(logger->log_buffer);
 		logger->log_buffer = NULL;
 	}
 
 	if (logger->log_enable_mask_minors) {
-		dm_free(logger->ctx, logger->log_enable_mask_minors);
+		dm_free(logger->log_enable_mask_minors);
 		logger->log_enable_mask_minors = NULL;
 	}
 }
@@ -342,12 +334,12 @@ static void destruct(struct dal_logger *logger)
 struct dal_logger *dal_logger_create(struct dc_context *ctx)
 {
 	/* malloc struct */
-	struct dal_logger *logger = dm_alloc(ctx, sizeof(struct dal_logger));
+	struct dal_logger *logger = dm_alloc(sizeof(struct dal_logger));
 
 	if (!logger)
 		return NULL;
 	if (!construct(ctx, logger)) {
-		dm_free(ctx, logger);
+		dm_free(logger);
 		return NULL;
 	}
 
@@ -359,7 +351,7 @@ uint32_t dal_logger_destroy(struct dal_logger **logger)
 	if (logger == NULL || *logger == NULL)
 		return 1;
 	destruct(*logger);
-	dm_free((*logger)->ctx, *logger);
+	dm_free(*logger);
 	*logger = NULL;
 
 	return 0;
@@ -474,9 +466,6 @@ static void log_to_internal_buffer(struct log_entry *entry)
 			logger->buffer_read_offset = 0;
 		}
 
-
-
-
 		if (space_before_wrap > size) {
 			/* No wrap around, copy 'size' bytes
 			 * from 'entry->buf' to 'log_buffer'
@@ -520,7 +509,6 @@ static void log_to_internal_buffer(struct log_entry *entry)
 	unlock(logger);
 }
 
-
 static void log_timestamp(struct log_entry *entry)
 {
 	dal_logger_append(entry, "00:00:00 ");
@@ -567,7 +555,6 @@ static void log_heading(struct log_entry *entry,
 	log_major_minor(entry);
 }
 
-
 static void append_entry(
 		struct log_entry *entry,
 		char *buffer,
@@ -608,7 +595,6 @@ void dal_logger_write(
 		va_start(args, msg);
 		dal_logger_open(logger, &entry, major, minor);
 
-
 		size = dm_log_to_buffer(
 			buffer, DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE, msg, args);
 
@@ -631,7 +617,6 @@ void dal_logger_write(
 	}
 }
 
-
 /* Same as dal_logger_write, except without open() and close(), which must
  * be done separately.
  */
@@ -671,7 +656,6 @@ void dal_logger_append(
 	}
 }
 
-
 uint32_t dal_logger_read(
 	struct dal_logger *logger, /* <[in] */
 	uint32_t output_buffer_size, /* <[in] */
@@ -763,9 +747,7 @@ void dal_logger_open(
 	entry->minor = 0;
 	entry->logger = logger;
 
-	entry->buf = dm_alloc(
-		logger->ctx,
-		DAL_LOGGER_BUFFER_MAX_SIZE * sizeof(char));
+	entry->buf = dm_alloc(DAL_LOGGER_BUFFER_MAX_SIZE * sizeof(char));
 
 	entry->buf_offset = 0;
 	entry->max_buf_bytes = DAL_LOGGER_BUFFER_MAX_SIZE * sizeof(char);
@@ -781,7 +763,6 @@ void dal_logger_close(struct log_entry *entry)
 {
 	struct dal_logger *logger = entry->logger;
 
-
 	if (logger && logger->open_count > 0) {
 		logger->open_count--;
 	} else {
@@ -799,7 +780,7 @@ void dal_logger_close(struct log_entry *entry)
 
 cleanup:
 	if (entry->buf) {
-		dm_free(entry->logger->ctx, entry->buf);
+		dm_free(entry->buf);
 		entry->buf = NULL;
 		entry->buf_offset = 0;
 		entry->max_buf_bytes = 0;
@@ -888,7 +869,6 @@ void dal_logger_set_flags(
 	logger->flags = flags;
 }
 
-
 uint32_t dal_logger_get_buffer_size(struct dal_logger *logger)
 {
 	return DAL_LOGGER_BUFFER_MAX_SIZE;
@@ -904,7 +884,6 @@ uint32_t dal_logger_set_buffer_size(
 	return DAL_LOGGER_BUFFER_MAX_SIZE;
 }
 
-
 const struct log_major_info *dal_logger_enum_log_major_info(
 		struct dal_logger *logger,
 		unsigned int enum_index)
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/logger.h b/drivers/gpu/drm/amd/dal/dc/basics/logger.h
index fba5ec3..c2aea53 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/logger.h
+++ b/drivers/gpu/drm/amd/dal/dc/basics/logger.h
@@ -31,7 +31,6 @@
 #define DAL_LOGGER_BUFFER_MAX_SIZE 2048
 #define DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE 256
 
-
 #include "include/logger_types.h"
 
 struct dal_logger {
diff --git a/drivers/gpu/drm/amd/dal/dc/basics/vector.c b/drivers/gpu/drm/amd/dal/dc/basics/vector.c
index 32ca6b1..7ad7fef 100644
--- a/drivers/gpu/drm/amd/dal/dc/basics/vector.c
+++ b/drivers/gpu/drm/amd/dal/dc/basics/vector.c
@@ -40,7 +40,7 @@ bool dal_vector_construct(
 		return false;
 	}
 
-	vector->container = dm_alloc(ctx, struct_size * capacity);
+	vector->container = dm_alloc(struct_size * capacity);
 	if (vector->container == NULL)
 		return false;
 	vector->capacity = capacity;
@@ -67,7 +67,7 @@ bool dal_vector_presized_costruct(
 		return false;
 	}
 
-	vector->container = dm_alloc(ctx, struct_size * count);
+	vector->container = dm_alloc(struct_size * count);
 
 	if (vector->container == NULL)
 		return false;
@@ -95,7 +95,7 @@ struct vector *dal_vector_presized_create(
 	void *initial_value,
 	uint32_t struct_size)
 {
-	struct vector *vector = dm_alloc(ctx, sizeof(struct vector));
+	struct vector *vector = dm_alloc(sizeof(struct vector));
 
 	if (vector == NULL)
 		return NULL;
@@ -105,7 +105,7 @@ struct vector *dal_vector_presized_create(
 		return vector;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, vector);
+	dm_free(vector);
 	return NULL;
 }
 
@@ -114,7 +114,7 @@ struct vector *dal_vector_create(
 	uint32_t capacity,
 	uint32_t struct_size)
 {
-	struct vector *vector = dm_alloc(ctx, sizeof(struct vector));
+	struct vector *vector = dm_alloc(sizeof(struct vector));
 
 	if (vector == NULL)
 		return NULL;
@@ -122,9 +122,8 @@ struct vector *dal_vector_create(
 	if (dal_vector_construct(vector, ctx, capacity, struct_size))
 		return vector;
 
-
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, vector);
+	dm_free(vector);
 	return NULL;
 }
 
@@ -132,7 +131,7 @@ void dal_vector_destruct(
 	struct vector *vector)
 {
 	if (vector->container != NULL)
-		dm_free(vector->ctx, vector->container);
+		dm_free(vector->container);
 	vector->count = 0;
 	vector->capacity = 0;
 }
@@ -143,7 +142,7 @@ void dal_vector_destroy(
 	if (vector == NULL || *vector == NULL)
 		return;
 	dal_vector_destruct(*vector);
-	dm_free((*vector)->ctx, *vector);
+	dm_free(*vector);
 	*vector = NULL;
 }
 
@@ -291,8 +290,7 @@ bool dal_vector_reserve(struct vector *vector, uint32_t capacity)
 	if (capacity <= vector->capacity)
 		return true;
 
-	new_container = dm_realloc(vector->ctx, vector->container,
-		capacity * vector->struct_size);
+	new_container = dm_realloc(vector->container, capacity * vector->struct_size);
 
 	if (new_container) {
 		vector->container = new_container;
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
index 586a5ee..f433f8e 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
@@ -96,7 +96,6 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 	ATOM_OBJECT *object);
 static void process_ext_display_connection_info(struct bios_parser *bp);
 
-
 #define BIOS_IMAGE_SIZE_OFFSET 2
 #define BIOS_IMAGE_SIZE_UNIT 512
 
@@ -120,14 +119,14 @@ struct dc_bios *dal_bios_parser_create(
 {
 	struct bios_parser *bp = NULL;
 
-	bp = dm_alloc(init->ctx, sizeof(struct bios_parser));
+	bp = dm_alloc(sizeof(struct bios_parser));
 	if (!bp)
 		return NULL;
 
 	if (bios_parser_construct(bp, init, as))
 		return &bp->base;
 
-	dm_free(init->ctx, bp);
+	dm_free(bp);
 	BREAK_TO_DEBUGGER();
 	return NULL;
 }
@@ -135,7 +134,7 @@ struct dc_bios *dal_bios_parser_create(
 static void destruct(struct bios_parser *bp)
 {
 	if (bp->bios_local_image)
-		dm_free(bp->ctx, bp->bios_local_image);
+		dm_free(bp->bios_local_image);
 }
 
 void dal_bios_parser_destroy(struct dc_bios **dcb)
@@ -149,7 +148,7 @@ void dal_bios_parser_destroy(struct dc_bios **dcb)
 
 	destruct(bp);
 
-	dm_free((bp)->ctx, bp);
+	dm_free(bp);
 	*dcb = NULL;
 }
 
@@ -563,7 +562,6 @@ static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
 		result = bios_parser_get_thermal_ddc_info(dcb,
 			i2c_line, info);
 
-
 	return result;
 }
 
@@ -1528,7 +1526,6 @@ static ATOM_I2C_RECORD *get_i2c_record(
 	return NULL;
 }
 
-
 static enum bp_result get_ss_info_from_ss_info_table(
 	struct bios_parser *bp,
 	uint32_t id,
@@ -2312,7 +2309,6 @@ static uint32_t bios_parser_get_ss_entry_number(
 	return 0;
 }
 
-
 /**
  * get_ss_entry_number_from_ss_info_tbl
  * Get Number of spread spectrum entry from the SS_Info table from the VBIOS.
@@ -2381,7 +2377,6 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 	return number;
 }
 
-
 /**
  * get_ss_entry_number
  * Get spread sprectrum information from the ASIC_InternalSS_Info Ver 2.1 or
@@ -4089,7 +4084,7 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 		uint8_t *original_bios;
 		/* Step 1: Replace bios image with the new copy which will be
 		 * patched */
-		bp->bios_local_image = dm_alloc(bp->ctx, bp->bios_size);
+		bp->bios_local_image = dm_alloc(bp->bios_size);
 		if (bp->bios_local_image == NULL) {
 			BREAK_TO_DEBUGGER();
 			/* Failed to alloc bp->bios_local_image */
@@ -4667,14 +4662,13 @@ static enum bp_result construct_integrated_info(
 	return result;
 }
 
-
 static struct integrated_info *bios_parser_create_integrated_info(
 	struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct integrated_info *info = NULL;
 
-	info = dm_alloc(bp->ctx, sizeof(struct integrated_info));
+	info = dm_alloc(sizeof(struct integrated_info));
 
 	if (info == NULL) {
 		ASSERT_CRITICAL(0);
@@ -4684,7 +4678,7 @@ static struct integrated_info *bios_parser_create_integrated_info(
 	if (construct_integrated_info(bp, info) == BP_RESULT_OK)
 		return info;
 
-	dm_free(bp->ctx, info);
+	dm_free(info);
 
 	return NULL;
 }
@@ -4693,15 +4687,13 @@ static void bios_parser_destroy_integrated_info(
 	struct dc_bios *dcb,
 	struct integrated_info **info)
 {
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
 	if (info == NULL) {
 		ASSERT_CRITICAL(0);
 		return;
 	}
 
 	if (*info != NULL) {
-		dm_free(bp->ctx, *info);
+		dm_free(*info);
 		*info = NULL;
 	}
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
index 3bc52f5..2ea0576 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
@@ -47,7 +47,6 @@
 	dm_bios_cmd_table_para_revision(bp->ctx, \
 		GetIndexIntoMasterTable(COMMAND, command))
 
-
 static void init_dig_encoder_control(struct bios_parser *bp);
 static void init_transmitter_control(struct bios_parser *bp);
 static void init_set_pixel_clock(struct bios_parser *bp);
@@ -268,7 +267,6 @@ static enum bp_result encoder_control_digx_v4(
 	else
 		params.acConfig.ucDPLinkRate = 0; /* single link 1.62GHz */
 
-
 	params.acConfig.ucDigSel = (uint8_t)(cntl->engine_id);
 
 	/* We need to convert from KHz units into 10KHz units */
@@ -1907,7 +1905,6 @@ static enum bp_result set_crtc_timing_v1(
 	params.usV_SyncWidth =
 			cpu_to_le16((uint16_t)(bp_params->v_sync_width));
 
-
 	/* VBIOS does not expect any value except zero into this call, for
 	 * underscan use another entry ProgramOverscan call but when mode
 	 * 1776x1000 with the overscan 72x44 .e.i. 1920x1080 @30 DAL2 is ok,
@@ -2006,7 +2003,6 @@ static enum bp_result set_crtc_using_dtd_timing_v3(
 		params.susModeMiscInfo.usAccess =
 				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);
 
-
 	if (bp_params->flags.INTERLACE)	{
 		params.susModeMiscInfo.usAccess =
 				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);
@@ -2652,7 +2648,6 @@ static enum bp_result enable_disp_power_gating_v2_1(
 	return result;
 }
 
-
 /*******************************************************************************
  ********************************************************************************
  **
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c b/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c
index 614ba94..092c0f6 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce110/command_table_helper_dce110.c
@@ -65,7 +65,6 @@ static uint8_t phy_id_to_atom(enum transmitter t)
 	return atom_phy_id;
 }
 
-
 static uint8_t signal_type_to_atom_dig_mode(enum signal_type s)
 {
 	uint8_t atom_dig_mode = ATOM_TRANSMITTER_DIGMODE_V5_DP;
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c b/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c
index 541a8c4..b6ee5bf 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c
@@ -38,7 +38,6 @@
 
 #include "../bios_parser_helper.h"
 
-
 static const uint8_t bios_scratch0_dacb_shift = 8;
 
 /**
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
index 2b69536..ca17b25 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
@@ -3601,7 +3601,6 @@ void bw_calcs_init(struct bw_calcs_dceip *bw_dceip,
 	vbios.blackout_duration = bw_int_to_fixed(18); /* us */
 	vbios.maximum_blackout_recovery_time = bw_int_to_fixed(20);
 
-
 	dceip.dmif_request_buffer_size = bw_int_to_fixed(768);
 	dceip.de_tiling_buffer = bw_int_to_fixed(0);
 	dceip.dcfclk_request_generation = 0;
@@ -3703,10 +3702,9 @@ bool bw_calcs(struct dc_context *ctx, const struct bw_calcs_dceip *dceip,
 	const struct bw_calcs_mode_data *mode_data,
 	struct bw_calcs_output *calcs_output)
 {
-	struct bw_calcs_results *bw_results_internal = dm_alloc(
-				ctx, sizeof(struct bw_calcs_results));
+	struct bw_calcs_results *bw_results_internal = dm_alloc(sizeof(struct bw_calcs_results));
 	struct bw_calcs_mode_data_internal *bw_data_internal =
-		dm_alloc(ctx, sizeof(struct bw_calcs_mode_data_internal));
+		dm_alloc(sizeof(struct bw_calcs_mode_data_internal));
 
 	switch (mode_data->number_of_displays) {
 	case (6):
@@ -3941,8 +3939,8 @@ bool bw_calcs(struct dc_context *ctx, const struct bw_calcs_dceip *dceip,
 		calcs_output->required_sclk = 0;
 	}
 
-	dm_free(ctx, bw_data_internal);
-	dm_free(ctx, bw_results_internal);
+	dm_free(bw_data_internal);
+	dm_free(bw_results_internal);
 
 	return is_display_configuration_supported(vbios, calcs_output);
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c b/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c
index 8a7a4c9..edb109e 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/bw_fixed.c
@@ -25,7 +25,6 @@
 #include "dm_services.h"
 #include "bw_fixed.h"
 
-
 #define BITS_PER_FRACTIONAL_PART 24
 
 #define MIN_I32 \
@@ -40,7 +39,6 @@
 #define MAX_I64 \
 	(int64_t)((1ULL << 63) - 1)
 
-
 #define FRACTIONAL_PART_MASK \
 	((1ULL << BITS_PER_FRACTIONAL_PART) - 1)
 
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/gamma_calcs.c b/drivers/gpu/drm/amd/dal/dc/calcs/gamma_calcs.c
index 6f0f64a..9c18bda 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/gamma_calcs.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/gamma_calcs.c
@@ -185,7 +185,6 @@ static bool setup_custom_float(
 	return true;
 }
 
-
 static bool convert_to_custom_float_format_ex(
 	struct fixed31_32 value,
 	const struct custom_float_format *format,
@@ -432,7 +431,6 @@ struct dividers {
 	struct fixed31_32 divider3;
 };
 
-
 static void build_regamma_coefficients(struct gamma_coefficients *coefficients)
 {
 	/* sRGB should apply 2.4 */
@@ -1338,4 +1336,3 @@ void calculate_regamma_params(struct pwl_params *params,
 			params->hw_points_num);
 }
 
-
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c b/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
index 64ca203..706bf0a 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
@@ -1099,9 +1099,7 @@ static bool allocate_3d_storage(
 	int32_t indexof_table = 0;
 	int32_t indexof_row = 0;
 
-	struct fixed31_32 ***tables = dm_alloc(
-		ctx,
-		numberof_tables * sizeof(struct fixed31_32 **));
+	struct fixed31_32 ***tables = dm_alloc(numberof_tables * sizeof(struct fixed31_32 **));
 
 	if (!tables) {
 		BREAK_TO_DEBUGGER();
@@ -1109,9 +1107,7 @@ static bool allocate_3d_storage(
 	}
 
 	while (indexof_table != numberof_tables) {
-		struct fixed31_32 **rows = dm_alloc(
-			ctx,
-			numberof_rows * sizeof(struct fixed31_32 *));
+		struct fixed31_32 **rows = dm_alloc(numberof_rows * sizeof(struct fixed31_32 *));
 
 		if (!rows) {
 			BREAK_TO_DEBUGGER();
@@ -1122,9 +1118,7 @@ static bool allocate_3d_storage(
 		tables[indexof_table] = rows;
 
 		while (indexof_row != numberof_rows) {
-			struct fixed31_32 *columns = dm_alloc(
-				ctx,
-				numberof_columns * sizeof(struct fixed31_32));
+			struct fixed31_32 *columns = dm_alloc(numberof_columns * sizeof(struct fixed31_32));
 
 			if (!columns) {
 				BREAK_TO_DEBUGGER();
@@ -1150,19 +1144,19 @@ failure:
 
 	while (indexof_table >= 0) {
 		while (indexof_row >= 0) {
-			dm_free(ctx, tables[indexof_table][indexof_row]);
+			dm_free(tables[indexof_table][indexof_row]);
 
 			--indexof_row;
 		}
 
 		indexof_row = numberof_rows - 1;
 
-		dm_free(ctx, tables[indexof_table]);
+		dm_free(tables[indexof_table]);
 
 		--indexof_table;
 	}
 
-	dm_free(ctx, tables);
+	dm_free(tables);
 
 	return false;
 }
@@ -1184,18 +1178,17 @@ static void destroy_3d_storage(
 		uint32_t indexof_row = 0;
 
 		while (indexof_row != numberof_rows) {
-			dm_free(
-				ctx, tables[indexof_table][indexof_row]);
+			dm_free(tables[indexof_table][indexof_row]);
 
 			++indexof_row;
 		};
 
-		dm_free(ctx, tables[indexof_table]);
+		dm_free(tables[indexof_table]);
 
 		++indexof_table;
 	};
 
-	dm_free(ctx, tables);
+	dm_free(tables);
 
 	*ptr = NULL;
 }
@@ -1627,15 +1620,13 @@ static bool generate_filter(
 
 	if (filter->coefficients_quantity < coefficients_quantity) {
 		if (filter->coefficients) {
-			dm_free(filter->ctx, filter->coefficients);
+			dm_free(filter->coefficients);
 
 			filter->coefficients = NULL;
 			filter->coefficients_quantity = 0;
 		}
 
-		filter->coefficients = dm_alloc(
-			filter->ctx,
-			coefficients_quantity * sizeof(struct fixed31_32));
+		filter->coefficients = dm_alloc(coefficients_quantity * sizeof(struct fixed31_32));
 
 		if (!filter->coefficients) {
 			BREAK_TO_DEBUGGER();
@@ -1655,15 +1646,13 @@ static bool generate_filter(
 
 	if (filter->coefficients_sum_quantity < coefficients_sum_quantity) {
 		if (filter->coefficients_sum) {
-			dm_free(filter->ctx, filter->coefficients_sum);
+			dm_free(filter->coefficients_sum);
 
 			filter->coefficients_sum = NULL;
 			filter->coefficients_sum_quantity = 0;
 		}
 
-		filter->coefficients_sum = dm_alloc(
-			filter->ctx,
-			coefficients_sum_quantity * sizeof(struct fixed31_32));
+		filter->coefficients_sum = dm_alloc(coefficients_sum_quantity * sizeof(struct fixed31_32));
 
 		if (!filter->coefficients_sum) {
 			BREAK_TO_DEBUGGER();
@@ -1831,16 +1820,16 @@ static void destruct_scaler_filter(
 	struct scaler_filter *filter)
 {
 	if (filter->coefficients_sum)
-		dm_free(filter->ctx, filter->coefficients_sum);
+		dm_free(filter->coefficients_sum);
 
 	if (filter->coefficients)
-		dm_free(filter->ctx, filter->coefficients);
+		dm_free(filter->coefficients);
 
 	if (filter->integer_filter)
-		dm_free(filter->ctx, filter->integer_filter);
+		dm_free(filter->integer_filter);
 
 	if (filter->filter)
-		dm_free(filter->ctx, filter->filter);
+		dm_free(filter->filter);
 
 	destroy_upscaling_table(filter);
 
@@ -1850,7 +1839,7 @@ static void destruct_scaler_filter(
 struct scaler_filter *dal_scaler_filter_create(struct dc_context *ctx)
 {
 	struct scaler_filter *filter =
-		dm_alloc(ctx, sizeof(struct scaler_filter));
+		dm_alloc(sizeof(struct scaler_filter));
 
 	if (!filter) {
 		BREAK_TO_DEBUGGER();
@@ -1862,7 +1851,7 @@ struct scaler_filter *dal_scaler_filter_create(struct dc_context *ctx)
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, filter);
+	dm_free(filter);
 
 	return NULL;
 }
@@ -1902,15 +1891,13 @@ bool dal_scaler_filter_generate(
 
 	if (filter_size_required > filter->filter_size_allocated) {
 		if (filter->filter) {
-			dm_free(filter->ctx, filter->filter);
+			dm_free(filter->filter);
 
 			filter->filter = 0;
 			filter->filter_size_allocated = 0;
 		}
 
-		filter->filter = dm_alloc(
-			filter->ctx,
-			filter_size_required * sizeof(struct fixed31_32));
+		filter->filter = dm_alloc(filter_size_required * sizeof(struct fixed31_32));
 
 		if (!filter->filter) {
 			BREAK_TO_DEBUGGER();
@@ -1918,14 +1905,12 @@ bool dal_scaler_filter_generate(
 		}
 
 		if (filter->integer_filter) {
-			dm_free(filter->ctx, filter->integer_filter);
+			dm_free(filter->integer_filter);
 
 			filter->integer_filter = 0;
 		}
 
-		filter->integer_filter = dm_alloc(
-			filter->ctx,
-			filter_size_required * sizeof(uint32_t));
+		filter->integer_filter = dm_alloc(filter_size_required * sizeof(uint32_t));
 
 		if (!filter->integer_filter) {
 			BREAK_TO_DEBUGGER();
@@ -1986,7 +1971,7 @@ void dal_scaler_filter_destroy(
 
 	destruct_scaler_filter(*filter);
 
-	dm_free((*filter)->ctx, *filter);
+	dm_free(*filter);
 
 	*filter = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 69489f7..44f43ea 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -121,9 +121,7 @@ static bool create_links(struct core_dc *dc, const struct dc_init_data *init_par
 	}
 
 	for (i = 0; i < init_params->num_virtual_links; i++) {
-		struct core_link *link = dm_alloc(
-			dc->ctx,
-			sizeof(*link));
+		struct core_link *link = dm_alloc(sizeof(*link));
 		struct encoder_init_data enc_init = {0};
 
 		if (link == NULL) {
@@ -138,9 +136,7 @@ static bool create_links(struct core_dc *dc, const struct dc_init_data *init_par
 		link->link_id.type = OBJECT_TYPE_CONNECTOR;
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
-		link->link_enc = dm_alloc(
-			dc->ctx,
-			sizeof(*link->link_enc));
+		link->link_enc = dm_alloc(sizeof(*link->link_enc));
 
 		enc_init.adapter_service = init_params->adapter_srv;
 		enc_init.ctx = init_params->ctx;
@@ -164,7 +160,6 @@ failed_alloc:
 	return false;
 }
 
-
 static void init_hw(struct core_dc *dc)
 {
 	int i;
@@ -318,7 +313,7 @@ static bool construct(struct core_dc *dc, const struct dal_init_data *init_param
 	ctx.cgs_device = init_params->cgs_device;
 	ctx.dc = dc;
 
-	dc_init_data.ctx = dm_alloc(&ctx, sizeof(*dc_init_data.ctx));
+	dc_init_data.ctx = dm_alloc(sizeof(*dc_init_data.ctx));
 	if (!dc_init_data.ctx) {
 		dm_error("%s: failed to create ctx\n", __func__);
 		goto ctx_fail;
@@ -384,7 +379,7 @@ as_fail:
 	dal_logger_destroy(&dc_init_data.ctx->logger);
 logger_fail:
 hwss_fail:
-	dm_free(&ctx, dc_init_data.ctx);
+	dm_free(dc_init_data.ctx);
 ctx_fail:
 	return false;
 }
@@ -395,7 +390,7 @@ static void destruct(struct core_dc *dc)
 	destroy_links(dc);
 	dc->res_pool.funcs->destruct(&dc->res_pool);
 	dal_logger_destroy(&dc->ctx->logger);
-	dm_free(dc->ctx, dc->ctx);
+	dm_free(dc->ctx);
 }
 
 /*
@@ -474,7 +469,7 @@ struct core_dc *dc_create(const struct dal_init_data *init_params)
 		.driver_context = init_params->driver,
 		.cgs_device = init_params->cgs_device
 	};
-	struct core_dc *dc = dm_alloc(&ctx, sizeof(*dc));
+	struct core_dc *dc = dm_alloc(sizeof(*dc));
 
 	if (NULL == dc)
 		goto alloc_fail;
@@ -489,7 +484,7 @@ struct core_dc *dc_create(const struct dal_init_data *init_params)
 	return dc;
 
 construct_fail:
-	dm_free(&ctx, dc);
+	dm_free(dc);
 
 alloc_fail:
 	return NULL;
@@ -497,9 +492,8 @@ alloc_fail:
 
 void dc_destroy(struct core_dc **dc)
 {
-	struct dc_context ctx = *((*dc)->ctx);
 	destruct(*dc);
-	dm_free(&ctx, *dc);
+	dm_free(*dc);
 	*dc = NULL;
 }
 
@@ -511,7 +505,7 @@ bool dc_validate_resources(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
-	context = dm_alloc(dc->ctx, sizeof(struct validate_context));
+	context = dm_alloc(sizeof(struct validate_context));
 	if(context == NULL)
 		goto context_alloc_fail;
 
@@ -519,7 +513,7 @@ bool dc_validate_resources(
 						dc, set, set_count, context);
 
 	val_ctx_destruct(context);
-	dm_free(dc->ctx, context);
+	dm_free(context);
 context_alloc_fail:
 
 	return (result == DC_OK);
@@ -668,7 +662,7 @@ bool dc_commit_targets(
 
 	}
 
-	context = dm_alloc(dc->ctx, sizeof(struct validate_context));
+	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
 
@@ -714,7 +708,7 @@ bool dc_commit_targets(
 	dc->current_context = *context;
 
 fail:
-	dm_free(dc->ctx, context);
+	dm_free(context);
 
 context_alloc_fail:
 	return (result == DC_OK);
@@ -736,7 +730,7 @@ bool dc_commit_surfaces_to_target(
 	int new_enabled_surface_count = 0;
 	bool is_mpo_turning_on = false;
 
-	context = dm_alloc(dc->ctx, sizeof(struct validate_context));
+	context = dm_alloc(sizeof(struct validate_context));
 
 	val_ctx_copy_construct(&dc->current_context, context);
 
@@ -866,14 +860,14 @@ bool dc_commit_surfaces_to_target(
 
 	val_ctx_destruct(&dc->current_context);
 	dc->current_context = *context;
-	dm_free(dc->ctx, context);
+	dm_free(context);
 	return true;
 
 unexpected_fail:
 
 	val_ctx_destruct(context);
 
-	dm_free(dc->ctx, context);
+	dm_free(context);
 	return false;
 }
 
@@ -951,7 +945,6 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 	return dal_irq_service_to_irq_source(dc->res_pool.irqs, src_id, ext_id);
 }
 
-
 void dc_interrupt_set(const struct core_dc *dc, enum dc_irq_source src, bool enable)
 {
 	dal_irq_service_set(dc->res_pool.irqs, src, enable);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 36b1661..e259509 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -39,13 +39,11 @@
 #include "hw_sequencer.h"
 #include "fixed31_32.h"
 
-
 #define LINK_INFO(...) \
 	dal_logger_write(dc_ctx->logger, \
 		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_HOTPLUG, \
 		__VA_ARGS__)
 
-
 /*******************************************************************************
  * Private structures
  ******************************************************************************/
@@ -172,13 +170,11 @@ hpd_gpio_failure:
 	return false;
 }
 
-
 enum ddc_transaction_type get_ddc_transaction_type(
 		enum signal_type sink_signal)
 {
 	enum ddc_transaction_type transaction_type = DDC_TRANSACTION_TYPE_NONE;
 
-
 	switch (sink_signal) {
 	case SIGNAL_TYPE_DVI_SINGLE_LINK:
 	case SIGNAL_TYPE_DVI_DUAL_LINK:
@@ -204,7 +200,6 @@ enum ddc_transaction_type get_ddc_transaction_type(
 		break;
 	}
 
-
 	return transaction_type;
 }
 
@@ -636,7 +631,6 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 			else
 				link->dpcd_sink_count = 1;
 
-
 		dal_ddc_service_set_transaction_type(
 						link->ddc,
 						sink_caps.transaction_type);
@@ -1063,7 +1057,7 @@ create_fail:
 struct core_link *link_create(const struct link_init_data *init_params)
 {
 	struct core_link *link =
-			dm_alloc(init_params->ctx, sizeof(*link));
+			dm_alloc(sizeof(*link));
 
 	if (NULL == link)
 		goto alloc_fail;
@@ -1074,7 +1068,7 @@ struct core_link *link_create(const struct link_init_data *init_params)
 	return link;
 
 construct_fail:
-	dm_free(init_params->ctx, link);
+	dm_free(link);
 
 alloc_fail:
 	return NULL;
@@ -1083,7 +1077,7 @@ alloc_fail:
 void link_destroy(struct core_link **link)
 {
 	destruct(*link);
-	dm_free((*link)->ctx, *link);
+	dm_free(*link);
 	*link = NULL;
 }
 
@@ -1530,8 +1524,6 @@ static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 	pbn = get_pbn_from_timing(pipe_ctx);
 	avg_time_slots_per_mtp = dal_fixed31_32_div(pbn, pbn_per_slot);
 
-
-
 	stream_encoder->funcs->set_mst_bandwidth(
 		stream_encoder,
 		avg_time_slots_per_mtp);
@@ -1647,4 +1639,3 @@ void core_link_disable_stream(struct pipe_ctx *pipe_ctx)
 	disable_link(pipe_ctx->stream->sink->link, pipe_ctx->signal);
 }
 
-
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
index f725da7..f211408 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_ddc.c
@@ -95,7 +95,6 @@ enum edid_read_result {
 #define HDMI_SCDC_ERR_DETECT 0x50
 #define HDMI_SCDC_TEST_CONFIG 0xC0
 
-
 union hdmi_scdc_update_read_data {
 	uint8_t byte[2];
 	struct {
@@ -143,8 +142,6 @@ union hdmi_scdc_test_config_Data {
 	} fields;
 };
 
-
-
 struct i2c_payloads {
 	struct vector payloads;
 };
@@ -157,7 +154,7 @@ struct i2c_payloads *dal_ddc_i2c_payloads_create(struct dc_context *ctx, uint32_
 {
 	struct i2c_payloads *payloads;
 
-	payloads = dm_alloc(ctx, sizeof(struct i2c_payloads));
+	payloads = dm_alloc(sizeof(struct i2c_payloads));
 
 	if (!payloads)
 		return NULL;
@@ -166,7 +163,7 @@ struct i2c_payloads *dal_ddc_i2c_payloads_create(struct dc_context *ctx, uint32_
 		&payloads->payloads, ctx, count, sizeof(struct i2c_payload)))
 		return payloads;
 
-	dm_free(ctx, payloads);
+	dm_free(payloads);
 	return NULL;
 
 }
@@ -186,7 +183,7 @@ void dal_ddc_i2c_payloads_destroy(struct i2c_payloads **p)
 	if (!p || !*p)
 		return;
 	dal_vector_destruct(&(*p)->payloads);
-	dm_free((*p)->payloads.ctx, *p);
+	dm_free(*p);
 	*p = NULL;
 
 }
@@ -195,7 +192,7 @@ struct aux_payloads *dal_ddc_aux_payloads_create(struct dc_context *ctx, uint32_
 {
 	struct aux_payloads *payloads;
 
-	payloads = dm_alloc(ctx, sizeof(struct aux_payloads));
+	payloads = dm_alloc(sizeof(struct aux_payloads));
 
 	if (!payloads)
 		return NULL;
@@ -204,7 +201,7 @@ struct aux_payloads *dal_ddc_aux_payloads_create(struct dc_context *ctx, uint32_
 		&payloads->payloads, ctx, count, sizeof(struct aux_payloads)))
 		return payloads;
 
-	dm_free(ctx, payloads);
+	dm_free(payloads);
 	return NULL;
 }
 
@@ -218,14 +215,13 @@ uint32_t  dal_ddc_aux_payloads_get_count(struct aux_payloads *p)
 	return p->payloads.count;
 }
 
-
 void dal_ddc_aux_payloads_destroy(struct aux_payloads **p)
 {
 	if (!p || !*p)
 		return;
 
 	dal_vector_destruct(&(*p)->payloads);
-	dm_free((*p)->payloads.ctx, *p);
+	dm_free(*p);
 	*p = NULL;
 }
 
@@ -273,7 +269,6 @@ void dal_ddc_aux_payloads_add(
 	}
 }
 
-
 static bool construct(
 	struct ddc_service *ddc_service,
 	struct ddc_service_init_data *init_data)
@@ -297,7 +292,6 @@ static bool construct(
 			dal_adapter_service_is_feature_supported(
 				FEATURE_EDID_STRESS_READ);
 
-
 	ddc_service->flags.IS_INTERNAL_DISPLAY =
 		connector_id == CONNECTOR_ID_EDP ||
 		connector_id == CONNECTOR_ID_LVDS;
@@ -311,7 +305,7 @@ struct ddc_service *dal_ddc_service_create(
 {
 	struct ddc_service *ddc_service;
 
-	ddc_service = dm_alloc(init_data->ctx, sizeof(struct ddc_service));
+	ddc_service = dm_alloc(sizeof(struct ddc_service));
 
 	if (!ddc_service)
 		return NULL;
@@ -319,7 +313,7 @@ struct ddc_service *dal_ddc_service_create(
 	if (construct(ddc_service, init_data))
 		return ddc_service;
 
-	dm_free(init_data->ctx, ddc_service);
+	dm_free(ddc_service);
 	return NULL;
 }
 
@@ -336,7 +330,7 @@ void dal_ddc_service_destroy(struct ddc_service **ddc)
 		return;
 	}
 	destruct(*ddc);
-	dm_free((*ddc)->ctx, *ddc);
+	dm_free(*ddc);
 	*ddc = NULL;
 }
 
@@ -1055,7 +1049,6 @@ struct ddc *dal_ddc_service_get_ddc_pin(struct ddc_service *ddc_service)
 	return ddc_service->ddc_pin;
 }
 
-
 void dal_ddc_service_reset_dp_receiver_id_info(struct ddc_service *ddc_service)
 {
 	dm_memset(&ddc_service->dp_receiver_id_info,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
index 92d44aa..31f8ce3 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
@@ -119,7 +119,6 @@ static void dpcd_set_link_settings(
 	union lane_count_set lane_count_set = {{0}};
 	uint8_t link_set_buffer[2];
 
-
 	downspread.raw = (uint8_t)
 	(lt_settings->link_settings.link_spread);
 
@@ -219,7 +218,6 @@ static void dpcd_set_lt_pattern_and_lane_settings(
 		DPCD_ADDRESS_TRAINING_PATTERN_SET,
 		dpcd_pattern.v1_4.TRAINING_PATTERN_SET);
 
-
 	/*****************************************************************
 	* DpcdAddress_Lane0Set -> DpcdAddress_Lane3Set
 	*****************************************************************/
@@ -261,7 +259,6 @@ static void dpcd_set_lt_pattern_and_lane_settings(
 		dpcd_lane[0].bits.MAX_SWING_REACHED,
 		dpcd_lane[0].bits.MAX_PRE_EMPHASIS_REACHED);
 
-
 	if (edp_workaround) {
 		/* for eDP write in 2 parts because the 5-byte burst is
 		* causing issues on some eDP panels (EPR#366724)
@@ -390,7 +387,6 @@ static void find_max_drive_settings(
 			link_training_setting->
 			lane_settings[lane].VOLTAGE_SWING;
 
-
 		if (link_training_setting->lane_settings[lane].PRE_EMPHASIS >
 				max_requested.PRE_EMPHASIS)
 			max_requested.PRE_EMPHASIS =
@@ -479,7 +475,6 @@ static void get_lane_status_and_drive_settings(
 		(uint8_t *)(dpcd_buf),
 		sizeof(dpcd_buf));
 
-
 	for (lane = 0; lane <
 		(uint32_t)(link_training_setting->link_settings.lane_count);
 		lane++) {
@@ -875,7 +870,6 @@ static bool perform_clock_recovery_sequence(
 					link,
 					lt_settings);
 
-
 		/* 3. wait receiver to lock-on*/
 		wait_for_training_aux_rd_interval(
 				link,
@@ -891,7 +885,6 @@ static bool perform_clock_recovery_sequence(
 				&dpcd_lane_status_updated,
 				&req_settings);
 
-
 		/* 5. check CR done*/
 		if (is_cr_done(lane_count, dpcd_lane_status))
 			return true;
@@ -909,7 +902,6 @@ static bool perform_clock_recovery_sequence(
 		else
 			retries_cr = 0;
 
-
 			/* 8. update VS/PE/PC2 in lt_settings*/
 			update_drive_settings(lt_settings, req_settings);
 
@@ -1125,7 +1117,7 @@ static enum clock_source_id get_clock_source_id_for_link_training(
 	set.surface_count = 0;
 	set.target = target;
 
-	context = dm_alloc(link->ctx, sizeof(struct validate_context));
+	context = dm_alloc(sizeof(struct validate_context));
 
 	if (!context)
 		goto fail_context;
@@ -1139,7 +1131,7 @@ static enum clock_source_id get_clock_source_id_for_link_training(
 	if (result)
 		id = context->res_ctx.pipe_ctx[0].clock_source->id;
 
-	dm_free(link->ctx, context);
+	dm_free(context);
 fail_context:
 	dc_target_release(target);
 fail_target:
@@ -1575,7 +1567,6 @@ bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link)
 		hpd_irq_dpcd_data.bytes.device_service_irq.bits.UP_REQ_MSG_RDY)
 		return false;
 
-
 	/* For now we only handle 'Downstream port status' case. */
 	/* If we got sink count changed it means Downstream port status changed,
 	 * then DM should call DC to do the detection. */
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
index 3f05723..63ff4b0 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
@@ -12,7 +12,6 @@
 #include "dce110/dce110_link_encoder.h"
 #include "dce110/dce110_stream_encoder.h"
 
-
 enum dc_status core_link_read_dpcd(
 	struct core_link* link,
 	uint32_t address,
@@ -131,7 +130,6 @@ bool dp_set_hw_training_pattern(
 	return true;
 }
 
-
 void dp_set_hw_lane_settings(
 	struct core_link *link,
 	const struct link_training_settings *link_settings)
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 013612a..e397751 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -80,7 +80,6 @@ void unreference_clock_source(
 		}
 	}
 
-
 }
 
 void reference_clock_source(
@@ -186,7 +185,6 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 		dal_pixel_format = PIXEL_FORMAT_FP16;
 		break;
 
-
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 		dal_pixel_format = PIXEL_FORMAT_420BPP12;
 		break;
@@ -248,7 +246,6 @@ static void calculate_overscan(
 						pipe_ctx->scl_data.ratios.horz)) -
 						pipe_ctx->scl_data.overscan.left;
 
-
 	pipe_ctx->scl_data.overscan.top = stream->public.dst.y;
 	if (stream->public.src.y < surface->clip_rect.y)
 		pipe_ctx->scl_data.overscan.top += (surface->clip_rect.y
@@ -266,7 +263,6 @@ static void calculate_overscan(
 						pipe_ctx->scl_data.ratios.vert)) -
 						pipe_ctx->scl_data.overscan.top;
 
-
 	/* TODO: Add timing overscan to finalize overscan calculation*/
 }
 
@@ -406,7 +402,6 @@ bool attach_surfaces_to_context(
 		return false;
 	}
 
-
 	/* retain new surfaces */
 	for (i = 0; i < surface_count; i++)
 		dc_surface_retain(surfaces[i]);
@@ -1011,7 +1006,6 @@ static void set_avi_info_frame(
 	info_frame.avi_info_packet.info_packet_hdmi.bits.Y0_Y1_Y2 =
 		pixel_encoding;
 
-
 	/* A0 = 1 Active Format Information valid */
 	info_frame.avi_info_packet.info_packet_hdmi.bits.A0 =
 		ACTIVE_FORMAT_VALID;
@@ -1039,7 +1033,6 @@ static void set_avi_info_frame(
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_NO_DATA;
 
-
 	/* TODO: un-hardcode aspect ratio */
 	aspect = stream->public.timing.aspect_ratio;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c b/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c
index c5a770e..67ae799 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_sink.c
@@ -76,22 +76,19 @@ void dc_sink_retain(const struct dc_sink *dc_sink)
 
 void dc_sink_release(const struct dc_sink *dc_sink)
 {
-	struct core_sink *core_sink = DC_SINK_TO_CORE(dc_sink);
 	struct sink *sink = DC_SINK_TO_SINK(dc_sink);
 
 	--sink->ref_count;
 
 	if (sink->ref_count == 0) {
 		destruct(sink);
-		dm_free(core_sink->ctx, sink);
+		dm_free(sink);
 	}
 }
 
 struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params)
 {
-	struct core_link *core_link = DC_LINK_TO_LINK(init_params->link);
-
-	struct sink *sink = dm_alloc(core_link->ctx, sizeof(*sink));
+	struct sink *sink = dm_alloc(sizeof(*sink));
 
 	if (NULL == sink)
 		goto alloc_fail;
@@ -105,7 +102,7 @@ struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params)
 	return &sink->protected.public;
 
 construct_fail:
-	dm_free(core_link->ctx, sink);
+	dm_free(sink);
 
 alloc_fail:
 	return NULL;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
index d7012bc..4ceee56 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
@@ -140,12 +140,11 @@ void dc_stream_release(struct dc_stream *public)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(public);
 	struct core_stream *protected = DC_STREAM_TO_CORE(public);
-	struct dc_context *ctx = protected->ctx;
 	stream->ref_count--;
 
 	if (stream->ref_count == 0) {
 		destruct(protected);
-		dm_free(ctx, stream);
+		dm_free(stream);
 	}
 }
 
@@ -157,7 +156,7 @@ struct dc_stream *dc_create_stream_for_sink(const struct dc_sink *dc_sink)
 	if (sink == NULL)
 		goto alloc_fail;
 
-	stream = dm_alloc(sink->ctx, sizeof(struct stream));
+	stream = dm_alloc(sizeof(struct stream));
 
 	if (NULL == stream)
 		goto alloc_fail;
@@ -170,7 +169,7 @@ struct dc_stream *dc_create_stream_for_sink(const struct dc_sink *dc_sink)
 	return &stream->protected.public;
 
 construct_fail:
-	dm_free(sink->ctx, stream);
+	dm_free(stream);
 
 alloc_fail:
 	return NULL;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
index 967b106..4a3d18d 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
@@ -53,7 +53,6 @@ struct gamma {
 #define CORE_GAMMA_TO_GAMMA(core_gamma) \
 	container_of(core_gamma, struct gamma, protected)
 
-
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
@@ -82,7 +81,7 @@ void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 
 struct dc_surface *dc_create_surface(const struct core_dc *dc)
 {
-	struct surface *surface = dm_alloc(dc->ctx, sizeof(*surface));
+	struct surface *surface = dm_alloc(sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
@@ -95,7 +94,7 @@ struct dc_surface *dc_create_surface(const struct core_dc *dc)
 	return &surface->protected.public;
 
 construct_fail:
-	dm_free(dc->ctx, surface);
+	dm_free(surface);
 
 alloc_fail:
 	return NULL;
@@ -115,7 +114,7 @@ void dc_surface_release(const struct dc_surface *dc_surface)
 
 	if (surface->ref_count == 0) {
 		destruct(surface);
-		dm_free(surface->protected.ctx, surface);
+		dm_free(surface);
 	}
 }
 
@@ -143,14 +142,13 @@ void dc_gamma_release(const struct dc_gamma *dc_gamma)
 
 	if (gamma->ref_count == 0) {
 		destruct_gamma(gamma);
-		dm_free(gamma->protected.ctx, gamma);
+		dm_free(gamma);
 	}
 }
 
-
 struct dc_gamma *dc_create_gamma(const struct core_dc *dc)
 {
-	struct gamma *gamma = dm_alloc(dc->ctx, sizeof(*gamma));
+	struct gamma *gamma = dm_alloc(sizeof(*gamma));
 
 	if (gamma == NULL)
 		goto alloc_fail;
@@ -163,7 +161,7 @@ struct dc_gamma *dc_create_gamma(const struct core_dc *dc)
 	return &gamma->protected.public;
 
 construct_fail:
-	dm_free(dc->ctx, gamma);
+	dm_free(gamma);
 
 alloc_fail:
 	return NULL;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
index e1fce1c..c697a5e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
@@ -83,7 +83,7 @@ void dc_target_release(struct dc_target *dc_target)
 	target->ref_count--;
 	if (target->ref_count == 0) {
 		destruct(protected);
-		dm_free(protected->ctx, target);
+		dm_free(target);
 	}
 }
 
@@ -113,7 +113,7 @@ struct dc_target *dc_create_target_for_streams(
 
 	stream = DC_STREAM_TO_CORE(dc_streams[0]);
 
-	target = dm_alloc(stream->ctx, sizeof(struct target));
+	target = dm_alloc(sizeof(struct target));
 
 	if (NULL == target)
 		goto target_alloc_fail;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 68a63cf..aacdefe 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -422,7 +422,6 @@ struct dc_sink_init_data {
 
 struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params);
 
-
 /*******************************************************************************
  * Cursor interfaces - To manages the cursor within a target
  ******************************************************************************/
@@ -471,8 +470,6 @@ bool dc_set_cursor_position(
 		struct dc_cursor *cursor,
 		struct dc_cursor_position *pos);
 
-
-
 /*******************************************************************************
  * Interrupt interfaces
  ******************************************************************************/
@@ -488,7 +485,6 @@ const struct dc_target *dc_get_target_on_irq_source(
 		const struct core_dc *dc,
 		enum dc_irq_source src);
 
-
 /*******************************************************************************
  * Power Interfaces
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h b/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
index 53f0477..7def8dd 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
@@ -38,7 +38,6 @@
 
 #include "include/bios_parser_types.h"
 
-
 struct dc_vbios_funcs {
 	uint8_t (*get_connectors_number)(struct dc_bios *bios);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_ddc_types.h b/drivers/gpu/drm/amd/dal/dc/dc_ddc_types.h
index c74d99c..5f2107f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_ddc_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_ddc_types.h
@@ -61,7 +61,6 @@ struct ddc {
 	struct dc_context *ctx;
 };
 
-
 union ddc_wa {
 	struct {
 		uint32_t DP_SKIP_POWER_OFF:1;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
index 82e3afb..03b95e9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
@@ -251,7 +251,6 @@ enum dc_rotation_angle {
 	ROTATION_ANGLE_COUNT
 };
 
-
 struct dc_cursor_position {
 	uint32_t x;
 	uint32_t y;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_types.h b/drivers/gpu/drm/amd/dal/dc/dc_types.h
index f764d37..b737206 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_types.h
@@ -212,13 +212,11 @@ enum plane_stereo_format {
 	PLANE_STEREO_FORMAT_CHECKER_BOARD = 7
 };
 
-
 /* TODO: Find way to calculate number of bits
  *  Please increase if pixel_format enum increases
  * num  from  PIXEL_FORMAT_INDEX8 to PIXEL_FORMAT_444BPP32
  */
 
-
 enum dc_edid_connector_type {
 	EDID_CONNECTOR_UNKNOWN = 0,
 	EDID_CONNECTOR_ANALOG = 1,
@@ -293,7 +291,6 @@ struct dc_resolution {
 	uint32_t height;
 };
 
-
 struct dc_mode_flags {
 	/* note: part of refresh rate flag*/
 	uint32_t INTERLACE :1;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
index a1c1d1c..c759081 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
@@ -75,7 +75,6 @@ static const struct dce100_hw_seq_reg_offsets reg_offsets[] = {
 #define HW_REG_CRTC(reg, id)\
 	(reg + reg_offsets[id].crtc)
 
-
 /*******************************************************************************
  * Private definitions
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index bc9fd02..6260751 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -139,7 +139,6 @@ static const struct dce110_mem_input_reg_offsets dce100_mi_reg_offsets[] = {
 	}
 };
 
-
 static const struct dce110_clk_src_reg_offsets dce100_clk_src_reg_offsets[] = {
 	{
 		.pll_cntl = mmBPHYC_PLL0_PLL_CNTL,
@@ -211,7 +210,6 @@ static const struct dce110_ipp_reg_offsets dce100_ipp_reg_offsets[] = {
 }
 };
 
-
 static const struct dce110_link_enc_bl_registers link_enc_bl_regs = {
 		.BL_PWM_CNTL = mmBL_PWM_CNTL,
 		.BL_PWM_GRP1_REG_LOCK = mmBL_PWM_GRP1_REG_LOCK,
@@ -339,7 +337,6 @@ static const struct dce110_opp_reg_offsets dce100_opp_reg_offsets[] = {
 }
 };
 
-
 static struct timing_generator *dce100_timing_generator_create(
 		struct adapter_service *as,
 		struct dc_context *ctx,
@@ -347,7 +344,7 @@ static struct timing_generator *dce100_timing_generator_create(
 		const struct dce110_timing_generator_offsets *offsets)
 {
 	struct dce110_timing_generator *tg110 =
-		dm_alloc(ctx, sizeof(struct dce110_timing_generator));
+		dm_alloc(sizeof(struct dce110_timing_generator));
 
 	if (!tg110)
 		return NULL;
@@ -357,7 +354,7 @@ static struct timing_generator *dce100_timing_generator_create(
 		return &tg110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, tg110);
+	dm_free(tg110);
 	return NULL;
 }
 
@@ -368,7 +365,7 @@ static struct stream_encoder *dce100_stream_encoder_create(
 	const struct dce110_stream_enc_registers *regs)
 {
 	struct dce110_stream_encoder *enc110 =
-		dm_alloc(ctx, sizeof(struct dce110_stream_encoder));
+		dm_alloc(sizeof(struct dce110_stream_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -377,7 +374,7 @@ static struct stream_encoder *dce100_stream_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, enc110);
+	dm_free(enc110);
 	return NULL;
 }
 
@@ -387,7 +384,7 @@ static struct mem_input *dce100_mem_input_create(
 	const struct dce110_mem_input_reg_offsets *offset)
 {
 	struct dce110_mem_input *mem_input110 =
-		dm_alloc(ctx, sizeof(struct dce110_mem_input));
+		dm_alloc(sizeof(struct dce110_mem_input));
 
 	if (!mem_input110)
 		return NULL;
@@ -397,13 +394,13 @@ static struct mem_input *dce100_mem_input_create(
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, mem_input110);
+	dm_free(mem_input110);
 	return NULL;
 }
 
 static void dce100_transform_destroy(struct transform **xfm)
 {
-	dm_free((*xfm)->ctx, TO_DCE110_TRANSFORM(*xfm));
+	dm_free(TO_DCE110_TRANSFORM(*xfm));
 	*xfm = NULL;
 }
 
@@ -413,7 +410,7 @@ static struct transform *dce100_transform_create(
 	const struct dce110_transform_reg_offsets *offsets)
 {
 	struct dce110_transform *transform =
-		dm_alloc(ctx, sizeof(struct dce110_transform));
+		dm_alloc(sizeof(struct dce110_transform));
 
 	if (!transform)
 		return NULL;
@@ -422,7 +419,7 @@ static struct transform *dce100_transform_create(
 		return &transform->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, transform);
+	dm_free(transform);
 	return NULL;
 }
 
@@ -432,7 +429,7 @@ static struct input_pixel_processor *dce100_ipp_create(
 	const struct dce110_ipp_reg_offsets *offsets)
 {
 	struct dce110_ipp *ipp =
-		dm_alloc(ctx, sizeof(struct dce110_ipp));
+		dm_alloc(sizeof(struct dce110_ipp));
 
 	if (!ipp)
 		return NULL;
@@ -441,7 +438,7 @@ static struct input_pixel_processor *dce100_ipp_create(
 		return &ipp->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, ipp);
+	dm_free(ipp);
 	return NULL;
 }
 
@@ -449,9 +446,7 @@ struct link_encoder *dce100_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
 	struct dce110_link_encoder *enc110 =
-		dm_alloc(
-			enc_init_data->ctx,
-			sizeof(struct dce110_link_encoder));
+		dm_alloc(sizeof(struct dce110_link_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -465,18 +460,17 @@ struct link_encoder *dce100_link_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(enc_init_data->ctx, enc110);
+	dm_free(enc110);
 	return NULL;
 }
 
-
 struct output_pixel_processor *dce100_opp_create(
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dce110_opp_reg_offsets *offset)
 {
 	struct dce110_opp *opp =
-		dm_alloc(ctx, sizeof(struct dce110_opp));
+		dm_alloc(sizeof(struct dce110_opp));
 
 	if (!opp)
 		return NULL;
@@ -486,24 +480,23 @@ struct output_pixel_processor *dce100_opp_create(
 		return &opp->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, opp);
+	dm_free(opp);
 	return NULL;
 }
 
-
 void dce100_opp_destroy(struct output_pixel_processor **opp)
 {
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_dx);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128_oem);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coeff128);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_1025);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.axis_x_256);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.coordinates_x);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_regamma);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_resulted);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_oem);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp)->regamma.rgb_user);
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp));
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.coeff128_dx);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.coeff128_oem);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.coeff128);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.axis_x_1025);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.axis_x_256);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.coordinates_x);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.rgb_regamma);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.rgb_resulted);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.rgb_oem);
+	dm_free(FROM_DCE11_OPP(*opp)->regamma.rgb_user);
+	dm_free(FROM_DCE11_OPP(*opp));
 	*opp = NULL;
 }
 
@@ -514,7 +507,7 @@ struct clock_source *dce100_clock_source_create(
 	const struct dce110_clk_src_reg_offsets *offsets)
 {
 	struct dce110_clk_src *clk_src =
-		dm_alloc(ctx, sizeof(struct dce110_clk_src));
+		dm_alloc(sizeof(struct dce110_clk_src));
 
 	if (!clk_src)
 		return NULL;
@@ -528,7 +521,7 @@ struct clock_source *dce100_clock_source_create(
 
 void dce100_clock_source_destroy(struct clock_source **clk_src)
 {
-	dm_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
+	dm_free(TO_DCE110_CLK_SRC(*clk_src));
 	*clk_src = NULL;
 }
 
@@ -547,22 +540,19 @@ void dce100_destruct_resource_pool(struct resource_pool *pool)
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dm_free(pool->mis[i]->ctx,
-					TO_DCE110_MEM_INPUT(pool->mis[i]));
+			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dm_free(pool->timing_generators[i]->ctx,
-					DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dm_free(pool->stream_enc[i]->ctx,
-				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
+			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
 	for (i = 0; i < pool->clk_src_count; i++) {
@@ -1147,8 +1137,7 @@ bool dce100_construct_resource_pool(
 stream_enc_create_fail:
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dm_free(pool->stream_enc[i]->ctx,
-				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
+			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
 audio_create_fail:
@@ -1169,14 +1158,12 @@ controller_create_fail:
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dm_free(pool->mis[i]->ctx,
-					TO_DCE110_MEM_INPUT(pool->mis[i]));
+			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dm_free(pool->timing_generators[i]->ctx,
-				DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h
index 65cd170..c332869 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h
@@ -13,7 +13,6 @@ struct core_dc;
 struct resource_pool;
 struct dc_validation_set;
 
-
 bool dce100_construct_resource_pool(
 	struct adapter_service *adapter_serv,
 	uint8_t num_virtual_links,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
index ba2929b..033afe8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
@@ -225,7 +225,6 @@ static bool calc_fb_divider_checking_tolerance(
 	return false;
 }
 
-
 static bool calc_pll_dividers_in_range(
 		struct calc_pll_clock_source *calc_pll_cs,
 		struct pll_settings *pll_settings,
@@ -582,11 +581,8 @@ static bool calculate_ss(
 	if (pll_settings == NULL)
 		return false;
 
-
 	dm_memset(ds_data, 0, sizeof(struct delta_sigma_data));
 
-
-
 	/* compute SS_AMOUNT_FBDIV & SS_AMOUNT_NFRAC_SLIP & SS_AMOUNT_DSFRAC*/
 	/* 6 decimal point support in fractional feedback divider */
 	fb_div  = dal_fixed32_32_from_fraction(
@@ -616,7 +612,6 @@ static bool calculate_ss(
 		pll_settings->reference_freq * 1000,
 		pll_settings->reference_divider * ss_data->modulation_freq_hz);
 
-
 	if (ss_data->flags.CENTER_SPREAD)
 		modulation_time = dal_fixed32_32_div_int(modulation_time, 4);
 	else
@@ -829,7 +824,6 @@ static struct clock_source_funcs dce110_clk_src_funcs = {
 	.get_pix_clk_dividers = dce110_get_pix_clk_dividers
 };
 
-
 static void get_ss_info_from_atombios(
 		struct dce110_clk_src *clk_src,
 		enum as_signal_type as_signal,
@@ -868,14 +862,12 @@ static void get_ss_info_from_atombios(
 	if (*ss_entries_num == 0)
 		return;
 
-	ss_info = dm_alloc(clk_src->base.ctx, sizeof(struct spread_spectrum_info)
-				* (*ss_entries_num));
+	ss_info = dm_alloc(sizeof(struct spread_spectrum_info) * (*ss_entries_num));
 	ss_info_cur = ss_info;
 	if (ss_info == NULL)
 		return;
 
-	ss_data = dm_alloc(clk_src->base.ctx, sizeof(struct spread_spectrum_data) *
-							(*ss_entries_num));
+	ss_data = dm_alloc(sizeof(struct spread_spectrum_data) * (*ss_entries_num));
 	if (ss_data == NULL)
 		goto out_free_info;
 
@@ -949,14 +941,14 @@ static void get_ss_info_from_atombios(
 	}
 
 	*spread_spectrum_data = ss_data;
-	dm_free(clk_src->base.ctx, ss_info);
+	dm_free(ss_info);
 	return;
 
 out_free_data:
-	dm_free(clk_src->base.ctx, ss_data);
+	dm_free(ss_data);
 	*ss_entries_num = 0;
 out_free_info:
-	dm_free(clk_src->base.ctx, ss_info);
+	dm_free(ss_info);
 }
 
 static void ss_info_from_atombios_create(
@@ -1160,4 +1152,3 @@ unexpected_failure:
 	return false;
 }
 
-
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
index 285d544..5b55ce8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_compressor.c
@@ -280,8 +280,6 @@ static uint32_t lpt_memory_control_config(struct dce110_compressor *cp110,
 	return lpt_control;
 }
 
-
-
 static bool is_source_bigger_than_epanel_size(
 	struct dce110_compressor *cp110,
 	uint32_t source_view_width,
@@ -753,7 +751,6 @@ void dce110_compressor_program_lpt_control(
  * DCE 11 Frame Buffer Compression Implementation
  */
 
-
 void dce110_compressor_set_fbc_invalidation_triggers(
 	struct compressor *compressor,
 	uint32_t fbc_trigger)
@@ -866,7 +863,7 @@ struct compressor *dce110_compressor_create(struct dc_context *ctx,
 	struct adapter_service *as)
 {
 	struct dce110_compressor *cp110 =
-		dm_alloc(ctx, sizeof(struct dce110_compressor));
+		dm_alloc(sizeof(struct dce110_compressor));
 
 	if (!cp110)
 		return NULL;
@@ -875,12 +872,12 @@ struct compressor *dce110_compressor_create(struct dc_context *ctx,
 		return &cp110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, cp110);
+	dm_free(cp110);
 	return NULL;
 }
 
 void dce110_compressor_destroy(struct compressor **compressor)
 {
-	dm_free((*compressor)->ctx, TO_DCE110_COMPRESSOR(*compressor));
+	dm_free(TO_DCE110_COMPRESSOR(*compressor));
 	*compressor = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 68dc378..716a762 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -101,7 +101,6 @@ static const struct dce110_hw_seq_reg_offsets reg_offsets[] = {
 #define HW_REG_CRTC(reg, id)\
 	(reg + reg_offsets[id].crtc)
 
-
 #define MAX_WATERMARK 0xFFFF
 #define SAFE_NBP_MARK 0x7FFF
 
@@ -408,7 +407,6 @@ static void dce110_set_blender_mode(
 		BLND_CONTROL,
 		BLND_MULTIPLIED_MODE);
 
-
 	dm_write_reg(ctx, addr, value);
 }
 
@@ -506,7 +504,6 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	}
 }
 
-
 static bool set_gamma_ramp(
 	struct input_pixel_processor *ipp,
 	struct output_pixel_processor *opp,
@@ -518,18 +515,16 @@ static bool set_gamma_ramp(
 	struct temp_params *temp_params;
 	bool result = false;
 
-	prescale_params = dm_alloc(opp->ctx,
-			sizeof(struct ipp_prescale_params));
+	prescale_params = dm_alloc(sizeof(struct ipp_prescale_params));
 
 	if (prescale_params == NULL)
 		goto prescale_alloc_fail;
 
-	regamma_params = dm_alloc(opp->ctx,
-			sizeof(struct pwl_params));
+	regamma_params = dm_alloc(sizeof(struct pwl_params));
 	if (regamma_params == NULL)
 		goto regamma_alloc_fail;
 
-	temp_params = dm_alloc(opp->ctx, sizeof(struct temp_params));
+	temp_params = dm_alloc(sizeof(struct temp_params));
 
 	if (temp_params == NULL)
 		goto temp_alloc_fail;
@@ -558,14 +553,14 @@ static bool set_gamma_ramp(
 
 	opp->funcs->opp_power_on_regamma_lut(opp, false);
 
-	dm_free(opp->ctx, temp_params);
+	dm_free(temp_params);
 
 	result = true;
 
 temp_alloc_fail:
-	dm_free(opp->ctx, regamma_params);
+	dm_free(regamma_params);
 regamma_alloc_fail:
-	dm_free(opp->ctx, prescale_params);
+	dm_free(prescale_params);
 prescale_alloc_fail:
 	return result;
 }
@@ -641,7 +636,6 @@ static void update_info_frame(struct pipe_ctx *pipe_ctx)
 			&pipe_ctx->encoder_info_frame);
 }
 
-
 static void enable_stream(struct pipe_ctx *pipe_ctx)
 {
 	enum dc_lane_count lane_count =
@@ -905,7 +899,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	return DC_OK;
 }
 
-
 /******************************************************************************/
 
 static void power_down_encoders(struct core_dc *dc)
@@ -1064,7 +1057,6 @@ static bool dc_set_clocks_and_clock_state (
 	struct display_clock *disp_clk = context->res_ctx.pool.display_clock;
 	struct dc_context *ctx = context->targets[0]->ctx;
 
-
 	if (!dc_pre_clock_change(
 			ctx,
 			&context->res_ctx.min_clocks,
@@ -1092,7 +1084,6 @@ static bool dc_set_clocks_and_clock_state (
 		dm_error("DC: failed to set minimum clock state!\n");
 	}
 
-
 	/*bm_clk_info.max_mclk_khz = output.max_mclk;
 	bm_clk_info.min_mclk_khz = output.min_mclk;
 	bm_clk_info.max_sclk_khz = output.max_sclk;
@@ -1174,7 +1165,6 @@ static void set_displaymarks(
 	}
 }
 
-
 static void set_safe_displaymarks(struct resource_context *res_ctx)
 {
 	uint8_t i;
@@ -1294,7 +1284,6 @@ static enum dc_status apply_ctx_to_hw(
 	return DC_OK;
 }
 
-
 /*******************************************************************************
  * Front End programming
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c
index e67b7e6..3a9756d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.c
@@ -57,6 +57,6 @@ bool dce110_ipp_construct(
 
 void dce110_ipp_destroy(struct input_pixel_processor **ipp)
 {
-	dm_free((*ipp)->ctx, TO_DCE110_IPP(*ipp));
+	dm_free(TO_DCE110_IPP(*ipp));
 	*ipp = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.h
index 0004d7a..b20a8e7 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp.h
@@ -28,7 +28,6 @@
 
 #include "ipp.h"
 
-
 struct gamma_parameters;
 struct dev_c_lut;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c
index eaa1f05..2dabaed 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_ipp_cursor.c
@@ -70,7 +70,6 @@ static void program_address(
 	struct dce110_ipp *ipp110,
 	PHYSICAL_ADDRESS_LOC address);
 
-
 void dce110_ipp_cursor_set_position(
 	struct input_pixel_processor *ipp,
 	const struct dc_cursor_position *position)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
index d1fa4a7..e412804 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
@@ -156,5 +156,4 @@ void dce110_link_encoder_set_dp_phy_pattern_training_pattern(
 	struct link_encoder *enc,
 	uint32_t index);
 
-
 #endif /* __DC_LINK_ENCODER__DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index d9dab36..b1f1135 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -36,7 +36,6 @@
 
 #include "dce110_mem_input.h"
 
-
 #define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
 #define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)
 #define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)
@@ -287,7 +286,6 @@ static void program_size_and_rotation(
 		DCP_REG(mmGRPH_PITCH),
 		value);
 
-
 	value = 0;
 	switch (rotation) {
 	case ROTATION_ANGLE_90:
@@ -338,7 +336,6 @@ static void program_pixel_format(
 			DCP_REG(mmGRPH_SWAP_CNTL),
 			value);
 
-
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
 				DCP_REG(mmGRPH_CONTROL));
@@ -508,7 +505,6 @@ static void program_urgency_watermark(
 		URGENCY_HIGH_WATERMARK);
 	dm_write_reg(ctx, urgency_addr, urgency_cntl);
 
-
 	/*Write mask to enable reading/writing of watermark set B*/
 	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
 	set_reg_field_value(wm_mask_cntl,
@@ -812,7 +808,6 @@ void dce110_allocate_mem_input(
 				"%s: DMIF allocation failed",
 				__func__);
 
-
 	if (pix_clk_khz != 0) {
 		addr = mmDPG_PIPE_ARBITRATION_CONTROL1 + bm110->offsets.dmif;
 		value = dm_read_reg(mi->ctx, addr);
@@ -955,6 +950,6 @@ bool dce110_mem_input_construct(
 
 void dce110_mem_input_destroy(struct mem_input **mem_input)
 {
-	dm_free((*mem_input)->ctx, TO_DCE110_MEM_INPUT(*mem_input));
+	dm_free(TO_DCE110_MEM_INPUT(*mem_input));
 	*mem_input = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
index 0383178..32ee571 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
@@ -36,7 +36,6 @@ struct dce110_mem_input_reg_offsets {
 	uint32_t pipe;
 };
 
-
 enum stutter_mode_type {
 /*	TODO: Clean up these enums, right now only one is being used
  *	STUTTER_MODE_LEGACY = 0X00000001,
@@ -129,5 +128,4 @@ bool  dce110_mem_input_program_surface_config(
 	union plane_size *plane_size,
 	enum dc_rotation_angle rotation);
 
-
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
index 08620e6..acfbd08 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
@@ -36,12 +36,10 @@
 
 #include "dce110_mem_input.h"
 
-
 #define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
 /*#define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)*/
 /*#define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)*/
 
-
 static const struct dce110_mem_input_reg_offsets dce110_mi_v_reg_offsets[] = {
 	{
 		.dcp = 0,
@@ -575,7 +573,6 @@ static void program_urgency_watermark(
 		URGENCY_HIGH_WATERMARK);
 	dm_write_reg(ctx, urgency_addr, urgency_cntl);
 
-
 	/*Write mask to enable reading/writing of watermark set B*/
 	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
 	set_reg_field_value(wm_mask_cntl,
@@ -727,7 +724,6 @@ static void program_nbp_watermark(
 		NB_PSTATE_CHANGE_WATERMARK_MASK);
 	dm_write_reg(ctx, wm_mask_ctrl_addr, value);
 
-
 	value = dm_read_reg(ctx, nbp_pstate_ctrl_addr);
 
 	set_reg_field_value(
@@ -847,7 +843,6 @@ void dce110_mem_input_v_program_display_marks(
 		stutter);
 }
 
-
 void dce110_allocate_mem_input_v(
 	struct mem_input *mi,
 	uint32_t h_total,/* for current stream */
@@ -899,7 +894,7 @@ bool dce110_mem_input_v_construct(
 #if 0
 void dce110_mem_input_v_destroy(struct mem_input **mem_input)
 {
-	dm_free((*mem_input)->ctx, TO_DCE110_MEM_INPUT(*mem_input));
+	dm_free(TO_DCE110_MEM_INPUT(*mem_input));
 	*mem_input = NULL;
 }
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
index 24b4211..3df346b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
@@ -80,5 +80,4 @@ bool  dce110_mem_input_v_program_surface_config(
 	union plane_size *plane_size,
 	enum dc_rotation_angle rotation);
 
-
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c
index ab937d5..d3da726 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.c
@@ -72,7 +72,7 @@ bool dce110_opp_construct(struct dce110_opp *opp110,
 
 void dce110_opp_destroy(struct output_pixel_processor **opp)
 {
-	dm_free((*opp)->ctx, FROM_DCE11_OPP(*opp));
+	dm_free(FROM_DCE11_OPP(*opp));
 	*opp = NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
index abb5a5d..a0b6d8e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
@@ -130,7 +130,6 @@ void dce110_opp_program_clamping_and_pixel_encoding(
 	struct output_pixel_processor *opp,
 	const struct clamping_and_pixel_encoding_params *params);
 
-
 void dce110_opp_set_dyn_expansion(
 	struct output_pixel_processor *opp,
 	enum dc_color_space color_sp,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c
index e4f4fe0..8b9725c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_regamma.c
@@ -482,7 +482,6 @@ static void program_pwl(
 	dm_write_reg(opp110->base.ctx, DCFE_REG(mmDCFE_MEM_PWR_CTRL), value);
 }
 
-
 bool dce110_opp_program_regamma_pwl(
 	struct output_pixel_processor *opp,
 	const struct pwl_params *params)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c
index 8babd01..7413db4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c
@@ -70,6 +70,3 @@ bool dce110_opp_v_construct(struct dce110_opp *opp110,
 	return true;
 }
 
-
-
-
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index cdd1f94..99484f6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -254,7 +254,6 @@ static const struct dce110_stream_enc_registers stream_enc_regs[] = {
 		stream_enc_regs(6)
 };
 
-
 /* AG TBD Needs to be reduced back to 3 pipes once dce10 hw sequencer implemented. */
 static const struct dce110_opp_reg_offsets dce110_opp_reg_offsets[] = {
 {
@@ -285,7 +284,6 @@ static const struct dce110_opp_reg_offsets dce110_opp_reg_offsets[] = {
 }
 };
 
-
 static const struct dce110_clk_src_reg_offsets dce110_clk_src_reg_offsets[] = {
 	{
 		.pll_cntl = mmBPHYC_PLL0_PLL_CNTL,
@@ -304,7 +302,7 @@ static struct timing_generator *dce110_timing_generator_create(
 		const struct dce110_timing_generator_offsets *offsets)
 {
 	struct dce110_timing_generator *tg110 =
-		dm_alloc(ctx, sizeof(struct dce110_timing_generator));
+		dm_alloc(sizeof(struct dce110_timing_generator));
 
 	if (!tg110)
 		return NULL;
@@ -313,7 +311,7 @@ static struct timing_generator *dce110_timing_generator_create(
 		return &tg110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, tg110);
+	dm_free(tg110);
 	return NULL;
 }
 
@@ -324,7 +322,7 @@ static struct stream_encoder *dce110_stream_encoder_create(
 	const struct dce110_stream_enc_registers *regs)
 {
 	struct dce110_stream_encoder *enc110 =
-		dm_alloc(ctx, sizeof(struct dce110_stream_encoder));
+		dm_alloc(sizeof(struct dce110_stream_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -333,7 +331,7 @@ static struct stream_encoder *dce110_stream_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, enc110);
+	dm_free(enc110);
 	return NULL;
 }
 
@@ -343,7 +341,7 @@ static struct mem_input *dce110_mem_input_create(
 	const struct dce110_mem_input_reg_offsets *offset)
 {
 	struct dce110_mem_input *mem_input110 =
-		dm_alloc(ctx, sizeof(struct dce110_mem_input));
+		dm_alloc(sizeof(struct dce110_mem_input));
 
 	if (!mem_input110)
 		return NULL;
@@ -353,13 +351,13 @@ static struct mem_input *dce110_mem_input_create(
 		return &mem_input110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, mem_input110);
+	dm_free(mem_input110);
 	return NULL;
 }
 
 static void dce110_transform_destroy(struct transform **xfm)
 {
-	dm_free((*xfm)->ctx, TO_DCE110_TRANSFORM(*xfm));
+	dm_free(TO_DCE110_TRANSFORM(*xfm));
 	*xfm = NULL;
 }
 
@@ -369,7 +367,7 @@ static struct transform *dce110_transform_create(
 	const struct dce110_transform_reg_offsets *offsets)
 {
 	struct dce110_transform *transform =
-		dm_alloc(ctx, sizeof(struct dce110_transform));
+		dm_alloc(sizeof(struct dce110_transform));
 
 	if (!transform)
 		return NULL;
@@ -378,7 +376,7 @@ static struct transform *dce110_transform_create(
 		return &transform->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, transform);
+	dm_free(transform);
 	return NULL;
 }
 
@@ -388,7 +386,7 @@ static struct input_pixel_processor *dce110_ipp_create(
 	const struct dce110_ipp_reg_offsets *offsets)
 {
 	struct dce110_ipp *ipp =
-		dm_alloc(ctx, sizeof(struct dce110_ipp));
+		dm_alloc(sizeof(struct dce110_ipp));
 
 	if (!ipp)
 		return NULL;
@@ -397,7 +395,7 @@ static struct input_pixel_processor *dce110_ipp_create(
 		return &ipp->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, ipp);
+	dm_free(ipp);
 	return NULL;
 }
 
@@ -405,9 +403,7 @@ struct link_encoder *dce110_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
 	struct dce110_link_encoder *enc110 =
-		dm_alloc(
-			enc_init_data->ctx,
-			sizeof(struct dce110_link_encoder));
+		dm_alloc(sizeof(struct dce110_link_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -421,24 +417,23 @@ struct link_encoder *dce110_link_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(enc_init_data->ctx, enc110);
+	dm_free(enc110);
 	return NULL;
 }
 
 void dce110_link_encoder_destroy(struct link_encoder **enc)
 {
-	dm_free((*enc)->ctx, TO_DCE110_LINK_ENC(*enc));
+	dm_free(TO_DCE110_LINK_ENC(*enc));
 	*enc = NULL;
 }
 
-
 static struct output_pixel_processor *dce110_opp_create(
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dce110_opp_reg_offsets *offsets)
 {
 	struct dce110_opp *opp =
-		dm_alloc(ctx, sizeof(struct dce110_opp));
+		dm_alloc(sizeof(struct dce110_opp));
 
 	if (!opp)
 		return NULL;
@@ -448,7 +443,7 @@ static struct output_pixel_processor *dce110_opp_create(
 		return &opp->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, opp);
+	dm_free(opp);
 	return NULL;
 }
 
@@ -459,7 +454,7 @@ struct clock_source *dce110_clock_source_create(
 	const struct dce110_clk_src_reg_offsets *offsets)
 {
 	struct dce110_clk_src *clk_src =
-		dm_alloc(ctx, sizeof(struct dce110_clk_src));
+		dm_alloc(sizeof(struct dce110_clk_src));
 
 	if (!clk_src)
 		return NULL;
@@ -473,7 +468,7 @@ struct clock_source *dce110_clock_source_create(
 
 void dce110_clock_source_destroy(struct clock_source **clk_src)
 {
-	dm_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
+	dm_free(TO_DCE110_CLK_SRC(*clk_src));
 	*clk_src = NULL;
 }
 
@@ -492,21 +487,19 @@ void dce110_destruct_resource_pool(struct resource_pool *pool)
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dm_free(pool->mis[i]->ctx,
-					TO_DCE110_MEM_INPUT(pool->mis[i]));
+			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dm_free(pool->timing_generators[i]->ctx, DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dm_free(pool->stream_enc[i]->ctx,
-				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
+			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
 	for (i = 0; i < pool->clk_src_count; i++) {
@@ -1059,10 +1052,10 @@ static struct resource_funcs dce110_res_pool_funcs = {
 
 static void underlay_create(struct dc_context *ctx, struct resource_pool *pool)
 {
-	struct dce110_timing_generator *dce110_tgv = dm_alloc(ctx, sizeof (*dce110_tgv));
-	struct dce110_transform *dce110_xfmv = dm_alloc(ctx, sizeof (*dce110_xfmv));
-	struct dce110_mem_input *dce110_miv = dm_alloc(ctx, sizeof (*dce110_miv));
-	struct dce110_opp *dce110_oppv = dm_alloc(ctx, sizeof (*dce110_oppv));
+	struct dce110_timing_generator *dce110_tgv = dm_alloc(sizeof (*dce110_tgv));
+	struct dce110_transform *dce110_xfmv = dm_alloc(sizeof (*dce110_xfmv));
+	struct dce110_mem_input *dce110_miv = dm_alloc(sizeof (*dce110_miv));
+	struct dce110_opp *dce110_oppv = dm_alloc(sizeof (*dce110_oppv));
 
 	dce110_opp_v_construct(dce110_oppv, ctx);
 	dce110_timing_generator_v_construct(dce110_tgv, pool->adapter_srv, ctx);
@@ -1271,8 +1264,7 @@ bool dce110_construct_resource_pool(
 stream_enc_create_fail:
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dm_free(pool->stream_enc[i]->ctx,
-				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
+			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
 audio_create_fail:
@@ -1293,14 +1285,12 @@ controller_create_fail:
 			dce110_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dm_free(pool->mis[i]->ctx,
-					TO_DCE110_MEM_INPUT(pool->mis[i]));
+			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dm_free(pool->timing_generators[i]->ctx,
-				DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index 59ec7f4..ceb91fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -444,7 +444,6 @@ static void disable_stereo(struct timing_generator *tg)
 	value = 0;
 	dm_write_reg(tg->ctx, addr, value);
 
-
 	addr = tg->regs[IDX_CRTC_STEREO_CONTROL];
 	dm_write_reg(tg->ctx, addr, value);
 }
@@ -1196,7 +1195,6 @@ void dce110_timing_generator_setup_global_swap_lock(
 	dm_write_reg(tg->ctx, address, value);
 }
 
-
 void dce110_timing_generator_tear_down_global_swap_lock(
 	struct timing_generator *tg)
 {
@@ -1227,7 +1225,6 @@ void dce110_timing_generator_tear_down_global_swap_lock(
 			DCP_GSL_CONTROL,
 			DCP_GSL_HSYNC_FLIP_FORCE_DELAY);
 
-
 	set_reg_field_value(value,
 			0x6,
 			DCP_GSL_CONTROL,
@@ -1807,7 +1804,6 @@ bool dce110_tg_validate_timing(struct timing_generator *tg,
 	return dce110_timing_generator_validate_timing(tg, timing, SIGNAL_TYPE_NONE);
 }
 
-
 void dce110_tg_wait_for_state(struct timing_generator *tg,
 	enum crtc_state state)
 {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
index d09af97..005f22b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
@@ -26,7 +26,6 @@
 #ifndef __DC_TIMING_GENERATOR_DCE110_H__
 #define __DC_TIMING_GENERATOR_DCE110_H__
 
-
 #include "timing_generator.h"
 #include "../include/grph_object_id.h"
 #include "../include/hw_sequencer_types.h"
@@ -129,7 +128,6 @@ void dce110_timing_generator_wait_for_vblank(struct timing_generator *tg);
 /* wait until TG is in beginning of active region */
 void dce110_timing_generator_wait_for_vactive(struct timing_generator *tg);
 
-
 /*********** Timing Generator Synchronization routines ****/
 
 /* Setups Global Swap Lock group, TimingServer or TimingClient*/
@@ -180,7 +178,6 @@ void dce110_timing_generator_color_space_to_black_color(
 	struct crtc_black_color *black_color);
 /*************** End-of-move ********************/
 
-
 /* Not called yet */
 void dce110_timing_generator_set_test_pattern(
 	struct timing_generator *tg,
@@ -226,7 +223,6 @@ bool dce110_tg_set_blank(struct timing_generator *tg,
 bool dce110_tg_validate_timing(struct timing_generator *tg,
 	const struct dc_crtc_timing *timing);
 
-
 void dce110_tg_wait_for_state(struct timing_generator *tg,
 	enum crtc_state state);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
index a7ea52e..10fc041 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
@@ -1,5 +1,3 @@
-
-
 #include "dm_services.h"
 
 /* include DCE11 register header files */
@@ -17,7 +15,6 @@
 
 #include "timing_generator.h"
 
-
 /** ********************************************************************************
  *
  * DCE11 Timing Generator Implementation
@@ -591,7 +588,6 @@ static void dce110_timing_generator_v_set_colors(struct timing_generator *tg,
 		dce110_timing_generator_v_set_overscan_color(tg, overscan_color);
 }
 
-
 static void dce110_timing_generator_v_set_early_control(
 		struct timing_generator *tg,
 		uint32_t early_cntl)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
index 4a5d54c..f8376f8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
@@ -103,7 +103,6 @@ static bool setup_scaling_configuration(
 	set_reg_field_value(value, 1, SCL_MODE, SCL_PSCL_EN);
 	dm_write_reg(ctx, addr, value);
 
-
 	addr = SCL_REG(mmSCL_TAP_CONTROL);
 	value = dm_read_reg(ctx, addr);
 	set_reg_field_value(value, data->taps.h_taps - 1,
@@ -112,7 +111,6 @@ static bool setup_scaling_configuration(
 			SCL_TAP_CONTROL, SCL_V_NUM_OF_TAPS);
 	dm_write_reg(ctx, addr, value);
 
-
 	addr = SCL_REG(mmSCL_CONTROL);
 	value = dm_read_reg(ctx, addr);
 	 /* 1 - Replaced out of bound pixels with edge */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
index 47ab396..17b72e7 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
@@ -37,7 +37,6 @@
 			"TRANSFORM SCALER:%s()\n", __func__)
 #define LB_TOTAL_NUMBER_OF_ENTRIES 1712
 
-
 struct sclv_ratios_inits {
 	uint32_t h_int_scale_ratio_luma;
 	uint32_t h_int_scale_ratio_chroma;
@@ -80,7 +79,6 @@ static void calculate_viewport(
 	chroma_viewport->height = luma_viewport->height;
 	chroma_viewport->width = luma_viewport->width;
 
-
 	if (scl_data->format == PIXEL_FORMAT_420BPP12) {
 		luma_viewport->height += luma_viewport->height % 2;
 		luma_viewport->width += luma_viewport->width % 2;
@@ -94,7 +92,6 @@ static void calculate_viewport(
 	}
 }
 
-
 static void program_viewport(
 	struct dce110_transform *xfm110,
 	struct rect *luma_view_port,
@@ -381,7 +378,6 @@ static void program_scl_ratios_inits(
 		SCL_V_SCALE_RATIO);
 	dm_write_reg(ctx, addr, value);
 
-
 	addr = mmSCLV_HORZ_FILTER_SCALE_RATIO_C;
 	value = 0;
 	set_reg_field_value(
@@ -400,7 +396,6 @@ static void program_scl_ratios_inits(
 		SCL_V_SCALE_RATIO_C);
 	dm_write_reg(ctx, addr, value);
 
-
 	addr = mmSCLV_HORZ_FILTER_INIT;
 	value = 0;
 	set_reg_field_value(
@@ -429,7 +424,6 @@ static void program_scl_ratios_inits(
 		SCL_V_INIT_INT);
 	dm_write_reg(ctx, addr, value);
 
-
 	addr = mmSCLV_HORZ_FILTER_INIT_C;
 	value = 0;
 	set_reg_field_value(
@@ -482,7 +476,6 @@ static bool dce110_transform_v_set_scaler(
 	struct rect chroma_viewport = {0};
 	struct dc_context *ctx = xfm->ctx;
 
-
 	/* 1. Calculate viewport, viewport programming should happen after init
 	 * calculations as they may require an adjustment in the viewport.
 	 */
@@ -570,7 +563,6 @@ static bool dce110_transform_v_power_up_line_buffer(struct transform *xfm)
 	return true;
 }
 
-
 static struct transform_funcs dce110_transform_v_funcs = {
 	.transform_power_up =
 		dce110_transform_v_power_up_line_buffer,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c
index a3b767e..d7d0088 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_compressor.c
@@ -292,8 +292,6 @@ static uint32_t lpt_memory_control_config(struct dce80_compressor *cp80,
 	return lpt_control;
 }
 
-
-
 static bool is_source_bigger_than_epanel_size(
 	struct dce80_compressor *cp80,
 	uint32_t source_view_width,
@@ -734,7 +732,6 @@ void dce80_compressor_program_lpt_control(
  * DCE 11 Frame Buffer Compression Implementation
  */
 
-
 void dce80_compressor_set_fbc_invalidation_triggers(
 	struct compressor *compressor,
 	uint32_t fbc_trigger)
@@ -847,7 +844,7 @@ struct compressor *dce80_compressor_create(struct dc_context *ctx,
 	struct adapter_service *as)
 {
 	struct dce80_compressor *cp80 =
-		dm_alloc(ctx, sizeof(struct dce80_compressor));
+		dm_alloc(sizeof(struct dce80_compressor));
 
 	if (!cp80)
 		return NULL;
@@ -856,12 +853,12 @@ struct compressor *dce80_compressor_create(struct dc_context *ctx,
 		return &cp80->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, cp80);
+	dm_free(cp80);
 	return NULL;
 }
 
 void dce80_compressor_destroy(struct compressor **compressor)
 {
-	dm_free((*compressor)->ctx, TO_DCE80_COMPRESSOR(*compressor));
+	dm_free(TO_DCE80_COMPRESSOR(*compressor));
 	*compressor = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
index 1502829..ef55de3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
@@ -90,8 +90,6 @@ static const struct dce80_hw_seq_reg_offsets reg_offsets[] = {
 #define HW_REG_CRTC(reg, id)\
 	(reg + reg_offsets[id].crtc)
 
-
-
 /*******************************************************************************
  * Private definitions
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.c
index 6dde1eb..2ddcffd 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.c
@@ -59,6 +59,6 @@ bool dce80_ipp_construct(
 
 void dce80_ipp_destroy(struct input_pixel_processor **ipp)
 {
-	dm_free((*ipp)->ctx, TO_DCE80_IPP(*ipp));
+	dm_free(TO_DCE80_IPP(*ipp));
 	*ipp = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.h
index adf33cd..d350138 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp.h
@@ -36,7 +36,6 @@ struct dce110_ipp_reg_offsets;
 struct gamma_parameters;
 struct dev_c_lut;
 
-
 bool dce80_ipp_construct(
 	struct dce110_ipp *ipp,
 	struct dc_context *ctx,
@@ -45,5 +44,4 @@ bool dce80_ipp_construct(
 
 void dce80_ipp_destroy(struct input_pixel_processor **ipp);
 
-
 #endif /*__DC_IPP_DCE80_H__*/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp_gamma.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp_gamma.c
index fdffb8c..eacb14e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp_gamma.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_ipp_gamma.c
@@ -43,16 +43,12 @@ enum {
 	MAX_INPUT_LUT_ENTRY = 256
 };
 
-
 /*PROTOTYPE DECLARATIONS*/
 
-
 static void set_legacy_input_gamma_mode(
 	struct dce110_ipp *ipp80,
 	bool is_legacy);
 
-
-
 void dce80_ipp_set_legacy_input_gamma_mode(
 		struct input_pixel_processor *ipp,
 		bool is_legacy)
@@ -62,7 +58,6 @@ void dce80_ipp_set_legacy_input_gamma_mode(
 	set_legacy_input_gamma_mode(ipp80, is_legacy);
 }
 
-
 static void set_legacy_input_gamma_mode(
 	struct dce110_ipp *ipp80,
 	bool is_legacy)
@@ -79,7 +74,3 @@ static void set_legacy_input_gamma_mode(
 	dm_write_reg(ipp80->base.ctx, addr, value);
 }
 
-
-
-
-
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
index 5288436..e8c9e86 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
@@ -209,7 +209,6 @@ static struct link_encoder_funcs dce80_lnk_enc_funcs = {
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe
 };
 
-
 bool dce80_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
index 86a79b2..27533bb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
@@ -37,7 +37,6 @@
 #include "../dce110/dce110_mem_input.h"
 #include "dce80_mem_input.h"
 
-
 #define MAX_WATERMARK 0xFFFF
 #define SAFE_NBP_MARK 0x7FFF
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.c
index 82c98a1..9a3f674 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.c
@@ -76,8 +76,6 @@ static const struct dce80_opp_reg_offsets reg_offsets[] = {
 }
 };
 
-
-
 static struct opp_funcs funcs = {
 		.opp_power_on_regamma_lut = dce80_opp_power_on_regamma_lut,
 		.opp_program_bit_depth_reduction =
@@ -116,7 +114,7 @@ bool dce80_opp_construct(struct dce80_opp *opp80,
 
 void dce80_opp_destroy(struct output_pixel_processor **opp)
 {
-	dm_free((*opp)->ctx, FROM_OPP(*opp));
+	dm_free(FROM_OPP(*opp));
 	*opp = NULL;
 }
 
@@ -125,7 +123,7 @@ struct output_pixel_processor *dce80_opp_create(
 	uint32_t inst)
 {
 	struct dce80_opp *opp =
-		dm_alloc(ctx, sizeof(struct dce80_opp));
+		dm_alloc(sizeof(struct dce80_opp));
 
 	if (!opp)
 		return NULL;
@@ -135,7 +133,7 @@ struct output_pixel_processor *dce80_opp_create(
 		return &opp->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, opp);
+	dm_free(opp);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
index a3b1c08..a8a8813 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
@@ -120,7 +120,6 @@ void dce80_opp_program_clamping_and_pixel_encoding(
 	struct output_pixel_processor *opp,
 	const struct clamping_and_pixel_encoding_params *params);
 
-
 void dce80_opp_set_dyn_expansion(
 	struct output_pixel_processor *opp,
 	enum dc_color_space color_sp,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_regamma.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_regamma.c
index 5b9663c..14362b4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_regamma.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_regamma.c
@@ -490,7 +490,6 @@ static void program_pwl(
 			value);
 }
 
-
 void dce80_opp_power_on_regamma_lut(
 	struct output_pixel_processor *opp,
 	bool power_on)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index be8bba1..ae85fec 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -338,7 +338,7 @@ static struct timing_generator *dce80_timing_generator_create(
 		const struct dce110_timing_generator_offsets *offsets)
 {
 	struct dce110_timing_generator *tg110 =
-		dm_alloc(ctx, sizeof(struct dce110_timing_generator));
+		dm_alloc(sizeof(struct dce110_timing_generator));
 
 	if (!tg110)
 		return NULL;
@@ -347,7 +347,7 @@ static struct timing_generator *dce80_timing_generator_create(
 		return &tg110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, tg110);
+	dm_free(tg110);
 	return NULL;
 }
 
@@ -358,7 +358,7 @@ static struct stream_encoder *dce80_stream_encoder_create(
 	const struct dce110_stream_enc_registers *regs)
 {
 	struct dce110_stream_encoder *enc110 =
-		dm_alloc(ctx, sizeof(struct dce110_stream_encoder));
+		dm_alloc(sizeof(struct dce110_stream_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -367,18 +367,17 @@ static struct stream_encoder *dce80_stream_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, enc110);
+	dm_free(enc110);
 	return NULL;
 }
 
-
 static struct mem_input *dce80_mem_input_create(
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dce110_mem_input_reg_offsets *offsets)
 {
 	struct dce110_mem_input *mem_input80 =
-		dm_alloc(ctx, sizeof(struct dce110_mem_input));
+		dm_alloc(sizeof(struct dce110_mem_input));
 
 	if (!mem_input80)
 		return NULL;
@@ -388,13 +387,13 @@ static struct mem_input *dce80_mem_input_create(
 		return &mem_input80->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, mem_input80);
+	dm_free(mem_input80);
 	return NULL;
 }
 
 static void dce80_transform_destroy(struct transform **xfm)
 {
-	dm_free((*xfm)->ctx, TO_DCE80_TRANSFORM(*xfm));
+	dm_free(TO_DCE80_TRANSFORM(*xfm));
 	*xfm = NULL;
 }
 
@@ -404,7 +403,7 @@ static struct transform *dce80_transform_create(
 	const struct dce80_transform_reg_offsets *offsets)
 {
 	struct dce80_transform *transform =
-		dm_alloc(ctx, sizeof(struct dce80_transform));
+		dm_alloc(sizeof(struct dce80_transform));
 
 	if (!transform)
 		return NULL;
@@ -413,7 +412,7 @@ static struct transform *dce80_transform_create(
 		return &transform->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, transform);
+	dm_free(transform);
 	return NULL;
 }
 
@@ -423,7 +422,7 @@ static struct input_pixel_processor *dce80_ipp_create(
 	const struct dce110_ipp_reg_offsets *offset)
 {
 	struct dce110_ipp *ipp =
-		dm_alloc(ctx, sizeof(struct dce110_ipp));
+		dm_alloc(sizeof(struct dce110_ipp));
 
 	if (!ipp)
 		return NULL;
@@ -431,9 +430,8 @@ static struct input_pixel_processor *dce80_ipp_create(
 	if (dce80_ipp_construct(ipp, ctx, inst, offset))
 		return &ipp->base;
 
-
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, ipp);
+	dm_free(ipp);
 	return NULL;
 }
 
@@ -441,9 +439,7 @@ struct link_encoder *dce80_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
 	struct dce110_link_encoder *enc110 =
-		dm_alloc(
-		enc_init_data->ctx,
-		sizeof(struct dce110_link_encoder));
+		dm_alloc(sizeof(struct dce110_link_encoder));
 
 	if (!enc110)
 		return NULL;
@@ -457,7 +453,7 @@ struct link_encoder *dce80_link_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(enc_init_data->ctx, enc110);
+	dm_free(enc110);
 	return NULL;
 }
 
@@ -468,7 +464,7 @@ struct clock_source *dce80_clock_source_create(
 	const struct dce110_clk_src_reg_offsets *offsets)
 {
 	struct dce110_clk_src *clk_src =
-		dm_alloc(ctx, sizeof(struct dce110_clk_src));
+		dm_alloc(sizeof(struct dce110_clk_src));
 
 	if (!clk_src)
 		return NULL;
@@ -482,7 +478,7 @@ struct clock_source *dce80_clock_source_create(
 
 void dce80_clock_source_destroy(struct clock_source **clk_src)
 {
-	dm_free((*clk_src)->ctx, TO_DCE110_CLK_SRC(*clk_src));
+	dm_free(TO_DCE110_CLK_SRC(*clk_src));
 	*clk_src = NULL;
 }
 
@@ -501,21 +497,19 @@ void dce80_destruct_resource_pool(struct resource_pool *pool)
 			dce80_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dm_free(pool->mis[i]->ctx,
-					TO_DCE110_MEM_INPUT(pool->mis[i]));
+			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 
 		if (pool->timing_generators[i] != NULL)	{
-			dm_free(pool->timing_generators[i]->ctx, DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dm_free(pool->stream_enc[i]->ctx,
-				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
+			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
 	for (i = 0; i < pool->clk_src_count; i++) {
@@ -1247,8 +1241,7 @@ bool dce80_construct_resource_pool(
 stream_enc_create_fail:
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] != NULL)
-			dm_free(pool->stream_enc[i]->ctx,
-				DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
+			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
 	}
 
 audio_create_fail:
@@ -1269,13 +1262,11 @@ controller_create_fail:
 			dce80_ipp_destroy(&pool->ipps[i]);
 
 		if (pool->mis[i] != NULL) {
-			dm_free(pool->mis[i]->ctx,
-					TO_DCE110_MEM_INPUT(pool->mis[i]));
+			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
 			pool->mis[i] = NULL;
 		}
 		if (pool->timing_generators[i] != NULL)	{
-			dm_free(pool->timing_generators[i]->ctx,
-				DCE110TG_FROM_TG(pool->timing_generators[i]));
+			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
 			pool->timing_generators[i] = NULL;
 		}
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h
index 8b7edb9..158522d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h
@@ -81,5 +81,4 @@ void dce80_stream_encoder_dp_unblank(
 	struct stream_encoder *enc,
 	const struct encoder_unblank_param *param);
 
-
 #endif /* __DC_STREAM_ENCODER_DCE80_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.h
index 06339ed..86de41a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.h
@@ -26,7 +26,6 @@
 #ifndef __DC_TIMING_GENERATOR_DCE80_H__
 #define __DC_TIMING_GENERATOR_DCE80_H__
 
-
 #include "timing_generator.h"
 #include "../include/grph_object_id.h"
 
@@ -44,6 +43,4 @@ void dce80_timing_generator_enable_advanced_request(
 	bool enable,
 	const struct dc_crtc_timing *timing);
 
-
-
 #endif /* __DC_TIMING_GENERATOR_DCE80_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h
index a0fb2d2..b719546 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h
@@ -82,5 +82,4 @@ bool dce80_transform_get_current_pixel_storage_depth(
 	struct transform *xfm,
 	enum lb_pixel_depth *depth);
 
-
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services.h b/drivers/gpu/drm/amd/dal/dc/dm_services.h
index 5ba8be8..d3820f8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services.h
@@ -40,13 +40,9 @@
 
 #undef DEPRECATED
 
-/* if the pointer is not NULL, the allocated memory is zeroed */
-void *dm_alloc(struct dc_context *ctx, uint32_t size);
-
-/* reallocate memory. The contents will remain unchanged.*/
-void *dm_realloc(struct dc_context *ctx, const void *ptr, uint32_t size);
-
-void dm_free(struct dc_context *ctx, void *p);
+#define dm_alloc(size) kzalloc(size, GFP_KERNEL)
+#define dm_realloc(ptr, size) krealloc(ptr, size, GFP_KERNEL)
+#define dm_free(ptr) kfree(ptr)
 
 void dm_memset(void *p, int32_t c, uint32_t count);
 
@@ -249,7 +245,6 @@ bool dm_pp_get_clock_levels_by_type(
 	enum dm_pp_clock_type clk_type,
 	struct dm_pp_clock_levels *clk_level_info);
 
-
 bool dm_pp_apply_safe_state(
 		const struct dc_context *ctx);
 
@@ -268,7 +263,6 @@ bool dm_pp_apply_display_requirements(
 	const struct dc_context *ctx,
 	const struct dm_pp_display_configuration *pp_display_cfg);
 
-
 /****** end of PP interfaces ******/
 
 void dm_sleep_in_milliseconds(struct dc_context *ctx, uint32_t milliseconds);
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
index a74fb85..1e87624 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
@@ -102,7 +102,6 @@ enum { false, true };
 			printf("[DAL_LOG]" fmt, ##__VA_ARGS__); } \
 				while (false)
 
-
 #define dm_debug(fmt, ...) printf("[DAL_DBG]" fmt, ##__VA_ARGS__)
 
 #define dm_vlog(fmt, args) vprintf(fmt, args)
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
index 8ff899c..3e7d42e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
@@ -62,7 +62,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dm_free((*ptr)->ctx, pin);
+	dm_free(pin);
 
 	*ptr = NULL;
 }
@@ -814,7 +814,6 @@ static const struct hw_gpio_pin_funcs funcs = {
 	.close = dal_hw_gpio_close,
 };
 
-
 static bool construct(
 	struct hw_ddc_dce110 *pin,
 	enum gpio_id id,
@@ -864,7 +863,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc_dce110 *pin = dm_alloc(ctx, sizeof(struct hw_ddc_dce110));
+	struct hw_ddc_dce110 *pin = dm_alloc(sizeof(struct hw_ddc_dce110));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -876,7 +875,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, pin);
+	dm_free(pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
index a90115c..f385394 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
@@ -61,7 +61,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dm_free((*ptr)->ctx, pin);
+	dm_free(pin);
 
 	*ptr = NULL;
 }
@@ -348,7 +348,7 @@ struct hw_gpio_pin *dal_hw_hpd_dce110_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_hpd_dce110 *pin = dm_alloc(ctx, sizeof(struct hw_hpd_dce110));
+	struct hw_hpd_dce110 *pin = dm_alloc(sizeof(struct hw_hpd_dce110));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -360,7 +360,7 @@ struct hw_gpio_pin *dal_hw_hpd_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, pin);
+	dm_free(pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
index 850caeb..5776751 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
@@ -72,7 +72,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dm_free((*ptr)->ctx, pin);
+	dm_free(pin);
 
 	*ptr = NULL;
 }
@@ -875,7 +875,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce80_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc_dce80 *pin = dm_alloc(ctx, sizeof(struct hw_ddc_dce80));
+	struct hw_ddc_dce80 *pin = dm_alloc(sizeof(struct hw_ddc_dce80));
 
 	if (!pin) {
 		BREAK_TO_DEBUGGER();
@@ -887,7 +887,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce80_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, pin);
+	dm_free(pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c
index 67b249b..342b3aa 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c
@@ -46,7 +46,6 @@
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
-
 /*
  * This unit
  */
@@ -73,7 +72,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dm_free((*ptr)->ctx, pin);
+	dm_free(pin);
 
 	*ptr = NULL;
 }
@@ -360,7 +359,7 @@ struct hw_gpio_pin *dal_hw_hpd_dce80_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_hpd_dce80 *pin = dm_alloc(ctx, sizeof(struct hw_hpd_dce80));
+	struct hw_hpd_dce80 *pin = dm_alloc(sizeof(struct hw_hpd_dce80));
 
 	if (!pin) {
 		BREAK_TO_DEBUGGER();
@@ -372,7 +371,7 @@ struct hw_gpio_pin *dal_hw_hpd_dce80_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, pin);
+	dm_free(pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c b/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
index c3d8cdb..6eedef6 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
@@ -229,7 +229,7 @@ struct ddc *dal_gpio_create_ddc(
 	if (!service->translate.funcs->offset_to_id(offset, mask, &id, &en))
 		return NULL;
 
-	ddc = dm_alloc(service->ctx, sizeof(struct ddc));
+	ddc = dm_alloc(sizeof(struct ddc));
 
 	if (!ddc) {
 		BREAK_TO_DEBUGGER();
@@ -262,7 +262,7 @@ failure_2:
 	dal_gpio_service_destroy_gpio(&ddc->pin_data);
 
 failure_1:
-	dm_free(service->ctx, ddc);
+	dm_free(ddc);
 
 	return NULL;
 }
@@ -284,7 +284,7 @@ void dal_gpio_destroy_ddc(
 	}
 
 	destruct(*ddc);
-	dm_free((*ddc)->ctx, *ddc);
+	dm_free(*ddc);
 
 	*ddc = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c
index 1dd31d8..6e4bfd2 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_ddc_diag.c
@@ -49,7 +49,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dm_free((*ptr)->ctx, pin);
+	dm_free(pin);
 
 	*ptr = NULL;
 }
@@ -79,7 +79,7 @@ struct hw_gpio_pin *dal_hw_ddc_diag_fpga_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc *pin = dm_alloc(ctx, sizeof(struct hw_ddc));
+	struct hw_ddc *pin = dm_alloc(sizeof(struct hw_ddc));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -91,7 +91,7 @@ struct hw_gpio_pin *dal_hw_ddc_diag_fpga_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, pin);
+	dm_free(pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c
index 019e810..c193f0e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.c
@@ -33,7 +33,6 @@
 #include "../hw_gpio.h"
 #include "../hw_hpd.h"
 
-
 static void destruct(
 	struct hw_hpd *pin)
 {
@@ -47,7 +46,7 @@ static void destroy(
 
 	destruct(pin);
 
-	dm_free((*ptr)->ctx, pin);
+	dm_free(pin);
 
 	*ptr = NULL;
 }
@@ -83,7 +82,7 @@ struct hw_gpio_pin *dal_hw_hpd_diag_fpga_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_hpd *pin = dm_alloc(ctx, sizeof(struct hw_hpd));
+	struct hw_hpd *pin = dm_alloc(sizeof(struct hw_hpd));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -95,7 +94,7 @@ struct hw_gpio_pin *dal_hw_hpd_diag_fpga_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, pin);
+	dm_free(pin);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.h b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.h
index bfa2c24..aa9cd54 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_hpd_diag.h
@@ -26,7 +26,6 @@
 #ifndef __DAL_HW_HPD_DIAG_FPGA_H__
 #define __DAL_HW_HPD_DIAG_FPGA_H__
 
-
 struct hw_gpio_pin *dal_hw_hpd_diag_fpga_create(
 	struct dc_context *ctx,
 	enum gpio_id id,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c
index 177330a..bf90688 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/diagnostics/hw_translate_diag.c
@@ -28,7 +28,6 @@
 
 #include "../hw_translate.h"
 
-
 /* function table */
 static const struct hw_translate_funcs funcs = {
 	.offset_to_id = NULL,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c
index 7e16d63..eeefaa2 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_base.c
@@ -246,7 +246,7 @@ struct gpio *dal_gpio_create(
 	uint32_t en,
 	enum gpio_pin_output_state output_state)
 {
-	struct gpio *gpio = dm_alloc(service->ctx, sizeof(struct gpio));
+	struct gpio *gpio = dm_alloc(sizeof(struct gpio));
 
 	if (!gpio) {
 		ASSERT_CRITICAL(false);
@@ -273,7 +273,7 @@ void dal_gpio_destroy(
 
 	dal_gpio_close(*gpio);
 
-	dm_free((*gpio)->service->ctx, *gpio);
+	dm_free(*gpio);
 
 	*gpio = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
index 6837898..8b4eba9 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
@@ -68,7 +68,7 @@ struct gpio_service *dal_gpio_service_create(
 
 	uint32_t index_of_id;
 
-	service = dm_alloc(ctx, sizeof(struct gpio_service));
+	service = dm_alloc(sizeof(struct gpio_service));
 
 	if (!service) {
 		BREAK_TO_DEBUGGER();
@@ -107,9 +107,7 @@ struct gpio_service *dal_gpio_service_create(
 			if (number_of_bits) {
 				uint32_t index_of_uint = 0;
 
-				slot = dm_alloc(
-					ctx,
-					number_of_uints * sizeof(uint32_t));
+				slot = dm_alloc(number_of_uints * sizeof(uint32_t));
 
 				if (!slot) {
 					BREAK_TO_DEBUGGER();
@@ -141,11 +139,11 @@ failure_2:
 		slot = service->busyness[index_of_id];
 
 		if (slot)
-			dm_free(ctx, slot);
+			dm_free(slot);
 	};
 
 failure_1:
-	dm_free(ctx, service);
+	dm_free(service);
 
 	return NULL;
 }
@@ -243,13 +241,13 @@ void dal_gpio_service_destroy(
 			uint32_t *slot = (*ptr)->busyness[index_of_id];
 
 			if (slot)
-				dm_free((*ptr)->ctx, slot);
+				dm_free(slot);
 
 			++index_of_id;
 		} while (index_of_id < GPIO_ID_COUNT);
 	}
 
-	dm_free((*ptr)->ctx, *ptr);
+	dm_free(*ptr);
 
 	*ptr = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c
index 9c8ff54..63d6b54 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_factory.c
@@ -96,7 +96,7 @@ void dal_hw_factory_destroy(
 		return;
 	}
 
-	dm_free(ctx, *factory);
+	dm_free(*factory);
 
 	*factory = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/irq.c b/drivers/gpu/drm/amd/dal/dc/gpio/irq.c
index debc2ea..bf577f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/irq.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/irq.c
@@ -137,7 +137,7 @@ struct irq *dal_gpio_create_irq(
 		return NULL;
 	}
 
-	irq = dm_alloc(service->ctx, sizeof(struct irq));
+	irq = dm_alloc(sizeof(struct irq));
 
 	if (!irq) {
 		ASSERT_CRITICAL(false);
@@ -153,7 +153,7 @@ struct irq *dal_gpio_create_irq(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(service->ctx, irq);
+	dm_free(irq);
 
 	return NULL;
 }
@@ -174,7 +174,7 @@ void dal_gpio_destroy_irq(
 	}
 
 	destruct(*irq);
-	dm_free((*irq)->ctx, *irq);
+	dm_free(*irq);
 
 	*irq = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c
index a54cc25..36a08a5 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/dc_clock_gating_dce110.c
@@ -46,7 +46,6 @@ static void force_hw_base_light_sleep(struct dc_context *ctx)
 	uint32_t addr = 0;
 	uint32_t value = 0;
 
-
 	addr = mmDC_MEM_GLOBAL_PWR_REQ_CNTL;
 	/* Read the mmDC_MEM_GLOBAL_PWR_REQ_CNTL to get the currently
 	 * programmed DC_MEM_GLOBAL_PWR_REQ_DIS*/
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index 15243de..2ee5773 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -52,7 +52,6 @@ static struct state_dependent_clocks max_clks_by_state[] = {
 /*ClocksStatePerformance*/
 { .display_clk_khz = 643000, .pixel_clk_khz = 400000 } };
 
-
 /* Starting point for each divider range.*/
 enum divider_range_start {
 	DIVIDER_RANGE_01_START = 200, /* 2.00*/
@@ -188,7 +187,6 @@ static uint32_t get_dp_ref_clk_frequency(struct display_clock *dc)
 			DENTIST_DISPCLK_CNTL,
 			DENTIST_DPREFCLK_WDIVIDER));
 
-
 	if (target_div != INVALID_DIVIDER) {
 		/* Calculate the current DFS clock, in kHz.*/
 		dp_ref_clk_khz = (DIVIDER_RANGE_SCALE_FACTOR
@@ -226,14 +224,13 @@ static uint32_t get_dp_ref_clk_frequency(struct display_clock *dc)
 	return dp_ref_clk_khz;
 }
 
-
 static void destroy(struct display_clock **base)
 {
 	struct display_clock_dce110 *dc110;
 
 	dc110 = DCLCK110_FROM_BASE(*base);
 
-	dm_free((*base)->ctx, dc110);
+	dm_free(dc110);
 
 	*base = NULL;
 }
@@ -954,7 +951,7 @@ struct display_clock *dal_display_clock_dce110_create(
 {
 	struct display_clock_dce110 *dc110;
 
-	dc110 = dm_alloc(ctx, sizeof(struct display_clock_dce110));
+	dc110 = dm_alloc(sizeof(struct display_clock_dce110));
 
 	if (dc110 == NULL)
 		return NULL;
@@ -962,7 +959,7 @@ struct display_clock *dal_display_clock_dce110_create(
 	if (dal_display_clock_dce110_construct(dc110, ctx, as))
 		return &dc110->disp_clk_base;
 
-	dm_free(ctx, dc110);
+	dm_free(dc110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
index 760705f..5346ded 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
@@ -51,7 +51,6 @@ static struct state_dependent_clocks max_clks_by_state[] = {
 /* ClocksStatePerformance */
 { .display_clk_khz = 600000, .pixel_clk_khz = 400000 } };
 
-
 /* Starting point for each divider range.*/
 enum divider_range_start {
 	DIVIDER_RANGE_01_START = 200, /* 2.00*/
@@ -240,7 +239,6 @@ static uint32_t calc_single_display_min_clks(
 	uint32_t alt_disp_clk_khz;
 	struct display_clock_dce80 *dc = FROM_DISPLAY_CLOCK(base);
 
-
 	if (0 != params->dest_view.height && 0 != params->dest_view.width) {
 
 		h_scale = dal_fixed32_32_from_fraction(
@@ -258,7 +256,6 @@ static uint32_t calc_single_display_min_clks(
 	v_filter_init = dal_fixed32_32_add(v_filter_init,
 		dal_fixed32_32_from_fraction(15, 10));
 
-
 	v_filter_init_trunc = dal_fixed32_32_floor(v_filter_init);
 
 	v_filter_init_ceil = dal_fixed32_32_from_fraction(
@@ -349,7 +346,6 @@ static uint32_t calc_cursor_bw_for_min_clks(struct min_clock_params *params)
 	struct fixed32_32 src_lines_per_dst_line;
 	struct fixed32_32 cursor_bw;
 
-
 	/*  DCE8 Mode Support and Mode Set Architecture Specification Rev 1.3
 	 6.3.3	Cursor data Throughput requirement on DISPCLK
 	 The MCIF to DCP cursor data return throughput is one pixel per DISPCLK
@@ -428,7 +424,6 @@ static uint32_t calculate_min_clock(
 	uint32_t total_cursor_bw = 0;
 	struct display_clock_dce80 *disp_clk = FROM_DISPLAY_CLOCK(dc);
 
-
 	if (disp_clk->use_max_disp_clk)
 		return min_clk_khz;
 
@@ -635,7 +630,6 @@ static uint32_t get_dp_ref_clk_frequency(struct display_clock *dc)
 			DENTIST_DISPCLK_CNTL,
 			DENTIST_DPREFCLK_WDIVIDER));
 
-
 	if (target_div != INVALID_DIVIDER) {
 		/* Calculate the current DFS clock, in kHz.*/
 		dp_ref_clk_khz = (DIVIDER_RANGE_SCALE_FACTOR
@@ -812,7 +806,7 @@ static void destroy(struct display_clock **dc)
 	struct display_clock_dce80 *disp_clk;
 
 	disp_clk = FROM_DISPLAY_CLOCK(*dc);
-	dm_free((*dc)->ctx, disp_clk);
+	dm_free(disp_clk);
 	*dc = NULL;
 }
 
@@ -911,7 +905,7 @@ struct display_clock *dal_display_clock_dce80_create(
 {
 	struct display_clock_dce80 *disp_clk;
 
-	disp_clk = dm_alloc(ctx, sizeof(struct display_clock_dce80));
+	disp_clk = dm_alloc(sizeof(struct display_clock_dce80));
 
 	if (disp_clk == NULL)
 		return NULL;
@@ -919,7 +913,7 @@ struct display_clock *dal_display_clock_dce80_create(
 	if (display_clock_construct(ctx, disp_clk, as))
 		return &disp_clk->disp_clk;
 
-	dm_free(ctx, disp_clk);
+	dm_free(disp_clk);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.h b/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.h
index 2ec1034..e53522f 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/divider_range.h
@@ -59,5 +59,4 @@ uint32_t dal_divider_range_get_did(
 	uint32_t ranges_num,
 	uint32_t divider);
 
-
 #endif /* __DAL_DIVIDER_RANGE_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
index f9c5543..d2f49b8 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
@@ -92,7 +92,7 @@ static void destroy(
 
 	destruct(engine);
 
-	dm_free((*aux_engine)->base.ctx, engine);
+	dm_free(engine);
 
 	*aux_engine = NULL;
 }
@@ -645,7 +645,6 @@ static enum aux_channel_operation_result get_channel_status(
 			time_elapsed += 10;
 		} while (time_elapsed < aux_engine->timeout_period);
 
-
 	}
 
 	/* Note that the following bits are set in 'status.bits'
@@ -770,7 +769,7 @@ struct aux_engine *dal_aux_engine_dce110_create(
 		return NULL;
 	}
 
-	engine = dm_alloc(aux_init_data->ctx, sizeof(*engine));
+	engine = dm_alloc(sizeof(*engine));
 
 	if (!engine) {
 		ASSERT_CRITICAL(false);
@@ -782,7 +781,7 @@ struct aux_engine *dal_aux_engine_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(aux_init_data->ctx, engine);
+	dm_free(engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
index 2517f44..b43a431 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
@@ -91,7 +91,6 @@ enum {
 #define FROM_ENGINE(ptr) \
 	FROM_I2C_ENGINE(container_of((ptr), struct i2c_engine, base))
 
-
 static void disable_i2c_hw_engine(
 	struct i2c_hw_engine_dce110 *engine)
 {
@@ -242,7 +241,6 @@ static bool setup_engine(
 			DC_I2C_CONTROL,
 			DC_I2C_DDC_SELECT);
 
-
 		dm_write_reg(i2c_engine->base.ctx, addr, value);
 	}
 
@@ -448,7 +446,6 @@ static bool process_transaction(
 			DC_I2C_TRANSACTION0,
 			DC_I2C_START0);
 
-
 		if ((engine->transaction_count == 3) ||
 		(request->action == I2CAUX_TRANSACTION_ACTION_I2C_WRITE) ||
 		(request->action & I2CAUX_TRANSACTION_ACTION_I2C_READ)) {
@@ -792,7 +789,7 @@ static void destroy(
 
 	dal_i2c_hw_engine_destruct(&engine_dce110->base);
 
-	dm_free((*i2c_engine)->base.ctx, engine_dce110);
+	dm_free(engine_dce110);
 
 	*i2c_engine = NULL;
 }
@@ -892,7 +889,6 @@ static bool construct(
 	engine_dce110->addr.DC_I2C_DDCX_SPEED =
 		mmDC_I2C_DDC1_SPEED + ddc_speed_offset[arg->engine_id];
 
-
 	value = dm_read_reg(
 		engine_dce110->base.base.base.ctx,
 		mmMICROSECOND_TIME_BASE_DIV);
@@ -922,7 +918,6 @@ static bool construct(
 	engine_dce110->reference_frequency =
 		(arg->reference_frequency * 2) / xtal_ref_div;
 
-
 	return true;
 }
 
@@ -936,7 +931,7 @@ struct i2c_engine *dal_i2c_hw_engine_dce110_create(
 		return NULL;
 	}
 
-	engine_dce10 = dm_alloc(arg->ctx, sizeof(struct i2c_hw_engine_dce110));
+	engine_dce10 = dm_alloc(sizeof(struct i2c_hw_engine_dce110));
 
 	if (!engine_dce10) {
 		ASSERT_CRITICAL(false);
@@ -948,7 +943,7 @@ struct i2c_engine *dal_i2c_hw_engine_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(arg->ctx, engine_dce10);
+	dm_free(engine_dce10);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c
index f060b25..0a339b8 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_sw_engine_dce110.c
@@ -88,7 +88,7 @@ static void destroy(
 
 	destruct(sw_engine);
 
-	dm_free((*engine)->base.ctx, sw_engine);
+	dm_free(sw_engine);
 
 	*engine = NULL;
 }
@@ -154,7 +154,7 @@ struct i2c_engine *dal_i2c_sw_engine_dce110_create(
 		return NULL;
 	}
 
-	engine_dce110 = dm_alloc(arg->ctx, sizeof(struct i2c_sw_engine_dce110));
+	engine_dce110 = dm_alloc(sizeof(struct i2c_sw_engine_dce110));
 
 	if (!engine_dce110) {
 		ASSERT_CRITICAL(false);
@@ -166,7 +166,7 @@ struct i2c_engine *dal_i2c_sw_engine_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(arg->ctx, engine_dce110);
+	dm_free(engine_dce110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
index 9c88762..2470c77 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
@@ -68,7 +68,7 @@ static void destroy(
 
 	destruct(i2caux_dce110);
 
-	dm_free((*i2c_engine)->ctx, i2caux_dce110);
+	dm_free(i2caux_dce110);
 
 	*i2c_engine = NULL;
 }
@@ -248,7 +248,7 @@ struct i2caux *dal_i2caux_dce110_create(
 	struct dc_context *ctx)
 {
 	struct i2caux_dce110 *i2caux_dce110 =
-		dm_alloc(ctx, sizeof(struct i2caux_dce110));
+		dm_alloc(sizeof(struct i2caux_dce110));
 
 	if (!i2caux_dce110) {
 		ASSERT_CRITICAL(false);
@@ -260,7 +260,7 @@ struct i2caux *dal_i2caux_dce110_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, i2caux_dce110);
+	dm_free(i2caux_dce110);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/aux_engine_dce80.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/aux_engine_dce80.c
index a4fc2cd..b732860 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/aux_engine_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/aux_engine_dce80.c
@@ -45,7 +45,6 @@
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
-
 /*
  * This unit
  */
@@ -94,7 +93,7 @@ static void destroy(
 
 	destruct(engine);
 
-	dm_free((*aux_engine)->base.ctx, engine);
+	dm_free(engine);
 
 	*aux_engine = NULL;
 }
@@ -599,7 +598,6 @@ static enum aux_channel_operation_result get_channel_status(
 			time_elapsed += 10;
 		} while (time_elapsed < aux_engine->timeout_period);
 
-
 	}
 
 	/* Note that the following bits are set in 'status.bits'
@@ -722,7 +720,7 @@ struct aux_engine *dal_aux_engine_dce80_create(
 		return NULL;
 	}
 
-	engine = dm_alloc(arg->ctx, sizeof(struct aux_engine_dce80));
+	engine = dm_alloc(sizeof(struct aux_engine_dce80));
 
 	if (!engine) {
 		BREAK_TO_DEBUGGER();
@@ -734,7 +732,7 @@ struct aux_engine *dal_aux_engine_dce80_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(arg->ctx, engine);
+	dm_free(engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_hw_engine_dce80.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_hw_engine_dce80.c
index 3d61963..bce2b94 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_hw_engine_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_hw_engine_dce80.c
@@ -206,7 +206,7 @@ static void destroy(
 
 	destruct(engine);
 
-	dm_free((*i2c_engine)->base.ctx, engine);
+	dm_free(engine);
 
 	*i2c_engine = NULL;
 }
@@ -259,7 +259,6 @@ static bool setup_engine(
 			DC_I2C_CONTROL,
 			DC_I2C_DDC_SELECT);
 
-
 		dm_write_reg(i2c_engine->base.ctx, addr, value);
 	}
 
@@ -450,7 +449,6 @@ static bool process_transaction(
 			DC_I2C_TRANSACTION0,
 			DC_I2C_START0);
 
-
 		if ((engine->transaction_count == 3) ||
 		(request->action == I2CAUX_TRANSACTION_ACTION_I2C_WRITE) ||
 		(request->action & I2CAUX_TRANSACTION_ACTION_I2C_READ)) {
@@ -883,7 +881,7 @@ struct i2c_engine *dal_i2c_hw_engine_dce80_create(
 		return NULL;
 	}
 
-	engine = dm_alloc(arg->ctx, sizeof(struct i2c_hw_engine_dce80));
+	engine = dm_alloc(sizeof(struct i2c_hw_engine_dce80));
 
 	if (!engine) {
 		BREAK_TO_DEBUGGER();
@@ -895,7 +893,7 @@ struct i2c_engine *dal_i2c_hw_engine_dce80_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(arg->ctx, engine);
+	dm_free(engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_sw_engine_dce80.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_sw_engine_dce80.c
index e5135c5..5f2f298 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_sw_engine_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2c_sw_engine_dce80.c
@@ -60,7 +60,6 @@ static const uint32_t ddc_hw_status_addr[] = {
 	mmDC_I2C_DDCVGA_HW_STATUS
 };
 
-
 /*
  * @brief
  * Cast 'struct i2c_sw_engine *'
@@ -104,12 +103,11 @@ static void destroy(
 
 	destruct(sw_engine);
 
-	dm_free((*engine)->base.ctx, sw_engine);
+	dm_free(sw_engine);
 
 	*engine = NULL;
 }
 
-
 static bool acquire_engine(
 	struct i2c_engine *engine,
 	struct ddc *ddc_handle)
@@ -168,7 +166,7 @@ struct i2c_engine *dal_i2c_sw_engine_dce80_create(
 		return NULL;
 	}
 
-	engine = dm_alloc(arg->ctx, sizeof(struct i2c_sw_engine_dce80));
+	engine = dm_alloc(sizeof(struct i2c_sw_engine_dce80));
 
 	if (!engine) {
 		BREAK_TO_DEBUGGER();
@@ -180,7 +178,7 @@ struct i2c_engine *dal_i2c_sw_engine_dce80_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(arg->ctx, engine);
+	dm_free(engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
index 4abf488..1ed6196 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
@@ -51,7 +51,6 @@
 #include "../aux_engine.h"
 #include "aux_engine_dce80.h"
 
-
 /*
  * This unit
  */
@@ -72,7 +71,7 @@ static void destroy(
 
 	destruct(i2caux_dce80);
 
-	dm_free((*i2c_engine)->ctx, i2caux_dce80);
+	dm_free(i2caux_dce80);
 
 	*i2c_engine = NULL;
 }
@@ -246,7 +245,7 @@ struct i2caux *dal_i2caux_dce80_create(
 	struct dc_context *ctx)
 {
 	struct i2caux_dce80 *i2caux_dce80 =
-		dm_alloc(ctx, sizeof(struct i2caux_dce80));
+		dm_alloc(sizeof(struct i2caux_dce80));
 
 	if (!i2caux_dce80) {
 		BREAK_TO_DEBUGGER();
@@ -258,7 +257,7 @@ struct i2caux *dal_i2caux_dce80_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(ctx, i2caux_dce80);
+	dm_free(i2caux_dce80);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c b/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c
index f4bc39d..027b207 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/diagnostics/i2caux_diag.c
@@ -59,13 +59,11 @@ static void destroy(
 {
 	destruct(*i2c_engine);
 
-	dm_free((*i2c_engine)->ctx, *i2c_engine);
+	dm_free(*i2c_engine);
 
 	*i2c_engine = NULL;
 }
 
-
-
 /* function table */
 static const struct i2caux_funcs i2caux_funcs = {
 	.destroy = destroy,
@@ -94,7 +92,7 @@ struct i2caux *dal_i2caux_diag_fpga_create(
 	struct adapter_service *as,
 	struct dc_context *ctx)
 {
-	struct i2caux *i2caux =	dm_alloc(ctx, sizeof(struct i2caux));
+	struct i2caux *i2caux =	dm_alloc(sizeof(struct i2caux));
 
 	if (!i2caux) {
 		ASSERT_CRITICAL(false);
@@ -106,7 +104,7 @@ struct i2caux *dal_i2caux_diag_fpga_create(
 
 	ASSERT_CRITICAL(false);
 
-	dm_free(ctx, i2caux);
+	dm_free(i2caux);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
index 21e8fa2..2ee5118 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
@@ -542,7 +542,7 @@ static void destroy(
 {
 	dal_i2c_sw_engine_destruct(FROM_I2C_ENGINE(*ptr));
 
-	dm_free((*ptr)->base.ctx, *ptr);
+	dm_free(*ptr);
 	*ptr = NULL;
 }
 
@@ -584,8 +584,6 @@ bool dal_i2c_sw_engine_construct(
 	return true;
 }
 
-
-
 struct i2c_engine *dal_i2c_sw_engine_create(
 	const struct i2c_sw_engine_create_arg *arg)
 {
@@ -596,7 +594,7 @@ struct i2c_engine *dal_i2c_sw_engine_create(
 		return NULL;
 	}
 
-	engine = dm_alloc(arg->ctx, sizeof(struct i2c_sw_engine));
+	engine = dm_alloc(sizeof(struct i2c_sw_engine));
 
 	if (!engine) {
 		BREAK_TO_DEBUGGER();
@@ -608,7 +606,7 @@ struct i2c_engine *dal_i2c_sw_engine_create(
 
 	BREAK_TO_DEBUGGER();
 
-	dm_free(arg->ctx, engine);
+	dm_free(engine);
 
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/bandwidth_calcs.h b/drivers/gpu/drm/amd/dal/dc/inc/bandwidth_calcs.h
index 0d228ed..2adad08 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/bandwidth_calcs.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/bandwidth_calcs.h
@@ -230,7 +230,6 @@ struct bw_calcs_mode_data_internal {
 	enum bw_defines d2_graphics_stereo_mode;
 };
 
-
 struct bw_calcs_input_single_display {
 	uint32_t graphics_rotation_angle;
 	uint32_t underlay_rotation_angle;
@@ -484,7 +483,6 @@ struct bw_calcs_output {
 	int32_t required_blackout_duration_us;
 };
 
-
 /**
  * Initialize structures with data which will NOT change at runtime.
  */
@@ -505,6 +503,5 @@ bool bw_calcs(
 	const struct bw_calcs_mode_data *mode_data,
 	struct bw_calcs_output *calcs_output);
 
-
 #endif /* __BANDWIDTH_CALCS_H__ */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/bw_fixed.h b/drivers/gpu/drm/amd/dal/dc/inc/bw_fixed.h
index ff271cc..b31d07a 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/bw_fixed.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/bw_fixed.h
@@ -60,5 +60,4 @@ bool bw_meq(const struct bw_fixed arg1, const struct bw_fixed arg2);
 bool bw_ltn(const struct bw_fixed arg1, const struct bw_fixed arg2);
 bool bw_mtn(const struct bw_fixed arg1, const struct bw_fixed arg2);
 
-
 #endif //BW_FIXED_H_
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 4b9ce6a..be3a693 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -55,7 +55,6 @@ struct core_target {
 #define DC_GAMMA_TO_CORE(dc_gamma) \
 	container_of(dc_gamma, struct core_gamma, public)
 
-
 struct core_surface {
 	struct dc_surface public;
 	struct dc_surface_status status;
@@ -99,7 +98,6 @@ struct core_stream {
 	struct dc_stream_status status;
 };
 
-
 /************ core_sink *****************/
 
 #define DC_SINK_TO_CORE(dc_sink) \
@@ -349,5 +347,4 @@ struct validate_context {
 	struct dm_pp_display_configuration pp_display_cfg;
 };
 
-
 #endif /* _CORE_TYPES_H_ */
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/ipp.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/ipp.h
index 505bf72..f419331 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/ipp.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/ipp.h
@@ -1,4 +1,3 @@
-
 /*
  * Copyright 2015 Advanced Micro Devices, Inc.
  *
@@ -61,7 +60,6 @@ enum ipp_degamma_mode {
 	IPP_DEGAMMA_MODE_USER_PWL
 };
 
-
 enum ovl_color_space {
 	OVL_COLOR_SPACE_UNKNOWN = 0,
 	OVL_COLOR_SPACE_RGB,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
index 1c9b732..1c6bab3 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
@@ -88,8 +88,6 @@ struct bit_depth_reduction_params {
 	uint32_t g_seed_value;
 };
 
-
-
 enum wide_gamut_regamma_mode {
 	/*  0x0  - BITS2:0 Bypass */
 	WIDE_GAMUT_REGAMMA_MODE_GRAPHICS_BYPASS,
@@ -255,7 +253,6 @@ struct opp_grph_csc_adjustment {
 	int32_t grph_hue;
 };
 
-
 /* Underlay related types */
 
 struct hw_adjustment_range {
@@ -318,7 +315,6 @@ struct opp_funcs {
 			enum ovl_csc_adjust_item overlay_adjust_item,
 			struct hw_adjustment_range *range);
 
-
 	void (*opp_destroy)(struct output_pixel_processor **opp);
 };
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
index 47cf6de..87a1343 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
@@ -12,7 +12,6 @@ struct dc_bios;
 struct dc_context;
 struct dc_crtc_timing;
 
-
 struct encoder_info_packet {
 	bool valid;
 	uint8_t hb0;
@@ -45,7 +44,6 @@ struct encoder_set_dp_phy_pattern_param {
 	enum dp_panel_mode dp_panel_mode;
 };
 
-
 struct stream_encoder {
 	struct stream_encoder_funcs *funcs;
 	struct dc_context *ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
index 374e222..25f2417 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
@@ -44,7 +44,6 @@ struct crtc_position {
 	uint32_t nominal_vcount;
 };
 
-
 enum dcp_gsl_purpose {
 	DCP_GSL_PURPOSE_SURFACE_FLIP = 0,
 	DCP_GSL_PURPOSE_STEREO3D_PHASE,
@@ -110,7 +109,6 @@ struct timing_generator {
 	struct dc_context *ctx;
 };
 
-
 struct dc_crtc_timing;
 
 struct timing_generator_funcs {
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
index bf84f96..c0fd26b 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
@@ -46,7 +46,6 @@ enum lb_pixel_depth {
 	LB_PIXEL_DEPTH_36BPP = 8
 };
 
-
 enum raw_gamma_ramp_type {
        GAMMA_RAMP_TYPE_UNINITIALIZED,
        GAMMA_RAMP_TYPE_DEFAULT,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 2571691..490ee10 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -35,7 +35,6 @@ enum pipe_gating_control {
 	PIPE_GATING_CONTROL_INIT
 };
 
-
 struct hw_sequencer_funcs {
 
 	enum dc_status (*apply_ctx_to_hw)(
@@ -71,7 +70,6 @@ struct hw_sequencer_funcs {
 	void (*encoder_set_lcd_backlight_level)(
 		struct link_encoder *enc, uint32_t level);
 
-
 	void (*crtc_switch_to_clk_src)(struct clock_source *, uint8_t);
 
 	/* power management */
@@ -118,5 +116,4 @@ bool dc_construct_hw_sequencer(
 				struct adapter_service *adapter_serv,
 				struct core_dc *dc);
 
-
 #endif /* __DC_HW_SEQUENCER_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c b/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
index 4085b6f..ff40f5c 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/irq/dce110/irq_service_dce110.c
@@ -376,7 +376,7 @@ bool construct(
 struct irq_service *dal_irq_service_dce110_create(
 	struct irq_service_init_data *init_data)
 {
-	struct irq_service *irq_service = dm_alloc(init_data->ctx, sizeof(*irq_service));
+	struct irq_service *irq_service = dm_alloc(sizeof(*irq_service));
 
 	if (!irq_service)
 		return NULL;
@@ -384,6 +384,6 @@ struct irq_service *dal_irq_service_dce110_create(
 	if (construct(irq_service, init_data))
 		return irq_service;
 
-	dm_free(init_data->ctx, irq_service);
+	dm_free(irq_service);
 	return NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c b/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c
index 3e2f232..cde34ce 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/irq/irq_service.c
@@ -81,7 +81,7 @@ void dal_irq_service_destroy(struct irq_service **irq_service)
 		return;
 	}
 
-	dm_free((*irq_service)->ctx, *irq_service);
+	dm_free(*irq_service);
 
 	*irq_service = NULL;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/irq_types.h b/drivers/gpu/drm/amd/dal/dc/irq_types.h
index 35a0991..1f62e52 100644
--- a/drivers/gpu/drm/amd/dal/dc/irq_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/irq_types.h
@@ -33,7 +33,6 @@ typedef void (*interrupt_handler)(void *);
 typedef void *irq_handler_idx;
 #define DAL_INVALID_IRQ_HANDLER_IDX NULL
 
-
 /* The order of the IRQ sources is important and MUST match the one's
 of base driver */
 enum dc_irq_source {
diff --git a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.h
index e44713f..eb1a94f 100644
--- a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_link_encoder.h
@@ -31,5 +31,4 @@
 bool virtual_link_encoder_construct(
 	struct link_encoder *enc, const struct encoder_init_data *init_data);
 
-
 #endif /* __DC_VIRTUAL_LINK_ENCODER_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
index 4f5271b..33f4ef9 100644
--- a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
@@ -109,7 +109,7 @@ bool virtual_stream_encoder_construct(
 struct stream_encoder *virtual_stream_encoder_create(
 	struct dc_context *ctx, struct dc_bios *bp)
 {
-	struct stream_encoder *enc = dm_alloc(ctx, sizeof(*enc));
+	struct stream_encoder *enc = dm_alloc(sizeof(*enc));
 
 	if (!enc)
 		return NULL;
@@ -118,7 +118,7 @@ struct stream_encoder *virtual_stream_encoder_create(
 		return enc;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(ctx, enc);
+	dm_free(enc);
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
index 8ebbe65..a4b37ff 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
@@ -39,7 +39,6 @@
 struct i2caux;
 struct adapter_service;
 
-
 /*
  * enum adapter_feature_id
  *
@@ -345,7 +344,6 @@ bool dal_adapter_service_get_firmware_info(
 	struct adapter_service *as,
 	struct firmware_info *info);
 
-
 /* functions to get a total number of objects of specific type */
 uint8_t dal_adapter_service_get_connectors_num(
 	struct adapter_service *as);
@@ -585,7 +583,6 @@ struct ddc *dal_adapter_service_obtain_ddc_from_i2c_info(
 struct bdf_info dal_adapter_service_get_adapter_info(
 	struct adapter_service *as);
 
-
 /* Determine if this ASIC needs to wait on PLL lock bit */
 bool dal_adapter_service_should_psr_skip_wait_for_pll_lock(
 	struct adapter_service *as);
diff --git a/drivers/gpu/drm/amd/dal/include/asic_capability_interface.h b/drivers/gpu/drm/amd/dal/include/asic_capability_interface.h
index bdeaaf9..b5335d1 100644
--- a/drivers/gpu/drm/amd/dal/include/asic_capability_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/asic_capability_interface.h
@@ -32,7 +32,6 @@
 /* Forward declaration */
 struct hw_asic_id;
 
-
 /* ASIC capability */
 struct asic_capability {
 	struct dc_context *ctx;
@@ -43,7 +42,6 @@ struct asic_capability {
 	uint32_t data[ASIC_DATA_MAX_NUMBER];
 };
 
-
 /**
  * Interfaces
  */
diff --git a/drivers/gpu/drm/amd/dal/include/asic_capability_types.h b/drivers/gpu/drm/amd/dal/include/asic_capability_types.h
index 1cb9776..56fdcd8 100644
--- a/drivers/gpu/drm/amd/dal/include/asic_capability_types.h
+++ b/drivers/gpu/drm/amd/dal/include/asic_capability_types.h
@@ -55,7 +55,6 @@ struct asic_caps {
 	bool SUPPORT_8BPP:1;
 };
 
-
 /*
  * ASIC Stereo 3D Caps
  */
@@ -69,7 +68,6 @@ struct asic_stereo_3d_caps {
 	bool INTERLEAVE:1;
 };
 
-
 /*
  * ASIC Bugs
  */
@@ -81,7 +79,6 @@ struct asic_bugs {
 	bool PSR_WA_OVERSCAN_CRC_ERROR:1;
 };
 
-
 /*
  * ASIC Data
  */
@@ -115,7 +112,6 @@ enum asic_data {
 	ASIC_DATA_MAX_NUMBER /* end of enum */
 };
 
-
 /*
  * ASIC Feature Flags
  */
diff --git a/drivers/gpu/drm/amd/dal/include/audio_interface.h b/drivers/gpu/drm/amd/dal/include/audio_interface.h
index bf21762..ef740a2 100644
--- a/drivers/gpu/drm/amd/dal/include/audio_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/audio_interface.h
@@ -80,7 +80,6 @@ bool dal_audio_is_output_signal_supported(
 	struct audio *audio,
 	enum signal_type signal);
 
-
 /***** programming interface *****/
 
 /* perform power up sequence (boot up, resume, recovery) */
@@ -131,7 +130,6 @@ enum audio_result dal_audio_mute(
 	enum engine_id engine_id,
 	enum signal_type signal);
 
-
 /***** information interface *****/
 
 struct audio_feature_support dal_audio_get_supported_features(
diff --git a/drivers/gpu/drm/amd/dal/include/audio_types.h b/drivers/gpu/drm/amd/dal/include/audio_types.h
index 54f5546..8f1eda1 100644
--- a/drivers/gpu/drm/amd/dal/include/audio_types.h
+++ b/drivers/gpu/drm/amd/dal/include/audio_types.h
@@ -33,7 +33,6 @@
 #define MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS 18
 #define MULTI_CHANNEL_SPLIT_NO_ASSO_INFO 0xFFFFFFFF
 
-
 struct audio_pll_hw_settings {
 	uint32_t feed_back_divider;
 	uint32_t step_size_integer;
@@ -154,7 +153,6 @@ struct audio_info_flags {
 	};
 };
 
-
 /*struct audio_info_flags {
 	struct audio_speaker_flags {
 		uint32_t FL_FR:1;
diff --git a/drivers/gpu/drm/amd/dal/include/dal_asic_id.h b/drivers/gpu/drm/amd/dal/include/dal_asic_id.h
index 78f88b1..d8c4cd1 100644
--- a/drivers/gpu/drm/amd/dal/include/dal_asic_id.h
+++ b/drivers/gpu/drm/amd/dal/include/dal_asic_id.h
@@ -105,7 +105,6 @@
 #define DEVICE_ID_TEMASH_9839 0x9839
 #define DEVICE_ID_TEMASH_983D 0x983D
 
-
 /* Asic Family IDs for different asic family. */
 #define FAMILY_CI 120 /* Sea Islands: Hawaii (P), Bonaire (M) */
 #define FAMILY_KV 125 /* Fusion => Kaveri: Spectre, Spooky; Kabini: Kalindi */
diff --git a/drivers/gpu/drm/amd/dal/include/dal_register_logger.h b/drivers/gpu/drm/amd/dal/include/dal_register_logger.h
index 176d811..00dfcd7 100644
--- a/drivers/gpu/drm/amd/dal/include/dal_register_logger.h
+++ b/drivers/gpu/drm/amd/dal/include/dal_register_logger.h
@@ -35,7 +35,6 @@ void dal_reg_logger_push(const char *caller_func);
 /* dal_reg_logger_pop - stop Register Logging */
 void dal_reg_logger_pop(void);
 
-
 /* for internal use of the Logger only */
 void dal_reg_logger_rw_count_increment(void);
 bool dal_reg_logger_should_dump_register(void);
diff --git a/drivers/gpu/drm/amd/dal/include/ddc_service_types.h b/drivers/gpu/drm/amd/dal/include/ddc_service_types.h
index 63dbbc5..0a6ba91 100644
--- a/drivers/gpu/drm/amd/dal/include/ddc_service_types.h
+++ b/drivers/gpu/drm/amd/dal/include/ddc_service_types.h
@@ -52,7 +52,6 @@ enum ddc_service_type {
 	DDC_SERVICE_TYPE_DISPLAY_PORT_MST,
 };
 
-
 enum dcs_dpcd_revision {
 	DCS_DPCD_REV_10 = 0x10,
 	DCS_DPCD_REV_11 = 0x11,
@@ -110,7 +109,6 @@ struct display_sink_capability {
 	enum signal_type signal;
 };
 
-
 struct av_sync_data {
 	uint8_t av_granularity;/* DPCD 00023h */
 	uint8_t aud_dec_lat1;/* DPCD 00024h */
diff --git a/drivers/gpu/drm/amd/dal/include/display_clock_interface.h b/drivers/gpu/drm/amd/dal/include/display_clock_interface.h
index a621930..a625e24 100644
--- a/drivers/gpu/drm/amd/dal/include/display_clock_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/display_clock_interface.h
@@ -194,5 +194,4 @@ uint32_t dal_display_clock_get_dfs_bypass_threshold(
 void dal_display_clock_invalid_clock_state(
 	struct display_clock *disp_clk);
 
-
 #endif /* __DISPLAY_CLOCK_INTERFACE_H__ */
diff --git a/drivers/gpu/drm/amd/dal/include/dpcd_defs.h b/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
index 2e9672b..59677ed 100644
--- a/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
+++ b/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
@@ -747,7 +747,6 @@ union dp_downstream_port_present {
 	} fields;
 };
 
-
 union dwnstream_port_caps_byte3_dvi {
 	struct {
 		uint8_t RESERVED1:1;
diff --git a/drivers/gpu/drm/amd/dal/include/fixed31_32.h b/drivers/gpu/drm/amd/dal/include/fixed31_32.h
index 507f9f6..05f04a6 100644
--- a/drivers/gpu/drm/amd/dal/include/fixed31_32.h
+++ b/drivers/gpu/drm/amd/dal/include/fixed31_32.h
@@ -385,5 +385,4 @@ uint32_t dal_fixed31_32_u2d19(
 uint32_t dal_fixed31_32_u0d19(
 	struct fixed31_32 arg);
 
-
 #endif
diff --git a/drivers/gpu/drm/amd/dal/include/gpio_types.h b/drivers/gpu/drm/amd/dal/include/gpio_types.h
index 62548d6..8b2db41 100644
--- a/drivers/gpu/drm/amd/dal/include/gpio_types.h
+++ b/drivers/gpu/drm/amd/dal/include/gpio_types.h
@@ -329,7 +329,6 @@ struct gpio_config_data {
 	} config;
 };
 
-
 struct gpio_ddc_open_options {
 	bool en_bit_present;
 };
diff --git a/drivers/gpu/drm/amd/dal/include/grph_object_ctrl_defs.h b/drivers/gpu/drm/amd/dal/include/grph_object_ctrl_defs.h
index fe65b18..7df01ff 100644
--- a/drivers/gpu/drm/amd/dal/include/grph_object_ctrl_defs.h
+++ b/drivers/gpu/drm/amd/dal/include/grph_object_ctrl_defs.h
@@ -151,7 +151,6 @@ struct graphics_object_i2c_info {
 	uint32_t i2c_slave_address;
 };
 
-
 struct graphics_object_hpd_info {
 	uint8_t hpd_int_gpio_uid;
 	uint8_t hpd_active;
@@ -335,7 +334,6 @@ struct transmitter_configuration {
 	struct transmitter_configuration_info secondary_transmitter_config;
 };
 
-
 /* These size should be sufficient to store info coming from BIOS */
 #define NUMBER_OF_UCHAR_FOR_GUID 16
 #define MAX_NUMBER_OF_EXT_DISPLAY_PATH 7
diff --git a/drivers/gpu/drm/amd/dal/include/grph_object_defs.h b/drivers/gpu/drm/amd/dal/include/grph_object_defs.h
index a1e468f..a7c42f0 100644
--- a/drivers/gpu/drm/amd/dal/include/grph_object_defs.h
+++ b/drivers/gpu/drm/amd/dal/include/grph_object_defs.h
@@ -215,7 +215,6 @@ struct static_screen_events {
 	};
 };
 
-
 /*
  * ***************************************************************
  * ********************* Register programming sequences ********
diff --git a/drivers/gpu/drm/amd/dal/include/grph_object_id.h b/drivers/gpu/drm/amd/dal/include/grph_object_id.h
index 4c8079c..64b113b 100644
--- a/drivers/gpu/drm/amd/dal/include/grph_object_id.h
+++ b/drivers/gpu/drm/amd/dal/include/grph_object_id.h
@@ -111,7 +111,6 @@ enum clock_source_id {
 	CLOCK_SOURCE_COMBO_DISPLAY_PLL0
 };
 
-
 /* Encoder object ids */
 enum encoder_id {
 	ENCODER_ID_UNKNOWN = 0,
@@ -146,7 +145,6 @@ enum encoder_id {
 	ENCODER_ID_INTERNAL_VIRTUAL,
 };
 
-
 /* Connector object ids */
 enum connector_id {
 	CONNECTOR_ID_UNKNOWN = 0,
@@ -261,7 +259,6 @@ bool dal_graphics_object_id_is_equal(
 uint32_t dal_graphics_object_id_to_uint(
 	struct graphics_object_id id);
 
-
 enum controller_id dal_graphics_object_id_get_controller_id(
 	struct graphics_object_id id);
 enum clock_source_id dal_graphics_object_id_get_clock_source_id(
diff --git a/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h b/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h
index 9e32674..76c551c 100644
--- a/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h
+++ b/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h
@@ -232,8 +232,6 @@ struct hw_stereo_mixer_params {
 	bool single_pipe;
 };
 
-
-
 struct hw_action_flags {
 	uint32_t RESYNC_PATH:1;
 	uint32_t TIMING_CHANGED:1;
@@ -281,14 +279,12 @@ struct hw_info_frame {
 	struct hw_info_packet vsc_packet;
 };
 
-
 enum channel_command_type {
 	CHANNEL_COMMAND_I2C,
 	CHANNEL_COMMAND_I2C_OVER_AUX,
 	CHANNEL_COMMAND_AUX
 };
 
-
 /* maximum TMDS transmitter pixel clock is 165 MHz. So it is KHz */
 #define	TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
 #define	NATIVE_HDMI_MAX_PIXEL_CLOCK_IN_KHZ 297000
diff --git a/drivers/gpu/drm/amd/dal/include/i2caux_interface.h b/drivers/gpu/drm/amd/dal/include/i2caux_interface.h
index ac16fa0..17c7768 100644
--- a/drivers/gpu/drm/amd/dal/include/i2caux_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/i2caux_interface.h
@@ -29,7 +29,6 @@
 #include "ddc_interface.h"
 #include "adapter_service_interface.h"
 
-
 #define DEFAULT_AUX_MAX_DATA_SIZE 16
 #define AUX_MAX_DEFER_WRITE_RETRY 20
 
diff --git a/drivers/gpu/drm/amd/dal/include/logger_interface.h b/drivers/gpu/drm/amd/dal/include/logger_interface.h
index 4d945ea..e4e6b3a 100644
--- a/drivers/gpu/drm/amd/dal/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/logger_interface.h
@@ -36,7 +36,6 @@ union logger_flags;
  * TODO: This logger functionality needs to be implemented and reworked.
  */
 
-
 /*
  *
  * DAL logger functionality
diff --git a/drivers/gpu/drm/amd/dal/include/logger_types.h b/drivers/gpu/drm/amd/dal/include/logger_types.h
index 6147999..759542a 100644
--- a/drivers/gpu/drm/amd/dal/include/logger_types.h
+++ b/drivers/gpu/drm/amd/dal/include/logger_types.h
@@ -26,12 +26,10 @@
 #ifndef __DAL_LOGGER_TYPES_H__
 #define __DAL_LOGGER_TYPES_H__
 
-
 /*
  * TODO: This logger functionality needs to be implemented and reworked.
  */
 
-
 struct dal_logger;
 
 enum log_major {
@@ -75,7 +73,6 @@ enum log_major {
 *        of log message per LogMajor
 */
 
-
 enum log_minor {
 
 	/* Special case for 'all' checkbox */
diff --git a/drivers/gpu/drm/amd/dal/include/set_mode_types.h b/drivers/gpu/drm/amd/dal/include/set_mode_types.h
index 97160fe..93aa534 100644
--- a/drivers/gpu/drm/amd/dal/include/set_mode_types.h
+++ b/drivers/gpu/drm/amd/dal/include/set_mode_types.h
@@ -28,7 +28,6 @@
 
 #include "dc_types.h"
 
-
 /* GTC group number */
 enum gtc_group {
 	GTC_GROUP_DISABLED,
@@ -135,8 +134,6 @@ struct info_frame {
 	struct info_packet spd_info_packet;
 };
 
-
-
 #pragma pack(pop)
 
 #endif /* __DAL_SET_MODE_TYPES_H__ */
-- 
2.7.4

