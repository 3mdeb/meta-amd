From d8b4073090d3a65d39cdbf0c788ffbf48c33bf8c Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 27 Jul 2017 09:33:33 -0400
Subject: [PATCH 2783/2831] drm/amd/display: Rename dc_stream to
 dc_stream_state

find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
-o -name "*.cpp" -o -name "*.hpp" | \
xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'

find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
-o -name "*.cpp" -o -name "*.hpp" | \
xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'

find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
-o -name "*.cpp" -o -name "*.hpp" | \
xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'

Plus some manual changes

Change-Id: I355da33290bb0b4060540a198a1e38261b1ba939
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>

 Conflicts:
    drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
Signed-off-by: Raveendra Talabattula <raveendra.talabattula@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h           |   2 +-
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c  | 332 +++++++++++----------
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h  |   4 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c  |   6 +-
 drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c   |  20 +-
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |  52 ++--
 drivers/gpu/drm/amd/display/dc/core/dc.c           | 168 +++++------
 drivers/gpu/drm/amd/display/dc/core/dc_debug.c     | 188 ++++++------
 drivers/gpu/drm/amd/display/dc/core/dc_link.c      |  18 +-
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c   |   2 +-
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  | 258 ++++++++--------
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |  34 +--
 drivers/gpu/drm/amd/display/dc/core/dc_surface.c   |  74 ++---
 drivers/gpu/drm/amd/display/dc/dc.h                |  92 +++---
 drivers/gpu/drm/amd/display/dc/dc_types.h          |   2 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c     |   4 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h     |   2 +-
 .../gpu/drm/amd/display/dc/dce/dce_link_encoder.c  |   2 +-
 .../gpu/drm/amd/display/dc/dce/dce_link_encoder.h  |   2 +-
 .../drm/amd/display/dc/dce100/dce100_resource.c    |  12 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    | 141 +++++----
 .../drm/amd/display/dc/dce110/dce110_resource.c    |  28 +-
 .../drm/amd/display/dc/dce112/dce112_resource.c    |  16 +-
 .../drm/amd/display/dc/dce112/dce112_resource.h    |   2 +-
 .../drm/amd/display/dc/dce120/dce120_resource.c    |   2 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |  12 +-
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  | 148 ++++-----
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |  12 +-
 drivers/gpu/drm/amd/display/dc/dm_helpers.h        |   6 +-
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |  15 +-
 drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h    |   4 +-
 .../gpu/drm/amd/display/dc/inc/hw/link_encoder.h   |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h  |   6 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h      |  15 +-
 .../amd/display/dc/virtual/virtual_link_encoder.c  |   2 +-
 .../gpu/drm/amd/display/include/logger_interface.h |   2 +-
 .../drm/amd/display/modules/freesync/freesync.c    |  50 ++--
 .../gpu/drm/amd/display/modules/inc/mod_freesync.h |  28 +-
 38 files changed, 883 insertions(+), 882 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index 01d0a11..04dfb2b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
@@ -442,7 +442,7 @@ struct amdgpu_crtc {
 	int otg_inst;
 	uint32_t flip_flags;
 	/* After Set Mode stream will be non-NULL */
-	const struct dc_stream *stream;
+	const struct dc_stream_state *stream;
 	struct drm_pending_vblank_event *event;
 };
 
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index b0d316c..692c0e90 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -70,7 +70,7 @@
 #include "i2caux_interface.h"
 
 
-static enum drm_plane_type dm_surfaces_type_default[AMDGPU_MAX_PLANES] = {
+static enum drm_plane_type dm_plane_type_default[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
@@ -79,14 +79,14 @@ static enum drm_plane_type dm_surfaces_type_default[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 };
 
-static enum drm_plane_type dm_surfaces_type_carizzo[AMDGPU_MAX_PLANES] = {
+static enum drm_plane_type dm_plane_type_carizzo[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_OVERLAY,/* YUV Capable Underlay */
 };
 
-static enum drm_plane_type dm_surfaces_type_stoney[AMDGPU_MAX_PLANES] = {
+static enum drm_plane_type dm_plane_type_stoney[AMDGPU_MAX_PLANES] = {
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_PRIMARY,
 	DRM_PLANE_TYPE_OVERLAY, /* YUV Capable Underlay */
@@ -116,7 +116,8 @@ static u32 dm_vblank_get_counter(struct amdgpu_device *adev, int crtc)
 
 
 		if (acrtc_state->stream == NULL) {
-			DRM_ERROR("dc_stream is NULL for crtc '%d'!\n", crtc);
+			DRM_ERROR("dc_stream_state is NULL for crtc '%d'!\n",
+				  crtc);
 			return 0;
 		}
 
@@ -137,7 +138,8 @@ static int dm_crtc_get_scanoutpos(struct amdgpu_device *adev, int crtc,
 						acrtc->base.state);
 
 		if (acrtc_state->stream ==  NULL) {
-			DRM_ERROR("dc_stream is NULL for crtc '%d'!\n", crtc);
+			DRM_ERROR("dc_stream_state is NULL for crtc '%d'!\n",
+				  crtc);
 			return 0;
 		}
 
@@ -1408,11 +1410,11 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 		return -1;
 	}
 
-	for (i = 0; i < dm->dc->caps.max_surfaces; i++) {
+	for (i = 0; i < dm->dc->caps.max_planes; i++) {
 		mode_info->planes[i] = kzalloc(sizeof(struct amdgpu_plane),
 								 GFP_KERNEL);
 		if (!mode_info->planes[i]) {
-			DRM_ERROR("KMS: Failed to allocate surface\n");
+			DRM_ERROR("KMS: Failed to allocate plane\n");
 			goto fail_free_planes;
 		}
 		mode_info->planes[i]->base.type = mode_info->plane_type[i];
@@ -1516,7 +1518,7 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 fail_free_connector:
 	kfree(aconnector);
 fail_free_planes:
-	for (i = 0; i < dm->dc->caps.max_surfaces; i++)
+	for (i = 0; i < dm->dc->caps.max_planes; i++)
 		kfree(mode_info->planes[i]);
 	return -1;
 }
@@ -1575,7 +1577,7 @@ static int amdgpu_notify_freesync(struct drm_device *dev, void *data,
 	num_streams = dc_get_current_stream_count(adev->dm.dc);
 
 	for (i = 0; i < num_streams; i++) {
-		struct dc_stream *stream;
+		struct dc_stream_state *stream;
 		stream = dc_get_stream_at_index(adev->dm.dc, i);
 
 		mod_freesync_update_state(adev->dm.freesync_module,
@@ -1650,52 +1652,52 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_FIJI:
 	case CHIP_TONGA:
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_CARRIZO:
 		adev->mode_info.num_crtc = 3;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 9;
-		adev->mode_info.plane_type = dm_surfaces_type_carizzo;
+		adev->mode_info.plane_type = dm_plane_type_carizzo;
 		break;
 	case CHIP_STONEY:
 		adev->mode_info.num_crtc = 2;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 9;
-		adev->mode_info.plane_type = dm_surfaces_type_stoney;
+		adev->mode_info.plane_type = dm_plane_type_stoney;
 		break;
 	case CHIP_POLARIS11:
 	case CHIP_POLARIS12:
 		adev->mode_info.num_crtc = 5;
 		adev->mode_info.num_hpd = 5;
 		adev->mode_info.num_dig = 5;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_POLARIS10:
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 	case CHIP_VEGA10:
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case CHIP_RAVEN:
 		adev->mode_info.num_crtc = 4;
 		adev->mode_info.num_hpd = 4;
 		adev->mode_info.num_dig = 4;
-		adev->mode_info.plane_type = dm_surfaces_type_default;
+		adev->mode_info.plane_type = dm_plane_type_default;
 		break;
 #endif
 	default:
@@ -1742,8 +1744,8 @@ struct dm_connector_state {
 	container_of((x), struct dm_connector_state, base)
 
 static bool modeset_required(struct drm_crtc_state *crtc_state,
-			     struct dc_stream *new_stream,
-			     struct dc_stream *old_stream)
+			     struct dc_stream_state *new_stream,
+			     struct dc_stream_state *old_stream)
 {
 	if (dc_is_stream_unchanged(new_stream, old_stream)) {
 		crtc_state->mode_changed = false;
@@ -1952,50 +1954,50 @@ static int dm_crtc_cursor_move(struct drm_crtc *crtc,
 
 static bool fill_rects_from_plane_state(
 	const struct drm_plane_state *state,
-	struct dc_plane_state *surface)
+	struct dc_plane_state *plane_state)
 {
-	surface->src_rect.x = state->src_x >> 16;
-	surface->src_rect.y = state->src_y >> 16;
+	plane_state->src_rect.x = state->src_x >> 16;
+	plane_state->src_rect.y = state->src_y >> 16;
 	/*we ignore for now mantissa and do not to deal with floating pixels :(*/
-	surface->src_rect.width = state->src_w >> 16;
+	plane_state->src_rect.width = state->src_w >> 16;
 
-	if (surface->src_rect.width == 0)
+	if (plane_state->src_rect.width == 0)
 		return false;
 
-	surface->src_rect.height = state->src_h >> 16;
-	if (surface->src_rect.height == 0)
+	plane_state->src_rect.height = state->src_h >> 16;
+	if (plane_state->src_rect.height == 0)
 		return false;
 
-	surface->dst_rect.x = state->crtc_x;
-	surface->dst_rect.y = state->crtc_y;
+	plane_state->dst_rect.x = state->crtc_x;
+	plane_state->dst_rect.y = state->crtc_y;
 
 	if (state->crtc_w == 0)
 		return false;
 
-	surface->dst_rect.width = state->crtc_w;
+	plane_state->dst_rect.width = state->crtc_w;
 
 	if (state->crtc_h == 0)
 		return false;
 
-	surface->dst_rect.height = state->crtc_h;
+	plane_state->dst_rect.height = state->crtc_h;
 
-	surface->clip_rect = surface->dst_rect;
+	plane_state->clip_rect = plane_state->dst_rect;
 
 	switch (state->rotation) {
 	case BIT(DRM_ROTATE_0):
-		surface->rotation = ROTATION_ANGLE_0;
+		plane_state->rotation = ROTATION_ANGLE_0;
 		break;
 	case BIT(DRM_ROTATE_90):
-		surface->rotation = ROTATION_ANGLE_90;
+		plane_state->rotation = ROTATION_ANGLE_90;
 		break;
 	case BIT(DRM_ROTATE_180):
-		surface->rotation = ROTATION_ANGLE_180;
+		plane_state->rotation = ROTATION_ANGLE_180;
 		break;
 	case BIT(DRM_ROTATE_270):
-		surface->rotation = ROTATION_ANGLE_270;
+		plane_state->rotation = ROTATION_ANGLE_270;
 		break;
 	default:
-		surface->rotation = ROTATION_ANGLE_0;
+		plane_state->rotation = ROTATION_ANGLE_0;
 		break;
 	}
 
@@ -2027,7 +2029,7 @@ static int get_fb_info(
 
 static int fill_plane_attributes_from_fb(
 	struct amdgpu_device *adev,
-	struct dc_plane_state *surface,
+	struct dc_plane_state *plane_state,
 	const struct amdgpu_framebuffer *amdgpu_fb, bool addReq)
 {
 	uint64_t tiling_flags;
@@ -2046,28 +2048,28 @@ static int fill_plane_attributes_from_fb(
 
 	switch (fb->pixel_format) {
 	case DRM_FORMAT_C8:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS;
 		break;
 	case DRM_FORMAT_RGB565:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_RGB565;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_RGB565;
 		break;
 	case DRM_FORMAT_XRGB8888:
 	case DRM_FORMAT_ARGB8888:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB8888;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB8888;
 		break;
 	case DRM_FORMAT_XRGB2101010:
 	case DRM_FORMAT_ARGB2101010:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010;
 		break;
 	case DRM_FORMAT_XBGR2101010:
 	case DRM_FORMAT_ABGR2101010:
-		surface->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010;
+		plane_state->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010;
 		break;
 	case DRM_FORMAT_NV21:
-		surface->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr;
+		plane_state->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr;
 		break;
 	case DRM_FORMAT_NV12:
-		surface->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb;
+		plane_state->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb;
 		break;
 	default:
 		DRM_ERROR("Unsupported screen format %s\n",
@@ -2075,45 +2077,45 @@ static int fill_plane_attributes_from_fb(
 		return -EINVAL;
 	}
 
-	if (surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
-		surface->address.type = PLN_ADDR_TYPE_GRAPHICS;
-		surface->address.grph.addr.low_part = lower_32_bits(fb_location);
-		surface->address.grph.addr.high_part = upper_32_bits(fb_location);
-		surface->plane_size.grph.surface_size.x = 0;
-		surface->plane_size.grph.surface_size.y = 0;
-		surface->plane_size.grph.surface_size.width = fb->width;
-		surface->plane_size.grph.surface_size.height = fb->height;
-		surface->plane_size.grph.surface_pitch =
-				fb->pitches[0] / (fb->bits_per_pixel / 8);
+	if (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
+		plane_state->address.type = PLN_ADDR_TYPE_GRAPHICS;
+		plane_state->address.grph.addr.low_part = lower_32_bits(fb_location);
+		plane_state->address.grph.addr.high_part = upper_32_bits(fb_location);
+		plane_state->plane_size.grph.surface_size.x = 0;
+		plane_state->plane_size.grph.surface_size.y = 0;
+		plane_state->plane_size.grph.surface_size.width = fb->width;
+		plane_state->plane_size.grph.surface_size.height = fb->height;
+		plane_state->plane_size.grph.surface_pitch =
+					fb->pitches[0] / (fb->bits_per_pixel / 8);	
 		/* TODO: unhardcode */
-		surface->color_space = COLOR_SPACE_SRGB;
+		plane_state->color_space = COLOR_SPACE_SRGB;
 
 	} else {
 		awidth = ALIGN(fb->width, 64);
-		surface->address.type = PLN_ADDR_TYPE_VIDEO_PROGRESSIVE;
-		surface->address.video_progressive.luma_addr.low_part
+		plane_state->address.type = PLN_ADDR_TYPE_VIDEO_PROGRESSIVE;
+		plane_state->address.video_progressive.luma_addr.low_part
 						= lower_32_bits(fb_location);
-		surface->address.video_progressive.chroma_addr.low_part
+		plane_state->address.video_progressive.chroma_addr.low_part
 						= lower_32_bits(fb_location) +
 							(awidth * fb->height);
-		surface->plane_size.video.luma_size.x = 0;
-		surface->plane_size.video.luma_size.y = 0;
-		surface->plane_size.video.luma_size.width = awidth;
-		surface->plane_size.video.luma_size.height = fb->height;
+		plane_state->plane_size.video.luma_size.x = 0;
+		plane_state->plane_size.video.luma_size.y = 0;
+		plane_state->plane_size.video.luma_size.width = awidth;
+		plane_state->plane_size.video.luma_size.height = fb->height;
 		/* TODO: unhardcode */
-		surface->plane_size.video.luma_pitch = awidth;
+		plane_state->plane_size.video.luma_pitch = awidth;
 
-		surface->plane_size.video.chroma_size.x = 0;
-		surface->plane_size.video.chroma_size.y = 0;
-		surface->plane_size.video.chroma_size.width = awidth;
-		surface->plane_size.video.chroma_size.height = fb->height;
-		surface->plane_size.video.chroma_pitch = awidth / 2;
+		plane_state->plane_size.video.chroma_size.x = 0;
+		plane_state->plane_size.video.chroma_size.y = 0;
+		plane_state->plane_size.video.chroma_size.width = awidth;
+		plane_state->plane_size.video.chroma_size.height = fb->height;
+		plane_state->plane_size.video.chroma_pitch = awidth / 2;
 
 		/* TODO: unhardcode */
-		surface->color_space = COLOR_SPACE_YCBCR709;
+		plane_state->color_space = COLOR_SPACE_YCBCR709;
 	}
 
-	memset(&surface->tiling_info, 0, sizeof(surface->tiling_info));
+	memset(&plane_state->tiling_info, 0, sizeof(plane_state->tiling_info));
 
 	/* Fill GFX8 params */
 	if (AMDGPU_TILING_GET(tiling_flags, ARRAY_MODE) == DC_ARRAY_2D_TILED_THIN1) {
@@ -2126,51 +2128,51 @@ static int fill_plane_attributes_from_fb(
 		num_banks = AMDGPU_TILING_GET(tiling_flags, NUM_BANKS);
 
 		/* XXX fix me for VI */
-		surface->tiling_info.gfx8.num_banks = num_banks;
-		surface->tiling_info.gfx8.array_mode =
+		plane_state->tiling_info.gfx8.num_banks = num_banks;
+		plane_state->tiling_info.gfx8.array_mode =
 				DC_ARRAY_2D_TILED_THIN1;
-		surface->tiling_info.gfx8.tile_split = tile_split;
-		surface->tiling_info.gfx8.bank_width = bankw;
-		surface->tiling_info.gfx8.bank_height = bankh;
-		surface->tiling_info.gfx8.tile_aspect = mtaspect;
-		surface->tiling_info.gfx8.tile_mode =
+		plane_state->tiling_info.gfx8.tile_split = tile_split;
+		plane_state->tiling_info.gfx8.bank_width = bankw;
+		plane_state->tiling_info.gfx8.bank_height = bankh;
+		plane_state->tiling_info.gfx8.tile_aspect = mtaspect;
+		plane_state->tiling_info.gfx8.tile_mode =
 				DC_ADDR_SURF_MICRO_TILING_DISPLAY;
 	} else if (AMDGPU_TILING_GET(tiling_flags, ARRAY_MODE)
 			== DC_ARRAY_1D_TILED_THIN1) {
-		surface->tiling_info.gfx8.array_mode = DC_ARRAY_1D_TILED_THIN1;
+		plane_state->tiling_info.gfx8.array_mode = DC_ARRAY_1D_TILED_THIN1;
 	}
 
-	surface->tiling_info.gfx8.pipe_config =
+	plane_state->tiling_info.gfx8.pipe_config =
 			AMDGPU_TILING_GET(tiling_flags, PIPE_CONFIG);
 
 	if (adev->asic_type == CHIP_VEGA10 ||
 	    adev->asic_type == CHIP_RAVEN) {
 		/* Fill GFX9 params */
-		surface->tiling_info.gfx9.num_pipes =
+		plane_state->tiling_info.gfx9.num_pipes =
 			adev->gfx.config.gb_addr_config_fields.num_pipes;
-		surface->tiling_info.gfx9.num_banks =
+		plane_state->tiling_info.gfx9.num_banks =
 			adev->gfx.config.gb_addr_config_fields.num_banks;
-		surface->tiling_info.gfx9.pipe_interleave =
+		plane_state->tiling_info.gfx9.pipe_interleave =
 			adev->gfx.config.gb_addr_config_fields.pipe_interleave_size;
-		surface->tiling_info.gfx9.num_shader_engines =
+		plane_state->tiling_info.gfx9.num_shader_engines =
 			adev->gfx.config.gb_addr_config_fields.num_se;
-		surface->tiling_info.gfx9.max_compressed_frags =
+		plane_state->tiling_info.gfx9.max_compressed_frags =
 			adev->gfx.config.gb_addr_config_fields.max_compress_frags;
-		surface->tiling_info.gfx9.num_rb_per_se =
+		plane_state->tiling_info.gfx9.num_rb_per_se =
 			adev->gfx.config.gb_addr_config_fields.num_rb_per_se;
-		surface->tiling_info.gfx9.swizzle =
+		plane_state->tiling_info.gfx9.swizzle =
 			AMDGPU_TILING_GET(tiling_flags, SWIZZLE_MODE);
-		surface->tiling_info.gfx9.shaderEnable = 1;
+		plane_state->tiling_info.gfx9.shaderEnable = 1;
 	}
 
-	surface->visible = true;
-	surface->scaling_quality.h_taps_c = 0;
-	surface->scaling_quality.v_taps_c = 0;
+	plane_state->visible = true;
+	plane_state->scaling_quality.h_taps_c = 0;
+	plane_state->scaling_quality.v_taps_c = 0;
 
-	/* is this needed? is surface zeroed at allocation? */
-	surface->scaling_quality.h_taps = 0;
-	surface->scaling_quality.v_taps = 0;
-	surface->stereo_format = PLANE_STEREO_FORMAT_NONE;
+	/* is this needed? is plane_state zeroed at allocation? */
+	plane_state->scaling_quality.h_taps = 0;
+	plane_state->scaling_quality.v_taps = 0;
+	plane_state->stereo_format = PLANE_STEREO_FORMAT_NONE;
 
 	return ret;
 
@@ -2180,7 +2182,7 @@ static int fill_plane_attributes_from_fb(
 
 static void fill_gamma_from_crtc_state(
 	const struct drm_crtc_state *crtc_state,
-	struct dc_plane_state *dc_surface)
+	struct dc_plane_state *plane_state)
 {
 	int i;
 	struct dc_gamma *gamma;
@@ -2199,12 +2201,12 @@ static void fill_gamma_from_crtc_state(
 		gamma->blue[i] = lut[i].blue;
 	}
 
-	dc_surface->gamma_correction = gamma;
+	plane_state->gamma_correction = gamma;
 }
 
 static int fill_plane_attributes(
 			struct amdgpu_device *adev,
-			struct dc_plane_state *surface,
+			struct dc_plane_state *dc_plane_state,
 			struct drm_plane_state *plane_state,
 			struct drm_crtc_state *crtc_state,
 			bool addrReq)
@@ -2215,12 +2217,12 @@ static int fill_plane_attributes(
 	struct dc_transfer_func *input_tf;
 	int ret = 0;
 
-	if (!fill_rects_from_plane_state(plane_state, surface))
+	if (!fill_rects_from_plane_state(plane_state, dc_plane_state))
 		return -EINVAL;
 
 	ret = fill_plane_attributes_from_fb(
 		crtc->dev->dev_private,
-		surface,
+		dc_plane_state,
 		amdgpu_fb,
 		addrReq);
 
@@ -2235,11 +2237,11 @@ static int fill_plane_attributes(
 	input_tf->type = TF_TYPE_PREDEFINED;
 	input_tf->tf = TRANSFER_FUNCTION_SRGB;
 
-	surface->in_transfer_func = input_tf;
+	dc_plane_state->in_transfer_func = input_tf;
 
 	/* In case of gamma set, update gamma value */
 	if (crtc_state->gamma_lut)
-		fill_gamma_from_crtc_state(crtc_state, surface);
+		fill_gamma_from_crtc_state(crtc_state, dc_plane_state);
 
 	return ret;
 }
@@ -2273,7 +2275,7 @@ struct amdgpu_connector *aconnector_from_drm_crtc_id(
 static void update_stream_scaling_settings(
 		const struct drm_display_mode *mode,
 		const struct dm_connector_state *dm_state,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	enum amdgpu_rmx_type rmx_type;
 
@@ -2417,7 +2419,7 @@ static enum dc_color_space get_output_color_space(
 /*****************************************************************************/
 
 static void fill_stream_properties_from_drm_display_mode(
-	struct dc_stream *stream,
+	struct dc_stream_state *stream,
 	const struct drm_display_mode *mode_in,
 	const struct drm_connector *connector)
 {
@@ -2558,14 +2560,14 @@ static void decide_crtc_timing_for_drm_display_mode(
 	}
 }
 
-static struct dc_stream *create_stream_for_sink(
+static struct dc_stream_state *create_stream_for_sink(
 		struct amdgpu_connector *aconnector,
 		const struct drm_display_mode *drm_mode,
 		const struct dm_connector_state *dm_state)
 {
 	struct drm_display_mode *preferred_mode = NULL;
 	const struct drm_connector *drm_connector;
-	struct dc_stream *stream = NULL;
+	struct dc_stream_state *stream = NULL;
 	struct drm_display_mode mode = *drm_mode;
 	bool native_mode_found = false;
 
@@ -3140,7 +3142,7 @@ int amdgpu_dm_connector_mode_valid(
 	struct dc_sink *dc_sink;
 	struct amdgpu_device *adev = connector->dev->dev_private;
 	/* TODO: Unhardcode stream count */
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
 
 	if ((mode->flags & DRM_MODE_FLAG_INTERLACE) ||
@@ -3288,9 +3290,9 @@ dm_drm_plane_duplicate_state(struct drm_plane *plane)
 
 	__drm_atomic_helper_plane_duplicate_state(plane, &dm_plane_state->base);
 
-	if (old_dm_plane_state->surface) {
-		dm_plane_state->surface = old_dm_plane_state->surface;
-		dc_surface_retain(dm_plane_state->surface);
+	if (old_dm_plane_state->dc_state) {
+		dm_plane_state->dc_state = old_dm_plane_state->dc_state;
+		dc_plane_state_retain(dm_plane_state->dc_state);
 	}
 
 	return &dm_plane_state->base;
@@ -3301,8 +3303,8 @@ void dm_drm_plane_destroy_state(struct drm_plane *plane,
 {
 	struct dm_plane_state *dm_plane_state = to_dm_plane_state(state);
 
-	if (dm_plane_state->surface)
-		dc_surface_release(dm_plane_state->surface);
+	if (dm_plane_state->dc_state)
+		dc_plane_state_release(dm_plane_state->dc_state);
 
 	__drm_atomic_helper_plane_destroy_state(state);
 	kfree(dm_plane_state);
@@ -3371,18 +3373,18 @@ static int dm_plane_helper_prepare_fb(
 
 	amdgpu_bo_ref(rbo);
 
-	if (dm_plane_state_new->surface &&
-			dm_plane_state_old->surface != dm_plane_state_new->surface) {
-		struct dc_plane_state *surface = dm_plane_state_new->surface;
+	if (dm_plane_state_new->dc_state &&
+			dm_plane_state_old->dc_state != dm_plane_state_new->dc_state) {
+		struct dc_plane_state *plane_state = dm_plane_state_new->dc_state;
 
-		if (surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
-			surface->address.grph.addr.low_part = lower_32_bits(afb->address);
-			surface->address.grph.addr.high_part = upper_32_bits(afb->address);
+		if (plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
+			plane_state->address.grph.addr.low_part = lower_32_bits(afb->address);
+			plane_state->address.grph.addr.high_part = upper_32_bits(afb->address);
 		} else {
 			awidth = ALIGN(new_state->fb->width, 64);
-			surface->address.video_progressive.luma_addr.low_part
+			plane_state->address.video_progressive.luma_addr.low_part
 							= lower_32_bits(afb->address);
-			surface->address.video_progressive.chroma_addr.low_part
+			plane_state->address.video_progressive.chroma_addr.low_part
 							= lower_32_bits(afb->address) +
 								(awidth * new_state->fb->height);
 		}
@@ -3446,7 +3448,7 @@ int dm_create_validation_set_for_connector(struct drm_connector *connector,
 	struct dc_sink *dc_sink =
 			to_amdgpu_connector(connector)->dc_sink;
 	/* TODO: Unhardcode stream count */
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 
 	if ((mode->flags & DRM_MODE_FLAG_INTERLACE) ||
 			(mode->flags & DRM_MODE_FLAG_DBLSCAN))
@@ -3484,10 +3486,10 @@ int dm_plane_atomic_check(struct drm_plane *plane,
 	struct dc *dc = adev->dm.dc;
 	struct dm_plane_state *dm_plane_state = to_dm_plane_state(state);
 
-	if (!dm_plane_state->surface)
+	if (!dm_plane_state->dc_state)
 		return true;
 
-	if (dc_validate_plane(dc, dm_plane_state->surface))
+	if (dc_validate_plane(dc, dm_plane_state->dc_state))
 		return 0;
 
 	return -EINVAL;
@@ -4105,7 +4107,7 @@ static bool is_scaling_state_different(
 static void remove_stream(
 		struct amdgpu_device *adev,
 		struct amdgpu_crtc *acrtc,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	/* this is the update mode case */
 	if (adev->dm.freesync_module)
@@ -4181,6 +4183,7 @@ static void amdgpu_dm_do_flip(
 	struct amdgpu_device *adev = crtc->dev->dev_private;
 	bool async_flip = (acrtc->flip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;
 	struct dc_flip_addrs addr = { {0} };
+	/* TODO eliminate or rename surface_update */
 	struct dc_surface_update surface_updates[1] = { {0} };
 	struct dm_crtc_state *acrtc_state = to_dm_crtc_state(crtc->state);
 
@@ -4236,11 +4239,11 @@ static void amdgpu_dm_do_flip(
 	if (acrtc->base.state->event)
 		prepare_flip_isr(acrtc);
 
-	surface_updates->surface = dc_stream_get_status(acrtc_state->stream)->surfaces[0];
+	surface_updates->surface = dc_stream_get_status(acrtc_state->stream)->plane_states[0];
 	surface_updates->flip_addr = &addr;
 
 
-	dc_update_surfaces_and_stream(adev->dm.dc, surface_updates, 1, acrtc_state->stream, NULL);
+	dc_update_planes_and_stream(adev->dm.dc, surface_updates, 1, acrtc_state->stream, NULL);
 
 	DRM_DEBUG_DRIVER("%s Flipping to hi: 0x%x, low: 0x%x \n",
 			 __func__,
@@ -4251,7 +4254,7 @@ static void amdgpu_dm_do_flip(
 	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 }
 
-static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
+static void amdgpu_dm_commit_planes(struct drm_atomic_state *state,
 			struct drm_device *dev,
 			struct amdgpu_display_manager *dm,
 			struct drm_crtc *pcrtc,
@@ -4260,8 +4263,8 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 	uint32_t i;
 	struct drm_plane *plane;
 	struct drm_plane_state *old_plane_state;
-	struct dc_stream *dc_stream_attach;
-	struct dc_plane_state *dc_surfaces_constructed[MAX_SURFACES];
+	struct dc_stream_state *dc_stream_attach;
+	struct dc_plane_state *plane_states_constructed[MAX_SURFACES];
 	struct amdgpu_crtc *acrtc_attach = to_amdgpu_crtc(pcrtc);
 	struct dm_crtc_state *acrtc_state = to_dm_crtc_state(pcrtc->state);
 	int planes_count = 0;
@@ -4289,8 +4292,9 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 
 		spin_lock_irqsave(&crtc->dev->event_lock, flags);
 		if (acrtc_attach->pflip_status != AMDGPU_FLIP_NONE) {
-			DRM_ERROR("add_surface: acrtc %d, already busy\n",
-					acrtc_attach->crtc_id);
+			DRM_ERROR("%s: acrtc %d, already busy\n",
+				  __func__,
+				  acrtc_attach->crtc_id);
 			spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 			/* In commit tail framework this cannot happen */
 			WARN_ON(1);
@@ -4298,9 +4302,9 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 
 		if (!pflip_needed) {
-			WARN_ON(!dm_plane_state->surface);
+			WARN_ON(!dm_plane_state->dc_state);
 
-			dc_surfaces_constructed[planes_count] = dm_plane_state->surface;
+			plane_states_constructed[planes_count] = dm_plane_state->dc_state;
 
 			dc_stream_attach = acrtc_state->stream;
 			planes_count++;
@@ -4343,11 +4347,11 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 			spin_unlock_irqrestore(&pcrtc->dev->event_lock, flags);
 		}
 
-		if (false == dc_commit_surfaces_to_stream(dm->dc,
-							  dc_surfaces_constructed,
-							  planes_count,
-							  dc_stream_attach))
-			dm_error("%s: Failed to attach surface!\n", __func__);
+		if (false == dc_commit_planes_to_stream(dm->dc,
+							plane_states_constructed,
+							planes_count,
+							dc_stream_attach))
+			dm_error("%s: Failed to attach plane!\n", __func__);
 	} else {
 
 		/*TODO BUG Here should go disable planes on CRTC. */
@@ -4397,7 +4401,7 @@ void amdgpu_dm_atomic_commit_tail(
 	struct drm_crtc *crtc, *pcrtc;
 	struct drm_crtc_state *old_crtc_state;
 	struct amdgpu_crtc *new_crtcs[MAX_STREAMS];
-	struct dc_stream *new_stream = NULL;
+	struct dc_stream_state *new_stream = NULL;
 	unsigned long flags;
 	bool wait_for_vblank = true;
 	struct drm_connector *connector;
@@ -4558,20 +4562,20 @@ void amdgpu_dm_atomic_commit_tail(
 		new_acrtc_state = to_dm_crtc_state(acrtc->base.state);
 
 		update_stream_scaling_settings(&con_new_state->base.crtc->mode,
-				con_new_state, (struct dc_stream *)new_acrtc_state->stream);
+				con_new_state, (struct dc_stream_state *)new_acrtc_state->stream);
 
 		status = dc_stream_get_status(new_acrtc_state->stream);
 		WARN_ON(!status);
-		WARN_ON(!status->surface_count);
+		WARN_ON(!status->plane_count);
 
 		if (!new_acrtc_state->stream)
 			continue;
 
 		/*TODO How it works with MPO ?*/
-		if (!dc_commit_surfaces_to_stream(
+		if (!dc_commit_planes_to_stream(
 				dm->dc,
-				status->surfaces,
-				status->surface_count,
+				status->plane_states,
+				status->plane_count,
 				new_acrtc_state->stream))
 			dm_error("%s: Failed to update stream scaling!\n", __func__);
 	}
@@ -4596,7 +4600,7 @@ void amdgpu_dm_atomic_commit_tail(
 		new_acrtc_state = to_dm_crtc_state(pcrtc->state);
 
 		if (new_acrtc_state->stream)
-			amdgpu_dm_commit_surfaces(state, dev, dm, pcrtc, &wait_for_vblank);
+			amdgpu_dm_commit_planes(state, dev, dm, pcrtc, &wait_for_vblank);
 	}
 
 
@@ -4711,34 +4715,34 @@ void dm_restore_drm_connector_state(struct drm_device *dev, struct drm_connector
 		dm_force_atomic_commit(&aconnector->base);
 }
 
-static uint32_t add_val_sets_surface(
+static uint32_t add_val_sets_plane(
 	struct dc_validation_set *val_sets,
 	uint32_t set_count,
-	const struct dc_stream *stream,
-	struct dc_plane_state *surface)
+	const struct dc_stream_state *stream,
+	struct dc_plane_state *plane_state)
 {
 	uint32_t i = 0, j = 0;
 
 	while (i < set_count) {
 		if (val_sets[i].stream == stream) {
-			while (val_sets[i].surfaces[j])
+			while (val_sets[i].plane_states[j])
 				j++;
 			break;
 		}
 		++i;
 	}
 
-	val_sets[i].surfaces[j] = surface;
-	val_sets[i].surface_count++;
+	val_sets[i].plane_states[j] = plane_state;
+	val_sets[i].plane_count++;
 
-	return val_sets[i].surface_count;
+	return val_sets[i].plane_count;
 }
 
 static uint32_t update_in_val_sets_stream(
 	struct dc_validation_set *val_sets,
 	uint32_t set_count,
-	struct dc_stream *old_stream,
-	struct dc_stream *new_stream,
+	struct dc_stream_state *old_stream,
+	struct dc_stream_state *new_stream,
 	struct drm_crtc *crtc)
 {
 	uint32_t i = 0;
@@ -4761,7 +4765,7 @@ static uint32_t update_in_val_sets_stream(
 static uint32_t remove_from_val_sets(
 	struct dc_validation_set *val_sets,
 	uint32_t set_count,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	int i;
 
@@ -4852,7 +4856,7 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 
 	/*
 	 * This bool will be set for true for any modeset/reset
-	 * or surface update which implies non fast surface update.
+	 * or plane update which implies non fast surface update.
 	 */
 	bool lock_and_validation_needed = false;
 
@@ -4883,7 +4887,7 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
 		struct amdgpu_crtc *acrtc = NULL;
 		struct amdgpu_connector *aconnector = NULL;
-		struct dc_stream *new_stream = NULL;
+		struct dc_stream_state *new_stream = NULL;
 		struct drm_connector_state *conn_state = NULL;
 		struct dm_connector_state *dm_conn_state = NULL;
 
@@ -5039,13 +5043,13 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 
 			pflip_needed = !state->allow_modeset;
 			if (!pflip_needed) {
-				struct dc_plane_state *surface;
+				struct dc_plane_state *dc_plane_state;
 
-				surface = dc_create_surface(dc);
+				dc_plane_state = dc_create_plane_state(dc);
 
 				ret = fill_plane_attributes(
 					plane_crtc->dev->dev_private,
-					surface,
+					dc_plane_state,
 					plane_state,
 					crtc_state,
 					false);
@@ -5053,15 +5057,15 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 					goto fail;
 
 
-				if (dm_plane_state->surface)
-					dc_surface_release(dm_plane_state->surface);
+				if (dm_plane_state->dc_state)
+					dc_plane_state_release(dm_plane_state->dc_state);
 
-				dm_plane_state->surface = surface;
+				dm_plane_state->dc_state = dc_plane_state;
 
-				add_val_sets_surface(set,
+				add_val_sets_plane(set,
 						     set_count,
 						     new_acrtc_state->stream,
-						     surface);
+						     dc_plane_state);
 
 				lock_and_validation_needed = true;
 			}
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index e4ee895..3505421 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -196,12 +196,12 @@ struct  dc_stream;
 
 struct dm_plane_state {
 	struct drm_plane_state base;
-	struct dc_plane_state *surface;
+	struct dc_plane_state *dc_state;
 };
 
 struct dm_crtc_state {
 	struct drm_crtc_state base;
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 };
 
 #define to_dm_crtc_state(x)    container_of(x, struct dm_crtc_state, base)
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
index 0a61558..4a12453 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
@@ -174,7 +174,7 @@ static void get_payload_table(
  */
 bool dm_helpers_dp_mst_write_payload_allocation_table(
 		struct dc_context *ctx,
-		const struct dc_stream *stream,
+		const struct dc_stream_state *stream,
 		struct dp_mst_stream_allocation_table *proposed_table,
 		bool enable)
 {
@@ -264,7 +264,7 @@ bool dm_helpers_dp_mst_write_payload_allocation_table(
  */
 bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 		struct dc_context *ctx,
-		const struct dc_stream *stream)
+		const struct dc_stream_state *stream)
 {
 	struct amdgpu_connector *aconnector;
 	struct drm_dp_mst_topology_mgr *mst_mgr;
@@ -290,7 +290,7 @@ bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 
 bool dm_helpers_dp_mst_send_payload_allocation(
 		struct dc_context *ctx,
-		const struct dc_stream *stream,
+		const struct dc_stream_state *stream,
 		bool enable)
 {
 	struct amdgpu_connector *aconnector;
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
index 9a85022..28dbd18 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
@@ -2594,15 +2594,15 @@ static void populate_initial_data(
 		if (!pipe[i].stream || !pipe[i].bottom_pipe)
 			continue;
 
-		ASSERT(pipe[i].surface);
+		ASSERT(pipe[i].plane_state);
 
 		if (num_displays == 0) {
-			if (!pipe[i].surface->visible)
+			if (!pipe[i].plane_state->visible)
 				data->d0_underlay_mode = bw_def_underlay_only;
 			else
 				data->d0_underlay_mode = bw_def_blend;
 		} else {
-			if (!pipe[i].surface->visible)
+			if (!pipe[i].plane_state->visible)
 				data->d1_underlay_mode = bw_def_underlay_only;
 			else
 				data->d1_underlay_mode = bw_def_blend;
@@ -2620,7 +2620,7 @@ static void populate_initial_data(
 		data->v_taps[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.taps.v_taps);
 		data->h_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.horz.value);
 		data->v_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.vert.value);
-		switch (pipe[i].surface->rotation) {
+		switch (pipe[i].plane_state->rotation) {
 		case ROTATION_ANGLE_0:
 			data->rotation_angle[num_displays + 4] = bw_int_to_fixed(0);
 			break;
@@ -2636,7 +2636,7 @@ static void populate_initial_data(
 		default:
 			break;
 		}
-		switch (pipe[i].surface->format) {
+		switch (pipe[i].plane_state->format) {
 		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 		case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
 		case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
@@ -2670,14 +2670,14 @@ static void populate_initial_data(
 			data->src_height[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.viewport.height);
 			data->src_width[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.viewport.width);
 			data->pitch_in_pixels[num_displays * 2 + j] = bw_int_to_fixed(
-					pipe[i].bottom_pipe->surface->plane_size.grph.surface_pitch);
+					pipe[i].bottom_pipe->plane_state->plane_size.grph.surface_pitch);
 			data->h_taps[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.taps.h_taps);
 			data->v_taps[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.taps.v_taps);
 			data->h_scale_ratio[num_displays * 2 + j] = fixed31_32_to_bw_fixed(
 					pipe[i].bottom_pipe->scl_data.ratios.horz.value);
 			data->v_scale_ratio[num_displays * 2 + j] = fixed31_32_to_bw_fixed(
 					pipe[i].bottom_pipe->scl_data.ratios.vert.value);
-			switch (pipe[i].bottom_pipe->surface->rotation) {
+			switch (pipe[i].bottom_pipe->plane_state->rotation) {
 			case ROTATION_ANGLE_0:
 				data->rotation_angle[num_displays * 2 + j] = bw_int_to_fixed(0);
 				break;
@@ -2710,7 +2710,7 @@ static void populate_initial_data(
 		data->h_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.h_total);
 		data->v_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.v_total);
 		data->pixel_rate[num_displays + 4] = bw_frc_to_fixed(pipe[i].stream->timing.pix_clk_khz, 1000);
-		if (pipe[i].surface) {
+		if (pipe[i].plane_state) {
 			data->src_width[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.width);
 			data->pitch_in_pixels[num_displays + 4] = data->src_width[num_displays + 4];
 			data->src_height[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.height);
@@ -2718,7 +2718,7 @@ static void populate_initial_data(
 			data->v_taps[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.taps.v_taps);
 			data->h_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.horz.value);
 			data->v_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.vert.value);
-			switch (pipe[i].surface->rotation) {
+			switch (pipe[i].plane_state->rotation) {
 			case ROTATION_ANGLE_0:
 				data->rotation_angle[num_displays + 4] = bw_int_to_fixed(0);
 				break;
@@ -2734,7 +2734,7 @@ static void populate_initial_data(
 			default:
 				break;
 			}
-			switch (pipe[i].surface->format) {
+			switch (pipe[i].plane_state->format) {
 			case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 			case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 			case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index 7f7cb8f..404b39e 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -233,16 +233,16 @@ static void pipe_ctx_to_e2e_pipe_params (
 		struct _vcs_dpi_display_pipe_params_st *input)
 {
 	input->src.is_hsplit = false;
-	if (pipe->top_pipe != NULL && pipe->top_pipe->surface == pipe->surface)
+	if (pipe->top_pipe != NULL && pipe->top_pipe->plane_state == pipe->plane_state)
 		input->src.is_hsplit = true;
-	else if (pipe->bottom_pipe != NULL && pipe->bottom_pipe->surface == pipe->surface)
+	else if (pipe->bottom_pipe != NULL && pipe->bottom_pipe->plane_state == pipe->plane_state)
 		input->src.is_hsplit = true;
 
-	input->src.dcc                 = pipe->surface->dcc.enable;
+	input->src.dcc                 = pipe->plane_state->dcc.enable;
 	input->src.dcc_rate            = 1;
-	input->src.meta_pitch          = pipe->surface->dcc.grph.meta_pitch;
+	input->src.meta_pitch          = pipe->plane_state->dcc.grph.meta_pitch;
 	input->src.source_scan         = dm_horz;
-	input->src.sw_mode             = pipe->surface->tiling_info.gfx9.swizzle;
+	input->src.sw_mode             = pipe->plane_state->tiling_info.gfx9.swizzle;
 
 	input->src.viewport_width      = pipe->scl_data.viewport.width;
 	input->src.viewport_height     = pipe->scl_data.viewport.height;
@@ -251,7 +251,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	input->src.cur0_src_width      = 128; /* TODO: Cursor calcs, not curently stored */
 	input->src.cur0_bpp            = 32;
 
-	switch (pipe->surface->tiling_info.gfx9.swizzle) {
+	switch (pipe->plane_state->tiling_info.gfx9.swizzle) {
 	/* for 4/8/16 high tiles */
 	case DC_SW_LINEAR:
 		input->src.is_display_sw = 1;
@@ -299,7 +299,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 		break;
 	}
 
-	switch (pipe->surface->rotation) {
+	switch (pipe->plane_state->rotation) {
 	case ROTATION_ANGLE_0:
 	case ROTATION_ANGLE_180:
 		input->src.source_scan = dm_horz;
@@ -314,7 +314,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	}
 
 	/* TODO: Fix pixel format mappings */
-	switch (pipe->surface->format) {
+	switch (pipe->plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 		input->src.source_format = dm_420_8;
@@ -455,7 +455,7 @@ static void dcn_bw_calc_rq_dlg_ttu(
 			true,
 			true,
 			v->pte_enable == dcn_bw_yes,
-			pipe->surface->flip_immediate);
+			pipe->plane_state->flip_immediate);
 }
 
 static void dcn_dml_wm_override(
@@ -478,7 +478,7 @@ static void dcn_dml_wm_override(
 	for (i = 0, in_idx = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe->stream || !pipe->surface)
+		if (!pipe->stream || !pipe->plane_state)
 			continue;
 
 		input[in_idx].clks_cfg.dcfclk_mhz = v->dcfclk;
@@ -516,7 +516,7 @@ static void dcn_dml_wm_override(
 	for (i = 0, in_idx = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe->stream || !pipe->surface)
+		if (!pipe->stream || !pipe->plane_state)
 			continue;
 
 		dml_rq_dlg_get_dlg_reg(dml,
@@ -527,7 +527,7 @@ static void dcn_dml_wm_override(
 			true,
 			true,
 			v->pte_enable == dcn_bw_yes,
-			pipe->surface->flip_immediate);
+			pipe->plane_state->flip_immediate);
 		in_idx++;
 	}
 	dm_free(input);
@@ -541,7 +541,7 @@ static void split_stream_across_pipes(
 {
 	int pipe_idx = secondary_pipe->pipe_idx;
 
-	if (!primary_pipe->surface)
+	if (!primary_pipe->plane_state)
 		return;
 
 	*secondary_pipe = *primary_pipe;
@@ -843,7 +843,7 @@ bool dcn_validate_bandwidth(
 		if (!pipe->stream)
 			continue;
 		/* skip all but first of split pipes */
-		if (pipe->top_pipe && pipe->top_pipe->surface == pipe->surface)
+		if (pipe->top_pipe && pipe->top_pipe->plane_state == pipe->plane_state)
 			continue;
 
 		v->underscan_output[input_idx] = false; /* taken care of in recout already*/
@@ -869,7 +869,7 @@ bool dcn_validate_bandwidth(
 			}
 		}
 
-		if (!pipe->surface){
+		if (!pipe->plane_state) {
 			v->dcc_enable[input_idx] = dcn_bw_yes;
 			v->source_pixel_format[input_idx] = dcn_bw_rgb_sub_32;
 			v->source_surface_mode[input_idx] = dcn_bw_sw_4_kb_s;
@@ -889,8 +889,8 @@ bool dcn_validate_bandwidth(
 			v->viewport_width[input_idx] = pipe->scl_data.viewport.width;
 			v->scaler_rec_out_width[input_idx] = pipe->scl_data.recout.width;
 			v->scaler_recout_height[input_idx] = pipe->scl_data.recout.height;
-			if (pipe->bottom_pipe && pipe->bottom_pipe->surface == pipe->surface) {
-				if (pipe->surface->rotation % 2 == 0) {
+			if (pipe->bottom_pipe && pipe->bottom_pipe->plane_state == pipe->plane_state) {
+				if (pipe->plane_state->rotation % 2 == 0) {
 					int viewport_end = pipe->scl_data.viewport.width
 							+ pipe->scl_data.viewport.x;
 					int viewport_b_end = pipe->bottom_pipe->scl_data.viewport.width
@@ -919,17 +919,17 @@ bool dcn_validate_bandwidth(
 						+ pipe->bottom_pipe->scl_data.recout.width;
 			}
 
-			v->dcc_enable[input_idx] = pipe->surface->dcc.enable ? dcn_bw_yes : dcn_bw_no;
+			v->dcc_enable[input_idx] = pipe->plane_state->dcc.enable ? dcn_bw_yes : dcn_bw_no;
 			v->source_pixel_format[input_idx] = tl_pixel_format_to_bw_defs(
-					pipe->surface->format);
+					pipe->plane_state->format);
 			v->source_surface_mode[input_idx] = tl_sw_mode_to_bw_defs(
-					pipe->surface->tiling_info.gfx9.swizzle);
+					pipe->plane_state->tiling_info.gfx9.swizzle);
 			v->lb_bit_per_pixel[input_idx] = tl_lb_bpp_to_int(pipe->scl_data.lb_params.depth);
 			v->override_hta_ps[input_idx] = pipe->scl_data.taps.h_taps;
 			v->override_vta_ps[input_idx] = pipe->scl_data.taps.v_taps;
 			v->override_hta_pschroma[input_idx] = pipe->scl_data.taps.h_taps_c;
 			v->override_vta_pschroma[input_idx] = pipe->scl_data.taps.v_taps_c;
-			v->source_scan[input_idx] = (pipe->surface->rotation % 2) ? dcn_bw_vert : dcn_bw_hor;
+			v->source_scan[input_idx] = (pipe->plane_state->rotation % 2) ? dcn_bw_vert : dcn_bw_hor;
 		}
 		if (v->is_line_buffer_bpp_fixed == dcn_bw_yes)
 			v->lb_bit_per_pixel[input_idx] = v->line_buffer_fixed_bpp;
@@ -996,7 +996,7 @@ bool dcn_validate_bandwidth(
 			if (!pipe->stream)
 				continue;
 			/* skip all but first of split pipes */
-			if (pipe->top_pipe && pipe->top_pipe->surface == pipe->surface)
+			if (pipe->top_pipe && pipe->top_pipe->plane_state == pipe->plane_state)
 				continue;
 
 			pipe->pipe_dlg_param.vupdate_width = v->v_update_width[input_idx];
@@ -1024,7 +1024,7 @@ bool dcn_validate_bandwidth(
 			pipe->pipe_dlg_param.vblank_start = asic_blank_start;
 			pipe->pipe_dlg_param.vblank_end = asic_blank_end;
 
-			if (pipe->surface) {
+			if (pipe->plane_state) {
 				struct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;
 
 				if (v->dpp_per_plane[input_idx] == 2 ||
@@ -1036,7 +1036,7 @@ bool dcn_validate_bandwidth(
 					 TIMING_3D_FORMAT_TOP_AND_BOTTOM ||
 					 pipe->stream->timing.timing_3d_format ==
 					 TIMING_3D_FORMAT_SIDE_BY_SIDE))) {
-					if (hsplit_pipe && hsplit_pipe->surface == pipe->surface) {
+					if (hsplit_pipe && hsplit_pipe->plane_state == pipe->plane_state) {
 						/* update previously split pipe */
 						hsplit_pipe->pipe_dlg_param.vupdate_width = v->v_update_width[input_idx];
 						hsplit_pipe->pipe_dlg_param.vupdate_offset = v->v_update_offset[input_idx];
@@ -1057,12 +1057,12 @@ bool dcn_validate_bandwidth(
 					}
 
 					dcn_bw_calc_rq_dlg_ttu(dc, v, hsplit_pipe);
-				} else if (hsplit_pipe && hsplit_pipe->surface == pipe->surface) {
+				} else if (hsplit_pipe && hsplit_pipe->plane_state == pipe->plane_state) {
 					/* merge previously split pipe */
 					pipe->bottom_pipe = hsplit_pipe->bottom_pipe;
 					if (hsplit_pipe->bottom_pipe)
 						hsplit_pipe->bottom_pipe->top_pipe = pipe;
-					hsplit_pipe->surface = NULL;
+					hsplit_pipe->plane_state = NULL;
 					hsplit_pipe->stream = NULL;
 					hsplit_pipe->top_pipe = NULL;
 					hsplit_pipe->bottom_pipe = NULL;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index cc8590e..6edcbc2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -149,12 +149,12 @@ static bool create_links(
 }
 
 static bool stream_adjust_vmin_vmax(struct dc *dc,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_stream *stream = streams[0];
+	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
@@ -175,12 +175,12 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 }
 
 static bool stream_get_crtc_position(struct dc *dc,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_stream *stream = streams[0];
+	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 	struct crtc_position position;
@@ -200,7 +200,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 	return ret;
 }
 
-static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
+static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
@@ -218,7 +218,7 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 	return ret;
 }
 
-static bool program_csc_matrix(struct dc *dc, struct dc_stream *stream)
+static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
@@ -241,7 +241,7 @@ static bool program_csc_matrix(struct dc *dc, struct dc_stream *stream)
 }
 
 static void set_static_screen_events(struct dc *dc,
-		struct dc_stream **streams,
+		struct dc_stream_state **streams,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
@@ -252,7 +252,7 @@ static void set_static_screen_events(struct dc *dc,
 	int num_pipes_affected = 0;
 
 	for (i = 0; i < num_streams; i++) {
-		struct dc_stream *stream = streams[i];
+		struct dc_stream_state *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
 			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
@@ -333,7 +333,7 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
-void set_dither_option(struct dc_stream *stream,
+void set_dither_option(struct dc_stream_state *stream,
 		enum dc_dither_option option)
 {
 	struct bit_depth_reduction_params params;
@@ -639,21 +639,21 @@ static bool is_validation_required(
 
 	for (i = 0; i < set_count; i++) {
 
-		if (set[i].surface_count != context->stream_status[i].surface_count)
+		if (set[i].plane_count != context->stream_status[i].plane_count)
 			return true;
 		if (!dc_is_stream_unchanged(set[i].stream, context->streams[i]))
 			return true;
 
-		for (j = 0; j < set[i].surface_count; j++) {
-			struct dc_plane_state temp_surf;
-			memset(&temp_surf, 0, sizeof(temp_surf));
+		for (j = 0; j < set[i].plane_count; j++) {
+			struct dc_plane_state temp_plane;
+			memset(&temp_plane, 0, sizeof(temp_plane));
 
-			temp_surf = *context->stream_status[i].surfaces[j];
-			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
-			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
-			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
+			temp_plane = *context->stream_status[i].plane_states[j];
+			temp_plane.clip_rect = set[i].plane_states[j]->clip_rect;
+			temp_plane.dst_rect.x = set[i].plane_states[j]->dst_rect.x;
+			temp_plane.dst_rect.y = set[i].plane_states[j]->dst_rect.y;
 
-			if (memcmp(&temp_surf, set[i].surfaces[j], sizeof(temp_surf)) != 0)
+			if (memcmp(&temp_plane, set[i].plane_states[j], sizeof(temp_plane)) != 0)
 				return true;
 		}
 	}
@@ -683,8 +683,8 @@ static bool validate_surfaces(
 	int i, j;
 
 	for (i = 0; i < set_count; i++)
-		for (j = 0; j < set[i].surface_count; j++)
-			if (!dc_validate_plane(dc, set[i].surfaces[j]))
+		for (j = 0; j < set[i].plane_count; j++)
+			if (!dc_validate_plane(dc, set[i].plane_states[j]))
 				return false;
 
 	return true;
@@ -769,7 +769,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -893,7 +893,7 @@ static bool context_changed(
 
 static bool streams_changed(
 		struct core_dc *dc,
-		struct dc_stream *streams[],
+		struct dc_stream_state *streams[],
 		uint8_t stream_count)
 {
 	uint8_t i;
@@ -912,7 +912,7 @@ static bool streams_changed(
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
-	struct dc_stream *streams[],
+	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
 	bool ret = true;
@@ -958,7 +958,7 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
-	struct dc_stream *dc_streams[MAX_STREAMS] = {0};
+	struct dc_stream_state *dc_streams[MAX_STREAMS] = {0};
 
 	for (i = 0; i < context->stream_count; i++)
 		dc_streams[i] =  context->streams[i];
@@ -977,11 +977,11 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
-		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			const struct dc_plane_state *surface =
-					context->stream_status[i].surfaces[j];
+		for (j = 0; j < context->stream_status[i].plane_count; j++) {
+			const struct dc_plane_state *plane_state =
+					context->stream_status[i].plane_states[j];
 
-			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+			core_dc->hwss.apply_ctx_for_surface(core_dc, plane_state, context);
 
 			/*
 			 * enable stereo
@@ -1031,7 +1031,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		dc_stream_log(stream,
 				core_dc->ctx->logger,
@@ -1046,7 +1046,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 
 bool dc_commit_streams(
 	struct dc *dc,
-	struct dc_stream *streams[],
+	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1062,7 +1062,7 @@ bool dc_commit_streams(
 				__func__, stream_count);
 
 	for (i = 0; i < stream_count; i++) {
-		struct dc_stream *stream = streams[i];
+		struct dc_stream_state *stream = streams[i];
 		struct dc_stream_status *status = dc_stream_get_status(stream);
 		int j;
 
@@ -1073,9 +1073,9 @@ bool dc_commit_streams(
 		set[i].stream = stream;
 
 		if (status) {
-			set[i].surface_count = status->surface_count;
-			for (j = 0; j < status->surface_count; j++)
-				set[i].surfaces[j] = status->surfaces[j];
+			set[i].plane_count = status->plane_count;
+			for (j = 0; j < status->plane_count; j++)
+				set[i].plane_states[j] = status->plane_states[j];
 		}
 
 	}
@@ -1122,7 +1122,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL
-				|| context->res_ctx.pipe_ctx[i].surface == NULL)
+				|| context->res_ctx.pipe_ctx[i].plane_state == NULL)
 			core_dc->hwss.power_down_front_end(core_dc, i);
 
 	/* 3rd param should be true, temp w/a for RV*/
@@ -1134,11 +1134,11 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	return true;
 }
 
-bool dc_commit_surfaces_to_stream(
+bool dc_commit_planes_to_stream(
 		struct dc *dc,
-		struct dc_plane_state **new_surfaces,
-		uint8_t new_surface_count,
-		struct dc_stream *dc_stream)
+		struct dc_plane_state **plane_states,
+		uint8_t new_plane_count,
+		struct dc_stream_state *dc_stream)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
 	struct dc_flip_addrs flip_addr[MAX_SURFACES];
@@ -1162,37 +1162,37 @@ bool dc_commit_surfaces_to_stream(
 	stream_update->dst = dc_stream->dst;
 	stream_update->out_transfer_func = dc_stream->out_transfer_func;
 
-	for (i = 0; i < new_surface_count; i++) {
-		updates[i].surface = new_surfaces[i];
+	for (i = 0; i < new_plane_count; i++) {
+		updates[i].surface = plane_states[i];
 		updates[i].gamma =
-			(struct dc_gamma *)new_surfaces[i]->gamma_correction;
-		updates[i].in_transfer_func = new_surfaces[i]->in_transfer_func;
-		flip_addr[i].address = new_surfaces[i]->address;
-		flip_addr[i].flip_immediate = new_surfaces[i]->flip_immediate;
-		plane_info[i].color_space = new_surfaces[i]->color_space;
-		plane_info[i].format = new_surfaces[i]->format;
-		plane_info[i].plane_size = new_surfaces[i]->plane_size;
-		plane_info[i].rotation = new_surfaces[i]->rotation;
-		plane_info[i].horizontal_mirror = new_surfaces[i]->horizontal_mirror;
-		plane_info[i].stereo_format = new_surfaces[i]->stereo_format;
-		plane_info[i].tiling_info = new_surfaces[i]->tiling_info;
-		plane_info[i].visible = new_surfaces[i]->visible;
-		plane_info[i].per_pixel_alpha = new_surfaces[i]->per_pixel_alpha;
-		plane_info[i].dcc = new_surfaces[i]->dcc;
-		scaling_info[i].scaling_quality = new_surfaces[i]->scaling_quality;
-		scaling_info[i].src_rect = new_surfaces[i]->src_rect;
-		scaling_info[i].dst_rect = new_surfaces[i]->dst_rect;
-		scaling_info[i].clip_rect = new_surfaces[i]->clip_rect;
+			(struct dc_gamma *)plane_states[i]->gamma_correction;
+		updates[i].in_transfer_func = plane_states[i]->in_transfer_func;
+		flip_addr[i].address = plane_states[i]->address;
+		flip_addr[i].flip_immediate = plane_states[i]->flip_immediate;
+		plane_info[i].color_space = plane_states[i]->color_space;
+		plane_info[i].format = plane_states[i]->format;
+		plane_info[i].plane_size = plane_states[i]->plane_size;
+		plane_info[i].rotation = plane_states[i]->rotation;
+		plane_info[i].horizontal_mirror = plane_states[i]->horizontal_mirror;
+		plane_info[i].stereo_format = plane_states[i]->stereo_format;
+		plane_info[i].tiling_info = plane_states[i]->tiling_info;
+		plane_info[i].visible = plane_states[i]->visible;
+		plane_info[i].per_pixel_alpha = plane_states[i]->per_pixel_alpha;
+		plane_info[i].dcc = plane_states[i]->dcc;
+		scaling_info[i].scaling_quality = plane_states[i]->scaling_quality;
+		scaling_info[i].src_rect = plane_states[i]->src_rect;
+		scaling_info[i].dst_rect = plane_states[i]->dst_rect;
+		scaling_info[i].clip_rect = plane_states[i]->clip_rect;
 
 		updates[i].flip_addr = &flip_addr[i];
 		updates[i].plane_info = &plane_info[i];
 		updates[i].scaling_info = &scaling_info[i];
 	}
 
-	dc_update_surfaces_and_stream(
+	dc_update_planes_and_stream(
 			dc,
 			updates,
-			new_surface_count,
+			new_plane_count,
 			dc_stream, stream_update);
 
 	dc_post_update_surfaces_to_stream(dc);
@@ -1220,14 +1220,14 @@ void dc_release_validate_context(struct validate_context *context)
 
 static bool is_surface_in_context(
 		const struct validate_context *context,
-		const struct dc_plane_state *surface)
+		const struct dc_plane_state *plane_state)
 {
 	int j;
 
 	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (surface == pipe_ctx->surface) {
+		if (plane_state == pipe_ctx->plane_state) {
 			return true;
 		}
 	}
@@ -1371,7 +1371,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
-	if (stream_status == NULL || stream_status->surface_count != surface_count)
+	if (stream_status == NULL || stream_status->plane_count != surface_count)
 		return UPDATE_TYPE_FULL;
 
 	if (stream_update)
@@ -1393,9 +1393,9 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-void dc_update_surfaces_and_stream(struct dc *dc,
+void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1470,10 +1470,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		struct dc_plane_state *new_surfaces[MAX_SURFACES] = {0};
+		struct dc_plane_state *new_planes[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
-			new_surfaces[i] = srf_updates[i].surface;
+			new_planes[i] = srf_updates[i].surface;
 
 		/* initialize scratch memory for building context */
 		context = dm_alloc(sizeof(*context));
@@ -1487,7 +1487,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, stream,
+				new_planes, surface_count, stream,
 				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
@@ -1542,7 +1542,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-				if (pipe_ctx->surface != surface)
+				if (pipe_ctx->plane_state != surface)
 					continue;
 
 				resource_build_scaling_params(pipe_ctx);
@@ -1599,14 +1599,14 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
+		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->surface != surface)
+			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->plane_state != plane_state)
 				continue;
-			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
 			core_dc->hwss.pipe_control_lock(
@@ -1622,15 +1622,15 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 		struct pipe_ctx *cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
-		bool is_new_pipe_surface = cur_pipe_ctx->surface != pipe_ctx->surface;
+		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
-		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->surface)
+		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
 			continue;
 
 		if (!pipe_ctx->top_pipe)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, pipe_ctx->surface, context);
+					core_dc, pipe_ctx->plane_state, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
@@ -1638,7 +1638,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		if (is_new_pipe_surface) {
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 			core_dc->hwss.set_input_transfer_func(
-					pipe_ctx, pipe_ctx->surface);
+					pipe_ctx, pipe_ctx->plane_state);
 			core_dc->hwss.set_output_transfer_func(
 					pipe_ctx, pipe_ctx->stream);
 		}
@@ -1649,16 +1649,16 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
+		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, surface, context);
+					core_dc, plane_state, context);
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (pipe_ctx->surface != surface)
+			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
 			if (srf_updates[i].flip_addr)
@@ -1669,7 +1669,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 			if (srf_updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
-						pipe_ctx, pipe_ctx->surface);
+						pipe_ctx, pipe_ctx->plane_state);
 
 			if (stream_update != NULL &&
 					stream_update->out_transfer_func != NULL) {
@@ -1690,9 +1690,9 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		for (j = 0; j < surface_count; j++) {
 			if (update_type != UPDATE_TYPE_FULL &&
-			    srf_updates[j].surface != pipe_ctx->surface)
+			    srf_updates[j].surface != pipe_ctx->plane_state)
 				continue;
-			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
 			core_dc->hwss.pipe_control_lock(
@@ -1723,7 +1723,7 @@ uint8_t dc_get_current_stream_count(const struct dc *dc)
 	return core_dc->current_context->stream_count;
 }
 
-struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
+struct dc_stream_state *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	if (i < core_dc->current_context->stream_count)
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
index e8d4b8c..ca4f1db 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
@@ -38,7 +38,7 @@
 
 void pre_surface_trace(
 		const struct dc *dc,
-		const struct dc_plane_state *const *surfaces,
+		const struct dc_plane_state *const *plane_states,
 		int surface_count)
 {
 	int i;
@@ -46,111 +46,111 @@ void pre_surface_trace(
 	struct dal_logger *logger =  core_dc->ctx->logger;
 
 	for (i = 0; i < surface_count; i++) {
-		const struct dc_plane_state *surface = surfaces[i];
+		const struct dc_plane_state *plane_state = plane_states[i];
 
-		SURFACE_TRACE("Surface %d:\n", i);
+		SURFACE_TRACE("Planes %d:\n", i);
 
 		SURFACE_TRACE(
-				"surface->visible = %d;\n"
-				"surface->flip_immediate = %d;\n"
-				"surface->address.type = %d;\n"
-				"surface->address.grph.addr.quad_part = 0x%X;\n"
-				"surface->address.grph.meta_addr.quad_part = 0x%X;\n"
-				"surface->scaling_quality.h_taps = %d;\n"
-				"surface->scaling_quality.v_taps = %d;\n"
-				"surface->scaling_quality.h_taps_c = %d;\n"
-				"surface->scaling_quality.v_taps_c = %d;\n",
-				surface->visible,
-				surface->flip_immediate,
-				surface->address.type,
-				surface->address.grph.addr.quad_part,
-				surface->address.grph.meta_addr.quad_part,
-				surface->scaling_quality.h_taps,
-				surface->scaling_quality.v_taps,
-				surface->scaling_quality.h_taps_c,
-				surface->scaling_quality.v_taps_c);
+				"plane_state->visible = %d;\n"
+				"plane_state->flip_immediate = %d;\n"
+				"plane_state->address.type = %d;\n"
+				"plane_state->address.grph.addr.quad_part = 0x%X;\n"
+				"plane_state->address.grph.meta_addr.quad_part = 0x%X;\n"
+				"plane_state->scaling_quality.h_taps = %d;\n"
+				"plane_state->scaling_quality.v_taps = %d;\n"
+				"plane_state->scaling_quality.h_taps_c = %d;\n"
+				"plane_state->scaling_quality.v_taps_c = %d;\n",
+				plane_state->visible,
+				plane_state->flip_immediate,
+				plane_state->address.type,
+				plane_state->address.grph.addr.quad_part,
+				plane_state->address.grph.meta_addr.quad_part,
+				plane_state->scaling_quality.h_taps,
+				plane_state->scaling_quality.v_taps,
+				plane_state->scaling_quality.h_taps_c,
+				plane_state->scaling_quality.v_taps_c);
 
 		SURFACE_TRACE(
-				"surface->src_rect.x = %d;\n"
-				"surface->src_rect.y = %d;\n"
-				"surface->src_rect.width = %d;\n"
-				"surface->src_rect.height = %d;\n"
-				"surface->dst_rect.x = %d;\n"
-				"surface->dst_rect.y = %d;\n"
-				"surface->dst_rect.width = %d;\n"
-				"surface->dst_rect.height = %d;\n"
-				"surface->clip_rect.x = %d;\n"
-				"surface->clip_rect.y = %d;\n"
-				"surface->clip_rect.width = %d;\n"
-				"surface->clip_rect.height = %d;\n",
-				surface->src_rect.x,
-				surface->src_rect.y,
-				surface->src_rect.width,
-				surface->src_rect.height,
-				surface->dst_rect.x,
-				surface->dst_rect.y,
-				surface->dst_rect.width,
-				surface->dst_rect.height,
-				surface->clip_rect.x,
-				surface->clip_rect.y,
-				surface->clip_rect.width,
-				surface->clip_rect.height);
+				"plane_state->src_rect.x = %d;\n"
+				"plane_state->src_rect.y = %d;\n"
+				"plane_state->src_rect.width = %d;\n"
+				"plane_state->src_rect.height = %d;\n"
+				"plane_state->dst_rect.x = %d;\n"
+				"plane_state->dst_rect.y = %d;\n"
+				"plane_state->dst_rect.width = %d;\n"
+				"plane_state->dst_rect.height = %d;\n"
+				"plane_state->clip_rect.x = %d;\n"
+				"plane_state->clip_rect.y = %d;\n"
+				"plane_state->clip_rect.width = %d;\n"
+				"plane_state->clip_rect.height = %d;\n",
+				plane_state->src_rect.x,
+				plane_state->src_rect.y,
+				plane_state->src_rect.width,
+				plane_state->src_rect.height,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.height,
+				plane_state->clip_rect.x,
+				plane_state->clip_rect.y,
+				plane_state->clip_rect.width,
+				plane_state->clip_rect.height);
 
 		SURFACE_TRACE(
-				"surface->plane_size.grph.surface_size.x = %d;\n"
-				"surface->plane_size.grph.surface_size.y = %d;\n"
-				"surface->plane_size.grph.surface_size.width = %d;\n"
-				"surface->plane_size.grph.surface_size.height = %d;\n"
-				"surface->plane_size.grph.surface_pitch = %d;\n",
-				surface->plane_size.grph.surface_size.x,
-				surface->plane_size.grph.surface_size.y,
-				surface->plane_size.grph.surface_size.width,
-				surface->plane_size.grph.surface_size.height,
-				surface->plane_size.grph.surface_pitch);
+				"plane_state->plane_size.grph.surface_size.x = %d;\n"
+				"plane_state->plane_size.grph.surface_size.y = %d;\n"
+				"plane_state->plane_size.grph.surface_size.width = %d;\n"
+				"plane_state->plane_size.grph.surface_size.height = %d;\n"
+				"plane_state->plane_size.grph.surface_pitch = %d;\n",
+				plane_state->plane_size.grph.surface_size.x,
+				plane_state->plane_size.grph.surface_size.y,
+				plane_state->plane_size.grph.surface_size.width,
+				plane_state->plane_size.grph.surface_size.height,
+				plane_state->plane_size.grph.surface_pitch);
 
 
 		SURFACE_TRACE(
-				"surface->tiling_info.gfx8.num_banks = %d;\n"
-				"surface->tiling_info.gfx8.bank_width = %d;\n"
-				"surface->tiling_info.gfx8.bank_width_c = %d;\n"
-				"surface->tiling_info.gfx8.bank_height = %d;\n"
-				"surface->tiling_info.gfx8.bank_height_c = %d;\n"
-				"surface->tiling_info.gfx8.tile_aspect = %d;\n"
-				"surface->tiling_info.gfx8.tile_aspect_c = %d;\n"
-				"surface->tiling_info.gfx8.tile_split = %d;\n"
-				"surface->tiling_info.gfx8.tile_split_c = %d;\n"
-				"surface->tiling_info.gfx8.tile_mode = %d;\n"
-				"surface->tiling_info.gfx8.tile_mode_c = %d;\n",
-				surface->tiling_info.gfx8.num_banks,
-				surface->tiling_info.gfx8.bank_width,
-				surface->tiling_info.gfx8.bank_width_c,
-				surface->tiling_info.gfx8.bank_height,
-				surface->tiling_info.gfx8.bank_height_c,
-				surface->tiling_info.gfx8.tile_aspect,
-				surface->tiling_info.gfx8.tile_aspect_c,
-				surface->tiling_info.gfx8.tile_split,
-				surface->tiling_info.gfx8.tile_split_c,
-				surface->tiling_info.gfx8.tile_mode,
-				surface->tiling_info.gfx8.tile_mode_c);
+				"plane_state->tiling_info.gfx8.num_banks = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_width = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_width_c = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_height = %d;\n"
+				"plane_state->tiling_info.gfx8.bank_height_c = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_aspect = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_aspect_c = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_split = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_split_c = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_mode = %d;\n"
+				"plane_state->tiling_info.gfx8.tile_mode_c = %d;\n",
+				plane_state->tiling_info.gfx8.num_banks,
+				plane_state->tiling_info.gfx8.bank_width,
+				plane_state->tiling_info.gfx8.bank_width_c,
+				plane_state->tiling_info.gfx8.bank_height,
+				plane_state->tiling_info.gfx8.bank_height_c,
+				plane_state->tiling_info.gfx8.tile_aspect,
+				plane_state->tiling_info.gfx8.tile_aspect_c,
+				plane_state->tiling_info.gfx8.tile_split,
+				plane_state->tiling_info.gfx8.tile_split_c,
+				plane_state->tiling_info.gfx8.tile_mode,
+				plane_state->tiling_info.gfx8.tile_mode_c);
 
 		SURFACE_TRACE(
-				"surface->tiling_info.gfx8.pipe_config = %d;\n"
-				"surface->tiling_info.gfx8.array_mode = %d;\n"
-				"surface->color_space = %d;\n"
-				"surface->dcc.enable = %d;\n"
-				"surface->format = %d;\n"
-				"surface->rotation = %d;\n"
-				"surface->stereo_format = %d;\n",
-				surface->tiling_info.gfx8.pipe_config,
-				surface->tiling_info.gfx8.array_mode,
-				surface->color_space,
-				surface->dcc.enable,
-				surface->format,
-				surface->rotation,
-				surface->stereo_format);
-
-		SURFACE_TRACE("surface->tiling_info.gfx9.swizzle = %d;\n",
-				surface->tiling_info.gfx9.swizzle);
+				"plane_state->tiling_info.gfx8.pipe_config = %d;\n"
+				"plane_state->tiling_info.gfx8.array_mode = %d;\n"
+				"plane_state->color_space = %d;\n"
+				"plane_state->dcc.enable = %d;\n"
+				"plane_state->format = %d;\n"
+				"plane_state->rotation = %d;\n"
+				"plane_state->stereo_format = %d;\n",
+				plane_state->tiling_info.gfx8.pipe_config,
+				plane_state->tiling_info.gfx8.array_mode,
+				plane_state->color_space,
+				plane_state->dcc.enable,
+				plane_state->format,
+				plane_state->rotation,
+				plane_state->stereo_format);
+
+		SURFACE_TRACE("plane_state->tiling_info.gfx9.swizzle = %d;\n",
+				plane_state->tiling_info.gfx9.swizzle);
 
 		SURFACE_TRACE("\n");
 	}
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index a983a5e..7a2fe2f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -1143,7 +1143,7 @@ static void dpcd_configure_panel_mode(
 
 static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	union down_spread_ctrl downspread;
 
@@ -1159,7 +1159,7 @@ static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 
 static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_status status;
 	bool skip_video_pattern;
 	struct dc_link *link = stream->sink->link;
@@ -1250,7 +1250,7 @@ static enum dc_status enable_link_dp_mst(struct pipe_ctx *pipe_ctx)
 
 static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	enum dc_color_depth display_color_depth;
 
@@ -1341,7 +1341,7 @@ static void disable_link(struct dc_link *link, enum signal_type signal)
 }
 
 enum dc_status dc_link_validate_mode_timing(
-		const struct dc_stream *stream,
+		const struct dc_stream_state *stream,
 		struct dc_link *link,
 		const struct dc_crtc_timing *timing)
 {
@@ -1374,7 +1374,7 @@ enum dc_status dc_link_validate_mode_timing(
 
 
 bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
-		uint32_t frame_ramp, const struct dc_stream *stream)
+		uint32_t frame_ramp, const struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct abm *abm = core_dc->res_pool->abm;
@@ -1450,7 +1450,7 @@ bool dc_link_get_psr_state(const struct dc_link *link, uint32_t *psr_state)
 }
 
 bool dc_link_setup_psr(struct dc_link *link,
-		const struct dc_stream *stream, struct psr_config *psr_config,
+		const struct dc_stream_state *stream, struct psr_config *psr_config,
 		struct psr_context *psr_context)
 {
 	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
@@ -1587,7 +1587,7 @@ void core_link_resume(struct dc_link *link)
 		program_hpd_filter(link);
 }
 
-static struct fixed31_32 get_pbn_per_slot(struct dc_stream *stream)
+static struct fixed31_32 get_pbn_per_slot(struct dc_stream_state *stream)
 {
 	struct dc_link_settings *link_settings =
 			&stream->sink->link->cur_link_settings;
@@ -1696,7 +1696,7 @@ static void update_mst_stream_alloc_table(
  */
 static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	struct link_encoder *link_encoder = link->link_enc;
 	struct stream_encoder *stream_encoder = pipe_ctx->stream_enc;
@@ -1778,7 +1778,7 @@ static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 
 static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	struct link_encoder *link_encoder = link->link_enc;
 	struct stream_encoder *stream_encoder = pipe_ctx->stream_enc;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 1750634..50724f9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -1433,7 +1433,7 @@ bool dp_validate_mode_timing(
 		return false;
 }
 
-void decide_link_settings(struct dc_stream *stream,
+void decide_link_settings(struct dc_stream_state *stream,
 	struct dc_link_settings *link_setting)
 {
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d346101..7c30962 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -294,8 +294,8 @@ void resource_reference_clock_source(
 }
 
 bool resource_are_streams_timing_synchronizable(
-	struct dc_stream *stream1,
-	struct dc_stream *stream2)
+	struct dc_stream_state *stream1,
+	struct dc_stream_state *stream2)
 {
 	if (stream1->timing.h_total != stream2->timing.h_total)
 		return false;
@@ -430,17 +430,17 @@ static void rect_swap_helper(struct rect *rect)
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect surf_src = surface->src_rect;
+	struct rect surf_src = plane_state->src_rect;
 	struct rect clip = { 0 };
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 	bool pri_split = pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface;
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
@@ -448,41 +448,41 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		sec_split = false;
 	}
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
-	clip.x = stream->src.x > surface->clip_rect.x ?
-			stream->src.x : surface->clip_rect.x;
+	clip.x = stream->src.x > plane_state->clip_rect.x ?
+			stream->src.x : plane_state->clip_rect.x;
 
 	clip.width = stream->src.x + stream->src.width <
-			surface->clip_rect.x + surface->clip_rect.width ?
+			plane_state->clip_rect.x + plane_state->clip_rect.width ?
 			stream->src.x + stream->src.width - clip.x :
-			surface->clip_rect.x + surface->clip_rect.width - clip.x ;
+			plane_state->clip_rect.x + plane_state->clip_rect.width - clip.x ;
 
-	clip.y = stream->src.y > surface->clip_rect.y ?
-			stream->src.y : surface->clip_rect.y;
+	clip.y = stream->src.y > plane_state->clip_rect.y ?
+			stream->src.y : plane_state->clip_rect.y;
 
 	clip.height = stream->src.y + stream->src.height <
-			surface->clip_rect.y + surface->clip_rect.height ?
+			plane_state->clip_rect.y + plane_state->clip_rect.height ?
 			stream->src.y + stream->src.height - clip.y :
-			surface->clip_rect.y + surface->clip_rect.height - clip.y ;
+			plane_state->clip_rect.y + plane_state->clip_rect.height - clip.y ;
 
 	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	data->viewport.x = surf_src.x + (clip.x - surface->dst_rect.x) *
-			surf_src.width / surface->dst_rect.width;
+	data->viewport.x = surf_src.x + (clip.x - plane_state->dst_rect.x) *
+			surf_src.width / plane_state->dst_rect.width;
 	data->viewport.width = clip.width *
-			surf_src.width / surface->dst_rect.width;
+			surf_src.width / plane_state->dst_rect.width;
 
-	data->viewport.y = surf_src.y + (clip.y - surface->dst_rect.y) *
-			surf_src.height / surface->dst_rect.height;
+	data->viewport.y = surf_src.y + (clip.y - plane_state->dst_rect.y) *
+			surf_src.height / plane_state->dst_rect.height;
 	data->viewport.height = clip.height *
-			surf_src.height / surface->dst_rect.height;
+			surf_src.height / plane_state->dst_rect.height;
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
@@ -498,13 +498,13 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	/* Handle hsplit */
 	if (pri_split || sec_split) {
 		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
-		bool right_view = (sec_split != surface->horizontal_mirror) !=
-					(surface->rotation == ROTATION_ANGLE_180);
+		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
+					(plane_state->rotation == ROTATION_ANGLE_180);
 
-		if (surface->rotation == ROTATION_ANGLE_90
-				|| surface->rotation == ROTATION_ANGLE_270)
+		if (plane_state->rotation == ROTATION_ANGLE_90
+				|| plane_state->rotation == ROTATION_ANGLE_270)
 			/* Secondary_pipe XOR Rotation_270 */
-			right_view = (surface->rotation == ROTATION_ANGLE_270) != sec_split;
+			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
 
 		if (right_view) {
 			data->viewport.width /= 2;
@@ -520,8 +520,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		}
 	}
 
-	if (surface->rotation == ROTATION_ANGLE_90 ||
-			surface->rotation == ROTATION_ANGLE_270) {
+	if (plane_state->rotation == ROTATION_ANGLE_90 ||
+			plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -529,14 +529,14 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = pipe_ctx->stream;
-	struct rect surf_src = surface->src_rect;
-	struct rect surf_clip = surface->clip_rect;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
+	struct rect surf_src = plane_state->src_rect;
+	struct rect surf_clip = plane_state->clip_rect;
 	int recout_full_x, recout_full_y;
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.recout.x = stream->dst.x;
@@ -568,8 +568,8 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 						- pipe_ctx->scl_data.recout.y;
 
 	/* Handle h & vsplit */
-	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
-		pipe_ctx->surface) {
+	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
+		pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 			pipe_ctx->scl_data.recout.height /= 2;
 			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
@@ -581,7 +581,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
 		else
@@ -592,13 +592,13 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
-	recout_full_x = stream->dst.x + (surface->dst_rect.x -  stream->src.x)
+	recout_full_x = stream->dst.x + (plane_state->dst_rect.x -  stream->src.x)
 					* stream->dst.width / stream->src.width -
-			surf_src.x * surface->dst_rect.width / surf_src.width
+			surf_src.x * plane_state->dst_rect.width / surf_src.width
 					* stream->dst.width / stream->src.width;
-	recout_full_y = stream->dst.y + (surface->dst_rect.y -  stream->src.y)
+	recout_full_y = stream->dst.y + (plane_state->dst_rect.y -  stream->src.y)
 					* stream->dst.height / stream->src.height -
-			surf_src.y * surface->dst_rect.height / surf_src.height
+			surf_src.y * plane_state->dst_rect.height / surf_src.height
 					* stream->dst.height / stream->src.height;
 
 	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
@@ -607,24 +607,24 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = pipe_ctx->stream;
-	struct rect surf_src = surface->src_rect;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
+	struct rect surf_src = plane_state->src_rect;
 	const int in_w = stream->src.width;
 	const int in_h = stream->src.height;
 	const int out_w = stream->dst.width;
 	const int out_h = stream->dst.height;
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
 					surf_src.width,
-					surface->dst_rect.width);
+					plane_state->dst_rect.width);
 	pipe_ctx->scl_data.ratios.vert = dal_fixed31_32_from_fraction(
 					surf_src.height,
-					surface->dst_rect.height);
+					plane_state->dst_rect.height);
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
@@ -649,13 +649,13 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect src = pipe_ctx->surface->src_rect;
+	struct rect src = pipe_ctx->plane_state->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
@@ -805,8 +805,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -814,7 +814,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
@@ -824,7 +824,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
 	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
-			pipe_ctx->surface->format);
+			pipe_ctx->plane_state->format);
 
 	calculate_scaling_ratios(pipe_ctx);
 
@@ -846,14 +846,14 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	/* Taps calculations */
 	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+		pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
 		pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
 
 		res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-			pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+			pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -869,10 +869,10 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				pipe_ctx->scl_data.viewport.width,
 				pipe_ctx->scl_data.viewport.x,
 				pipe_ctx->scl_data.viewport.y,
-				surface->dst_rect.height,
-				surface->dst_rect.width,
-				surface->dst_rect.x,
-				surface->dst_rect.y);
+				plane_state->dst_rect.height,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y);
 
 	return res;
 }
@@ -885,7 +885,7 @@ enum dc_status resource_build_scaling_params_for_context(
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
+		if (context->res_ctx.pipe_ctx[i].plane_state != NULL &&
 				context->res_ctx.pipe_ctx[i].stream != NULL)
 			if (!resource_build_scaling_params(&context->res_ctx.pipe_ctx[i]))
 				return DC_FAIL_SCALING;
@@ -920,7 +920,7 @@ struct pipe_ctx *find_idle_secondary_pipe(
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -940,7 +940,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 	struct resource_context *res_ctx = &context->res_ctx;
@@ -954,13 +954,13 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	if (!head_pipe)
 		ASSERT(0);
 
-	if (!head_pipe->surface)
+	if (!head_pipe->plane_state)
 		return head_pipe;
 
 	/* Re-use pipe already acquired for this stream if available*/
 	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				!res_ctx->pipe_ctx[i].surface) {
+				!res_ctx->pipe_ctx[i].plane_state) {
 			return &res_ctx->pipe_ctx[i];
 		}
 	}
@@ -979,7 +979,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 static void release_free_pipes_for_stream(
 		struct resource_context *res_ctx,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 
@@ -987,7 +987,7 @@ static void release_free_pipes_for_stream(
 		/* never release the topmost pipe*/
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				res_ctx->pipe_ctx[i].top_pipe &&
-				!res_ctx->pipe_ctx[i].surface) {
+				!res_ctx->pipe_ctx[i].plane_state) {
 			memset(&res_ctx->pipe_ctx[i], 0, sizeof(struct pipe_ctx));
 		}
 	}
@@ -997,7 +997,7 @@ static void release_free_pipes_for_stream(
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 
@@ -1005,7 +1005,7 @@ static int acquire_first_split_pipe(
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
 		if (pipe_ctx->top_pipe &&
-				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+				pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state) {
 			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
 			if (pipe_ctx->bottom_pipe)
 				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
@@ -1028,9 +1028,9 @@ static int acquire_first_split_pipe(
 #endif
 
 bool resource_attach_surfaces_to_context(
-		struct dc_plane_state * const *surfaces,
+		struct dc_plane_state * const *plane_states,
 		int surface_count,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct validate_context *context,
 		const struct resource_pool *pool)
 {
@@ -1057,25 +1057,25 @@ bool resource_attach_surfaces_to_context(
 
 	/* retain new surfaces */
 	for (i = 0; i < surface_count; i++)
-		dc_surface_retain(surfaces[i]);
+		dc_plane_state_retain(plane_states[i]);
 
 	/* detach surfaces from pipes */
 	for (i = 0; i < pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == stream) {
-			context->res_ctx.pipe_ctx[i].surface = NULL;
+			context->res_ctx.pipe_ctx[i].plane_state = NULL;
 			context->res_ctx.pipe_ctx[i].bottom_pipe = NULL;
 		}
 
 	/* release existing surfaces*/
-	for (i = 0; i < stream_status->surface_count; i++)
-		dc_surface_release(stream_status->surfaces[i]);
+	for (i = 0; i < stream_status->plane_count; i++)
+		dc_plane_state_release(stream_status->plane_states[i]);
 
-	for (i = surface_count; i < stream_status->surface_count; i++)
-		stream_status->surfaces[i] = NULL;
+	for (i = surface_count; i < stream_status->plane_count; i++)
+		stream_status->plane_states[i] = NULL;
 
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = surfaces[i];
+		struct dc_plane_state *plane_state = plane_states[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, stream);
 
@@ -1087,11 +1087,11 @@ bool resource_attach_surfaces_to_context(
 		}
 #endif
 		if (!free_pipe) {
-			stream_status->surfaces[i] = NULL;
+			stream_status->plane_states[i] = NULL;
 			return false;
 		}
 
-		free_pipe->surface = surface;
+		free_pipe->plane_state = plane_state;
 
 		if (tail_pipe) {
 			free_pipe->tg = tail_pipe->tg;
@@ -1110,16 +1110,16 @@ bool resource_attach_surfaces_to_context(
 
 	/* assign new surfaces*/
 	for (i = 0; i < surface_count; i++)
-		stream_status->surfaces[i] = surfaces[i];
+		stream_status->plane_states[i] = plane_states[i];
 
-	stream_status->surface_count = surface_count;
+	stream_status->plane_count = surface_count;
 
 	return true;
 }
 
 
-static bool is_timing_changed(struct dc_stream *cur_stream,
-		struct dc_stream *new_stream)
+static bool is_timing_changed(struct dc_stream_state *cur_stream,
+		struct dc_stream_state *new_stream)
 {
 	if (cur_stream == NULL)
 		return true;
@@ -1141,7 +1141,7 @@ static bool is_timing_changed(struct dc_stream *cur_stream,
 }
 
 static bool are_stream_backends_same(
-	struct dc_stream *stream_a, struct dc_stream *stream_b)
+	struct dc_stream_state *stream_a, struct dc_stream_state *stream_b)
 {
 	if (stream_a == stream_b)
 		return true;
@@ -1156,7 +1156,7 @@ static bool are_stream_backends_same(
 }
 
 bool dc_is_stream_unchanged(
-	struct dc_stream *old_stream, struct dc_stream *stream)
+	struct dc_stream_state *old_stream, struct dc_stream_state *stream)
 {
 
 	if (!are_stream_backends_same(old_stream, stream))
@@ -1180,17 +1180,17 @@ bool resource_validate_attach_surfaces(
 					old_context->streams[j],
 					context->streams[i])) {
 				if (!resource_attach_surfaces_to_context(
-						old_context->stream_status[j].surfaces,
-						old_context->stream_status[j].surface_count,
+						old_context->stream_status[j].plane_states,
+						old_context->stream_status[j].plane_count,
 						context->streams[i],
 						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
 			}
-		if (set[i].surface_count != 0)
+		if (set[i].plane_count != 0)
 			if (!resource_attach_surfaces_to_context(
-					set[i].surfaces,
-					set[i].surface_count,
+					set[i].plane_states,
+					set[i].plane_count,
 					context->streams[i],
 					context, pool))
 				return false;
@@ -1233,7 +1233,7 @@ static void set_audio_in_use(
 static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 
@@ -1260,7 +1260,7 @@ static int acquire_first_free_pipe(
 static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 	int j = -1;
@@ -1311,7 +1311,7 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-static void update_stream_signal(struct dc_stream *stream)
+static void update_stream_signal(struct dc_stream_state *stream)
 {
 	if (stream->output_signal == SIGNAL_TYPE_NONE) {
 		struct dc_sink *dc_sink = stream->sink;
@@ -1334,12 +1334,12 @@ static void update_stream_signal(struct dc_stream *stream)
 }
 
 bool resource_is_stream_unchanged(
-	struct validate_context *old_context, struct dc_stream *stream)
+	struct validate_context *old_context, struct dc_stream_state *stream)
 {
 	int i;
 
 	for (i = 0; i < old_context->stream_count; i++) {
-		struct dc_stream *old_stream = old_context->streams[i];
+		struct dc_stream_state *old_stream = old_context->streams[i];
 
 		if (are_stream_backends_same(old_stream, stream))
 				return true;
@@ -1351,23 +1351,23 @@ bool resource_is_stream_unchanged(
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
-	struct dc_plane_state *surface = to_pipe_ctx->surface;
-	struct dc_stream *stream = to_pipe_ctx->stream;
+	struct dc_plane_state *plane_state = to_pipe_ctx->plane_state;
+	struct dc_stream_state *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
 	to_pipe_ctx->stream = stream;
-	if (surface != NULL)
-		to_pipe_ctx->surface = surface;
+	if (plane_state != NULL)
+		to_pipe_ctx->plane_state = plane_state;
 }
 
-static struct dc_stream *find_pll_sharable_stream(
-		struct dc_stream *stream_needs_pll,
+static struct dc_stream_state *find_pll_sharable_stream(
+		struct dc_stream_state *stream_needs_pll,
 		struct validate_context *context)
 {
 	int i;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream_has_pll = context->streams[i];
+		struct dc_stream_state *stream_has_pll = context->streams[i];
 
 		/* We are looking for non dp, non virtual stream */
 		if (resource_are_streams_timing_synchronizable(
@@ -1411,7 +1411,7 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-static void calculate_phy_pix_clks(struct dc_stream *stream)
+static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 {
 	update_stream_signal(stream);
 
@@ -1433,7 +1433,7 @@ enum dc_status resource_map_pool_resources(
 	int i, j;
 
 	for (i = 0; old_context && i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (!resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
@@ -1486,7 +1486,7 @@ enum dc_status resource_map_pool_resources(
 	}
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 		struct pipe_ctx *pipe_ctx = NULL;
 		int pipe_idx = -1;
 
@@ -1581,7 +1581,7 @@ static void set_avi_info_frame(
 		struct encoder_info_packet *info_packet,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
 	struct info_frame info_frame = { {0} };
 	uint32_t pixel_encoding = 0;
@@ -1821,7 +1821,7 @@ static void set_avi_info_frame(
 
 static void set_vendor_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	uint32_t length = 0;
 	bool hdmi_vic_mode = false;
@@ -1934,7 +1934,7 @@ static void set_vendor_info_packet(
 
 static void set_spd_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	/* SPD info packet for FreeSync */
 
@@ -2055,18 +2055,18 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_plane_state *surface,
-		struct dc_stream *stream)
+		struct dc_plane_state *plane_state,
+		struct dc_stream_state *stream)
 {
 	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
 	struct dc_hdr_static_metadata hdr_metadata;
 	uint32_t data;
 
-	if (!surface)
+	if (!plane_state)
 		return;
 
-	hdr_metadata = surface->hdr_static_ctx;
+	hdr_metadata = plane_state->hdr_static_ctx;
 
 	if (!hdr_metadata.hdr_supported)
 		return;
@@ -2159,7 +2159,7 @@ static void set_hdr_static_info_packet(
 
 static void set_vsc_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
@@ -2204,11 +2204,11 @@ void dc_resource_validate_ctx_destruct(struct validate_context *context)
 	int i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		for (j = 0; j < context->stream_status[i].surface_count; j++)
-			dc_surface_release(
-				context->stream_status[i].surfaces[j]);
+		for (j = 0; j < context->stream_status[i].plane_count; j++)
+			dc_plane_state_release(
+				context->stream_status[i].plane_states[j]);
 
-		context->stream_status[i].surface_count = 0;
+		context->stream_status[i].plane_count = 0;
 		dc_stream_release(context->streams[i]);
 		context->streams[i] = NULL;
 	}
@@ -2240,9 +2240,9 @@ void dc_resource_validate_ctx_copy_construct(
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {
 		dc_stream_retain(dst_ctx->streams[i]);
-		for (j = 0; j < dst_ctx->stream_status[i].surface_count; j++)
-			dc_surface_retain(
-				dst_ctx->stream_status[i].surfaces[j]);
+		for (j = 0; j < dst_ctx->stream_status[i].plane_count; j++)
+			dc_plane_state_retain(
+				dst_ctx->stream_status[i].plane_states[j]);
 	}
 
 	/* context refcount should not be overridden */
@@ -2288,7 +2288,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->surface, pipe_ctx->stream);
+				pipe_ctx->plane_state, pipe_ctx->stream);
 
 	} else if (dc_is_dp_signal(signal)) {
 		set_vsc_info_packet(&info->vsc, pipe_ctx->stream);
@@ -2296,7 +2296,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->surface, pipe_ctx->stream);
+				pipe_ctx->plane_state, pipe_ctx->stream);
 	}
 
 	patch_gamut_packet_checksum(&info->gamut);
@@ -2312,7 +2312,7 @@ enum dc_status resource_map_clock_resources(
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -2392,7 +2392,7 @@ bool pipe_need_reprogram(
 	return false;
 }
 
-void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
+void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth)
 {
 	enum dc_dither_option option = stream->dither_option;
@@ -2502,7 +2502,7 @@ void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream)
+bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_context *dc_ctx = core_dc->ctx;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a77e1e8..2b65068 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -34,7 +34,7 @@
  * Private functions
  ******************************************************************************/
 
-static bool construct(struct dc_stream *stream,
+static bool construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
@@ -84,7 +84,7 @@ static bool construct(struct dc_stream *stream,
 	return true;
 }
 
-static void destruct(struct dc_stream *stream)
+static void destruct(struct dc_stream_state *stream)
 {
 	dc_sink_release(stream->sink);
 	if (stream->out_transfer_func != NULL) {
@@ -94,14 +94,14 @@ static void destruct(struct dc_stream *stream)
 	}
 }
 
-void dc_stream_retain(struct dc_stream *stream)
+void dc_stream_retain(struct dc_stream_state *stream)
 {
 
 	ASSERT(stream->ref_count > 0);
 	stream->ref_count++;
 }
 
-void dc_stream_release(struct dc_stream *stream)
+void dc_stream_release(struct dc_stream_state *stream)
 {
 
 	if (stream != NULL) {
@@ -115,15 +115,15 @@ void dc_stream_release(struct dc_stream *stream)
 	}
 }
 
-struct dc_stream *dc_create_stream_for_sink(
+struct dc_stream_state *dc_create_stream_for_sink(
 		struct dc_sink *sink)
 {
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 
 	if (sink == NULL)
 		goto alloc_fail;
 
-	stream = dm_alloc(sizeof(struct dc_stream));
+	stream = dm_alloc(sizeof(struct dc_stream_state));
 
 	if (NULL == stream)
 		goto alloc_fail;
@@ -143,7 +143,7 @@ struct dc_stream *dc_create_stream_for_sink(
 }
 
 struct dc_stream_status *dc_stream_get_status(
-	struct dc_stream *stream)
+	struct dc_stream_state *stream)
 {
 	uint8_t i;
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
@@ -161,7 +161,7 @@ struct dc_stream_status *dc_stream_get_status(
  * Update the cursor attributes and set cursor surface address
  */
 bool dc_stream_set_cursor_attributes(
-	const struct dc_stream *stream,
+	const struct dc_stream_state *stream,
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
@@ -185,7 +185,7 @@ bool dc_stream_set_cursor_attributes(
 
 		if (pipe_ctx->stream != stream || !pipe_ctx->ipp)
 			continue;
-		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
 
 		pipe_ctx->ipp->funcs->ipp_cursor_set_attributes(
@@ -196,7 +196,7 @@ bool dc_stream_set_cursor_attributes(
 }
 
 bool dc_stream_set_cursor_position(
-	struct dc_stream *stream,
+	struct dc_stream_state *stream,
 	const struct dc_cursor_position *position)
 {
 	int i;
@@ -229,14 +229,14 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->ipp || !pipe_ctx->surface)
+				!pipe_ctx->ipp || !pipe_ctx->plane_state)
 			continue;
 
-		if (pipe_ctx->surface->address.type
+		if (pipe_ctx->plane_state->address.type
 				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 			pos_cpy.enable = false;
 
-		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			pos_cpy.enable = false;
 
 		ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
@@ -245,7 +245,7 @@ bool dc_stream_set_cursor_position(
 	return true;
 }
 
-uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream)
+uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
@@ -264,7 +264,7 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream)
 	return 0;
 }
 
-bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
+bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 				  uint32_t *v_blank_start,
 				  uint32_t *v_blank_end,
 				  uint32_t *h_position,
@@ -297,7 +297,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
 
 
 void dc_stream_log(
-	const struct dc_stream *stream,
+	const struct dc_stream_state *stream,
 	struct dal_logger *dm_logger,
 	enum dc_log_type log_type)
 {
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 941b367..3bcca2d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -34,75 +34,75 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct dc_plane_state *surface)
+static bool construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
-	surface->ctx = ctx;
-	memset(&surface->hdr_static_ctx,
+	plane_state->ctx = ctx;
+	memset(&plane_state->hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 
-static void destruct(struct dc_plane_state *surface)
+static void destruct(struct dc_plane_state *plane_state)
 {
-	if (surface->gamma_correction != NULL) {
-		dc_gamma_release(&surface->gamma_correction);
+	if (plane_state->gamma_correction != NULL) {
+		dc_gamma_release(&plane_state->gamma_correction);
 	}
-	if (surface->in_transfer_func != NULL) {
+	if (plane_state->in_transfer_func != NULL) {
 		dc_transfer_func_release(
-				surface->in_transfer_func);
-		surface->in_transfer_func = NULL;
+				plane_state->in_transfer_func);
+		plane_state->in_transfer_func = NULL;
 	}
 }
 
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-void enable_surface_flip_reporting(struct dc_plane_state *surface,
+void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 		uint32_t controller_id)
 {
-	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
+	plane_state->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_plane_state *dc_create_surface(const struct dc *dc)
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_plane_state *surface = dm_alloc(sizeof(*surface));
+	struct dc_plane_state *plane_state = dm_alloc(sizeof(*plane_state));
 
-	if (NULL == surface)
+	if (NULL == plane_state)
 		goto alloc_fail;
 
-	if (false == construct(core_dc->ctx, surface))
+	if (false == construct(core_dc->ctx, plane_state))
 		goto construct_fail;
 
-	++surface->ref_count;
+	++plane_state->ref_count;
 
-	return surface;
+	return plane_state;
 
 construct_fail:
-	dm_free(surface);
+	dm_free(plane_state);
 
 alloc_fail:
 	return NULL;
 }
 
-const struct dc_surface_status *dc_surface_get_status(
-		const struct dc_plane_state *dc_surface)
+const struct dc_plane_status *dc_plane_get_status(
+		const struct dc_plane_state *plane_state)
 {
-	const struct dc_surface_status *surface_status;
+	const struct dc_plane_status *plane_status;
 	struct core_dc *core_dc;
 	int i;
 
-	if (!dc_surface ||
-		!dc_surface->ctx ||
-		!dc_surface->ctx->dc) {
+	if (!plane_state ||
+		!plane_state->ctx ||
+		!plane_state->ctx->dc) {
 		ASSERT(0);
 		return NULL; /* remove this if above assert never hit */
 	}
 
-	surface_status = &dc_surface->status;
-	core_dc = DC_TO_CORE(dc_surface->ctx->dc);
+	plane_status = &plane_state->status;
+	core_dc = DC_TO_CORE(plane_state->ctx->dc);
 
 	if (core_dc->current_context == NULL)
 		return NULL;
@@ -111,29 +111,29 @@ const struct dc_surface_status *dc_surface_get_status(
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != dc_surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		core_dc->hwss.update_pending_status(pipe_ctx);
 	}
 
-	return surface_status;
+	return plane_status;
 }
 
-void dc_surface_retain(struct dc_plane_state *surface)
+void dc_plane_state_retain(struct dc_plane_state *plane_state)
 {
-	ASSERT(surface->ref_count > 0);
-	++surface->ref_count;
+	ASSERT(plane_state->ref_count > 0);
+	++plane_state->ref_count;
 }
 
-void dc_surface_release(struct dc_plane_state *surface)
+void dc_plane_state_release(struct dc_plane_state *plane_state)
 {
-	ASSERT(surface->ref_count > 0);
-	--surface->ref_count;
+	ASSERT(plane_state->ref_count > 0);
+	--plane_state->ref_count;
 
-	if (surface->ref_count == 0) {
-		destruct(surface);
-		dm_free(surface);
+	if (plane_state->ref_count == 0) {
+		destruct(plane_state);
+		dm_free(plane_state);
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 2545502..4568d55 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -47,7 +47,7 @@ struct dc_caps {
 	uint32_t max_links;
 	uint32_t max_audios;
 	uint32_t max_slave_planes;
-	uint32_t max_surfaces;
+	uint32_t max_planes;
 	uint32_t max_downscale_ratio;
 	uint32_t i2c_speed_in_khz;
 
@@ -101,30 +101,30 @@ struct dc_cap_funcs {
 			struct dc_surface_dcc_cap *output);
 };
 
-struct dc_stream_funcs {
+struct dc_stream_state_funcs {
 	bool (*adjust_vmin_vmax)(struct dc *dc,
-			struct dc_stream **stream,
+			struct dc_stream_state **stream,
 			int num_streams,
 			int vmin,
 			int vmax);
 	bool (*get_crtc_position)(struct dc *dc,
-			struct dc_stream **stream,
+			struct dc_stream_state **stream,
 			int num_streams,
 			unsigned int *v_pos,
 			unsigned int *nom_v_pos);
 
 	bool (*set_gamut_remap)(struct dc *dc,
-			const struct dc_stream *stream);
+			const struct dc_stream_state *stream);
 
 	bool (*program_csc_matrix)(struct dc *dc,
-			struct dc_stream *stream);
+			struct dc_stream_state *stream);
 
 	void (*set_static_screen_events)(struct dc *dc,
-			struct dc_stream **stream,
+			struct dc_stream_state **stream,
 			int num_streams,
 			const struct dc_static_screen_events *events);
 
-	void (*set_dither_option)(struct dc_stream *stream,
+	void (*set_dither_option)(struct dc_stream_state *stream,
 			enum dc_dither_option option);
 };
 
@@ -190,7 +190,7 @@ struct dc_debug {
 struct dc {
 	struct dc_caps caps;
 	struct dc_cap_funcs cap_funcs;
-	struct dc_stream_funcs stream_funcs;
+	struct dc_stream_state_funcs stream_funcs;
 	struct dc_link_funcs link_funcs;
 	struct dc_config config;
 	struct dc_debug debug;
@@ -303,7 +303,7 @@ struct dc_transfer_func {
  * the last requested address and the currently active address so the called
  * can determine if there are any outstanding flips
  */
-struct dc_surface_status {
+struct dc_plane_status {
 	struct dc_plane_address requested_address;
 	struct dc_plane_address current_address;
 	bool is_flip_pending;
@@ -338,7 +338,7 @@ struct dc_plane_state {
 	bool horizontal_mirror;
 
 	/* private to DC core */
-	struct dc_surface_status status;
+	struct dc_plane_status status;
 	struct dc_context *ctx;
 
 	/* private to dc_surface.c */
@@ -385,12 +385,12 @@ struct dc_surface_update {
 /*
  * Create a new surface with default parameters;
  */
-struct dc_plane_state *dc_create_surface(const struct dc *dc);
-const struct dc_surface_status *dc_surface_get_status(
-		const struct dc_plane_state *dc_surface);
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc);
+const struct dc_plane_status *dc_plane_get_status(
+		const struct dc_plane_state *plane_state);
 
-void dc_surface_retain(struct dc_plane_state *dc_surface);
-void dc_surface_release(struct dc_plane_state *dc_surface);
+void dc_plane_state_retain(struct dc_plane_state *plane_state);
+void dc_plane_state_release(struct dc_plane_state *plane_state);
 
 void dc_gamma_retain(struct dc_gamma *dc_gamma);
 void dc_gamma_release(struct dc_gamma **dc_gamma);
@@ -418,7 +418,7 @@ struct dc_flip_addrs {
  *   Surface addresses and flip attributes are programmed.
  *   Surface flip occur at next configured time (h_sync or v_sync flip)
  */
-void dc_flip_surface_addrs(struct dc *dc,
+void dc_flip_plane_addrs(struct dc *dc,
 		struct dc_plane_state *const plane_states[],
 		struct dc_flip_addrs flip_addrs[],
 		uint32_t count);
@@ -434,11 +434,11 @@ void dc_flip_surface_addrs(struct dc *dc,
  *   This does not trigger a flip.  No surface address is programmed.
  */
 
-bool dc_commit_surfaces_to_stream(
+bool dc_commit_planes_to_stream(
 		struct dc *dc,
-		struct dc_plane_state **dc_surfaces,
-		uint8_t surface_count,
-		struct dc_stream *stream);
+		struct dc_plane_state **plane_states,
+		uint8_t new_plane_count,
+		struct dc_stream_state *stream);
 
 bool dc_post_update_surfaces_to_stream(
 		struct dc *dc);
@@ -481,8 +481,8 @@ enum surface_update_type {
 
 struct dc_stream_status {
 	int primary_otg_inst;
-	int surface_count;
-	struct dc_plane_state *surfaces[MAX_SURFACE_NUM];
+	int plane_count;
+	struct dc_plane_state *plane_states[MAX_SURFACE_NUM];
 
 	/*
 	 * link this stream passes through
@@ -490,7 +490,7 @@ struct dc_stream_status {
 	struct dc_link *link;
 };
 
-struct dc_stream {
+struct dc_stream_state {
 	struct dc_sink *sink;
 	struct dc_crtc_timing timing;
 
@@ -541,7 +541,7 @@ struct dc_stream_update {
 };
 
 bool dc_is_stream_unchanged(
-	struct dc_stream *old_stream, struct dc_stream *stream);
+	struct dc_stream_state *old_stream, struct dc_stream_state *stream);
 
 /*
  * Setup stream attributes if no stream updates are provided
@@ -558,32 +558,32 @@ bool dc_is_stream_unchanged(
  *
  */
 
-void dc_update_surfaces_and_stream(struct dc *dc,
+void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_surface_update *surface_updates, int surface_count,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct dc_stream_update *stream_update);
 
 /*
  * Log the current stream state.
  */
 void dc_stream_log(
-	const struct dc_stream *stream,
+	const struct dc_stream_state *stream,
 	struct dal_logger *dc_logger,
 	enum dc_log_type log_type);
 
 uint8_t dc_get_current_stream_count(const struct dc *dc);
-struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i);
+struct dc_stream_state *dc_get_stream_at_index(const struct dc *dc, uint8_t i);
 
 /*
  * Return the current frame counter.
  */
-uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream);
+uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream);
 
 /* TODO: Return parsed values rather than direct register read
  * This has a dependency on the caller (amdgpu_get_crtc_scanoutpos)
  * being refactored properly to be dce-specific
  */
-bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
+bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 				  uint32_t *v_blank_start,
 				  uint32_t *v_blank_end,
 				  uint32_t *h_position,
@@ -593,12 +593,12 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
  * Structure to store surface/stream associations for validation
  */
 struct dc_validation_set {
-	struct dc_stream *stream;
-	struct dc_plane_state *surfaces[MAX_SURFACES];
-	uint8_t surface_count;
+	struct dc_stream_state *stream;
+	struct dc_plane_state *plane_states[MAX_SURFACES];
+	uint8_t plane_count;
 };
 
-bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream);
+bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream);
 
 bool dc_validate_plane(const struct dc *dc, const struct dc_plane_state *plane_state);
 /*
@@ -627,7 +627,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		struct dc_stream *stream);
+		struct dc_stream_state *stream);
 
 void dc_resource_validate_ctx_copy_construct(
 		const struct validate_context *src_ctx,
@@ -656,7 +656,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context);
  */
 bool dc_commit_streams(
 		struct dc *dc,
-		struct dc_stream *streams[],
+		struct dc_stream_state *streams[],
 		uint8_t stream_count);
 /*
  * Enable stereo when commit_streams is not required,
@@ -665,19 +665,19 @@ bool dc_commit_streams(
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
-	struct dc_stream *streams[],
+	struct dc_stream_state *streams[],
 	uint8_t stream_count);
 
 /**
  * Create a new default stream for the requested sink
  */
-struct dc_stream *dc_create_stream_for_sink(struct dc_sink *dc_sink);
+struct dc_stream_state *dc_create_stream_for_sink(struct dc_sink *dc_sink);
 
-void dc_stream_retain(struct dc_stream *dc_stream);
-void dc_stream_release(struct dc_stream *dc_stream);
+void dc_stream_retain(struct dc_stream_state *dc_stream);
+void dc_stream_release(struct dc_stream_state *dc_stream);
 
 struct dc_stream_status *dc_stream_get_status(
-	struct dc_stream *dc_stream);
+	struct dc_stream_state *dc_stream);
 
 enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc *dc,
@@ -816,7 +816,7 @@ const struct graphics_object_id dc_get_link_id_at_index(
 
 /* Set backlight level of an embedded panel (eDP, LVDS). */
 bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
-		uint32_t frame_ramp, const struct dc_stream *stream);
+		uint32_t frame_ramp, const struct dc_stream_state *stream);
 
 bool dc_link_set_abm_disable(const struct dc_link *dc_link);
 
@@ -825,7 +825,7 @@ bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable);
 bool dc_link_get_psr_state(const struct dc_link *dc_link, uint32_t *psr_state);
 
 bool dc_link_setup_psr(struct dc_link *dc_link,
-		const struct dc_stream *stream, struct psr_config *psr_config,
+		const struct dc_stream_state *stream, struct psr_config *psr_config,
 		struct psr_context *psr_context);
 
 /* Request DC to detect if there is a Panel connected.
@@ -939,11 +939,11 @@ bool dc_sink_set_container_id(struct dc_sink *dc_sink, const struct dc_container
  ******************************************************************************/
 /* TODO: Deprecated once we switch to dc_set_cursor_position */
 bool dc_stream_set_cursor_attributes(
-	const struct dc_stream *stream,
+	const struct dc_stream_state *stream,
 	const struct dc_cursor_attributes *attributes);
 
 bool dc_stream_set_cursor_position(
-	struct dc_stream *stream,
+	struct dc_stream_state *stream,
 	const struct dc_cursor_position *position);
 
 /* Newer interfaces  */
diff --git a/drivers/gpu/drm/amd/display/dc/dc_types.h b/drivers/gpu/drm/amd/display/dc/dc_types.h
index 4fb9584..a47f7472 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_types.h
@@ -35,7 +35,7 @@
 
 /* forward declarations */
 struct dc_plane_state;
-struct dc_stream;
+struct dc_stream_state;
 struct dc_link;
 struct dc_sink;
 struct dal;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
index af59ab9..8140ff3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
@@ -197,9 +197,9 @@ void dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,
 }
 
 /* Only use LUT for 8 bit formats */
-bool dce_use_lut(const struct dc_plane_state *surface)
+bool dce_use_lut(const struct dc_plane_state *plane_state)
 {
-	switch (surface->format) {
+	switch (plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		return true;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
index d5cb98a..a0531b3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
@@ -552,5 +552,5 @@ void dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,
 		struct clock_source *clk_src,
 		unsigned int tg_inst);
 
-bool dce_use_lut(const struct dc_plane_state *surface);
+bool dce_use_lut(const struct dc_plane_state *plane_state);
 #endif   /*__DCE_HWSEQ_H__*/
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
index 24d0c48..5bb2ac7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
@@ -1009,7 +1009,7 @@ bool dce110_link_encoder_construct(
 
 bool dce110_link_encoder_validate_output_with_stream(
 	struct link_encoder *enc,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
 	bool is_valid;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h
index 5f05ca6..5960fb9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h
@@ -196,7 +196,7 @@ bool dce110_link_encoder_validate_wireless_output(
 
 bool dce110_link_encoder_validate_output_with_stream(
 	struct link_encoder *enc,
-	const struct dc_stream *stream);
+	const struct dc_stream_state *stream);
 
 /****************** HW programming ************************/
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index 2cf2fef..46f0c71 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -660,7 +660,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -705,13 +705,13 @@ static bool dce100_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -765,7 +765,7 @@ enum dc_status dce100_validate_with_context(
 
 enum dc_status dce100_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -958,7 +958,7 @@ static bool construct(
 		}
 	}
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 998adec..9b05b5b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -215,11 +215,11 @@ static bool dce110_enable_display_power_gating(
 }
 
 static void build_prescale_params(struct ipp_prescale_params *prescale_params,
-		const struct dc_plane_state *surface)
+		const struct dc_plane_state *plane_state)
 {
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
-	switch (surface->format) {
+	switch (plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;
@@ -240,7 +240,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_plane_state *surface)
+	const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -250,14 +250,14 @@ static bool dce110_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->in_transfer_func)
-		tf = surface->in_transfer_func;
+	if (plane_state->in_transfer_func)
+		tf = plane_state->in_transfer_func;
 
-	build_prescale_params(&prescale_params, surface);
+	build_prescale_params(&prescale_params, plane_state);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->gamma_correction && dce_use_lut(surface))
-		ipp->funcs->ipp_program_input_lut(ipp, surface->gamma_correction);
+	if (plane_state->gamma_correction && dce_use_lut(plane_state))
+		ipp->funcs->ipp_program_input_lut(ipp, plane_state->gamma_correction);
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
@@ -623,7 +623,7 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 
@@ -745,7 +745,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 
 	if (pipe_ctx->audio) {
@@ -833,7 +833,7 @@ static void build_audio_output(
 	const struct pipe_ctx *pipe_ctx,
 	struct audio_output *audio_output)
 {
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	audio_output->engine_id = pipe_ctx->stream_enc->id;
 
 	audio_output->signal = pipe_ctx->stream->signal;
@@ -981,7 +981,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
@@ -1037,7 +1037,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
@@ -1119,7 +1119,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if ((!pipe_ctx_old ||
 	     memcmp(&pipe_ctx_old->scl_data, &pipe_ctx->scl_data,
 		    sizeof(struct scaler_data)) != 0) &&
-	     pipe_ctx->surface) {
+	     pipe_ctx->plane_state) {
 		program_scaler(dc, pipe_ctx);
 	}
 
@@ -1229,7 +1229,7 @@ void dce110_enable_accelerated_mode(struct core_dc *dc)
 
 static uint32_t compute_pstate_blackout_duration(
 	struct bw_fixed blackout_duration,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	uint32_t total_dest_line_time_ns;
 	uint32_t pstate_blackout_duration_ns;
@@ -1916,11 +1916,11 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 	struct default_adjustment default_adjust = { 0 };
 
 	default_adjust.force_hw_default = false;
-	if (pipe_ctx->surface == NULL)
+	if (pipe_ctx->plane_state == NULL)
 		default_adjust.in_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.in_color_space =
-				pipe_ctx->surface->color_space;
+				pipe_ctx->plane_state->color_space;
 	if (pipe_ctx->stream == NULL)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
@@ -1971,16 +1971,16 @@ static void program_surface_visibility(const struct core_dc *dc,
 		/* For now we are supporting only two pipes */
 		ASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);
 
-		if (pipe_ctx->bottom_pipe->surface->visible) {
-			if (pipe_ctx->surface->visible)
+		if (pipe_ctx->bottom_pipe->plane_state->visible) {
+			if (pipe_ctx->plane_state->visible)
 				blender_mode = BLND_MODE_BLENDING;
 			else
 				blender_mode = BLND_MODE_OTHER_PIPE;
 
-		} else if (!pipe_ctx->surface->visible)
+		} else if (!pipe_ctx->plane_state->visible)
 			blank_target = true;
 
-	} else if (!pipe_ctx->surface->visible)
+	} else if (!pipe_ctx->plane_state->visible)
 		blank_target = true;
 
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
@@ -2038,7 +2038,7 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	struct mem_input *mi = pipe_ctx->mi;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2103,57 +2103,57 @@ static void set_plane_config(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->format,
-			&surface->tiling_info,
-			&surface->plane_size,
-			surface->rotation,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&plane_state->plane_size,
+			plane_state->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
+		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 }
 
 static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->address,
-			surface->flip_immediate);
+			&plane_state->address,
+			plane_state->flip_immediate);
 
-	surface->status.requested_address = surface->address;
+	plane_state->status.requested_address = plane_state->address;
 }
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
-	surface->status.is_flip_pending =
+	plane_state->status.is_flip_pending =
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
-	if (surface->status.is_flip_pending && !surface->visible)
+	if (plane_state->status.is_flip_pending && !plane_state->visible)
 		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
 
-	surface->status.current_address = pipe_ctx->mi->current_address;
+	plane_state->status.current_address = pipe_ctx->mi->current_address;
 	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			pipe_ctx->tg->funcs->is_stereo_left_eye) {
-		surface->status.is_right_eye =\
+		plane_state->status.is_right_eye =\
 				!pipe_ctx->tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
 	}
 }
@@ -2325,7 +2325,7 @@ void dce110_fill_display_configs(
 	for (j = 0; j < context->stream_count; j++) {
 		int k;
 
-		const struct dc_stream *stream = context->streams[j];
+		const struct dc_stream_state *stream = context->streams[j];
 		struct dm_pp_single_disp_config *cfg =
 			&pp_display_cfg->disp_configs[num_cfgs];
 		const struct pipe_ctx *pipe_ctx = NULL;
@@ -2370,7 +2370,7 @@ uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 	uint32_t min_vertical_blank_time = -1;
 
 		for (j = 0; j < context->stream_count; j++) {
-			struct dc_stream *stream = context->streams[j];
+			struct dc_stream_state *stream = context->streams[j];
 			uint32_t vertical_blank_in_pixels = 0;
 			uint32_t vertical_blank_time = 0;
 
@@ -2490,7 +2490,7 @@ static void dce110_program_front_end_for_pipe(
 {
 	struct mem_input *mi = pipe_ctx->mi;
 	struct pipe_ctx *old_pipe = NULL;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2558,21 +2558,21 @@ static void dce110_program_front_end_for_pipe(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->format,
-			&surface->tiling_info,
-			&surface->plane_size,
-			surface->rotation,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&plane_state->plane_size,
+			plane_state->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
+		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
@@ -2581,21 +2581,21 @@ static void dce110_program_front_end_for_pipe(
 			" %d; dst: %d, %d, %d, %d;"
 			"clip: %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
-			pipe_ctx->surface,
-			pipe_ctx->surface->address.grph.addr.high_part,
-			pipe_ctx->surface->address.grph.addr.low_part,
-			pipe_ctx->surface->src_rect.x,
-			pipe_ctx->surface->src_rect.y,
-			pipe_ctx->surface->src_rect.width,
-			pipe_ctx->surface->src_rect.height,
-			pipe_ctx->surface->dst_rect.x,
-			pipe_ctx->surface->dst_rect.y,
-			pipe_ctx->surface->dst_rect.width,
-			pipe_ctx->surface->dst_rect.height,
-			pipe_ctx->surface->clip_rect.x,
-			pipe_ctx->surface->clip_rect.y,
-			pipe_ctx->surface->clip_rect.width,
-			pipe_ctx->surface->clip_rect.height);
+			pipe_ctx->plane_state,
+			pipe_ctx->plane_state->address.grph.addr.high_part,
+			pipe_ctx->plane_state->address.grph.addr.low_part,
+			pipe_ctx->plane_state->src_rect.x,
+			pipe_ctx->plane_state->src_rect.y,
+			pipe_ctx->plane_state->src_rect.width,
+			pipe_ctx->plane_state->src_rect.height,
+			pipe_ctx->plane_state->dst_rect.x,
+			pipe_ctx->plane_state->dst_rect.y,
+			pipe_ctx->plane_state->dst_rect.width,
+			pipe_ctx->plane_state->dst_rect.height,
+			pipe_ctx->plane_state->clip_rect.x,
+			pipe_ctx->plane_state->clip_rect.y,
+			pipe_ctx->plane_state->clip_rect.width,
+			pipe_ctx->plane_state->clip_rect.height);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe %d: width, height, x, y\n"
@@ -2614,19 +2614,18 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *surface,
+		const struct dc_plane_state *plane_state,
 		struct validate_context *context)
 {
 	int i;
 
-	/* TODO remove when removing the surface reset workaroud*/
-	if (!surface)
+	if (!plane_state)
 		return;
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 5c1790b..f580da1b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -718,7 +718,7 @@ static void get_pixel_clock_parameters(
 	const struct pipe_ctx *pipe_ctx,
 	struct pixel_clk_params *pixel_clk_params)
 {
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 
 	/*TODO: is this halved for YCbCr 420? in that case we might want to move
 	 * the pixel clock normalization for hdmi up to here instead of doing it
@@ -764,9 +764,9 @@ static bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigne
 {
 	if (pipe_ctx->pipe_idx != underlay_idx)
 		return true;
-	if (!pipe_ctx->surface)
+	if (!pipe_ctx->plane_state)
 		return false;
-	if (pipe_ctx->surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+	if (pipe_ctx->plane_state->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 		return false;
 	return true;
 }
@@ -780,7 +780,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -901,22 +901,22 @@ static bool dce110_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 2)
+		if (set[i].plane_count > 2)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 
-		if (set[i].surface_count == 2) {
-			if (set[i].surfaces[1]->format
+		if (set[i].plane_count == 2) {
+			if (set[i].plane_states[1]->format
 					< SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 				return false;
-			if (set[i].surfaces[1]->src_rect.width > 1920
-					|| set[i].surfaces[1]->src_rect.height > 1080)
+			if (set[i].plane_states[1]->src_rect.width > 1920
+					|| set[i].plane_states[1]->src_rect.height > 1080)
 				return false;
 
 			if (set[i].stream->timing.pixel_encoding != PIXEL_ENCODING_RGB)
@@ -973,7 +973,7 @@ enum dc_status dce110_validate_with_context(
 
 enum dc_status dce110_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -1006,7 +1006,7 @@ enum dc_status dce110_validate_guaranteed(
 static struct pipe_ctx *dce110_acquire_underlay(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx = &context->res_ctx;
@@ -1351,7 +1351,7 @@ static bool construct(
 	if (!dce110_hw_sequencer_construct(dc))
 		goto res_create_fail;
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index c68372f..420434d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -700,7 +700,7 @@ static void destruct(struct dce110_resource_pool *pool)
 static struct clock_source *find_matching_pll(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		const struct dc_stream *const stream)
+		const struct dc_stream_state *const stream)
 {
 	switch (stream->sink->link->link_enc->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -731,7 +731,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -845,7 +845,7 @@ enum dc_status resource_map_phy_clock_resources(
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -889,13 +889,13 @@ static bool dce112_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -949,7 +949,7 @@ enum dc_status dce112_validate_with_context(
 
 enum dc_status dce112_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -1319,7 +1319,7 @@ static bool construct(
 			  &res_create_funcs))
 		goto res_create_fail;
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	/* Create hardware sequencer */
 	if (!dce112_hw_sequencer_construct(dc))
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
index cb2c69f..feef559 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
@@ -44,7 +44,7 @@ enum dc_status dce112_validate_with_context(
 
 enum dc_status dce112_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context);
 
 bool dce112_validate_bandwidth(
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
index 45f5fd6..6448d15 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
@@ -982,7 +982,7 @@ static bool construct(
 	if (!dce120_hw_sequencer_create(dc))
 		goto controller_create_fail;
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index bcb6644..7473f585 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -677,7 +677,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -722,13 +722,13 @@ static bool dce80_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -781,7 +781,7 @@ enum dc_status dce80_validate_with_context(
 
 enum dc_status dce80_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -959,7 +959,7 @@ static bool construct(
 		}
 	}
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3979cb0..5922cf8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -679,7 +679,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
 	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
@@ -986,7 +986,7 @@ static void reset_hw_ctx_wrap(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->stream ||
-				!pipe_ctx->surface ||
+				!pipe_ctx->plane_state ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 
 			plane_atomic_disconnect(dc, i);
@@ -1010,13 +1010,13 @@ static void reset_hw_ctx_wrap(
 		/*if (!pipe_ctx_old->stream)
 			continue;*/
 
-		if (pipe_ctx->stream && pipe_ctx->surface
+		if (pipe_ctx->stream && pipe_ctx->plane_state
 				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			continue;
 
 		plane_atomic_disable(dc, i);
 
-		if (!pipe_ctx->stream || !pipe_ctx->surface)
+		if (!pipe_ctx->stream || !pipe_ctx->plane_state)
 			plane_atomic_power_down(dc, i);
 	}
 
@@ -1038,24 +1038,24 @@ static void reset_hw_ctx_wrap(
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
-	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
+	if (sec_split && plane_state->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 		(pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
 		 pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
-		*addr = surface->address.grph_stereo.left_addr;
-		surface->address.grph_stereo.left_addr =
-		surface->address.grph_stereo.right_addr;
+		*addr = plane_state->address.grph_stereo.left_addr;
+		plane_state->address.grph_stereo.left_addr =
+		plane_state->address.grph_stereo.right_addr;
 		return true;
 	} else {
 		if (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&
-			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
-			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
-			surface->address.grph_stereo.right_addr =
-			surface->address.grph_stereo.left_addr;
+			plane_state->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
+			plane_state->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
+			plane_state->address.grph_stereo.right_addr =
+			plane_state->address.grph_stereo.left_addr;
 		}
 	}
 	return false;
@@ -1065,22 +1065,22 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->address,
-			surface->flip_immediate);
-	surface->status.requested_address = surface->address;
+			&plane_state->address,
+			plane_state->flip_immediate);
+	plane_state->status.requested_address = plane_state->address;
 	if (addr_patched)
-		pipe_ctx->surface->address.grph_stereo.left_addr = addr;
+		pipe_ctx->plane_state->address.grph_stereo.left_addr = addr;
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *surface)
+	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -1089,12 +1089,12 @@ static bool dcn10_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->in_transfer_func)
-		tf = surface->in_transfer_func;
+	if (plane_state->in_transfer_func)
+		tf = plane_state->in_transfer_func;
 
-	if (surface->gamma_correction && dce_use_lut(surface))
+	if (plane_state->gamma_correction && dce_use_lut(plane_state))
 		ipp->funcs->ipp_program_input_lut(ipp,
-				surface->gamma_correction);
+				plane_state->gamma_correction);
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
@@ -1445,7 +1445,7 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	struct transform *xfm = pipe_ctx->xfm;
 
@@ -1689,7 +1689,7 @@ static void dcn10_power_on_fe(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
-	struct dc_plane_state *dc_surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	power_on_plane(dc->hwseq,
@@ -1704,24 +1704,24 @@ static void dcn10_power_on_fe(
 			OPP_PIPE_CLOCK_EN, 1);
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
-	if (dc_surface) {
+	if (plane_state) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
 				" %d; dst: %d, %d, %d, %d;\n",
 				pipe_ctx->pipe_idx,
-				dc_surface,
-				dc_surface->address.grph.addr.high_part,
-				dc_surface->address.grph.addr.low_part,
-				dc_surface->src_rect.x,
-				dc_surface->src_rect.y,
-				dc_surface->src_rect.width,
-				dc_surface->src_rect.height,
-				dc_surface->dst_rect.x,
-				dc_surface->dst_rect.y,
-				dc_surface->dst_rect.width,
-				dc_surface->dst_rect.height);
+				plane_state,
+				plane_state->address.grph.addr.high_part,
+				plane_state->address.grph.addr.low_part,
+				plane_state->src_rect.x,
+				plane_state->src_rect.y,
+				plane_state->src_rect.width,
+				plane_state->src_rect.height,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.height);
 
 		dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
 				"Pipe %d: width, height, x, y\n"
@@ -1805,7 +1805,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
 		return true;
@@ -1814,7 +1814,7 @@ static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1823,7 +1823,7 @@ static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1898,12 +1898,12 @@ static void update_dchubp_dpp(
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	struct dc_plane_state *surface = pipe_ctx->surface;
-	union plane_size size = surface->plane_size;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	union plane_size size = plane_state->plane_size;
 	struct default_adjustment ocsc = {0};
 	struct mpcc_cfg mpcc_cfg = {0};
 	struct pipe_ctx *top_pipe;
-	bool per_pixel_alpha = surface->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1936,12 +1936,12 @@ static void update_dchubp_dpp(
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 
 	ipp->funcs->ipp_setup(ipp,
-			surface->format,
+			plane_state->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
@@ -1982,12 +1982,12 @@ static void update_dchubp_dpp(
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,
-		surface->format,
-		&surface->tiling_info,
+		plane_state->format,
+		&plane_state->tiling_info,
 		&size,
-		surface->rotation,
-		&surface->dcc,
-		surface->horizontal_mirror);
+		plane_state->rotation,
+		&plane_state->dcc,
+		plane_state->horizontal_mirror);
 
 	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
@@ -2025,7 +2025,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
 	}
 
-	if (pipe_ctx->surface != NULL) {
+	if (pipe_ctx->plane_state != NULL) {
 		dcn10_power_on_fe(dc, pipe_ctx, context);
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
@@ -2068,7 +2068,7 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *surface,
+		const struct dc_plane_state *plane_state,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2076,11 +2076,11 @@ static void dcn10_apply_ctx_for_surface(
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	if (!surface)
+	if (!plane_state)
 		return;
 
 	for (be_idx = 0; be_idx < dc->res_pool->pipe_count; be_idx++)
-		if (surface == context->res_ctx.pipe_ctx[be_idx].surface)
+		if (plane_state == context->res_ctx.pipe_ctx[be_idx].plane_state)
 			break;
 
 	/* reset unused mpcc */
@@ -2089,7 +2089,7 @@ static void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->surface && !old_pipe_ctx->surface)
+		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
 
 		/*
@@ -2097,7 +2097,7 @@ static void dcn10_apply_ctx_for_surface(
 		 * fairly hacky right now, using opp_id as indicator
 		 */
 
-		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
+		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (pipe_ctx->mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
@@ -2109,7 +2109,7 @@ static void dcn10_apply_ctx_for_surface(
 		}
 
 
-		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
+		if ((!pipe_ctx->plane_state && old_pipe_ctx->plane_state)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
 			if (old_pipe_ctx->tg->inst != be_idx)
 				continue;
@@ -2135,7 +2135,7 @@ static void dcn10_apply_ctx_for_surface(
 
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
-			old_pipe_ctx->surface = NULL;
+			old_pipe_ctx->plane_state = NULL;
 
 			dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset mpcc for pipe %d\n",
@@ -2146,7 +2146,7 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		/* looking for top pipe to program */
@@ -2321,7 +2321,7 @@ static void set_plane_config(
 }
 
 static void dcn10_config_stereo_parameters(
-		struct dc_stream *stream, struct crtc_stereo_flags *flags)
+		struct dc_stream_state *stream, struct crtc_stereo_flags *flags)
 {
 	enum view_3d_format view_format = stream->view_format;
 	enum dc_timing_3d_format timing_3d_format =\
@@ -2360,7 +2360,7 @@ static void dcn10_config_stereo_parameters(
 static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 
 	dcn10_config_stereo_parameters(stream, &flags);
 
@@ -2468,34 +2468,34 @@ static bool dcn10_dummy_display_power_gating(
 
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->tg;
 
-	if (surface->ctx->dc->debug.sanity_checks) {
-		struct core_dc *dc = DC_TO_CORE(surface->ctx->dc);
+	if (plane_state->ctx->dc->debug.sanity_checks) {
+		struct core_dc *dc = DC_TO_CORE(plane_state->ctx->dc);
 
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
-	surface->status.is_flip_pending =
+	plane_state->status.is_flip_pending =
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
 	/* DCN we read INUSE address in MI, do we still need this wa? */
-	if (surface->status.is_flip_pending &&
-			!surface->visible) {
+	if (plane_state->status.is_flip_pending &&
+			!plane_state->visible) {
 		pipe_ctx->mi->current_address =
 				pipe_ctx->mi->request_address;
 		BREAK_TO_DEBUGGER();
 	}
 
-	surface->status.current_address = pipe_ctx->mi->current_address;
+	plane_state->status.current_address = pipe_ctx->mi->current_address;
 	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
-		surface->status.is_right_eye =
+		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
 	}
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index 9d44f42..3fe6df9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -774,7 +774,7 @@ static void get_pixel_clock_parameters(
 	const struct pipe_ctx *pipe_ctx,
 	struct pixel_clk_params *pixel_clk_params)
 {
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	pixel_clk_params->requested_pix_clk = stream->timing.pix_clk_khz;
 	pixel_clk_params->encoder_object_id = stream->sink->link->link_enc->id;
 	pixel_clk_params->signal_type = pipe_ctx->stream->signal;
@@ -796,7 +796,7 @@ static void get_pixel_clock_parameters(
 
 }
 
-static void build_clamping_params(struct dc_stream *stream)
+static void build_clamping_params(struct dc_stream_state *stream)
 {
 	stream->clamping.clamping_level = CLAMPING_FULL_RANGE;
 	stream->clamping.c_depth = stream->timing.display_color_depth;
@@ -831,7 +831,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
@@ -916,7 +916,7 @@ enum dc_status dcn10_validate_with_context(
 
 enum dc_status dcn10_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -947,7 +947,7 @@ enum dc_status dcn10_validate_guaranteed(
 static struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	struct resource_context *res_ctx = &context->res_ctx;
 	struct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
@@ -1406,7 +1406,7 @@ static bool construct(
 			goto res_create_fail;
 
 	dcn10_hw_sequencer_construct(dc);
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	dc->public.cap_funcs = cap_funcs;
 
diff --git a/drivers/gpu/drm/amd/display/dc/dm_helpers.h b/drivers/gpu/drm/amd/display/dc/dm_helpers.h
index e8bd501..3901032 100644
--- a/drivers/gpu/drm/amd/display/dc/dm_helpers.h
+++ b/drivers/gpu/drm/amd/display/dc/dm_helpers.h
@@ -45,7 +45,7 @@ enum dc_edid_status dm_helpers_parse_edid_caps(
  */
 bool dm_helpers_dp_mst_write_payload_allocation_table(
 		struct dc_context *ctx,
-		const struct dc_stream *stream,
+		const struct dc_stream_state *stream,
 		struct dp_mst_stream_allocation_table *proposed_table,
 		bool enable);
 
@@ -54,13 +54,13 @@ bool dm_helpers_dp_mst_write_payload_allocation_table(
  */
 bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 		struct dc_context *ctx,
-		const struct dc_stream *stream);
+		const struct dc_stream_state *stream);
 /*
  * Sends ALLOCATE_PAYLOAD message.
  */
 bool dm_helpers_dp_mst_send_payload_allocation(
 		struct dc_context *ctx,
-		const struct dc_stream *stream,
+		const struct dc_stream_state *stream,
 		bool enable);
 
 bool dm_helpers_dp_mst_start_top_mgr(
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 44a87c9..3b3330c 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -36,7 +36,7 @@
 
 #define MAX_CLOCK_SOURCES 7
 
-void enable_surface_flip_reporting(struct dc_plane_state *dc_surface,
+void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 		uint32_t controller_id);
 
 #include "grph_object_id.h"
@@ -60,7 +60,7 @@ struct dc_link *link_create(const struct link_init_data *init_params);
 void link_destroy(struct dc_link **link);
 
 enum dc_status dc_link_validate_mode_timing(
-		const struct dc_stream *stream,
+		const struct dc_stream_state *stream,
 		struct dc_link *link,
 		const struct dc_crtc_timing *timing);
 
@@ -92,7 +92,7 @@ struct resource_funcs {
 
 	enum dc_status (*validate_guaranteed)(
 					const struct core_dc *dc,
-					struct dc_stream *stream,
+					struct dc_stream_state *stream,
 					struct validate_context *context);
 
 	bool (*validate_bandwidth)(
@@ -102,8 +102,7 @@ struct resource_funcs {
 	struct pipe_ctx *(*acquire_idle_pipe_for_layer)(
 			struct validate_context *context,
 			const struct resource_pool *pool,
-			struct dc_stream *stream);
-
+			struct dc_stream_state *stream);
 	enum dc_status (*validate_plane)(const struct dc_plane_state *plane_state);
 };
 
@@ -154,8 +153,8 @@ struct resource_pool {
 };
 
 struct pipe_ctx {
-	struct dc_plane_state *surface;
-	struct dc_stream *stream;
+	struct dc_plane_state *plane_state;
+	struct dc_stream_state *stream;
 
 	struct mem_input *mi;
 	struct input_pixel_processor *ipp;
@@ -240,7 +239,7 @@ union bw_context {
 };
 
 struct validate_context {
-	struct dc_stream *streams[MAX_PIPES];
+	struct dc_stream_state *streams[MAX_PIPES];
 	struct dc_stream_status stream_status[MAX_PIPES];
 	uint8_t stream_count;
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
index 1a4a605..7168dcc 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
@@ -30,7 +30,7 @@
 #define LINK_TRAINING_RETRY_DELAY 50 /* ms */
 
 struct dc_link;
-struct dc_stream;
+struct dc_stream_state;
 struct dc_link_settings;
 
 bool dp_hbr_verify_link_cap(
@@ -50,7 +50,7 @@ bool dp_validate_mode_timing(
 	const struct dc_crtc_timing *timing);
 
 void decide_link_settings(
-	struct dc_stream *stream,
+	struct dc_stream_state *stream,
 	struct dc_link_settings *link_setting);
 
 bool perform_link_training_with_retries(
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
index 28fb02f..38e4070 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
@@ -93,7 +93,7 @@ struct link_encoder {
 
 struct link_encoder_funcs {
 	bool (*validate_output_with_stream)(
-		struct link_encoder *enc, const struct dc_stream *stream);
+		struct link_encoder *enc, const struct dc_stream_state *stream);
 	void (*hw_init)(struct link_encoder *enc);
 	void (*setup)(struct link_encoder *enc,
 		enum signal_type signal);
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
index c529ddd..5d075f9 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
@@ -59,7 +59,7 @@ struct hw_sequencer_funcs {
 
 	void (*apply_ctx_for_surface)(
 			struct core_dc *dc,
-			const struct dc_plane_state *surface,
+			const struct dc_plane_state *plane_state,
 			struct validate_context *context);
 
 	void (*set_plane_config)(
@@ -88,11 +88,11 @@ struct hw_sequencer_funcs {
 
 	bool (*set_input_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
-				const struct dc_plane_state *surface);
+				const struct dc_plane_state *plane_state);
 
 	bool (*set_output_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
-				const struct dc_stream *stream);
+				const struct dc_stream_state *stream);
 
 	void (*power_down)(struct core_dc *dc);
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index bfd7cfc..7f30d99 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -103,8 +103,8 @@ void resource_reference_clock_source(
 		struct clock_source *clock_source);
 
 bool resource_are_streams_timing_synchronizable(
-		struct dc_stream *stream1,
-		struct dc_stream *stream2);
+		struct dc_stream_state *stream1,
+		struct dc_stream_state *stream2);
 
 struct clock_source *resource_find_used_clk_src_for_sharing(
 		struct resource_context *res_ctx,
@@ -116,12 +116,12 @@ struct clock_source *dc_resource_find_first_free_pll(
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
-		struct dc_stream *stream);
+		struct dc_stream_state *stream);
 
 bool resource_attach_surfaces_to_context(
-		struct dc_plane_state *const *surfaces,
+		struct dc_plane_state *const *plane_state,
 		int surface_count,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context,
 		const struct resource_pool *pool);
 
@@ -130,8 +130,7 @@ struct pipe_ctx *find_idle_secondary_pipe(
 		const struct resource_pool *pool);
 
 bool resource_is_stream_unchanged(
-	struct validate_context *old_context, struct dc_stream *stream);
-
+	struct validate_context *old_context, struct dc_stream_state *stream);
 
 bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
@@ -162,7 +161,7 @@ bool pipe_need_reprogram(
 		struct pipe_ctx *pipe_ctx_old,
 		struct pipe_ctx *pipe_ctx);
 
-void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
+void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth);
 
 #endif /* DRIVERS_GPU_DRM_AMD_DC_DEV_DC_INC_RESOURCE_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c b/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c
index dd024c9..57b5a3b 100644
--- a/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c
@@ -30,7 +30,7 @@
 
 static bool virtual_link_encoder_validate_output_with_stream(
 	struct link_encoder *enc,
-	const struct dc_stream *stream) { return true; }
+	const struct dc_stream_state *stream) { return true; }
 
 static void virtual_link_encoder_hw_init(struct link_encoder *enc) {}
 
diff --git a/drivers/gpu/drm/amd/display/include/logger_interface.h b/drivers/gpu/drm/amd/display/include/logger_interface.h
index 0e978d9..beb7909 100644
--- a/drivers/gpu/drm/amd/display/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/display/include/logger_interface.h
@@ -77,7 +77,7 @@ void logger_write(struct dal_logger *logger,
 
 void pre_surface_trace(
 		const struct dc *dc,
-		const struct dc_plane_state *const *surfaces,
+		const struct dc_plane_state *const *plane_states,
 		int surface_count);
 
 void update_surface_trace(
diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 358f8a8..f0a3e43 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -111,7 +111,7 @@ struct freesync_state {
 };
 
 struct freesync_entity {
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 	struct mod_freesync_caps *caps;
 	struct freesync_state state;
 	struct mod_freesync_user_enable user_enable;
@@ -229,7 +229,7 @@ void mod_freesync_destroy(struct mod_freesync *mod_freesync)
  * on the core_freesync->map and returns the corresponding index
  */
 static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int index = 0;
 
@@ -244,7 +244,7 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 }
 
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream, struct mod_freesync_caps *caps)
+		struct dc_stream_state *stream, struct mod_freesync_caps *caps)
 {
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
@@ -322,7 +322,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i = 0;
 	struct core_freesync *core_freesync = NULL;
@@ -344,7 +344,7 @@ bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
 }
 
 static void update_stream_freesync_context(struct core_freesync *core_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int index;
 	struct freesync_context *ctx;
@@ -368,7 +368,7 @@ static void update_stream_freesync_context(struct core_freesync *core_freesync,
 }
 
 static void update_stream(struct core_freesync *core_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int index = map_index_from_stream(core_freesync, stream);
 	if (core_freesync->map[index].caps->supported) {
@@ -378,7 +378,7 @@ static void update_stream(struct core_freesync *core_freesync,
 }
 
 static void calc_freesync_range(struct core_freesync *core_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct freesync_state *state,
 		unsigned int min_refresh_in_uhz,
 		unsigned int max_refresh_in_uhz)
@@ -452,7 +452,7 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 		min_frame_duration_in_ns) / 2000;
 }
 
-static void calc_v_total_from_duration(struct dc_stream *stream,
+static void calc_v_total_from_duration(struct dc_stream_state *stream,
 		unsigned int duration_in_ns, int *v_total_nominal)
 {
 	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
@@ -461,7 +461,7 @@ static void calc_v_total_from_duration(struct dc_stream *stream,
 }
 
 static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int index, int *v_total)
 {
 	unsigned int frame_duration = 0;
@@ -557,7 +557,7 @@ static void reset_freesync_state_variables(struct freesync_state* state)
  * Sets freesync mode on a stream depending on current freesync state.
  */
 static bool set_freesync_on_streams(struct core_freesync *core_freesync,
-		struct dc_stream **streams, int num_streams)
+		struct dc_stream_state **streams, int num_streams)
 {
 	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
 	unsigned int stream_idx, map_index = 0;
@@ -729,7 +729,7 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams)
+		struct dc_stream_state **streams, int num_streams)
 {
 	unsigned int index, v_total, inserted_frame_v_total = 0;
 	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
@@ -839,7 +839,7 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		struct mod_freesync_params *freesync_params)
 {
 	bool freesync_program_required = false;
@@ -929,7 +929,7 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 
 
 bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct mod_freesync_params *freesync_params)
 {
 	unsigned int index = 0;
@@ -965,7 +965,7 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int stream_index, map_index;
@@ -1017,7 +1017,7 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int index = 0;
@@ -1035,7 +1035,7 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		bool *is_ramp_active)
 {
 	unsigned int index = 0;
@@ -1054,7 +1054,7 @@ bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream *streams,
+		struct dc_stream_state *streams,
 		unsigned int min_refresh,
 		unsigned int max_refresh,
 		struct mod_freesync_caps *caps)
@@ -1107,7 +1107,7 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *min_refresh,
 		unsigned int *max_refresh)
 {
@@ -1129,7 +1129,7 @@ bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *vmin,
 		unsigned int *vmax)
 {
@@ -1151,7 +1151,7 @@ bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos)
 {
@@ -1179,7 +1179,7 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams)
+		struct dc_stream_state **streams, int num_streams)
 {
 	unsigned int stream_index, map_index;
 	struct freesync_state *state;
@@ -1239,7 +1239,7 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
  * is required, depending on the times calculated
  */
 static void update_timestamps(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, unsigned int map_index,
+		const struct dc_stream_state *stream, unsigned int map_index,
 		unsigned int last_render_time_in_us)
 {
 	struct freesync_state *state = &core_freesync->map[map_index].state;
@@ -1304,7 +1304,7 @@ static void update_timestamps(struct core_freesync *core_freesync,
 }
 
 static void apply_below_the_range(struct core_freesync *core_freesync,
-		struct dc_stream *stream, unsigned int map_index,
+		struct dc_stream_state *stream, unsigned int map_index,
 		unsigned int last_render_time_in_us)
 {
 	unsigned int inserted_frame_duration_in_us = 0;
@@ -1403,7 +1403,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 }
 
 static void apply_fixed_refresh(struct core_freesync *core_freesync,
-		struct dc_stream *stream, unsigned int map_index)
+		struct dc_stream_state *stream, unsigned int map_index)
 {
 	unsigned int vmin = 0, vmax = 0;
 	struct freesync_state *state = &core_freesync->map[map_index].state;
@@ -1434,7 +1434,7 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		unsigned int curr_time_stamp_in_us)
 {
 	unsigned int stream_index, map_index, last_render_time_in_us = 0;
diff --git a/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h b/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h
index 2b9d451..84b5342 100644
--- a/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h
+++ b/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h
@@ -101,67 +101,67 @@ struct mod_freesync_params {
  * Add stream to be tracked by module
  */
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream, struct mod_freesync_caps *caps);
+		struct dc_stream_state *stream, struct mod_freesync_caps *caps);
 
 /*
  * Remove stream to be tracked by module
  */
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream);
+		struct dc_stream_state *stream);
 
 /*
  * Update the freesync state flags for each display and program
  * freesync accordingly
  */
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		struct mod_freesync_params *freesync_params);
 
 bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct mod_freesync_params *freesync_params);
 
 bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable);
 
 bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct mod_freesync_user_enable *user_enable);
 
 bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		bool *is_ramp_active);
 
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream *streams,
+		struct dc_stream_state *streams,
 		unsigned int min_refresh,
 		unsigned int max_refresh,
 		struct mod_freesync_caps *caps);
 
 bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *min_refresh,
 		unsigned int *max_refresh);
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *vmin,
 		unsigned int *vmax);
 
 bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos);
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams);
+		struct dc_stream_state **streams, int num_streams);
 
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams);
+		struct dc_stream_state **streams, int num_streams);
 
 void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		unsigned int curr_time_stamp);
 
 #endif
-- 
2.7.4

