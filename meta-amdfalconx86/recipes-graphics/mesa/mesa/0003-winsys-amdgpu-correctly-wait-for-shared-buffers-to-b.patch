From e67bee7d8b060bdb8a3ddfa38a26cf3d13f896ca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 8 Jul 2015 19:01:34 +0200
Subject: [PATCH 03/16] winsys/amdgpu: correctly wait for shared buffers to
 become idle
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
Reviewed-by: Christian König <christian.koenig@amd.com>
Signed-off-by: Arindam Nath <arindam.nath@amd.com>
---
 src/gallium/winsys/amdgpu/drm/amdgpu_bo.c | 17 +++++++++++++++++
 src/gallium/winsys/amdgpu/drm/amdgpu_bo.h |  5 +++++
 2 files changed, 22 insertions(+)

diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
index 89a7183..b9ce70e 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
@@ -80,6 +80,21 @@ static bool amdgpu_bo_wait(struct pb_buffer *_buf, uint64_t timeout,
    struct amdgpu_winsys *ws = bo->rws;
    int i;
 
+   if (bo->is_shared) {
+      /* We can't use user fences for shared buffers, because user fences
+       * are local to this process only. If we want to wait for all buffer
+       * uses in all processes, we have to use amdgpu_bo_wait_for_idle.
+       */
+      bool buffer_busy = true;
+      int r;
+
+      r = amdgpu_bo_wait_for_idle(bo->bo, timeout, &buffer_busy);
+      if (r)
+         fprintf(stderr, "%s: amdgpu_bo_wait_for_idle failed %i\n", __func__,
+                 r);
+      return !buffer_busy;
+   }
+
    if (timeout == 0) {
       /* Timeout == 0 is quite simple. */
       if (p_atomic_read(&bo->num_active_ioctls))
@@ -652,6 +667,7 @@ static struct pb_buffer *amdgpu_bo_from_handle(struct radeon_winsys *rws,
    bo->va_handle = va_handle;
    bo->initial_domain = initial;
    bo->unique_id = __sync_fetch_and_add(&ws->next_bo_unique_id, 1);
+   bo->is_shared = true;
 
    if (stride)
       *stride = whandle->stride;
@@ -701,6 +717,7 @@ static boolean amdgpu_bo_get_handle(struct pb_buffer *buffer,
       return FALSE;
 
    whandle->stride = stride;
+   bo->is_shared = true;
    return TRUE;
 }
 
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.h b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.h
index 65eb77d..9630c8c 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.h
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.h
@@ -62,6 +62,11 @@ struct amdgpu_winsys_bo {
     * thread, is this bo referenced in? */
    volatile int num_active_ioctls;
 
+   /* whether buffer_get_handle or buffer_from_handle was called,
+    * it can only transition from false to true
+    */
+   volatile int is_shared; /* bool (int for atomicity) */
+
    /* Fences for buffer synchronization. */
    struct pipe_fence_handle *fence[RING_LAST];
 };
-- 
1.9.1

