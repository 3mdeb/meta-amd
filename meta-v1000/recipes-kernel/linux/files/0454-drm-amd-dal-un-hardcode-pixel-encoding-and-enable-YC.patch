From ab8b867f0ed4ab7f7c54612bf522e2abdebc98b9 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Tue, 26 Apr 2016 18:42:20 -0400
Subject: [PATCH 0454/1722] drm/amd/dal: un-hardcode pixel encoding and enable
 YCbCr444

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    | 66 ++++++++++++++++---
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 73 ++--------------------
 drivers/gpu/drm/amd/dal/dc/core/dc_stream.c        | 14 +----
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  2 +
 drivers/gpu/drm/amd/dal/dc/dc_hw_types.h           |  5 --
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 47 +-------------
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    | 13 ----
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |  2 -
 drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h      | 13 ----
 9 files changed, 72 insertions(+), 163 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index f72116f..e74cf75 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -722,13 +722,58 @@ static enum dc_aspect_ratio get_aspect_ratio(
 		return ASPECT_RATIO_4_3;
 }
 
+static enum dc_color_space get_output_color_space(
+				const struct dc_crtc_timing *dc_crtc_timing)
+{
+	enum dc_color_space color_space = COLOR_SPACE_SRGB;
+
+	switch (dc_crtc_timing->pixel_encoding)	{
+	case PIXEL_ENCODING_YCBCR422:
+	case PIXEL_ENCODING_YCBCR444:
+	case PIXEL_ENCODING_YCBCR420:
+	{
+		/*
+		 * 27030khz is the separation point between HDTV and SDTV
+		 * according to HDMI spec, we use YCbCr709 and YCbCr601
+		 * respectively
+		 */
+		if (dc_crtc_timing->pix_clk_khz > 27030) {
+			if (dc_crtc_timing->flags.Y_ONLY)
+				color_space =
+					COLOR_SPACE_YCBCR709_LIMITED;
+			else
+				color_space = COLOR_SPACE_YCBCR709;
+		} else {
+			if (dc_crtc_timing->flags.Y_ONLY)
+				color_space =
+					COLOR_SPACE_YCBCR601_LIMITED;
+			else
+				color_space = COLOR_SPACE_YCBCR601;
+		}
+
+	}
+	break;
+	case PIXEL_ENCODING_RGB:
+		color_space = COLOR_SPACE_SRGB;
+		break;
+
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	return color_space;
+}
+
 /*****************************************************************************/
 
-static void dc_timing_from_drm_display_mode(
-	struct dc_crtc_timing *timing_out,
+static void fill_stream_properties_from_drm_display_mode(
+	struct dc_stream *stream,
 	const struct drm_display_mode *mode_in,
 	const struct drm_connector *connector)
 {
+	struct dc_crtc_timing *timing_out = &stream->timing;
+
 	memset(timing_out, 0, sizeof(struct dc_crtc_timing));
 
 	timing_out->h_border_left = 0;
@@ -736,8 +781,13 @@ static void dc_timing_from_drm_display_mode(
 	timing_out->v_border_top = 0;
 	timing_out->v_border_bottom = 0;
 	/* TODO: un-hardcode */
-	timing_out->pixel_encoding = PIXEL_ENCODING_RGB;
-	timing_out->timing_standard = TIMING_STANDARD_HDMI;
+
+	if (stream->sink->sink_signal == SIGNAL_TYPE_HDMI_TYPE_A &&
+			(connector->display_info.color_formats & DRM_COLOR_FORMAT_YCRCB444))
+		timing_out->pixel_encoding = PIXEL_ENCODING_YCBCR444;
+	else
+		timing_out->pixel_encoding = PIXEL_ENCODING_RGB;
+
 	timing_out->timing_3d_format = TIMING_3D_FORMAT_NONE;
 	timing_out->display_color_depth = convert_color_depth_from_display_info(
 			connector);
@@ -764,6 +814,8 @@ static void dc_timing_from_drm_display_mode(
 	if (mode_in->flags & DRM_MODE_FLAG_PVSYNC)
 		timing_out->flags.VSYNC_POSITIVE_POLARITY = 1;
 
+	stream->output_color_space = get_output_color_space(timing_out);
+
 }
 
 static void fill_audio_info(
@@ -902,7 +954,7 @@ static struct dc_target *create_target_for_sink(
 				dm_state->scaling != RMX_OFF);
 	}
 
-	dc_timing_from_drm_display_mode(&stream->timing,
+	fill_stream_properties_from_drm_display_mode(stream,
 			&mode, &aconnector->base);
 
 	fill_audio_info(
@@ -1230,7 +1282,7 @@ int amdgpu_dm_connector_mode_valid(
 	}
 
 	drm_mode_set_crtcinfo(mode, 0);
-	dc_timing_from_drm_display_mode(&streams[0]->timing, mode, connector);
+	fill_stream_properties_from_drm_display_mode(streams[0], mode, connector);
 
 	target = dc_create_target_for_streams(streams, 1);
 	val_set.target = target;
@@ -1459,7 +1511,7 @@ int dm_create_validation_set_for_target(struct drm_connector *connector,
 	}
 
 	drm_mode_set_crtcinfo(mode, 0);
-	dc_timing_from_drm_display_mode(&streams[0]->timing, mode, connector);
+	fill_stream_properties_from_drm_display_mode(streams[0], mode, connector);
 
 	target = dc_create_target_for_streams(streams, 1);
 	val_set->target = target;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 5e916e5..928141a 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -885,67 +885,6 @@ enum dc_status resource_map_pool_resources(
 	return DC_OK;
 }
 
-static enum ds_color_space build_default_color_space(
-		struct pipe_ctx *pipe_ctx)
-{
-	enum ds_color_space color_space =
-			DS_COLOR_SPACE_SRGB_FULLRANGE;
-	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
-
-	switch (pipe_ctx->signal) {
-	/* TODO: implement other signal color space setting */
-	case SIGNAL_TYPE_DISPLAY_PORT:
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-	case SIGNAL_TYPE_EDP:
-		break;
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-	{
-		uint32_t pix_clk_khz;
-
-		if (timing->pixel_encoding != PIXEL_ENCODING_YCBCR422 &&
-			timing->pixel_encoding != PIXEL_ENCODING_YCBCR444) {
-			if (timing->timing_standard ==
-					TIMING_STANDARD_CEA770 ||
-				timing->timing_standard ==
-						TIMING_STANDARD_CEA861)
-				color_space = DS_COLOR_SPACE_SRGB_FULLRANGE;
-
-			pix_clk_khz = timing->pix_clk_khz / 10;
-			if (timing->h_addressable == 640 &&
-				timing->v_addressable == 480 &&
-				(pix_clk_khz == 2520 || pix_clk_khz == 2517))
-				color_space = DS_COLOR_SPACE_SRGB_FULLRANGE;
-		} else {
-			if (timing->timing_standard ==
-					TIMING_STANDARD_CEA770 ||
-					timing->timing_standard ==
-					TIMING_STANDARD_CEA861) {
-
-				color_space =
-					(timing->pix_clk_khz > PIXEL_CLOCK) ?
-						DS_COLOR_SPACE_YCBCR709 :
-						DS_COLOR_SPACE_YCBCR601;
-			}
-		}
-		break;
-	}
-	default:
-		switch (timing->pixel_encoding) {
-		case PIXEL_ENCODING_YCBCR422:
-		case PIXEL_ENCODING_YCBCR444:
-			if (timing->pix_clk_khz > PIXEL_CLOCK)
-				color_space = DS_COLOR_SPACE_YCBCR709;
-			else
-				color_space = DS_COLOR_SPACE_YCBCR601;
-			break;
-		default:
-			break;
-		}
-		break;
-	}
-	return color_space;
-}
-
 static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 	struct encoder_info_frame *encoder_info_frame)
 {
@@ -1006,7 +945,7 @@ static void set_avi_info_frame(
 		struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	enum ds_color_space color_space = DS_COLOR_SPACE_UNKNOWN;
+	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
 	struct info_frame info_frame = { {0} };
 	uint32_t pixel_encoding = 0;
 	enum scanning_type scan_type = SCANNING_TYPE_NODATA;
@@ -1019,7 +958,7 @@ static void set_avi_info_frame(
 	if (info_packet == NULL)
 		return;
 
-	color_space = build_default_color_space(pipe_ctx);
+	color_space = pipe_ctx->stream->public.output_color_space;
 
 	/* Initialize header */
 	info_frame.avi_info_packet.info_packet_hdmi.bits.header.
@@ -1072,10 +1011,10 @@ static void set_avi_info_frame(
 	info_frame.avi_info_packet.info_packet_hdmi.bits.S0_S1 = scan_type;
 
 	/* C0, C1 : Colorimetry */
-	if (color_space == DS_COLOR_SPACE_YCBCR709)
+	if (color_space == COLOR_SPACE_YCBCR709)
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_ITU709;
-	else if (color_space == DS_COLOR_SPACE_YCBCR601)
+	else if (color_space == COLOR_SPACE_YCBCR601)
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_ITU601;
 	else
@@ -1113,10 +1052,10 @@ static void set_avi_info_frame(
 	}
 
 	/* TODO: un-hardcode q0_q1 */
-	if (color_space == DS_COLOR_SPACE_SRGB_FULLRANGE)
+	if (color_space == COLOR_SPACE_SRGB)
 		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
 						RGB_QUANTIZATION_FULL_RANGE;
-	else if (color_space == DS_COLOR_SPACE_SRGB_LIMITEDRANGE)
+	else if (color_space == COLOR_SPACE_SRGB_LIMITED)
 		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
 						RGB_QUANTIZATION_LIMITED_RANGE;
 	else
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
index 9a97574..a24b9f9 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
@@ -71,17 +71,6 @@ static void build_bit_depth_reduction_params(
 	return;
 }
 
-static void setup_pixel_encoding(
-	struct clamping_and_pixel_encoding_params *clamping)
-{
-	/*TODO: Need to un-hardcode, refer to function with same name
-		 * in dal2 hw_sequencer*/
-
-	clamping->pixel_encoding = PIXEL_ENCODING_RGB;
-
-	return;
-}
-
 static bool construct(struct core_stream *stream,
 	const struct dc_sink *dc_sink_data)
 {
@@ -94,7 +83,8 @@ static bool construct(struct core_stream *stream,
 	dc_sink_retain(dc_sink_data);
 
 	build_bit_depth_reduction_params(stream, &stream->bit_depth_params);
-	setup_pixel_encoding(&stream->clamping);
+
+	stream->clamping.pixel_encoding = stream->public.timing.pixel_encoding;
 
 	/* Copy audio modes */
 	/* TODO - Remove this translation */
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 8d6fc6b..490f95d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -306,6 +306,8 @@ struct dc_stream {
 	const struct dc_sink *sink;
 	struct dc_crtc_timing timing;
 
+	enum dc_color_space output_color_space;
+
 	struct rect src; /* viewport in target space*/
 	struct rect dst; /* stream addressable area */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
index 9a92dd7..c03efa5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
@@ -345,7 +345,6 @@ struct dc_cursor_attributes {
 
 /* OPP */
 
-
 enum dc_color_space {
 	COLOR_SPACE_UNKNOWN,
 	COLOR_SPACE_SRGB,
@@ -358,8 +357,6 @@ enum dc_color_space {
 	COLOR_SPACE_YCBCR709_LIMITED
 };
 
-
-
 /* XFM */
 
 /* used in  struct dc_surface */
@@ -370,7 +367,6 @@ struct scaling_taps {
 	uint32_t h_taps_c;
 };
 
-
 enum dc_timing_standard {
 	TIMING_STANDARD_UNDEFINED,
 	TIMING_STANDARD_DMT,
@@ -503,7 +499,6 @@ struct dc_crtc_timing {
 
 	uint32_t vic;
 	uint32_t hdmi_vic;
-	enum dc_timing_standard timing_standard;
 	enum dc_timing_3d_format timing_3d_format;
 	enum dc_color_depth display_color_depth;
 	enum dc_pixel_encoding pixel_encoding;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 265617d..c91c71b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -630,44 +630,6 @@ static void unblank_stream(struct pipe_ctx *pipe_ctx,
 	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
 }
 
-static enum dc_color_space get_output_color_space(
-				const struct dc_crtc_timing *dc_crtc_timing)
-{
-	enum dc_color_space color_space = COLOR_SPACE_SRGB;
-
-	switch (dc_crtc_timing->pixel_encoding)	{
-	case PIXEL_ENCODING_YCBCR422:
-	case PIXEL_ENCODING_YCBCR444:
-	case PIXEL_ENCODING_YCBCR420:
-	{
-		if ((dc_crtc_timing->timing_standard ==
-			TIMING_STANDARD_CEA770) ||
-			(dc_crtc_timing->timing_standard ==
-				TIMING_STANDARD_CEA861)) {
-			if (dc_crtc_timing->pix_clk_khz > 27030) {
-				if (dc_crtc_timing->flags.Y_ONLY)
-					color_space =
-						COLOR_SPACE_YCBCR709_LIMITED;
-				else
-					color_space = COLOR_SPACE_YCBCR709;
-			} else {
-				if (dc_crtc_timing->flags.Y_ONLY)
-					color_space =
-						COLOR_SPACE_YCBCR601_LIMITED;
-				else
-					color_space = COLOR_SPACE_YCBCR601;
-			}
-		}
-	}
-	break;
-
-	default:
-		break;
-	}
-
-	return color_space;
-}
-
 static enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)
 {
 	switch (crtc_id) {
@@ -765,7 +727,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct core_dc *dc)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	enum dc_color_space color_space;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context.res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
@@ -844,10 +805,9 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			true : false);
 
 	/* program blank color */
-	color_space = get_output_color_space(&stream->public.timing);
 	pipe_ctx->tg->funcs->set_blank_color(
 			pipe_ctx->tg,
-			color_space);
+			stream->public.output_color_space);
 
 	if (!pipe_ctx_old->stream) {
 		core_link_enable_stream(pipe_ctx);
@@ -1380,8 +1340,7 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 
 	default_adjust.force_hw_default = false;
 	default_adjust.in_color_space = pipe_ctx->surface->public.color_space;
-	default_adjust.out_color_space = get_output_color_space(
-					&pipe_ctx->stream->public.timing);
+	default_adjust.out_color_space = pipe_ctx->stream->public.output_color_space;
 	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
 	default_adjust.surface_pixel_format = pipe_ctx->scl_data.format;
 
@@ -1408,7 +1367,7 @@ static void program_scaler(const struct pipe_ctx *pipe_ctx)
 
 	pipe_ctx->tg->funcs->set_overscan_blank_color(
 		pipe_ctx->tg,
-		get_output_color_space(&pipe_ctx->stream->public.timing));
+		pipe_ctx->stream->public.output_color_space);
 
 	pipe_ctx->xfm->funcs->transform_set_scaler(pipe_ctx->xfm, &pipe_ctx->scl_data);
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 0b666fb..1d5f79b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -970,19 +970,6 @@ static bool validate_hdmi_output(
 		(pixel_clock > enc110->base.features.max_pixel_clock))
 		return false;
 
-	/*
-	 * Restriction: allow non-CE mode (IT mode) to support RGB only.
-	 * When it is IT mode, the format mode will be 0,
-	 * but currently the code is broken,
-	 * VIDEO FORMAT is always 0 in validatepathMode().
-	 * Due to overscan change - need fix there and test the impact - to do.
-	 */
-	if (crtc_timing->timing_standard != TIMING_STANDARD_CEA861 &&
-		crtc_timing->timing_standard != TIMING_STANDARD_HDMI)
-		if (crtc_timing->pixel_encoding !=
-			PIXEL_ENCODING_RGB)
-			return false;
-
 	/* DCE11 HW does not support 420 */
 	if (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 86edf4d..0ce43b0 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -82,8 +82,6 @@ void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 #define DC_STREAM_TO_CORE(dc_stream) container_of( \
 	dc_stream, struct core_stream, public)
 
-#define PIXEL_CLOCK	27030
-
 struct core_stream {
 	struct dc_stream public;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
index 02c05f3..57e54f9 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
@@ -63,19 +63,6 @@ enum colorimetry {
        COLORIMETRY_EXTENDED = 3
 };
 
-enum ds_color_space {
-       DS_COLOR_SPACE_UNKNOWN = 0,
-       DS_COLOR_SPACE_SRGB_FULLRANGE = 1,
-       DS_COLOR_SPACE_SRGB_LIMITEDRANGE,
-       DS_COLOR_SPACE_YPBPR601,
-       DS_COLOR_SPACE_YPBPR709,
-       DS_COLOR_SPACE_YCBCR601,
-       DS_COLOR_SPACE_YCBCR709,
-       DS_COLOR_SPACE_NMVPU_SUPERAA,
-       DS_COLOR_SPACE_YCBCR601_YONLY,
-       DS_COLOR_SPACE_YCBCR709_YONLY/*same as YCbCr, but Y in Full range*/
-};
-
 enum active_format_info {
        ACTIVE_FORMAT_NO_DATA = 0,
        ACTIVE_FORMAT_VALID = 1
-- 
2.7.4

