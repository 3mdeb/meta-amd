From fd87538ecbeefcd78c2ff94800f6aa5f0220fe02 Mon Sep 17 00:00:00 2001
From: daylee <Dayeong.Lee@amd.com>
Date: Mon, 27 Jun 2016 17:57:57 -0400
Subject: [PATCH 0594/1722] drm/amd/dal: Expose flip_pending bit

Retrieve dc_surface_status for a dc_surface.
Surface status would have the address and the flip
pending info.

Change-Id: Iee5cb8a13c69fcdd1895ccd289305ba10402bf16
Signed-off-by: Dayeong Lee <Dayeong.Lee@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc_surface.c       | 42 ++++++++++++++++++++++
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  2 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 17 +++++++--
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c   | 16 +++++----
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h   |  4 +--
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c | 17 +++++----
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c |  4 +--
 drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h      |  2 +-
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |  3 ++
 9 files changed, 86 insertions(+), 21 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
index d688bc2..3e45992 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
@@ -102,6 +102,48 @@ alloc_fail:
 	return NULL;
 }
 
+const struct dc_surface_status *dc_surface_get_status(
+		struct dc_surface *dc_surface)
+{
+	struct dc_surface_status *surface_status;
+	struct core_surface *core_surface;
+	struct core_dc *core_dc;
+	int i;
+
+	if (dc_surface == NULL)
+		return NULL;
+
+	core_surface = DC_SURFACE_TO_CORE(dc_surface);
+
+	if (core_surface == NULL || core_surface->ctx == NULL)
+		return NULL;
+
+	surface_status = &core_surface->status;
+
+	if (core_surface->ctx == NULL || core_surface->ctx->dc == NULL)
+		return NULL;
+
+	core_dc = DC_TO_CORE(core_surface->ctx->dc);
+
+	if (core_dc->current_context == NULL)
+		return NULL;
+
+	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count;
+			i++) {
+		struct pipe_ctx *pipe_ctx =
+				&core_dc->current_context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->surface !=
+				DC_SURFACE_TO_CORE(dc_surface))
+			continue;
+
+		core_dc->hwss.update_pending_status(pipe_ctx);
+		surface_status->requested_address = dc_surface->address;
+	}
+
+	return surface_status;
+}
+
 void dc_surface_retain(const struct dc_surface *dc_surface)
 {
 	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index aa456fd..d5966c8 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -148,7 +148,7 @@ struct dc_surface {
  */
 struct dc_surface_status {
 	struct dc_plane_address requested_address;
-	struct dc_plane_address current_address;
+	bool is_flip_pending;
 };
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index a2e96c7..2ad7eed 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1506,10 +1506,22 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, false);
 
 	if (surface->public.flip_immediate)
-		pipe_ctx->mi->funcs->wait_for_no_surface_update_pending(
-								pipe_ctx->mi);
+		while (pipe_ctx->mi->funcs->mem_input_is_flip_pending(
+				pipe_ctx->mi))
+			;
 }
 
+static void update_pending_status(struct pipe_ctx *pipe_ctx)
+{
+	struct core_surface *surface = pipe_ctx->surface;
+
+	if (surface == NULL)
+		return;
+
+	surface->status.is_flip_pending =
+			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
+					pipe_ctx->mi);
+}
 
 static void power_down(struct core_dc *dc)
 {
@@ -1877,6 +1889,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.apply_ctx_to_surface = apply_ctx_to_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
+	.update_pending_status = update_pending_status,
 	.update_plane_surface = update_plane_surface,
 	.set_gamma_correction = set_gamma_ramp,
 	.power_down = power_down,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index e569eac..0235560 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -348,14 +348,18 @@ static void program_pixel_format(
 	}
 }
 
-void dce110_mem_input_wait_for_no_surface_update_pending(struct mem_input *mem_input)
+bool dce110_mem_input_is_flip_pending(struct mem_input *mem_input)
 {
 	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
 	uint32_t value;
 
-	do {
-		value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE));
-	} while (get_reg_field_value(value, GRPH_UPDATE, GRPH_SURFACE_UPDATE_PENDING));
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_UPDATE));
+
+	if (get_reg_field_value(value, GRPH_UPDATE,
+			GRPH_SURFACE_UPDATE_PENDING))
+		return true;
+
+	return false;
 }
 
 bool dce110_mem_input_program_surface_flip_and_addr(
@@ -869,8 +873,8 @@ static struct mem_input_funcs dce110_mem_input_funcs = {
 			dce110_mem_input_program_surface_flip_and_addr,
 	.mem_input_program_surface_config =
 			dce110_mem_input_program_surface_config,
-	.wait_for_no_surface_update_pending =
-			dce110_mem_input_wait_for_no_surface_update_pending
+	.mem_input_is_flip_pending =
+			dce110_mem_input_is_flip_pending
 };
 /*****************************************/
 /* Constructor, Destructor               */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
index 0704269..f36f0fe 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
@@ -130,13 +130,13 @@ bool  dce110_mem_input_program_surface_config(
 	enum dc_rotation_angle rotation);
 
 /*
- * dce110_mem_input_wait_for_no_surface_update_pending
+ * dce110_mem_input_is_flip_pending
  *
  * This function will wait until the surface update-pending bit is cleared.
  * This is necessary when a flip immediate call is requested as we shouldn't
  * return until the flip has actually occurred.
  */
-void dce110_mem_input_wait_for_no_surface_update_pending(
+bool dce110_mem_input_is_flip_pending(
 	struct mem_input *mem_input);
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
index e48a6c9..45dc985 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
@@ -492,15 +492,18 @@ static void program_pixel_format(
 	}
 }
 
-void dce110_mem_input_v_wait_for_no_surface_update_pending(
-				struct mem_input *mem_input)
+bool dce110_mem_input_v_is_surface_pending(struct mem_input *mem_input)
 {
 	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
 	uint32_t value;
 
-	do  {
-		value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_UPDATE));
-	} while (get_reg_field_value(value, UNP_GRPH_UPDATE, GRPH_SURFACE_UPDATE_PENDING));
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_UPDATE));
+
+	if (get_reg_field_value(value, UNP_GRPH_UPDATE,
+			GRPH_SURFACE_UPDATE_PENDING))
+		return true;
+
+	return false;
 }
 
 bool dce110_mem_input_v_program_surface_flip_and_addr(
@@ -873,8 +876,8 @@ static struct mem_input_funcs dce110_mem_input_v_funcs = {
 			dce110_mem_input_v_program_surface_flip_and_addr,
 	.mem_input_program_surface_config =
 			dce110_mem_input_v_program_surface_config,
-	.wait_for_no_surface_update_pending =
-			dce110_mem_input_v_wait_for_no_surface_update_pending
+	.mem_input_is_flip_pending =
+			dce110_mem_input_v_is_surface_pending
 };
 /*****************************************/
 /* Constructor, Destructor               */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
index 7812a7d..c8841c1 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_mem_input.c
@@ -181,8 +181,8 @@ static struct mem_input_funcs dce80_mem_input_funcs = {
 			dce110_mem_input_program_surface_flip_and_addr,
 	.mem_input_program_surface_config =
 			dce110_mem_input_program_surface_config,
-	.wait_for_no_surface_update_pending =
-			dce110_mem_input_wait_for_no_surface_update_pending
+	.mem_input_is_flip_pending =
+			dce110_mem_input_is_flip_pending
 };
 
 /*****************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
index 0a8285e..2d5dff0 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
@@ -73,7 +73,7 @@ struct mem_input_funcs {
 		union plane_size *plane_size,
 		enum dc_rotation_angle rotation);
 
-	void (*wait_for_no_surface_update_pending)(struct mem_input *mem_input);
+	bool (*mem_input_is_flip_pending)(struct mem_input *mem_input);
 };
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 021ed1e..ec55823 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -62,6 +62,9 @@ struct hw_sequencer_funcs {
 		const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx);
 
+	void (*update_pending_status)(
+			struct pipe_ctx *pipe_ctx);
+
 	void (*update_plane_surface)(
 		struct core_dc *dc,
 		struct validate_context *context,
-- 
2.7.4

