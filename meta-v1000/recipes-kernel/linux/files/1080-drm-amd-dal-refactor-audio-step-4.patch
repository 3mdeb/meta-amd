From 287befbb9c73a3961798e653dd221934ffdaef6e Mon Sep 17 00:00:00 2001
From: Tony Cheng <tony.cheng@amd.com>
Date: Wed, 14 Sep 2016 11:37:13 -0400
Subject: [PATCH 1080/1722] drm/amd/dal: refactor audio step 4

- move AFMT disable code in dal_audio_disable_output to stream_enc
- setup infrastructure for resource to assign register offset for audio
- separate out AZ disable and program directly by audio
- remove audio_power_down.  dead code
- move audio disable to the correct place, in disable stream sequence

Change-Id: I44001306033c93a7a58306c049bfaabf04415c87
Signed-off-by: Tony Cheng <tony.cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/audio/Makefile          |    2 +-
 drivers/gpu/drm/amd/dal/dc/audio/audio.h           |   24 +-
 drivers/gpu/drm/amd/dal/dc/audio/audio_base.c      |   84 +-
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c |  768 +++++++++++--
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h |   24 +
 .../amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c  | 1194 --------------------
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c   |  112 +-
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h   |    6 -
 .../amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c    | 1081 ------------------
 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c    |  493 --------
 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h    |  101 --
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |    1 +
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |   52 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |   49 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |   51 +-
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  |  418 +++++++
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.h  |   59 +
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |   52 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |   53 +-
 drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h |   31 +-
 drivers/gpu/drm/amd/dal/include/audio_interface.h  |   49 +-
 drivers/gpu/drm/amd/dal/include/audio_types.h      |   49 +-
 22 files changed, 1355 insertions(+), 3398 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c

diff --git a/drivers/gpu/drm/amd/dal/dc/audio/Makefile b/drivers/gpu/drm/amd/dal/dc/audio/Makefile
index 90bdaa6..e78897a 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/Makefile
+++ b/drivers/gpu/drm/amd/dal/dc/audio/Makefile
@@ -3,7 +3,7 @@
 # It provides the control and status of HW adapter resources,
 # that are global for the ASIC and sharable between pipes.
 
-AUDIO = audio_base.o hw_ctx_audio.o
+AUDIO = audio_base.o
 
 AMD_DAL_AUDIO = $(addprefix $(AMDDALPATH)/dc/audio/,$(AUDIO))
 
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio.h b/drivers/gpu/drm/amd/dal/dc/audio/audio.h
index a39890d..fc2a54e 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/audio.h
@@ -39,6 +39,17 @@
 struct audio;
 
 struct audio_funcs {
+	void (*az_enable)(
+			struct audio *audio);
+
+	void (*az_disable)(
+			struct audio *audio);
+
+	void (*az_configure)(struct audio *audio,
+		enum signal_type signal,
+		const struct audio_crtc_info *crtc_info,
+		const struct audio_info *audio_info);
+
 	/*
 	 *get_object_id
 	 *get_object_type
@@ -56,17 +67,6 @@ struct audio_funcs {
 	 *release_hw_base
 	 */
 
-	/* setup audio */
-	enum audio_result (*setup)(
-		struct audio *audio,
-		struct audio_output *output,
-		struct audio_info *info);
-
-	enum audio_result (*disable_output)(
-		struct audio *audio,
-		enum engine_id engine_id,
-		enum signal_type signal);
-
 	/*enable_azalia_audio_jack_presence
 	 * disable_azalia_audio_jack_presence
 	 */
@@ -104,13 +104,13 @@ struct audio_funcs {
 struct audio {
 	/* hook functions. they will be overwritten by specific ASIC */
 	const struct audio_funcs *funcs;
-	/* TODO: static struct audio_funcs funcs;*/
 
 	/*external structures - get service from external*/
 	struct graphics_object_id id;
 	/* audio HW context */
 	struct hw_ctx_audio *hw_ctx;
 	struct dc_context *ctx;
+	unsigned int inst;
 };
 
 /* - functions defined by audio.h will be used by audio component only.
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
index 66ac071..69f44af 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
@@ -51,26 +51,6 @@ static void destroy(
 	BREAK_TO_DEBUGGER();
 }
 
-static enum audio_result setup(
-	struct audio *audio,
-	struct audio_output *output,
-	struct audio_info *info)
-{
-	/*DCE specific, must be implemented in derived*/
-	BREAK_TO_DEBUGGER();
-	return AUDIO_RESULT_OK;
-}
-
-static enum audio_result disable_output(
-	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal)
-{
-	/*DCE specific, must be implemented in derived*/
-	BREAK_TO_DEBUGGER();
-	return AUDIO_RESULT_OK;
-}
-
 static enum audio_result initialize(
 	struct audio *audio)
 {
@@ -94,8 +74,6 @@ static void setup_audio_wall_dto(
 
 static const struct audio_funcs audio_funcs = {
 	.destroy = destroy,
-	.setup = setup,
-	.disable_output = disable_output,
 	.initialize = initialize,
 	.setup_audio_wall_dto = setup_audio_wall_dto,
 };
@@ -113,6 +91,7 @@ bool dal_audio_construct_base(
 
 	/* save audio endpoint number to identify object creating */
 	audio->id = init_data->audio_stream_id;
+	audio->inst = init_data->inst;
 
 	return true;
 }
@@ -144,42 +123,6 @@ void dal_audio_destroy(
 	*audio = NULL;
 }
 
-/* enable azalia audio endpoint. This function call hw_ctx directly
- *not overwitten at audio level.
- */
-enum audio_result dal_audio_enable_azalia_audio_jack_presence(
-	struct audio *audio,
-	enum engine_id engine_id)
-{
-	audio->hw_ctx->funcs->enable_azalia_audio(audio->hw_ctx, engine_id);
-	return AUDIO_RESULT_OK;
-}
-
-/* disable azalia audio endpoint. This function call hw_ctx directly
- *not overwitten at audio level.
- */
-enum audio_result dal_audio_disable_azalia_audio_jack_presence(
-	struct audio *audio,
-	enum engine_id engine_id)
-{
-	audio->hw_ctx->funcs->disable_azalia_audio(audio->hw_ctx, engine_id);
-	return AUDIO_RESULT_OK;
-}
-
-/* get audio bandwidth information. This function call hw_ctx directly
- *not overwitten at audio level.
- */
-void dal_audio_check_audio_bandwidth(
-	struct audio *audio,
-	const struct audio_crtc_info *info,
-	uint32_t channel_count,
-	enum signal_type signal,
-	union audio_sample_rates *sample_rates)
-{
-	dal_hw_ctx_audio_check_audio_bandwidth(
-		audio->hw_ctx, info, channel_count, signal, sample_rates);
-}
-
 /* DP Audio register write access. This function call hw_ctx directly
  * not overwitten at audio level.
  */
@@ -191,31 +134,6 @@ enum audio_result dal_audio_power_up(
 	return audio->funcs->initialize(audio);
 }
 
-/* perform power down (shut down, stand by) */
-enum audio_result dal_audio_power_down(
-	struct audio *audio)
-{
-	return AUDIO_RESULT_OK;
-}
-
-/* setup audio */
-enum audio_result dal_audio_setup(
-	struct audio *audio,
-	struct audio_output *output,
-	struct audio_info *info)
-{
-	return audio->funcs->setup(audio, output, info);
-}
-
-/* disable audio */
-enum audio_result dal_audio_disable_output(
-	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal)
-{
-	return audio->funcs->disable_output(audio, engine_id, signal);
-}
-
 /* update audio wall clock source */
 void dal_audio_setup_audio_wall_dto(
 	struct audio *audio,
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
index 36f8f6b..a875acb 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
@@ -29,6 +29,9 @@
 
 #include "audio_dce110.h"
 
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+
 /***** static functions  *****/
 
 static void destruct(struct audio_dce110 *audio)
@@ -57,119 +60,697 @@ static void destroy(struct audio **ptr)
 	*ptr = NULL;
 }
 
-/* The inital call of hook function comes from audio object level.
- *The passing object handle "struct audio *audio" point to base object
- *already.There is not need to get base object from audio_dce110.
- */
+#define DCE110_AUD(audio)\
+	container_of(audio, struct audio_dce110, base)
 
-/**
-* setup
-*
-* @brief
-*  setup Audio HW block, to be called by dal_audio_setup
-*
-*/
-static enum audio_result setup(
-	struct audio *audio,
-	struct audio_output *output,
-	struct audio_info *info)
+#define CTX \
+	aud110->base.ctx
+
+#define REG(reg)\
+	(aud110->regs->reg)
+
+#define IX_REG(reg)\
+	ix ## reg
+
+
+#define REG_READ(reg_name) \
+		dm_read_reg(CTX, REG(reg_name))
+
+#define REG_WRITE(reg_name, value) \
+		dm_write_reg(CTX, REG(reg_name), value)
+
+#define REG_SET_N(reg_name, n, ...)	\
+		generic_reg_update_ex(CTX, \
+				REG(reg_name), \
+				0, \
+				n, __VA_ARGS__)
+
+#define REG_SET(reg_name, field, val)	\
+		REG_SET_N(reg_name, 1, FD(reg_name##__##field), val)
+
+#define AZ_REG_READ(reg_name) \
+		read_indirect_azalia_reg(audio, IX_REG(reg_name))
+
+#define AZ_REG_WRITE(reg_name, value) \
+		write_indirect_azalia_reg(audio, IX_REG(reg_name), value)
+
+
+static void write_indirect_azalia_reg(struct audio *audio,
+	uint32_t reg_index,
+	uint32_t reg_data)
 {
-	switch (output->signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		/*setup HDMI audio engine*/
-		audio->hw_ctx->funcs->enable_afmt_clock(
-			audio->hw_ctx,
-			output->engine_id,
-			true);
-		audio->hw_ctx->funcs->setup_hdmi_audio(
-			audio->hw_ctx, output->engine_id, &output->crtc_info);
-
-		audio->hw_ctx->funcs->setup_azalia(
-			audio->hw_ctx,
-			output->engine_id,
-			output->signal,
-			&output->crtc_info,
-			&output->pll_info,
-			info);
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
+	REG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX,
+			AZALIA_ENDPOINT_REG_INDEX, reg_index);
+
+	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
+	REG_SET(AZALIA_F0_CODEC_ENDPOINT_DATA,
+			AZALIA_ENDPOINT_REG_DATA, reg_data);
+
+	dal_logger_write(CTX->logger,
+		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_AUDIO,
+		"AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
+		reg_index, reg_data);
+}
+
+static uint32_t read_indirect_azalia_reg(struct audio *audio, uint32_t reg_index)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value = 0;
+
+	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
+	REG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX,
+			AZALIA_ENDPOINT_REG_INDEX, reg_index);
+
+	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
+	value = REG_READ(AZALIA_F0_CODEC_ENDPOINT_DATA);
+
+	dal_logger_write(CTX->logger,
+		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_AUDIO,
+		"AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
+		reg_index, value);
+
+	return value;
+}
+
+static bool is_audio_format_supported(
+	const struct audio_info *audio_info,
+	enum audio_format_code audio_format_code,
+	uint32_t *format_index)
+{
+	uint32_t index;
+	uint32_t max_channe_index = 0;
+	bool found = false;
+
+	if (audio_info == NULL)
+		return found;
+
+	/* pass through whole array */
+	for (index = 0; index < audio_info->mode_count; index++) {
+		if (audio_info->modes[index].format_code == audio_format_code) {
+			if (found) {
+				/* format has multiply entries, choose one with
+				 *  highst number of channels */
+				if (audio_info->modes[index].channel_count >
+		audio_info->modes[max_channe_index].channel_count) {
+					max_channe_index = index;
+				}
+			} else {
+				/* format found, save it's index */
+				found = true;
+				max_channe_index = index;
+			}
+		}
+	}
+
+	/* return index */
+	if (found && format_index != NULL)
+		*format_index = max_channe_index;
+
+	return found;
+}
+
+/*For HDMI, calculate if specified sample rates can fit into a given timing */
+static void check_audio_bandwidth_hdmi(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	union audio_sample_rates *sample_rates)
+{
+	uint32_t samples;
+	uint32_t  h_blank;
+	bool limit_freq_to_48_khz = false;
+	bool limit_freq_to_88_2_khz = false;
+	bool limit_freq_to_96_khz = false;
+	bool limit_freq_to_174_4_khz = false;
+
+	/* For two channels supported return whatever sink support,unmodified*/
+	if (channel_count > 2) {
+
+		/* Based on HDMI spec 1.3 Table 7.5 */
+		if ((crtc_info->requested_pixel_clock <= 27000) &&
+		(crtc_info->v_active <= 576) &&
+		!(crtc_info->interlaced) &&
+		!(crtc_info->pixel_repetition == 2 ||
+		crtc_info->pixel_repetition == 4)) {
+			limit_freq_to_48_khz = true;
+
+		} else if ((crtc_info->requested_pixel_clock <= 27000) &&
+				(crtc_info->v_active <= 576) &&
+				(crtc_info->interlaced) &&
+				(crtc_info->pixel_repetition == 2)) {
+			limit_freq_to_88_2_khz = true;
+
+		} else if ((crtc_info->requested_pixel_clock <= 54000) &&
+				(crtc_info->v_active <= 576) &&
+				!(crtc_info->interlaced)) {
+			limit_freq_to_174_4_khz = true;
+		}
+	}
+
+	/* Also do some calculation for the available Audio Bandwidth for the
+	 * 8 ch (i.e. for the Layout 1 => ch > 2)
+	 */
+	h_blank = crtc_info->h_total - crtc_info->h_active;
+
+	if (crtc_info->pixel_repetition)
+		h_blank *= crtc_info->pixel_repetition;
+
+	/*based on HDMI spec 1.3 Table 7.5 */
+	h_blank -= 58;
+	/*for Control Period */
+	h_blank -= 16;
+
+	samples = h_blank * 10;
+	/* Number of Audio Packets (multiplied by 10) per Line (for 8 ch number
+	 * of Audio samples per line multiplied by 10 - Layout 1)
+	 */
+	 samples /= 32;
+	 samples *= crtc_info->v_active;
+	 /*Number of samples multiplied by 10, per second */
+	 samples *= crtc_info->refresh_rate;
+	 /*Number of Audio samples per second */
+	 samples /= 10;
+
+	 /* @todo do it after deep color is implemented
+	  * 8xx - deep color bandwidth scaling
+	  * Extra bandwidth is avaliable in deep color b/c link runs faster than
+	  * pixel rate. This has the effect of allowing more tmds characters to
+	  * be transmitted during blank
+	  */
+
+	switch (crtc_info->color_depth) {
+	case COLOR_DEPTH_888:
+		samples *= 4;
 		break;
+	case COLOR_DEPTH_101010:
+		samples *= 5;
+		break;
+	case COLOR_DEPTH_121212:
+		samples *= 6;
+		break;
+	default:
+		samples *= 4;
+		break;
+	}
 
-	case SIGNAL_TYPE_WIRELESS:
-		/* setup Azalia block for Wireless Display - This
-			is different than for wired
-			displays because there is no
-			DIG to program.*/
-		/*TODO:
-		audio->hw_ctx->funcs->setup_azalia_for_vce(
-			audio->hw_ctx,
-			audio->signal,
-			audio->crtc_info,
-			info);
-		*/
+	samples /= 4;
+
+	/*check limitation*/
+	if (samples < 88200)
+		limit_freq_to_48_khz = true;
+	else if (samples < 96000)
+		limit_freq_to_88_2_khz = true;
+	else if (samples < 176400)
+		limit_freq_to_96_khz = true;
+	else if (samples < 192000)
+		limit_freq_to_174_4_khz = true;
+
+	if (sample_rates != NULL) {
+		/* limit frequencies */
+		if (limit_freq_to_174_4_khz)
+			sample_rates->rate.RATE_192 = 0;
+
+		if (limit_freq_to_96_khz) {
+			sample_rates->rate.RATE_192 = 0;
+			sample_rates->rate.RATE_176_4 = 0;
+		}
+		if (limit_freq_to_88_2_khz) {
+			sample_rates->rate.RATE_192 = 0;
+			sample_rates->rate.RATE_176_4 = 0;
+			sample_rates->rate.RATE_96 = 0;
+		}
+		if (limit_freq_to_48_khz) {
+			sample_rates->rate.RATE_192 = 0;
+			sample_rates->rate.RATE_176_4 = 0;
+			sample_rates->rate.RATE_96 = 0;
+			sample_rates->rate.RATE_88_2 = 0;
+		}
+	}
+}
+
+/*For DP SST, calculate if specified sample rates can fit into a given timing */
+static void check_audio_bandwidth_dpsst(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	union audio_sample_rates *sample_rates)
+{
+	/* do nothing */
+}
+
+/*For DP MST, calculate if specified sample rates can fit into a given timing */
+static void check_audio_bandwidth_dpmst(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	union audio_sample_rates *sample_rates)
+{
+	/* do nothing  */
+}
+
+static void check_audio_bandwidth(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	enum signal_type signal,
+	union audio_sample_rates *sample_rates)
+{
+	switch (signal) {
+	case SIGNAL_TYPE_HDMI_TYPE_A:
+		check_audio_bandwidth_hdmi(
+			crtc_info, channel_count, sample_rates);
 		break;
+	case SIGNAL_TYPE_EDP:
 	case SIGNAL_TYPE_DISPLAY_PORT:
+		check_audio_bandwidth_dpsst(
+			crtc_info, channel_count, sample_rates);
+		break;
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-	case SIGNAL_TYPE_EDP:
-		/* setup DP audio engine will be done at enable output */
-
-		/* setup Azalia block*/
-		audio->hw_ctx->funcs->setup_azalia(
-			audio->hw_ctx,
-			output->engine_id,
-			output->signal,
-			&output->crtc_info,
-			&output->pll_info,
-			info);
-
+		check_audio_bandwidth_dpmst(
+			crtc_info, channel_count, sample_rates);
 		break;
 	default:
-		return AUDIO_RESULT_ERROR;
+		break;
 	}
+}
 
-	return AUDIO_RESULT_OK;
+/* expose/not expose HBR capability to Audio driver */
+static void set_high_bit_rate_capable(
+	struct audio *audio,
+	bool capable)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+	uint32_t value = 0;
+
+	/* set high bit rate audio capable*/
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR);
+
+	set_reg_field_value(value, capable,
+		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
+		HBR_CAPABLE);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR, value);
 }
 
-/**
-* disable_output
-*
-* @brief
-*  disable Audio HW block, to be called by dal_audio_disable_output
-*
-*/
-static enum audio_result disable_output(
+/* set video latency in in ms/2+1 */
+static void set_video_latency(
+	struct audio *audio,
+	int latency_in_ms)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value = 0;
+
+	if ((latency_in_ms < 0) || (latency_in_ms > 255))
+		return;
+
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
+
+	set_reg_field_value(value, latency_in_ms,
+		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		VIDEO_LIPSYNC);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		value);
+}
+
+/* set audio latency in in ms/2+1 */
+static void set_audio_latency(
+	struct audio *audio,
+	int latency_in_ms)
+{
+	uint32_t value = 0;
+
+	if (latency_in_ms < 0)
+		latency_in_ms = 0;
+
+	if (latency_in_ms > 255)
+		latency_in_ms = 255;
+
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
+
+	set_reg_field_value(value, latency_in_ms,
+		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		AUDIO_LIPSYNC);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		value);
+}
+
+void dce110_aud_az_enable(struct audio *audio)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
+
+	if (get_reg_field_value(value,
+			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
+			AUDIO_ENABLED) != 1)
+		set_reg_field_value(value, 1,
+			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
+			AUDIO_ENABLED);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
+}
+
+void dce110_aud_az_disable(struct audio *audio)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value;
+
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
+
+	set_reg_field_value(value, 0,
+		AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
+		AUDIO_ENABLED);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
+}
+
+void dce110_aud_az_configure(
 	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal)
+	enum signal_type signal,
+	const struct audio_crtc_info *crtc_info,
+	const struct audio_info *audio_info)
 {
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t speakers = audio_info->flags.info.ALLSPEAKERS;
+	uint32_t value;
+	uint32_t field = 0;
+	enum audio_format_code audio_format_code;
+	uint32_t format_index;
+	uint32_t index;
+	bool is_ac3_supported = false;
+	union audio_sample_rates sample_rate;
+	uint32_t strlen = 0;
+
+	/* Speaker Allocation */
+	/*
+	uint32_t value;
+	uint32_t field = 0;*/
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);
+
+	set_reg_field_value(value,
+		speakers,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		SPEAKER_ALLOCATION);
+
+	/* LFE_PLAYBACK_LEVEL = LFEPBL
+	 * LFEPBL = 0 : Unknown or refer to other information
+	 * LFEPBL = 1 : 0dB playback
+	 * LFEPBL = 2 : +10dB playback
+	 * LFE_BL = 3 : Reserved
+	 */
+	set_reg_field_value(value,
+		0,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		LFE_PLAYBACK_LEVEL);
+	/* todo: according to reg spec LFE_PLAYBACK_LEVEL is read only.
+	 *  why are we writing to it?  DCE8 does not write this */
+
+
+	set_reg_field_value(value,
+		0,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		HDMI_CONNECTION);
+
+	set_reg_field_value(value,
+		0,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		DP_CONNECTION);
+
+	field = get_reg_field_value(value,
+			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+			EXTRA_CONNECTION_INFO);
+
+	field &= ~0x1;
+
+	set_reg_field_value(value,
+		field,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		EXTRA_CONNECTION_INFO);
+
+	/* set audio for output signal */
 	switch (signal) {
 	case SIGNAL_TYPE_HDMI_TYPE_A:
-	case SIGNAL_TYPE_WIRELESS:
-		/* disable HDMI audio */
-		audio->hw_ctx->
-			funcs->disable_azalia_audio(
-					audio->hw_ctx, engine_id);
-		audio->hw_ctx->
-			funcs->enable_afmt_clock(
-					audio->hw_ctx, engine_id,
-					false);
+		set_reg_field_value(value,
+			1,
+			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+			HDMI_CONNECTION);
 
 		break;
+
+	case SIGNAL_TYPE_EDP:
 	case SIGNAL_TYPE_DISPLAY_PORT:
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-	case SIGNAL_TYPE_EDP: {
-			/* disable DP audio */
-			audio->hw_ctx->funcs->disable_dp_audio(
-				audio->hw_ctx, engine_id);
-			audio->hw_ctx->funcs->disable_azalia_audio(
-				audio->hw_ctx, engine_id);
-			audio->hw_ctx->funcs->enable_afmt_clock(
-				audio->hw_ctx, engine_id, false);
-		}
+		set_reg_field_value(value,
+			1,
+			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+			DP_CONNECTION);
 		break;
 	default:
-		return AUDIO_RESULT_ERROR;
+		BREAK_TO_DEBUGGER();
+		break;
 	}
 
-	return AUDIO_RESULT_OK;
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, value);
+
+	/*  Audio Descriptors   */
+	/* pass through all formats */
+	for (format_index = 0; format_index < AUDIO_FORMAT_CODE_COUNT;
+			format_index++) {
+		audio_format_code =
+			(AUDIO_FORMAT_CODE_FIRST + format_index);
+
+		/* those are unsupported, skip programming */
+		if (audio_format_code == AUDIO_FORMAT_CODE_1BITAUDIO ||
+			audio_format_code == AUDIO_FORMAT_CODE_DST)
+			continue;
+
+		value = 0;
+
+		/* check if supported */
+		if (is_audio_format_supported(
+				audio_info, audio_format_code, &index)) {
+			const struct audio_mode *audio_mode =
+					&audio_info->modes[index];
+			union audio_sample_rates sample_rates =
+					audio_mode->sample_rates;
+			uint8_t byte2 = audio_mode->max_bit_rate;
+
+			/* adjust specific properties */
+			switch (audio_format_code) {
+			case AUDIO_FORMAT_CODE_LINEARPCM: {
+				check_audio_bandwidth(
+					crtc_info,
+					audio_mode->channel_count,
+					signal,
+					&sample_rates);
+
+				byte2 = audio_mode->sample_size;
+
+				set_reg_field_value(value,
+						sample_rates.all,
+						AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+						SUPPORTED_FREQUENCIES_STEREO);
+				}
+				break;
+			case AUDIO_FORMAT_CODE_AC3:
+				is_ac3_supported = true;
+				break;
+			case AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS:
+			case AUDIO_FORMAT_CODE_DTS_HD:
+			case AUDIO_FORMAT_CODE_MAT_MLP:
+			case AUDIO_FORMAT_CODE_DST:
+			case AUDIO_FORMAT_CODE_WMAPRO:
+				byte2 = audio_mode->vendor_specific;
+				break;
+			default:
+				break;
+			}
+
+			/* fill audio format data */
+			set_reg_field_value(value,
+					audio_mode->channel_count - 1,
+					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+					MAX_CHANNELS);
+
+			set_reg_field_value(value,
+					sample_rates.all,
+					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+					SUPPORTED_FREQUENCIES);
+
+			set_reg_field_value(value,
+					byte2,
+					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+					DESCRIPTOR_BYTE_2);
+		} /* if */
+
+		AZ_REG_WRITE(
+				AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0 + format_index,
+				value);
+	} /* for */
+
+	if (is_ac3_supported)
+		/* todo: this reg global.  why program global register? */
+		REG_WRITE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
+				0x05);
+
+	/* check for 192khz/8-Ch support for HBR requirements */
+	sample_rate.all = 0;
+	sample_rate.rate.RATE_192 = 1;
+
+	check_audio_bandwidth(
+		crtc_info,
+		8,
+		signal,
+		&sample_rate);
+
+	set_high_bit_rate_capable(audio, sample_rate.rate.RATE_192);
+
+	/* Audio and Video Lipsync */
+	set_video_latency(audio, audio_info->video_latency);
+	set_audio_latency(audio, audio_info->audio_latency);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->manufacture_id,
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
+		MANUFACTURER_ID);
+
+	set_reg_field_value(value, audio_info->product_id,
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
+		PRODUCT_ID);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
+		value);
+
+	value = 0;
+
+	/*get display name string length */
+	while (audio_info->display_name[strlen++] != '\0') {
+		if (strlen >=
+		MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS)
+			break;
+		}
+	set_reg_field_value(value, strlen,
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
+		SINK_DESCRIPTION_LEN);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
+		value);
+
+	/*
+	*write the port ID:
+	*PORT_ID0 = display index
+	*PORT_ID1 = 16bit BDF
+	*(format MSB->LSB: 8bit Bus, 5bit Device, 3bit Function)
+	*/
+
+	value = 0;
+
+	set_reg_field_value(value, audio_info->port_id[0],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
+		PORT_ID0);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->port_id[1],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
+		PORT_ID1);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3, value);
+
+	/*write the 18 char monitor string */
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[0],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION0);
+
+	set_reg_field_value(value, audio_info->display_name[1],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION1);
+
+	set_reg_field_value(value, audio_info->display_name[2],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION2);
+
+	set_reg_field_value(value, audio_info->display_name[3],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION3);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[4],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION4);
+
+	set_reg_field_value(value, audio_info->display_name[5],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION5);
+
+	set_reg_field_value(value, audio_info->display_name[6],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION6);
+
+	set_reg_field_value(value, audio_info->display_name[7],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION7);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[8],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION8);
+
+	set_reg_field_value(value, audio_info->display_name[9],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION9);
+
+	set_reg_field_value(value, audio_info->display_name[10],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION10);
+
+	set_reg_field_value(value, audio_info->display_name[11],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION11);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[12],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION12);
+
+	set_reg_field_value(value, audio_info->display_name[13],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION13);
+
+	set_reg_field_value(value, audio_info->display_name[14],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION14);
+
+	set_reg_field_value(value, audio_info->display_name[15],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION15);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[16],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
+		DESCRIPTION16);
+
+	set_reg_field_value(value, audio_info->display_name[17],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
+		DESCRIPTION17);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8, value);
 }
 
 /**
@@ -180,8 +761,7 @@ static enum audio_result disable_output(
 *  initialization. this function is called at dal_audio_power_up.
 *
 */
-static enum audio_result initialize(
-	struct audio *audio)
+static enum audio_result initialize(struct audio *audio)
 {
 	uint8_t audio_endpoint_enum_id = 0;
 
@@ -223,10 +803,11 @@ static void setup_audio_wall_dto(
 
 static const struct audio_funcs funcs = {
 	.destroy = destroy,
-	.setup = setup,
-	.disable_output = disable_output,
 	.initialize = initialize,
 	.setup_audio_wall_dto = setup_audio_wall_dto,
+	.az_enable = dce110_aud_az_enable,
+	.az_disable = dce110_aud_az_disable,
+	.az_configure = dce110_aud_az_configure,
 };
 
 static bool construct(
@@ -256,6 +837,9 @@ struct audio *dal_audio_create_dce110(
 		ASSERT_CRITICAL(audio);
 		return NULL;
 	}
+
+	audio->regs = init_data->reg;
+
 	/*pointer to base_audio_block of audio_dce110 ==> audio base object */
 	if (construct(audio, init_data))
 		return &audio->base;
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
index efd441e..ac79932 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
@@ -29,12 +29,36 @@
 #include "audio/hw_ctx_audio.h"
 #include "audio/dce110/hw_ctx_audio_dce110.h"
 
+#define AUD_REG(reg_name, block_prefix, id)\
+	.reg_name = block_prefix ## id ## _ ## reg_name\
+
+#define AUD_COMMON_REG_LIST(id)\
+	SE_REG(AZALIA_F0_CODEC_ENDPOINT_INDEX, mmAZF0ENDPOINT, id),\
+	SE_REG(AZALIA_F0_CODEC_ENDPOINT_DATA, mmAZF0ENDPOINT, id),\
+	.AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
+
+struct dce110_audio_registers {
+	uint32_t AZALIA_F0_CODEC_ENDPOINT_INDEX;
+	uint32_t AZALIA_F0_CODEC_ENDPOINT_DATA;
+
+	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS;
+};
+
 struct audio_dce110 {
 	struct audio base;
+	const struct dce110_audio_registers *regs;
 	/* dce-specific members are following */
 	/* none */
 };
 
 struct audio *dal_audio_create_dce110(const struct audio_init_data *init_data);
 
+void dce110_aud_az_enable(struct audio *audio);
+void dce110_aud_az_disable(struct audio *audio);
+
+void dce110_aud_az_configure(struct audio *audio,
+	enum signal_type signal,
+	const struct audio_crtc_info *crtc_info,
+	const struct audio_info *audio_info);
+
 #endif   /*__DAL_AUDIO_DCE_110_H__*/
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
index 0241779..56aea6f 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
@@ -48,14 +48,6 @@
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_AUDIO, \
 			"Audio:%s()\n", __func__)
 
-static const uint32_t engine_offset[] = {
-	0,
-	mmDIG1_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG2_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG3_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG4_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG5_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL
-};
 
 static void destroy(
 	struct hw_ctx_audio **ptr)
@@ -71,257 +63,6 @@ static void destroy(
 	*ptr = NULL;
 }
 
-/* ---  helpers --- */
-static void write_indirect_azalia_reg(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t reg_index,
-	uint32_t reg_data)
-{
-	uint32_t addr = 0;
-	uint32_t value = 0;
-	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index;
-
-		set_reg_field_value(value, reg_index,
-			AZALIA_F0_CODEC_ENDPOINT_INDEX,
-			AZALIA_ENDPOINT_REG_INDEX);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data;
-
-		value = 0;
-		set_reg_field_value(value, reg_data,
-			AZALIA_F0_CODEC_ENDPOINT_DATA,
-			AZALIA_ENDPOINT_REG_DATA);
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	dal_logger_write(
-		hw_ctx->ctx->logger,
-		LOG_MAJOR_HW_TRACE,
-		LOG_MINOR_HW_TRACE_AUDIO,
-		"AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
-		reg_index, reg_data);
-}
-
-static uint32_t read_indirect_azalia_reg(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t reg_index)
-{
-	uint32_t ret_val = 0;
-	uint32_t addr = 0;
-	uint32_t value = 0;
-
-	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index;
-
-		set_reg_field_value(value, reg_index,
-			AZALIA_F0_CODEC_ENDPOINT_INDEX,
-			AZALIA_ENDPOINT_REG_INDEX);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data;
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		ret_val = value;
-	}
-
-	dal_logger_write(
-		hw_ctx->ctx->logger,
-		LOG_MAJOR_HW_TRACE,
-		LOG_MINOR_HW_TRACE_AUDIO,
-		"AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
-		reg_index, ret_val);
-
-	return ret_val;
-}
-
-/* expose/not expose HBR capability to Audio driver */
-static void set_high_bit_rate_capable(
-	const struct hw_ctx_audio *hw_ctx,
-	bool capable)
-{
-	uint32_t value = 0;
-
-	/* set high bit rate audio capable*/
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR);
-
-	set_reg_field_value(value, capable,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
-		HBR_CAPABLE);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
-		value);
-}
-
-/* set HBR channnel count *
-static void set_hbr_channel_count(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t hbr_channel_count)
-{
-	uint32_t value = 0;
-
-	if (hbr_channel_count > 7)
-		return;
-
-	value = dal_read_reg(hw_ctx->ctx,
-		mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL);
-
-	set_reg_field_value(value, hbr_channel_count,
-		AZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL,
-		HBR_CHANNEL_COUNT);
-
-	dal_write_reg(hw_ctx->ctx,
-		mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL, value);
-
-}
-
-*set compressed audio channel count *
-static void set_compressed_audio_channel_count(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t compressed_audio_ch_count)
-{
-	uint32_t value = 0;
-	if (compressed_audio_ch_count > 7)
-		return;
-
-	value = dal_read_reg(hw_ctx->ctx,
-		mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL);
-
-	set_reg_field_value(value, compressed_audio_ch_count,
-		AZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL,
-		COMPRESSED_CHANNEL_COUNT);
-
-	dal_write_reg(hw_ctx->ctx,
-		mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL,
-		value);
-
-}
-*/
-/* set video latency in in ms/2+1 */
-static void set_video_latency(
-	const struct hw_ctx_audio *hw_ctx,
-	int latency_in_ms)
-{
-	uint32_t value = 0;
-
-	if ((latency_in_ms < 0) || (latency_in_ms > 255))
-		return;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
-
-	set_reg_field_value(value, latency_in_ms,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		VIDEO_LIPSYNC);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		value);
-
-}
-
-/* set audio latency in in ms/2+1 */
-static void set_audio_latency(
-	const struct hw_ctx_audio *hw_ctx,
-	int latency_in_ms)
-{
-	uint32_t value = 0;
-
-	if (latency_in_ms < 0)
-		latency_in_ms = 0;
-
-	if (latency_in_ms > 255)
-		latency_in_ms = 255;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
-
-	set_reg_field_value(value, latency_in_ms,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		AUDIO_LIPSYNC);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		value);
-
-}
-
-/* enable HW/SW Sync */
-/*static void enable_hw_sw_sync(
-	const struct hw_ctx_audio *hw_ctx)
-{
-		union AZALIA_CYCLIC_BUFFER_SYNC value;
-
-	value = dal_read_reg(mmAZALIA_CYCLIC_BUFFER_SYNC);
-	value.bits.CYCLIC_BUFFER_SYNC_ENABLE = 1;
-	dal_write_reg(mmAZALIA_CYCLIC_BUFFER_SYNC, value);
-}*/
-
-/* disable HW/SW Sync */
-/*static void disable_hw_sw_sync(
-	const struct hw_ctx_audio *hw_ctx)
-{
-	union AZALIA_CYCLIC_BUFFER_SYNC value;
-
-	value = dal_read_reg(
-		mmAZALIA_CYCLIC_BUFFER_SYNC);
-	value.bits.CYCLIC_BUFFER_SYNC_ENABLE = 0;
-	dal_write_reg(
-		mmAZALIA_CYCLIC_BUFFER_SYNC, value);
-}*/
-
-/* update hardware with software's current position in cyclic buffer */
-/*static void update_sw_write_ptr(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t offset)
-{
-		union AZALIA_APPLICATION_POSITION_IN_CYCLIC_BUFFER value;
-
-	value = dal_read_reg(
-		mmAZALIA_APPLICATION_POSITION_IN_CYCLIC_BUFFER);
-	value.bits.APPLICATION_POSITION_IN_CYCLIC_BUFFER = offset;
-	dal_write_reg(
-		mmAZALIA_APPLICATION_POSITION_IN_CYCLIC_BUFFER,
-		value);
-}*/
-
-/* update Audio/Video association */
-/*static void update_av_association(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	enum signal_type signal,
-	uint32_t displayId)
-{
-
-}*/
-
 /* ---  hook functions --- */
 static bool get_azalia_clock_info_hdmi(
 	const struct hw_ctx_audio *hw_ctx,
@@ -486,930 +227,6 @@ static void setup_audio_wall_dto(
 	}
 }
 
-/* setup HDMI audio */
-static void setup_hdmi_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	const struct audio_crtc_info *crtc_info)
-{
-	struct audio_clock_info audio_clock_info = {0};
-	uint32_t max_packets_per_line;
-	uint32_t addr = 0;
-	uint32_t value = 0;
-
-	/* For now still do calculation, although this field is ignored when
-	above HDMI_PACKET_GEN_VERSION set to 1 */
-	max_packets_per_line =
-		dal_audio_hw_ctx_calc_max_audio_packets_per_line(
-			hw_ctx,
-			crtc_info);
-
-	/* HDMI_AUDIO_PACKET_CONTROL */
-	{
-		addr =
-			mmHDMI_AUDIO_PACKET_CONTROL + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, max_packets_per_line,
-			HDMI_AUDIO_PACKET_CONTROL,
-			HDMI_AUDIO_PACKETS_PER_LINE);
-		/* still apply RS600's default setting which is 1. */
-		set_reg_field_value(value, 1,
-			HDMI_AUDIO_PACKET_CONTROL,
-			HDMI_AUDIO_DELAY_EN);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AFMT_AUDIO_PACKET_CONTROL */
-	{
-		addr = mmAFMT_AUDIO_PACKET_CONTROL + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 1,
-			AFMT_AUDIO_PACKET_CONTROL,
-			AFMT_60958_CS_UPDATE);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AFMT_AUDIO_PACKET_CONTROL2 */
-	{
-		addr = mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 0,
-				AFMT_AUDIO_PACKET_CONTROL2,
-				AFMT_AUDIO_LAYOUT_OVRD);
-
-		/*Register field changed.*/
-		set_reg_field_value(value, 0,
-			AFMT_AUDIO_PACKET_CONTROL2,
-			AFMT_60958_OSF_OVRD);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* HDMI_ACR_PACKET_CONTROL */
-	{
-		addr = mmHDMI_ACR_PACKET_CONTROL + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 1,
-			HDMI_ACR_PACKET_CONTROL,
-			HDMI_ACR_AUTO_SEND);
-
-		/* Set HDMI_ACR_SOURCE to 0, to use hardwre
-		 *  computed CTS values.*/
-		set_reg_field_value(value, 0,
-			HDMI_ACR_PACKET_CONTROL,
-			HDMI_ACR_SOURCE);
-
-		/* For now clear HDMI_ACR_AUDIO_PRIORITY =>ACR packet has
-		higher priority over Audio Sample */
-		set_reg_field_value(value, 0,
-			HDMI_ACR_PACKET_CONTROL,
-			HDMI_ACR_AUDIO_PRIORITY);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* Program audio clock sample/regeneration parameters */
-	if (dal_audio_hw_ctx_get_audio_clock_info(
-		hw_ctx,
-		crtc_info->color_depth,
-		crtc_info->requested_pixel_clock,
-		crtc_info->calculated_pixel_clock,
-		&audio_clock_info)) {
-
-		/* HDMI_ACR_32_0__HDMI_ACR_CTS_32_MASK */
-		{
-			addr = mmHDMI_ACR_32_0 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-
-			set_reg_field_value(value, audio_clock_info.cts_32khz,
-				HDMI_ACR_32_0,
-				HDMI_ACR_CTS_32);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_32_1__HDMI_ACR_N_32_MASK */
-		{
-			addr = mmHDMI_ACR_32_1 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.n_32khz,
-				HDMI_ACR_32_1,
-				HDMI_ACR_N_32);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_44_0__HDMI_ACR_CTS_44_MASK */
-		{
-			addr = mmHDMI_ACR_44_0 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.cts_44khz,
-				HDMI_ACR_44_0,
-				HDMI_ACR_CTS_44);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_44_1__HDMI_ACR_N_44_MASK */
-		{
-			addr = mmHDMI_ACR_44_1 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.n_44khz,
-				HDMI_ACR_44_1,
-				HDMI_ACR_N_44);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_48_0__HDMI_ACR_CTS_48_MASK */
-		{
-			addr = mmHDMI_ACR_48_0 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.cts_48khz,
-				HDMI_ACR_48_0,
-				HDMI_ACR_CTS_48);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_48_1__HDMI_ACR_N_48_MASK */
-		{
-			addr = mmHDMI_ACR_48_1 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.n_48khz,
-				HDMI_ACR_48_1,
-				HDMI_ACR_N_48);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* Video driver cannot know in advance which sample rate will
-		be used by HD Audio driver
-		HDMI_ACR_PACKET_CONTROL__HDMI_ACR_N_MULTIPLE field is
-		programmed below in interruppt callback */
-	} /* if */
-
-	/* AFMT_60958_0__AFMT_60958_CS_CHANNEL_NUMBER_L_MASK &
-	AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY_MASK */
-	{
-		addr = mmAFMT_60958_0 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 1,
-			AFMT_60958_0,
-			AFMT_60958_CS_CHANNEL_NUMBER_L);
-
-		 /*HW default */
-		set_reg_field_value(value, 0,
-			AFMT_60958_0,
-			AFMT_60958_CS_CLOCK_ACCURACY);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AFMT_60958_1 AFMT_60958_CS_CHALNNEL_NUMBER_R */
-	{
-		addr = mmAFMT_60958_1 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 2,
-			AFMT_60958_1,
-			AFMT_60958_CS_CHANNEL_NUMBER_R);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/*AFMT_60958_2 now keep this settings until
-	 *  Programming guide comes out*/
-	{
-		addr = mmAFMT_60958_2 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 3,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_2);
-
-		set_reg_field_value(value, 4,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_3);
-
-		set_reg_field_value(value, 5,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_4);
-
-		set_reg_field_value(value, 6,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_5);
-
-		set_reg_field_value(value, 7,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_6);
-
-		set_reg_field_value(value, 8,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_7);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-}
-
-static void enable_afmt_clock(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	bool enable_flag)
-{
-	uint32_t engine_offs = engine_offset[engine_id];
-	uint32_t value;
-	uint32_t count = 0;
-	uint32_t enable = enable_flag ? 1:0;
-
-	/* Enable Audio packets*/
-	value = dm_read_reg(hw_ctx->ctx, mmAFMT_CNTL + engine_offs);
-
-	/*enable AFMT clock*/
-	set_reg_field_value(value, enable,
-		AFMT_CNTL, AFMT_AUDIO_CLOCK_EN);
-	dm_write_reg(hw_ctx->ctx, mmAFMT_CNTL + engine_offs, value);
-
-	/*wait for AFMT clock to turn on,
-	 * the expectation is that this
-	 * should complete in 1-2 reads)
-	 */
-	do {
-		/* Wait for 1us between subsequent register reads.*/
-		udelay(1);
-		value = dm_read_reg(hw_ctx->ctx,
-				mmAFMT_CNTL + engine_offs);
-	} while (get_reg_field_value(value,
-				AFMT_CNTL, AFMT_AUDIO_CLOCK_ON) !=
-						enable && count++ < 10);
-}
-
-/* enable Azalia audio */
-static void enable_azalia_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id)
-{
-	uint32_t value;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-
-	if (get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-			AUDIO_ENABLED) != 1)
-		set_reg_field_value(value, 1,
-			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-			AUDIO_ENABLED);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		value);
-}
-
-/* disable Azalia audio */
-static void disable_azalia_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id)
-{
-	uint32_t value;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-
-	set_reg_field_value(value, 0,
-		AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		AUDIO_ENABLED);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		value);
-}
-
-/* disable DP audio */
-static void disable_dp_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id)
-{
-	const uint32_t addr = mmDP_SEC_CNTL + engine_offset[engine_id];
-
-	uint32_t value;
-
-	/* Disable Audio packets */
-	value = dm_read_reg(hw_ctx->ctx, addr);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_ASP_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_ATP_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_AIP_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_ACM_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_STREAM_ENABLE);
-
-	/* This register shared with encoder info frame. Therefore we need to
-	keep master enabled if at least on of the fields is not 0 */
-	if (value != 0)
-		set_reg_field_value(value, 1,
-			DP_SEC_CNTL,
-			DP_SEC_STREAM_ENABLE);
-
-	dm_write_reg(hw_ctx->ctx, addr, value);
-}
-
-static void configure_azalia(
-	const struct hw_ctx_audio *hw_ctx,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_info *audio_info)
-{
-	uint32_t speakers = audio_info->flags.info.ALLSPEAKERS;
-	uint32_t value;
-	uint32_t field = 0;
-	enum audio_format_code audio_format_code;
-	uint32_t format_index;
-	uint32_t index;
-	bool is_ac3_supported = false;
-	bool is_audio_format_supported = false;
-	union audio_sample_rates sample_rate;
-	uint32_t strlen = 0;
-
-	/* Speaker Allocation */
-	/*
-	uint32_t value;
-	uint32_t field = 0;*/
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);
-
-	set_reg_field_value(value,
-		speakers,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		SPEAKER_ALLOCATION);
-
-	/* LFE_PLAYBACK_LEVEL = LFEPBL
-	 * LFEPBL = 0 : Unknown or refer to other information
-	 * LFEPBL = 1 : 0dB playback
-	 * LFEPBL = 2 : +10dB playback
-	 * LFE_BL = 3 : Reserved
-	 */
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		LFE_PLAYBACK_LEVEL);
-
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		HDMI_CONNECTION);
-
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		DP_CONNECTION);
-
-	field = get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			EXTRA_CONNECTION_INFO);
-
-	field &= ~0x1;
-
-	set_reg_field_value(value,
-		field,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		EXTRA_CONNECTION_INFO);
-
-	/* set audio for output signal */
-	switch (signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			HDMI_CONNECTION);
-
-		break;
-	case SIGNAL_TYPE_WIRELESS: {
-		/*LSB used for "is wireless" flag */
-		field = 0;
-		field = get_reg_field_value(value,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		EXTRA_CONNECTION_INFO);
-		field |= 0x1;
-		set_reg_field_value(value,
-			field,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			EXTRA_CONNECTION_INFO);
-
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			HDMI_CONNECTION);
-
-		}
-		break;
-	case SIGNAL_TYPE_EDP:
-	case SIGNAL_TYPE_DISPLAY_PORT:
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			DP_CONNECTION);
-
-		break;
-	default:
-		break;
-	}
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		value);
-
-	/* Wireless Display identification */
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_WIRELESS_DISPLAY_IDENTIFICATION);
-
-	set_reg_field_value(value,
-		signal == SIGNAL_TYPE_WIRELESS ? 1 : 0,
-		AZALIA_F0_CODEC_PIN_CONTROL_WIRELESS_DISPLAY_IDENTIFICATION,
-		WIRELESS_DISPLAY_IDENTIFICATION);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_WIRELESS_DISPLAY_IDENTIFICATION,
-		value);
-
-	/*  Audio Descriptors   */
-	/* pass through all formats */
-	for (format_index = 0; format_index < AUDIO_FORMAT_CODE_COUNT;
-			format_index++) {
-		audio_format_code =
-			(AUDIO_FORMAT_CODE_FIRST + format_index);
-
-		/* those are unsupported, skip programming */
-		if (audio_format_code == AUDIO_FORMAT_CODE_1BITAUDIO ||
-			audio_format_code == AUDIO_FORMAT_CODE_DST)
-			continue;
-
-		value = 0;
-
-		/* check if supported */
-		is_audio_format_supported =
-			dal_audio_hw_ctx_is_audio_format_supported(
-				hw_ctx,
-				audio_info,
-				audio_format_code, &index);
-
-		if (is_audio_format_supported) {
-			const struct audio_mode *audio_mode =
-					&audio_info->modes[index];
-			union audio_sample_rates sample_rates =
-					audio_mode->sample_rates;
-			uint8_t byte2 = audio_mode->max_bit_rate;
-
-			/* adjust specific properties */
-			switch (audio_format_code) {
-			case AUDIO_FORMAT_CODE_LINEARPCM: {
-				dal_hw_ctx_audio_check_audio_bandwidth(
-					hw_ctx,
-					crtc_info,
-					audio_mode->channel_count,
-					signal,
-					&sample_rates);
-
-				byte2 = audio_mode->sample_size;
-
-				set_reg_field_value(value,
-				sample_rates.all,
-		AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-				SUPPORTED_FREQUENCIES_STEREO);
-
-				}
-				break;
-			case AUDIO_FORMAT_CODE_AC3:
-				is_ac3_supported = true;
-				break;
-			case AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS:
-			case AUDIO_FORMAT_CODE_DTS_HD:
-			case AUDIO_FORMAT_CODE_MAT_MLP:
-			case AUDIO_FORMAT_CODE_DST:
-			case AUDIO_FORMAT_CODE_WMAPRO:
-				byte2 = audio_mode->vendor_specific;
-				break;
-			default:
-				break;
-			}
-
-			/* fill audio format data */
-			set_reg_field_value(value,
-			audio_mode->channel_count - 1,
-			AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-			MAX_CHANNELS);
-
-			set_reg_field_value(value,
-			sample_rates.all,
-			AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-			SUPPORTED_FREQUENCIES);
-
-			set_reg_field_value(value,
-			byte2,
-			AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-			DESCRIPTOR_BYTE_2);
-
-		} /* if */
-
-		write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0 +
-		format_index,
-		value);
-	} /* for */
-
-	if (is_ac3_supported)
-		dm_write_reg(hw_ctx->ctx,
-		mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
-		0x05);
-
-	/* check for 192khz/8-Ch support for HBR requirements */
-	sample_rate.all = 0;
-	sample_rate.rate.RATE_192 = 1;
-	dal_hw_ctx_audio_check_audio_bandwidth(
-		hw_ctx,
-		crtc_info,
-		8,
-		signal,
-		&sample_rate);
-
-	set_high_bit_rate_capable(hw_ctx, sample_rate.rate.RATE_192);
-
-	/* Audio and Video Lipsync */
-	set_video_latency(hw_ctx, audio_info->video_latency);
-	set_audio_latency(hw_ctx, audio_info->audio_latency);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->manufacture_id,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		MANUFACTURER_ID);
-
-	set_reg_field_value(value, audio_info->product_id,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		PRODUCT_ID);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		value);
-
-	value = 0;
-
-	/*get display name string length */
-	while (audio_info->display_name[strlen++] != '\0') {
-		if (strlen >=
-		MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS)
-			break;
-		}
-	set_reg_field_value(value, strlen,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
-		SINK_DESCRIPTION_LEN);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
-		value);
-
-	/*
-	*write the port ID:
-	*PORT_ID0 = display index
-	*PORT_ID1 = 16bit BDF
-	*(format MSB->LSB: 8bit Bus, 5bit Device, 3bit Function)
-	*/
-
-	value = 0;
-
-	set_reg_field_value(value, audio_info->port_id[0],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
-		PORT_ID0);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->port_id[1],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
-		PORT_ID1);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
-		value);
-
-	/*write the 18 char monitor string */
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[0],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION0);
-
-	set_reg_field_value(value, audio_info->display_name[1],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION1);
-
-	set_reg_field_value(value, audio_info->display_name[2],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION2);
-
-	set_reg_field_value(value, audio_info->display_name[3],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION3);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[4],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION4);
-
-	set_reg_field_value(value, audio_info->display_name[5],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION5);
-
-	set_reg_field_value(value, audio_info->display_name[6],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION6);
-
-	set_reg_field_value(value, audio_info->display_name[7],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION7);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[8],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION8);
-
-	set_reg_field_value(value, audio_info->display_name[9],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION9);
-
-	set_reg_field_value(value, audio_info->display_name[10],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION10);
-
-	set_reg_field_value(value, audio_info->display_name[11],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION11);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[12],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION12);
-
-	set_reg_field_value(value, audio_info->display_name[13],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION13);
-
-	set_reg_field_value(value, audio_info->display_name[14],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION14);
-
-	set_reg_field_value(value, audio_info->display_name[15],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION15);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[16],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		DESCRIPTION16);
-
-	set_reg_field_value(value, audio_info->display_name[17],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		DESCRIPTION17);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		value);
-
-}
-
-/* setup Azalia HW block */
-static void setup_azalia(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_pll_info *pll_info,
-	const struct audio_info *audio_info)
-{
-	uint32_t speakers = 0;
-	uint32_t channels = 0;
-
-	if (audio_info == NULL)
-		/* This should not happen.it does so we don't get BSOD*/
-		return;
-
-	speakers = audio_info->flags.info.ALLSPEAKERS;
-	channels = dal_audio_hw_ctx_speakers_to_channels(
-		hw_ctx,
-		audio_info->flags.speaker_flags).all;
-
-	/* setup the audio stream source select (audio -> dig mapping) */
-	{
-		const uint32_t addr =
-			mmAFMT_AUDIO_SRC_CONTROL + engine_offset[engine_id];
-
-		uint32_t value = 0;
-		/*convert one-based index to zero-based */
-		set_reg_field_value(value,
-			FROM_BASE(hw_ctx)->azalia_stream_id - 1,
-			AFMT_AUDIO_SRC_CONTROL,
-			AFMT_AUDIO_SRC_SELECT);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* Channel allocation */
-	{
-		const uint32_t addr =
-			mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
-		uint32_t value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value,
-			channels,
-			AFMT_AUDIO_PACKET_CONTROL2,
-			AFMT_AUDIO_CHANNEL_ENABLE);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	configure_azalia(hw_ctx, signal, crtc_info, audio_info);
-}
-
-/* enable channel splitting mapping */
-static void setup_channel_splitting_mapping(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	enum signal_type signal,
-	const struct audio_channel_associate_info *audio_mapping,
-	bool enable)
-{
-	uint32_t value = 0;
-
-	if ((audio_mapping == NULL || audio_mapping->u32all == 0) && enable)
-		return;
-
-	value = audio_mapping->u32all;
-
-	if (enable == false)
-		/*0xFFFFFFFF;*/
-		value = MULTI_CHANNEL_SPLIT_NO_ASSO_INFO;
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_ASSOCIATION_INFO,
-		value);
-}
-
-/* get current channel spliting */
-static bool get_channel_splitting_mapping(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	struct audio_channel_associate_info *audio_mapping)
-{
-	uint32_t value = 0;
-
-	if (audio_mapping == NULL)
-		return false;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_ASSOCIATION_INFO);
-
-	/*0xFFFFFFFF*/
-	if (get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_ASSOCIATION_INFO,
-			ASSOCIATION_INFO) !=
-			MULTI_CHANNEL_SPLIT_NO_ASSO_INFO) {
-		uint32_t multi_channel01_enable = 0;
-		uint32_t multi_channel23_enable = 0;
-		uint32_t multi_channel45_enable = 0;
-		uint32_t multi_channel67_enable = 0;
-		/* get the one we set.*/
-		audio_mapping->u32all = value;
-
-		/* check each enable status*/
-		value = read_indirect_azalia_reg(
-			hw_ctx,
-			ixAZALIA_F0_CODEC_PIN_CONTROL_MULTICHANNEL_ENABLE);
-
-		multi_channel01_enable = get_reg_field_value(value,
-		AZALIA_F0_CODEC_PIN_CONTROL_MULTICHANNEL_ENABLE,
-		MULTICHANNEL01_ENABLE);
-
-		multi_channel23_enable = get_reg_field_value(value,
-		AZALIA_F0_CODEC_PIN_CONTROL_MULTICHANNEL_ENABLE,
-		MULTICHANNEL23_ENABLE);
-
-		multi_channel45_enable = get_reg_field_value(value,
-		AZALIA_F0_CODEC_PIN_CONTROL_MULTICHANNEL_ENABLE,
-		MULTICHANNEL45_ENABLE);
-
-		multi_channel67_enable = get_reg_field_value(value,
-		AZALIA_F0_CODEC_PIN_CONTROL_MULTICHANNEL_ENABLE,
-		MULTICHANNEL67_ENABLE);
-
-		if (multi_channel01_enable == 0 &&
-			multi_channel23_enable == 0 &&
-			multi_channel45_enable == 0 &&
-			multi_channel67_enable == 0)
-			dal_logger_write(hw_ctx->ctx->logger,
-				LOG_MAJOR_HW_TRACE,
-				LOG_MINOR_COMPONENT_AUDIO,
-				"Audio driver did not enable multi-channel\n");
-
-		return true;
-	}
-
-	return false;
-}
-
-/* set the payload value for the unsolicited response */
-static void set_unsolicited_response_payload(
-	const struct hw_ctx_audio *hw_ctx,
-	enum audio_payload payload)
-{
-	/* set the payload value for the unsolicited response
-	 Jack presence is not required to be enabled */
-	uint32_t value = 0;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_UNSOLICITED_RESPONSE_FORCE);
-
-	set_reg_field_value(value, payload,
-		AZALIA_F0_CODEC_PIN_CONTROL_UNSOLICITED_RESPONSE_FORCE,
-		UNSOLICITED_RESPONSE_PAYLOAD);
-
-	set_reg_field_value(value, 1,
-		AZALIA_F0_CODEC_PIN_CONTROL_UNSOLICITED_RESPONSE_FORCE,
-		UNSOLICITED_RESPONSE_FORCE);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_UNSOLICITED_RESPONSE_FORCE,
-		value);
-}
-
 /* initialize HW state */
 static void hw_initialize(
 	const struct hw_ctx_audio *hw_ctx)
@@ -1511,23 +328,12 @@ static const struct hw_ctx_audio_funcs funcs = {
 	.destroy = destroy,
 	.setup_audio_wall_dto =
 		setup_audio_wall_dto,
-	.setup_hdmi_audio =
-		setup_hdmi_audio,
-	.enable_azalia_audio =
-		enable_azalia_audio,
-	.disable_azalia_audio =
-		disable_azalia_audio,
-	.disable_dp_audio =
-		disable_dp_audio,
-	.setup_azalia =
-		setup_azalia,
 	.hw_initialize =
 		hw_initialize,
 	.get_azalia_clock_info_hdmi =
 		get_azalia_clock_info_hdmi,
 	.get_azalia_clock_info_dp =
 		get_azalia_clock_info_dp,
-	.enable_afmt_clock = enable_afmt_clock
 };
 
 static bool construct(
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
index 89f8cd7..d3116c4 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
@@ -28,10 +28,11 @@
 #include "include/logger_interface.h"
 
 #include "audio_dce80.h"
+#include "../dce110/audio_dce110.h"
 
 /***** static functions  *****/
 
-static void destruct(struct audio_dce80 *audio)
+static void destruct(struct audio_dce110 *audio)
 {
 	/*release memory allocated for hw_ctx -- allocated is initiated
 	 *by audio_dce80 power_up
@@ -46,105 +47,17 @@ static void destruct(struct audio_dce80 *audio)
 
 static void destroy(struct audio **ptr)
 {
-	struct audio_dce80 *audio = NULL;
+	struct audio_dce110 *audio = NULL;
 
-	audio = container_of(*ptr, struct audio_dce80, base);
+	audio = container_of(*ptr, struct audio_dce110, base);
 
 	destruct(audio);
 
-	/* release memory allocated for audio_dce80*/
+	/* release memory allocated for audio_dce110*/
 	dm_free(audio);
 	*ptr = NULL;
 }
 
-/* The inital call of hook function comes from audio object level.
- *The passing object handle "struct audio *audio" point to base object
- *already.There is not need to get base object from audio_dce80.
- */
-
-/**
-* Setup
-*
-* @brief
-*  setup Audio HW block, to be called by dal_audio_setup
-*
-* @param
-*  engine_id         - HDMI engine id
-*  pTiming          - CRTC timing
-*  actualPixelClock - actual programmed pixel clock
-*/
-static enum audio_result setup(
-	struct audio *audio,
-	struct audio_output *output,
-	struct audio_info *info)
-{
-	switch (output->signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-	case SIGNAL_TYPE_WIRELESS:
-		/* setup HDMI audio engine */
-		audio->hw_ctx->funcs->setup_hdmi_audio(
-			audio->hw_ctx, output->engine_id, &output->crtc_info);
-		break;
-	case SIGNAL_TYPE_DISPLAY_PORT:
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-	case SIGNAL_TYPE_EDP:
-		/* setup DP audio engine will be done at enable output */
-		break;
-	default:
-		return AUDIO_RESULT_ERROR;
-	}
-
-	/* setup Azalia block */
-	audio->hw_ctx->funcs->setup_azalia(
-		audio->hw_ctx,
-		output->engine_id,
-		output->signal,
-		&output->crtc_info,
-		&output->pll_info,
-		info);
-
-	return AUDIO_RESULT_OK;
-}
-
-/**
-* disable_output
-*
-* @brief
-*  disable Audio HW block, to be called by dal_audio_disable_output
-*
-* @param
-*  engine_id         - HDMI engine id
-*/
-static enum audio_result disable_output(
-	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal)
-{
-	switch (signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-	case SIGNAL_TYPE_WIRELESS:
-		/* disable HDMI audio */
-		audio->hw_ctx->
-			funcs->disable_azalia_audio(
-					audio->hw_ctx, engine_id);
-		break;
-	case SIGNAL_TYPE_DISPLAY_PORT:
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-	case SIGNAL_TYPE_EDP: {
-			/* disable DP audio */
-			audio->hw_ctx->funcs->disable_dp_audio(
-				audio->hw_ctx, engine_id);
-			audio->hw_ctx->funcs->disable_azalia_audio(
-				audio->hw_ctx, engine_id);
-		}
-		break;
-	default:
-		return AUDIO_RESULT_ERROR;
-	}
-
-	return AUDIO_RESULT_OK;
-}
-
 /**
 * initialize
 *
@@ -202,14 +115,15 @@ static void setup_audio_wall_dto(
 
 static const struct audio_funcs funcs = {
 	.destroy = destroy,
-	.setup = setup,
-	.disable_output = disable_output,
 	.initialize = initialize,
 	.setup_audio_wall_dto = setup_audio_wall_dto,
+	.az_enable = dce110_aud_az_enable,
+	.az_disable = dce110_aud_az_disable,
+	.az_configure = dce110_aud_az_configure,
 };
 
 static bool construct(
-	struct audio_dce80 *audio,
+	struct audio_dce110 *audio,
 	const struct audio_init_data *init_data)
 {
 	struct audio *base = &audio->base;
@@ -228,13 +142,15 @@ static bool construct(
 struct audio *dal_audio_create_dce80(
 	const struct audio_init_data *init_data)
 {
-	/*allocate memory for audio_dce80 */
-	struct audio_dce80 *audio = dm_alloc(sizeof(struct audio_dce80));
+	/*allocate memory for audio_dce110 */
+	struct audio_dce110 *audio = dm_alloc(sizeof(struct audio_dce110));
 
 	if (audio == NULL)
 		return NULL;
 
-	/*pointer to base_audio_block of audio_dce80 ==> audio base object */
+	audio->regs = init_data->reg;
+
+	/*pointer to base_audio_block of audio_dce110 ==> audio base object */
 	if (construct(audio, init_data))
 		return &audio->base;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
index 4779fac..9ecd076 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
@@ -29,12 +29,6 @@
 #include "audio/hw_ctx_audio.h"
 #include "audio/dce80/hw_ctx_audio_dce80.h"
 
-struct audio_dce80 {
-	struct audio base;
-	/* dce-specific members are following */
-	/* none */
-};
-
 struct audio *dal_audio_create_dce80(const struct audio_init_data *init_data);
 
 #endif   /* __DAL_AUDIO_80__  */
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
index c3d0736..cc3ec16 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
@@ -44,15 +44,6 @@
 
 #define FIRST_AUDIO_STREAM_ID 1
 
-static const uint32_t engine_offset[] = {
-	0,
-	mmDIG1_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG2_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG3_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG4_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG5_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL,
-	mmDIG6_DIG_FE_CNTL - mmDIG0_DIG_FE_CNTL
-};
 /* --- static functions --- */
 
 /* static void dal_audio_destruct_hw_ctx_audio_dce80(
@@ -72,252 +63,6 @@ static void destroy(
 	*ptr = NULL;
 }
 
-/* ---  helpers --- */
-
-static void write_indirect_azalia_reg(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t reg_index,
-	uint32_t reg_data)
-{
-	uint32_t addr = 0;
-	uint32_t value = 0;
-	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index;
-
-		set_reg_field_value(value, reg_index,
-			AZALIA_F0_CODEC_ENDPOINT_INDEX,
-			AZALIA_ENDPOINT_REG_INDEX);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data;
-
-		value = 0;
-		set_reg_field_value(value, reg_data,
-			AZALIA_F0_CODEC_ENDPOINT_DATA,
-			AZALIA_ENDPOINT_REG_DATA);
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	dal_logger_write(
-		hw_ctx->ctx->logger,
-		LOG_MAJOR_HW_TRACE,
-		LOG_MINOR_HW_TRACE_AUDIO,
-		"AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
-		reg_index, reg_data);
-}
-
-static uint32_t read_indirect_azalia_reg(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t reg_index)
-{
-	uint32_t ret_val = 0;
-	uint32_t addr = 0;
-	uint32_t value = 0;
-
-	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index;
-
-		set_reg_field_value(value, reg_index,
-			AZALIA_F0_CODEC_ENDPOINT_INDEX,
-			AZALIA_ENDPOINT_REG_INDEX);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
-	{
-		addr =
-			FROM_BASE(hw_ctx)->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data;
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		ret_val = value;
-	}
-
-	dal_logger_write(
-		hw_ctx->ctx->logger,
-		LOG_MAJOR_HW_TRACE,
-		LOG_MINOR_HW_TRACE_AUDIO,
-		"AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
-		reg_index, ret_val);
-
-	return ret_val;
-}
-
-/* expose/not expose HBR capability to Audio driver */
-static void set_high_bit_rate_capable(
-	const struct hw_ctx_audio *hw_ctx,
-	bool capable)
-{
-	uint32_t value = 0;
-
-	/* set high bit rate audio capable*/
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR);
-
-	set_reg_field_value(value, capable,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
-		HBR_CAPABLE);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
-		value);
-}
-
-/* set HBR channnel count */
-/*static void set_hbr_channel_count(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t hbr_channel_count)
-{
-	if (hbr_channel_count > 7)
-		return;
-
-	{
-		union AZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL value;
-
-		value.u32All = dal_read_reg(
-			mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL);
-		value.bits.HBR_CHANNEL_COUNT = hbr_channel_count;
-		dal_write_reg(
-			mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL, value.u32All);
-	}
-}*/
-
-/* set compressed audio channel cound */
-/*static void set_compressed_audio_channel_count(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t compressed_audio_ch_count)
-{
-	if (compressed_audio_ch_count > 7)
-		return;
-
-	{
-		union AZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL value;
-
-		value.u32All = dal_read_reg(
-			mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL);
-		value.bits.COMPRESSED_CHANNEL_COUNT =
-			compressed_audio_ch_count;
-		dal_write_reg(
-			mmAZALIA_F0_CODEC_CHANNEL_COUNT_CONTROL,
-			value.u32All);
-	}
-}*/
-
-/* set video latency in in ms/2+1 */
-static void set_video_latency(
-	const struct hw_ctx_audio *hw_ctx,
-	int latency_in_ms)
-{
-	uint32_t value = 0;
-
-	if ((latency_in_ms < 0) || (latency_in_ms > 255))
-		return;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
-
-	set_reg_field_value(value, latency_in_ms,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		VIDEO_LIPSYNC);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		value);
-}
-
-/* set audio latency in in ms/2+1 */
-static void set_audio_latency(
-	const struct hw_ctx_audio *hw_ctx,
-	int latency_in_ms)
-{
-	uint32_t value = 0;
-
-	if (latency_in_ms < 0)
-		latency_in_ms = 0;
-
-	if (latency_in_ms > 255)
-		latency_in_ms = 255;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
-
-	set_reg_field_value(value, latency_in_ms,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		AUDIO_LIPSYNC);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		value);
-}
-
-/* enable HW/SW Sync */
-/*static void enable_hw_sw_sync(
-	const struct hw_ctx_audio *hw_ctx)
-{
-		union AZALIA_CYCLIC_BUFFER_SYNC value;
-
-	value.u32All = dal_read_reg(mmAZALIA_CYCLIC_BUFFER_SYNC);
-	value.bits.CYCLIC_BUFFER_SYNC_ENABLE = 1;
-	dal_write_reg(mmAZALIA_CYCLIC_BUFFER_SYNC, value.u32All);
-}*/
-
-/* disable HW/SW Sync */
-/*static void disable_hw_sw_sync(
-	const struct hw_ctx_audio *hw_ctx)
-{
-	union AZALIA_CYCLIC_BUFFER_SYNC value;
-
-	value.u32All = dal_read_reg(
-		mmAZALIA_CYCLIC_BUFFER_SYNC);
-	value.bits.CYCLIC_BUFFER_SYNC_ENABLE = 0;
-	dal_write_reg(
-		mmAZALIA_CYCLIC_BUFFER_SYNC, value.u32All);
-}*/
-
-/* update hardware with software's current position in cyclic buffer */
-/*static void update_sw_write_ptr(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t offset)
-{
-		union AZALIA_APPLICATION_POSITION_IN_CYCLIC_BUFFER value;
-
-	value.u32All = dal_read_reg(
-		mmAZALIA_APPLICATION_POSITION_IN_CYCLIC_BUFFER);
-	value.bits.APPLICATION_POSITION_IN_CYCLIC_BUFFER = offset;
-	dal_write_reg(
-		mmAZALIA_APPLICATION_POSITION_IN_CYCLIC_BUFFER,
-		value.u32All);
-}*/
-
-/* update Audio/Video association */
-/*static void update_av_association(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	enum signal_type signal,
-	uint32_t displayId)
-{
-
-}*/
-
 /* ---  hook functions --- */
 
 static bool get_azalia_clock_info_hdmi(
@@ -482,757 +227,6 @@ static void setup_audio_wall_dto(
 	}
 }
 
-/* setup HDMI audio */
-static void setup_hdmi_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	const struct audio_crtc_info *crtc_info)
-{
-	struct audio_clock_info audio_clock_info = {0};
-	uint32_t max_packets_per_line;
-	uint32_t addr = 0;
-	uint32_t value = 0;
-
-	/* For now still do calculation, although this field is ignored when
-	above HDMI_PACKET_GEN_VERSION set to 1 */
-	max_packets_per_line =
-		dal_audio_hw_ctx_calc_max_audio_packets_per_line(
-			hw_ctx,
-			crtc_info);
-
-	/* HDMI_AUDIO_PACKET_CONTROL */
-	{
-		addr =
-			mmHDMI_AUDIO_PACKET_CONTROL + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, max_packets_per_line,
-			HDMI_AUDIO_PACKET_CONTROL,
-			HDMI_AUDIO_PACKETS_PER_LINE);
-		/* still apply RS600's default setting which is 1. */
-		set_reg_field_value(value, 1,
-			HDMI_AUDIO_PACKET_CONTROL,
-			HDMI_AUDIO_DELAY_EN);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AFMT_AUDIO_PACKET_CONTROL */
-	{
-		addr = mmAFMT_AUDIO_PACKET_CONTROL + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 1,
-			AFMT_AUDIO_PACKET_CONTROL,
-			AFMT_60958_CS_UPDATE);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AFMT_AUDIO_PACKET_CONTROL2 */
-	{
-		addr = mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 0,
-				AFMT_AUDIO_PACKET_CONTROL2,
-				AFMT_AUDIO_LAYOUT_OVRD);
-
-		/*Register field changed.*/
-		set_reg_field_value(value, 0,
-			AFMT_AUDIO_PACKET_CONTROL2,
-			AFMT_60958_OSF_OVRD);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* HDMI_ACR_PACKET_CONTROL */
-	{
-		addr = mmHDMI_ACR_PACKET_CONTROL + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 1,
-			HDMI_ACR_PACKET_CONTROL,
-			HDMI_ACR_AUTO_SEND);
-
-		/* Set HDMI_ACR_SOURCE to 0, to use hardwre
-		 *  computed CTS values.*/
-		set_reg_field_value(value, 0,
-			HDMI_ACR_PACKET_CONTROL,
-			HDMI_ACR_SOURCE);
-
-		/* For now clear HDMI_ACR_AUDIO_PRIORITY =>ACR packet has
-		higher priority over Audio Sample */
-		set_reg_field_value(value, 0,
-			HDMI_ACR_PACKET_CONTROL,
-			HDMI_ACR_AUDIO_PRIORITY);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* Program audio clock sample/regeneration parameters */
-	if (dal_audio_hw_ctx_get_audio_clock_info(
-		hw_ctx,
-		crtc_info->color_depth,
-		crtc_info->requested_pixel_clock,
-		crtc_info->calculated_pixel_clock,
-		&audio_clock_info)) {
-
-		/* HDMI_ACR_32_0__HDMI_ACR_CTS_32_MASK */
-		{
-			addr = mmHDMI_ACR_32_0 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-
-			set_reg_field_value(value, audio_clock_info.cts_32khz,
-				HDMI_ACR_32_0,
-				HDMI_ACR_CTS_32);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_32_1__HDMI_ACR_N_32_MASK */
-		{
-			addr = mmHDMI_ACR_32_1 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.n_32khz,
-				HDMI_ACR_32_1,
-				HDMI_ACR_N_32);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_44_0__HDMI_ACR_CTS_44_MASK */
-		{
-			addr = mmHDMI_ACR_44_0 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.cts_44khz,
-				HDMI_ACR_44_0,
-				HDMI_ACR_CTS_44);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_44_1__HDMI_ACR_N_44_MASK */
-		{
-			addr = mmHDMI_ACR_44_1 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.n_44khz,
-				HDMI_ACR_44_1,
-				HDMI_ACR_N_44);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_48_0__HDMI_ACR_CTS_48_MASK */
-		{
-			addr = mmHDMI_ACR_48_0 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.cts_48khz,
-				HDMI_ACR_48_0,
-				HDMI_ACR_CTS_48);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* HDMI_ACR_48_1__HDMI_ACR_N_48_MASK */
-		{
-			addr = mmHDMI_ACR_48_1 + engine_offset[engine_id];
-
-			value = dm_read_reg(hw_ctx->ctx, addr);
-			set_reg_field_value(value, audio_clock_info.n_48khz,
-				HDMI_ACR_48_1,
-				HDMI_ACR_N_48);
-
-			dm_write_reg(hw_ctx->ctx, addr, value);
-		}
-
-		/* Video driver cannot know in advance which sample rate will
-		be used by HD Audio driver
-		HDMI_ACR_PACKET_CONTROL__HDMI_ACR_N_MULTIPLE field is
-		programmed below in interruppt callback */
-	} /* if */
-
-	/* AFMT_60958_0__AFMT_60958_CS_CHANNEL_NUMBER_L_MASK &
-	AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY_MASK */
-	{
-		addr = mmAFMT_60958_0 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 1,
-			AFMT_60958_0,
-			AFMT_60958_CS_CHANNEL_NUMBER_L);
-
-		 /*HW default */
-		set_reg_field_value(value, 0,
-			AFMT_60958_0,
-			AFMT_60958_CS_CLOCK_ACCURACY);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* AFMT_60958_1 AFMT_60958_CS_CHALNNEL_NUMBER_R */
-	{
-		addr = mmAFMT_60958_1 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 2,
-			AFMT_60958_1,
-			AFMT_60958_CS_CHANNEL_NUMBER_R);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/*AFMT_60958_2 now keep this settings until
-	 *  Programming guide comes out*/
-	{
-		addr = mmAFMT_60958_2 + engine_offset[engine_id];
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-		set_reg_field_value(value, 3,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_2);
-
-		set_reg_field_value(value, 4,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_3);
-
-		set_reg_field_value(value, 5,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_4);
-
-		set_reg_field_value(value, 6,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_5);
-
-		set_reg_field_value(value, 7,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_6);
-
-		set_reg_field_value(value, 8,
-			AFMT_60958_2,
-			AFMT_60958_CS_CHANNEL_NUMBER_7);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-}
-
-/* enable Azalia audio */
-static void enable_azalia_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id)
-{
-	uint32_t value;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-
-	if (get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-			AUDIO_ENABLED) != 1)
-		set_reg_field_value(value, 1,
-			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-			AUDIO_ENABLED);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		value);
-}
-
-/* disable Azalia audio */
-static void disable_azalia_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id)
-{
-	uint32_t value;
-
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-
-	set_reg_field_value(value, 0,
-		AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		AUDIO_ENABLED);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		value);
-}
-
-/* disable DP audio */
-static void disable_dp_audio(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id)
-{
-	const uint32_t addr = mmDP_SEC_CNTL + engine_offset[engine_id];
-
-	uint32_t value;
-
-	/* Disable Audio packets */
-	value = dm_read_reg(hw_ctx->ctx, addr);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_ASP_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_ATP_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_AIP_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_ACM_ENABLE);
-
-	set_reg_field_value(value, 0,
-		DP_SEC_CNTL,
-		DP_SEC_STREAM_ENABLE);
-
-	/* This register shared with encoder info frame. Therefore we need to
-	keep master enabled if at least on of the fields is not 0 */
-	if (value != 0)
-		set_reg_field_value(value, 1,
-			DP_SEC_CNTL,
-			DP_SEC_STREAM_ENABLE);
-
-	dm_write_reg(hw_ctx->ctx, addr, value);
-}
-
-static void configure_azalia(
-	const struct hw_ctx_audio *hw_ctx,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_info *audio_info)
-{
-	uint32_t speakers = audio_info->flags.info.ALLSPEAKERS;
-	uint32_t value;
-	uint32_t field = 0;
-	enum audio_format_code audio_format_code;
-	uint32_t format_index;
-	uint32_t index;
-	bool is_ac3_supported = false;
-	bool is_audio_format_supported = false;
-	union audio_sample_rates sample_rate;
-	uint32_t strlen = 0;
-
-	/* Speaker Allocation */
-	/*
-	uint32_t value;
-	uint32_t field = 0;*/
-	value = read_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);
-
-	set_reg_field_value(value,
-		speakers,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		SPEAKER_ALLOCATION);
-
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		HDMI_CONNECTION);
-
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		DP_CONNECTION);
-
-	field = get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			EXTRA_CONNECTION_INFO);
-
-	field &= ~0x1;
-
-	set_reg_field_value(value,
-		field,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		EXTRA_CONNECTION_INFO);
-
-	/* set audio for output signal */
-	switch (signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			HDMI_CONNECTION);
-
-		break;
-	case SIGNAL_TYPE_WIRELESS: {
-		/*LSB used for "is wireless" flag */
-		field = 0;
-		field = get_reg_field_value(value,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		EXTRA_CONNECTION_INFO);
-		field |= 0x1;
-		set_reg_field_value(value,
-			field,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			EXTRA_CONNECTION_INFO);
-
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			HDMI_CONNECTION);
-
-		}
-		break;
-	case SIGNAL_TYPE_EDP:
-	case SIGNAL_TYPE_DISPLAY_PORT:
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			DP_CONNECTION);
-
-		break;
-	default:
-		break;
-	}
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		value);
-
-	/*  Audio Descriptors   */
-	/* pass through all formats */
-	for (format_index = 0; format_index < AUDIO_FORMAT_CODE_COUNT;
-			format_index++) {
-		audio_format_code =
-			(AUDIO_FORMAT_CODE_FIRST + format_index);
-
-		/* those are unsupported, skip programming */
-		if (audio_format_code == AUDIO_FORMAT_CODE_1BITAUDIO ||
-			audio_format_code == AUDIO_FORMAT_CODE_DST)
-			continue;
-
-		value = 0;
-
-		/* check if supported */
-		is_audio_format_supported =
-			dal_audio_hw_ctx_is_audio_format_supported(
-				hw_ctx,
-				audio_info,
-				audio_format_code, &index);
-
-		if (is_audio_format_supported) {
-			const struct audio_mode *audio_mode =
-					&audio_info->modes[index];
-			union audio_sample_rates sample_rates =
-					audio_mode->sample_rates;
-			uint8_t byte2 = audio_mode->max_bit_rate;
-
-			/* adjust specific properties */
-			switch (audio_format_code) {
-			case AUDIO_FORMAT_CODE_LINEARPCM: {
-				dal_hw_ctx_audio_check_audio_bandwidth(
-					hw_ctx,
-					crtc_info,
-					audio_mode->channel_count,
-					signal,
-					&sample_rates);
-
-				byte2 = audio_mode->sample_size;
-
-				set_reg_field_value(value,
-				sample_rates.all,
-		AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-				SUPPORTED_FREQUENCIES_STEREO);
-
-				}
-				break;
-			case AUDIO_FORMAT_CODE_AC3:
-				is_ac3_supported = true;
-				break;
-			case AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS:
-			case AUDIO_FORMAT_CODE_DTS_HD:
-			case AUDIO_FORMAT_CODE_MAT_MLP:
-			case AUDIO_FORMAT_CODE_DST:
-			case AUDIO_FORMAT_CODE_WMAPRO:
-				byte2 = audio_mode->vendor_specific;
-				break;
-			default:
-				break;
-			}
-
-			/* fill audio format data */
-			set_reg_field_value(value,
-			audio_mode->channel_count - 1,
-			AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-			MAX_CHANNELS);
-
-			set_reg_field_value(value,
-			sample_rates.all,
-			AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-			SUPPORTED_FREQUENCIES);
-
-			set_reg_field_value(value,
-			byte2,
-			AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-			DESCRIPTOR_BYTE_2);
-
-		} /* if */
-
-		write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0 +
-		format_index,
-		value);
-	} /* for */
-
-	if (is_ac3_supported)
-		dm_write_reg(hw_ctx->ctx,
-		mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
-		0x05);
-
-	/* check for 192khz/8-Ch support for HBR requirements */
-	sample_rate.all = 0;
-	sample_rate.rate.RATE_192 = 1;
-	dal_hw_ctx_audio_check_audio_bandwidth(
-		hw_ctx,
-		crtc_info,
-		8,
-		signal,
-		&sample_rate);
-
-	set_high_bit_rate_capable(hw_ctx, sample_rate.rate.RATE_192);
-
-	/* Audio and Video Lipsync */
-	set_video_latency(hw_ctx, audio_info->video_latency);
-	set_audio_latency(hw_ctx, audio_info->audio_latency);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->manufacture_id,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		MANUFACTURER_ID);
-
-	set_reg_field_value(value, audio_info->product_id,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		PRODUCT_ID);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		value);
-
-	value = 0;
-
-	/*get display name string length */
-	while (audio_info->display_name[strlen++] != '\0') {
-		if (strlen >=
-		MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS)
-			break;
-		}
-	set_reg_field_value(value, strlen,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
-		SINK_DESCRIPTION_LEN);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
-		value);
-
-	/*
-	*write the port ID:
-	*PORT_ID0 = display index
-	*PORT_ID1 = 16bit BDF
-	*(format MSB->LSB: 8bit Bus, 5bit Device, 3bit Function)
-	*/
-
-	value = 0;
-
-	set_reg_field_value(value, audio_info->port_id[0],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
-		PORT_ID0);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->port_id[1],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
-		PORT_ID1);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
-		value);
-
-	/*write the 18 char monitor string */
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[0],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION0);
-
-	set_reg_field_value(value, audio_info->display_name[1],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION1);
-
-	set_reg_field_value(value, audio_info->display_name[2],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION2);
-
-	set_reg_field_value(value, audio_info->display_name[3],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION3);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[4],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION4);
-
-	set_reg_field_value(value, audio_info->display_name[5],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION5);
-
-	set_reg_field_value(value, audio_info->display_name[6],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION6);
-
-	set_reg_field_value(value, audio_info->display_name[7],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION7);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[8],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION8);
-
-	set_reg_field_value(value, audio_info->display_name[9],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION9);
-
-	set_reg_field_value(value, audio_info->display_name[10],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION10);
-
-	set_reg_field_value(value, audio_info->display_name[11],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION11);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[12],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION12);
-
-	set_reg_field_value(value, audio_info->display_name[13],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION13);
-
-	set_reg_field_value(value, audio_info->display_name[14],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION14);
-
-	set_reg_field_value(value, audio_info->display_name[15],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION15);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[16],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		DESCRIPTION16);
-
-	set_reg_field_value(value, audio_info->display_name[17],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		DESCRIPTION17);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		value);
-
-}
-
-/* setup Azalia HW block */
-static void setup_azalia(
-	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_pll_info *pll_info,
-	const struct audio_info *audio_info)
-{
-	uint32_t speakers = 0;
-	uint32_t channels = 0;
-
-	if (audio_info == NULL)
-		/* This should not happen.it does so we don't get BSOD*/
-		return;
-
-	speakers = audio_info->flags.info.ALLSPEAKERS;
-	channels = dal_audio_hw_ctx_speakers_to_channels(
-		hw_ctx,
-		audio_info->flags.speaker_flags).all;
-
-	/* setup the audio stream source select (audio -> dig mapping) */
-	{
-		const uint32_t addr =
-			mmAFMT_AUDIO_SRC_CONTROL + engine_offset[engine_id];
-
-		uint32_t value = 0;
-		/*convert one-based index to zero-based */
-		set_reg_field_value(value,
-			FROM_BASE(hw_ctx)->azalia_stream_id - 1,
-			AFMT_AUDIO_SRC_CONTROL,
-			AFMT_AUDIO_SRC_SELECT);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/* Channel allocation */
-	{
-		const uint32_t addr =
-			mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
-		uint32_t value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value,
-			channels,
-			AFMT_AUDIO_PACKET_CONTROL2,
-			AFMT_AUDIO_CHANNEL_ENABLE);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	configure_azalia(hw_ctx, signal, crtc_info, audio_info);
-}
-
 /* initialize HW state */
 static void hw_initialize(
 	const struct hw_ctx_audio *hw_ctx)
@@ -1280,71 +274,6 @@ static void hw_initialize(
 	}
 }
 
-/* Assign GTC group and enable GTC value embedding */
-static void enable_gtc_embedding_with_group(
-	const struct hw_ctx_audio *hw_ctx,
-	uint32_t group_num,
-	uint32_t audio_latency)
-{
-	/*need to replace the static number with variable */
-	if (group_num <= 6) {
-		uint32_t value = read_indirect_azalia_reg(
-			hw_ctx,
-			ixAZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING);
-
-		set_reg_field_value(
-			value,
-			group_num,
-			AZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING,
-			PRESENTATION_TIME_EMBEDDING_GROUP);
-
-		set_reg_field_value(
-			value,
-			1,
-			AZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING,
-			PRESENTATION_TIME_EMBEDDING_ENABLE);
-
-		write_indirect_azalia_reg(
-			hw_ctx,
-			ixAZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING,
-			value);
-
-		/*update audio latency to LIPSYNC*/
-		set_audio_latency(hw_ctx, audio_latency);
-	} else {
-		dal_logger_write(
-			hw_ctx->ctx->logger,
-			LOG_MAJOR_HW_TRACE,
-			LOG_MINOR_COMPONENT_AUDIO,
-			"GTC group number %d is too big",
-			group_num);
-	}
-}
-
- /* Disable GTC value embedding */
-static void disable_gtc_embedding(
-	const struct hw_ctx_audio *hw_ctx)
-{
-	uint32_t value = 0;
-
-	value = read_indirect_azalia_reg(
-	hw_ctx,
-	ixAZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING);
-
-	set_reg_field_value(value, 0,
-	AZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING,
-	PRESENTATION_TIME_EMBEDDING_ENABLE);
-
-	set_reg_field_value(value, 0,
-	AZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING,
-	PRESENTATION_TIME_EMBEDDING_GROUP);
-
-	write_indirect_azalia_reg(
-		hw_ctx,
-		ixAZALIA_F0_CODEC_CONVERTER_CONTROL_GTC_EMBEDDING,
-		value);
-}
-
 /* search pixel clock value for Azalia HDMI Audio */
 static bool get_azalia_clock_info_hdmi(
 	const struct hw_ctx_audio *hw_ctx,
@@ -1399,16 +328,6 @@ static const struct hw_ctx_audio_funcs funcs = {
 	.destroy = destroy,
 	.setup_audio_wall_dto =
 		setup_audio_wall_dto,
-	.setup_hdmi_audio =
-		setup_hdmi_audio,
-	.enable_azalia_audio =
-		enable_azalia_audio,
-	.disable_azalia_audio =
-		disable_azalia_audio,
-	.disable_dp_audio =
-		disable_dp_audio,
-	.setup_azalia =
-		setup_azalia,
 	.hw_initialize =
 		hw_initialize,
 	.get_azalia_clock_info_hdmi =
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
deleted file mode 100644
index 606e98b..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "hw_ctx_audio.h"
-
-/* 25.2MHz/1.001*/
-/* 25.2MHz/1.001*/
-/* 25.2MHz*/
-/* 27MHz */
-/* 27MHz*1.001*/
-/* 27MHz*1.001*/
-/* 54MHz*/
-/* 54MHz*1.001*/
-/* 74.25MHz/1.001*/
-/* 74.25MHz*/
-/* 148.5MHz/1.001*/
-/* 148.5MHz*/
-
-static const struct audio_clock_info audio_clock_info_table[12] = {
-	{2517, 4576, 28125, 7007, 31250, 6864, 28125},
-	{2518, 4576, 28125, 7007, 31250, 6864, 28125},
-	{2520, 4096, 25200, 6272, 28000, 6144, 25200},
-	{2700, 4096, 27000, 6272, 30000, 6144, 27000},
-	{2702, 4096, 27027, 6272, 30030, 6144, 27027},
-	{2703, 4096, 27027, 6272, 30030, 6144, 27027},
-	{5400, 4096, 54000, 6272, 60000, 6144, 54000},
-	{5405, 4096, 54054, 6272, 60060, 6144, 54054},
-	{7417, 11648, 210937, 17836, 234375, 11648, 140625},
-	{7425, 4096, 74250, 6272, 82500, 6144, 74250},
-	{14835, 11648, 421875, 8918, 234375, 5824, 140625},
-	{14850, 4096, 148500, 6272, 165000, 6144, 148500}
-};
-
-static const struct audio_clock_info audio_clock_info_table_36bpc[12] = {
-	{2517, 9152, 84375, 7007, 48875, 9152, 56250},
-	{2518, 9152, 84375, 7007, 48875, 9152, 56250},
-	{2520, 4096, 37800, 6272, 42000, 6144, 37800},
-	{2700, 4096, 40500, 6272, 45000, 6144, 40500},
-	{2702, 8192, 81081, 6272, 45045, 8192, 54054},
-	{2703, 8192, 81081, 6272, 45045, 8192, 54054},
-	{5400, 4096, 81000, 6272, 90000, 6144, 81000},
-	{5405, 4096, 81081, 6272, 90090, 6144, 81081},
-	{7417, 11648, 316406, 17836, 351562, 11648, 210937},
-	{7425, 4096, 111375, 6272, 123750, 6144, 111375},
-	{14835, 11648, 632812, 17836, 703125, 11648, 421875},
-	{14850, 4096, 222750, 6272, 247500, 6144, 222750}
-};
-
-static const struct audio_clock_info audio_clock_info_table_48bpc[12] = {
-	{2517, 4576, 56250, 7007, 62500, 6864, 56250},
-	{2518, 4576, 56250, 7007, 62500, 6864, 56250},
-	{2520, 4096, 50400, 6272, 56000, 6144, 50400},
-	{2700, 4096, 54000, 6272, 60000, 6144, 54000},
-	{2702, 4096, 54054, 6267, 60060, 8192, 54054},
-	{2703, 4096, 54054, 6272, 60060, 8192, 54054},
-	{5400, 4096, 108000, 6272, 120000, 6144, 108000},
-	{5405, 4096, 108108, 6272, 120120, 6144, 108108},
-	{7417, 11648, 421875, 17836, 468750, 11648, 281250},
-	{7425, 4096, 148500, 6272, 165000, 6144, 148500},
-	{14835, 11648, 843750, 8918, 468750, 11648, 281250},
-	{14850, 4096, 297000, 6272, 330000, 6144, 297000}
-};
-
-/***** static function *****/
-
-
-/*****SCOPE : within audio hw context dal-audio-hw-ctx *****/
-
-/* check whether specified sample rates can fit into a given timing */
-void dal_hw_ctx_audio_check_audio_bandwidth(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	enum signal_type signal,
-	union audio_sample_rates *sample_rates)
-{
-	switch (signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		dal_audio_hw_ctx_check_audio_bandwidth_hdmi(
-			hw_ctx, crtc_info, channel_count, sample_rates);
-		break;
-	case SIGNAL_TYPE_EDP:
-	case SIGNAL_TYPE_DISPLAY_PORT:
-		dal_audio_hw_ctx_check_audio_bandwidth_dpsst(
-			hw_ctx, crtc_info, channel_count, sample_rates);
-		break;
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-		dal_audio_hw_ctx_check_audio_bandwidth_dpmst(
-			hw_ctx,  crtc_info, channel_count, sample_rates);
-		break;
-	default:
-		break;
-	}
-}
-
-/*For HDMI, calculate if specified sample rates can fit into a given timing */
-void dal_audio_hw_ctx_check_audio_bandwidth_hdmi(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates)
-{
-	uint32_t samples;
-	uint32_t  h_blank;
-	bool limit_freq_to_48_khz = false;
-	bool limit_freq_to_88_2_khz = false;
-	bool limit_freq_to_96_khz = false;
-	bool limit_freq_to_174_4_khz = false;
-
-	/* For two channels supported return whatever sink support,unmodified*/
-	if (channel_count > 2) {
-
-		/* Based on HDMI spec 1.3 Table 7.5 */
-		if ((crtc_info->requested_pixel_clock <= 27000) &&
-		(crtc_info->v_active <= 576) &&
-		!(crtc_info->interlaced) &&
-		!(crtc_info->pixel_repetition == 2 ||
-		crtc_info->pixel_repetition == 4)) {
-			limit_freq_to_48_khz = true;
-
-		} else if ((crtc_info->requested_pixel_clock <= 27000) &&
-				(crtc_info->v_active <= 576) &&
-				(crtc_info->interlaced) &&
-				(crtc_info->pixel_repetition == 2)) {
-			limit_freq_to_88_2_khz = true;
-
-		} else if ((crtc_info->requested_pixel_clock <= 54000) &&
-				(crtc_info->v_active <= 576) &&
-				!(crtc_info->interlaced)) {
-			limit_freq_to_174_4_khz = true;
-		}
-	}
-
-	/* Also do some calculation for the available Audio Bandwidth for the
-	 * 8 ch (i.e. for the Layout 1 => ch > 2)
-	 */
-	h_blank = crtc_info->h_total - crtc_info->h_active;
-
-	if (crtc_info->pixel_repetition)
-		h_blank *= crtc_info->pixel_repetition;
-
-	/*based on HDMI spec 1.3 Table 7.5 */
-	h_blank -= 58;
-	/*for Control Period */
-	h_blank -= 16;
-
-	samples = h_blank * 10;
-	/* Number of Audio Packets (multiplied by 10) per Line (for 8 ch number
-	 * of Audio samples per line multiplied by 10 - Layout 1)
-	 */
-	 samples /= 32;
-	 samples *= crtc_info->v_active;
-	 /*Number of samples multiplied by 10, per second */
-	 samples *= crtc_info->refresh_rate;
-	 /*Number of Audio samples per second */
-	 samples /= 10;
-
-	 /* @todo do it after deep color is implemented
-	  * 8xx - deep color bandwidth scaling
-	  * Extra bandwidth is avaliable in deep color b/c link runs faster than
-	  * pixel rate. This has the effect of allowing more tmds characters to
-	  * be transmitted during blank
-	  */
-
-	switch (crtc_info->color_depth) {
-	case COLOR_DEPTH_888:
-		samples *= 4;
-		break;
-	case COLOR_DEPTH_101010:
-		samples *= 5;
-		break;
-	case COLOR_DEPTH_121212:
-		samples *= 6;
-		break;
-	default:
-		samples *= 4;
-		break;
-	}
-
-	samples /= 4;
-
-	/*check limitation*/
-	if (samples < 88200)
-		limit_freq_to_48_khz = true;
-	else if (samples < 96000)
-		limit_freq_to_88_2_khz = true;
-	else if (samples < 176400)
-		limit_freq_to_96_khz = true;
-	else if (samples < 192000)
-		limit_freq_to_174_4_khz = true;
-
-	if (sample_rates != NULL) {
-		/* limit frequencies */
-		if (limit_freq_to_174_4_khz)
-			sample_rates->rate.RATE_192 = 0;
-
-		if (limit_freq_to_96_khz) {
-			sample_rates->rate.RATE_192 = 0;
-			sample_rates->rate.RATE_176_4 = 0;
-		}
-		if (limit_freq_to_88_2_khz) {
-			sample_rates->rate.RATE_192 = 0;
-			sample_rates->rate.RATE_176_4 = 0;
-			sample_rates->rate.RATE_96 = 0;
-		}
-		if (limit_freq_to_48_khz) {
-			sample_rates->rate.RATE_192 = 0;
-			sample_rates->rate.RATE_176_4 = 0;
-			sample_rates->rate.RATE_96 = 0;
-			sample_rates->rate.RATE_88_2 = 0;
-		}
-	}
-}
-
-/*For DP SST, calculate if specified sample rates can fit into a given timing */
-void dal_audio_hw_ctx_check_audio_bandwidth_dpsst(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates)
-{
-	/* do nothing */
-}
-
-/*For DP MST, calculate if specified sample rates can fit into a given timing */
-void dal_audio_hw_ctx_check_audio_bandwidth_dpmst(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates)
-{
-	/* do nothing  */
-}
-
-/* calculate max number of Audio packets per line */
-uint32_t dal_audio_hw_ctx_calc_max_audio_packets_per_line(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info)
-{
-	uint32_t max_packets_per_line;
-
-	max_packets_per_line =
-		crtc_info->h_total - crtc_info->h_active;
-
-	if (crtc_info->pixel_repetition)
-		max_packets_per_line *= crtc_info->pixel_repetition;
-
-	/* for other hdmi features */
-	max_packets_per_line -= 58;
-	/* for Control Period */
-	max_packets_per_line -= 16;
-	/* Number of Audio Packets per Line */
-	max_packets_per_line /= 32;
-
-	return max_packets_per_line;
-}
-
-/**
-* speakersToChannels
-*
-* @brief
-*  translate speakers to channels
-*
-*  FL  - Front Left
-*  FR  - Front Right
-*  RL  - Rear Left
-*  RR  - Rear Right
-*  RC  - Rear Center
-*  FC  - Front Center
-*  FLC - Front Left Center
-*  FRC - Front Right Center
-*  RLC - Rear Left Center
-*  RRC - Rear Right Center
-*  LFE - Low Freq Effect
-*
-*               FC
-*          FLC      FRC
-*    FL                    FR
-*
-*                    LFE
-*              ()
-*
-*
-*    RL                    RR
-*          RLC      RRC
-*               RC
-*
-*             ch  8   7   6   5   4   3   2   1
-* 0b00000011      -   -   -   -   -   -   FR  FL
-* 0b00000111      -   -   -   -   -   LFE FR  FL
-* 0b00001011      -   -   -   -   FC  -   FR  FL
-* 0b00001111      -   -   -   -   FC  LFE FR  FL
-* 0b00010011      -   -   -   RC  -   -   FR  FL
-* 0b00010111      -   -   -   RC  -   LFE FR  FL
-* 0b00011011      -   -   -   RC  FC  -   FR  FL
-* 0b00011111      -   -   -   RC  FC  LFE FR  FL
-* 0b00110011      -   -   RR  RL  -   -   FR  FL
-* 0b00110111      -   -   RR  RL  -   LFE FR  FL
-* 0b00111011      -   -   RR  RL  FC  -   FR  FL
-* 0b00111111      -   -   RR  RL  FC  LFE FR  FL
-* 0b01110011      -   RC  RR  RL  -   -   FR  FL
-* 0b01110111      -   RC  RR  RL  -   LFE FR  FL
-* 0b01111011      -   RC  RR  RL  FC  -   FR  FL
-* 0b01111111      -   RC  RR  RL  FC  LFE FR  FL
-* 0b11110011      RRC RLC RR  RL  -   -   FR  FL
-* 0b11110111      RRC RLC RR  RL  -   LFE FR  FL
-* 0b11111011      RRC RLC RR  RL  FC  -   FR  FL
-* 0b11111111      RRC RLC RR  RL  FC  LFE FR  FL
-* 0b11000011      FRC FLC -   -   -   -   FR  FL
-* 0b11000111      FRC FLC -   -   -   LFE FR  FL
-* 0b11001011      FRC FLC -   -   FC  -   FR  FL
-* 0b11001111      FRC FLC -   -   FC  LFE FR  FL
-* 0b11010011      FRC FLC -   RC  -   -   FR  FL
-* 0b11010111      FRC FLC -   RC  -   LFE FR  FL
-* 0b11011011      FRC FLC -   RC  FC  -   FR  FL
-* 0b11011111      FRC FLC -   RC  FC  LFE FR  FL
-* 0b11110011      FRC FLC RR  RL  -   -   FR  FL
-* 0b11110111      FRC FLC RR  RL  -   LFE FR  FL
-* 0b11111011      FRC FLC RR  RL  FC  -   FR  FL
-* 0b11111111      FRC FLC RR  RL  FC  LFE FR  FL
-*
-* @param
-*  speakers - speaker information as it comes from CEA audio block
-*/
-/* translate speakers to channels */
-union audio_cea_channels dal_audio_hw_ctx_speakers_to_channels(
-	const struct hw_ctx_audio *hw_ctx,
-	struct audio_speaker_flags speaker_flags)
-{
-	union audio_cea_channels cea_channels = {0};
-
-	/* these are one to one */
-	cea_channels.channels.FL = speaker_flags.FL_FR;
-	cea_channels.channels.FR = speaker_flags.FL_FR;
-	cea_channels.channels.LFE = speaker_flags.LFE;
-	cea_channels.channels.FC = speaker_flags.FC;
-
-	/* if Rear Left and Right exist move RC speaker to channel 7
-	 * otherwise to channel 5
-	 */
-	if (speaker_flags.RL_RR) {
-		cea_channels.channels.RL_RC = speaker_flags.RL_RR;
-		cea_channels.channels.RR = speaker_flags.RL_RR;
-		cea_channels.channels.RC_RLC_FLC = speaker_flags.RC;
-	} else {
-		cea_channels.channels.RL_RC = speaker_flags.RC;
-	}
-
-	/* FRONT Left Right Center and REAR Left Right Center are exclusive */
-	if (speaker_flags.FLC_FRC) {
-		cea_channels.channels.RC_RLC_FLC = speaker_flags.FLC_FRC;
-		cea_channels.channels.RRC_FRC = speaker_flags.FLC_FRC;
-	} else {
-		cea_channels.channels.RC_RLC_FLC = speaker_flags.RLC_RRC;
-		cea_channels.channels.RRC_FRC = speaker_flags.RLC_RRC;
-	}
-
-	return cea_channels;
-}
-
-/* check whether specified audio format supported */
-bool dal_audio_hw_ctx_is_audio_format_supported(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_info *audio_info,
-	enum audio_format_code audio_format_code,
-	uint32_t *format_index)
-{
-	uint32_t index;
-	uint32_t max_channe_index = 0;
-	bool found = false;
-
-	if (audio_info == NULL)
-		return found;
-
-	/* pass through whole array */
-	for (index = 0; index < audio_info->mode_count; index++) {
-		if (audio_info->modes[index].format_code == audio_format_code) {
-			if (found) {
-				/* format has multiply entries, choose one with
-				 *  highst number of channels */
-				if (audio_info->modes[index].channel_count >
-		audio_info->modes[max_channe_index].channel_count) {
-					max_channe_index = index;
-				}
-			} else {
-				/* format found, save it's index */
-				found = true;
-				max_channe_index = index;
-			}
-		}
-	}
-
-	/* return index */
-	if (found && format_index != NULL)
-		*format_index = max_channe_index;
-
-	return found;
-}
-
-/* search pixel clock value for HDMI */
-bool dal_audio_hw_ctx_get_audio_clock_info(
-	const struct hw_ctx_audio *hw_ctx,
-	enum dc_color_depth color_depth,
-	uint32_t crtc_pixel_clock_in_khz,
-	uint32_t actual_pixel_clock_in_khz,
-	struct audio_clock_info *audio_clock_info)
-{
-	const struct audio_clock_info *clock_info;
-	uint32_t index;
-	uint32_t crtc_pixel_clock_in_10khz = crtc_pixel_clock_in_khz / 10;
-	uint32_t audio_array_size;
-
-	if (audio_clock_info == NULL)
-		return false; /* should not happen */
-
-	switch (color_depth) {
-	case COLOR_DEPTH_161616:
-		clock_info = audio_clock_info_table_48bpc;
-		audio_array_size = ARRAY_SIZE(
-				audio_clock_info_table_48bpc);
-		break;
-	case COLOR_DEPTH_121212:
-		clock_info = audio_clock_info_table_36bpc;
-		audio_array_size = ARRAY_SIZE(
-				audio_clock_info_table_36bpc);
-		break;
-	default:
-		clock_info = audio_clock_info_table;
-		audio_array_size = ARRAY_SIZE(
-				audio_clock_info_table);
-		break;
-	}
-
-	if (clock_info != NULL) {
-		/* search for exact pixel clock in table */
-		for (index = 0; index < audio_array_size; index++) {
-			if (clock_info[index].pixel_clock_in_10khz >
-				crtc_pixel_clock_in_10khz)
-				break;  /* not match */
-			else if (clock_info[index].pixel_clock_in_10khz ==
-					crtc_pixel_clock_in_10khz) {
-				/* match found */
-				if (audio_clock_info != NULL) {
-					*audio_clock_info = clock_info[index];
-					return true;
-				}
-			}
-		}
-	}
-
-	/* not found */
-	if (actual_pixel_clock_in_khz == 0)
-		actual_pixel_clock_in_khz = crtc_pixel_clock_in_khz;
-
-	/* See HDMI spec  the table entry under
-	 *  pixel clock of "Other". */
-	audio_clock_info->pixel_clock_in_10khz =
-			actual_pixel_clock_in_khz / 10;
-	audio_clock_info->cts_32khz = actual_pixel_clock_in_khz;
-	audio_clock_info->cts_44khz = actual_pixel_clock_in_khz;
-	audio_clock_info->cts_48khz = actual_pixel_clock_in_khz;
-
-	audio_clock_info->n_32khz = 4096;
-	audio_clock_info->n_44khz = 6272;
-	audio_clock_info->n_48khz = 6144;
-
-	return true;
-}
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
index 9fb3207..053686d 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
+++ b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
@@ -54,38 +54,6 @@ struct hw_ctx_audio_funcs {
 
 	/* MM register access  read_register  write_register */
 
-	/***** from dal2 hwcontextaudio_hal.hpp *****/
-
-	/* setup HDMI audio */
-	void (*setup_hdmi_audio)(
-		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id,
-		const struct audio_crtc_info *crtc_info);
-
-	/* enable Azalia audio */
-	void (*enable_azalia_audio)(
-		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id);
-
-	/* disable Azalia audio */
-	void (*disable_azalia_audio)(
-		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id);
-
-	/* disable DP audio */
-	void (*disable_dp_audio)(
-		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id);
-
-	/* setup Azalia HW block */
-	void (*setup_azalia)(
-		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id,
-		enum signal_type signal,
-		const struct audio_crtc_info *crtc_info,
-		const struct audio_pll_info *pll_info,
-		const struct audio_info *audio_info);
-
 	/* initialize HW state */
 	void (*hw_initialize)(
 		const struct hw_ctx_audio *hw_ctx);
@@ -113,11 +81,6 @@ struct hw_ctx_audio_funcs {
 		const struct audio_pll_info *pll_info,
 		struct azalia_clock_info *azalia_clock_info);
 
-	void (*enable_afmt_clock)(
-		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id,
-		bool enable);
-
 	/* @@@@   private:  @@@@  */
 
 	/* check_audio_bandwidth_hdmi  */
@@ -149,70 +112,6 @@ struct hw_ctx_audio {
 bool dal_audio_construct_hw_ctx_audio(
 	struct hw_ctx_audio *hw_ctx);
 
-/*
- *creator of audio HW context will be implemented by specific ASIC object only.
- *Top base or interface object does not have implementation of creator.
- */
-
-/* --- functions called by audio hw context itself --- */
-
-/* MM register access */
-/*read_register  - dal_read_reg */
-/*write_register - dal_write_reg*/
-
-/*check whether specified sample rates can fit into a given timing */
-void dal_hw_ctx_audio_check_audio_bandwidth(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	enum signal_type signal,
-	union audio_sample_rates *sample_rates);
-
-/*For HDMI, calculate if specified sample rates can fit into a given timing */
-void dal_audio_hw_ctx_check_audio_bandwidth_hdmi(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates);
-
-/*For DPSST, calculate if specified sample rates can fit into a given timing */
-void dal_audio_hw_ctx_check_audio_bandwidth_dpsst(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates);
-
-/*For DPMST, calculate if specified sample rates can fit into a given timing */
-void dal_audio_hw_ctx_check_audio_bandwidth_dpmst(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates);
-
-/* calculate max number of Audio packets per line */
-uint32_t dal_audio_hw_ctx_calc_max_audio_packets_per_line(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_crtc_info *crtc_info);
-
-/* translate speakers to channels */
-union audio_cea_channels dal_audio_hw_ctx_speakers_to_channels(
-	const struct hw_ctx_audio *hw_ctx,
-	struct audio_speaker_flags speaker_flags);
-
-/* check whether specified audio format supported */
-bool dal_audio_hw_ctx_is_audio_format_supported(
-	const struct hw_ctx_audio *hw_ctx,
-	const struct audio_info *audio_info,
-	enum audio_format_code audio_format_code,
-	uint32_t *format_index);
-
-/* search pixel clock value for HDMI */
-bool dal_audio_hw_ctx_get_audio_clock_info(
-	const struct hw_ctx_audio *hw_ctx,
-	enum dc_color_depth color_depth,
-	uint32_t crtc_pixel_clock_in_khz,
-	uint32_t actual_pixel_clock_in_khz,
-	struct audio_clock_info *audio_clock_info);
 
 #endif  /* __DAL_HW_CTX_AUDIO_H__ */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index ae34228..5e95c2a 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -35,6 +35,7 @@
 #include "dc_link_ddc.h"
 #include "link_hwss.h"
 #include "stream_encoder.h"
+#include "audio/audio.h"
 #include "link_encoder.h"
 #include "hw_sequencer.h"
 #include "fixed31_32.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 9195fa2..9bcad48 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -273,39 +273,7 @@ static const struct dce110_link_enc_registers link_enc_regs[] = {
 
 #define stream_enc_regs(id)\
 [id] = {\
-	.AFMT_AVI_INFO0 = mmDIG ## id ## _AFMT_AVI_INFO0,\
-	.AFMT_AVI_INFO1 = mmDIG ## id ## _AFMT_AVI_INFO1,\
-	.AFMT_AVI_INFO2 = mmDIG ## id ## _AFMT_AVI_INFO2,\
-	.AFMT_AVI_INFO3 = mmDIG ## id ## _AFMT_AVI_INFO3,\
-	.AFMT_GENERIC_0 = mmDIG ## id ## _AFMT_GENERIC_0,\
-	.AFMT_GENERIC_7 = mmDIG ## id ## _AFMT_GENERIC_7,\
-	.AFMT_GENERIC_HDR = mmDIG ## id ## _AFMT_GENERIC_HDR,\
-	.AFMT_INFOFRAME_CONTROL0 = mmDIG ## id ## _AFMT_INFOFRAME_CONTROL0,\
-	.AFMT_VBI_PACKET_CONTROL = mmDIG ## id ## _AFMT_VBI_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL2 = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL2,\
-	.AFMT_60958_0 = mmDIG ## id ## _AFMT_60958_0,\
-	.DIG_FE_CNTL = mmDIG ## id ## _DIG_FE_CNTL,\
-	.DP_MSE_RATE_CNTL = mmDP ## id ## _DP_MSE_RATE_CNTL,\
-	.DP_MSE_RATE_UPDATE = mmDP ## id ## _DP_MSE_RATE_UPDATE,\
-	.DP_PIXEL_FORMAT = mmDP ## id ## _DP_PIXEL_FORMAT,\
-	.DP_SEC_CNTL = mmDP ## id ## _DP_SEC_CNTL,\
-	.DP_STEER_FIFO = mmDP ## id ## _DP_STEER_FIFO,\
-	.DP_VID_M = mmDP ## id ## _DP_VID_M,\
-	.DP_VID_N = mmDP ## id ## _DP_VID_N,\
-	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL,\
-	.DP_VID_TIMING = mmDP ## id ## _DP_VID_TIMING,\
-	.DP_SEC_AUD_N = mmDP ## id ## _DP_SEC_AUD_N,\
-	.DP_SEC_TIMESTAMP = mmDP ## id ## _DP_SEC_TIMESTAMP,\
-	.HDMI_CONTROL = mmDIG ## id ## _HDMI_CONTROL,\
-	.HDMI_GC = mmDIG ## id ## _HDMI_GC,\
-	.HDMI_GENERIC_PACKET_CONTROL0 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL0,\
-	.HDMI_GENERIC_PACKET_CONTROL1 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL1,\
-	.HDMI_INFOFRAME_CONTROL0 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL0,\
-	.HDMI_INFOFRAME_CONTROL1 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL1,\
-	.HDMI_VBI_PACKET_CONTROL = mmDIG ## id ## _HDMI_VBI_PACKET_CONTROL,\
-	.TMDS_CNTL = mmDIG ## id ## _TMDS_CNTL,\
-	\
+	SE_COMMON_REG_LIST(id)\
 	.AFMT_CNTL = 0,\
 }
 
@@ -319,6 +287,21 @@ static const struct dce110_stream_enc_registers stream_enc_regs[] = {
 	stream_enc_regs(6)
 };
 
+#define audio_regs(id)\
+[id] = {\
+	AUD_COMMON_REG_LIST(id)\
+}
+
+static const struct dce110_audio_registers audio_regs[] = {
+	audio_regs(0),
+	audio_regs(1),
+	audio_regs(2),
+	audio_regs(3),
+	audio_regs(4),
+	audio_regs(5),
+	audio_regs(6),
+};
+
 #define DCFE_MEM_PWR_CTRL_REG_BASE 0x1b03
 
 static const struct dce110_opp_reg_offsets dce100_opp_reg_offsets[] = {
@@ -942,6 +925,9 @@ static bool construct(
                 }
 
                 audio_init_data.audio_stream_id = obj_id;
+                audio_init_data.inst = i;
+                audio_init_data.reg = &audio_regs[i];
+
                 pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
                 if (pool->base.audios[i] == NULL) {
                         BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index b4283fa..d9f5a3b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -44,6 +44,7 @@
 #include "stream_encoder.h"
 #include "link_encoder.h"
 #include "clock_source.h"
+#include "audio/audio.h"
 #include "gamma_calcs.h"
 
 /* include DCE11 register header files */
@@ -578,9 +579,15 @@ static void disable_stream(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->stream_enc);
 
 	if (pipe_ctx->audio) {
-		/* mute audio */
-		pipe_ctx->stream_enc->funcs->audio_mute_control(
-			pipe_ctx->stream_enc, true);
+		pipe_ctx->stream_enc->funcs->audio_mute_control(pipe_ctx->stream_enc, true);
+
+		if (dc_is_dp_signal(pipe_ctx->stream->signal))
+			pipe_ctx->stream_enc->funcs->dp_audio_disable(pipe_ctx->stream_enc);
+		else
+			pipe_ctx->stream_enc->funcs->hdmi_audio_disable(pipe_ctx->stream_enc);
+
+		pipe_ctx->audio->funcs->az_disable(pipe_ctx->audio);
+		pipe_ctx->audio = NULL;
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */
@@ -1298,17 +1305,7 @@ static void reset_single_pipe_hw_ctx(
 
 	dcb = dal_adapter_service_get_bios_parser(
 			context->res_ctx.pool.adapter_srv);
-	if (pipe_ctx->audio) {
-		dal_audio_disable_output(pipe_ctx->audio,
-				pipe_ctx->stream_enc->id,
-				pipe_ctx->stream->signal);
-
-		/* todo: core_link_disable_stream rely
-		 * audio pointer to mute audio. we never mute correctly
-		 */
-		pipe_ctx->audio = NULL;
-	}
-
+	
 	core_link_disable_stream(pipe_ctx);
 	if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
 		dm_error("DC: failed to blank crtc!\n");
@@ -1457,13 +1454,25 @@ static enum dc_status apply_ctx_to_hw(
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 			build_audio_output(pipe_ctx, &audio_output);
-			if (AUDIO_RESULT_OK != dal_audio_setup(
+
+			if (dc_is_dp_signal(pipe_ctx->stream->signal))
+				pipe_ctx->stream_enc->funcs->dp_audio_setup(
+						pipe_ctx->stream_enc,
+						pipe_ctx->audio->inst,
+						&pipe_ctx->stream->public.audio_info);
+			else
+				pipe_ctx->stream_enc->funcs->hdmi_audio_setup(
+						pipe_ctx->stream_enc,
+						pipe_ctx->audio->inst,
+						&pipe_ctx->stream->public.audio_info,
+						&audio_output.crtc_info);
+
+			pipe_ctx->audio->funcs->az_configure(
 					pipe_ctx->audio,
-					&audio_output,
-					&pipe_ctx->stream->public.audio_info)) {
-				BREAK_TO_DEBUGGER();
-				return DC_ERROR_UNEXPECTED;
-			}
+					pipe_ctx->stream->signal,
+					&audio_output.crtc_info,
+					&pipe_ctx->stream->public.audio_info);
+
 			if (!programmed_audio_dto) {
 				dal_audio_setup_audio_wall_dto(
 					pipe_ctx->audio,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 4b0839a..b666376 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -221,39 +221,8 @@ static const struct dce110_link_enc_registers link_enc_regs[] = {
 
 #define stream_enc_regs(id)\
 [id] = {\
+	SE_COMMON_REG_LIST(id)\
 	.AFMT_CNTL = mmDIG ## id ## _AFMT_CNTL,\
-	.AFMT_AVI_INFO0 = mmDIG ## id ## _AFMT_AVI_INFO0,\
-	.AFMT_AVI_INFO1 = mmDIG ## id ## _AFMT_AVI_INFO1,\
-	.AFMT_AVI_INFO2 = mmDIG ## id ## _AFMT_AVI_INFO2,\
-	.AFMT_AVI_INFO3 = mmDIG ## id ## _AFMT_AVI_INFO3,\
-	.AFMT_GENERIC_0 = mmDIG ## id ## _AFMT_GENERIC_0,\
-	.AFMT_GENERIC_7 = mmDIG ## id ## _AFMT_GENERIC_7,\
-	.AFMT_GENERIC_HDR = mmDIG ## id ## _AFMT_GENERIC_HDR,\
-	.AFMT_INFOFRAME_CONTROL0 = mmDIG ## id ## _AFMT_INFOFRAME_CONTROL0,\
-	.AFMT_VBI_PACKET_CONTROL = mmDIG ## id ## _AFMT_VBI_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL2 = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL2,\
-	.AFMT_60958_0 = mmDIG ## id ## _AFMT_60958_0,\
-	.DIG_FE_CNTL = mmDIG ## id ## _DIG_FE_CNTL,\
-	.DP_MSE_RATE_CNTL = mmDP ## id ## _DP_MSE_RATE_CNTL,\
-	.DP_MSE_RATE_UPDATE = mmDP ## id ## _DP_MSE_RATE_UPDATE,\
-	.DP_PIXEL_FORMAT = mmDP ## id ## _DP_PIXEL_FORMAT,\
-	.DP_SEC_CNTL = mmDP ## id ## _DP_SEC_CNTL,\
-	.DP_STEER_FIFO = mmDP ## id ## _DP_STEER_FIFO,\
-	.DP_VID_M = mmDP ## id ## _DP_VID_M,\
-	.DP_VID_N = mmDP ## id ## _DP_VID_N,\
-	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL,\
-	.DP_VID_TIMING = mmDP ## id ## _DP_VID_TIMING,\
-	.DP_SEC_AUD_N = mmDP ## id ## _DP_SEC_AUD_N,\
-	.DP_SEC_TIMESTAMP = mmDP ## id ## _DP_SEC_TIMESTAMP,\
-	.HDMI_CONTROL = mmDIG ## id ## _HDMI_CONTROL,\
-	.HDMI_GC = mmDIG ## id ## _HDMI_GC,\
-	.HDMI_GENERIC_PACKET_CONTROL0 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL0,\
-	.HDMI_GENERIC_PACKET_CONTROL1 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL1,\
-	.HDMI_INFOFRAME_CONTROL0 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL0,\
-	.HDMI_INFOFRAME_CONTROL1 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL1,\
-	.HDMI_VBI_PACKET_CONTROL = mmDIG ## id ## _HDMI_VBI_PACKET_CONTROL,\
-	.TMDS_CNTL = mmDIG ## id ## _TMDS_CNTL,\
 }
 
 static const struct dce110_stream_enc_registers stream_enc_regs[] = {
@@ -266,6 +235,21 @@ static const struct dce110_stream_enc_registers stream_enc_regs[] = {
 		stream_enc_regs(6)
 };
 
+#define audio_regs(id)\
+[id] = {\
+	AUD_COMMON_REG_LIST(id)\
+}
+
+static const struct dce110_audio_registers audio_regs[] = {
+	audio_regs(0),
+	audio_regs(1),
+	audio_regs(2),
+	audio_regs(3),
+	audio_regs(4),
+	audio_regs(5),
+	audio_regs(6),
+};
+
 /* AG TBD Needs to be reduced back to 3 pipes once dce10 hw sequencer implemented. */
 static const struct dce110_opp_reg_offsets dce110_opp_reg_offsets[] = {
 {
@@ -1295,6 +1279,9 @@ static bool construct(
                 }
 
                 audio_init_data.audio_stream_id = obj_id;
+                audio_init_data.inst = i;
+                audio_init_data.reg = &audio_regs[i];
+
                 pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
                 if (pool->base.audios[i] == NULL) {
                         BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index 179a4a0..6bfe2d4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -1101,6 +1101,395 @@ static void dce110_stream_encoder_dp_unblank(
 #define DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT 0x8000
 #define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC 1
 
+#include "include/audio_types.h"
+
+/**
+* speakersToChannels
+*
+* @brief
+*  translate speakers to channels
+*
+*  FL  - Front Left
+*  FR  - Front Right
+*  RL  - Rear Left
+*  RR  - Rear Right
+*  RC  - Rear Center
+*  FC  - Front Center
+*  FLC - Front Left Center
+*  FRC - Front Right Center
+*  RLC - Rear Left Center
+*  RRC - Rear Right Center
+*  LFE - Low Freq Effect
+*
+*               FC
+*          FLC      FRC
+*    FL                    FR
+*
+*                    LFE
+*              ()
+*
+*
+*    RL                    RR
+*          RLC      RRC
+*               RC
+*
+*             ch  8   7   6   5   4   3   2   1
+* 0b00000011      -   -   -   -   -   -   FR  FL
+* 0b00000111      -   -   -   -   -   LFE FR  FL
+* 0b00001011      -   -   -   -   FC  -   FR  FL
+* 0b00001111      -   -   -   -   FC  LFE FR  FL
+* 0b00010011      -   -   -   RC  -   -   FR  FL
+* 0b00010111      -   -   -   RC  -   LFE FR  FL
+* 0b00011011      -   -   -   RC  FC  -   FR  FL
+* 0b00011111      -   -   -   RC  FC  LFE FR  FL
+* 0b00110011      -   -   RR  RL  -   -   FR  FL
+* 0b00110111      -   -   RR  RL  -   LFE FR  FL
+* 0b00111011      -   -   RR  RL  FC  -   FR  FL
+* 0b00111111      -   -   RR  RL  FC  LFE FR  FL
+* 0b01110011      -   RC  RR  RL  -   -   FR  FL
+* 0b01110111      -   RC  RR  RL  -   LFE FR  FL
+* 0b01111011      -   RC  RR  RL  FC  -   FR  FL
+* 0b01111111      -   RC  RR  RL  FC  LFE FR  FL
+* 0b11110011      RRC RLC RR  RL  -   -   FR  FL
+* 0b11110111      RRC RLC RR  RL  -   LFE FR  FL
+* 0b11111011      RRC RLC RR  RL  FC  -   FR  FL
+* 0b11111111      RRC RLC RR  RL  FC  LFE FR  FL
+* 0b11000011      FRC FLC -   -   -   -   FR  FL
+* 0b11000111      FRC FLC -   -   -   LFE FR  FL
+* 0b11001011      FRC FLC -   -   FC  -   FR  FL
+* 0b11001111      FRC FLC -   -   FC  LFE FR  FL
+* 0b11010011      FRC FLC -   RC  -   -   FR  FL
+* 0b11010111      FRC FLC -   RC  -   LFE FR  FL
+* 0b11011011      FRC FLC -   RC  FC  -   FR  FL
+* 0b11011111      FRC FLC -   RC  FC  LFE FR  FL
+* 0b11110011      FRC FLC RR  RL  -   -   FR  FL
+* 0b11110111      FRC FLC RR  RL  -   LFE FR  FL
+* 0b11111011      FRC FLC RR  RL  FC  -   FR  FL
+* 0b11111111      FRC FLC RR  RL  FC  LFE FR  FL
+*
+* @param
+*  speakers - speaker information as it comes from CEA audio block
+*/
+/* translate speakers to channels */
+
+union audio_cea_channels {
+	uint8_t all;
+	struct audio_cea_channels_bits {
+		uint32_t FL:1;
+		uint32_t FR:1;
+		uint32_t LFE:1;
+		uint32_t FC:1;
+		uint32_t RL_RC:1;
+		uint32_t RR:1;
+		uint32_t RC_RLC_FLC:1;
+		uint32_t RRC_FRC:1;
+	} channels;
+};
+
+struct audio_clock_info {
+	/* pixel clock frequency*/
+	uint32_t pixel_clock_in_10khz;
+	/* N - 32KHz audio */
+	uint32_t n_32khz;
+	/* CTS - 32KHz audio*/
+	uint32_t cts_32khz;
+	uint32_t n_44khz;
+	uint32_t cts_44khz;
+	uint32_t n_48khz;
+	uint32_t cts_48khz;
+};
+
+/* 25.2MHz/1.001*/
+/* 25.2MHz/1.001*/
+/* 25.2MHz*/
+/* 27MHz */
+/* 27MHz*1.001*/
+/* 27MHz*1.001*/
+/* 54MHz*/
+/* 54MHz*1.001*/
+/* 74.25MHz/1.001*/
+/* 74.25MHz*/
+/* 148.5MHz/1.001*/
+/* 148.5MHz*/
+
+static const struct audio_clock_info audio_clock_info_table[12] = {
+	{2517, 4576, 28125, 7007, 31250, 6864, 28125},
+	{2518, 4576, 28125, 7007, 31250, 6864, 28125},
+	{2520, 4096, 25200, 6272, 28000, 6144, 25200},
+	{2700, 4096, 27000, 6272, 30000, 6144, 27000},
+	{2702, 4096, 27027, 6272, 30030, 6144, 27027},
+	{2703, 4096, 27027, 6272, 30030, 6144, 27027},
+	{5400, 4096, 54000, 6272, 60000, 6144, 54000},
+	{5405, 4096, 54054, 6272, 60060, 6144, 54054},
+	{7417, 11648, 210937, 17836, 234375, 11648, 140625},
+	{7425, 4096, 74250, 6272, 82500, 6144, 74250},
+	{14835, 11648, 421875, 8918, 234375, 5824, 140625},
+	{14850, 4096, 148500, 6272, 165000, 6144, 148500}
+};
+
+static const struct audio_clock_info audio_clock_info_table_36bpc[12] = {
+	{2517, 9152, 84375, 7007, 48875, 9152, 56250},
+	{2518, 9152, 84375, 7007, 48875, 9152, 56250},
+	{2520, 4096, 37800, 6272, 42000, 6144, 37800},
+	{2700, 4096, 40500, 6272, 45000, 6144, 40500},
+	{2702, 8192, 81081, 6272, 45045, 8192, 54054},
+	{2703, 8192, 81081, 6272, 45045, 8192, 54054},
+	{5400, 4096, 81000, 6272, 90000, 6144, 81000},
+	{5405, 4096, 81081, 6272, 90090, 6144, 81081},
+	{7417, 11648, 316406, 17836, 351562, 11648, 210937},
+	{7425, 4096, 111375, 6272, 123750, 6144, 111375},
+	{14835, 11648, 632812, 17836, 703125, 11648, 421875},
+	{14850, 4096, 222750, 6272, 247500, 6144, 222750}
+};
+
+static const struct audio_clock_info audio_clock_info_table_48bpc[12] = {
+	{2517, 4576, 56250, 7007, 62500, 6864, 56250},
+	{2518, 4576, 56250, 7007, 62500, 6864, 56250},
+	{2520, 4096, 50400, 6272, 56000, 6144, 50400},
+	{2700, 4096, 54000, 6272, 60000, 6144, 54000},
+	{2702, 4096, 54054, 6267, 60060, 8192, 54054},
+	{2703, 4096, 54054, 6272, 60060, 8192, 54054},
+	{5400, 4096, 108000, 6272, 120000, 6144, 108000},
+	{5405, 4096, 108108, 6272, 120120, 6144, 108108},
+	{7417, 11648, 421875, 17836, 468750, 11648, 281250},
+	{7425, 4096, 148500, 6272, 165000, 6144, 148500},
+	{14835, 11648, 843750, 8918, 468750, 11648, 281250},
+	{14850, 4096, 297000, 6272, 330000, 6144, 297000}
+};
+
+union audio_cea_channels speakers_to_channels(
+	struct audio_speaker_flags speaker_flags)
+{
+	union audio_cea_channels cea_channels = {0};
+
+	/* these are one to one */
+	cea_channels.channels.FL = speaker_flags.FL_FR;
+	cea_channels.channels.FR = speaker_flags.FL_FR;
+	cea_channels.channels.LFE = speaker_flags.LFE;
+	cea_channels.channels.FC = speaker_flags.FC;
+
+	/* if Rear Left and Right exist move RC speaker to channel 7
+	 * otherwise to channel 5
+	 */
+	if (speaker_flags.RL_RR) {
+		cea_channels.channels.RL_RC = speaker_flags.RL_RR;
+		cea_channels.channels.RR = speaker_flags.RL_RR;
+		cea_channels.channels.RC_RLC_FLC = speaker_flags.RC;
+	} else {
+		cea_channels.channels.RL_RC = speaker_flags.RC;
+	}
+
+	/* FRONT Left Right Center and REAR Left Right Center are exclusive */
+	if (speaker_flags.FLC_FRC) {
+		cea_channels.channels.RC_RLC_FLC = speaker_flags.FLC_FRC;
+		cea_channels.channels.RRC_FRC = speaker_flags.FLC_FRC;
+	} else {
+		cea_channels.channels.RC_RLC_FLC = speaker_flags.RLC_RRC;
+		cea_channels.channels.RRC_FRC = speaker_flags.RLC_RRC;
+	}
+
+	return cea_channels;
+}
+
+uint32_t calc_max_audio_packets_per_line(
+	const struct audio_crtc_info *crtc_info)
+{
+	uint32_t max_packets_per_line;
+
+	max_packets_per_line =
+		crtc_info->h_total - crtc_info->h_active;
+
+	if (crtc_info->pixel_repetition)
+		max_packets_per_line *= crtc_info->pixel_repetition;
+
+	/* for other hdmi features */
+	max_packets_per_line -= 58;
+	/* for Control Period */
+	max_packets_per_line -= 16;
+	/* Number of Audio Packets per Line */
+	max_packets_per_line /= 32;
+
+	return max_packets_per_line;
+}
+
+bool get_audio_clock_info(
+	enum dc_color_depth color_depth,
+	uint32_t crtc_pixel_clock_in_khz,
+	uint32_t actual_pixel_clock_in_khz,
+	struct audio_clock_info *audio_clock_info)
+{
+	const struct audio_clock_info *clock_info;
+	uint32_t index;
+	uint32_t crtc_pixel_clock_in_10khz = crtc_pixel_clock_in_khz / 10;
+	uint32_t audio_array_size;
+
+	if (audio_clock_info == NULL)
+		return false; /* should not happen */
+
+	switch (color_depth) {
+	case COLOR_DEPTH_161616:
+		clock_info = audio_clock_info_table_48bpc;
+		audio_array_size = ARRAY_SIZE(
+				audio_clock_info_table_48bpc);
+		break;
+	case COLOR_DEPTH_121212:
+		clock_info = audio_clock_info_table_36bpc;
+		audio_array_size = ARRAY_SIZE(
+				audio_clock_info_table_36bpc);
+		break;
+	default:
+		clock_info = audio_clock_info_table;
+		audio_array_size = ARRAY_SIZE(
+				audio_clock_info_table);
+		break;
+	}
+
+	if (clock_info != NULL) {
+		/* search for exact pixel clock in table */
+		for (index = 0; index < audio_array_size; index++) {
+			if (clock_info[index].pixel_clock_in_10khz >
+				crtc_pixel_clock_in_10khz)
+				break;  /* not match */
+			else if (clock_info[index].pixel_clock_in_10khz ==
+					crtc_pixel_clock_in_10khz) {
+				/* match found */
+				if (audio_clock_info != NULL) {
+					*audio_clock_info = clock_info[index];
+					return true;
+				}
+			}
+		}
+	}
+
+	/* not found */
+	if (actual_pixel_clock_in_khz == 0)
+		actual_pixel_clock_in_khz = crtc_pixel_clock_in_khz;
+
+	/* See HDMI spec  the table entry under
+	 *  pixel clock of "Other". */
+	audio_clock_info->pixel_clock_in_10khz =
+			actual_pixel_clock_in_khz / 10;
+	audio_clock_info->cts_32khz = actual_pixel_clock_in_khz;
+	audio_clock_info->cts_44khz = actual_pixel_clock_in_khz;
+	audio_clock_info->cts_48khz = actual_pixel_clock_in_khz;
+
+	audio_clock_info->n_32khz = 4096;
+	audio_clock_info->n_44khz = 6272;
+	audio_clock_info->n_48khz = 6144;
+
+	return true;
+}
+
+static void dce110_se_audio_setup(
+	struct stream_encoder *enc,
+	unsigned int az_inst,
+	struct audio_info *audio_info)
+{
+	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
+
+	uint32_t speakers = 0;
+	uint32_t channels = 0;
+
+	ASSERT(audio_info);
+	if (audio_info == NULL)
+		/* This should not happen.it does so we don't get BSOD*/
+		return;
+
+	speakers = audio_info->flags.info.ALLSPEAKERS;
+	channels = speakers_to_channels(audio_info->flags.speaker_flags).all;
+
+	/* setup the audio stream source select (audio -> dig mapping) */
+	LINK_REG_SET(AFMT_AUDIO_SRC_CONTROL, AFMT_AUDIO_SRC_SELECT, az_inst);
+
+	/* Channel allocation */
+	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL2, AFMT_AUDIO_CHANNEL_ENABLE, channels);
+}
+
+static void dce110_se_setup_hdmi_audio(
+	struct stream_encoder *enc,
+	const struct audio_crtc_info *crtc_info)
+{
+	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
+
+	struct audio_clock_info audio_clock_info = {0};
+	uint32_t max_packets_per_line;
+	uint32_t addr = 0;
+	uint32_t value = 0;
+
+	/* For now still do calculation, although this field is ignored when
+	above HDMI_PACKET_GEN_VERSION set to 1 */
+	max_packets_per_line = calc_max_audio_packets_per_line(crtc_info);
+
+	/* HDMI_AUDIO_PACKET_CONTROL */
+	LINK_REG_UPDATE_N(HDMI_AUDIO_PACKET_CONTROL, 2,
+			FD(HDMI_AUDIO_PACKET_CONTROL__HDMI_AUDIO_PACKETS_PER_LINE), max_packets_per_line,
+			FD(HDMI_AUDIO_PACKET_CONTROL__HDMI_AUDIO_DELAY_EN), 1);
+
+	/* AFMT_AUDIO_PACKET_CONTROL */
+	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);
+
+	/* AFMT_AUDIO_PACKET_CONTROL2 */
+	LINK_REG_UPDATE_N(AFMT_AUDIO_PACKET_CONTROL2, 2,
+			FD(AFMT_AUDIO_PACKET_CONTROL2__AFMT_AUDIO_LAYOUT_OVRD), 0,
+			FD(AFMT_AUDIO_PACKET_CONTROL2__AFMT_60958_OSF_OVRD), 0);
+
+	/* HDMI_ACR_PACKET_CONTROL */
+	LINK_REG_UPDATE_N(HDMI_ACR_PACKET_CONTROL, 3,
+			FD(HDMI_ACR_PACKET_CONTROL__HDMI_ACR_AUTO_SEND), 1,
+			FD(HDMI_ACR_PACKET_CONTROL__HDMI_ACR_SOURCE), 0,
+			FD(HDMI_ACR_PACKET_CONTROL__HDMI_ACR_AUDIO_PRIORITY), 0);
+
+	/* Program audio clock sample/regeneration parameters */
+	if (get_audio_clock_info(
+		crtc_info->color_depth,
+		crtc_info->requested_pixel_clock,
+		crtc_info->calculated_pixel_clock,
+		&audio_clock_info)) {
+
+		/* HDMI_ACR_32_0__HDMI_ACR_CTS_32_MASK */
+		LINK_REG_UPDATE(HDMI_ACR_32_0, HDMI_ACR_CTS_32, audio_clock_info.cts_32khz);
+
+		/* HDMI_ACR_32_1__HDMI_ACR_N_32_MASK */
+		LINK_REG_UPDATE(HDMI_ACR_32_1, HDMI_ACR_N_32, audio_clock_info.n_32khz);
+
+		/* HDMI_ACR_44_0__HDMI_ACR_CTS_44_MASK */
+		LINK_REG_UPDATE(HDMI_ACR_44_0, HDMI_ACR_CTS_44, audio_clock_info.cts_44khz);
+
+		/* HDMI_ACR_44_1__HDMI_ACR_N_44_MASK */
+		LINK_REG_UPDATE(HDMI_ACR_44_1, HDMI_ACR_N_44, audio_clock_info.n_44khz);
+
+		/* HDMI_ACR_48_0__HDMI_ACR_CTS_48_MASK */
+		LINK_REG_UPDATE(HDMI_ACR_48_0, HDMI_ACR_CTS_48, audio_clock_info.cts_48khz);
+
+		/* HDMI_ACR_48_1__HDMI_ACR_N_48_MASK */
+		LINK_REG_UPDATE(HDMI_ACR_48_1, HDMI_ACR_N_48, audio_clock_info.n_48khz);
+
+		/* Video driver cannot know in advance which sample rate will
+		be used by HD Audio driver
+		HDMI_ACR_PACKET_CONTROL__HDMI_ACR_N_MULTIPLE field is
+		programmed below in interruppt callback */
+	} /* if */
+
+	/* AFMT_60958_0__AFMT_60958_CS_CHANNEL_NUMBER_L_MASK &
+	AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY_MASK */
+	LINK_REG_UPDATE_N(AFMT_60958_0, 2,
+			FD(AFMT_60958_0__AFMT_60958_CS_CHANNEL_NUMBER_L), 1,
+			FD(AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY), 0);
+
+	/* AFMT_60958_1 AFMT_60958_CS_CHALNNEL_NUMBER_R */
+	LINK_REG_UPDATE(AFMT_60958_1, AFMT_60958_CS_CHANNEL_NUMBER_R, 2);
+
+	/*AFMT_60958_2 now keep this settings until
+	 *  Programming guide comes out*/
+	LINK_REG_UPDATE_N(AFMT_60958_2, 6,
+			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_2), 3,
+			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_3), 4,
+			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_4), 5,
+			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_5), 6,
+			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_6), 7,
+			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_7), 8);
+}
+
 static void dce110_se_setup_dp_audio(
 	struct stream_encoder *enc)
 {
@@ -1212,6 +1601,14 @@ void dce110_se_audio_mute_control(
 	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_AUDIO_SAMPLE_SEND, !mute);
 }
 
+void dce110_se_dp_audio_setup(
+	struct stream_encoder *enc,
+	unsigned int az_inst,
+	struct audio_info *info)
+{
+	dce110_se_audio_setup(enc, az_inst, info);
+}
+
 void dce110_se_dp_audio_enable(
 	struct stream_encoder *enc)
 {
@@ -1227,6 +1624,22 @@ void dce110_se_dp_audio_disable(
 	dce110_se_enable_audio_clock(enc, false);
 }
 
+void dce110_se_hdmi_audio_setup(
+	struct stream_encoder *enc,
+	unsigned int az_inst,
+	struct audio_info *info,
+	struct audio_crtc_info *audio_crtc_info)
+{
+	dce110_se_enable_audio_clock(enc, true);
+	dce110_se_setup_hdmi_audio(enc, audio_crtc_info);
+	dce110_se_audio_setup(enc, az_inst, info);
+}
+
+void dce110_se_hdmi_audio_disable(
+	struct stream_encoder *enc)
+{
+	dce110_se_enable_audio_clock(enc, false);
+}
 
 static const struct stream_encoder_funcs dce110_str_enc_funcs = {
 	.dp_set_stream_attribute =
@@ -1251,8 +1664,13 @@ static const struct stream_encoder_funcs dce110_str_enc_funcs = {
 		dce110_stream_encoder_dp_unblank,
 
 	.audio_mute_control = dce110_se_audio_mute_control,
+
+	.dp_audio_setup = dce110_se_dp_audio_setup,
 	.dp_audio_enable = dce110_se_dp_audio_enable,
 	.dp_audio_disable = dce110_se_dp_audio_disable,
+
+	.hdmi_audio_setup = dce110_se_hdmi_audio_setup,
+	.hdmi_audio_disable = dce110_se_hdmi_audio_disable,
 };
 
 bool dce110_stream_encoder_construct(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
index 0ea5257..325f807 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
@@ -31,6 +31,54 @@
 #define DCE110STRENC_FROM_STRENC(stream_encoder)\
 	container_of(stream_encoder, struct dce110_stream_encoder, base)
 
+#define SE_REG(reg_name, block_prefix, id)\
+	.reg_name = block_prefix ## id ## _ ## reg_name\
+
+#define SE_COMMON_REG_LIST(id)\
+	.AFMT_AVI_INFO0 = mmDIG ## id ## _AFMT_AVI_INFO0,\
+	.AFMT_AVI_INFO1 = mmDIG ## id ## _AFMT_AVI_INFO1,\
+	.AFMT_AVI_INFO2 = mmDIG ## id ## _AFMT_AVI_INFO2,\
+	.AFMT_AVI_INFO3 = mmDIG ## id ## _AFMT_AVI_INFO3,\
+	.AFMT_GENERIC_0 = mmDIG ## id ## _AFMT_GENERIC_0,\
+	.AFMT_GENERIC_7 = mmDIG ## id ## _AFMT_GENERIC_7,\
+	.AFMT_GENERIC_HDR = mmDIG ## id ## _AFMT_GENERIC_HDR,\
+	.AFMT_INFOFRAME_CONTROL0 = mmDIG ## id ## _AFMT_INFOFRAME_CONTROL0,\
+	.AFMT_VBI_PACKET_CONTROL = mmDIG ## id ## _AFMT_VBI_PACKET_CONTROL,\
+	.AFMT_AUDIO_PACKET_CONTROL = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL,\
+	.AFMT_AUDIO_PACKET_CONTROL2 = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL2,\
+	.AFMT_AUDIO_SRC_CONTROL = mmDIG ## id ## _AFMT_AUDIO_SRC_CONTROL,\
+	.AFMT_60958_0 = mmDIG ## id ## _AFMT_60958_0,\
+	.AFMT_60958_1 = mmDIG ## id ## _AFMT_60958_1,\
+	.AFMT_60958_2 = mmDIG ## id ## _AFMT_60958_2,\
+	.DIG_FE_CNTL = mmDIG ## id ## _DIG_FE_CNTL,\
+	.DP_MSE_RATE_CNTL = mmDP ## id ## _DP_MSE_RATE_CNTL,\
+	.DP_MSE_RATE_UPDATE = mmDP ## id ## _DP_MSE_RATE_UPDATE,\
+	.DP_PIXEL_FORMAT = mmDP ## id ## _DP_PIXEL_FORMAT,\
+	.DP_SEC_CNTL = mmDP ## id ## _DP_SEC_CNTL,\
+	.DP_STEER_FIFO = mmDP ## id ## _DP_STEER_FIFO,\
+	.DP_VID_M = mmDP ## id ## _DP_VID_M,\
+	.DP_VID_N = mmDP ## id ## _DP_VID_N,\
+	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL,\
+	.DP_VID_TIMING = mmDP ## id ## _DP_VID_TIMING,\
+	.DP_SEC_AUD_N = mmDP ## id ## _DP_SEC_AUD_N,\
+	.DP_SEC_TIMESTAMP = mmDP ## id ## _DP_SEC_TIMESTAMP,\
+	.HDMI_CONTROL = mmDIG ## id ## _HDMI_CONTROL,\
+	.HDMI_GC = mmDIG ## id ## _HDMI_GC,\
+	.HDMI_GENERIC_PACKET_CONTROL0 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL0,\
+	.HDMI_GENERIC_PACKET_CONTROL1 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL1,\
+	.HDMI_INFOFRAME_CONTROL0 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL0,\
+	.HDMI_INFOFRAME_CONTROL1 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL1,\
+	.HDMI_VBI_PACKET_CONTROL = mmDIG ## id ## _HDMI_VBI_PACKET_CONTROL,\
+	SE_REG(HDMI_AUDIO_PACKET_CONTROL, mmDIG, id),\
+	SE_REG(HDMI_ACR_PACKET_CONTROL, mmDIG, id),\
+	SE_REG(HDMI_ACR_32_0, mmDIG, id),\
+	SE_REG(HDMI_ACR_32_1, mmDIG, id),\
+	SE_REG(HDMI_ACR_44_0, mmDIG, id),\
+	SE_REG(HDMI_ACR_44_1, mmDIG, id),\
+	SE_REG(HDMI_ACR_48_0, mmDIG, id),\
+	SE_REG(HDMI_ACR_48_1, mmDIG, id),\
+	.TMDS_CNTL = mmDIG ## id ## _TMDS_CNTL,
+
 struct dce110_stream_enc_registers {
 	uint32_t AFMT_CNTL;
 	uint32_t AFMT_AVI_INFO0;
@@ -44,7 +92,10 @@ struct dce110_stream_enc_registers {
 	uint32_t AFMT_VBI_PACKET_CONTROL;
 	uint32_t AFMT_AUDIO_PACKET_CONTROL;
 	uint32_t AFMT_AUDIO_PACKET_CONTROL2;
+	uint32_t AFMT_AUDIO_SRC_CONTROL;
 	uint32_t AFMT_60958_0;
+	uint32_t AFMT_60958_1;
+	uint32_t AFMT_60958_2;
 	uint32_t DIG_FE_CNTL;
 	uint32_t DP_MSE_RATE_CNTL;
 	uint32_t DP_MSE_RATE_UPDATE;
@@ -64,6 +115,14 @@ struct dce110_stream_enc_registers {
 	uint32_t HDMI_INFOFRAME_CONTROL0;
 	uint32_t HDMI_INFOFRAME_CONTROL1;
 	uint32_t HDMI_VBI_PACKET_CONTROL;
+	uint32_t HDMI_AUDIO_PACKET_CONTROL;
+	uint32_t HDMI_ACR_PACKET_CONTROL;
+	uint32_t HDMI_ACR_32_0;
+	uint32_t HDMI_ACR_32_1;
+	uint32_t HDMI_ACR_44_0;
+	uint32_t HDMI_ACR_44_1;
+	uint32_t HDMI_ACR_48_0;
+	uint32_t HDMI_ACR_48_1;
 	uint32_t TMDS_CNTL;
 };
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index b691d36..aea0192 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -264,42 +264,10 @@ static const struct dce110_link_enc_registers link_enc_regs[] = {
 	link_regs(4),
 	link_regs(5)
 };
-
 #define stream_enc_regs(id)\
 [id] = {\
+	SE_COMMON_REG_LIST(id)\
 	.AFMT_CNTL = mmDIG ## id ## _AFMT_CNTL,\
-	.AFMT_AVI_INFO0 = mmDIG ## id ## _AFMT_AVI_INFO0,\
-	.AFMT_AVI_INFO1 = mmDIG ## id ## _AFMT_AVI_INFO1,\
-	.AFMT_AVI_INFO2 = mmDIG ## id ## _AFMT_AVI_INFO2,\
-	.AFMT_AVI_INFO3 = mmDIG ## id ## _AFMT_AVI_INFO3,\
-	.AFMT_GENERIC_0 = mmDIG ## id ## _AFMT_GENERIC_0,\
-	.AFMT_GENERIC_7 = mmDIG ## id ## _AFMT_GENERIC_7,\
-	.AFMT_GENERIC_HDR = mmDIG ## id ## _AFMT_GENERIC_HDR,\
-	.AFMT_INFOFRAME_CONTROL0 = mmDIG ## id ## _AFMT_INFOFRAME_CONTROL0,\
-	.AFMT_VBI_PACKET_CONTROL = mmDIG ## id ## _AFMT_VBI_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL2 = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL2,\
-	.AFMT_60958_0 = mmDIG ## id ## _AFMT_60958_0,\
-	.DIG_FE_CNTL = mmDIG ## id ## _DIG_FE_CNTL,\
-	.DP_MSE_RATE_CNTL = mmDP ## id ## _DP_MSE_RATE_CNTL,\
-	.DP_MSE_RATE_UPDATE = mmDP ## id ## _DP_MSE_RATE_UPDATE,\
-	.DP_PIXEL_FORMAT = mmDP ## id ## _DP_PIXEL_FORMAT,\
-	.DP_SEC_CNTL = mmDP ## id ## _DP_SEC_CNTL,\
-	.DP_STEER_FIFO = mmDP ## id ## _DP_STEER_FIFO,\
-	.DP_VID_M = mmDP ## id ## _DP_VID_M,\
-	.DP_VID_N = mmDP ## id ## _DP_VID_N,\
-	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL,\
-	.DP_VID_TIMING = mmDP ## id ## _DP_VID_TIMING,\
-	.DP_SEC_AUD_N = mmDP ## id ## _DP_SEC_AUD_N,\
-	.DP_SEC_TIMESTAMP = mmDP ## id ## _DP_SEC_TIMESTAMP,\
-	.HDMI_CONTROL = mmDIG ## id ## _HDMI_CONTROL,\
-	.HDMI_GC = mmDIG ## id ## _HDMI_GC,\
-	.HDMI_GENERIC_PACKET_CONTROL0 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL0,\
-	.HDMI_GENERIC_PACKET_CONTROL1 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL1,\
-	.HDMI_INFOFRAME_CONTROL0 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL0,\
-	.HDMI_INFOFRAME_CONTROL1 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL1,\
-	.HDMI_VBI_PACKET_CONTROL = mmDIG ## id ## _HDMI_VBI_PACKET_CONTROL,\
-	.TMDS_CNTL = mmDIG ## id ## _TMDS_CNTL,\
 }
 
 static const struct dce110_stream_enc_registers stream_enc_regs[] = {
@@ -311,6 +279,21 @@ static const struct dce110_stream_enc_registers stream_enc_regs[] = {
 	stream_enc_regs(5)
 };
 
+#define audio_regs(id)\
+[id] = {\
+	AUD_COMMON_REG_LIST(id)\
+}
+
+static const struct dce110_audio_registers audio_regs[] = {
+	audio_regs(0),
+	audio_regs(1),
+	audio_regs(2),
+	audio_regs(3),
+	audio_regs(4),
+	audio_regs(5),
+	audio_regs(6),
+};
+
 static const struct dce110_opp_reg_offsets dce112_opp_reg_offsets[] = {
 {
 	.fmt_offset = (mmFMT0_FMT_CONTROL - mmFMT0_FMT_CONTROL),
@@ -1255,6 +1238,9 @@ static bool construct(
                 }
 
                 audio_init_data.audio_stream_id = obj_id;
+                audio_init_data.inst = i;
+                audio_init_data.reg = &audio_regs[i];
+
 		pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
                 if (pool->base.audios[i] == NULL) {
                         BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 88a31d7..54a8589 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -46,6 +46,7 @@
 #include "dce110/dce110_ipp.h"
 #include "dce110/dce110_clock_source.h"
 #include "audio/dce80/audio_dce80.h"
+#include "audio/dce110/audio_dce110.h"
 
 #include "dce80/dce80_hw_sequencer.h"
 
@@ -272,39 +273,7 @@ static const struct dce110_link_enc_registers link_enc_regs[] = {
 
 #define stream_enc_regs(id)\
 [id] = {\
-	.AFMT_AVI_INFO0 = mmDIG ## id ## _AFMT_AVI_INFO0,\
-	.AFMT_AVI_INFO1 = mmDIG ## id ## _AFMT_AVI_INFO1,\
-	.AFMT_AVI_INFO2 = mmDIG ## id ## _AFMT_AVI_INFO2,\
-	.AFMT_AVI_INFO3 = mmDIG ## id ## _AFMT_AVI_INFO3,\
-	.AFMT_GENERIC_0 = mmDIG ## id ## _AFMT_GENERIC_0,\
-	.AFMT_GENERIC_7 = mmDIG ## id ## _AFMT_GENERIC_7,\
-	.AFMT_GENERIC_HDR = mmDIG ## id ## _AFMT_GENERIC_HDR,\
-	.AFMT_INFOFRAME_CONTROL0 = mmDIG ## id ## _AFMT_INFOFRAME_CONTROL0,\
-	.AFMT_VBI_PACKET_CONTROL = mmDIG ## id ## _AFMT_VBI_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL,\
-	.AFMT_AUDIO_PACKET_CONTROL2 = mmDIG ## id ## _AFMT_AUDIO_PACKET_CONTROL2,\
-	.AFMT_60958_0 = mmDIG ## id ## _AFMT_60958_0,\
-	.DIG_FE_CNTL = mmDIG ## id ## _DIG_FE_CNTL,\
-	.DP_MSE_RATE_CNTL = mmDP ## id ## _DP_MSE_RATE_CNTL,\
-	.DP_MSE_RATE_UPDATE = mmDP ## id ## _DP_MSE_RATE_UPDATE,\
-	.DP_PIXEL_FORMAT = mmDP ## id ## _DP_PIXEL_FORMAT,\
-	.DP_SEC_CNTL = mmDP ## id ## _DP_SEC_CNTL,\
-	.DP_STEER_FIFO = mmDP ## id ## _DP_STEER_FIFO,\
-	.DP_VID_M = mmDP ## id ## _DP_VID_M,\
-	.DP_VID_N = mmDP ## id ## _DP_VID_N,\
-	.DP_VID_STREAM_CNTL = mmDP ## id ## _DP_VID_STREAM_CNTL,\
-	.DP_VID_TIMING = mmDP ## id ## _DP_VID_TIMING,\
-	.DP_SEC_AUD_N = mmDP ## id ## _DP_SEC_AUD_N,\
-	.DP_SEC_TIMESTAMP = mmDP ## id ## _DP_SEC_TIMESTAMP,\
-	.HDMI_CONTROL = mmDIG ## id ## _HDMI_CONTROL,\
-	.HDMI_GC = mmDIG ## id ## _HDMI_GC,\
-	.HDMI_GENERIC_PACKET_CONTROL0 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL0,\
-	.HDMI_GENERIC_PACKET_CONTROL1 = mmDIG ## id ## _HDMI_GENERIC_PACKET_CONTROL1,\
-	.HDMI_INFOFRAME_CONTROL0 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL0,\
-	.HDMI_INFOFRAME_CONTROL1 = mmDIG ## id ## _HDMI_INFOFRAME_CONTROL1,\
-	.HDMI_VBI_PACKET_CONTROL = mmDIG ## id ## _HDMI_VBI_PACKET_CONTROL,\
-	.TMDS_CNTL = mmDIG ## id ## _TMDS_CNTL,\
-	\
+	SE_COMMON_REG_LIST(id)\
 	.AFMT_CNTL = 0,\
 }
 
@@ -317,6 +286,21 @@ static const struct dce110_stream_enc_registers stream_enc_regs[] = {
 	stream_enc_regs(5)
 };
 
+#define audio_regs(id)\
+[id] = {\
+	AUD_COMMON_REG_LIST(id)\
+}
+
+static const struct dce110_audio_registers audio_regs[] = {
+	audio_regs(0),
+	audio_regs(1),
+	audio_regs(2),
+	audio_regs(3),
+	audio_regs(4),
+	audio_regs(5),
+	audio_regs(6),
+};
+
 static const struct dce110_clk_src_reg_offsets dce80_clk_src_reg_offsets[] = {
 	{
 		.pll_cntl = mmDCCG_PLL0_PLL_CNTL,
@@ -880,6 +864,9 @@ static bool construct(
                 }
 
                 audio_init_data.audio_stream_id = obj_id;
+                audio_init_data.inst = i;
+                audio_init_data.reg = &audio_regs[i];
+
 		pool->base.audios[i] = dal_audio_create_dce80(&audio_init_data);
                 if (pool->base.audios[i] == NULL) {
                         BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
index 989b7bc..e6b74ec 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
@@ -55,38 +55,65 @@ struct stream_encoder_funcs {
 	void (*dp_set_stream_attribute)(
 		struct stream_encoder *enc,
 		struct dc_crtc_timing *crtc_timing);
+
 	void (*hdmi_set_stream_attribute)(
 		struct stream_encoder *enc,
 		struct dc_crtc_timing *crtc_timing,
 		int actual_pix_clk_khz,
 		bool enable_audio);
+
 	void (*dvi_set_stream_attribute)(
 		struct stream_encoder *enc,
 		struct dc_crtc_timing *crtc_timing,
 		bool is_dual_link);
+
 	void (*set_mst_bandwidth)(
 		struct stream_encoder *enc,
 		struct fixed31_32 avg_time_slots_per_mtp);
+
 	void (*update_hdmi_info_packets)(
 		struct stream_encoder *enc,
 		const struct encoder_info_frame *info_frame);
+
 	void (*stop_hdmi_info_packets)(
 		struct stream_encoder *enc);
+
 	void (*update_dp_info_packets)(
 		struct stream_encoder *enc,
 		const struct encoder_info_frame *info_frame);
+
 	void (*stop_dp_info_packets)(
 		struct stream_encoder *enc);
+
 	void (*dp_blank)(
 		struct stream_encoder *enc);
+
 	void (*dp_unblank)(
 		struct stream_encoder *enc,
 		const struct encoder_unblank_param *param);
 
 	void (*audio_mute_control)(
 		struct stream_encoder *enc, bool mute);
-	void (*dp_audio_enable) (struct stream_encoder *enc);
-	void (*dp_audio_disable) (struct stream_encoder *enc);
+
+	void (*dp_audio_setup)(
+		struct stream_encoder *enc,
+		unsigned int az_inst,
+		struct audio_info *info);
+
+	void (*dp_audio_enable) (
+			struct stream_encoder *enc);
+
+	void (*dp_audio_disable) (
+			struct stream_encoder *enc);
+
+	void (*hdmi_audio_setup)(
+		struct stream_encoder *enc,
+		unsigned int az_inst,
+		struct audio_info *info,
+		struct audio_crtc_info *audio_crtc_info);
+
+	void (*hdmi_audio_disable) (
+			struct stream_encoder *enc);
 };
 
 #endif /* STREAM_ENCODER_H_ */
diff --git a/drivers/gpu/drm/amd/dal/include/audio_interface.h b/drivers/gpu/drm/amd/dal/include/audio_interface.h
index 6d3b436..5014a13 100644
--- a/drivers/gpu/drm/amd/dal/include/audio_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/audio_interface.h
@@ -45,6 +45,9 @@ struct dal_adapter_service;
 struct audio_init_data {
 	struct graphics_object_id audio_stream_id;
 	struct dc_context *ctx;
+
+	unsigned int inst;
+	const struct dce110_audio_registers *reg;
 };
 
 enum audio_result {
@@ -63,54 +66,8 @@ void dal_audio_destroy(
 enum audio_result dal_audio_power_up(
 	struct audio *audio);
 
-/* perform power down (shut down, stand by) */
-enum audio_result dal_audio_power_down(
-	struct audio *audio);
-
-/* setup audio */
-enum audio_result dal_audio_setup(
-	struct audio *audio,
-	struct audio_output *output,
-	struct audio_info *info);
-
-/* disable audio */
-enum audio_result dal_audio_disable_output(
-	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal);
-
-/* enable azalia audio endpoint */
-enum audio_result dal_audio_enable_azalia_audio_jack_presence(
-	struct audio *audio,
-	enum engine_id engine_id);
-
-/* disable azalia audio endpoint */
-enum audio_result dal_audio_disable_azalia_audio_jack_presence(
-	struct audio *audio,
-	enum engine_id engine_id);
-
-/* unmute audio */
-enum audio_result dal_audio_unmute(
-	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal);
-
-/* mute audio */
-enum audio_result dal_audio_mute(
-	struct audio *audio,
-	enum engine_id engine_id,
-	enum signal_type signal);
-
 /***** information interface *****/
 
-/* get audio bandwidth information */
-void dal_audio_check_audio_bandwidth(
-	struct audio *audio,
-	const struct audio_crtc_info *info,
-	uint32_t channel_count,
-	enum signal_type signal,
-	union audio_sample_rates *sample_rates);
-
 /* Update audio wall clock source */
 void dal_audio_setup_audio_wall_dto(
 	struct audio *audio,
diff --git a/drivers/gpu/drm/amd/dal/include/audio_types.h b/drivers/gpu/drm/amd/dal/include/audio_types.h
index 7cf9358..55044b3 100644
--- a/drivers/gpu/drm/amd/dal/include/audio_types.h
+++ b/drivers/gpu/drm/amd/dal/include/audio_types.h
@@ -33,19 +33,18 @@
 #define MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS 18
 #define MULTI_CHANNEL_SPLIT_NO_ASSO_INFO 0xFFFFFFFF
 
-struct audio_clock_info {
-	/* pixel clock frequency*/
-	uint32_t pixel_clock_in_10khz;
-	/* N - 32KHz audio */
-	uint32_t n_32khz;
-	/* CTS - 32KHz audio*/
-	uint32_t cts_32khz;
-	uint32_t n_44khz;
-	uint32_t cts_44khz;
-	uint32_t n_48khz;
-	uint32_t cts_48khz;
-};
 
+struct audio_crtc_info {
+	uint32_t h_total;
+	uint32_t h_active;
+	uint32_t v_active;
+	uint32_t pixel_repetition;
+	uint32_t requested_pixel_clock; /* in KHz */
+	uint32_t calculated_pixel_clock; /* in KHz */
+	uint32_t refresh_rate;
+	enum dc_color_depth color_depth;
+	bool interlaced;
+};
 struct azalia_clock_info {
 	uint32_t pixel_clock_in_10khz;
 	uint32_t audio_dto_phase;
@@ -63,32 +62,6 @@ enum audio_dto_source {
 	DTO_SOURCE_ID5
 };
 
-union audio_cea_channels {
-	uint8_t all;
-	struct audio_cea_channels_bits {
-		uint32_t FL:1;
-		uint32_t FR:1;
-		uint32_t LFE:1;
-		uint32_t FC:1;
-		uint32_t RL_RC:1;
-		uint32_t RR:1;
-		uint32_t RC_RLC_FLC:1;
-		uint32_t RRC_FRC:1;
-	} channels;
-};
-
-struct audio_crtc_info {
-	uint32_t h_total;
-	uint32_t h_active;
-	uint32_t v_active;
-	uint32_t pixel_repetition;
-	uint32_t requested_pixel_clock; /* in KHz */
-	uint32_t calculated_pixel_clock; /* in KHz */
-	uint32_t refresh_rate;
-	enum dc_color_depth color_depth;
-	bool interlaced;
-};
-
 /* PLL information required for AZALIA DTO calculation */
 
 struct audio_pll_info {
-- 
2.7.4

