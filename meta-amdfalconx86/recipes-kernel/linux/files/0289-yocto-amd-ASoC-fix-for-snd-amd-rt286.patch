This patch is a fix for AMD sound card driver and rt286 codec driver
for yocto

Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
diff -Naur a/drivers/gpu/drm/amd/include/bus/amd_gnb_bus.h b/drivers/gpu/drm/amd/include/bus/amd_gnb_bus.h
--- a/drivers/gpu/drm/amd/include/bus/amd_gnb_bus.h	2015-08-31 10:45:59.813081240 +0530
+++ b/drivers/gpu/drm/amd/include/bus/amd_gnb_bus.h	2015-08-31 11:09:24.141108777 +0530
@@ -62,6 +62,12 @@
 #define amd_gnb_parent_to_pci_device(x) container_of((x)->dev.parent, \
 						     struct pci_dev,  \
 						     dev)
+#define AMD_GNB_PARENT_IS_CARRIZO(x)					\
+	({ struct pci_dev *parent = amd_gnb_parent_to_pci_device(x);	\
+		parent->vendor == 0x1002 && parent->device == 0x9874; })
+#define AMD_GNB_PARENT_IS_AMUR(x)					\
+	({ struct pci_dev *parent = amd_gnb_parent_to_pci_device(x);	\
+		parent->vendor == 0x1002 && parent->device == 0x9890; })
 
 int amd_gnb_bus_register_device(struct amd_gnb_bus_dev *dev);
 void amd_gnb_bus_unregister_device(struct amd_gnb_bus_dev *dev);
diff -Naur a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
--- a/drivers/gpu/drm/Kconfig	2015-08-31 10:45:59.685081237 +0530
+++ b/drivers/gpu/drm/Kconfig	2015-08-31 11:09:24.141108777 +0530
@@ -145,6 +145,8 @@
 
 source "drivers/gpu/drm/amd/amdgpu/Kconfig"
 
+source "drivers/gpu/drm/amd/acp/Kconfig"
+
 source "drivers/gpu/drm/nouveau/Kconfig"
 
 config DRM_I810
diff -Naur a/include/sound/soc.h b/include/sound/soc.h
--- a/include/sound/soc.h	2015-08-31 10:45:56.097081167 +0530
+++ b/include/sound/soc.h	2015-08-31 11:09:24.149108777 +0530
@@ -458,12 +458,12 @@
 #endif
 
 /* codec register bit access */
-int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value);
 int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
-			       unsigned short reg, unsigned int mask,
+			       unsigned int reg, unsigned int mask,
 			       unsigned int value);
-int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value);
 
 int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
diff -Naur a/sound/soc/soc-core.c b/sound/soc/soc-core.c
--- a/sound/soc/soc-core.c	2015-08-31 10:45:58.313081210 +0530
+++ b/sound/soc/soc-core.c	2015-08-31 11:09:24.157108777 +0530
@@ -2314,7 +2314,7 @@
  *
  * Returns 1 for change, 0 for no change, or negative error code.
  */
-int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value)
 {
 	bool change;
@@ -2355,7 +2355,7 @@
  * Returns 1 for change else 0.
  */
 int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
-			       unsigned short reg, unsigned int mask,
+			       unsigned int reg, unsigned int mask,
 			       unsigned int value)
 {
 	int change;
@@ -2380,7 +2380,7 @@
  *
  * Returns 1 for change else 0.
  */
-int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value)
 {
 	int change;
@@ -2910,7 +2910,7 @@
 	int min = mc->min;
 	int mask = (1 << (fls(min + max) - 1)) - 1;
 	int err = 0;
-	unsigned short val, val_mask, val2 = 0;
+	unsigned int val, val_mask, val2 = 0;
 
 	val_mask = mask << shift;
 	val = (ucontrol->value.integer.value[0] + min) & mask;
diff -Naur a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
--- a/sound/soc/soc-dapm.c	2015-08-31 10:45:58.261081209 +0530
+++ b/sound/soc/soc-dapm.c	2015-08-31 11:09:24.161108778 +0530
@@ -251,6 +251,7 @@
 static void dapm_kcontrol_free(struct snd_kcontrol *kctl)
 {
 	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kctl);
+	kfree(data->widget);
 	kfree(data->wlist);
 	kfree(data);
 }
@@ -419,7 +420,7 @@
 }
 
 static int soc_widget_update_bits_locked(struct snd_soc_dapm_widget *w,
-	unsigned short reg, unsigned int mask, unsigned int value)
+	int reg, unsigned int mask, unsigned int value)
 {
 	bool change;
 	unsigned int old, new;
@@ -689,9 +690,9 @@
 	int shared;
 	struct snd_kcontrol *kcontrol;
 	bool wname_in_long_name, kcname_in_long_name;
-	char *long_name = NULL;
+	char *long_name;
 	const char *name;
-	int ret = 0;
+	int ret;
 
 	if (dapm->codec)
 		prefix = dapm->codec->name_prefix;
@@ -756,17 +757,15 @@
 
 		kcontrol = snd_soc_cnew(&w->kcontrol_news[kci], NULL, name,
 					prefix);
-		if (!kcontrol) {
-			ret = -ENOMEM;
-			goto exit_free;
-		}
-
+		kfree(long_name);
+		if (!kcontrol)
+			return -ENOMEM;
 		kcontrol->private_free = dapm_kcontrol_free;
 
 		ret = dapm_kcontrol_data_alloc(w, kcontrol);
 		if (ret) {
 			snd_ctl_free_one(kcontrol);
-			goto exit_free;
+			return ret;
 		}
 
 		ret = snd_ctl_add(card, kcontrol);
@@ -774,18 +773,17 @@
 			dev_err(dapm->dev,
 				"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",
 				w->name, name, ret);
-			goto exit_free;
+			return ret;
 		}
 	}
 
 	ret = dapm_kcontrol_add_widget(kcontrol, w);
-	if (ret == 0)
-		w->kcontrols[kci] = kcontrol;
+	if (ret)
+		return ret;
 
-exit_free:
-	kfree(long_name);
+	w->kcontrols[kci] = kcontrol;
 
-	return ret;
+	return 0;
 }
 
 /* create new dapm mixer control */
@@ -2891,19 +2889,22 @@
 	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
 
 	change = dapm_kcontrol_set_value(kcontrol, val);
+
+	if (reg != SND_SOC_NOPM) {
+		mask = mask << shift;
+		val = val << shift;
+
+		change = snd_soc_test_bits(codec, reg, mask, val);
+	}
+
 	if (change) {
 		if (reg != SND_SOC_NOPM) {
-			mask = mask << shift;
-			val = val << shift;
-
-			if (snd_soc_test_bits(codec, reg, mask, val)) {
-				update.kcontrol = kcontrol;
-				update.reg = reg;
-				update.mask = mask;
-				update.val = val;
-				card->update = &update;
-			}
+			update.kcontrol = kcontrol;
+			update.reg = reg;
+			update.mask = mask;
+			update.val = val;
 
+			card->update = &update;
 		}
 
 		ret = soc_dapm_mixer_update_power(card, kcontrol, connect);
@@ -3649,11 +3650,8 @@
 		cpu_dai = rtd->cpu_dai;
 		codec_dai = rtd->codec_dai;
 
-		/*
-		 * dynamic FE links have no fixed DAI mapping.
-		 * CODEC<->CODEC links have no direct connection.
-		 */
-		if (rtd->dai_link->dynamic || rtd->dai_link->params)
+		/* dynamic FE links have no fixed DAI mapping */
+		if (rtd->dai_link->dynamic)
 			continue;
 
 		/* there is no point in connecting BE DAI links with dummies */
diff -Naur a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
--- a/sound/soc/soc-pcm.c	2015-08-31 10:45:58.317081210 +0530
+++ b/sound/soc/soc-pcm.c	2015-08-31 11:09:24.161108778 +0530
@@ -1989,6 +1989,7 @@
 
 		paths = dpcm_path_get(fe, SNDRV_PCM_STREAM_PLAYBACK, &list);
 		if (paths < 0) {
+			dpcm_path_put(&list);
 			dev_warn(fe->dev, "ASoC: %s no valid %s path\n",
 					fe->dai_link->name,  "playback");
 			mutex_unlock(&card->mutex);
@@ -2011,7 +2012,6 @@
 			dpcm_be_disconnect(fe, SNDRV_PCM_STREAM_PLAYBACK);
 		}
 
-		dpcm_path_put(&list);
 capture:
 		/* skip if FE doesn't have capture capability */
 		if (!fe->cpu_dai->driver->capture.channels_min)
@@ -2019,6 +2019,7 @@
 
 		paths = dpcm_path_get(fe, SNDRV_PCM_STREAM_CAPTURE, &list);
 		if (paths < 0) {
+			dpcm_path_put(&list);
 			dev_warn(fe->dev, "ASoC: %s no valid %s path\n",
 					fe->dai_link->name,  "capture");
 			mutex_unlock(&card->mutex);
@@ -2083,6 +2084,7 @@
 	fe->dpcm[stream].runtime = fe_substream->runtime;
 
 	if (dpcm_path_get(fe, stream, &list) <= 0) {
+		dpcm_path_put(&list);
 		dev_dbg(fe->dev, "ASoC: %s no valid %s route\n",
 			fe->dai_link->name, stream ? "capture" : "playback");
 	}
