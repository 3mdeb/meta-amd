From 2b271c20e680a2c8e310f1d5cfedfa849dbba8dc Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Fri, 10 Jun 2016 11:43:29 -0400
Subject: [PATCH 0577/1722] drm/amd/dal: simplify timing sync implementation

Change-Id: I960f819e3b4eacc72496e2371ecd6cfaac7782dc
Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  4 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 41 +++++++-------
 .../amd/dal/dc/dce110/dce110_timing_generator.c    | 63 +++++++---------------
 .../amd/dal/dc/dce110/dce110_timing_generator.h    |  2 +-
 .../amd/dal/dc/dce110/dce110_timing_generator_v.c  |  2 +-
 .../drm/amd/dal/dc/dce80/dce80_timing_generator.c  |  1 +
 .../gpu/drm/amd/dal/dc/inc/hw/timing_generator.h   | 12 +----
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |  5 +-
 drivers/gpu/drm/amd/dal/include/grph_object_defs.h | 12 -----
 9 files changed, 48 insertions(+), 94 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 1d9842c..96455ed 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -482,6 +482,7 @@ static void program_timing_sync(
 		struct validate_context *ctx)
 {
         int i, j;
+        int group_index = 0;
         int pipe_count = ctx->res_ctx.pool->pipe_count;
         struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
         
@@ -518,7 +519,8 @@ static void program_timing_sync(
 
                 if (group_size > 1) {
                         core_dc->hwss.enable_timing_synchronization(
-                                                core_dc, group_size, pipe_set);
+                                core_dc, group_index, group_size, pipe_set);
+                        group_index++;
                 }
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 6c9da64..988453c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1488,54 +1488,49 @@ static bool wait_for_reset_trigger_to_occur(
 }
 
 /* Enable timing synchronization for a group of Timing Generators. */
-static void enable_timing_synchronization(
+static void dce110_enable_timing_synchronization(
 		struct core_dc *dc,
-		uint32_t group_size,
-		struct pipe_ctx *pipe_ctxs[])
+		int group_index,
+		int group_size,
+		struct pipe_ctx *grouped_pipes[])
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dcp_gsl_params gsl_params = { 0 };
-	struct trigger_params trigger_params;
-	uint32_t i;
+	int i;
 
 	DC_SYNC_INFO("GSL: Setting-up...\n");
 
+	/* Designate a single TG in the group as a master.
+	 * Since HW doesn't care which one, we always assign
+	 * the 1st one in the group. */
 	gsl_params.gsl_group = 0;
-	gsl_params.gsl_purpose = DCP_GSL_PURPOSE_SURFACE_FLIP;
-
-	for (i = 0; i < group_size; i++) {
-		/* Designate a single TG in the group as a master.
-		 * Since HW doesn't care which one, we always assign
-		 * the 1st one in the group. */
-		gsl_params.timing_server = (0 == i ? true : false);
+	gsl_params.gsl_master = grouped_pipes[0]->tg->inst;
 
-		pipe_ctxs[i]->tg->funcs->setup_global_swap_lock(pipe_ctxs[i]->tg, &gsl_params);
-	}
+	for (i = 0; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->setup_global_swap_lock(
+					grouped_pipes[i]->tg, &gsl_params);
 
 	/* Reset slave controllers on master VSync */
 	DC_SYNC_INFO("GSL: enabling trigger-reset\n");
-	memset(&trigger_params, 0, sizeof(trigger_params));
-
-	trigger_params.edge = TRIGGER_EDGE_DEFAULT;
-	trigger_params.source = SYNC_SOURCE_GSL_GROUP0;
 
 	for (i = 1 /* skip the master */; i < group_size; i++) {
-		pipe_ctxs[i]->tg->funcs->enable_reset_trigger(pipe_ctxs[i]->tg, &trigger_params);
+		grouped_pipes[i]->tg->funcs->enable_reset_trigger(
+					grouped_pipes[i]->tg, gsl_params.gsl_group);
 
 		DC_SYNC_INFO("GSL: waiting for reset to occur.\n");
-		wait_for_reset_trigger_to_occur(dc_ctx, pipe_ctxs[i]->tg);
+		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->tg);
 
 		/* Regardless of success of the wait above, remove the reset or
 		 * the driver will start timing out on Display requests. */
 		DC_SYNC_INFO("GSL: disabling trigger-reset.\n");
-		pipe_ctxs[i]->tg->funcs->disable_reset_trigger(pipe_ctxs[i]->tg);
+		grouped_pipes[i]->tg->funcs->disable_reset_trigger(grouped_pipes[i]->tg);
 	}
 
 	/* GSL Vblank synchronization is a one time sync mechanism, assumption
 	 * is that the sync'ed displays will not drift out of sync over time*/
 	DC_SYNC_INFO("GSL: Restoring register states.\n");
 	for (i = 0; i < group_size; i++)
-		pipe_ctxs[i]->tg->funcs->tear_down_global_swap_lock(pipe_ctxs[i]->tg);
+		grouped_pipes[i]->tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->tg);
 
 	DC_SYNC_INFO("GSL: Set-up complete.\n");
 }
@@ -1740,7 +1735,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_gamma_correction = set_gamma_ramp,
 	.power_down = power_down,
 	.enable_accelerated_mode = enable_accelerated_mode,
-	.enable_timing_synchronization = enable_timing_synchronization,
+	.enable_timing_synchronization = dce110_enable_timing_synchronization,
 	.program_bw = program_bw,
 	.enable_stream = enable_stream,
 	.disable_stream = disable_stream,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index d8891a6..bb12a57 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -1062,6 +1062,8 @@ bool dce110_timing_generator_construct(
 		return false;
 
 	tg110->controller_id = CONTROLLER_ID_D0 + instance;
+	tg110->base.inst = instance;
+
 	tg110->offsets = *offsets;
 
 	tg110->base.funcs = &dce110_tg_funcs;
@@ -1109,7 +1111,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 			DCP_GSL0_EN);
 
 	set_reg_field_value(value,
-			gsl_params->timing_server,
+			gsl_params->gsl_master == tg->inst,
 			DCP_GSL_CONTROL,
 			DCP_GSL_MASTER_EN);
 
@@ -1125,7 +1127,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 			DCP_GSL_CONTROL,
 			DCP_GSL_HSYNC_FLIP_CHECK_DELAY);
 
-	/* DCP_GSL_PURPOSE_SURFACE_FLIP */
+
 	{
 		uint32_t value_crtc_vtotal;
 
@@ -1133,7 +1135,7 @@ void dce110_timing_generator_setup_global_swap_lock(
 				CRTC_REG(mmCRTC_V_TOTAL));
 
 		set_reg_field_value(value,
-				gsl_params->gsl_purpose,
+				0,/* DCP_GSL_PURPOSE_SURFACE_FLIP */
 				DCP_GSL_CONTROL,
 				DCP_GSL_SYNC_SOURCE);
 
@@ -1350,60 +1352,33 @@ void dce110_timing_generator_set_lock_master(struct timing_generator *tg,
 
 void dce110_timing_generator_enable_reset_trigger(
 	struct timing_generator *tg,
-	const struct trigger_params *trigger_params)
+	int source_tg_inst)
 {
 	uint32_t value;
-	struct dc_context *dc_ctx = tg->ctx;
 	uint32_t rising_edge = 0;
 	uint32_t falling_edge = 0;
 	enum trigger_source_select trig_src_select = TRIGGER_SOURCE_SELECT_LOGIC_ZERO;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
 	/* Setup trigger edge */
-	switch (trigger_params->edge) {
-	/* Default = based on current timing polarity */
-	case TRIGGER_EDGE_DEFAULT:
-		{
-			uint32_t pol_value = dm_read_reg(tg->ctx,
-					CRTC_REG(mmCRTC_V_SYNC_A_CNTL));
-
-			/* Register spec has reversed definition:
-			 *	0 for positive, 1 for negative */
-			if (get_reg_field_value(pol_value,
-					CRTC_V_SYNC_A_CNTL,
-					CRTC_V_SYNC_A_POL) == 0) {
-				rising_edge = 1;
-			} else {
-				falling_edge = 1;
-			}
+	{
+		uint32_t pol_value = dm_read_reg(tg->ctx,
+				CRTC_REG(mmCRTC_V_SYNC_A_CNTL));
+
+		/* Register spec has reversed definition:
+		 *	0 for positive, 1 for negative */
+		if (get_reg_field_value(pol_value,
+				CRTC_V_SYNC_A_CNTL,
+				CRTC_V_SYNC_A_POL) == 0) {
+			rising_edge = 1;
+		} else {
+			falling_edge = 1;
 		}
-		break;
-	case TRIGGER_EDGE_RISING:
-		rising_edge = 1;
-		break;
-	case TRIGGER_EDGE_FALLING:
-		falling_edge = 1;
-		break;
-	case TRIGGER_EDGE_BOTH:
-		rising_edge = 1;
-		falling_edge = 1;
-		break;
-	default:
-		DC_ERROR("Invalid Trigger Edge!\n");
-		return;
 	}
 
 	value = dm_read_reg(tg->ctx, CRTC_REG(mmCRTC_TRIGB_CNTL));
 
-	switch(trigger_params->source) {
-	/* Currently supporting only a single group, the group zero. */
-	case SYNC_SOURCE_GSL_GROUP0:
-		trig_src_select = TRIGGER_SOURCE_SELECT_GSL_GROUP0;
-		break;
-	default:
-		DC_ERROR("Unsupported GSL Group!\n");
-		return;
-	}
+	trig_src_select = TRIGGER_SOURCE_SELECT_GSL_GROUP0;
 
 	set_reg_field_value(value,
 			trig_src_select,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
index 1d0749c..a3079ce 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
@@ -139,7 +139,7 @@ void dce110_timing_generator_tear_down_global_swap_lock(
 /* Reset slave controllers on master VSync */
 void dce110_timing_generator_enable_reset_trigger(
 	struct timing_generator *tg,
-	const struct trigger_params *trigger_params);
+	int source);
 
 /* disabling trigger-reset */
 void dce110_timing_generator_disable_reset_trigger(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
index c91b5b44..b959506 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
@@ -652,7 +652,7 @@ static void dce110_timing_generator_v_setup_global_swap_lock(
 
 static void dce110_timing_generator_v_enable_reset_trigger(
 	struct timing_generator *tg,
-	const struct trigger_params *trigger_params)
+	int source_tg_inst)
 {
 	dal_logger_write(tg->ctx->logger, LOG_MAJOR_ERROR,
 					LOG_MINOR_COMPONENT_CONTROLLER,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.c
index f33385c..9738d12 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_timing_generator.c
@@ -161,6 +161,7 @@ bool dce80_timing_generator_construct(
 		return false;
 
 	tg110->controller_id = CONTROLLER_ID_D0 + instance;
+	tg110->base.inst = instance;
 	tg110->offsets = *offsets;
 	tg110->derived_offsets = reg_offsets[instance];
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
index f8c8e3c..1c6d43b 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
@@ -44,16 +44,9 @@ struct crtc_position {
 	uint32_t nominal_vcount;
 };
 
-enum dcp_gsl_purpose {
-	DCP_GSL_PURPOSE_SURFACE_FLIP = 0,
-	DCP_GSL_PURPOSE_STEREO3D_PHASE,
-	DCP_GSL_PURPOSE_UNDEFINED
-};
-
 struct dcp_gsl_params {
-	enum dcp_gsl_purpose gsl_purpose;
 	int gsl_group;
-	bool timing_server;
+	int gsl_master;
 };
 
 #define LEFT_EYE_3D_PRIMARY_SURFACE 1
@@ -147,8 +140,7 @@ struct timing_generator_funcs {
 							const struct dcp_gsl_params *gsl_params);
 	void (*unlock)(struct timing_generator *tg);
 	void (*lock)(struct timing_generator *tg);
-	void (*enable_reset_trigger)(struct timing_generator *tg,
-						const struct trigger_params *trigger_params);
+	void (*enable_reset_trigger)(struct timing_generator *tg, int source_tg_inst);
 	void (*disable_reset_trigger)(struct timing_generator *tg);
 	void (*tear_down_global_swap_lock)(struct timing_generator *tg);
 	void (*enable_advanced_request)(struct timing_generator *tg,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 60163a5..5757cc7 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -82,8 +82,9 @@ struct hw_sequencer_funcs {
 
 	void (*enable_timing_synchronization)(
 			struct core_dc *dc,
-			uint32_t group_size,
-			struct pipe_ctx *pipe_ctxs[]);
+			int group_index,
+			int group_size,
+			struct pipe_ctx *grouped_pipes[]);
 
 	/* backlight control */
 	void (*encoder_set_lcd_backlight_level)(
diff --git a/drivers/gpu/drm/amd/dal/include/grph_object_defs.h b/drivers/gpu/drm/amd/dal/include/grph_object_defs.h
index 5547ae9..2941b88 100644
--- a/drivers/gpu/drm/amd/dal/include/grph_object_defs.h
+++ b/drivers/gpu/drm/amd/dal/include/grph_object_defs.h
@@ -136,17 +136,5 @@ enum sync_source {
 	SYNC_SOURCE_DUAL_GPU_PIN
 };
 
-enum trigger_edge {
-	TRIGGER_EDGE_RISING = 0,
-	TRIGGER_EDGE_FALLING,
-	TRIGGER_EDGE_BOTH,
-	TRIGGER_EDGE_DEFAULT
-};
-
-/* Parameters to enable CRTC trigger */
-struct trigger_params {
-	enum sync_source source;
-	enum trigger_edge edge;
-};
 
 #endif
-- 
2.7.4

