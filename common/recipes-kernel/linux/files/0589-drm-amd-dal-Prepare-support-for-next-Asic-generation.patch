From 52f9ede2646da29cec38ea3536c714eb8f60906c Mon Sep 17 00:00:00 2001
From: Jun Lei <Jun.Lei@amd.com>
Date: Thu, 3 Dec 2015 11:01:33 -0500
Subject: [PATCH 0589/1110] drm/amd/dal: Prepare support for next Asic
 generation

Support new atombios interfaces.
Clean up code as preparation for next Asic generation.

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland<harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/audio/audio_base.c      |   3 +
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c      | 723 ++++++++--------
 drivers/gpu/drm/amd/dal/dc/bios/command_table.c    | 912 +++++++++++++--------
 drivers/gpu/drm/amd/dal/dc/bios/command_table.h    |   3 +
 .../gpu/drm/amd/dal/dc/bios/command_table_helper.c |   2 +-
 .../gpu/drm/amd/dal/dc/bios/command_table_helper.h |   3 +
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |   2 +
 drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c      |   1 +
 drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h      |   4 +
 .../drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c   |   2 +
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   2 +-
 .../drm/amd/dal/include/bios_parser_interface.h    |   3 +
 .../gpu/drm/amd/dal/include/bios_parser_types.h    |  35 +
 drivers/gpu/drm/amd/dal/include/grph_object_id.h   |  19 +-
 14 files changed, 1010 insertions(+), 704 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
index 6bac3ed..f553b7a 100644
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
+++ b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
@@ -30,7 +30,10 @@
 #include "audio.h"
 #include "hw_ctx_audio.h"
 
+#if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
 #include "dce110/audio_dce110.h"
+#include "dce110/hw_ctx_audio_dce110.h"
+#endif
 
 /***** static function : only used within audio.c *****/
 
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
index 7a2b247..1d02be9 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
@@ -94,6 +94,7 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 	ATOM_OBJECT *object);
 static void process_ext_display_connection_info(struct bios_parser *bp);
 
+
 #define BIOS_IMAGE_SIZE_OFFSET 2
 #define BIOS_IMAGE_SIZE_UNIT 512
 
@@ -922,7 +923,7 @@ static enum bp_result get_firmware_info_v1_4(
 	/* Pixel clock pll information. We need to convert from 10KHz units into
 	 * KHz units */
 	info->pll_info.crystal_frequency =
-			le16_to_cpu(firmware_info->usReferenceClock) * 10;
+		le16_to_cpu(firmware_info->usReferenceClock) * 10;
 	info->pll_info.min_input_pxl_clk_pll_frequency =
 		le16_to_cpu(firmware_info->usMinPixelClockPLL_Input) * 10;
 	info->pll_info.max_input_pxl_clk_pll_frequency =
@@ -973,7 +974,7 @@ static enum bp_result get_firmware_info_v2_1(
 	/* Pixel clock pll information. We need to convert from 10KHz units into
 	 * KHz units */
 	info->pll_info.crystal_frequency =
-			le16_to_cpu(firmwareInfo->usCoreReferenceClock) * 10;
+		le16_to_cpu(firmwareInfo->usCoreReferenceClock) * 10;
 	info->pll_info.min_input_pxl_clk_pll_frequency =
 		le16_to_cpu(firmwareInfo->usMinPixelClockPLL_Input) * 10;
 	info->pll_info.max_input_pxl_clk_pll_frequency =
@@ -1059,7 +1060,7 @@ static enum bp_result get_firmware_info_v2_2(
 	/* Pixel clock pll information. We need to convert from 10KHz units into
 	 * KHz units */
 	info->pll_info.crystal_frequency =
-			le16_to_cpu(firmware_info->usCoreReferenceClock) * 10;
+		le16_to_cpu(firmware_info->usCoreReferenceClock) * 10;
 	info->pll_info.min_input_pxl_clk_pll_frequency =
 		le16_to_cpu(firmware_info->usMinPixelClockPLL_Input) * 10;
 	info->pll_info.max_input_pxl_clk_pll_frequency =
@@ -1082,10 +1083,10 @@ static enum bp_result get_firmware_info_v2_2(
 		/* unit of 0.01% */
 		info->feature.memory_clk_ss_percentage = THREE_PERCENT_OF_10000;
 	else if (get_ss_info_v3_1(bp,
-		ASIC_INTERNAL_MEMORY_SS, index, &internal_ss) == BP_RESULT_OK) {
+			ASIC_INTERNAL_MEMORY_SS, index, &internal_ss) == BP_RESULT_OK) {
 		if (internal_ss.spread_spectrum_percentage) {
 			info->feature.memory_clk_ss_percentage =
-				internal_ss.spread_spectrum_percentage;
+					internal_ss.spread_spectrum_percentage;
 			if (internal_ss.type.CENTER_MODE) {
 				/* if it is centermode, the exact SS Percentage
 				 * will be round up of half of the percentage
@@ -1105,10 +1106,10 @@ static enum bp_result get_firmware_info_v2_2(
 		/* unit of 0.01% */
 		info->feature.engine_clk_ss_percentage = THREE_PERCENT_OF_10000;
 	else if (get_ss_info_v3_1(bp,
-		ASIC_INTERNAL_ENGINE_SS, index, &internal_ss) == BP_RESULT_OK) {
+			ASIC_INTERNAL_ENGINE_SS, index, &internal_ss) == BP_RESULT_OK) {
 		if (internal_ss.spread_spectrum_percentage) {
 			info->feature.engine_clk_ss_percentage =
-				internal_ss.spread_spectrum_percentage;
+					internal_ss.spread_spectrum_percentage;
 			if (internal_ss.type.CENTER_MODE) {
 				/* if it is centermode, the exact SS Percentage
 				 * will be round up of half of the percentage
@@ -1126,7 +1127,7 @@ static enum bp_result get_firmware_info_v2_2(
 	info->min_allowed_bl_level = firmware_info->ucMinAllowedBL_Level;
 	/* Used starting from CI */
 	info->smu_gpu_pll_output_freq =
-		(uint32_t) (le32_to_cpu(firmware_info->ulGPUPLL_OutputFreq) * 10);
+			(uint32_t) (le32_to_cpu(firmware_info->ulGPUPLL_OutputFreq) * 10);
 
 	return BP_RESULT_OK;
 }
@@ -1153,11 +1154,11 @@ static enum bp_result get_ss_info_v3_1(
 		DATA_TABLES(ASIC_InternalSS_Info));
 	table_size =
 		(le16_to_cpu(ss_table_header_include->sHeader.usStructureSize)
-		- sizeof(ATOM_COMMON_TABLE_HEADER))
+				- sizeof(ATOM_COMMON_TABLE_HEADER))
 				/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);
 
 	tbl = (ATOM_ASIC_SS_ASSIGNMENT_V3 *)
-		&ss_table_header_include->asSpreadSpectrum[0];
+				&ss_table_header_include->asSpreadSpectrum[0];
 
 	dc_service_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
 
@@ -1193,17 +1194,17 @@ static enum bp_result get_ss_info_v3_1(
 
 		/* #define SS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK 0x10 */
 		if (SS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK
-			& tbl[i].ucSpreadSpectrumMode)
+				& tbl[i].ucSpreadSpectrumMode)
 			ss_info->spread_percentage_divider = 1000;
 
 		ss_info->type.STEP_AND_DELAY_INFO = false;
-		 /* convert [10KHz] into [KHz] */
+		/* convert [10KHz] into [KHz] */
 		ss_info->target_clock_range =
-			le32_to_cpu(tbl[i].ulTargetClockRange) * 10;
+				le32_to_cpu(tbl[i].ulTargetClockRange) * 10;
 		ss_info->spread_spectrum_percentage =
-			(uint32_t)le16_to_cpu(tbl[i].usSpreadSpectrumPercentage);
+				(uint32_t)le16_to_cpu(tbl[i].usSpreadSpectrumPercentage);
 		ss_info->spread_spectrum_range =
-			(uint32_t)(le16_to_cpu(tbl[i].usSpreadRateIn10Hz) * 10);
+				(uint32_t)(le16_to_cpu(tbl[i].usSpreadRateIn10Hz) * 10);
 
 		return BP_RESULT_OK;
 	}
@@ -1247,7 +1248,17 @@ enum bp_result dal_bios_parser_set_pixel_clock(
 	if (!bp->cmd_tbl.set_pixel_clock)
 		return BP_RESULT_FAILURE;
 
-		return bp->cmd_tbl.set_pixel_clock(bp, bp_params);
+	return bp->cmd_tbl.set_pixel_clock(bp, bp_params);
+}
+
+enum bp_result dal_bios_parser_set_dce_clock(
+	struct bios_parser *bp,
+	struct bp_set_dce_clock_parameters *bp_params)
+{
+	if (!bp->cmd_tbl.set_dce_clock)
+		return BP_RESULT_FAILURE;
+
+	return bp->cmd_tbl.set_dce_clock(bp, bp_params);
 }
 
 enum bp_result dal_bios_parser_enable_spread_spectrum_on_ppll(
@@ -1605,10 +1616,10 @@ enum bp_result dal_bios_parser_get_spread_spectrum_info(
 			break;
 		}
 		break;
-	default:
-		break;
+		default:
+			break;
 	}
-		/* there can not be more then one entry for SS Info table */
+	/* there can not be more then one entry for SS Info table */
 	return result;
 }
 
@@ -1673,11 +1684,11 @@ static enum bp_result get_ss_info_from_internal_ss_info_tbl_V2_1(
 	dc_service_memset(info, 0, sizeof(struct spread_spectrum_info));
 
 	tbl_size = (le16_to_cpu(header->sHeader.usStructureSize)
-		- sizeof(ATOM_COMMON_TABLE_HEADER))
-				/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);
+			- sizeof(ATOM_COMMON_TABLE_HEADER))
+					/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);
 
 	tbl = (ATOM_ASIC_SS_ASSIGNMENT_V2 *)
-				&(header->asSpreadSpectrum[0]);
+					&(header->asSpreadSpectrum[0]);
 	for (i = 0; i < tbl_size; i++) {
 		result = BP_RESULT_NORECORD;
 
@@ -1755,7 +1766,7 @@ static enum bp_result get_ss_info_from_ss_info_table(
 		struct embedded_panel_info panel_info;
 
 		if (dal_bios_parser_get_embedded_panel_info(bp, &panel_info)
-			== BP_RESULT_OK)
+				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
 	}
@@ -1767,8 +1778,8 @@ static enum bp_result get_ss_info_from_ss_info_table(
 		return result;
 
 	table_size = (le16_to_cpu(tbl->sHeader.usStructureSize) -
-		sizeof(ATOM_COMMON_TABLE_HEADER)) /
-			sizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);
+			sizeof(ATOM_COMMON_TABLE_HEADER)) /
+					sizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);
 
 	for (i = 0; i < table_size; i++) {
 		if (id_local != (uint32_t)tbl->asSS_Info[i].ucSS_Id)
@@ -1777,11 +1788,11 @@ static enum bp_result get_ss_info_from_ss_info_table(
 		dc_service_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
 
 		if (ATOM_EXTERNAL_SS_MASK &
-			tbl->asSS_Info[i].ucSpreadSpectrumType)
+				tbl->asSS_Info[i].ucSpreadSpectrumType)
 			ss_info->type.EXTERNAL = true;
 
 		if (ATOM_SS_CENTRE_SPREAD_MODE_MASK &
-			tbl->asSS_Info[i].ucSpreadSpectrumType)
+				tbl->asSS_Info[i].ucSpreadSpectrumType)
 			ss_info->type.CENTER_MODE = true;
 
 		ss_info->type.STEP_AND_DELAY_INFO = true;
@@ -1836,7 +1847,7 @@ enum bp_result dal_bios_parser_get_embedded_panel_info(
 		default:
 			break;
 		}
-	default:
+		default:
 			break;
 	}
 
@@ -1878,7 +1889,7 @@ static enum bp_result get_embedded_panel_info_v1_2(
 	/* doesn't have borders, so we should be okay leaving this as is for
 	 * now.  May need to revisit if we ever have LVDS with borders*/
 	info->lcd_timing.horizontal_blanking_time =
-		le16_to_cpu(lvds->sLCDTiming.usHBlanking_Time);
+			le16_to_cpu(lvds->sLCDTiming.usHBlanking_Time);
 	/* usVActive does not include borders, according to VBIOS team*/
 	info->lcd_timing.vertical_addressable =
 			le16_to_cpu(lvds->sLCDTiming.usVActive);
@@ -1937,7 +1948,7 @@ static enum bp_result get_embedded_panel_info_v1_2(
 
 	/*Drr panel support can be reported by VBIOS*/
 	if (LCDPANEL_CAP_DRR_SUPPORTED
-		& lvds->ucLCDPanel_SpecialHandlingCap)
+			& lvds->ucLCDPanel_SpecialHandlingCap)
 		info->drr_enabled = 1;
 
 	if (ATOM_PANEL_MISC_DUAL & lvds->ucLVDS_Misc)
@@ -1948,7 +1959,7 @@ static enum bp_result get_embedded_panel_info_v1_2(
 
 	info->lcd_timing.misc_info.GREY_LEVEL =
 		(uint32_t) (ATOM_PANEL_MISC_GREY_LEVEL &
-		lvds->ucLVDS_Misc) >> ATOM_PANEL_MISC_GREY_LEVEL_SHIFT;
+			lvds->ucLVDS_Misc) >> ATOM_PANEL_MISC_GREY_LEVEL_SHIFT;
 
 	if (ATOM_PANEL_MISC_SPATIAL & lvds->ucLVDS_Misc)
 		info->lcd_timing.misc_info.SPATIAL = true;
@@ -1980,17 +1991,17 @@ static enum bp_result get_embedded_panel_info_v1_3(
 		return BP_RESULT_BADBIOSTABLE;
 
 	if (!((1 == lvds->sHeader.ucTableFormatRevision)
-		&& (3 <= lvds->sHeader.ucTableContentRevision)))
+			&& (3 <= lvds->sHeader.ucTableContentRevision)))
 		return BP_RESULT_UNSUPPORTED;
 
 	dc_service_memset(info, 0, sizeof(struct embedded_panel_info));
 
 	/* We need to convert from 10KHz units into KHz units */
 	info->lcd_timing.pixel_clk =
-		le16_to_cpu(lvds->sLCDTiming.usPixClk) * 10;
+			le16_to_cpu(lvds->sLCDTiming.usPixClk) * 10;
 	/* usHActive does not include borders, according to VBIOS team */
 	info->lcd_timing.horizontal_addressable =
-		le16_to_cpu(lvds->sLCDTiming.usHActive);
+			le16_to_cpu(lvds->sLCDTiming.usHActive);
 	/* usHBlanking_Time includes borders, so we should really be subtracting
 	 * borders duing this translation, but LVDS generally*/
 	/* doesn't have borders, so we should be okay leaving this as is for
@@ -2040,13 +2051,13 @@ static enum bp_result get_embedded_panel_info_v1_3(
 
 	/* Drr panel support can be reported by VBIOS*/
 	if (LCDPANEL_CAP_V13_DRR_SUPPORTED
-		& lvds->ucLCDPanel_SpecialHandlingCap)
+			& lvds->ucLCDPanel_SpecialHandlingCap)
 		info->drr_enabled = 1;
 
 	/* Get supported refresh rate*/
 	if (info->drr_enabled == 1) {
 		uint8_t min_rr =
-			lvds->sRefreshRateSupport.ucMinRefreshRateForDRR;
+				lvds->sRefreshRateSupport.ucMinRefreshRateForDRR;
 		uint8_t rr = lvds->sRefreshRateSupport.ucSupportedRefreshRate;
 
 		if (min_rr != 0) {
@@ -2081,8 +2092,8 @@ static enum bp_result get_embedded_panel_info_v1_3(
 		info->lcd_timing.misc_info.RGB888 = true;
 
 	info->lcd_timing.misc_info.GREY_LEVEL =
-		(uint32_t) (ATOM_PANEL_MISC_V13_GREY_LEVEL &
-		lvds->ucLCD_Misc) >> ATOM_PANEL_MISC_V13_GREY_LEVEL_SHIFT;
+			(uint32_t) (ATOM_PANEL_MISC_V13_GREY_LEVEL &
+				lvds->ucLCD_Misc) >> ATOM_PANEL_MISC_V13_GREY_LEVEL_SHIFT;
 
 	return BP_RESULT_OK;
 }
@@ -2150,7 +2161,7 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 	}
 
 	offset = le16_to_cpu(object->usRecordOffset)
-			+ bp->object_info_tbl_offset;
+					+ bp->object_info_tbl_offset;
 
 	for (;;) {
 		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
@@ -2161,7 +2172,7 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 		offset += header->ucRecordSize;
 
 		if (LAST_RECORD_TYPE == header->ucRecordType ||
-			!header->ucRecordSize)
+				!header->ucRecordSize)
 			break;
 
 		if (ATOM_ENCODER_CAP_RECORD_TYPE != header->ucRecordType)
@@ -2210,7 +2221,7 @@ enum bp_result dal_bios_parser_get_din_connector_info(
 	}
 
 	offset = le16_to_cpu(object->usRecordOffset)
-				+ bp->object_info_tbl_offset;
+						+ bp->object_info_tbl_offset;
 
 	for (;;) {
 		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
@@ -2224,15 +2235,15 @@ enum bp_result dal_bios_parser_get_din_connector_info(
 
 		/* get out of the loop if no more records */
 		if (LAST_RECORD_TYPE == header->ucRecordType ||
-			!header->ucRecordSize)
+				!header->ucRecordSize)
 			break;
 
 		if (ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD_TYPE !=
-			header->ucRecordType)
+				header->ucRecordType)
 			continue;
 
 		if (sizeof(ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD)
-			> header->ucRecordSize)
+				> header->ucRecordSize)
 			continue;
 
 		record = (ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD *)header;
@@ -2285,7 +2296,7 @@ uint32_t dal_bios_parser_get_ss_entry_number(
 		return get_ss_entry_number_from_ss_info_tbl(bp, ss_id);
 
 	header = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,
-		DATA_TABLES(ASIC_InternalSS_Info));
+			DATA_TABLES(ASIC_InternalSS_Info));
 	get_atom_data_table_revision(header, &revision);
 
 	switch (revision.major) {
@@ -2301,14 +2312,14 @@ uint32_t dal_bios_parser_get_ss_entry_number(
 		switch (revision.minor) {
 		case 1:
 			return
-			get_ss_entry_number_from_internal_ss_info_tbl_V3_1(
-				bp, ss_id);
+				get_ss_entry_number_from_internal_ss_info_tbl_V3_1(
+						bp, ss_id);
 		default:
 			break;
 		}
 		break;
-	default:
-		break;
+		default:
+			break;
 	}
 
 	return 0;
@@ -2341,11 +2352,11 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 		return number;
 
 	header = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,
-		DATA_TABLES(SS_Info));
+			DATA_TABLES(SS_Info));
 	get_atom_data_table_revision(header, &revision);
 
 	tbl = GET_IMAGE(ATOM_SPREAD_SPECTRUM_INFO,
-		DATA_TABLES(SS_Info));
+			DATA_TABLES(SS_Info));
 
 	if (1 != revision.major || 2 > revision.minor)
 		return number;
@@ -2359,7 +2370,7 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 		struct embedded_panel_info panel_info;
 
 		if (dal_bios_parser_get_embedded_panel_info(bp, &panel_info)
-			== BP_RESULT_OK)
+				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
 	}
@@ -2371,8 +2382,8 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 		return number;
 
 	table_size = (le16_to_cpu(tbl->sHeader.usStructureSize) -
-		sizeof(ATOM_COMMON_TABLE_HEADER)) /
-			sizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);
+			sizeof(ATOM_COMMON_TABLE_HEADER)) /
+					sizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);
 
 	for (i = 0; i < table_size; i++)
 		if (id_local == (uint32_t)tbl->asSS_Info[i].ucSS_Id) {
@@ -2424,14 +2435,14 @@ static uint32_t get_ss_entry_number_from_internal_ss_info_tbl_v2_1(
 		return 0;
 
 	header_include = GET_IMAGE(ATOM_ASIC_INTERNAL_SS_INFO_V2,
-		DATA_TABLES(ASIC_InternalSS_Info));
+			DATA_TABLES(ASIC_InternalSS_Info));
 
 	size = (le16_to_cpu(header_include->sHeader.usStructureSize)
-		- sizeof(ATOM_COMMON_TABLE_HEADER))
-				/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);
+			- sizeof(ATOM_COMMON_TABLE_HEADER))
+						/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);
 
 	tbl = (ATOM_ASIC_SS_ASSIGNMENT_V2 *)
-		&header_include->asSpreadSpectrum[0];
+				&header_include->asSpreadSpectrum[0];
 	for (i = 0; i < size; i++)
 		if (tbl[i].ucClockIndication == (uint8_t)id)
 			return 1;
@@ -2460,13 +2471,13 @@ static uint32_t get_ss_entry_number_from_internal_ss_info_tbl_V3_1(
 		return number;
 
 	header_include = GET_IMAGE(ATOM_ASIC_INTERNAL_SS_INFO_V3,
-		DATA_TABLES(ASIC_InternalSS_Info));
+			DATA_TABLES(ASIC_InternalSS_Info));
 	size = (le16_to_cpu(header_include->sHeader.usStructureSize) -
-		sizeof(ATOM_COMMON_TABLE_HEADER)) /
-			sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);
+			sizeof(ATOM_COMMON_TABLE_HEADER)) /
+					sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);
 
 	tbl = (ATOM_ASIC_SS_ASSIGNMENT_V3 *)
-		&header_include->asSpreadSpectrum[0];
+				&header_include->asSpreadSpectrum[0];
 
 	for (i = 0; i < size; i++)
 		if (tbl[i].ucClockIndication == (uint8_t)id)
@@ -2491,14 +2502,14 @@ static ATOM_FAKE_EDID_PATCH_RECORD *get_faked_edid_record(
 		return NULL;
 
 	if (1 != info->sHeader.ucTableFormatRevision
-		|| 2 > info->sHeader.ucTableContentRevision)
+			|| 2 > info->sHeader.ucTableContentRevision)
 		return NULL;
 
 	if (!le16_to_cpu(info->usExtInfoTableOffset))
 		return NULL;
 
 	record = GET_IMAGE(uint8_t, DATA_TABLES(LVDS_Info)
-		+ le16_to_cpu(info->usExtInfoTableOffset));
+			+ le16_to_cpu(info->usExtInfoTableOffset));
 
 	if (!record)
 		return NULL;
@@ -2586,15 +2597,15 @@ enum bp_result dal_bios_parser_get_gpio_pin_info(
 		return BP_RESULT_BADBIOSTABLE;
 
 	if (sizeof(ATOM_COMMON_TABLE_HEADER) + sizeof(ATOM_GPIO_PIN_LUT)
-		> le16_to_cpu(header->sHeader.usStructureSize))
+			> le16_to_cpu(header->sHeader.usStructureSize))
 		return BP_RESULT_BADBIOSTABLE;
 
 	if (1 != header->sHeader.ucTableContentRevision)
 		return BP_RESULT_UNSUPPORTED;
 
 	count = (le16_to_cpu(header->sHeader.usStructureSize)
-		- sizeof(ATOM_COMMON_TABLE_HEADER))
-		/ sizeof(ATOM_GPIO_PIN_ASSIGNMENT);
+			- sizeof(ATOM_COMMON_TABLE_HEADER))
+				/ sizeof(ATOM_GPIO_PIN_ASSIGNMENT);
 	for (i = 0; i < count; ++i) {
 		if (header->asGPIO_Pin[i].ucGPIO_ID != gpio_id)
 			continue;
@@ -2650,14 +2661,14 @@ enum bp_result dal_bios_parser_enum_embedded_panel_patch_mode(
 		return BP_RESULT_BADBIOSTABLE;
 
 	if (1 != info->sHeader.ucTableFormatRevision
-		|| 2 > info->sHeader.ucTableContentRevision)
+			|| 2 > info->sHeader.ucTableContentRevision)
 		return BP_RESULT_UNSUPPORTED;
 
 	if (!le16_to_cpu(info->usExtInfoTableOffset))
 		return BP_RESULT_UNSUPPORTED;
 
 	record = GET_IMAGE(uint8_t, list_of_tables->LVDS_Info +
-		le16_to_cpu(info->usExtInfoTableOffset));
+			le16_to_cpu(info->usExtInfoTableOffset));
 
 	if (!record)
 		return BP_RESULT_BADBIOSTABLE;
@@ -2707,7 +2718,7 @@ static enum bp_result get_gpio_i2c_info(struct bios_parser *bp,
 		return BP_RESULT_BADBIOSTABLE;
 
 	if (sizeof(ATOM_COMMON_TABLE_HEADER) + sizeof(ATOM_GPIO_I2C_ASSIGMENT)
-		> le16_to_cpu(header->sHeader.usStructureSize))
+			> le16_to_cpu(header->sHeader.usStructureSize))
 		return BP_RESULT_BADBIOSTABLE;
 
 	if (1 != header->sHeader.ucTableContentRevision)
@@ -2715,8 +2726,8 @@ static enum bp_result get_gpio_i2c_info(struct bios_parser *bp,
 
 	/* get data count */
 	count = (le16_to_cpu(header->sHeader.usStructureSize)
-		- sizeof(ATOM_COMMON_TABLE_HEADER))
-		/ sizeof(ATOM_GPIO_I2C_ASSIGMENT);
+			- sizeof(ATOM_COMMON_TABLE_HEADER))
+				/ sizeof(ATOM_GPIO_I2C_ASSIGMENT);
 	if (count < record->sucI2cId.bfI2C_LineMux)
 		return BP_RESULT_BADBIOSTABLE;
 
@@ -2727,38 +2738,38 @@ static enum bp_result get_gpio_i2c_info(struct bios_parser *bp,
 	info->i2c_slave_address = record->ucI2CAddr;
 
 	info->gpio_info.clk_mask_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkMaskRegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkMaskRegisterIndex);
 	info->gpio_info.clk_en_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkEnRegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkEnRegisterIndex);
 	info->gpio_info.clk_y_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkY_RegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkY_RegisterIndex);
 	info->gpio_info.clk_a_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkA_RegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usClkA_RegisterIndex);
 	info->gpio_info.data_mask_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataMaskRegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataMaskRegisterIndex);
 	info->gpio_info.data_en_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataEnRegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataEnRegisterIndex);
 	info->gpio_info.data_y_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataY_RegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataY_RegisterIndex);
 	info->gpio_info.data_a_register_index =
-		le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataA_RegisterIndex);
+			le16_to_cpu(header->asGPIO_Info[info->i2c_line].usDataA_RegisterIndex);
 
 	info->gpio_info.clk_mask_shift =
-		header->asGPIO_Info[info->i2c_line].ucClkMaskShift;
+			header->asGPIO_Info[info->i2c_line].ucClkMaskShift;
 	info->gpio_info.clk_en_shift =
-		header->asGPIO_Info[info->i2c_line].ucClkEnShift;
+			header->asGPIO_Info[info->i2c_line].ucClkEnShift;
 	info->gpio_info.clk_y_shift =
-		header->asGPIO_Info[info->i2c_line].ucClkY_Shift;
+			header->asGPIO_Info[info->i2c_line].ucClkY_Shift;
 	info->gpio_info.clk_a_shift =
-		header->asGPIO_Info[info->i2c_line].ucClkA_Shift;
+			header->asGPIO_Info[info->i2c_line].ucClkA_Shift;
 	info->gpio_info.data_mask_shift =
-		header->asGPIO_Info[info->i2c_line].ucDataMaskShift;
+			header->asGPIO_Info[info->i2c_line].ucDataMaskShift;
 	info->gpio_info.data_en_shift =
-		header->asGPIO_Info[info->i2c_line].ucDataEnShift;
+			header->asGPIO_Info[info->i2c_line].ucDataEnShift;
 	info->gpio_info.data_y_shift =
-		header->asGPIO_Info[info->i2c_line].ucDataY_Shift;
+			header->asGPIO_Info[info->i2c_line].ucDataY_Shift;
 	info->gpio_info.data_a_shift =
-		header->asGPIO_Info[info->i2c_line].ucDataA_Shift;
+			header->asGPIO_Info[info->i2c_line].ucDataA_Shift;
 
 	return BP_RESULT_OK;
 }
@@ -2801,8 +2812,8 @@ static ATOM_OBJECT *get_bios_object(struct bios_parser *bp,
 
 	for (i = 0; i < tbl->ucNumberOfObjects; i++)
 		if (dal_graphics_object_id_is_equal(id,
-			object_id_from_bios_object_id(
-				le16_to_cpu(tbl->asObjects[i].usObjectID))))
+				object_id_from_bios_object_id(
+						le16_to_cpu(tbl->asObjects[i].usObjectID))))
 			return &tbl->asObjects[i];
 
 	return NULL;
@@ -2820,7 +2831,7 @@ static uint32_t get_dest_obj_list(struct bios_parser *bp,
 	}
 
 	offset = le16_to_cpu(object->usSrcDstTableOffset)
-				+ bp->object_info_tbl_offset;
+						+ bp->object_info_tbl_offset;
 
 	number = GET_IMAGE(uint8_t, offset);
 	if (!number)
@@ -2835,7 +2846,7 @@ static uint32_t get_dest_obj_list(struct bios_parser *bp,
 
 	offset += sizeof(uint8_t);
 	*id_list = (uint16_t *)get_image(bp, offset,
-		*number * sizeof(uint16_t));
+			*number * sizeof(uint16_t));
 
 	if (!*id_list)
 		return 0;
@@ -2855,7 +2866,7 @@ static uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,
 	}
 
 	offset = le16_to_cpu(object->usSrcDstTableOffset)
-			+ bp->object_info_tbl_offset;
+					+ bp->object_info_tbl_offset;
 
 	number = GET_IMAGE(uint8_t, offset);
 	if (!number)
@@ -2863,7 +2874,7 @@ static uint32_t get_src_obj_list(struct bios_parser *bp, ATOM_OBJECT *object,
 
 	offset += sizeof(uint8_t);
 	*id_list = (uint16_t *)get_image(bp, offset,
-		*number * sizeof(uint16_t));
+			*number * sizeof(uint16_t));
 
 	if (!*id_list)
 		return 0;
@@ -2883,7 +2894,7 @@ static uint32_t get_dst_number_from_object(struct bios_parser *bp,
 	}
 
 	offset = le16_to_cpu(object->usSrcDstTableOffset)
-			+ bp->object_info_tbl_offset;
+					+ bp->object_info_tbl_offset;
 
 	number = GET_IMAGE(uint8_t, offset);
 	if (!number)
@@ -2924,11 +2935,11 @@ static uint32_t get_record_size(uint8_t *record)
 
 	case LCD_FAKE_EDID_PATCH_RECORD_TYPE: {
 		ATOM_FAKE_EDID_PATCH_RECORD *fake_record =
-			(ATOM_FAKE_EDID_PATCH_RECORD *) record;
+				(ATOM_FAKE_EDID_PATCH_RECORD *) record;
 		uint32_t edid_size = get_edid_size(fake_record);
 
 		return sizeof(ATOM_FAKE_EDID_PATCH_RECORD) + edid_size
-			- sizeof(fake_record->ucFakeEDIDString);
+				- sizeof(fake_record->ucFakeEDIDString);
 	}
 
 	case LCD_PANEL_RESOLUTION_RECORD_TYPE:
@@ -2967,7 +2978,7 @@ static struct graphics_object_id object_id_from_bios_object_id(
 		return go_id;
 
 	go_id = dal_graphics_object_id_init(
-		id_from_bios_object_id(type, bios_object_id), enum_id, type);
+			id_from_bios_object_id(type, bios_object_id), enum_id, type);
 
 	return go_id;
 }
@@ -2975,7 +2986,7 @@ static struct graphics_object_id object_id_from_bios_object_id(
 static enum object_type object_type_from_bios_object_id(uint32_t bios_object_id)
 {
 	uint32_t bios_object_type = (bios_object_id & OBJECT_TYPE_MASK)
-		>> OBJECT_TYPE_SHIFT;
+				>> OBJECT_TYPE_SHIFT;
 	enum object_type object_type;
 
 	switch (bios_object_type) {
@@ -3005,7 +3016,7 @@ static enum object_type object_type_from_bios_object_id(uint32_t bios_object_id)
 static enum object_enum_id enum_id_from_bios_object_id(uint32_t bios_object_id)
 {
 	uint32_t bios_enum_id =
-		(bios_object_id & ENUM_ID_MASK) >> ENUM_ID_SHIFT;
+			(bios_object_id & ENUM_ID_MASK) >> ENUM_ID_SHIFT;
 	enum object_enum_id id;
 
 	switch (bios_enum_id) {
@@ -3048,7 +3059,7 @@ static uint32_t id_from_bios_object_id(enum object_type type,
 		return (uint32_t)encoder_id_from_bios_object_id(bios_object_id);
 	case OBJECT_TYPE_CONNECTOR:
 		return (uint32_t)connector_id_from_bios_object_id(
-			bios_object_id);
+				bios_object_id);
 	case OBJECT_TYPE_GENERIC:
 		return generic_id_from_bios_object_id(bios_object_id);
 	default:
@@ -3341,9 +3352,9 @@ static void get_atom_data_table_revision(
 		return;
 
 	tbl_revision->major =
-		(uint32_t) GET_DATA_TABLE_MAJOR_REVISION(atom_data_tbl);
+			(uint32_t) GET_DATA_TABLE_MAJOR_REVISION(atom_data_tbl);
 	tbl_revision->minor =
-		(uint32_t) GET_DATA_TABLE_MINOR_REVISION(atom_data_tbl);
+			(uint32_t) GET_DATA_TABLE_MINOR_REVISION(atom_data_tbl);
 }
 
 static uint32_t signal_to_ss_id(enum as_signal_type signal)
@@ -3388,52 +3399,52 @@ static uint32_t get_support_mask_for_device_id(struct device_id device_id)
 			break;
 		}
 		break;
-	case DEVICE_TYPE_CRT:
-		switch (enum_id) {
-		case 1:
-			return ATOM_DEVICE_CRT1_SUPPORT;
-		case 2:
-			return ATOM_DEVICE_CRT2_SUPPORT;
-		default:
-			break;
-		}
-		break;
-	case DEVICE_TYPE_DFP:
-		switch (enum_id) {
-		case 1:
-			return ATOM_DEVICE_DFP1_SUPPORT;
-		case 2:
-			return ATOM_DEVICE_DFP2_SUPPORT;
-		case 3:
-			return ATOM_DEVICE_DFP3_SUPPORT;
-		case 4:
-			return ATOM_DEVICE_DFP4_SUPPORT;
-		case 5:
-			return ATOM_DEVICE_DFP5_SUPPORT;
-		case 6:
-			return ATOM_DEVICE_DFP6_SUPPORT;
-		default:
-			break;
-		}
-		break;
-	case DEVICE_TYPE_CV:
-		switch (enum_id) {
-		case 1:
-			return ATOM_DEVICE_CV_SUPPORT;
-		default:
-			break;
-		}
-		break;
-	case DEVICE_TYPE_TV:
-		switch (enum_id) {
-		case 1:
-			return ATOM_DEVICE_TV1_SUPPORT;
-		default:
+		case DEVICE_TYPE_CRT:
+			switch (enum_id) {
+			case 1:
+				return ATOM_DEVICE_CRT1_SUPPORT;
+			case 2:
+				return ATOM_DEVICE_CRT2_SUPPORT;
+			default:
+				break;
+			}
 			break;
-		}
-		break;
-	default:
-		break;
+			case DEVICE_TYPE_DFP:
+				switch (enum_id) {
+				case 1:
+					return ATOM_DEVICE_DFP1_SUPPORT;
+				case 2:
+					return ATOM_DEVICE_DFP2_SUPPORT;
+				case 3:
+					return ATOM_DEVICE_DFP3_SUPPORT;
+				case 4:
+					return ATOM_DEVICE_DFP4_SUPPORT;
+				case 5:
+					return ATOM_DEVICE_DFP5_SUPPORT;
+				case 6:
+					return ATOM_DEVICE_DFP6_SUPPORT;
+				default:
+					break;
+				}
+				break;
+				case DEVICE_TYPE_CV:
+					switch (enum_id) {
+					case 1:
+						return ATOM_DEVICE_CV_SUPPORT;
+					default:
+						break;
+					}
+					break;
+					case DEVICE_TYPE_TV:
+						switch (enum_id) {
+						case 1:
+							return ATOM_DEVICE_TV1_SUPPORT;
+						default:
+							break;
+						}
+						break;
+						default:
+							break;
 	};
 
 	/* Unidentified device ID, return empty support mask. */
@@ -3441,8 +3452,8 @@ static uint32_t get_support_mask_for_device_id(struct device_id device_id)
 }
 
 /**
-*  HwContext interface for writing MM registers
-*/
+ *  HwContext interface for writing MM registers
+ */
 
 static bool i2c_read(
 	struct bios_parser *bp,
@@ -3466,27 +3477,27 @@ static bool i2c_read(
 
 	{
 		struct i2c_payload payloads[] = {
-			{
-				.address = i2c_info->i2c_slave_address >> 1,
-				.data = offset,
-				.length = sizeof(offset),
-				.write = true
-			},
-			{
-				.address = i2c_info->i2c_slave_address >> 1,
-				.data = buffer,
-				.length = length,
-				.write = false
-			}
+				{
+						.address = i2c_info->i2c_slave_address >> 1,
+						.data = offset,
+						.length = sizeof(offset),
+						.write = true
+				},
+				{
+						.address = i2c_info->i2c_slave_address >> 1,
+						.data = buffer,
+						.length = length,
+						.write = false
+				}
 		};
 
 		cmd.payloads = payloads;
 		cmd.number_of_payloads = ARRAY_SIZE(payloads);
 
 		result = dal_i2caux_submit_i2c_command(
-			dal_adapter_service_get_i2caux(bp->as),
-			ddc,
-			&cmd);
+				dal_adapter_service_get_i2caux(bp->as),
+				ddc,
+				&cmd);
 	}
 
 	dal_adapter_service_release_ddc(bp->as, ddc);
@@ -3519,20 +3530,20 @@ static enum bp_result get_ext_display_connection_info(
 		struct graphics_object_i2c_info i2c_info;
 
 		gpio_i2c_header = GET_IMAGE(ATOM_GPIO_I2C_INFO,
-			bp->master_data_tbl->ListOfDataTables.GPIO_I2C_Info);
+				bp->master_data_tbl->ListOfDataTables.GPIO_I2C_Info);
 
 		if (NULL == gpio_i2c_header)
 			return BP_RESULT_BADBIOSTABLE;
 
 		if (get_gpio_i2c_info(bp, i2c_record, &i2c_info) !=
-			BP_RESULT_OK)
+				BP_RESULT_OK)
 			return BP_RESULT_BADBIOSTABLE;
 
 		if (i2c_read(
-			bp,
-			&i2c_info,
-			(uint8_t *)ext_display_connection_info_tbl,
-			sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO))) {
+				bp,
+				&i2c_info,
+				(uint8_t *)ext_display_connection_info_tbl,
+				sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO))) {
 			config_tbl_present = true;
 		}
 	}
@@ -3541,7 +3552,7 @@ static enum bp_result get_ext_display_connection_info(
 	if (config_tbl_present)
 		for (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; i++) {
 			if (ext_display_connection_info_tbl->ucGuid[i]
-				!= ext_display_connection_guid[i]) {
+														!= ext_display_connection_guid[i]) {
 				config_tbl_present = false;
 				break;
 			}
@@ -3551,10 +3562,10 @@ static enum bp_result get_ext_display_connection_info(
 	if (config_tbl_present) {
 		uint8_t check_sum = 0;
 		uint8_t *buf =
-			(uint8_t *)ext_display_connection_info_tbl;
+				(uint8_t *)ext_display_connection_info_tbl;
 
 		for (i = 0; i < sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO);
-			i++) {
+				i++) {
 			check_sum += buf[i];
 		}
 
@@ -3646,9 +3657,9 @@ static bool get_patched_device_tag(
 	/* Use fallback behaviour if not supported. */
 	if (!bp->remap_device_tags) {
 		device_tag->ulACPIDeviceEnum =
-			cpu_to_le32((uint32_t) le16_to_cpu(ext_display_path->usDeviceACPIEnum));
+				cpu_to_le32((uint32_t) le16_to_cpu(ext_display_path->usDeviceACPIEnum));
 		device_tag->usDeviceID =
-			cpu_to_le16(le16_to_cpu(ext_display_path->usDeviceTag));
+				cpu_to_le16(le16_to_cpu(ext_display_path->usDeviceTag));
 		return true;
 	}
 
@@ -3658,7 +3669,7 @@ static bool get_patched_device_tag(
 		/* Assign this device ID if supported. */
 		if ((device_support & dev_id) != 0) {
 			device_tag->ulACPIDeviceEnum =
-				cpu_to_le32((uint32_t) le16_to_cpu(ext_display_path->usDeviceACPIEnum));
+					cpu_to_le32((uint32_t) le16_to_cpu(ext_display_path->usDeviceACPIEnum));
 			device_tag->usDeviceID = cpu_to_le16((USHORT) dev_id);
 			return true;
 		}
@@ -3688,31 +3699,31 @@ static void add_device_tag_from_ext_display_path(
 	ATOM_CONNECTOR_DEVICE_TAG *device_tag = NULL;
 	ATOM_CONNECTOR_DEVICE_TAG_RECORD *device_tag_record = NULL;
 	enum bp_result result =
-		dal_bios_parser_get_device_tag_record(
-			bp, object, &device_tag_record);
+			dal_bios_parser_get_device_tag_record(
+					bp, object, &device_tag_record);
 
 	if ((le16_to_cpu(ext_display_path->usDeviceTag) != CONNECTOR_OBJECT_ID_NONE)
-		&& (result == BP_RESULT_OK)) {
+			&& (result == BP_RESULT_OK)) {
 		uint8_t index;
 
 		if ((device_tag_record->ucNumberOfDevice == 1) &&
-			(le16_to_cpu(device_tag_record->asDeviceTag[0].usDeviceID) == 0)) {
+				(le16_to_cpu(device_tag_record->asDeviceTag[0].usDeviceID) == 0)) {
 			/*Workaround bug in current VBIOS releases where
 			 * ucNumberOfDevice = 1 but there is no actual device
 			 * tag data. This w/a is temporary until the updated
 			 * VBIOS is distributed. */
 			device_tag_record->ucNumberOfDevice =
-				device_tag_record->ucNumberOfDevice - 1;
+					device_tag_record->ucNumberOfDevice - 1;
 		}
 
 		/* Attempt to find a matching device ID. */
 		index = device_tag_record->ucNumberOfDevice;
 		device_tag = &device_tag_record->asDeviceTag[index];
 		if (get_patched_device_tag(
-			bp,
-			ext_display_path,
-			*device_support,
-			device_tag)) {
+				bp,
+				ext_display_path,
+				*device_support,
+				device_tag)) {
 			/* Update cached device support to remove assigned ID.
 			 */
 			*device_support &= ~le16_to_cpu(device_tag->usDeviceID);
@@ -3737,7 +3748,7 @@ static EXT_DISPLAY_PATH *get_ext_display_path_entry(
 {
 	EXT_DISPLAY_PATH *ext_display_path;
 	uint32_t ext_display_path_index =
-		((bios_object_id & ENUM_ID_MASK) >> ENUM_ID_SHIFT) - 1;
+			((bios_object_id & ENUM_ID_MASK) >> ENUM_ID_SHIFT) - 1;
 
 	if (ext_display_path_index >= MAX_NUMBER_OF_EXT_DISPLAY_PATH)
 		return NULL;
@@ -3770,7 +3781,7 @@ static ATOM_CONNECTOR_AUXDDC_LUT_RECORD *get_ext_connector_aux_ddc_lut_record(
 	}
 
 	offset = le16_to_cpu(object->usRecordOffset)
-			+ bp->object_info_tbl_offset;
+					+ bp->object_info_tbl_offset;
 
 	for (;;) {
 		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
@@ -3779,13 +3790,13 @@ static ATOM_CONNECTOR_AUXDDC_LUT_RECORD *get_ext_connector_aux_ddc_lut_record(
 			return NULL;
 
 		if (LAST_RECORD_TYPE == header->ucRecordType ||
-			0 == header->ucRecordSize)
+				0 == header->ucRecordSize)
 			break;
 
 		if (ATOM_CONNECTOR_AUXDDC_LUT_RECORD_TYPE ==
-			header->ucRecordType &&
-			sizeof(ATOM_CONNECTOR_AUXDDC_LUT_RECORD) <=
-			header->ucRecordSize)
+				header->ucRecordType &&
+				sizeof(ATOM_CONNECTOR_AUXDDC_LUT_RECORD) <=
+				header->ucRecordSize)
 			return (ATOM_CONNECTOR_AUXDDC_LUT_RECORD *)(header);
 
 		offset += header->ucRecordSize;
@@ -3814,7 +3825,7 @@ static ATOM_CONNECTOR_HPDPIN_LUT_RECORD *get_ext_connector_hpd_pin_lut_record(
 	}
 
 	offset = le16_to_cpu(object->usRecordOffset)
-			+ bp->object_info_tbl_offset;
+					+ bp->object_info_tbl_offset;
 
 	for (;;) {
 		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
@@ -3823,13 +3834,13 @@ static ATOM_CONNECTOR_HPDPIN_LUT_RECORD *get_ext_connector_hpd_pin_lut_record(
 			return NULL;
 
 		if (LAST_RECORD_TYPE == header->ucRecordType ||
-			0 == header->ucRecordSize)
+				0 == header->ucRecordSize)
 			break;
 
 		if (ATOM_CONNECTOR_HPDPIN_LUT_RECORD_TYPE ==
-			header->ucRecordType &&
-			sizeof(ATOM_CONNECTOR_HPDPIN_LUT_RECORD) <=
-			header->ucRecordSize)
+				header->ucRecordType &&
+				sizeof(ATOM_CONNECTOR_HPDPIN_LUT_RECORD) <=
+				header->ucRecordSize)
 			return (ATOM_CONNECTOR_HPDPIN_LUT_RECORD *)header;
 
 		offset += header->ucRecordSize;
@@ -3866,13 +3877,13 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 	ATOM_OBJECT *opm_object = NULL;
 	uint32_t i = 0;
 	struct graphics_object_id opm_object_id =
-		dal_graphics_object_id_init(
-			GENERIC_ID_MXM_OPM,
-			ENUM_ID_1,
-			OBJECT_TYPE_GENERIC);
+			dal_graphics_object_id_init(
+					GENERIC_ID_MXM_OPM,
+					ENUM_ID_1,
+					OBJECT_TYPE_GENERIC);
 	ATOM_CONNECTOR_DEVICE_TAG_RECORD *dev_tag_record;
 	uint32_t cached_device_support =
-		le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport);
+			le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport);
 
 	uint32_t dst_number;
 	uint16_t *dst_object_id_list;
@@ -3882,23 +3893,23 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 		return BP_RESULT_UNSUPPORTED;
 
 	dc_service_memset(&ext_display_connection_info_tbl, 0,
-		sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO));
+			sizeof(ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO));
 
 	connector_tbl_offset = bp->object_info_tbl_offset
-		+ le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
+			+ le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
 	connector_tbl = GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
 
 	/* Read Connector info table from EEPROM through i2c */
 	if (get_ext_display_connection_info(
-		bp,
-		opm_object,
-		&ext_display_connection_info_tbl) != BP_RESULT_OK) {
+			bp,
+			opm_object,
+			&ext_display_connection_info_tbl) != BP_RESULT_OK) {
 		if (bp->headless_no_opm) {
 			/* Failed to read OPM, remove all non-CF connectors. */
 			for (i = 0; i < connector_tbl->ucNumberOfObjects; ++i) {
 				object = &connector_tbl->asObjects[i];
 				object_id = object_id_from_bios_object_id(
-					le16_to_cpu(object->usObjectID));
+						le16_to_cpu(object->usObjectID));
 				if (OBJECT_TYPE_CONNECTOR == object_id.type)
 					object->usObjectID = cpu_to_le16(0);
 			}
@@ -3907,17 +3918,17 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 		}
 
 		dal_logger_write(bp->ctx->logger,
-			LOG_MAJOR_BIOS,
-			LOG_MINOR_BIOS_CMD_TABLE,
-			"%s: Failed to read Connection Info Table", __func__);
+				LOG_MAJOR_BIOS,
+				LOG_MINOR_BIOS_CMD_TABLE,
+				"%s: Failed to read Connection Info Table", __func__);
 		return BP_RESULT_UNSUPPORTED;
 	}
 
 	/* Get pointer to AUX/DDC and HPD LUTs */
 	aux_ddc_lut_record =
-		get_ext_connector_aux_ddc_lut_record(bp, opm_object);
+			get_ext_connector_aux_ddc_lut_record(bp, opm_object);
 	hpd_pin_lut_record =
-		get_ext_connector_hpd_pin_lut_record(bp, opm_object);
+			get_ext_connector_hpd_pin_lut_record(bp, opm_object);
 
 	if ((aux_ddc_lut_record == NULL) || (hpd_pin_lut_record == NULL))
 		return BP_RESULT_UNSUPPORTED;
@@ -3929,21 +3940,21 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 			/* Remove support for all non-MXM connectors. */
 			object = &connector_tbl->asObjects[i];
 			object_id = object_id_from_bios_object_id(
-				le16_to_cpu(object->usObjectID));
+					le16_to_cpu(object->usObjectID));
 			if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
-				(CONNECTOR_ID_MXM == object_id.id))
+					(CONNECTOR_ID_MXM == object_id.id))
 				continue;
 
 			/* Remove support for all device tags. */
 			if (dal_bios_parser_get_device_tag_record(
-				bp, object, &dev_tag_record) != BP_RESULT_OK)
+					bp, object, &dev_tag_record) != BP_RESULT_OK)
 				continue;
 
 			for (j = 0; j < dev_tag_record->ucNumberOfDevice; ++j) {
 				ATOM_CONNECTOR_DEVICE_TAG *device_tag =
-					&dev_tag_record->asDeviceTag[j];
+						&dev_tag_record->asDeviceTag[j];
 				cached_device_support &=
-					~le16_to_cpu(device_tag->usDeviceID);
+						~le16_to_cpu(device_tag->usDeviceID);
 			}
 		}
 	}
@@ -3956,37 +3967,37 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 		object = &connector_tbl->asObjects[i];
 		object_id = object_id_from_bios_object_id(le16_to_cpu(object->usObjectID));
 		if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
-			(CONNECTOR_ID_MXM != object_id.id))
+				(CONNECTOR_ID_MXM != object_id.id))
 			continue;
 
 		/* Get the correct connection info table entry based on the enum
 		 * id. */
 		ext_display_path = get_ext_display_path_entry(
-			&ext_display_connection_info_tbl,
-			le16_to_cpu(object->usObjectID));
+				&ext_display_connection_info_tbl,
+				le16_to_cpu(object->usObjectID));
 		if (!ext_display_path)
 			return BP_RESULT_FAILURE;
 
 		/* Patch device connector ID */
 		object->usObjectID =
-			cpu_to_le16(le16_to_cpu(ext_display_path->usDeviceConnector));
+				cpu_to_le16(le16_to_cpu(ext_display_path->usDeviceConnector));
 
 		/* Patch device tag, ulACPIDeviceEnum. */
 		add_device_tag_from_ext_display_path(
-			bp,
-			object,
-			ext_display_path,
-			&cached_device_support);
+				bp,
+				object,
+				ext_display_path,
+				&cached_device_support);
 
 		/* Patch HPD info */
 		if (ext_display_path->ucExtHPDPINLutIndex <
-			MAX_NUMBER_OF_EXT_HPDPIN_LUT_ENTRIES) {
+				MAX_NUMBER_OF_EXT_HPDPIN_LUT_ENTRIES) {
 			hpd_record = get_hpd_record(bp, object);
 			if (hpd_record) {
 				uint8_t index =
-					ext_display_path->ucExtHPDPINLutIndex;
+						ext_display_path->ucExtHPDPINLutIndex;
 				hpd_record->ucHPDIntGPIOID =
-					hpd_pin_lut_record->ucHPDPINMap[index];
+						hpd_pin_lut_record->ucHPDPINMap[index];
 			} else {
 				BREAK_TO_DEBUGGER();
 				/* Invalid hpd record */
@@ -3996,13 +4007,13 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 
 		/* Patch I2C/AUX info */
 		if (ext_display_path->ucExtHPDPINLutIndex <
-			MAX_NUMBER_OF_EXT_AUXDDC_LUT_ENTRIES) {
+				MAX_NUMBER_OF_EXT_AUXDDC_LUT_ENTRIES) {
 			i2c_record = get_i2c_record(bp, object);
 			if (i2c_record) {
 				uint8_t index =
-					ext_display_path->ucExtAUXDDCLutIndex;
+						ext_display_path->ucExtAUXDDCLutIndex;
 				i2c_record->sucI2cId =
-					aux_ddc_lut_record->ucAUXDDCMap[index];
+						aux_ddc_lut_record->ucAUXDDCMap[index];
 			} else {
 				BREAK_TO_DEBUGGER();
 				/* Invalid I2C record */
@@ -4013,37 +4024,37 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 		/* Merge with other MXM connectors that map to the same physical
 		 * connector. */
 		for (j = i + 1;
-			j < connector_tbl->ucNumberOfObjects; j++) {
+				j < connector_tbl->ucNumberOfObjects; j++) {
 			ATOM_OBJECT *next_object;
 			struct graphics_object_id next_object_id;
 			EXT_DISPLAY_PATH *next_ext_display_path;
 
 			next_object = &connector_tbl->asObjects[j];
 			next_object_id = object_id_from_bios_object_id(
-				le16_to_cpu(next_object->usObjectID));
+					le16_to_cpu(next_object->usObjectID));
 
 			if ((OBJECT_TYPE_CONNECTOR != next_object_id.type) &&
-				(CONNECTOR_ID_MXM == next_object_id.id))
+					(CONNECTOR_ID_MXM == next_object_id.id))
 				continue;
 
 			next_ext_display_path = get_ext_display_path_entry(
-				&ext_display_connection_info_tbl,
-				le16_to_cpu(next_object->usObjectID));
+					&ext_display_connection_info_tbl,
+					le16_to_cpu(next_object->usObjectID));
 
 			if (next_ext_display_path == NULL)
 				return BP_RESULT_FAILURE;
 
 			/* Merge if using same connector. */
 			if ((le16_to_cpu(next_ext_display_path->usDeviceConnector) ==
-				le16_to_cpu(ext_display_path->usDeviceConnector)) &&
-				(le16_to_cpu(ext_display_path->usDeviceConnector) != 0)) {
+					le16_to_cpu(ext_display_path->usDeviceConnector)) &&
+					(le16_to_cpu(ext_display_path->usDeviceConnector) != 0)) {
 				/* Clear duplicate connector from table. */
 				next_object->usObjectID = cpu_to_le16(0);
 				add_device_tag_from_ext_display_path(
-					bp,
-					object,
-					ext_display_path,
-					&cached_device_support);
+						bp,
+						object,
+						ext_display_path,
+						&cached_device_support);
 			}
 		}
 	}
@@ -4053,7 +4064,7 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 	 *  display connection info table */
 
 	encoder_table_offset = bp->object_info_tbl_offset
-		+ le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset);
+			+ le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset);
 	encoder_table = GET_IMAGE(ATOM_OBJECT_TABLE, encoder_table_offset);
 
 	for (i = 0; i < encoder_table->ucNumberOfObjects; i++) {
@@ -4065,24 +4076,24 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 
 		for (j = 0; j < dst_number; j++) {
 			object_id = object_id_from_bios_object_id(
-				dst_object_id_list[j]);
+					dst_object_id_list[j]);
 
 			if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
-				(CONNECTOR_ID_MXM != object_id.id))
+					(CONNECTOR_ID_MXM != object_id.id))
 				continue;
 
 			/* Get the correct connection info table entry based on
 			 * the enum id. */
 			ext_display_path =
-				get_ext_display_path_entry(
-					&ext_display_connection_info_tbl,
-					dst_object_id_list[j]);
+					get_ext_display_path_entry(
+							&ext_display_connection_info_tbl,
+							dst_object_id_list[j]);
 
 			if (ext_display_path == NULL)
 				return BP_RESULT_FAILURE;
 
 			dst_object_id_list[j] =
-				le16_to_cpu(ext_display_path->usDeviceConnector);
+					le16_to_cpu(ext_display_path->usDeviceConnector);
 		}
 	}
 
@@ -4111,7 +4122,7 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 	uint32_t i = 0;
 
 	connector_tbl_offset = bp->object_info_tbl_offset +
-		le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
+			le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset);
 	connector_tbl = GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
 
 	/* Look for MXM connectors to determine whether we need patch the VBIOS
@@ -4122,7 +4133,7 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 		object_id = object_id_from_bios_object_id(le16_to_cpu(object->usObjectID));
 
 		if ((OBJECT_TYPE_CONNECTOR == object_id.type) &&
-			(CONNECTOR_ID_MXM == object_id.id)) {
+				(CONNECTOR_ID_MXM == object_id.id)) {
 			/* Once we found MXM connector - we can break */
 			mxm_connector_found = true;
 			break;
@@ -4150,20 +4161,20 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 		original_bios = bp->bios;
 		bp->bios = bp->bios_local_image;
 		connector_tbl =
-			GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
+				GET_IMAGE(ATOM_OBJECT_TABLE, connector_tbl_offset);
 
 		/* Step 2: (only if MXM connector found) Patch BIOS image with
 		 * info from external module */
 		if (mxm_connector_found &&
-			patch_bios_image_from_ext_display_connection_info(bp) !=
-				BP_RESULT_OK) {
+				patch_bios_image_from_ext_display_connection_info(bp) !=
+						BP_RESULT_OK) {
 			/* Patching the bios image has failed. We will copy
 			 * again original image provided and afterwards
 			 * only remove null entries */
 			dc_service_memmove(
-				bp->bios_local_image,
-				original_bios,
-				bp->bios_size);
+					bp->bios_local_image,
+					original_bios,
+					bp->bios_size);
 		}
 
 		/* Step 3: Compact connector table (remove null entries, valid
@@ -4171,17 +4182,17 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 		for (i = 0; i < connector_tbl->ucNumberOfObjects; i++) {
 			object = &connector_tbl->asObjects[i];
 			object_id = object_id_from_bios_object_id(
-				le16_to_cpu(object->usObjectID));
+					le16_to_cpu(object->usObjectID));
 
 			if (OBJECT_TYPE_CONNECTOR != object_id.type)
 				continue;
 
 			if (i != connectors_num) {
 				dc_service_memmove(
-					&connector_tbl->
-					asObjects[connectors_num],
-					object,
-					sizeof(ATOM_OBJECT));
+						&connector_tbl->
+						asObjects[connectors_num],
+						object,
+						sizeof(ATOM_OBJECT));
 			}
 			++connectors_num;
 		}
@@ -4199,27 +4210,27 @@ bool dal_bios_parser_is_accelerated_mode(
 {
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	return bp->bios_helper->is_accelerated_mode(
-		bp->ctx);
+			bp->ctx);
 #else
 	dal_logger_write(bp->ctx->logger,
-		LOG_MAJOR_BIOS,
-		LOG_MINOR_BIOS_CMD_TABLE,
-		"%s: VBIOS is not supported", __func__);
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 	return false;
 #endif
 }
 
 /**
-* dal_bios_parser_set_scratch_connected
-*
-* @brief
-*  update VBIOS scratch register about connected displays
-*
-* @param
-*  bool - update scratch register or just prepare info to be updated
-*  bool - connection state
-*  const ConnectorDeviceTagInfo* - pointer to device type and enum ID
-*/
+ * dal_bios_parser_set_scratch_connected
+ *
+ * @brief
+ *  update VBIOS scratch register about connected displays
+ *
+ * @param
+ *  bool - update scratch register or just prepare info to be updated
+ *  bool - connection state
+ *  const ConnectorDeviceTagInfo* - pointer to device type and enum ID
+ */
 void dal_bios_parser_set_scratch_connected(
 	struct bios_parser *bp,
 	struct graphics_object_id connector_id,
@@ -4228,25 +4239,25 @@ void dal_bios_parser_set_scratch_connected(
 {
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_connected(
-		bp->ctx,
-		connector_id, connected, device_tag);
+			bp->ctx,
+			connector_id, connected, device_tag);
 #else
 	dal_logger_write(bp->ctx->logger,
-		LOG_MAJOR_BIOS,
-		LOG_MINOR_BIOS_CMD_TABLE,
-		"%s: VBIOS is not supported", __func__);
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 #endif
 }
 
 /**
-* dal_bios_parser_set_scratch_critical_state
-*
-* @brief
-*  update critical state bit in VBIOS scratch register
-*
-* @param
-*  bool - to set or reset state
-*/
+ * dal_bios_parser_set_scratch_critical_state
+ *
+ * @brief
+ *  update critical state bit in VBIOS scratch register
+ *
+ * @param
+ *  bool - to set or reset state
+ */
 void dal_bios_parser_set_scratch_critical_state(
 	struct bios_parser *bp,
 	bool state)
@@ -4256,9 +4267,9 @@ void dal_bios_parser_set_scratch_critical_state(
 			bp->ctx, state);
 #else
 	dal_logger_write(bp->ctx->logger,
-		LOG_MAJOR_BIOS,
-		LOG_MINOR_BIOS_CMD_TABLE,
-		"%s: VBIOS is not supported", __func__);
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 #endif
 }
 
@@ -4267,27 +4278,27 @@ void dal_bios_parser_set_scratch_acc_mode_change(
 {
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_acc_mode_change(
-		bp->ctx);
+			bp->ctx);
 #else
 	dal_logger_write(bp->ctx->logger,
-		LOG_MAJOR_BIOS,
-		LOG_MINOR_BIOS_CMD_TABLE,
-		"%s: VBIOS is not supported", __func__);
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 #endif
 }
 
 /**
-* dal_bios_parser_prepare_scratch_active_and_requested
-*
-* @brief
-*  update VBIOS scratch registers about active and requested displays
-*
-* @param
-*  enum controller_id - controller Id
-*  enum signal_type signal - signal type used on display
-*  const struct connector_device_tag_info * - pointer to display type and
-*  enum Id
-*/
+ * dal_bios_parser_prepare_scratch_active_and_requested
+ *
+ * @brief
+ *  update VBIOS scratch registers about active and requested displays
+ *
+ * @param
+ *  enum controller_id - controller Id
+ *  enum signal_type signal - signal type used on display
+ *  const struct connector_device_tag_info * - pointer to display type and
+ *  enum Id
+ */
 void dal_bios_parser_prepare_scratch_active_and_requested(
 	struct bios_parser *bp,
 	enum controller_id controller_id,
@@ -4303,9 +4314,9 @@ void dal_bios_parser_prepare_scratch_active_and_requested(
 			device_tag);
 #else
 	dal_logger_write(bp->ctx->logger,
-		LOG_MAJOR_BIOS,
-		LOG_MINOR_BIOS_CMD_TABLE,
-		"%s: VBIOS is not supported", __func__);
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 #endif
 }
 
@@ -4314,13 +4325,13 @@ void dal_bios_parser_set_scratch_active_and_requested(
 {
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
 	bp->bios_helper->set_scratch_active_and_requested(
-		bp->ctx,
-		&bp->vbios_helper_data);
+			bp->ctx,
+			&bp->vbios_helper_data);
 #else
 	dal_logger_write(bp->ctx->logger,
-		LOG_MAJOR_BIOS,
-		LOG_MINOR_BIOS_CMD_TABLE,
-		"%s: VBIOS is not supported", __func__);
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 #endif
 }
 
@@ -4347,29 +4358,29 @@ static enum bp_result get_integrated_info_v8(
 	uint32_t i;
 
 	info_v8 = GET_IMAGE(ATOM_INTEGRATED_SYSTEM_INFO_V1_8,
-		bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);
+			bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);
 
 	if (info_v8 != NULL) {
 		info->boot_up_engine_clock =
-			le32_to_cpu(info_v8->ulBootUpEngineClock) * 10;
+				le32_to_cpu(info_v8->ulBootUpEngineClock) * 10;
 		info->dentist_vco_freq =
-			le32_to_cpu(info_v8->ulDentistVCOFreq) * 10;
+				le32_to_cpu(info_v8->ulDentistVCOFreq) * 10;
 		info->boot_up_uma_clock =
-			le32_to_cpu(info_v8->ulBootUpUMAClock) * 10;
+				le32_to_cpu(info_v8->ulBootUpUMAClock) * 10;
 
 		for (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {
 			/* Convert [10KHz] into [KHz] */
 			info->disp_clk_voltage[i].max_supported_clk =
 					le32_to_cpu(info_v8->sDISPCLK_Voltage[i].
-					ulMaximumSupportedCLK) * 10;
+							ulMaximumSupportedCLK) * 10;
 			info->disp_clk_voltage[i].voltage_index =
-				le32_to_cpu(info_v8->sDISPCLK_Voltage[i].ulVoltageIndex);
+					le32_to_cpu(info_v8->sDISPCLK_Voltage[i].ulVoltageIndex);
 		}
 
 		info->boot_up_req_display_vector =
-			le32_to_cpu(info_v8->ulBootUpReqDisplayVector);
+				le32_to_cpu(info_v8->ulBootUpReqDisplayVector);
 		info->gpu_cap_info =
-			le32_to_cpu(info_v8->ulGPUCapInfo);
+				le32_to_cpu(info_v8->ulGPUCapInfo);
 
 		/*
 		 * system_config: Bit[0] = 0 : PCIE power gating disabled
@@ -4394,8 +4405,8 @@ static enum bp_result get_integrated_info_v8(
 				le32_to_cpu(info_v8->ulNbpStateNClkFreq[0]);
 		for (i = 1; i < 4; ++i)
 			info->minimum_n_clk =
-			info->minimum_n_clk < le32_to_cpu(info_v8->ulNbpStateNClkFreq[i]) ?
-			info->minimum_n_clk : le32_to_cpu(info_v8->ulNbpStateNClkFreq[i]);
+					info->minimum_n_clk < le32_to_cpu(info_v8->ulNbpStateNClkFreq[i]) ?
+							info->minimum_n_clk : le32_to_cpu(info_v8->ulNbpStateNClkFreq[i]);
 
 		info->idle_n_clk = le32_to_cpu(info_v8->ulIdleNClk);
 		info->ddr_dll_power_up_time =
@@ -4439,11 +4450,11 @@ static enum bp_result get_integrated_info_v8(
 		for (i = 0; i < NUMBER_OF_AVAILABLE_SCLK; ++i) {
 			/* Convert [10KHz] into [KHz] */
 			info->avail_s_clk[i].supported_s_clk =
-				le32_to_cpu(info_v8->sAvail_SCLK[i].ulSupportedSCLK) * 10;
+					le32_to_cpu(info_v8->sAvail_SCLK[i].ulSupportedSCLK) * 10;
 			info->avail_s_clk[i].voltage_index =
-				le16_to_cpu(info_v8->sAvail_SCLK[i].usVoltageIndex);
+					le16_to_cpu(info_v8->sAvail_SCLK[i].usVoltageIndex);
 			info->avail_s_clk[i].voltage_id =
-				le16_to_cpu(info_v8->sAvail_SCLK[i].usVoltageID);
+					le16_to_cpu(info_v8->sAvail_SCLK[i].usVoltageID);
 		}
 
 		for (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {
@@ -4454,22 +4465,22 @@ static enum bp_result get_integrated_info_v8(
 		for (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {
 			info->ext_disp_conn_info.path[i].device_connector_id =
 					object_id_from_bios_object_id(
-			le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceConnector));
+							le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceConnector));
 
 			info->ext_disp_conn_info.path[i].ext_encoder_obj_id =
 					object_id_from_bios_object_id(
-			le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usExtEncoderObjId));
+							le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usExtEncoderObjId));
 
 			info->ext_disp_conn_info.path[i].device_tag =
-				le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceTag);
+					le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceTag);
 			info->ext_disp_conn_info.path[i].device_acpi_enum =
-				le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceACPIEnum);
+					le16_to_cpu(info_v8->sExtDispConnInfo.sPath[i].usDeviceACPIEnum);
 			info->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =
-			info_v8->sExtDispConnInfo.sPath[i].ucExtAUXDDCLutIndex;
+					info_v8->sExtDispConnInfo.sPath[i].ucExtAUXDDCLutIndex;
 			info->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =
-			info_v8->sExtDispConnInfo.sPath[i].ucExtHPDPINLutIndex;
+					info_v8->sExtDispConnInfo.sPath[i].ucExtHPDPINLutIndex;
 			info->ext_disp_conn_info.path[i].channel_mapping.raw =
-			info_v8->sExtDispConnInfo.sPath[i].ucChannelMapping;
+					info_v8->sExtDispConnInfo.sPath[i].ucChannelMapping;
 		}
 		info->ext_disp_conn_info.checksum =
 				info_v8->sExtDispConnInfo.ucChecksum;
@@ -4503,7 +4514,7 @@ static enum bp_result get_integrated_info_v9(
 	uint32_t i;
 
 	info_v9 = GET_IMAGE(ATOM_INTEGRATED_SYSTEM_INFO_V1_9,
-		bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);
+			bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);
 
 	if (info_v9 != NULL) {
 		info->boot_up_engine_clock =
@@ -4516,9 +4527,9 @@ static enum bp_result get_integrated_info_v9(
 		for (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {
 			/* Convert [10KHz] into [KHz] */
 			info->disp_clk_voltage[i].max_supported_clk =
-				le32_to_cpu(info_v9->sDISPCLK_Voltage[i].ulMaximumSupportedCLK) * 10;
+					le32_to_cpu(info_v9->sDISPCLK_Voltage[i].ulMaximumSupportedCLK) * 10;
 			info->disp_clk_voltage[i].voltage_index =
-				le32_to_cpu(info_v9->sDISPCLK_Voltage[i].ulVoltageIndex);
+					le32_to_cpu(info_v9->sDISPCLK_Voltage[i].ulVoltageIndex);
 		}
 
 		info->boot_up_req_display_vector =
@@ -4548,8 +4559,8 @@ static enum bp_result get_integrated_info_v9(
 				le32_to_cpu(info_v9->ulNbpStateNClkFreq[0]);
 		for (i = 1; i < 4; ++i)
 			info->minimum_n_clk =
-			info->minimum_n_clk < le32_to_cpu(info_v9->ulNbpStateNClkFreq[i]) ?
-			info->minimum_n_clk : le32_to_cpu(info_v9->ulNbpStateNClkFreq[i]);
+					info->minimum_n_clk < le32_to_cpu(info_v9->ulNbpStateNClkFreq[i]) ?
+							info->minimum_n_clk : le32_to_cpu(info_v9->ulNbpStateNClkFreq[i]);
 
 		info->idle_n_clk = le32_to_cpu(info_v9->ulIdleNClk);
 		info->ddr_dll_power_up_time =
@@ -4593,11 +4604,11 @@ static enum bp_result get_integrated_info_v9(
 		for (i = 0; i < NUMBER_OF_AVAILABLE_SCLK; ++i) {
 			/* Convert [10KHz] into [KHz] */
 			info->avail_s_clk[i].supported_s_clk =
-				le32_to_cpu(info_v9->sAvail_SCLK[i].ulSupportedSCLK) * 10;
+					le32_to_cpu(info_v9->sAvail_SCLK[i].ulSupportedSCLK) * 10;
 			info->avail_s_clk[i].voltage_index =
-				le16_to_cpu(info_v9->sAvail_SCLK[i].usVoltageIndex);
+					le16_to_cpu(info_v9->sAvail_SCLK[i].usVoltageIndex);
 			info->avail_s_clk[i].voltage_id =
-				le16_to_cpu(info_v9->sAvail_SCLK[i].usVoltageID);
+					le16_to_cpu(info_v9->sAvail_SCLK[i].usVoltageID);
 		}
 
 		for (i = 0; i < NUMBER_OF_UCHAR_FOR_GUID; ++i) {
@@ -4608,22 +4619,22 @@ static enum bp_result get_integrated_info_v9(
 		for (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; ++i) {
 			info->ext_disp_conn_info.path[i].device_connector_id =
 					object_id_from_bios_object_id(
-			le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceConnector));
+							le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceConnector));
 
 			info->ext_disp_conn_info.path[i].ext_encoder_obj_id =
 					object_id_from_bios_object_id(
-			le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usExtEncoderObjId));
+							le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usExtEncoderObjId));
 
 			info->ext_disp_conn_info.path[i].device_tag =
-				le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceTag);
+					le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceTag);
 			info->ext_disp_conn_info.path[i].device_acpi_enum =
-				le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceACPIEnum);
+					le16_to_cpu(info_v9->sExtDispConnInfo.sPath[i].usDeviceACPIEnum);
 			info->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index =
-			info_v9->sExtDispConnInfo.sPath[i].ucExtAUXDDCLutIndex;
+					info_v9->sExtDispConnInfo.sPath[i].ucExtAUXDDCLutIndex;
 			info->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index =
-			info_v9->sExtDispConnInfo.sPath[i].ucExtHPDPINLutIndex;
+					info_v9->sExtDispConnInfo.sPath[i].ucExtHPDPINLutIndex;
 			info->ext_disp_conn_info.path[i].channel_mapping.raw =
-			info_v9->sExtDispConnInfo.sPath[i].ucChannelMapping;
+					info_v9->sExtDispConnInfo.sPath[i].ucChannelMapping;
 		}
 		info->ext_disp_conn_info.checksum =
 				info_v9->sExtDispConnInfo.ucChecksum;
@@ -4658,9 +4669,9 @@ static enum bp_result construct_integrated_info(
 	struct atom_data_revision revision;
 
 	if (info != NULL &&
-		bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo) {
+			bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo) {
 		header = GET_IMAGE(ATOM_COMMON_TABLE_HEADER,
-		bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);
+				bp->master_data_tbl->ListOfDataTables.IntegratedSystemInfo);
 
 		get_atom_data_table_revision(header, &revision);
 
@@ -4687,12 +4698,12 @@ static enum bp_result construct_integrated_info(
 		for (i = 1; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {
 			for (j = i; j > 0; --j) {
 				if (
-				info->disp_clk_voltage[j].max_supported_clk <
-				info->disp_clk_voltage[j-1].max_supported_clk) {
+						info->disp_clk_voltage[j].max_supported_clk <
+						info->disp_clk_voltage[j-1].max_supported_clk) {
 					/* swap j and j - 1*/
 					temp = info->disp_clk_voltage[j-1];
 					info->disp_clk_voltage[j-1] =
-						info->disp_clk_voltage[j];
+							info->disp_clk_voltage[j];
 					info->disp_clk_voltage[j] = temp;
 				}
 			}
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
index a807ab6..8503eca 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
@@ -67,6 +67,7 @@ static void init_compute_memore_engine_pll(struct bios_parser *bp);
 static void init_external_encoder_control(struct bios_parser *bp);
 static void init_enable_disp_power_gating(struct bios_parser *bp);
 static void init_program_clock(struct bios_parser *bp);
+static void init_set_dce_clock(struct bios_parser *bp);
 
 void dal_bios_parser_init_cmd_tbl(struct bios_parser *bp)
 {
@@ -89,22 +90,23 @@ void dal_bios_parser_init_cmd_tbl(struct bios_parser *bp)
 	init_compute_memore_engine_pll(bp);
 	init_external_encoder_control(bp);
 	init_enable_disp_power_gating(bp);
+	init_set_dce_clock(bp);
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  D I G E N C O D E R C O N T R O L
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  D I G E N C O D E R C O N T R O L
+ **
+ ********************************************************************************
+ *******************************************************************************/
 static enum bp_result encoder_control_digx_v3(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl);
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl);
 
 static enum bp_result encoder_control_digx_v4(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl);
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl);
 static void init_encoder_control_dig_v1(struct bios_parser *bp);
 
 static void init_dig_encoder_control(struct bios_parser *bp)
@@ -126,14 +128,14 @@ static void init_dig_encoder_control(struct bios_parser *bp)
 }
 
 static enum bp_result encoder_control_dig_v1(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl);
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl);
 static enum bp_result encoder_control_dig1_v1(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl);
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl);
 static enum bp_result encoder_control_dig2_v1(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl);
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl);
 
 static void init_encoder_control_dig_v1(struct bios_parser *bp)
 {
@@ -153,8 +155,8 @@ static void init_encoder_control_dig_v1(struct bios_parser *bp)
 }
 
 static enum bp_result encoder_control_dig_v1(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl)
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	struct cmd_tbl *cmd_tbl = &bp->cmd_tbl;
@@ -180,8 +182,8 @@ static enum bp_result encoder_control_dig_v1(
 }
 
 static enum bp_result encoder_control_dig1_v1(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl)
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DIG_ENCODER_CONTROL_PARAMETERS_V2 params = {0};
@@ -195,8 +197,8 @@ static enum bp_result encoder_control_dig1_v1(
 }
 
 static enum bp_result encoder_control_dig2_v1(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl)
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DIG_ENCODER_CONTROL_PARAMETERS_V2 params = {0};
@@ -210,8 +212,8 @@ static enum bp_result encoder_control_dig2_v1(
 }
 
 static enum bp_result encoder_control_digx_v3(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl)
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DIG_ENCODER_CONTROL_PARAMETERS_V3 params = {0};
@@ -227,9 +229,9 @@ static enum bp_result encoder_control_digx_v3(
 	params.ucAction = bp->cmd_helper->encoder_action_to_atom(cntl->action);
 	params.usPixelClock = cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 	params.ucEncoderMode =
-		(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-				cntl->signal,
-				cntl->enable_dp_audio);
+			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+					cntl->signal,
+					cntl->enable_dp_audio);
 	params.ucLaneNum = (uint8_t)(cntl->lanes_number);
 
 	if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
@@ -257,8 +259,8 @@ static enum bp_result encoder_control_digx_v3(
 }
 
 static enum bp_result encoder_control_digx_v4(
-		struct bios_parser *bp,
-		struct bp_encoder_control *cntl)
+	struct bios_parser *bp,
+	struct bp_encoder_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DIG_ENCODER_CONTROL_PARAMETERS_V4 params = {0};
@@ -275,9 +277,9 @@ static enum bp_result encoder_control_digx_v4(
 	params.ucAction = bp->cmd_helper->encoder_action_to_atom(cntl->action);
 	params.usPixelClock = cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 	params.ucEncoderMode =
-		(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(
-				cntl->signal,
-				cntl->enable_dp_audio));
+			(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(
+					cntl->signal,
+					cntl->enable_dp_audio));
 	params.ucLaneNum = (uint8_t)(cntl->lanes_number);
 
 	if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
@@ -305,16 +307,16 @@ static enum bp_result encoder_control_digx_v4(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                 DVO ENCODER CONTROL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                 DVO ENCODER CONTROL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result dvo_encoder_control_v3(
-		struct bios_parser *bp,
-		struct bp_dvo_encoder_control *cntl);
+	struct bios_parser *bp,
+	struct bp_dvo_encoder_control *cntl);
 
 static void init_dvo_encoder_control(struct bios_parser *bp)
 {
@@ -329,8 +331,8 @@ static void init_dvo_encoder_control(struct bios_parser *bp)
 }
 
 static enum bp_result dvo_encoder_control_v3(
-		struct bios_parser *bp,
-		struct bp_dvo_encoder_control *cntl)
+	struct bios_parser *bp,
+	struct bp_dvo_encoder_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DVO_ENCODER_CONTROL_PARAMETERS_V3 params;
@@ -364,25 +366,28 @@ static enum bp_result dvo_encoder_control_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  TRANSMITTER CONTROL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  TRANSMITTER CONTROL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result transmitter_control_v2(
-		struct bios_parser *bp,
-		struct bp_transmitter_control *cntl);
+	struct bios_parser *bp,
+	struct bp_transmitter_control *cntl);
 static enum bp_result transmitter_control_v3(
-		struct bios_parser *bp,
-		struct bp_transmitter_control *cntl);
+	struct bios_parser *bp,
+	struct bp_transmitter_control *cntl);
 static enum bp_result transmitter_control_v4(
 	struct bios_parser *bp,
 	struct bp_transmitter_control *cntl);
 static enum bp_result transmitter_control_v1_5(
 	struct bios_parser *bp,
 	struct bp_transmitter_control *cntl);
+static enum bp_result transmitter_control_v1_6(
+	struct bios_parser *bp,
+	struct bp_transmitter_control *cntl);
 
 static void init_transmitter_control(struct bios_parser *bp)
 {
@@ -405,6 +410,9 @@ static void init_transmitter_control(struct bios_parser *bp)
 	case 5:
 		bp->cmd_tbl.transmitter_control = transmitter_control_v1_5;
 		break;
+	case 6:
+		bp->cmd_tbl.transmitter_control = transmitter_control_v1_6;
+		break;
 	default:
 		bp->cmd_tbl.transmitter_control = NULL;
 		break;
@@ -412,8 +420,8 @@ static void init_transmitter_control(struct bios_parser *bp)
 }
 
 static enum bp_result transmitter_control_v2(
-		struct bios_parser *bp,
-		struct bp_transmitter_control *cntl)
+	struct bios_parser *bp,
+	struct bp_transmitter_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DIG_TRANSMITTER_CONTROL_PARAMETERS_V2 params;
@@ -449,7 +457,7 @@ static enum bp_result transmitter_control_v2(
 
 		/* connector object id */
 		params.usInitInfo =
-			cpu_to_le16((uint8_t)cntl->connector_obj_id.id);
+				cpu_to_le16((uint8_t)cntl->connector_obj_id.id);
 		break;
 	case TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS:
 		/* votage swing and pre-emphsis */
@@ -471,13 +479,13 @@ static enum bp_result transmitter_control_v2(
 			 * We need to convert from KHz units into 20KHz units
 			 */
 			params.usPixelClock =
-				cpu_to_le16((uint16_t)(cntl->pixel_clock / 20));
+					cpu_to_le16((uint16_t)(cntl->pixel_clock / 20));
 		} else
 			/* link rate, half for dual link
 			 * We need to convert from KHz units into 10KHz units
 			 */
 			params.usPixelClock =
-				cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
+					cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 		break;
 	}
 
@@ -520,8 +528,8 @@ static enum bp_result transmitter_control_v2(
 	 * =3 reserved
 	 */
 	params.acConfig.ucTransmitterSel =
-		(uint8_t)bp->cmd_helper->transmitter_bp_to_atom(
-			cntl->transmitter);
+			(uint8_t)bp->cmd_helper->transmitter_bp_to_atom(
+					cntl->transmitter);
 
 	params.ucAction = (uint8_t)cntl->action;
 
@@ -532,17 +540,17 @@ static enum bp_result transmitter_control_v2(
 }
 
 static enum bp_result transmitter_control_v3(
-		struct bios_parser *bp,
-		struct bp_transmitter_control *cntl)
+	struct bios_parser *bp,
+	struct bp_transmitter_control *cntl)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DIG_TRANSMITTER_CONTROL_PARAMETERS_V3 params;
 	uint32_t pll_id;
 	enum connector_id conn_id =
-		dal_graphics_object_id_get_connector_id(cntl->connector_obj_id);
+			dal_graphics_object_id_get_connector_id(cntl->connector_obj_id);
 	const struct command_table_helper *cmd = bp->cmd_helper;
 	bool dual_link_conn = (CONNECTOR_ID_DUAL_LINK_DVII == conn_id)
-			|| (CONNECTOR_ID_DUAL_LINK_DVID == conn_id);
+					|| (CONNECTOR_ID_DUAL_LINK_DVID == conn_id);
 
 	dc_service_memset(&params, 0, sizeof(params));
 
@@ -577,7 +585,7 @@ static enum bp_result transmitter_control_v3(
 
 		/* connector object id */
 		params.usInitInfo =
-			cpu_to_le16((uint8_t)(cntl->connector_obj_id.id));
+				cpu_to_le16((uint8_t)(cntl->connector_obj_id.id));
 		break;
 	case TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS:
 		/* votage swing and pre-emphsis */
@@ -608,26 +616,26 @@ static enum bp_result transmitter_control_v3(
 			 * We need to convert from KHz units into 20KHz units
 			 */
 			params.usPixelClock =
-				cpu_to_le16((uint16_t)(cntl->pixel_clock / 20));
+					cpu_to_le16((uint16_t)(cntl->pixel_clock / 20));
 		} else {
 			/* link rate, half for dual link
 			 * We need to convert from KHz units into 10KHz units
 			 */
 			params.usPixelClock =
-				cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
+					cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 			if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
 				switch (cntl->color_depth) {
 				case COLOR_DEPTH_101010:
 					params.usPixelClock =
-						cpu_to_le16((le16_to_cpu(params.usPixelClock) * 30) / 24);
+							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 30) / 24);
 					break;
 				case COLOR_DEPTH_121212:
 					params.usPixelClock =
-						cpu_to_le16((le16_to_cpu(params.usPixelClock) * 36) / 24);
+							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 36) / 24);
 					break;
 				case COLOR_DEPTH_161616:
 					params.usPixelClock =
-						cpu_to_le16((le16_to_cpu(params.usPixelClock) * 48) / 24);
+							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 48) / 24);
 					break;
 				default:
 					break;
@@ -643,8 +651,8 @@ static enum bp_result transmitter_control_v3(
 	params.acConfig.fCoherentMode = cntl->coherent;
 
 	if ((TRANSMITTER_UNIPHY_B == cntl->transmitter)
-			|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)
-			|| (TRANSMITTER_UNIPHY_F == cntl->transmitter))
+		|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)
+		|| (TRANSMITTER_UNIPHY_F == cntl->transmitter))
 		/* Bit2: Transmitter Link selection
 		 * =0 when bit0=0, single link A/C/E, when bit0=1,
 		 * master link A/C/E
@@ -668,7 +676,7 @@ static enum bp_result transmitter_control_v3(
 	 * =3 reserved
 	 */
 	params.acConfig.ucTransmitterSel =
-		(uint8_t)cmd->transmitter_bp_to_atom(cntl->transmitter);
+			(uint8_t)cmd->transmitter_bp_to_atom(cntl->transmitter);
 
 	params.ucLaneNum = (uint8_t)cntl->lanes_number;
 
@@ -690,7 +698,7 @@ static enum bp_result transmitter_control_v4(
 	DIG_TRANSMITTER_CONTROL_PARAMETERS_V4 params;
 	uint32_t ref_clk_src_id;
 	enum connector_id conn_id =
-		dal_graphics_object_id_get_connector_id(cntl->connector_obj_id);
+			dal_graphics_object_id_get_connector_id(cntl->connector_obj_id);
 	const struct command_table_helper *cmd = bp->cmd_helper;
 
 	dc_service_memset(&params, 0, sizeof(params));
@@ -715,7 +723,7 @@ static enum bp_result transmitter_control_v4(
 	case TRANSMITTER_CONTROL_INIT:
 	{
 		if ((CONNECTOR_ID_DUAL_LINK_DVII == conn_id) ||
-			(CONNECTOR_ID_DUAL_LINK_DVID == conn_id))
+				(CONNECTOR_ID_DUAL_LINK_DVID == conn_id))
 			/* on INIT this bit should be set according to the
 			 * phisycal connector
 			 * Bit0: dual link connector flag
@@ -726,7 +734,7 @@ static enum bp_result transmitter_control_v4(
 
 		/* connector object id */
 		params.usInitInfo =
-			cpu_to_le16((uint8_t)(cntl->connector_obj_id.id));
+				cpu_to_le16((uint8_t)(cntl->connector_obj_id.id));
 	}
 	break;
 	case TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS:
@@ -736,7 +744,7 @@ static enum bp_result transmitter_control_v4(
 		break;
 	default:
 		if ((CONNECTOR_ID_DUAL_LINK_DVII == conn_id) ||
-			(CONNECTOR_ID_DUAL_LINK_DVID == conn_id))
+				(CONNECTOR_ID_DUAL_LINK_DVID == conn_id))
 			/* on ENABLE/DISABLE this bit should be set according to
 			 * actual timing (number of lanes)
 			 * Bit0: dual link connector flag
@@ -751,27 +759,27 @@ static enum bp_result transmitter_control_v4(
 			 * We need to convert from KHz units into 20KHz units
 			 */
 			params.usPixelClock =
-				cpu_to_le16((uint16_t)(cntl->pixel_clock / 20));
+					cpu_to_le16((uint16_t)(cntl->pixel_clock / 20));
 		else {
 			/* link rate, half for dual link
 			 * We need to convert from KHz units into 10KHz units
 			 */
 			params.usPixelClock =
-				cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
+					cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 
 			if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
 				switch (cntl->color_depth) {
 				case COLOR_DEPTH_101010:
 					params.usPixelClock =
-						cpu_to_le16((le16_to_cpu(params.usPixelClock) * 30) / 24);
+							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 30) / 24);
 					break;
 				case COLOR_DEPTH_121212:
 					params.usPixelClock =
-						cpu_to_le16((le16_to_cpu(params.usPixelClock) * 36) / 24);
+							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 36) / 24);
 					break;
 				case COLOR_DEPTH_161616:
 					params.usPixelClock =
-						cpu_to_le16((le16_to_cpu(params.usPixelClock) * 48) / 24);
+							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 48) / 24);
 					break;
 				default:
 					break;
@@ -878,8 +886,8 @@ static enum bp_result transmitter_control_v1_5(
 			break;
 		}
 		break;
-	default:
-		break;
+		default:
+			break;
 	}
 
 	if (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))
@@ -888,13 +896,76 @@ static enum bp_result transmitter_control_v1_5(
 	return result;
 }
 
+static enum bp_result transmitter_control_v1_6(
+	struct bios_parser *bp,
+	struct bp_transmitter_control *cntl)
+{
+	enum bp_result result = BP_RESULT_FAILURE;
+#ifdef LATEST_ATOM_BIOS_SUPPORT
+	const struct command_table_helper *cmd = bp->cmd_helper;
+	DIG_TRANSMITTER_CONTROL_PARAMETERS_V1_6 params;
+
+	dc_service_memset(&params, 0, sizeof(params));
+	params.ucPhyId = cmd->phy_id_to_atom(cntl->transmitter);
+	params.ucAction = (uint8_t)cntl->action;
+
+	if (cntl->action == TRANSMITTER_CONTROL_SET_VOLTAGE_AND_PREEMPASIS)
+		params.ucDPLaneSet = (uint8_t)cntl->lane_settings;
+	else
+		params.ucDigMode = cmd->signal_type_to_atom_dig_mode(cntl->signal);
+
+	params.ucLaneNum = (uint8_t)cntl->lanes_number;
+	params.ucHPDSel = cmd->hpd_sel_to_atom(cntl->hpd_sel);
+	params.ucDigEncoderSel = cmd->dig_encoder_sel_to_atom(cntl->engine_id);
+	params.ucConnObjId = (uint8_t)cntl->connector_obj_id.id;
+	params.ulSymClock = cntl->pixel_clock/10;
+
+	/*
+	 * In SI/TN case, caller have to set usPixelClock as following:
+	 * DP mode: usPixelClock = DP_LINK_CLOCK/10
+	 * (DP_LINK_CLOCK = 1.62GHz, 2.7GHz, 5.4GHz)
+	 * DVI single link mode: usPixelClock = pixel clock
+	 * DVI dual link mode: usPixelClock = pixel clock
+	 * HDMI mode: usPixelClock = pixel clock * deep_color_ratio
+	 * (=1: 8bpp, =1.25: 10bpp, =1.5:12bpp, =2: 16bpp)
+	 * LVDS mode: usPixelClock = pixel clock
+	 */
+	switch (cntl->signal) {
+	case SIGNAL_TYPE_HDMI_TYPE_A:
+		switch (cntl->color_depth) {
+		case COLOR_DEPTH_101010:
+			params.ulSymClock =
+				cpu_to_le16((le16_to_cpu(params.ulSymClock) * 30) / 24);
+			break;
+		case COLOR_DEPTH_121212:
+			params.ulSymClock =
+				cpu_to_le16((le16_to_cpu(params.ulSymClock) * 36) / 24);
+			break;
+		case COLOR_DEPTH_161616:
+			params.ulSymClock =
+				cpu_to_le16((le16_to_cpu(params.ulSymClock) * 48) / 24);
+			break;
+		default:
+			break;
+		}
+		break;
+		default:
+			break;
+	}
+
+	if (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))
+		result = BP_RESULT_OK;
+#endif
+	return result;
+}
+
 /*******************************************************************************
-********************************************************************************
-**
-**                  SET PIXEL CLOCK
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  SET PIXEL CLOCK
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result set_pixel_clock_v3(
 	struct bios_parser *bp,
@@ -905,6 +976,9 @@ static enum bp_result set_pixel_clock_v5(
 static enum bp_result set_pixel_clock_v6(
 	struct bios_parser *bp,
 	struct bp_pixel_clock_parameters *bp_params);
+static enum bp_result set_pixel_clock_v7(
+	struct bios_parser *bp,
+	struct bp_pixel_clock_parameters *bp_params);
 
 static void init_set_pixel_clock(struct bios_parser *bp)
 {
@@ -918,6 +992,9 @@ static void init_set_pixel_clock(struct bios_parser *bp)
 	case 6:
 		bp->cmd_tbl.set_pixel_clock = set_pixel_clock_v6;
 		break;
+	case 7:
+		bp->cmd_tbl.set_pixel_clock = set_pixel_clock_v7;
+		break;
 	default:
 		bp->cmd_tbl.set_pixel_clock = NULL;
 		break;
@@ -942,26 +1019,26 @@ static enum bp_result set_pixel_clock_v3(
 		return BP_RESULT_BADINPUT;
 
 	allocation.sPCLKInput.usRefDiv =
-		cpu_to_le16((uint16_t)bp_params->reference_divider);
+			cpu_to_le16((uint16_t)bp_params->reference_divider);
 	allocation.sPCLKInput.usFbDiv =
-		cpu_to_le16((uint16_t)bp_params->feedback_divider);
+			cpu_to_le16((uint16_t)bp_params->feedback_divider);
 	allocation.sPCLKInput.ucFracFbDiv =
-		(uint8_t)bp_params->fractional_feedback_divider;
+			(uint8_t)bp_params->fractional_feedback_divider;
 	allocation.sPCLKInput.ucPostDiv =
-		(uint8_t)bp_params->pixel_clock_post_divider;
+			(uint8_t)bp_params->pixel_clock_post_divider;
 
 	/* We need to convert from KHz units into 10KHz units */
 	allocation.sPCLKInput.usPixelClock =
-		cpu_to_le16((uint16_t)(bp_params->target_pixel_clock / 10));
+			cpu_to_le16((uint16_t)(bp_params->target_pixel_clock / 10));
 
 	params = (PIXEL_CLOCK_PARAMETERS_V3 *)&allocation.sPCLKInput;
 	params->ucTransmitterId =
-		bp->cmd_helper->encoder_id_to_atom(
-			dal_graphics_object_id_get_encoder_id(
-				bp_params->encoder_object_id));
+			bp->cmd_helper->encoder_id_to_atom(
+					dal_graphics_object_id_get_encoder_id(
+							bp_params->encoder_object_id));
 	params->ucEncoderMode =
-		(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(
-			bp_params->signal_type, false));
+			(uint8_t)(bp->cmd_helper->encoder_mode_bp_to_atom(
+					bp_params->signal_type, false));
 
 	if (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)
 		params->ucMiscInfo |= PIXEL_CLOCK_MISC_FORCE_PROG_PPLL;
@@ -1008,37 +1085,37 @@ static enum bp_result set_pixel_clock_v5(
 	dc_service_memset(&clk, 0, sizeof(clk));
 
 	if (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)
-		&& bp->cmd_helper->controller_id_to_atom(
-			bp_params->controller_id, &controller_id)) {
+			&& bp->cmd_helper->controller_id_to_atom(
+					bp_params->controller_id, &controller_id)) {
 		clk.sPCLKInput.ucCRTC = controller_id;
 		clk.sPCLKInput.ucPpll = (uint8_t)pll_id;
 		clk.sPCLKInput.ucRefDiv =
-			(uint8_t)(bp_params->reference_divider);
+				(uint8_t)(bp_params->reference_divider);
 		clk.sPCLKInput.usFbDiv =
-			cpu_to_le16((uint16_t)(bp_params->feedback_divider));
+				cpu_to_le16((uint16_t)(bp_params->feedback_divider));
 		clk.sPCLKInput.ulFbDivDecFrac =
-			cpu_to_le32(bp_params->fractional_feedback_divider);
+				cpu_to_le32(bp_params->fractional_feedback_divider);
 		clk.sPCLKInput.ucPostDiv =
-			(uint8_t)(bp_params->pixel_clock_post_divider);
+				(uint8_t)(bp_params->pixel_clock_post_divider);
 		clk.sPCLKInput.ucTransmitterID =
-			bp->cmd_helper->encoder_id_to_atom(
-				dal_graphics_object_id_get_encoder_id(
-					bp_params->encoder_object_id));
+				bp->cmd_helper->encoder_id_to_atom(
+						dal_graphics_object_id_get_encoder_id(
+								bp_params->encoder_object_id));
 		clk.sPCLKInput.ucEncoderMode =
-			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-				bp_params->signal_type, false);
+				(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+						bp_params->signal_type, false);
 
 		/* We need to convert from KHz units into 10KHz units */
 		clk.sPCLKInput.usPixelClock =
-			cpu_to_le16((uint16_t)(bp_params->target_pixel_clock / 10));
+				cpu_to_le16((uint16_t)(bp_params->target_pixel_clock / 10));
 
 		if (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)
 			clk.sPCLKInput.ucMiscInfo |=
-				PIXEL_CLOCK_MISC_FORCE_PROG_PPLL;
+					PIXEL_CLOCK_MISC_FORCE_PROG_PPLL;
 
 		if (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)
 			clk.sPCLKInput.ucMiscInfo |=
-				PIXEL_CLOCK_MISC_REF_DIV_SRC;
+					PIXEL_CLOCK_MISC_REF_DIV_SRC;
 
 		/* clkV5.ucMiscInfo bit[3:2]= HDMI panel bit depth: =0: 24bpp
 		 * =1:30bpp, =2:32bpp
@@ -1065,8 +1142,8 @@ static enum bp_result set_pixel_clock_v6(
 	dc_service_memset(&clk, 0, sizeof(clk));
 
 	if (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)
-		&& bp->cmd_helper->controller_id_to_atom(
-			bp_params->controller_id, &controller_id)) {
+			&& bp->cmd_helper->controller_id_to_atom(
+					bp_params->controller_id, &controller_id)) {
 		/* Note: VBIOS still wants to use ucCRTC name which is now
 		 * 1 byte in ULONG
 		 *typedef struct _CRTC_PIXEL_CLOCK_FREQ
@@ -1089,33 +1166,33 @@ static enum bp_result set_pixel_clock_v6(
 		clk.sPCLKInput.ulCrtcPclkFreq.ucCRTC = controller_id;
 		clk.sPCLKInput.ucPpll = (uint8_t) pll_id;
 		clk.sPCLKInput.ucRefDiv =
-			(uint8_t) bp_params->reference_divider;
+				(uint8_t) bp_params->reference_divider;
 		clk.sPCLKInput.usFbDiv =
-			cpu_to_le16((uint16_t) bp_params->feedback_divider);
+				cpu_to_le16((uint16_t) bp_params->feedback_divider);
 		clk.sPCLKInput.ulFbDivDecFrac =
-			cpu_to_le32(bp_params->fractional_feedback_divider);
+				cpu_to_le32(bp_params->fractional_feedback_divider);
 		clk.sPCLKInput.ucPostDiv =
-			(uint8_t) bp_params->pixel_clock_post_divider;
+				(uint8_t) bp_params->pixel_clock_post_divider;
 		clk.sPCLKInput.ucTransmitterID =
-			bp->cmd_helper->encoder_id_to_atom(
-				dal_graphics_object_id_get_encoder_id(
-					bp_params->encoder_object_id));
+				bp->cmd_helper->encoder_id_to_atom(
+						dal_graphics_object_id_get_encoder_id(
+								bp_params->encoder_object_id));
 		clk.sPCLKInput.ucEncoderMode =
-			(uint8_t) bp->cmd_helper->encoder_mode_bp_to_atom(
-				bp_params->signal_type, false);
+				(uint8_t) bp->cmd_helper->encoder_mode_bp_to_atom(
+						bp_params->signal_type, false);
 
 		/* We need to convert from KHz units into 10KHz units */
 		clk.sPCLKInput.ulCrtcPclkFreq.ulPixelClock =
-			cpu_to_le32(bp_params->target_pixel_clock / 10);
+				cpu_to_le32(bp_params->target_pixel_clock / 10);
 
 		if (bp_params->flags.FORCE_PROGRAMMING_OF_PLL) {
 			clk.sPCLKInput.ucMiscInfo |=
-				PIXEL_CLOCK_V6_MISC_FORCE_PROG_PPLL;
+					PIXEL_CLOCK_V6_MISC_FORCE_PROG_PPLL;
 		}
 
 		if (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC) {
 			clk.sPCLKInput.ucMiscInfo |=
-				PIXEL_CLOCK_V6_MISC_REF_DIV_SRC;
+					PIXEL_CLOCK_V6_MISC_REF_DIV_SRC;
 		}
 
 		/* clkV6.ucMiscInfo bit[3:2]= HDMI panel bit depth: =0:
@@ -1131,13 +1208,84 @@ static enum bp_result set_pixel_clock_v6(
 	return result;
 }
 
+static enum bp_result set_pixel_clock_v7(
+	struct bios_parser *bp,
+	struct bp_pixel_clock_parameters *bp_params)
+{
+	enum bp_result result = BP_RESULT_FAILURE;
+#ifdef LATEST_ATOM_BIOS_SUPPORT
+	PIXEL_CLOCK_PARAMETERS_V7 clk;
+	uint8_t controller_id;
+	uint32_t pll_id;
+
+	dc_service_memset(&clk, 0, sizeof(clk));
+
+	if (bp->cmd_helper->clock_source_id_to_atom(bp_params->pll_id, &pll_id)
+			&& bp->cmd_helper->controller_id_to_atom(bp_params->controller_id, &controller_id)) {
+		/* Note: VBIOS still wants to use ucCRTC name which is now
+		 * 1 byte in ULONG
+		 *typedef struct _CRTC_PIXEL_CLOCK_FREQ
+		 *{
+		 * target the pixel clock to drive the CRTC timing.
+		 * ULONG ulPixelClock:24;
+		 * 0 means disable PPLL/DCPLL. Expanded to 24 bits comparing to
+		 * previous version.
+		 * ATOM_CRTC1~6, indicate the CRTC controller to
+		 * ULONG ucCRTC:8;
+		 * drive the pixel clock. not used for DCPLL case.
+		 *}CRTC_PIXEL_CLOCK_FREQ;
+		 *union
+		 *{
+		 * pixel clock and CRTC id frequency
+		 * CRTC_PIXEL_CLOCK_FREQ ulCrtcPclkFreq;
+		 * ULONG ulDispEngClkFreq; dispclk frequency
+		 *};
+		 */
+		clk.ucCRTC = controller_id;
+		clk.ucPpll = (uint8_t) pll_id;
+		clk.ucTransmitterID = bp->cmd_helper->encoder_id_to_atom(dal_graphics_object_id_get_encoder_id(bp_params->encoder_object_id));
+		clk.ucEncoderMode = (uint8_t) bp->cmd_helper->encoder_mode_bp_to_atom(bp_params->signal_type, false);
+
+		/* We need to convert from KHz units into 10KHz units */
+		clk.ulPixelClock = cpu_to_le32(bp_params->target_pixel_clock / 10);
+
+		clk.ucDeepColorRatio = (uint8_t) bp->cmd_helper->transmitter_color_depth_to_atom(bp_params->color_depth);
+
+		if (bp_params->flags.FORCE_PROGRAMMING_OF_PLL)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_FORCE_PROG_PPLL;
+
+		if (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC;
+
+		if (bp_params->flags.PROGRAM_PHY_PLL_ONLY)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_PROG_PHYPLL;
+
+		if (bp_params->flags.SUPPORT_YUV_420)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_YUV420_MODE;
+
+		if (bp_params->flags.SET_XTALIN_REF_SRC)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC_XTALIN;
+
+		if (bp_params->flags.SET_GENLOCK_REF_DIV_SRC)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_REF_DIV_SRC_GENLK;
+
+		if (bp_params->signal_type == SIGNAL_TYPE_DVI_DUAL_LINK)
+			clk.ucMiscInfo |= PIXEL_CLOCK_V7_MISC_DVI_DUALLINK_EN;
+
+		if (EXEC_BIOS_CMD_TABLE(SetPixelClock, clk))
+			result = BP_RESULT_OK;
+	}
+#endif
+	return result;
+}
+
 /*******************************************************************************
-********************************************************************************
-**
-**                  ENABLE PIXEL CLOCK SS
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  ENABLE PIXEL CLOCK SS
+ **
+ ********************************************************************************
+ *******************************************************************************/
 static enum bp_result enable_spread_spectrum_on_ppll_v1(
 	struct bios_parser *bp,
 	struct bp_spread_spectrum_parameters *bp_params,
@@ -1156,15 +1304,15 @@ static void init_enable_spread_spectrum_on_ppll(struct bios_parser *bp)
 	switch (BIOS_CMD_TABLE_PARA_REVISION(EnableSpreadSpectrumOnPPLL)) {
 	case 1:
 		bp->cmd_tbl.enable_spread_spectrum_on_ppll =
-			enable_spread_spectrum_on_ppll_v1;
+				enable_spread_spectrum_on_ppll_v1;
 		break;
 	case 2:
 		bp->cmd_tbl.enable_spread_spectrum_on_ppll =
-			enable_spread_spectrum_on_ppll_v2;
+				enable_spread_spectrum_on_ppll_v2;
 		break;
 	case 3:
 		bp->cmd_tbl.enable_spread_spectrum_on_ppll =
-			enable_spread_spectrum_on_ppll_v3;
+				enable_spread_spectrum_on_ppll_v3;
 		break;
 	default:
 		bp->cmd_tbl.enable_spread_spectrum_on_ppll = NULL;
@@ -1188,14 +1336,14 @@ static enum bp_result enable_spread_spectrum_on_ppll_v1(
 		params.ucEnable = ATOM_DISABLE;
 
 	params.usSpreadSpectrumPercentage =
-		cpu_to_le16((uint16_t)bp_params->percentage);
+			cpu_to_le16((uint16_t)bp_params->percentage);
 	params.ucSpreadSpectrumStep =
-		(uint8_t)bp_params->ver1.step;
+			(uint8_t)bp_params->ver1.step;
 	params.ucSpreadSpectrumDelay =
-		(uint8_t)bp_params->ver1.delay;
+			(uint8_t)bp_params->ver1.delay;
 	/* convert back to unit of 10KHz */
 	params.ucSpreadSpectrumRange =
-		(uint8_t)(bp_params->ver1.range / 10000);
+			(uint8_t)(bp_params->ver1.range / 10000);
 
 	if (bp_params->flags.EXTERNAL_SS)
 		params.ucSpreadSpectrumType |= ATOM_EXTERNAL_SS_MASK;
@@ -1237,28 +1385,28 @@ static enum bp_result enable_spread_spectrum_on_ppll_v2(
 		params.ucEnable = ATOM_ENABLE;
 
 		params.usSpreadSpectrumPercentage =
-			cpu_to_le16((uint16_t)(bp_params->percentage));
+				cpu_to_le16((uint16_t)(bp_params->percentage));
 		params.usSpreadSpectrumStep =
-			cpu_to_le16((uint16_t)(bp_params->ds.ds_frac_size));
+				cpu_to_le16((uint16_t)(bp_params->ds.ds_frac_size));
 
 		if (bp_params->flags.EXTERNAL_SS)
 			params.ucSpreadSpectrumType |=
-				ATOM_PPLL_SS_TYPE_V2_EXT_SPREAD;
+					ATOM_PPLL_SS_TYPE_V2_EXT_SPREAD;
 
 		if (bp_params->flags.CENTER_SPREAD)
 			params.ucSpreadSpectrumType |=
-				ATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD;
+					ATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD;
 
 		/* Both amounts need to be left shifted first before bit
 		 * comparison. Otherwise, the result will always be zero here
 		 */
 		params.usSpreadSpectrumAmount = cpu_to_le16((uint16_t)(
-			((bp_params->ds.feedback_amount <<
-				ATOM_PPLL_SS_AMOUNT_V2_FBDIV_SHIFT) &
-				ATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK) |
-			((bp_params->ds.nfrac_amount <<
-				ATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT) &
-				ATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK)));
+				((bp_params->ds.feedback_amount <<
+						ATOM_PPLL_SS_AMOUNT_V2_FBDIV_SHIFT) &
+						ATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK) |
+						((bp_params->ds.nfrac_amount <<
+								ATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT) &
+								ATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK)));
 	} else
 		params.ucEnable = ATOM_DISABLE;
 
@@ -1307,27 +1455,27 @@ static enum bp_result enable_spread_spectrum_on_ppll_v3(
 		params.ucEnable = ATOM_ENABLE;
 
 		params.usSpreadSpectrumAmountFrac =
-			cpu_to_le16((uint16_t)(bp_params->ds_frac_amount));
+				cpu_to_le16((uint16_t)(bp_params->ds_frac_amount));
 		params.usSpreadSpectrumStep =
-			cpu_to_le16((uint16_t)(bp_params->ds.ds_frac_size));
+				cpu_to_le16((uint16_t)(bp_params->ds.ds_frac_size));
 
 		if (bp_params->flags.EXTERNAL_SS)
 			params.ucSpreadSpectrumType |=
-				ATOM_PPLL_SS_TYPE_V3_EXT_SPREAD;
+					ATOM_PPLL_SS_TYPE_V3_EXT_SPREAD;
 		if (bp_params->flags.CENTER_SPREAD)
 			params.ucSpreadSpectrumType |=
-				ATOM_PPLL_SS_TYPE_V3_CENTRE_SPREAD;
+					ATOM_PPLL_SS_TYPE_V3_CENTRE_SPREAD;
 
 		/* Both amounts need to be left shifted first before bit
 		 * comparison. Otherwise, the result will always be zero here
 		 */
 		params.usSpreadSpectrumAmount = cpu_to_le16((uint16_t)(
-			((bp_params->ds.feedback_amount <<
-				ATOM_PPLL_SS_AMOUNT_V3_FBDIV_SHIFT) &
-				ATOM_PPLL_SS_AMOUNT_V3_FBDIV_MASK) |
-			((bp_params->ds.nfrac_amount <<
-				ATOM_PPLL_SS_AMOUNT_V3_NFRAC_SHIFT) &
-				ATOM_PPLL_SS_AMOUNT_V3_NFRAC_MASK)));
+				((bp_params->ds.feedback_amount <<
+						ATOM_PPLL_SS_AMOUNT_V3_FBDIV_SHIFT) &
+						ATOM_PPLL_SS_AMOUNT_V3_FBDIV_MASK) |
+						((bp_params->ds.nfrac_amount <<
+								ATOM_PPLL_SS_AMOUNT_V3_NFRAC_SHIFT) &
+								ATOM_PPLL_SS_AMOUNT_V3_NFRAC_MASK)));
 	} else
 		params.ucEnable = ATOM_DISABLE;
 
@@ -1338,12 +1486,12 @@ static enum bp_result enable_spread_spectrum_on_ppll_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  ADJUST DISPLAY PLL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  ADJUST DISPLAY PLL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result adjust_display_pll_v2(
 	struct bios_parser *bp,
@@ -1372,7 +1520,7 @@ static bool adjust_display_pll_bug_patch(ADJUST_DISPLAY_PLL_PARAMETERS *params)
 	/* vbios bug: pixel clock should not be doubled for DVO with 24bit
 	 * interface */
 	if ((params->ucTransmitterID == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1)
-		&& (params->ucDVOConfig == DVO_ENCODER_CONFIG_24BIT))
+			&& (params->ucDVOConfig == DVO_ENCODER_CONFIG_24BIT))
 		/* the current pixel clock is good. no adjustment is required */
 		return true;
 	return false;
@@ -1391,16 +1539,16 @@ static enum bp_result adjust_display_pll_v2(
 
 	params.usPixelClock = cpu_to_le16((uint16_t)(pixel_clock_10KHz_in));
 	params.ucTransmitterID =
-		bp->cmd_helper->encoder_id_to_atom(
-			dal_graphics_object_id_get_encoder_id(
-				bp_params->encoder_object_id));
+			bp->cmd_helper->encoder_id_to_atom(
+					dal_graphics_object_id_get_encoder_id(
+							bp_params->encoder_object_id));
 	params.ucEncodeMode =
-		(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-			bp_params->signal_type, false);
+			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+					bp_params->signal_type, false);
 	params.ucDVOConfig = (uint8_t)(bp_params->dvo_config);
 
 	if (adjust_display_pll_bug_patch(&params)
-		|| EXEC_BIOS_CMD_TABLE(AdjustDisplayPll, params)) {
+			|| EXEC_BIOS_CMD_TABLE(AdjustDisplayPll, params)) {
 		/* Convert output pixel clock back 10KHz-->KHz: multiply
 		 * original pixel clock in KHz by ratio
 		 * [output pxlClk/input pxlClk] */
@@ -1409,8 +1557,8 @@ static enum bp_result adjust_display_pll_v2(
 		uint64_t pixel_clock = (uint64_t)bp_params->pixel_clock;
 
 		bp_params->adjusted_pixel_clock =
-			div_u64(pixel_clock * pixel_clock_10KHz_out,
-				pixel_clock_10KHz_in);
+				div_u64(pixel_clock * pixel_clock_10KHz_out,
+						pixel_clock_10KHz_in);
 		result = BP_RESULT_OK;
 	}
 
@@ -1431,31 +1579,31 @@ static enum bp_result adjust_display_pll_v3(
 	 * output pixel clock back 10KHz-->KHz */
 	params.sInput.usPixelClock = cpu_to_le16((uint16_t)pixel_clk_10_kHz_in);
 	params.sInput.ucTransmitterID =
-		bp->cmd_helper->encoder_id_to_atom(
-			dal_graphics_object_id_get_encoder_id(
-				bp_params->encoder_object_id));
+			bp->cmd_helper->encoder_id_to_atom(
+					dal_graphics_object_id_get_encoder_id(
+							bp_params->encoder_object_id));
 	params.sInput.ucEncodeMode =
-		(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-			bp_params->signal_type, false);
+			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+					bp_params->signal_type, false);
 
 	if (DISP_PLL_CONFIG_DVO_DDR_MODE_LOW_12BIT ==
-		bp_params->display_pll_config)
+			bp_params->display_pll_config)
 		params.sInput.ucDispPllConfig =
-			DISPPLL_CONFIG_DVO_DDR_SPEED |
-			DISPPLL_CONFIG_DVO_LOW12BIT;
+				DISPPLL_CONFIG_DVO_DDR_SPEED |
+				DISPPLL_CONFIG_DVO_LOW12BIT;
 	else if (DISP_PLL_CONFIG_DVO_DDR_MODE_UPPER_12BIT ==
-		bp_params->display_pll_config)
+			bp_params->display_pll_config)
 		params.sInput.ucDispPllConfig =
-			DISPPLL_CONFIG_DVO_DDR_SPEED |
-			DISPPLL_CONFIG_DVO_UPPER12BIT;
+				DISPPLL_CONFIG_DVO_DDR_SPEED |
+				DISPPLL_CONFIG_DVO_UPPER12BIT;
 	else if (DISP_PLL_CONFIG_DVO_DDR_MODE_24BIT ==
-		bp_params->display_pll_config)
+			bp_params->display_pll_config)
 		params.sInput.ucDispPllConfig =
-			DISPPLL_CONFIG_DVO_DDR_SPEED | DISPPLL_CONFIG_DVO_24BIT;
+				DISPPLL_CONFIG_DVO_DDR_SPEED | DISPPLL_CONFIG_DVO_24BIT;
 	else
 		/* this does not mean anything here */
 		params.sInput.ucDispPllConfig =
-			(uint8_t)(bp_params->display_pll_config);
+				(uint8_t)(bp_params->display_pll_config);
 
 	if (bp_params->ss_enable == true)
 		params.sInput.ucDispPllConfig |= DISPPLL_CONFIG_SS_ENABLE;
@@ -1468,13 +1616,13 @@ static enum bp_result adjust_display_pll_v3(
 		 * original pixel clock in KHz by ratio
 		 * [output pxlClk/input pxlClk] */
 		uint64_t pixel_clk_10_khz_out =
-			(uint64_t)le32_to_cpu(params.sOutput.ulDispPllFreq);
+				(uint64_t)le32_to_cpu(params.sOutput.ulDispPllFreq);
 		uint64_t pixel_clk = (uint64_t)bp_params->pixel_clock;
 
 		if (pixel_clk_10_kHz_in != 0) {
 			bp_params->adjusted_pixel_clock =
-				div_u64(pixel_clk * pixel_clk_10_khz_out,
-					pixel_clk_10_kHz_in);
+					div_u64(pixel_clk * pixel_clk_10_khz_out,
+							pixel_clk_10_kHz_in);
 		} else {
 			bp_params->adjusted_pixel_clock = 0;
 			BREAK_TO_DEBUGGER();
@@ -1490,12 +1638,12 @@ static enum bp_result adjust_display_pll_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  DAC ENCODER CONTROL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  DAC ENCODER CONTROL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result dac1_encoder_control_v1(
 	struct bios_parser *bp,
@@ -1589,12 +1737,12 @@ static enum bp_result dac2_encoder_control_v1(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  DAC OUTPUT CONTROL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  DAC OUTPUT CONTROL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 static enum bp_result dac1_output_control_v1(
 	struct bios_parser *bp,
 	bool enable);
@@ -1623,7 +1771,7 @@ static void init_dac_output_control(struct bios_parser *bp)
 }
 
 static enum bp_result dac1_output_control_v1(
-		struct bios_parser *bp, bool enable)
+	struct bios_parser *bp, bool enable)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION params;
@@ -1640,7 +1788,7 @@ static enum bp_result dac1_output_control_v1(
 }
 
 static enum bp_result dac2_output_control_v1(
-		struct bios_parser *bp, bool enable)
+	struct bios_parser *bp, bool enable)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	DISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION params;
@@ -1657,12 +1805,12 @@ static enum bp_result dac2_output_control_v1(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  DAC LOAD DETECTION
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  DAC LOAD DETECTION
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum signal_type dac_load_detection_v3(
 	struct bios_parser *bp,
@@ -1711,8 +1859,8 @@ static enum signal_type dac_load_detection_v3(
 			break;
 		}
 		break;
-	default:
-		return signal;
+		default:
+			return signal;
 	}
 
 	/* set the encoder to detect on */
@@ -1736,10 +1884,10 @@ static enum signal_type dac_load_detection_v3(
 		return signal;
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
 	signal = bp->bios_helper->detect_sink(
-		bp->ctx,
-		encoder,
-		connector,
-		display_signal);
+			bp->ctx,
+			encoder,
+			connector,
+			display_signal);
 #else
 	BREAK_TO_DEBUGGER(); /* VBios is needed */
 #endif
@@ -1748,17 +1896,17 @@ static enum signal_type dac_load_detection_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                 BLANK CRTC
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                 BLANK CRTC
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result blank_crtc_v1(
-		struct bios_parser *bp,
-		struct bp_blank_crtc_parameters *bp_params,
-		bool blank);
+	struct bios_parser *bp,
+	struct bp_blank_crtc_parameters *bp_params,
+	bool blank);
 
 static void init_blank_crtc(struct bios_parser *bp)
 {
@@ -1773,9 +1921,9 @@ static void init_blank_crtc(struct bios_parser *bp)
 }
 
 static enum bp_result blank_crtc_v1(
-		struct bios_parser *bp,
-		struct bp_blank_crtc_parameters *bp_params,
-		bool blank)
+	struct bios_parser *bp,
+	struct bp_blank_crtc_parameters *bp_params,
+	bool blank)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	BLANK_CRTC_PARAMETERS params = {0};
@@ -1790,11 +1938,11 @@ static enum bp_result blank_crtc_v1(
 		else
 			params.ucBlanking = ATOM_BLANKING_OFF;
 		params.usBlackColorRCr =
-			cpu_to_le16((uint16_t)bp_params->black_color_rcr);
+				cpu_to_le16((uint16_t)bp_params->black_color_rcr);
 		params.usBlackColorGY =
-			cpu_to_le16((uint16_t)bp_params->black_color_gy);
+				cpu_to_le16((uint16_t)bp_params->black_color_gy);
 		params.usBlackColorBCb =
-			cpu_to_le16((uint16_t)bp_params->black_color_bcb);
+				cpu_to_le16((uint16_t)bp_params->black_color_bcb);
 
 		if (EXEC_BIOS_CMD_TABLE(BlankCRTC, params))
 			result = BP_RESULT_OK;
@@ -1808,29 +1956,29 @@ static enum bp_result blank_crtc_v1(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  SET CRTC TIMING
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  SET CRTC TIMING
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result set_crtc_using_dtd_timing_v3(
-		struct bios_parser *bp,
-		struct bp_hw_crtc_timing_parameters *bp_params);
+	struct bios_parser *bp,
+	struct bp_hw_crtc_timing_parameters *bp_params);
 static enum bp_result set_crtc_timing_v1(
-		struct bios_parser *bp,
-		struct bp_hw_crtc_timing_parameters *bp_params);
+	struct bios_parser *bp,
+	struct bp_hw_crtc_timing_parameters *bp_params);
 
 static void init_set_crtc_timing(struct bios_parser *bp)
 {
 	uint32_t dtd_version =
-		BIOS_CMD_TABLE_PARA_REVISION(SetCRTC_UsingDTDTiming);
+			BIOS_CMD_TABLE_PARA_REVISION(SetCRTC_UsingDTDTiming);
 	if (dtd_version > 2)
 		switch (dtd_version) {
 		case 3:
 			bp->cmd_tbl.set_crtc_timing =
-				set_crtc_using_dtd_timing_v3;
+					set_crtc_using_dtd_timing_v3;
 			break;
 		default:
 			bp->cmd_tbl.set_crtc_timing = NULL;
@@ -1848,15 +1996,15 @@ static void init_set_crtc_timing(struct bios_parser *bp)
 }
 
 static enum bp_result set_crtc_timing_v1(
-		struct bios_parser *bp,
-		struct bp_hw_crtc_timing_parameters *bp_params)
+	struct bios_parser *bp,
+	struct bp_hw_crtc_timing_parameters *bp_params)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION params = {0};
 	uint8_t atom_controller_id;
 
 	if (bp->cmd_helper->controller_id_to_atom(
-		bp_params->controller_id, &atom_controller_id))
+			bp_params->controller_id, &atom_controller_id))
 		params.ucCRTC = atom_controller_id;
 
 	params.usH_Total = cpu_to_le16((uint16_t)(bp_params->h_total));
@@ -1884,15 +2032,15 @@ static enum bp_result set_crtc_timing_v1(
 
 	if (0 == bp_params->flags.HSYNC_POSITIVE_POLARITY)
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_HSYNC_POLARITY);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_HSYNC_POLARITY);
 
 	if (0 == bp_params->flags.VSYNC_POSITIVE_POLARITY)
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);
 
 	if (bp_params->flags.INTERLACE) {
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);
 
 		/* original DAL code has this condition to apply tis for
 		 * non-TV/CV only due to complex MV testing for possible
@@ -1908,12 +2056,12 @@ static enum bp_result set_crtc_timing_v1(
 		 * (spec CEA 861) or CEA timing table.
 		 */
 		params.usV_SyncStart =
-			cpu_to_le16((uint16_t)(bp_params->v_sync_start + 1));
+				cpu_to_le16((uint16_t)(bp_params->v_sync_start + 1));
 	}
 
 	if (bp_params->flags.HORZ_COUNT_BY_TWO)
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);
 
 	if (EXEC_BIOS_CMD_TABLE(SetCRTC_Timing, params))
 		result = BP_RESULT_OK;
@@ -1922,38 +2070,38 @@ static enum bp_result set_crtc_timing_v1(
 }
 
 static enum bp_result set_crtc_using_dtd_timing_v3(
-		struct bios_parser *bp,
-		struct bp_hw_crtc_timing_parameters *bp_params)
+	struct bios_parser *bp,
+	struct bp_hw_crtc_timing_parameters *bp_params)
 {
 	enum bp_result result = BP_RESULT_FAILURE;
 	SET_CRTC_USING_DTD_TIMING_PARAMETERS params = {0};
 	uint8_t atom_controller_id;
 
 	if (bp->cmd_helper->controller_id_to_atom(
-		bp_params->controller_id, &atom_controller_id))
+			bp_params->controller_id, &atom_controller_id))
 		params.ucCRTC = atom_controller_id;
 
 	/* bios usH_Size wants h addressable size */
 	params.usH_Size = cpu_to_le16((uint16_t)bp_params->h_addressable);
 	/* bios usH_Blanking_Time wants borders included in blanking */
 	params.usH_Blanking_Time =
-		cpu_to_le16((uint16_t)(bp_params->h_total - bp_params->h_addressable));
+			cpu_to_le16((uint16_t)(bp_params->h_total - bp_params->h_addressable));
 	/* bios usV_Size wants v addressable size */
 	params.usV_Size = cpu_to_le16((uint16_t)bp_params->v_addressable);
 	/* bios usV_Blanking_Time wants borders included in blanking */
 	params.usV_Blanking_Time =
-		cpu_to_le16((uint16_t)(bp_params->v_total - bp_params->v_addressable));
+			cpu_to_le16((uint16_t)(bp_params->v_total - bp_params->v_addressable));
 	/* bios usHSyncOffset is the offset from the end of h addressable,
 	 * our horizontalSyncStart is the offset from the beginning
 	 * of h addressable */
 	params.usH_SyncOffset =
-		cpu_to_le16((uint16_t)(bp_params->h_sync_start - bp_params->h_addressable));
+			cpu_to_le16((uint16_t)(bp_params->h_sync_start - bp_params->h_addressable));
 	params.usH_SyncWidth = cpu_to_le16((uint16_t)bp_params->h_sync_width);
 	/* bios usHSyncOffset is the offset from the end of v addressable,
 	 * our verticalSyncStart is the offset from the beginning of
 	 * v addressable */
 	params.usV_SyncOffset =
-		cpu_to_le16((uint16_t)(bp_params->v_sync_start - bp_params->v_addressable));
+			cpu_to_le16((uint16_t)(bp_params->v_sync_start - bp_params->v_addressable));
 	params.usV_SyncWidth = cpu_to_le16((uint16_t)bp_params->v_sync_width);
 
 	/* we assume that overscan from original timing does not get bigger
@@ -1963,16 +2111,16 @@ static enum bp_result set_crtc_using_dtd_timing_v3(
 
 	if (0 == bp_params->flags.HSYNC_POSITIVE_POLARITY)
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_HSYNC_POLARITY);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_HSYNC_POLARITY);
 
 	if (0 == bp_params->flags.VSYNC_POSITIVE_POLARITY)
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_VSYNC_POLARITY);
 
 
 	if (bp_params->flags.INTERLACE)	{
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_INTERLACE);
 
 		/* original DAL code has this condition to apply this
 		 * for non-TV/CV only
@@ -1990,14 +2138,14 @@ static enum bp_result set_crtc_using_dtd_timing_v3(
 			 * or CEA timing table.
 			 */
 			params.usV_SyncOffset =
-				cpu_to_le16(le16_to_cpu(params.usV_SyncOffset) + 1);
+					cpu_to_le16(le16_to_cpu(params.usV_SyncOffset) + 1);
 
 		}
 	}
 
 	if (bp_params->flags.HORZ_COUNT_BY_TWO)
 		params.susModeMiscInfo.usAccess =
-			cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);
+				cpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);
 
 	if (EXEC_BIOS_CMD_TABLE(SetCRTC_UsingDTDTiming, params))
 		result = BP_RESULT_OK;
@@ -2006,12 +2154,12 @@ static enum bp_result set_crtc_using_dtd_timing_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  SET CRTC OVERSCAN
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  SET CRTC OVERSCAN
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result set_crtc_overscan_v1(
 	struct bios_parser *bp,
@@ -2038,7 +2186,7 @@ static enum bp_result set_crtc_overscan_v1(
 	uint8_t atom_controller_id;
 
 	if (bp->cmd_helper->controller_id_to_atom(
-		bp_params->controller_id, &atom_controller_id))
+			bp_params->controller_id, &atom_controller_id))
 		params.ucCRTC = atom_controller_id;
 	else
 		return BP_RESULT_BADINPUT;
@@ -2059,12 +2207,12 @@ static enum bp_result set_crtc_overscan_v1(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  SELECT CRTC SOURCE
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  SELECT CRTC SOURCE
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result select_crtc_source_v2(
 	struct bios_parser *bp,
@@ -2102,26 +2250,26 @@ static enum bp_result select_crtc_source_v2(
 
 	/* set controller id */
 	if (bp->cmd_helper->controller_id_to_atom(
-		bp_params->controller_id, &atom_controller_id))
+			bp_params->controller_id, &atom_controller_id))
 		params.ucCRTC = atom_controller_id;
 	else
 		return BP_RESULT_FAILURE;
 
 	/* set encoder id */
 	if (bp->cmd_helper->engine_bp_to_atom(
-		bp_params->engine_id, &atom_engine_id))
+			bp_params->engine_id, &atom_engine_id))
 		params.ucEncoderID = (uint8_t)atom_engine_id;
 	else
 		return BP_RESULT_FAILURE;
 
 	if (SIGNAL_TYPE_EDP == s ||
 			(SIGNAL_TYPE_DISPLAY_PORT == s &&
-				SIGNAL_TYPE_LVDS == bp_params->sink_signal))
+					SIGNAL_TYPE_LVDS == bp_params->sink_signal))
 		s = SIGNAL_TYPE_LVDS;
 
 	params.ucEncodeMode =
-		(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-			s, bp_params->enable_dp_audio);
+			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+					s, bp_params->enable_dp_audio);
 
 	if (EXEC_BIOS_CMD_TABLE(SelectCRTC_Source, params))
 		result = BP_RESULT_OK;
@@ -2155,12 +2303,12 @@ static enum bp_result select_crtc_source_v3(
 
 	if (SIGNAL_TYPE_EDP == s ||
 			(SIGNAL_TYPE_DISPLAY_PORT == s &&
-			SIGNAL_TYPE_LVDS == bp_params->sink_signal))
+					SIGNAL_TYPE_LVDS == bp_params->sink_signal))
 		s = SIGNAL_TYPE_LVDS;
 
 	params.ucEncodeMode =
-		bp->cmd_helper->encoder_mode_bp_to_atom(
-			s, bp_params->enable_dp_audio);
+			bp->cmd_helper->encoder_mode_bp_to_atom(
+					s, bp_params->enable_dp_audio);
 	/* Needed for VBIOS Random Spatial Dithering feature */
 	params.ucDstBpc = (uint8_t)(bp_params->display_output_bit_depth);
 
@@ -2171,12 +2319,12 @@ static enum bp_result select_crtc_source_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  ENABLE CRTC
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  ENABLE CRTC
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result enable_crtc_v1(
 	struct bios_parser *bp,
@@ -2221,12 +2369,12 @@ static enum bp_result enable_crtc_v1(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  ENABLE CRTC MEM REQ
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  ENABLE CRTC MEM REQ
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result enable_crtc_mem_req_v1(
 	struct bios_parser *bp,
@@ -2272,12 +2420,12 @@ static enum bp_result enable_crtc_mem_req_v1(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  DISPLAY PLL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  DISPLAY PLL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result program_clock_v5(
 	struct bios_parser *bp,
@@ -2312,7 +2460,7 @@ static enum bp_result program_clock_v5(
 
 	dc_service_memset(&params, 0, sizeof(params));
 	if (!bp->cmd_helper->clock_source_id_to_atom(
-		bp_params->pll_id, &atom_pll_id)) {
+			bp_params->pll_id, &atom_pll_id)) {
 		BREAK_TO_DEBUGGER(); /* Invalid Inpute!! */
 		return BP_RESULT_BADINPUT;
 	}
@@ -2320,7 +2468,7 @@ static enum bp_result program_clock_v5(
 	/* We need to convert from KHz units into 10KHz units */
 	params.sPCLKInput.ucPpll = (uint8_t) atom_pll_id;
 	params.sPCLKInput.usPixelClock =
-		cpu_to_le16((uint16_t) (bp_params->target_pixel_clock / 10));
+			cpu_to_le16((uint16_t) (bp_params->target_pixel_clock / 10));
 	params.sPCLKInput.ucCRTC = (uint8_t) ATOM_CRTC_INVALID;
 
 	if (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)
@@ -2344,7 +2492,7 @@ static enum bp_result program_clock_v6(
 	dc_service_memset(&params, 0, sizeof(params));
 
 	if (!bp->cmd_helper->clock_source_id_to_atom(
-		bp_params->pll_id, &atom_pll_id)) {
+			bp_params->pll_id, &atom_pll_id)) {
 		BREAK_TO_DEBUGGER(); /*Invalid Input!!*/
 		return BP_RESULT_BADINPUT;
 	}
@@ -2352,7 +2500,7 @@ static enum bp_result program_clock_v6(
 	/* We need to convert from KHz units into 10KHz units */
 	params.sPCLKInput.ucPpll = (uint8_t)atom_pll_id;
 	params.sPCLKInput.ulDispEngClkFreq =
-		cpu_to_le32(bp_params->target_pixel_clock / 10);
+			cpu_to_le32(bp_params->target_pixel_clock / 10);
 
 	if (bp_params->flags.SET_EXTERNAL_REF_DIV_SRC)
 		params.sPCLKInput.ucMiscInfo |= PIXEL_CLOCK_MISC_REF_DIV_SRC;
@@ -2361,7 +2509,7 @@ static enum bp_result program_clock_v6(
 		/* True display clock is returned by VBIOS if DFS bypass
 		 * is enabled. */
 		bp_params->dfs_bypass_display_clock =
-			(uint32_t)(le32_to_cpu(params.sPCLKInput.ulDispEngClkFreq) * 10);
+				(uint32_t)(le32_to_cpu(params.sPCLKInput.ulDispEngClkFreq) * 10);
 		result = BP_RESULT_OK;
 	}
 
@@ -2369,12 +2517,12 @@ static enum bp_result program_clock_v6(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                 COMPUTE MEMORY ENGINE PLL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                 COMPUTE MEMORY ENGINE PLL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result compute_memore_engine_pll_v4(
 	struct bios_parser *bp,
@@ -2385,7 +2533,7 @@ static void init_compute_memore_engine_pll(struct bios_parser *bp)
 	switch (BIOS_CMD_TABLE_PARA_REVISION(ComputeMemoryEnginePLL)) {
 	case 4:
 		bp->cmd_tbl.compute_memore_engine_pll =
-			compute_memore_engine_pll_v4;
+				compute_memore_engine_pll_v4;
 		break;
 	default:
 		bp->cmd_tbl.compute_memore_engine_pll = NULL;
@@ -2419,12 +2567,12 @@ static enum bp_result compute_memore_engine_pll_v4(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  EXTERNAL ENCODER CONTROL
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  EXTERNAL ENCODER CONTROL
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result external_encoder_control_v3(
 	struct bios_parser *bp,
@@ -2436,7 +2584,7 @@ static void init_external_encoder_control(
 	switch (BIOS_CMD_TABLE_PARA_REVISION(ExternalEncoderControl)) {
 	case 3:
 		bp->cmd_tbl.external_encoder_control =
-			external_encoder_control_v3;
+				external_encoder_control_v3;
 		break;
 	default:
 		bp->cmd_tbl.external_encoder_control = NULL;
@@ -2494,7 +2642,7 @@ static enum bp_result external_encoder_control_v3(
 		/* output display connector type. Only valid in encoder
 		 * initialization */
 		cntl_params->usConnectorId =
-			cpu_to_le16((uint16_t)cntl->connector_obj_id.id);
+				cpu_to_le16((uint16_t)cntl->connector_obj_id.id);
 		break;
 	case EXTERNAL_ENCODER_CONTROL_SETUP:
 		/* EXTERNAL_ENCODER_CONTROL_PARAMETERS_V3 pixel clock unit in
@@ -2503,12 +2651,12 @@ static enum bp_result external_encoder_control_v3(
 		 * Only valid in setup and enableoutput
 		 */
 		cntl_params->usPixelClock =
-			cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
+				cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 		/* Indicate display output signal type drive by external
 		 * encoder, only valid in setup and enableoutput */
 		cntl_params->ucEncoderMode =
-			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-				cntl->signal, false);
+				(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+						cntl->signal, false);
 
 		if (is_input_signal_dp) {
 			/* Bit[0]: indicate link rate, =1: 2.7Ghz, =0: 1.62Ghz,
@@ -2519,7 +2667,7 @@ static enum bp_result external_encoder_control_v3(
 			 * in DP mode, only valid in encoder setup in DP mode.
 			 */
 			cntl_params->ucBitPerColor =
-				(uint8_t)(cntl->color_depth);
+					(uint8_t)(cntl->color_depth);
 		}
 		/* Indicate how many lanes used by external encoder, only valid
 		 * in encoder setup and enableoutput. */
@@ -2527,10 +2675,10 @@ static enum bp_result external_encoder_control_v3(
 		break;
 	case EXTERNAL_ENCODER_CONTROL_ENABLE:
 		cntl_params->usPixelClock =
-			cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
+				cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
 		cntl_params->ucEncoderMode =
-			(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
-				cntl->signal, false);
+				(uint8_t)bp->cmd_helper->encoder_mode_bp_to_atom(
+						cntl->signal, false);
 		cntl_params->ucLaneNum = (uint8_t)cntl->lanes_number;
 		break;
 	default:
@@ -2549,10 +2697,10 @@ static enum bp_result external_encoder_control_v3(
 			 * ExternalEncoderControl runs detection and save result
 			 * in BIOS scratch registers. */
 			cntl->signal = bp->bios_helper->detect_sink(
-				bp->ctx,
-				encoder,
-				cntl->connector_obj_id,
-				cntl->signal);
+					bp->ctx,
+					encoder,
+					cntl->connector_obj_id,
+					cntl->signal);
 		else/* BIOS table does not work. */
 #endif
 		{
@@ -2565,12 +2713,12 @@ static enum bp_result external_encoder_control_v3(
 }
 
 /*******************************************************************************
-********************************************************************************
-**
-**                  ENABLE DISPLAY POWER GATING
-**
-********************************************************************************
-*******************************************************************************/
+ ********************************************************************************
+ **
+ **                  ENABLE DISPLAY POWER GATING
+ **
+ ********************************************************************************
+ *******************************************************************************/
 
 static enum bp_result enable_disp_power_gating_v2_1(
 	struct bios_parser *bp,
@@ -2583,7 +2731,7 @@ static void init_enable_disp_power_gating(
 	switch (BIOS_CMD_TABLE_PARA_REVISION(EnableDispPowerGating)) {
 	case 1:
 		bp->cmd_tbl.enable_disp_power_gating =
-			enable_disp_power_gating_v2_1;
+				enable_disp_power_gating_v2_1;
 		break;
 	default:
 		bp->cmd_tbl.enable_disp_power_gating = NULL;
@@ -2607,10 +2755,88 @@ static enum bp_result enable_disp_power_gating_v2_1(
 		return BP_RESULT_BADINPUT;
 
 	params.ucEnable =
-		bp->cmd_helper->disp_power_gating_action_to_atom(action);
+			bp->cmd_helper->disp_power_gating_action_to_atom(action);
 
 	if (EXEC_BIOS_CMD_TABLE(EnableDispPowerGating, params))
 		result = BP_RESULT_OK;
 
 	return result;
 }
+
+
+/*******************************************************************************
+ ********************************************************************************
+ **
+ **                  SET DCE CLOCK
+ **
+ ********************************************************************************
+ *******************************************************************************/
+#ifdef LATEST_ATOM_BIOS_SUPPORT
+enum bp_result set_dce_clock_v2_1(
+	struct bios_parser *bp,
+	struct bp_set_dce_clock_parameters *bp_params);
+#endif
+
+static void init_set_dce_clock(struct bios_parser *bp)
+{
+#ifdef LATEST_ATOM_BIOS_SUPPORT
+	switch (BIOS_CMD_TABLE_PARA_REVISION(SetDCEClock)) {
+	case 1:
+		bp->cmd_tbl.set_dce_clock = set_dce_clock_v2_1;
+		break;
+	default:
+		bp->cmd_tbl.set_dce_clock = NULL;
+		break;
+	}
+#endif
+}
+
+#ifdef LATEST_ATOM_BIOS_SUPPORT
+static enum bp_result set_dce_clock_v2_1(
+	struct bios_parser *bp,
+	struct bp_set_dce_clock_parameters *bp_params)
+{
+	enum bp_result result = BP_RESULT_FAILURE;
+
+	SET_DCE_CLOCK_PS_ALLOCATION_V2_1 params;
+	uint32_t atom_pll_id;
+	uint32_t atom_clock_type;
+
+	dc_service_memset(&params, 0, sizeof(params));
+
+	const struct command_table_helper *cmd = bp->cmd_helper;
+
+	if (!cmd->clock_source_id_to_atom(bp_params->pll_id, &atom_pll_id) ||
+			!cmd->dc_clock_type_to_atom(bp_params->clock_type, &atom_clock_type))
+		return BP_RESULT_BADINPUT;
+
+	params.asParam.ucDCEClkSrc  = atom_pll_id;
+	params.asParam.ucDCEClkType = atom_clock_type;
+
+	if (bp_params->clock_type == DCECLOCK_TYPE_DPREFCLK) {
+		if (bp_params->flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK)
+			params.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_GENLK;
+
+		if (bp_params->flags.USE_PCIE_AS_SOURCE_FOR_DPREFCLK)
+			params.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_PCIE;
+
+		if (bp_params->flags.USE_XTALIN_AS_SOURCE_FOR_DPREFCLK)
+			params.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_XTALIN;
+
+		if (bp_params->flags.USE_GENERICA_AS_SOURCE_FOR_DPREFCLK)
+			params.asParam.ucDCEClkFlag |= DCE_CLOCK_FLAG_PLL_REFCLK_SRC_GENERICA;
+	}
+	else
+		/* only program clock frequency if display clock is used; VBIOS will program DPREFCLK */
+		/* We need to convert from KHz units into 10KHz units */
+		params.asParam.ulDCEClkFreq = cpu_to_le32(bp_params->target_clock_frequency / 10);
+
+	if (EXEC_BIOS_CMD_TABLE(SetDCEClock, params)) {
+		/* Convert from 10KHz units back to KHz */
+		bp_params->target_clock_frequency = le32_to_cpu(params.asParam.ulDCEClkFreq) * 10;
+		result = BP_RESULT_OK;
+	}
+
+	return result;
+}
+#endif
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table.h b/drivers/gpu/drm/amd/dal/dc/bios/command_table.h
index 814d31f..e233ea6 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table.h
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table.h
@@ -110,6 +110,9 @@ struct cmd_tbl {
 		struct bios_parser *bp,
 		enum controller_id crtc_id,
 		enum bp_pipe_control_action action);
+	enum bp_result (*set_dce_clock)(
+		struct bios_parser *bp,
+		struct bp_set_dce_clock_parameters *bp_params);
 };
 
 void dal_bios_parser_init_cmd_tbl(struct bios_parser *bp);
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c b/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c
index dad1426..51027c5 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.c
@@ -42,8 +42,8 @@ bool dal_bios_parser_init_cmd_tbl_helper(
 	case DCE_VERSION_11_0:
 		*h = dal_cmd_tbl_helper_dce110_get_table();
 		return true;
-
 #endif
+
 	default:
 		/* Unsupported DCE */
 		BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.h b/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.h
index e5c00de..cf563ce 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.h
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table_helper.h
@@ -57,6 +57,9 @@ struct command_table_helper {
 	uint8_t (*phy_id_to_atom)(enum transmitter t);
 	uint8_t (*disp_power_gating_action_to_atom)(
 			enum bp_pipe_control_action action);
+	bool (*dc_clock_type_to_atom)(enum bp_dce_clock_type id,
+			uint32_t *atom_clock_type);
+    uint8_t (*transmitter_color_depth_to_atom)(enum transmitter_color_depth id);
 };
 
 bool dal_bios_parser_init_cmd_tbl_helper(const struct command_table_helper **h,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 45a069a..6121277 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -684,6 +684,8 @@ enum dc_status dce110_validate_with_context(
 	context->res_ctx.pool = dc->res_pool;
 
 	result = dce_base_map_resources(dc, context);
+
+	if (result == DC_OK)
 	result = map_clock_resources(dc, context);
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c
index 8e700ea..11f16b7 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.c
@@ -75,6 +75,7 @@ struct clock_source *dal_clock_source_create(
 	}
 	break;
 #endif
+
 	default:
 		dal_logger_write(clk_src_init_data->ctx->logger,
 			LOG_MAJOR_ERROR,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h
index 0a83874..0210f03 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/clock_source.h
@@ -88,6 +88,10 @@ struct registers {
 	uint32_t dp_dtox_phase;
 	uint32_t dp_dtox_modulo;
 	uint32_t crtcx_pixel_rate_cntl;
+	uint32_t combophyx_pll_wrap_cntl;
+	uint32_t combophyx_freq_cntl0;
+	uint32_t combophyx_freq_cntl2;
+	uint32_t combophyx_freq_cntl3;
 };
 
 struct clock_source {
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
index 71d1a6c..3de8951 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
@@ -125,12 +125,14 @@ static const enum gpio_ddc_line hw_ddc_lines[] = {
 	GPIO_DDC_LINE_DDC1,
 	GPIO_DDC_LINE_DDC2,
 	GPIO_DDC_LINE_DDC3,
+	GPIO_DDC_LINE_DDC4,
 };
 
 static const enum gpio_ddc_line hw_aux_lines[] = {
 	GPIO_DDC_LINE_DDC1,
 	GPIO_DDC_LINE_DDC2,
 	GPIO_DDC_LINE_DDC3,
+	GPIO_DDC_LINE_DDC4,
 };
 
 /* function table */
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index a728446..6ef41b1 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -40,7 +40,7 @@ struct core_stream;
 
 #define MAX_PIPES 6
 #define MAX_STREAMS 6
-#define MAX_CLOCK_SOURCES 4
+#define MAX_CLOCK_SOURCES 7
 
 struct core_target {
 	struct dc_target public;
diff --git a/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h b/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h
index 6269164..13fa8ab 100644
--- a/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/bios_parser_interface.h
@@ -243,6 +243,9 @@ enum bp_result dal_bios_parser_adjust_pixel_clock(
 enum bp_result dal_bios_parser_set_pixel_clock(
 	struct bios_parser *bp,
 	struct bp_pixel_clock_parameters *bp_params);
+enum bp_result dal_bios_parser_set_dce_clock(
+	struct bios_parser *bp,
+	struct bp_set_dce_clock_parameters *bp_params);
 enum bp_result dal_bios_parser_enable_spread_spectrum_on_ppll(
 	struct bios_parser *bp,
 	struct bp_spread_spectrum_parameters *bp_params,
diff --git a/drivers/gpu/drm/amd/dal/include/bios_parser_types.h b/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
index da7d5f2..4176f28 100644
--- a/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
+++ b/drivers/gpu/drm/amd/dal/include/bios_parser_types.h
@@ -248,6 +248,9 @@ struct bp_pixel_clock_parameters {
 	/* VBIOS returns a fixed display clock when DFS-bypass feature
 	 * is enabled (KHz) */
 	uint32_t dfs_bypass_display_clock;
+	/* color depth to support HDMI deep color */
+	enum transmitter_color_depth color_depth;
+
 	struct program_pixel_clock_flags {
 		uint32_t FORCE_PROGRAMMING_OF_PLL:1;
 		/* Use Engine Clock as source for Display Clock when
@@ -255,6 +258,14 @@ struct bp_pixel_clock_parameters {
 		uint32_t USE_E_CLOCK_AS_SOURCE_FOR_D_CLOCK:1;
 		/* Use external reference clock (refDivSrc for PLL) */
 		uint32_t SET_EXTERNAL_REF_DIV_SRC:1;
+		/* Force program PHY PLL only */
+		uint32_t PROGRAM_PHY_PLL_ONLY:1;
+		/* Support for YUV420 */
+		uint32_t SUPPORT_YUV_420:1;
+		/* Use XTALIN reference clock source */
+		uint32_t SET_XTALIN_REF_SRC:1;
+		/* Use GENLK reference clock source */
+		uint32_t SET_GENLOCK_REF_DIV_SRC:1;
 	} flags;
 };
 
@@ -266,6 +277,30 @@ struct bp_display_clock_parameters {
 	uint32_t actual_post_divider_id;
 };
 
+enum bp_dce_clock_type {
+	DCECLOCK_TYPE_DISPLAY_CLOCK = 0,
+	DCECLOCK_TYPE_DPREFCLK      = 1
+};
+
+/* DCE Clock Parameters structure for SetDceClock Exec command table */
+struct bp_set_dce_clock_parameters {
+	enum clock_source_id pll_id; /* Clock Source Id */
+	/* Display clock or DPREFCLK value */
+	uint32_t target_clock_frequency;
+	/* Clock to set: =0: DISPCLK  =1: DPREFCLK  =2: PIXCLK */
+	enum bp_dce_clock_type clock_type;
+
+	struct set_dce_clock_flags {
+		uint32_t USE_GENERICA_AS_SOURCE_FOR_DPREFCLK:1;
+		/* Use XTALIN reference clock source */
+		uint32_t USE_XTALIN_AS_SOURCE_FOR_DPREFCLK:1;
+		/* Use PCIE reference clock source */
+		uint32_t USE_PCIE_AS_SOURCE_FOR_DPREFCLK:1;
+		/* Use GENLK reference clock source */
+		uint32_t USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK:1;
+	} flags;
+};
+
 struct spread_spectrum_flags {
 	/* 1 = Center Spread; 0 = down spread */
 	uint32_t CENTER_SPREAD:1;
diff --git a/drivers/gpu/drm/amd/dal/include/grph_object_id.h b/drivers/gpu/drm/amd/dal/include/grph_object_id.h
index fcf3eea..5d69a34 100644
--- a/drivers/gpu/drm/amd/dal/include/grph_object_id.h
+++ b/drivers/gpu/drm/amd/dal/include/grph_object_id.h
@@ -99,9 +99,16 @@ enum clock_source_id {
 	CLOCK_SOURCE_ID_DCPLL,
 	CLOCK_SOURCE_ID_DFS,	/* DENTIST */
 	CLOCK_SOURCE_ID_VCE,	/* VCE does not need a real PLL */
-	CLOCK_SOURCE_ID_DP_DTO,	/* Used to distinguish between */
-	/* programming pixel clock */
-	/* and ID (Phy) clock */
+	/* Used to distinguish between programming pixel clock and ID (Phy) clock */
+	CLOCK_SOURCE_ID_DP_DTO,
+
+	CLOCK_SOURCE_COMBO_PHY_PLL0, /*combo PHY PLL defines (DC 11.2 and up)*/
+	CLOCK_SOURCE_COMBO_PHY_PLL1,
+	CLOCK_SOURCE_COMBO_PHY_PLL2,
+	CLOCK_SOURCE_COMBO_PHY_PLL3,
+	CLOCK_SOURCE_COMBO_PHY_PLL4,
+	CLOCK_SOURCE_COMBO_PHY_PLL5,
+	CLOCK_SOURCE_COMBO_DISPLAY_PLL0
 };
 
 
@@ -224,6 +231,12 @@ union supported_stream_engines {
 	uint32_t u_all;
 };
 
+enum transmitter_color_depth {
+	TRANSMITTER_COLOR_DEPTH_24 = 0,  /* 8  bits */
+	TRANSMITTER_COLOR_DEPTH_30,      /* 10 bits */
+	TRANSMITTER_COLOR_DEPTH_36,      /* 12 bits */
+	TRANSMITTER_COLOR_DEPTH_48       /* 16 bits */
+};
 
 /*
  *****************************************************************************
-- 
2.7.4

