From 3a298bd13630e2cd990e2f06de80ad467f222881 Mon Sep 17 00:00:00 2001
From: Sanjay R Mehta <sanju.mehta@amd.com>
Date: Mon, 25 Apr 2016 00:53:44 +0530
Subject: [PATCH 08/12] ACP code as per 4-1-0 kernel

---
 drivers/gpu/drm/amd/acp/Kconfig              |    3 +-
 drivers/gpu/drm/amd/acp/Makefile             |    1 +
 drivers/gpu/drm/amd/acp/acp_hw.c             | 1050 +++++++++++++++++++++++++-
 drivers/gpu/drm/amd/acp/acp_hw.h             |  111 +++
 drivers/gpu/drm/amd/acp/include/acp_gfx_if.h |   17 +-
 drivers/gpu/drm/amd/acp/include/amd_acp.h    |  214 ++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c      |  383 ++--------
 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h      |    6 +-
 8 files changed, 1433 insertions(+), 352 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/acp/acp_hw.h
 create mode 100644 drivers/gpu/drm/amd/acp/include/amd_acp.h

diff --git a/drivers/gpu/drm/amd/acp/Kconfig b/drivers/gpu/drm/amd/acp/Kconfig
index 0f734ee..11c5faf 100644
--- a/drivers/gpu/drm/amd/acp/Kconfig
+++ b/drivers/gpu/drm/amd/acp/Kconfig
@@ -2,8 +2,7 @@ menu "ACP Configuration"
 
 config DRM_AMD_ACP
        bool "Enable ACP IP support"
-       select MFD_CORE
-       select PM_GENERIC_DOMAINS if PM
+       default y
        help
 	Choose this option to enable ACP IP support for AMD SOCs.
 
diff --git a/drivers/gpu/drm/amd/acp/Makefile b/drivers/gpu/drm/amd/acp/Makefile
index 8363cb5..c8c3303 100644
--- a/drivers/gpu/drm/amd/acp/Makefile
+++ b/drivers/gpu/drm/amd/acp/Makefile
@@ -3,6 +3,7 @@
 # of AMDSOC/AMDGPU drm driver.
 # It provides the HW control for ACP related functionalities.
 
+ccflags-y += -Idrivers/gpu/drm/amd/include/asic_reg/acp
 subdir-ccflags-y += -I$(AMDACPPATH)/ -I$(AMDACPPATH)/include
 
 AMD_ACP_FILES := $(AMDACPPATH)/acp_hw.o
diff --git a/drivers/gpu/drm/amd/acp/acp_hw.c b/drivers/gpu/drm/amd/acp/acp_hw.c
index 7af83f1..c9fcf3e 100644
--- a/drivers/gpu/drm/amd/acp/acp_hw.c
+++ b/drivers/gpu/drm/amd/acp/acp_hw.c
@@ -19,6 +19,7 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  *
+ *
  */
 
 #include <linux/mm.h>
@@ -27,15 +28,1006 @@
 #include <linux/delay.h>
 #include <linux/errno.h>
 
+#define VISLANDS30_IV_SRCID_ACP 0x000000a2
+
 #include "acp_gfx_if.h"
+#include "acp_hw.h"
+
+#include "acp_2_2_d.h"
+#include "acp_2_2_sh_mask.h"
+
+/* Configure a given dma channel parameters - enable/disble,
+ * number of descriptors, priority */
+
+static void config_acp_dma_channel(struct amd_acp_device *acp_dev, u8 ch_num,
+				   u16 dscr_strt_idx, u16 num_dscrs,
+				   enum acp_dma_priority_level priority_level)
+{
+	u32 dma_ctrl;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	/* read the dma control register and disable the channel run field */
+	dma_ctrl = cgs_read_register(acp_prv->cgs_device,
+				     mmACP_DMA_CNTL_0 + ch_num);
+	/* clear the dma channel control bits */
+	dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;
+
+	cgs_write_register(acp_prv->cgs_device, (mmACP_DMA_CNTL_0 + ch_num),
+			   dma_ctrl);
+
+	/* there is no transfer happening on this channel so
+	 * program DMAChDscrStrIdx to the index number of the first descriptor
+	 * to be processed.
+	 */
+	cgs_write_register(acp_prv->cgs_device,
+			   (mmACP_DMA_DSCR_STRT_IDX_0 + ch_num),
+			   (ACP_DMA_DSCR_STRT_IDX_0__DMAChDscrStrtIdx_MASK &
+			    dscr_strt_idx));
+
+	/* program DMAChDscrDscrCnt to the number of descriptors to be
+	 * processed in the transfer
+	 */
+	cgs_write_register(acp_prv->cgs_device,
+			   (mmACP_DMA_DSCR_CNT_0 + ch_num),
+			   (ACP_DMA_DSCR_CNT_0__DMAChDscrCnt_MASK & num_dscrs));
+
+	/* set DMAChPrioLvl according to the priority */
+	cgs_write_register(acp_prv->cgs_device,	(mmACP_DMA_PRIO_0 + ch_num),
+			   priority_level);
+}
+
+
+
+/* Initialize the dma descriptors location in SRAM and page size */
+static void acp_dma_descr_init(struct amd_acp_private *acp_prv)
+{
+	u32 sram_pte_offset = 0;
+
+	/* SRAM starts at 0x04000000. From that offset one page (4KB) left for
+	 * filling DMA descriptors.sram_pte_offset = 0x04001000 , used for
+	 * filling system RAM's physical pages.
+	 * This becomes the ALSA's Ring buffer start address
+	 */
+	sram_pte_offset = ACP_DAGB_GRP_SRAM_BASE_ADDRESS;
+
+	/* snoopable */
+	sram_pte_offset |= ACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBSnoopSel_MASK;
+	/* Memmory is system mmemory */
+	sram_pte_offset |= ACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBTargetMemSel_MASK;
+	/* Page Enabled */
+	sram_pte_offset |= ACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBGrpEnable_MASK;
+
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DAGB_BASE_ADDR_GRP_1,
+			   sram_pte_offset);
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DAGB_PAGE_SIZE_GRP_1,
+			   PAGE_SIZE_4K_ENABLE);
+}
+
+/* Initialize a dma descriptor in SRAM based on descritor information passed */
+static void config_dma_descriptor_in_sram(struct amd_acp_device *acp_dev,
+					  u16 descr_idx,
+					  acp_dma_dscr_transfer_t *descr_info)
+{
+	u32 sram_offset;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	sram_offset = (descr_idx * sizeof(acp_dma_dscr_transfer_t));
+
+	/* program the source base address. */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Addr,
+			   sram_offset);
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Data,
+			   descr_info->src);
+	/* program the destination base address. */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Addr,
+			   (sram_offset + 4));
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Data,
+						descr_info->dest);
+
+	/* program the number of bytes to be transferred for this descriptor. */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Addr,
+			   (sram_offset + 8));
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Data,
+			   descr_info->size_xfer_dir.val);
+}
+
+/* Initialize the DMA descriptor information */
+static void set_acp_sysmem_dma_descriptors(struct amd_acp_device *acp_dev,
+					   u32 size, int direction,
+					   u32 pte_offset)
+{
+	u16 dma_dscr_idx=0;
+	u16 num_descr;
+	acp_dma_dscr_transfer_t dmadscr[2];
+
+	num_descr = 2;
+
+	dmadscr[0].size_xfer_dir.val = (u32) 0x0;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12;
+		dmadscr[0].dest = ACP_SHARED_RAM_BANK_38_ADDRESS + (size / 2);
+		dmadscr[0].src = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS +
+			(pte_offset * PAGE_SIZE_4K);
+		dmadscr[0].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM;
+		dmadscr[0].size_xfer_dir.s.size = (size / 2);
+		dmadscr[0].size_xfer_dir.s.ioc = (u32) 0x0;
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH14;
+		dmadscr[0].src = ACP_SHARED_RAM_BANK_47_ADDRESS;
+		dmadscr[0].dest = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS +
+			(pte_offset * PAGE_SIZE_4K);
+		dmadscr[0].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION;
+		dmadscr[0].size_xfer_dir.s.size = size / 2;
+		dmadscr[0].size_xfer_dir.s.ioc = (u32) 0x1;
+	}
+
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[0]);
+
+	dmadscr[1].size_xfer_dir.val = (u32) 0x0;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_END_DMA_DESCR_CH12;
+		dmadscr[1].dest = ACP_SHARED_RAM_BANK_38_ADDRESS;
+		dmadscr[1].src = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS +
+			(pte_offset * PAGE_SIZE_4K) + (size / 2);
+		dmadscr[1].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM;
+		dmadscr[1].size_xfer_dir.s.size = (size / 2);
+		dmadscr[1].size_xfer_dir.s.ioc = (u32) 0x0;
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_END_DMA_DESCR_CH14;
+		dmadscr[1].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION;
+		dmadscr[1].size_xfer_dir.val = (u32) 0x0;
+		dmadscr[1].dest = dmadscr[0].dest + (size / 2);
+		dmadscr[1].src = dmadscr[0].src + (size / 2);
+		dmadscr[1].size_xfer_dir.s.size = (size / 2);
+		dmadscr[1].size_xfer_dir.s.ioc = (u32) 0x1;
+	}
+
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[1]);
+
+	if (direction == STREAM_PLAYBACK) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12;
+		config_acp_dma_channel(acp_dev, SYSRAM_TO_ACP_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	} else if (direction == STREAM_CAPTURE) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH14;
+		config_acp_dma_channel(acp_dev, ACP_TO_SYSRAM_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	}
+}
+
+/* Initialize the i2s dma descriptors in SRAM */
+static void set_acp_to_i2s_dma_descriptors(struct amd_acp_device *acp_dev,
+					   u32 size, int direction)
+{
+
+	u16 num_descr;
+	u16 dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;
+	acp_dma_dscr_transfer_t dmadscr[2];
+
+	num_descr = 2;
+
+	/* Let I2s Know the direction of transfer and source/destination
+	 *  of data
+	 */
+	dmadscr[0].size_xfer_dir.val = (u32) 0x0;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;
+		dmadscr[0].src = ACP_SHARED_RAM_BANK_38_ADDRESS;
+		dmadscr[0].size_xfer_dir.s.trans_direction = TO_ACP_I2S_1;
+		dmadscr[0].size_xfer_dir.s.size = (size / 2);
+		dmadscr[0].size_xfer_dir.s.ioc = (u32) 0x1;
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH15;
+		dmadscr[0].dest = ACP_SHARED_RAM_BANK_47_ADDRESS;
+		dmadscr[0].size_xfer_dir.s.trans_direction = FROM_ACP_I2S_1;
+		dmadscr[0].size_xfer_dir.s.size = (size / 2);
+		dmadscr[0].size_xfer_dir.s.ioc = (u32) 0x1;
+	}
+
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[0]);
+
+	dmadscr[1].size_xfer_dir.val = (u32) 0x0;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_END_DMA_DESCR_CH13;
+		dmadscr[1].src = dmadscr[0].src + (size / 2);
+		dmadscr[1].size_xfer_dir.s.trans_direction = TO_ACP_I2S_1;
+		dmadscr[1].size_xfer_dir.s.size = (size / 2);
+		dmadscr[1].size_xfer_dir.s.ioc = (u32) 0x1;
+
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_END_DMA_DESCR_CH15;
+		dmadscr[1].dest = dmadscr[0].dest + (size / 2);
+		dmadscr[1].size_xfer_dir.s.trans_direction = FROM_ACP_I2S_1;
+		dmadscr[1].size_xfer_dir.s.size = (size / 2);
+		dmadscr[1].size_xfer_dir.s.ioc = (u32) 0x1;
+	}
+
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[1]);
+
+	/* Configure the DMA channel with the above descriptore */
+	if (direction == STREAM_PLAYBACK) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;
+		config_acp_dma_channel(acp_dev, ACP_TO_I2S_DMA_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	} else if (direction == STREAM_CAPTURE) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH15;
+		config_acp_dma_channel(acp_dev, I2S_TO_ACP_DMA_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	}
+
+}
+
+static u16 get_dscr_idx(struct amd_acp_device *acp_dev, int direction)
+{
+	u16 dscr_idx;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK) {
+		dscr_idx = cgs_read_register(acp_prv->cgs_device,
+							mmACP_DMA_CUR_DSCR_13);
+		dscr_idx = (dscr_idx == PLAYBACK_START_DMA_DESCR_CH13) ?
+				PLAYBACK_START_DMA_DESCR_CH12 :
+				PLAYBACK_END_DMA_DESCR_CH12;
+	} else {
+		dscr_idx = cgs_read_register(acp_prv->cgs_device,
+							mmACP_DMA_CUR_DSCR_15);
+		dscr_idx = (dscr_idx == CAPTURE_START_DMA_DESCR_CH15) ?
+				CAPTURE_END_DMA_DESCR_CH14 :
+				CAPTURE_START_DMA_DESCR_CH14;
+	}
+
+	return dscr_idx;
+
+}
+
+/*	Create page table entries in ACP SRAM for the allocated memory */
+static void acp_pte_config(struct amd_acp_device *acp_dev, struct page *pg,
+			   u16 num_of_pages, u32 pte_offset)
+{
+	u16 page_idx;
+	u64 addr;
+	u32 low;
+	u32 high;
+	u32 offset;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	offset	= ACP_DAGB_GRP_SRBM_SRAM_BASE_OFFSET + (pte_offset * 8);
+	for (page_idx = 0; page_idx < (num_of_pages); page_idx++) {
+		/* Load the low address of page int ACP SRAM through SRBM */
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Addr,
+				   (offset + (page_idx * 8)));
+		addr = page_to_phys(pg);
+
+		low = lower_32_bits(addr);
+		high = upper_32_bits(addr);
+
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Data, low);
+
+		/* Load the High address of page int ACP SRAM through SRBM */
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Addr,
+				   (offset + (page_idx * 8) + 4));
+
+		/* page enable in ACP */
+		high |= BIT(31);
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Data, high);
+
+		/* Move to next physically contiguos page */
+		pg++;
+	}
+}
+
+
+/* enables/disables ACP's external interrupt */
+static void acp_enable_external_interrupts(struct amd_acp_device *acp_dev,
+					   int enable)
+{
+	u32 acp_ext_intr_enb;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	acp_ext_intr_enb = enable ?
+		ACP_EXTERNAL_INTR_ENB__ACPExtIntrEnb_MASK :
+		0;
+
+	/* Write the Software External Interrupt Enable register */
+	cgs_write_register(acp_prv->cgs_device,
+			   mmACP_EXTERNAL_INTR_ENB, acp_ext_intr_enb);
+}
+
+/*	Clear (acknowledge) DMA 'Interrupt on Complete' (IOC) in ACP
+ *	external interrupt status register
+ */
+static void acp_ext_stat_clear_dmaioc(struct amd_acp_device *acp_dev, u8 ch_num)
+{
+	u32 ext_intr_stat;
+	u32 chmask = BIT(ch_num);
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	ext_intr_stat = cgs_read_register(acp_prv->cgs_device,
+					  mmACP_EXTERNAL_INTR_STAT);
+	if (ext_intr_stat & (chmask <<
+			     ACP_EXTERNAL_INTR_STAT__DMAIOCStat__SHIFT)) {
+
+		ext_intr_stat &= (chmask <<
+				  ACP_EXTERNAL_INTR_STAT__DMAIOCAck__SHIFT);
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_EXTERNAL_INTR_STAT, ext_intr_stat);
+	}
+}
+
+/*	Check whether interrupt (IOC) is generated or not	*/
+static u16 acp_get_intr_flag(struct amd_acp_device *acp_dev)
+{
+	u32 ext_intr_status;
+	u32 intr_gen;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	ext_intr_status = cgs_read_register(acp_prv->cgs_device,
+					    mmACP_EXTERNAL_INTR_STAT);
+	intr_gen = (((ext_intr_status &
+		      ACP_EXTERNAL_INTR_STAT__DMAIOCStat_MASK) >>
+		     ACP_EXTERNAL_INTR_STAT__DMAIOCStat__SHIFT));
+
+	return intr_gen;
+}
+
+static int irq_set_source(void *private_data, unsigned src_id, unsigned type,
+								int enabled)
+{
+	struct amd_acp_device *acp_dev =
+		((struct acp_irq_prv *)private_data)->acp_dev;
+
+	if (src_id == VISLANDS30_IV_SRCID_ACP) {
+		acp_enable_external_interrupts(acp_dev, enabled);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+
+static inline void i2s_clear_irqs(struct amd_acp_device *acp_dev,
+				  int direction)
+{
+	u32 i = 0;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SSP_TOR0 + (0x10 * i)), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SMICSP_ROR0 +(0x10 * i)), 0);
+	}
+}
+
+static void i2s_disable_channels(struct amd_acp_device *acp_dev,
+					u32 stream)
+{
+	u32 i = 0;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (stream == STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SSP_TER0 + (0x10 * i)), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SMICSP_RER0 + (0x10 * i)), 0);
+	}
+}
+
+static void configure_i2s_stream(struct amd_acp_device *acp_dev,
+					struct acp_i2s_config *i2s_config)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (i2s_config->direction == STREAM_PLAYBACK) {
+		/* Transmit configuration register for data width */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_TCR0 + (0x10 *
+							i2s_config->ch_reg)),
+				   i2s_config->xfer_resolution);
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_TFCR0 + (0x10 *
+							 i2s_config->ch_reg)),
+				   0x02);
+
+		/* Read interrupt mask register */
+		i2s_config->irq =
+			cgs_read_register(acp_prv->cgs_device,
+					  (mmACP_I2SSP_IMR0 +
+					   (0x10 * i2s_config->ch_reg)));
+		/* TX FIFO Overrun,Empty interrupts */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_IMR0 + (0x10 *
+							i2s_config->ch_reg)),
+				   (i2s_config->irq & ~0x30));
+		/*Enable Transmit */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_TER0 + (0x10 *
+						i2s_config->ch_reg)), 1);
+	} else {
+		/* Receive configuration register for data width */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_RCR0 + (0x10 *
+							   i2s_config->ch_reg)),
+				   i2s_config->xfer_resolution);
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_RFCR0 + (0x10 *
+						    i2s_config->ch_reg)), 0x07);
+		/*Read interrupt mask register */
+		i2s_config->irq = cgs_read_register(acp_prv->cgs_device,
+						    (mmACP_I2SMICSP_IMR0 +
+					     (0x10 * i2s_config->ch_reg)));
+
+		/* TX FIFO Overrun,Empty interrupts */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_IMR0 + (0x10 *
+							   i2s_config->ch_reg)),
+				   i2s_config->irq & ~0x03);
+		/*Enable Receive */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_RER0 + (0x10 *
+						   i2s_config->ch_reg)), 1);
+	}
+}
+
+static void config_acp_dma(struct amd_acp_device *acp_dev,
+			   struct acp_dma_config *dma_config)
+{
+	u32 pte_offset;
+
+	if (dma_config->direction == STREAM_PLAYBACK)
+		pte_offset = PLAYBACK_PTE_OFFSET;
+	else
+		pte_offset = CAPTURE_PTE_OFFSET;
+
+	acp_pte_config(acp_dev, dma_config->pg,	dma_config->num_of_pages,
+		       pte_offset);
+
+	/* Configure System memory to acp dma descriptors */
+	set_acp_sysmem_dma_descriptors(acp_dev, dma_config->size,
+				       dma_config->direction,
+				       pte_offset);
+
+	/* Configure acp to i2s dma descriptors */
+	set_acp_to_i2s_dma_descriptors(acp_dev, dma_config->size,
+				       dma_config->direction);
+}
+
+/* Start a given dma channel */
+static int acp_dma_start(struct amd_acp_device *acp_dev,
+			 u16 ch_num, bool is_circular)
+{
+	int status;
+	u32 dma_ctrl;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	status = STATUS_UNSUCCESSFUL;
+
+	/* read the dma control register and disable the channel run field */
+	dma_ctrl = cgs_read_register(acp_prv->cgs_device,
+				     mmACP_DMA_CNTL_0 + ch_num);
+
+	/*Invalidating the DAGB cache */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DAGB_ATU_CTRL, ENABLE);
+
+	/* configure the DMA channel and start the DMA transfer
+	 * set dmachrun bit to start the transfer and enable the
+	 * interrupt on completion of the dma transfer
+	 */
+	dma_ctrl |= ACP_DMA_CNTL_0__DMAChRun_MASK;
+
+	if ((ch_num == ACP_TO_I2S_DMA_CH_NUM) ||
+	    (ch_num == ACP_TO_SYSRAM_CH_NUM) ||
+	    (ch_num == I2S_TO_ACP_DMA_CH_NUM)) {
+		dma_ctrl |= ACP_DMA_CNTL_0__DMAChIOCEn_MASK;
+	} else {
+		dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;
+	}
+
+	/* enable  for ACP SRAM to/from I2S DMA channel */
+	if (is_circular == true) {
+		dma_ctrl |= ACP_DMA_CNTL_0__Circular_DMA_En_MASK;
+		cgs_irq_get(acp_prv->cgs_device, VISLANDS30_IV_SRCID_ACP, 0);
+	}
+	else
+		dma_ctrl &= ~ACP_DMA_CNTL_0__Circular_DMA_En_MASK;
+
+	cgs_write_register(acp_prv->cgs_device,	(mmACP_DMA_CNTL_0 + ch_num),
+			   dma_ctrl);
+
+	status = STATUS_SUCCESS;
+	return status;
+}
+
+/* Stop a given dma channel number*/
+static int acp_dma_stop(struct amd_acp_device *acp_dev, u8 ch_num)
+{
+	int status = STATUS_UNSUCCESSFUL;
+	u32 dma_ctrl;
+	u32 dma_ch_sts;
+	u32 delay_time = ACP_DMA_RESET_TIME;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (acp_dev == NULL)
+		return status;
+
+	/* register mask value to check the channel status bits */
+	dma_ctrl = cgs_read_register(acp_prv->cgs_device,
+				     mmACP_DMA_CNTL_0 + ch_num);
+
+	/* clear the dma control register fields before writing zero
+	 * in reset bit
+	 */
+	dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;
+	dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;
+
+	cgs_write_register(acp_prv->cgs_device,
+			   (mmACP_DMA_CNTL_0 + ch_num), dma_ctrl);
+	dma_ch_sts = cgs_read_register(acp_prv->cgs_device, mmACP_DMA_CH_STS);
+
+	if (dma_ch_sts & BIT(ch_num)) {
+		/* set the reset bit for this channel
+		 * to stop the dma transfer */
+		dma_ctrl |= ACP_DMA_CNTL_0__DMAChRst_MASK;
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_DMA_CNTL_0 + ch_num), dma_ctrl);
+	}
+
+	/* if channel transfer is not stopped with in time delay
+	 * return this status */
+	status = -EBUSY;
+
+	/* check the channel status bit for some time and return the status */
+	while (0 < delay_time) {
+		dma_ch_sts = cgs_read_register(acp_prv->cgs_device,
+					       mmACP_DMA_CH_STS);
+		if (!(dma_ch_sts & BIT(ch_num))) {
+			/* clear the reset flag after successfully stopping
+			   the dma transfer and break from the loop */
+			dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRst_MASK;
+
+			cgs_write_register(acp_prv->cgs_device,
+					   (mmACP_DMA_CNTL_0 + ch_num),
+					   dma_ctrl);
+			status = STATUS_SUCCESS;
+			break;
+		}
+		delay_time--;
+	}
+
+	if ((ch_num == ACP_TO_I2S_DMA_CH_NUM) ||
+	    (ch_num == I2S_TO_ACP_DMA_CH_NUM)) {
+		cgs_irq_put(acp_prv->cgs_device, VISLANDS30_IV_SRCID_ACP, 0);
+	}
+
+	return status;
+}
 
-#define ACP_MODE_I2S	0
-#define ACP_MODE_AZ	1
+static int dma_irq_handler(void *prv_data)
+{
+	u16 play_acp_i2s_intr, cap_i2s_acp_intr, cap_acp_sysram_intr;
+	u16 dscr_idx, intr_flag;
+	u32 ext_intr_status;
+	int priority_level = 0x0;
+	int dma_transfer_status = STATUS_UNSUCCESSFUL;
+	struct acp_irq_prv *idata = prv_data;
+	struct amd_acp_device *acp_dev = idata->acp_dev;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	intr_flag = acp_get_intr_flag(acp_dev);
+
+	play_acp_i2s_intr = (intr_flag & BIT(ACP_TO_I2S_DMA_CH_NUM));
+	cap_i2s_acp_intr = (intr_flag & BIT(I2S_TO_ACP_DMA_CH_NUM));
+	cap_acp_sysram_intr = (intr_flag & BIT(ACP_TO_SYSRAM_CH_NUM));
+
+	if (!play_acp_i2s_intr && !cap_i2s_acp_intr && !cap_acp_sysram_intr) {
+		/* We registered for DMA Interrupt-On-Complete interrupts only.
+		 * If we hit here, log, acknowledge it and return. */
+		ext_intr_status = cgs_read_register(acp_prv->cgs_device,
+					    mmACP_EXTERNAL_INTR_STAT);
+		pr_info("ACP: Not a DMA IOC irq: %x\n", ext_intr_status);
+		return 0;
+	}
+
+	if (play_acp_i2s_intr) {
+		dscr_idx = get_dscr_idx(acp_dev, STREAM_PLAYBACK);
+		config_acp_dma_channel(acp_dev, SYSRAM_TO_ACP_CH_NUM, dscr_idx,
+				       1, priority_level);
+		dma_transfer_status = acp_dma_start(acp_dev,
+						    SYSRAM_TO_ACP_CH_NUM,
+						    false);
+		idata->set_elapsed(idata->dev, 1, 0);
+
+		acp_ext_stat_clear_dmaioc(acp_dev, ACP_TO_I2S_DMA_CH_NUM);
+	}
+
+	if (cap_i2s_acp_intr) {
+		dscr_idx = get_dscr_idx(acp_dev, STREAM_CAPTURE);
+		config_acp_dma_channel(acp_dev, ACP_TO_SYSRAM_CH_NUM, dscr_idx,
+				       1, priority_level);
+		dma_transfer_status = acp_dma_start(acp_dev,
+						    ACP_TO_SYSRAM_CH_NUM,
+						    false);
+
+		acp_ext_stat_clear_dmaioc(acp_dev, I2S_TO_ACP_DMA_CH_NUM);
+	}
+
+	if (cap_acp_sysram_intr) {
+		idata->set_elapsed(idata->dev, 0, 1);
+		acp_ext_stat_clear_dmaioc(acp_dev, ACP_TO_SYSRAM_CH_NUM);
+	}
+
+	return 0;
+}
+
+static int irq_handler(void *private_data, unsigned src_id,
+		       const uint32_t *iv_entry)
+{
+	if (src_id == VISLANDS30_IV_SRCID_ACP)
+		return dma_irq_handler(private_data);
+	else
+		return -1;
+}
+
+static void acp_suspend_tile(struct amd_acp_private *acp_prv, int tile)
+{
+	u32 val = 0;
+	u32 timeout = 0;
 
-#define mmACP_AZALIA_I2S_SELECT 0x51d4
+	if ((tile  < ACP_TILE_P1) || (tile > ACP_TILE_DSP2)) {
+		pr_err(" %s : Invalid ACP power tile index\n", __func__);
+		return;
+	}
+
+	val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_READ_REG_0 + tile);
+	val &= ACP_TILE_ON_MASK;
+
+	if (val == 0x0) {
+		val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_RETAIN_REG);
+		val = val | (1 << tile);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_PGFSM_RETAIN_REG,
+							val);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_PGFSM_CONFIG_REG,
+							0x500 + tile);
+
+		timeout = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
+		while (timeout--) {
+			val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_READ_REG_0 + tile);
+			val = val & ACP_TILE_ON_MASK;
+			if (val == ACP_TILE_OFF_MASK)
+				break;
+		}
+
+		val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_RETAIN_REG);
+
+		val |= ACP_TILE_OFF_RETAIN_REG_MASK;
+		cgs_write_register(acp_prv->cgs_device,	mmACP_PGFSM_RETAIN_REG,
+							val);
+	}
+
+}
+
+static void acp_resume_tile(struct amd_acp_private *acp_prv, int tile)
+{
+	u32 val = 0;
+	u32 timeout = 0;
+
+	if ((tile  < ACP_TILE_P1) || (tile > ACP_TILE_DSP2)) {
+		pr_err(" %s : Invalid ACP power tile index\n", __func__);
+		return;
+	}
+
+	val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_READ_REG_0 + tile);
+	val = val & ACP_TILE_ON_MASK;
+
+	if (val != 0x0) {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_PGFSM_CONFIG_REG,
+							0x600 + tile);
+		timeout = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
+		while (timeout--) {
+			val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_READ_REG_0 + tile);
+			val = val & ACP_TILE_ON_MASK;
+			if (val == 0x0)
+				break;
+		}
+		val = cgs_read_register(acp_prv->cgs_device,
+					mmACP_PGFSM_RETAIN_REG);
+		if (tile == ACP_TILE_P1)
+			val = val & (ACP_TILE_P1_MASK);
+		else if (tile == ACP_TILE_P2)
+			val = val & (ACP_TILE_P2_MASK);
+
+		cgs_write_register(acp_prv->cgs_device,	mmACP_PGFSM_RETAIN_REG,
+							val);
+	}
+}
+
+/* Initialize and bring ACP hardware to default state. */
+static void acp_init(struct amd_acp_private *acp_prv)
+{
+	u32 val;
+	u32 timeout_value;
+
+	/* Assert Soft reset of ACP */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+
+	val |= ACP_SOFT_RESET__SoftResetAud_MASK;
+	cgs_write_register(acp_prv->cgs_device,
+			   mmACP_SOFT_RESET, val);
+
+	timeout_value = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+		if (ACP_SOFT_RESET__SoftResetAudDone_MASK ==
+		    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))
+			break;
+	}
+
+	/* Enabling clock to ACP and waits until the clock is enabled */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_CONTROL);
+	val = val | ACP_CONTROL__ClkEn_MASK;
+	cgs_write_register(acp_prv->cgs_device,	mmACP_CONTROL, val);
+
+	timeout_value = ACP_CLOCK_EN_TIME_OUT_VALUE;
+
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_STATUS);
+		if (val & (u32) 0x1)
+			break;
+		udelay(100);
+	}
+
+	/* Deassert the SOFT RESET flags */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+	val &= ~ACP_SOFT_RESET__SoftResetAud_MASK;
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SOFT_RESET, val);
+
+	/* initiailizing Garlic Control DAGB register */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_AXI2DAGB_ONION_CNTL,
+			   ONION_CNTL_DEFAULT);
+
+	/* initiailizing Onion Control DAGB registers */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_AXI2DAGB_GARLIC_CNTL,
+			   GARLIC_CNTL_DEFAULT);
+
+	acp_dma_descr_init(acp_prv);
+
+	/* DMA DSCR BASE ADDRESS IN SRAM */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DMA_DESC_BASE_ADDR,
+			   ACP_SRAM_BASE_ADDRESS);
+
+	/* Num of descriptiors in SRAM 0x4, means 256 descriptors;(64 * 4) */
+	cgs_write_register(acp_prv->cgs_device, mmACP_DMA_DESC_MAX_NUM_DSCR,
+			   0x4);
+
+	cgs_write_register(acp_prv->cgs_device,	mmACP_EXTERNAL_INTR_CNTL,
+			   ACP_EXTERNAL_INTR_CNTL__DMAIOCMask_MASK);
+
+	pr_info("ACP: Initialized.\n");
+
+}
+
+static int acp_hw_init(struct amd_acp_device *acp_dev, void *iprv)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	acp_init(acp_prv);
+
+	cgs_add_irq_source(acp_prv->cgs_device, VISLANDS30_IV_SRCID_ACP, 1,
+			   irq_set_source, irq_handler, iprv);
+
+	/* Disable DSPs which are not used */
+	acp_suspend_tile(acp_prv, ACP_TILE_DSP0);
+	acp_suspend_tile(acp_prv, ACP_TILE_DSP1);
+	acp_suspend_tile(acp_prv, ACP_TILE_DSP2);
+
+	return STATUS_SUCCESS;
+}
+
+static void acp_deinit(struct amd_acp_private *acp_prv)
+{
+	u32 val;
+	u32 timeout_value;
+
+	  /* Assert Soft reset of ACP */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+
+	val |= ACP_SOFT_RESET__SoftResetAud_MASK;
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SOFT_RESET, val);
+
+	timeout_value = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+		if (ACP_SOFT_RESET__SoftResetAudDone_MASK ==
+		    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK)) {
+			break;
+	    }
+	}
+	 /** Disable ACP clock */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_CONTROL);
+	val &= ~ACP_CONTROL__ClkEn_MASK;
+	cgs_write_register(acp_prv->cgs_device, mmACP_CONTROL, val);
+
+	timeout_value = ACP_CLOCK_EN_TIME_OUT_VALUE;
+
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_STATUS);
+		if (!(val & (u32) 0x1))
+			break;
+		udelay(100);
+	}
+
+	pr_info("ACP: De-Initialized.\n");
+}
+
+static void acp_hw_deinit(struct amd_acp_device *acp_dev)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	acp_deinit(acp_prv);
+}
+
+/*	Get the number of bytes consumed for SRAM_TO_I2S DMA
+ *	 channel during rendering
+ */
+static u32 acp_update_dma_pointer(struct amd_acp_device *acp_dev, int direction,
+				  u32 period_size)
+{
+	u32 pos;
+	u16 dscr;
+	u32 mul;
+	u32 dma_config;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	pos = 0;
+
+	if (direction == STREAM_PLAYBACK) {
+		dscr = cgs_read_register(acp_prv->cgs_device,
+					 mmACP_DMA_CUR_DSCR_13);
+
+		mul = (dscr == PLAYBACK_START_DMA_DESCR_CH13) ? 0 : 1;
+		pos =  (mul * period_size);
+
+	} else if (direction == STREAM_CAPTURE) {
+		dma_config = cgs_read_register(acp_prv->cgs_device,
+					       mmACP_DMA_CNTL_14);
+		if (dma_config != 0) {
+			dscr = cgs_read_register(acp_prv->cgs_device,
+					 mmACP_DMA_CUR_DSCR_14);
+			mul = (dscr == CAPTURE_START_DMA_DESCR_CH14) ? 1 : 2;
+			pos = (mul * period_size);
+		}
+
+		if (pos >= (2 * period_size))
+			pos = 0;
+
+	}
+	return pos;
+}
+
+/*	Wait for complete buffering to complete in HOST
+ *	 to SRAM DMA channel
+ */
+static void wait_for_prebuffer_finish(struct amd_acp_device *acp_dev)
+{
+	u32 dma_ch_sts;
+	u32 channel_mask = BIT(SYSRAM_TO_ACP_CH_NUM);
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	do {
+		/* Read the channel status to poll dma transfer completion
+		 * (System RAM to SRAM)
+		 * In this case, it will be runtime->start_threshold
+		 * (2 ALSA periods) of transfer. Rendering starts after this
+		 * threshold is met.
+		 */
+		dma_ch_sts = cgs_read_register(acp_prv->cgs_device,
+					       mmACP_DMA_CH_STS);
+		udelay(20);
+	} while (dma_ch_sts & channel_mask);
+}
+
+static void i2s_reset(struct amd_acp_device *acp_dev, int direction)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK)
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_TXFFR, 1);
+	else
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_I2SMICSP_RXFFR, 1);
+
+}
+
+static void i2s_start(struct amd_acp_device *acp_dev, int direction)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK) {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_IER, 1);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_ITER, 1);
+
+	} else {
+		cgs_write_register(acp_prv->cgs_device, mmACP_I2SMICSP_IER, 1);
+		cgs_write_register(acp_prv->cgs_device, mmACP_I2SMICSP_IRER, 1);
+	}
+
+	cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_CER, 1);
+}
+
+static void i2s_stop(struct amd_acp_device *acp_dev, int direction)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	i2s_clear_irqs(acp_dev, direction);
+
+	if (direction == STREAM_PLAYBACK)
+		cgs_write_register(acp_prv->cgs_device, mmACP_I2SSP_ITER, 0);
+	else
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SMICSP_IRER, 0);
+
+	if (direction == STREAM_PLAYBACK) {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_CER, 0);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_IER, 0);
+	} else {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SMICSP_CER, 0);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SMICSP_IER, 0);
+	}
+}
+
+static void configure_i2s(struct amd_acp_device *acp_dev,
+			  struct acp_i2s_config *i2s_config)
+{
+	i2s_disable_channels(acp_dev, i2s_config->direction);
+	configure_i2s_stream(acp_dev, i2s_config);
+}
+
+void amd_acp_pcm_suspend(struct amd_acp_device *acp_dev)
+{
+	struct amd_acp_private *acp_prv;
+
+	acp_prv = (struct amd_acp_private *)acp_dev;
+	amd_acp_suspend(acp_prv);
+}
+
+void amd_acp_pcm_resume(struct amd_acp_device *acp_dev)
+{
+	struct amd_acp_private *acp_prv;
+
+	acp_prv = (struct amd_acp_private *)acp_dev;
+	amd_acp_resume(acp_prv);
+}
 
 int amd_acp_hw_init(void *cgs_device,
-		    unsigned acp_version_major, unsigned acp_version_minor)
+		    unsigned acp_version_major, unsigned acp_version_minor,
+		    struct amd_acp_private **acp_private)
 {
 	unsigned int acp_mode = ACP_MODE_I2S;
 
@@ -46,5 +1038,55 @@ int amd_acp_hw_init(void *cgs_device,
 	if (acp_mode != ACP_MODE_I2S)
 		return -ENODEV;
 
+	*acp_private = kzalloc(sizeof(struct amd_acp_private), GFP_KERNEL);
+	if (*acp_private == NULL)
+		return -ENOMEM;
+
+	(*acp_private)->cgs_device = cgs_device;
+	(*acp_private)->acp_version_major = acp_version_major;
+	(*acp_private)->acp_version_minor = acp_version_minor;
+
+	(*acp_private)->public.init = acp_hw_init;
+	(*acp_private)->public.fini = acp_hw_deinit;
+	(*acp_private)->public.config_dma = config_acp_dma;
+	(*acp_private)->public.config_dma_channel = config_acp_dma_channel;
+	(*acp_private)->public.dma_start = acp_dma_start;
+	(*acp_private)->public.dma_stop = acp_dma_stop;
+	(*acp_private)->public.update_dma_pointer = acp_update_dma_pointer;
+	(*acp_private)->public.prebuffer_audio = wait_for_prebuffer_finish;
+
+	(*acp_private)->public.i2s_reset = i2s_reset;
+	(*acp_private)->public.config_i2s = configure_i2s;
+	(*acp_private)->public.i2s_start = i2s_start;
+	(*acp_private)->public.i2s_stop = i2s_stop;
+
+	(*acp_private)->public.acp_suspend = amd_acp_pcm_suspend;
+	(*acp_private)->public.acp_resume = amd_acp_pcm_resume;
+
+	return 0;
+}
+
+int amd_acp_hw_fini(struct amd_acp_private *acp_private)
+{
+	kfree(acp_private);
 	return 0;
 }
+
+void amd_acp_suspend(struct amd_acp_private *acp_private)
+{
+	acp_suspend_tile(acp_private, ACP_TILE_P2);
+	acp_suspend_tile(acp_private, ACP_TILE_P1);
+}
+
+void amd_acp_resume(struct amd_acp_private *acp_private)
+{
+	acp_resume_tile(acp_private, ACP_TILE_P1);
+	acp_resume_tile(acp_private, ACP_TILE_P2);
+
+	acp_init(acp_private);
+
+	/* Disable DSPs which might have been enabled by SMU */
+	acp_suspend_tile(acp_private, ACP_TILE_DSP0);
+	acp_suspend_tile(acp_private, ACP_TILE_DSP1);
+	acp_suspend_tile(acp_private, ACP_TILE_DSP2);
+}
diff --git a/drivers/gpu/drm/amd/acp/acp_hw.h b/drivers/gpu/drm/amd/acp/acp_hw.h
new file mode 100644
index 0000000..4aa6b1c
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/acp_hw.h
@@ -0,0 +1,111 @@
+#ifndef __ACP_HW_H
+#define __ACP_HW_H
+
+#define ACP_MODE_I2S				0
+#define ACP_MODE_AZ				1
+
+#define DISABLE					0
+#define ENABLE					1
+
+#define PAGE_SIZE_4K				4096
+#define PAGE_SIZE_4K_ENABLE			0x02
+
+#define PLAYBACK_PTE_OFFSET			10
+#define CAPTURE_PTE_OFFSET			0
+
+#define GARLIC_CNTL_DEFAULT			0x00000FB4
+#define ONION_CNTL_DEFAULT			0x00000FB4
+
+#define ACP_PHYSICAL_BASE			0x14000
+
+/* Playback SRAM address (as a destination in dma descriptor) */
+#define ACP_SHARED_RAM_BANK_38_ADDRESS		0x404A000
+
+/* Capture SRAM address (as a source in dma descriptor) */
+#define ACP_SHARED_RAM_BANK_47_ADDRESS		0x4054000
+
+#define ACP_DMA_RESET_TIME			10000
+#define ACP_CLOCK_EN_TIME_OUT_VALUE		0x000000FF
+#define ACP_SOFT_RESET_DONE_TIME_OUT_VALUE	0x000000FF
+#define ACP_DMA_COMPLETE_TIME_OUT_VALUE		0x000000FF
+
+#define ACP_SRAM_BASE_ADDRESS			0x4000000
+#define ACP_DAGB_GRP_SRAM_BASE_ADDRESS		0x4001000
+#define ACP_DAGB_GRP_SRBM_SRAM_BASE_OFFSET	0x1000
+#define ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS	0x00000000
+#define ACP_INTERNAL_APERTURE_WINDOW_4_ADDRESS	0x01800000
+
+#define TO_ACP_I2S_1   0x2
+#define TO_ACP_I2S_2   0x4
+#define FROM_ACP_I2S_1 0xa
+#define FROM_ACP_I2S_2 0xb
+
+#define ACP_TILE_ON_MASK                0x03
+#define ACP_TILE_OFF_MASK               0x02
+#define ACP_TILE_ON_RETAIN_REG_MASK     0x1f
+#define ACP_TILE_OFF_RETAIN_REG_MASK    0x20
+
+#define ACP_TILE_P1_MASK                0x3e
+#define ACP_TILE_P2_MASK                0x3d
+#define ACP_TILE_DSP0_MASK              0x3b
+#define ACP_TILE_DSP1_MASK              0x37
+#define ACP_TILE_DSP2_MASK              0x2f
+
+enum {
+	ACP_TILE_P1 = 0,
+	ACP_TILE_P2,
+	ACP_TILE_DSP0,
+	ACP_TILE_DSP1,
+	ACP_TILE_DSP2,
+};
+
+enum {
+	STREAM_PLAYBACK = 0,
+	STREAM_CAPTURE,
+	STREAM_LAST = STREAM_CAPTURE,
+};
+
+enum {
+	ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION = 0x0,
+	ACP_DMA_ATTRIBUTES_SHARED_MEM_TO_DAGB_GARLIC = 0x1,
+	ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM = 0x8,
+	ACP_DMA_ATTRIBUTES_DAGB_GARLIC_TO_SHAREDMEM = 0x9,
+	ACP_DMA_ATTRIBUTES_FORCE_SIZE = 0xF
+};
+
+typedef struct acp_dma_dscr_size_transfer_direction {
+	/* Specifies the number of bytes need to be transferred
+	 *  from source to destination memory. */
+	u32 size:16;
+	/* Specifies transfer direction. */
+	u32 trans_direction:4;
+	/* reserved. */
+	u32 reserved1:2;
+	/* Specifies the IOC enable or not for descriptor. */
+	/* Defaultly this will be 0, for the last descriptor, make it Enable */
+	u32 ioc:1;
+	/* reserved. */
+	u32 reserved2:9;
+} acp_dma_dscr_size_transfer_direction_t;
+
+typedef union {
+	u32 val:32;
+	acp_dma_dscr_size_transfer_direction_t s;
+} acp_dma_dscr_size_transfer_direction_u;
+
+typedef struct acp_dma_dscr_transfer {
+	/* Specifies the source memory location for the DMA data transfer. */
+	u32 src;
+	/* Specifies the destination memory location to where the data will
+	   be transferred.
+	 */
+	u32 dest;
+	/* Specifies the number of bytes need to be transferred
+	 * from source to destination memory.Transfer direction & IOC enable
+	 */
+	acp_dma_dscr_size_transfer_direction_u size_xfer_dir;
+	/** Reserved for future use */
+	u32 reserved;
+} acp_dma_dscr_transfer_t;
+
+#endif /*__ACP_HW_H */
diff --git a/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h b/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h
index bccf47b..83662d6 100644
--- a/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h
+++ b/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h
@@ -27,8 +27,23 @@
 #include <linux/types.h>
 #include "cgs_linux.h"
 #include "cgs_common.h"
+#include "amd_acp.h"
+
+struct amd_acp_private {
+	/* The public struture is first, so that pointers can be cast
+	 * between the public and private structure */
+	struct amd_acp_device public;
+
+	/* private elements not expose through the bus interface */
+	void *cgs_device;
+	unsigned acp_version_major, acp_version_minor;
+};
 
 int amd_acp_hw_init(void *cgs_device,
-		    unsigned acp_version_major, unsigned acp_version_minor);
+		    unsigned acp_version_major, unsigned acp_version_minor,
+		    struct amd_acp_private **apriv);
+int amd_acp_hw_fini(struct amd_acp_private *apriv);
+void amd_acp_suspend(struct amd_acp_private *acp_private);
+void amd_acp_resume(struct amd_acp_private *acp_private);
 
 #endif /* _ACP_GFX_IF_H */
diff --git a/drivers/gpu/drm/amd/acp/include/amd_acp.h b/drivers/gpu/drm/amd/acp/include/amd_acp.h
new file mode 100644
index 0000000..8c1d31a
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/include/amd_acp.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+*/
+
+#ifndef _AMD_ACP_H
+#define _AMD_ACP_H
+
+#include <linux/types.h>
+
+/* Playback DMA channels */
+#define SYSRAM_TO_ACP_CH_NUM 12
+#define ACP_TO_I2S_DMA_CH_NUM 13
+
+/* Capture DMA channels */
+#define ACP_TO_SYSRAM_CH_NUM 14
+#define I2S_TO_ACP_DMA_CH_NUM 15
+
+#define PLAYBACK_START_DMA_DESCR_CH12 0
+#define PLAYBACK_END_DMA_DESCR_CH12 1
+
+#define PLAYBACK_START_DMA_DESCR_CH13 2
+#define PLAYBACK_END_DMA_DESCR_CH13 3
+
+
+#define CAPTURE_START_DMA_DESCR_CH14 4
+#define CAPTURE_END_DMA_DESCR_CH14 5
+
+#define CAPTURE_START_DMA_DESCR_CH15 6
+#define CAPTURE_END_DMA_DESCR_CH15 7
+
+#define STATUS_SUCCESS 0
+#define STATUS_UNSUCCESSFUL -1
+
+enum acp_dma_priority_level {
+	/* 0x0 Specifies the DMA channel is given normal priority */
+	ACP_DMA_PRIORITY_LEVEL_NORMAL = 0x0,
+	/* 0x1 Specifies the DMA channel is given high priority */
+	ACP_DMA_PRIORITY_LEVEL_HIGH = 0x1,
+	ACP_DMA_PRIORITY_LEVEL_FORCESIZE = 0xFF
+};
+
+struct acp_dma_config {
+	struct page *pg;
+	u16 num_of_pages;
+	u16 direction;
+	uint64_t size;
+};
+
+struct acp_i2s_config {
+	u16 direction;
+	u32 xfer_resolution;
+	u32 irq;
+	u32 ch_reg;
+};
+
+struct acp_irq_prv {
+	struct device *dev;
+	struct amd_acp_device *acp_dev;
+	void (*set_elapsed)(struct device *pdev, u16 play_intr,
+						u16 capture_intr);
+};
+
+/* Public interface of ACP device exposed on AMD GNB bus */
+struct amd_acp_device {
+	/* Handshake when ALSA driver connects, disconnects
+	 * TBD: is this really needed? */
+	int (*init)(struct amd_acp_device *acp_dev, void *iprv);
+	void (*fini)(struct amd_acp_device *acp_dev);
+
+	/**
+	 * config_dma() - Configure ACP internal DMA controller
+	 * @acp_dev:	    acp device
+	 * @acp_dma_config: DMA configuration parameters
+	 *
+	 * This will configure the DMA controller with the given
+	 * configuration parameters.
+	 */
+	void (*config_dma)(struct amd_acp_device *acp_dev,
+			   struct acp_dma_config *dma_config);
+
+	/**
+	 * config_dma_channel() - Configure ACP DMA channel
+	 * @acp_dev:	    acp device
+	 * @ch_num:	    channel number to be configured
+	 * @dscr_strt_idx:  DMA descriptor starting index
+	 * @priority_level: priority level of channel
+	 *
+	 * This will configure the DMA channel with the given
+	 * configuration parameters.
+	 */
+	void (*config_dma_channel)(struct amd_acp_device *acp_dev,
+				   u8 ch_num, u16 dscr_strt_idx, u16 num_dscrs,
+				   enum acp_dma_priority_level priority_level);
+
+	/**
+	 * dma_start() - Start ACP DMA engine
+	 * @acp_dev:	 acp device
+	 * @ch_num:	 DMA channel number
+	 * @is_circular: configure circular DMA
+	 *
+	 * Start DMA channel as configured.
+	 */
+	int (*dma_start)(struct amd_acp_device *acp_dev, u16 ch_num,
+			  bool is_circular);
+
+	/**
+	 * dma_stop() - Stop ACP DMA engine
+	 * @acp_dev:	acp device
+	 * @ch_num:	DMA channel number
+	 *
+	 * Stop DMA channel as configured.
+	 */
+	int (*dma_stop)(struct amd_acp_device *acp_dev, u8 ch_num);
+
+	/**
+	 * update_dma_pointer() - Query the buffer postion
+	 * @acp_dev:	 acp device
+	 * @direction:   Dma transfer direction
+	 * @period_size: size of buffer in-terms of ALSA terminology
+	 *
+	 * This will query the buffer position from ACP IP, based on data
+	 * produced/consumed
+	 */
+	u32 (*update_dma_pointer)(struct amd_acp_device *acp_dev,
+				  int direction, u32 period_size);
+
+	/**
+	 * prebuffer_audio() - Wait for buffering to complete
+	 * @acp_dev:	acp device
+	 *
+	 * Wait for buffering to complete in HOST to SRAM DMA channel.
+	 */
+	void (*prebuffer_audio)(struct amd_acp_device *acp_dev);
+
+	/**
+	 * i2s_reset() -  Reset i2s FIFOs
+	 * @acp_dev:	  acp device
+	 * @direction:    direction of stream – playback/record
+	 *
+	 * Resets I2S FIFOs
+	 */
+	void (*i2s_reset)(struct amd_acp_device *acp_dev, int direction);
+
+	/**
+	 * config_i2s() - Configure the i2s controller
+	 * @acp_dev:    acp device
+	 * @i2s_config: configuration of i2s controller
+	 *
+	 * This will configure the i2s controller instance used on the
+	 * board, with the given configuration parameters.
+	 */
+	void (*config_i2s)(struct amd_acp_device *acp_dev,
+			   struct acp_i2s_config *i2s_config);
+
+	/**
+	 * i2s_start() - Start i2s controller
+	 * @acp_dev:	  acp device
+	 * @direction:    direction of stream – playback/record
+	 *
+	 * Starts I2S data transmission
+	 */
+	void (*i2s_start)(struct amd_acp_device *acp_dev, int direction);
+
+	/**
+	 * i2s_stop() - Stop i2s controller
+	 * @acp_dev:	acp device
+	 * @stream:	Type of stream – playback/record
+	 *
+	 * Stops I2S data transmission
+	 */
+	void (*i2s_stop)(struct amd_acp_device *acp_dev, int direction);
+
+	/**
+	 * acp_suspend() - Power off ACP
+	 * @acp_dev:	acp device
+	 *
+	 * Switch off power tiles of ACP
+	 */
+	void (*acp_suspend)(struct amd_acp_device *acp_dev);
+
+	/**
+	 * acp_resume() - Power on ACP
+	 * @acp_dev:	acp device
+	 *
+	 * Switch on power tiles of ACP
+	 */
+
+	void (*acp_resume)(struct amd_acp_device *acp_dev);
+
+	/* TODO: Need callback registration interface for asynchronous
+	 * notifications */
+
+};
+
+#endif /* _AMD_ACP_H */
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
index d6b0bff..e4112ea 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
@@ -23,61 +23,16 @@
  *
  */
 
-#include <linux/irqdomain.h>
-#include <linux/pm_domain.h>
-#include <linux/platform_device.h>
-#include <sound/designware_i2s.h>
-#include <sound/pcm.h>
-
 #include "amdgpu.h"
 #include "atom.h"
 #include "amdgpu_acp.h"
-
+#include "amd_gnb_bus.h"
 #include "acp_gfx_if.h"
 
-#define ACP_TILE_ON_MASK                0x03
-#define ACP_TILE_OFF_MASK               0x02
-#define ACP_TILE_ON_RETAIN_REG_MASK     0x1f
-#define ACP_TILE_OFF_RETAIN_REG_MASK    0x20
-
-#define ACP_TILE_P1_MASK                0x3e
-#define ACP_TILE_P2_MASK                0x3d
-#define ACP_TILE_DSP0_MASK              0x3b
-#define ACP_TILE_DSP1_MASK              0x37
-
-#define ACP_TILE_DSP2_MASK              0x2f
-
-#define ACP_DMA_REGS_END		0x146c0
-#define ACP_I2S_PLAY_REGS_START		0x14840
-#define ACP_I2S_PLAY_REGS_END		0x148b4
-#define ACP_I2S_CAP_REGS_START		0x148b8
-#define ACP_I2S_CAP_REGS_END		0x1496c
-
-#define ACP_I2S_COMP1_CAP_REG_OFFSET	0xac
-#define ACP_I2S_COMP2_CAP_REG_OFFSET	0xa8
-#define ACP_I2S_COMP1_PLAY_REG_OFFSET	0x6c
-#define ACP_I2S_COMP2_PLAY_REG_OFFSET	0x68
-
-#define mmACP_PGFSM_RETAIN_REG		0x51c9
-#define mmACP_PGFSM_CONFIG_REG		0x51ca
-#define mmACP_PGFSM_READ_REG_0		0x51cc
-
-#define mmACP_MEM_SHUT_DOWN_REQ_LO	0x51f8
-#define mmACP_MEM_SHUT_DOWN_REQ_HI	0x51f9
-#define mmACP_MEM_SHUT_DOWN_STS_LO	0x51fa
-#define mmACP_MEM_SHUT_DOWN_STS_HI	0x51fb
-
-#define ACP_TIMEOUT_LOOP		0x000000FF
-#define ACP_DEVS			3
-#define ACP_SRC_ID			162
-
-enum {
-	ACP_TILE_P1 = 0,
-	ACP_TILE_P2,
-	ACP_TILE_DSP0,
-	ACP_TILE_DSP1,
-	ACP_TILE_DSP2,
-};
+static int acp_early_init(void *handle)
+{
+	return 0;
+}
 
 static int acp_sw_init(void *handle)
 {
@@ -103,168 +58,16 @@ static int acp_sw_fini(void *handle)
 	return 0;
 }
 
-/* power off a tile/block within ACP */
-static int acp_suspend_tile(void *cgs_dev, int tile)
-{
-	u32 val = 0;
-	u32 count = 0;
-
-	if ((tile  < ACP_TILE_P1) || (tile > ACP_TILE_DSP2)) {
-		pr_err("Invalid ACP tile : %d to suspend\n", tile);
-		return -1;
-	}
-
-	val = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0 + tile);
-	val &= ACP_TILE_ON_MASK;
-
-	if (val == 0x0) {
-		val = cgs_read_register(cgs_dev, mmACP_PGFSM_RETAIN_REG);
-		val = val | (1 << tile);
-		cgs_write_register(cgs_dev, mmACP_PGFSM_RETAIN_REG, val);
-		cgs_write_register(cgs_dev, mmACP_PGFSM_CONFIG_REG,
-					0x500 + tile);
-
-		count = ACP_TIMEOUT_LOOP;
-		while (true) {
-			val = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0
-								+ tile);
-			val = val & ACP_TILE_ON_MASK;
-			if (val == ACP_TILE_OFF_MASK)
-				break;
-			if (--count == 0) {
-				pr_err("Timeout reading ACP PGFSM status\n");
-				return -ETIMEDOUT;
-			}
-			udelay(100);
-		}
-
-		val = cgs_read_register(cgs_dev, mmACP_PGFSM_RETAIN_REG);
-
-		val |= ACP_TILE_OFF_RETAIN_REG_MASK;
-		cgs_write_register(cgs_dev, mmACP_PGFSM_RETAIN_REG, val);
-	}
-	return 0;
-}
-
-/* power on a tile/block within ACP */
-static int acp_resume_tile(void *cgs_dev, int tile)
-{
-	u32 val = 0;
-	u32 count = 0;
-
-	if ((tile  < ACP_TILE_P1) || (tile > ACP_TILE_DSP2)) {
-		pr_err("Invalid ACP tile to resume\n");
-		return -1;
-	}
-
-	val = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0 + tile);
-	val = val & ACP_TILE_ON_MASK;
-
-	if (val != 0x0) {
-		cgs_write_register(cgs_dev, mmACP_PGFSM_CONFIG_REG,
-					0x600 + tile);
-		count = ACP_TIMEOUT_LOOP;
-		while (true) {
-			val = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0
-							+ tile);
-			val = val & ACP_TILE_ON_MASK;
-			if (val == 0x0)
-				break;
-			if (--count == 0) {
-				pr_err("Timeout reading ACP PGFSM status\n");
-				return -ETIMEDOUT;
-			}
-			udelay(100);
-		}
-		val = cgs_read_register(cgs_dev, mmACP_PGFSM_RETAIN_REG);
-		if (tile == ACP_TILE_P1)
-			val = val & (ACP_TILE_P1_MASK);
-		else if (tile == ACP_TILE_P2)
-			val = val & (ACP_TILE_P2_MASK);
-
-		cgs_write_register(cgs_dev, mmACP_PGFSM_RETAIN_REG, val);
-	}
-	return 0;
-}
-
-struct acp_pm_domain {
-	void *cgs_dev;
-	struct generic_pm_domain gpd;
-};
-
-static int acp_poweroff(struct generic_pm_domain *genpd)
-{
-	int i, ret;
-	struct acp_pm_domain *apd;
-
-	apd = container_of(genpd, struct acp_pm_domain, gpd);
-	if (apd != NULL) {
-		/* Donot return abruptly if any of power tile fails to suspend.
-		 * Log it and continue powering off other tile
-		 */
-		for (i = 4; i >= 0 ; i--) {
-			ret = acp_suspend_tile(apd->cgs_dev, ACP_TILE_P1 + i);
-			if (ret)
-				pr_err("ACP tile %d tile suspend failed\n", i);
-		}
-	}
-	return 0;
-}
-
-static int acp_poweron(struct generic_pm_domain *genpd)
-{
-	int i, ret;
-	struct acp_pm_domain *apd;
-
-	apd = container_of(genpd, struct acp_pm_domain, gpd);
-	if (apd != NULL) {
-		for (i = 0; i < 2; i++) {
-			ret = acp_resume_tile(apd->cgs_dev, ACP_TILE_P1 + i);
-			if (ret) {
-				pr_err("ACP tile %d resume failed\n", i);
-				break;
-			}
-		}
-
-		/* Disable DSPs which are not going to be used */
-		for (i = 0; i < 3; i++) {
-			ret = acp_suspend_tile(apd->cgs_dev, ACP_TILE_DSP0 + i);
-			/* Continue suspending other DSP, even if one fails */
-			if (ret)
-				pr_err("ACP DSP %d suspend failed\n", i);
-		}
-	}
-	return 0;
-}
-
-static struct device *get_mfd_cell_dev(const char *device_name, int r)
-{
-	char auto_dev_name[25];
-	struct device *dev;
-
-	snprintf(auto_dev_name, sizeof(auto_dev_name),
-		 "%s.%d.auto", device_name, r);
-	dev = bus_find_device_by_name(&platform_bus_type, NULL, auto_dev_name);
-	dev_info(dev, "device %s added to pm domain\n", auto_dev_name);
-
-	return dev;
-}
-
 /**
- * acp_hw_init - start and test ACP block
+ * acp_hw_init - start and test UVD block
  *
  * @adev: amdgpu_device pointer
  *
  */
 static int acp_hw_init(void *handle)
 {
-	int r, i;
-	uint64_t acp_base;
-	struct device *dev;
-	struct i2s_platform_data *i2s_pdata;
-
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
-
+	int r;
 	const struct amdgpu_ip_block_version *ip_version =
 		amdgpu_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);
 
@@ -272,114 +75,21 @@ static int acp_hw_init(void *handle)
 		return -EINVAL;
 
 	r = amd_acp_hw_init(adev->acp.cgs_device,
-			    ip_version->major, ip_version->minor);
+			    ip_version->major, ip_version->minor,
+			    &adev->acp.private);
 	/* -ENODEV means board uses AZ rather than ACP */
 	if (r == -ENODEV)
 		return 0;
 	else if (r)
 		return r;
-
-	r = cgs_get_pci_resource(adev->acp.cgs_device, CGS_RESOURCE_TYPE_MMIO,
-			0x5289, 0, &acp_base);
-	if (r == -ENODEV)
-		return 0;
-	else if (r)
-		return r;
-
-	adev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);
-	if (adev->acp.acp_genpd == NULL)
-		return -ENOMEM;
-
-	adev->acp.acp_genpd->gpd.name = "ACP_AUDIO";
-	adev->acp.acp_genpd->gpd.power_off = acp_poweroff;
-	adev->acp.acp_genpd->gpd.power_on = acp_poweron;
-
-
-	adev->acp.acp_genpd->cgs_dev = adev->acp.cgs_device;
-
-	pm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);
-
-	adev->acp.acp_cell = kzalloc(sizeof(struct mfd_cell) * ACP_DEVS,
-							GFP_KERNEL);
-
-	if (adev->acp.acp_cell == NULL)
-		return -ENOMEM;
-
-	adev->acp.acp_res = kzalloc(sizeof(struct resource) * 4, GFP_KERNEL);
-
-	if (adev->acp.acp_res == NULL) {
-		kfree(adev->acp.acp_cell);
-		return -ENOMEM;
-	}
-
-	i2s_pdata = kzalloc(sizeof(struct i2s_platform_data) * 2, GFP_KERNEL);
-	if (i2s_pdata == NULL) {
-		kfree(adev->acp.acp_res);
-		kfree(adev->acp.acp_cell);
-		return -ENOMEM;
-	}
-
-	i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;
-	i2s_pdata[0].cap = DWC_I2S_PLAY;
-	i2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;
-	i2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;
-	i2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;
-
-	i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |
-				DW_I2S_QUIRK_COMP_PARAM1;
-	i2s_pdata[1].cap = DWC_I2S_RECORD;
-	i2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;
-	i2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;
-	i2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;
-
-	adev->acp.acp_res[0].name = "acp2x_dma";
-	adev->acp.acp_res[0].flags = IORESOURCE_MEM;
-	adev->acp.acp_res[0].start = acp_base;
-	adev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;
-
-	adev->acp.acp_res[1].name = "acp2x_dw_i2s_play";
-	adev->acp.acp_res[1].flags = IORESOURCE_MEM;
-	adev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;
-	adev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;
-
-	adev->acp.acp_res[2].name = "acp2x_dw_i2s_cap";
-	adev->acp.acp_res[2].flags = IORESOURCE_MEM;
-	adev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;
-	adev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;
-
-	adev->acp.acp_res[3].name = "acp2x_dma_irq";
-	adev->acp.acp_res[3].flags = IORESOURCE_IRQ;
-	adev->acp.acp_res[3].start = amdgpu_irq_create_mapping(adev, 162);
-	adev->acp.acp_res[3].end = adev->acp.acp_res[3].start;
-
-	adev->acp.acp_cell[0].name = "acp_audio_dma";
-	adev->acp.acp_cell[0].num_resources = 4;
-	adev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];
-
-	adev->acp.acp_cell[1].name = "designware-i2s";
-	adev->acp.acp_cell[1].num_resources = 1;
-	adev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];
-	adev->acp.acp_cell[1].platform_data = &i2s_pdata[0];
-	adev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);
-
-	adev->acp.acp_cell[2].name = "designware-i2s";
-	adev->acp.acp_cell[2].num_resources = 1;
-	adev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];
-	adev->acp.acp_cell[2].platform_data = &i2s_pdata[1];
-	adev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);
-
-	r = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,
-								ACP_DEVS);
-	if (r)
+	r = amd_gnb_bus_device_init(&adev->acp.acp_pcm_dev,
+				    AMD_GNB_IP_ACP_PCM,
+				    "acp_pcm_dev",
+				    adev->acp.private,
+				    adev->acp.parent);
+	if (r) {
+		amd_acp_hw_fini(adev->acp.private);
 		return r;
-
-	for (i = 0; i < ACP_DEVS ; i++) {
-		dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
-		r = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);
-		if (r) {
-			dev_err(dev, "Failed to add dev to genpd\n");
-			return r;
-		}
 	}
 
 	return 0;
@@ -393,58 +103,33 @@ static int acp_hw_init(void *handle)
  */
 static int acp_hw_fini(void *handle)
 {
-	int i, ret;
-	struct device *dev;
-
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	for (i = 0; i < ACP_DEVS ; i++) {
-		dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);
-		ret = pm_genpd_remove_device(&adev->acp.acp_genpd->gpd, dev);
-		/* If removal fails, dont giveup and try rest */
-		if (ret)
-			dev_err(dev, "remove dev from genpd failed\n");
+	if (adev->acp.private) {
+		amd_acp_hw_fini(adev->acp.private);
+		amd_gnb_bus_unregister_device(&adev->acp.acp_pcm_dev);
 	}
 
-	mfd_remove_devices(adev->acp.parent);
-	kfree(adev->acp.acp_res);
-	kfree(adev->acp.acp_genpd);
-	kfree(adev->acp.acp_cell);
-
 	return 0;
 }
 
 static int acp_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->acp.private)
+		amd_acp_suspend(adev->acp.private);
+
 	return 0;
 }
 
 static int acp_resume(void *handle)
 {
-	int i, ret;
-	struct acp_pm_domain *apd;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	/* SMU block will power on ACP irrespective of ACP runtime status.
-	 * Power off explicitly based on genpd ACP runtime status so that ACP
-	 * hw and ACP-genpd status are in sync.
-	 * 'suspend_power_off' represents "Power status before system suspend"
-	*/
-	if (adev->acp.acp_genpd->gpd.suspend_power_off == true) {
-		apd = container_of(&adev->acp.acp_genpd->gpd,
-					struct acp_pm_domain, gpd);
-
-		for (i = 4; i >= 0 ; i--) {
-			ret = acp_suspend_tile(apd->cgs_dev, ACP_TILE_P1 + i);
-			if (ret)
-				pr_err("ACP tile %d tile suspend failed\n", i);
-		}
-	}
-	return 0;
-}
+	if (adev->acp.private)
+		amd_acp_resume(adev->acp.private);
 
-static int acp_early_init(void *handle)
-{
 	return 0;
 }
 
@@ -479,6 +164,22 @@ static int acp_set_clockgating_state(void *handle,
 static int acp_set_powergating_state(void *handle,
 				     enum amd_powergating_state state)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	/* This doesn't actually powergate the ACP block.
+	 * That's done in the dpm code via the SMC.  This
+	 * just re-inits the block as necessary.  The actual
+	 * gating still happens in the dpm code.  We should
+	 * revisit this when there is a cleaner line between
+	 * the smc and the hw blocks
+	 */
+	if (state == AMD_PG_STATE_GATE) {
+		if (adev->acp.private)
+			amd_acp_suspend(adev->acp.private);
+	} else {
+		if (adev->acp.private)
+			amd_acp_resume(adev->acp.private);
+	}
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h
index f6e32a6..424cd52f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h
@@ -26,15 +26,13 @@
 #ifndef __AMDGPU_ACP_H__
 #define __AMDGPU_ACP_H__
 
-#include <linux/mfd/core.h>
+#include "amd_gnb_bus.h"
 
 struct amdgpu_acp {
 	struct device *parent;
+	struct amd_gnb_bus_dev acp_pcm_dev;
 	void *cgs_device;
 	struct amd_acp_private *private;
-	struct mfd_cell *acp_cell;
-	struct resource *acp_res;
-	struct acp_pm_domain *acp_genpd;
 };
 
 extern const struct amd_ip_funcs acp_ip_funcs;
-- 
1.9.1

