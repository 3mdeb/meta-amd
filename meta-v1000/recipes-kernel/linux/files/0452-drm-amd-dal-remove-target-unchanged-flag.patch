From 08dd5bf102235dd647ee7c9cfdb47c2169ac16a1 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Thu, 7 Apr 2016 12:11:00 -0400
Subject: [PATCH 0452/1722] drm/amd/dal: remove target unchanged flag

This change includes a behaviour fix for resource_map_pool_resources
that will allow dp streams to switch back to dp clock source if
they were previuously sharing a pll and the other stream became disabled.

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |   2 +
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 191 ++++++++++++++++++---
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  46 ++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  44 ++---
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  60 ++-----
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  47 ++---
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   4 -
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |  11 +-
 8 files changed, 228 insertions(+), 177 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 863a1bd..662b33d 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -604,6 +604,8 @@ static void fill_display_configs(
 					break;
 				}
 
+			ASSERT(pipe_ctx != NULL);
+
 			num_cfgs++;
 			cfg->signal = pipe_ctx->signal;
 			cfg->pipe_idx = pipe_ctx->pipe_idx;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 84ddabc..5e916e5 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -442,7 +442,7 @@ void resource_build_scaling_params_for_context(
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *surfaces[],
 		uint8_t surface_count,
-		struct dc_target *dc_target,
+		const struct dc_target *dc_target,
 		struct validate_context *context)
 {
 	uint8_t i, j, k;
@@ -483,8 +483,10 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < dc_target->stream_count; i++) {
 		k = 0;
 		for (j = 0; j < MAX_PIPES; j++) {
-			struct core_surface *surface =
-					DC_SURFACE_TO_CORE(surfaces[k]);
+			struct core_surface *surface = NULL;
+
+			if (surface_count)
+				surface = DC_SURFACE_TO_CORE(surfaces[k]);
 
 			if (context->res_ctx.pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(dc_target->streams[i]))
@@ -498,6 +500,83 @@ bool resource_attach_surfaces_to_context(
 	return true;
 }
 
+static bool are_streams_same(
+	const struct core_stream *stream_a, const struct core_stream *stream_b)
+{
+	if (stream_a == stream_b)
+		return true;
+
+	if (stream_a == NULL || stream_b == NULL)
+		return false;
+
+	if (memcmp(stream_a, stream_b, sizeof(struct core_stream)) == 0)
+		return true;
+
+	return false;
+}
+
+static bool is_target_unchanged(
+	const struct core_target *old_target, const struct core_target *target)
+{
+	int i;
+
+	if (old_target == target)
+		return true;
+	if (old_target->public.stream_count != target->public.stream_count)
+		return false;
+
+	for (i = 0; i < old_target->public.stream_count; i++) {
+		const struct core_stream *old_stream = DC_STREAM_TO_CORE(
+				old_target->public.streams[i]);
+		const struct core_stream *stream = DC_STREAM_TO_CORE(
+				target->public.streams[i]);
+
+		if (!are_streams_same(old_stream, stream))
+			return false;
+	}
+
+	return true;
+}
+
+bool resource_validate_attach_surfaces(
+		const struct dc_validation_set set[],
+		uint8_t set_count,
+		const struct validate_context *old_context,
+		struct validate_context *context)
+{
+	uint8_t i, j;
+
+	for (i = 0; i < set_count; i++) {
+		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
+
+		for (j = 0; j < old_context->target_count; j++)
+			if (is_target_unchanged(
+					old_context->targets[j],
+					context->targets[i])) {
+				if (!resource_attach_surfaces_to_context(
+						(struct dc_surface **) old_context->
+							target_status[j].surfaces,
+						old_context->target_status[j].surface_count,
+						&context->targets[i]->public,
+						context))
+					return false;
+				context->target_status[i] = old_context->target_status[j];
+			}
+		if (set[i].surface_count != 0)
+			if (!resource_attach_surfaces_to_context(
+					(struct dc_surface **) set[i].surfaces,
+					set[i].surface_count,
+					&context->targets[i]->public,
+					context))
+				return false;
+
+	}
+
+	return true;
+}
+
 /* Maximum TMDS single link pixel clock 165MHz */
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
 
@@ -635,38 +714,108 @@ static void set_stream_signal(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
 }
 
+bool resource_is_stream_unchanged(
+	const struct validate_context *old_context, struct core_stream *stream)
+{
+	int i, j;
+
+	for (i = 0; i < old_context->target_count; i++) {
+		struct core_target *old_target = old_context->targets[i];
+
+		for (j = 0; j < old_target->public.stream_count; j++) {
+			struct core_stream *old_stream =
+				DC_STREAM_TO_CORE(old_target->public.streams[j]);
+
+			if (are_streams_same(old_stream, stream))
+				return true;
+		}
+	}
+
+	return false;
+}
+
+static void copy_pipe_ctx(
+	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
+{
+	struct core_surface *surface = to_pipe_ctx->surface;
+	struct core_stream *stream = to_pipe_ctx->stream;
+
+	*to_pipe_ctx = *from_pipe_ctx;
+	to_pipe_ctx->stream = stream;
+	if (surface != NULL)
+		to_pipe_ctx->surface = surface;
+}
+
+static struct core_stream *find_pll_stream_by_timing(
+		struct dc_crtc_timing *timing,
+		struct validate_context *context)
+{
+	uint8_t i, j;
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+
+			/* We are looking for non dp, non virtual stream that
+			 * matches the timing provided
+			 */
+			if (resource_is_same_timing(timing, &stream->public.timing)
+				&& !dc_is_dp_signal(stream->sink->public.sink_signal)
+				&& stream->sink->link->public.connector_signal
+							!= SIGNAL_TYPE_VIRTUAL)
+					return stream;
+		}
+	}
+
+	return NULL;
+}
+
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
 	uint8_t i, j, k;
 
-	/* mark resources used for targets that are already active */
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
 
-		if (!context->target_flags[i].unchanged)
-			continue;
-
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 
+			if (!resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
+			/* mark resources used for stream that is already active */
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
+				const struct pipe_ctx *old_pipe_ctx =
+					&dc->current_context.res_ctx.pipe_ctx[k];
 
-				if (dc->current_context.res_ctx.pipe_ctx[k].stream
-					!= stream)
+				if (!are_streams_same(old_pipe_ctx->stream, stream))
 					continue;
 
-				*pipe_ctx =
-					dc->current_context.res_ctx.pipe_ctx[k];
+				pipe_ctx->stream = stream;
+				copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
 
 				set_stream_engine_in_use(
 					&context->res_ctx,
 					pipe_ctx->stream_enc);
 
+				/* Switch to dp clock source only if there is
+				 * no non dp stream that shares the same timing
+				 * with the dp stream.
+				 */
+				if (dc_is_dp_signal(pipe_ctx->signal) &&
+					!find_pll_stream_by_timing(
+						&stream->public.timing, context))
+					pipe_ctx->clock_source =
+						context->res_ctx.pool.dp_clock_source;
+
 				resource_reference_clock_source(
 					&context->res_ctx,
 					pipe_ctx->clock_source);
@@ -677,20 +826,20 @@ enum dc_status resource_map_pool_resources(
 		}
 	}
 
-	/* acquire new resources */
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
 
-		if (context->target_flags[i].unchanged)
-			continue;
-
 		for (j = 0; j < target->public.stream_count; j++) {
-			struct pipe_ctx *pipe_ctx = NULL;
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
-			struct core_stream *curr_stream;
+			struct core_stream *curr_stream = NULL;
+			struct pipe_ctx *pipe_ctx = NULL;
+			int pipe_idx = -1;
 
-			int8_t pipe_idx = acquire_first_free_pipe(
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+			/* acquire new resources */
+			pipe_idx = acquire_first_free_pipe(
 						&context->res_ctx, stream);
 			if (pipe_idx < 0)
 				return DC_NO_CONTROLLER_RESOURCE;
@@ -1224,13 +1373,13 @@ enum dc_status resource_map_clock_resources(
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
 
-		if (context->target_flags[i].unchanged)
-			continue;
-
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 4a51513..90df1fb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -611,13 +611,14 @@ static enum dc_status validate_mapped_resource(
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
 
-		if (context->target_flags[i].unchanged)
-			continue;
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
@@ -674,44 +675,17 @@ enum dc_status dce100_validate_with_context(
 		uint8_t set_count,
 		struct validate_context *context)
 {
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	uint8_t i, j;
 	struct dc_context *dc_ctx = dc->ctx;
-
-	for (i = 0; i < set_count; i++) {
-		bool unchanged = false;
-
-		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
-
-		for (j = 0; j < dc->current_context.target_count; j++)
-			if (dc->current_context.targets[j]
-						== context->targets[i]) {
-				unchanged = true;
-				context->target_flags[i].unchanged = true;
-				resource_attach_surfaces_to_context(
-					(struct dc_surface **)dc->current_context.
-						target_status[j].surfaces,
-					dc->current_context.target_status[j].surface_count,
-					&context->targets[i]->public,
-					context);
-				context->target_status[i] =
-					dc->current_context.target_status[j];
-			}
-		if (!unchanged || set[i].surface_count != 0)
-			if (!resource_attach_surfaces_to_context(
-					(struct dc_surface **)set[i].surfaces,
-					set[i].surface_count,
-					&context->targets[i]->public,
-					context)) {
-				DC_ERROR("Failed to attach surface to target!\n");
-				return DC_FAIL_ATTACH_SURFACES;
-			}
-	}
+	enum dc_status result = DC_ERROR_UNEXPECTED;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	if (!resource_validate_attach_surfaces(
+			set, set_count, &dc->current_context, context)) {
+		DC_ERROR("Failed to attach surface to target!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
 	result = resource_map_pool_resources(dc, context);
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 903d020..b7d485b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -574,13 +574,15 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
-		if (context->target_flags[i].unchanged)
-			continue;
+
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
@@ -804,41 +806,17 @@ enum dc_status dce110_validate_with_context(
 		uint8_t set_count,
 		struct validate_context *context)
 {
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	uint8_t i, j;
 	struct dc_context *dc_ctx = dc->ctx;
-
-	for (i = 0; i < set_count; i++) {
-		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
-
-		for (j = 0; j < dc->current_context.target_count; j++)
-			if (dc->current_context.targets[j]
-						== context->targets[i]) {
-				context->target_flags[i].unchanged = true;
-				resource_attach_surfaces_to_context(
-					(struct dc_surface **)dc->current_context.
-						target_status[j].surfaces,
-					dc->current_context.target_status[j].surface_count,
-					&context->targets[i]->public,
-					context);
-				context->target_status[i] =
-					dc->current_context.target_status[j];
-			}
-		if (set[i].surface_count != 0)
-			if (!resource_attach_surfaces_to_context(
-					(struct dc_surface **)set[i].surfaces,
-					set[i].surface_count,
-					&context->targets[i]->public,
-					context)) {
-				DC_ERROR("Failed to attach surface to target!\n");
-				return DC_FAIL_ATTACH_SURFACES;
-			}
-	}
+	enum dc_status result = DC_ERROR_UNEXPECTED;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	if (!resource_validate_attach_surfaces(
+			set, set_count, &dc->current_context, context)) {
+		DC_ERROR("Failed to attach surface to target!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
 	result = resource_map_pool_resources(dc, context);
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index dd185af..f9441c1 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -654,13 +654,15 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
-		if (context->target_flags[i].unchanged)
-			continue;
+
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
@@ -875,13 +877,6 @@ enum dc_status dce112_validate_bandwidth(
 	return result;
 }
 
-static void set_target_unchanged(
-		struct validate_context *context,
-		uint8_t target_idx)
-{
-	context->target_flags[target_idx].unchanged = true;
-}
-
 static enum dc_status map_clock_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
@@ -892,13 +887,13 @@ static enum dc_status map_clock_resources(
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
 
-		if (context->target_flags[i].unchanged)
-			continue;
-
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
@@ -937,44 +932,17 @@ enum dc_status dce112_validate_with_context(
 		uint8_t set_count,
 		struct validate_context *context)
 {
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	uint8_t i, j;
 	struct dc_context *dc_ctx = dc->ctx;
-
-	for (i = 0; i < set_count; i++) {
-		bool unchanged = false;
-
-		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
-
-		for (j = 0; j < dc->current_context.target_count; j++)
-			if (dc->current_context.targets[j]
-						== context->targets[i]) {
-				unchanged = true;
-				set_target_unchanged(context, i);
-				resource_attach_surfaces_to_context(
-					(struct dc_surface **)dc->current_context.
-						target_status[j].surfaces,
-					dc->current_context.target_status[j].surface_count,
-					&context->targets[i]->public,
-					context);
-				context->target_status[i] =
-					dc->current_context.target_status[j];
-			}
-		if (!unchanged || set[i].surface_count != 0)
-			if (!resource_attach_surfaces_to_context(
-					(struct dc_surface **)set[i].surfaces,
-					set[i].surface_count,
-					&context->targets[i]->public,
-					context)) {
-				DC_ERROR("Failed to attach surface to target!\n");
-				return DC_FAIL_ATTACH_SURFACES;
-			}
-	}
+	enum dc_status result = DC_ERROR_UNEXPECTED;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	if (!resource_validate_attach_surfaces(
+			set, set_count, &dc->current_context, context)) {
+		DC_ERROR("Failed to attach surface to target!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
 	result = resource_map_pool_resources(dc, context);
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index c52739c..6a56f65 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -572,13 +572,15 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->target_count; i++) {
 		struct core_target *target = context->targets[i];
-		if (context->target_flags[i].unchanged)
-			continue;
+
 		for (j = 0; j < target->public.stream_count; j++) {
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
+			if (resource_is_stream_unchanged(&dc->current_context, stream))
+				continue;
+
 			for (k = 0; k < MAX_PIPES; k++) {
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
@@ -636,44 +638,17 @@ enum dc_status dce80_validate_with_context(
 		uint8_t set_count,
 		struct validate_context *context)
 {
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	uint8_t i, j;
 	struct dc_context *dc_ctx = dc->ctx;
-
-	for (i = 0; i < set_count; i++) {
-		bool unchanged = false;
-
-		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
-
-		for (j = 0; j < dc->current_context.target_count; j++)
-			if (dc->current_context.targets[j]
-						== context->targets[i]) {
-				unchanged = true;
-				context->target_flags[i].unchanged = true;
-				resource_attach_surfaces_to_context(
-					(struct dc_surface **)dc->current_context.
-						target_status[j].surfaces,
-					dc->current_context.target_status[j].surface_count,
-					&context->targets[i]->public,
-					context);
-				context->target_status[i] =
-					dc->current_context.target_status[j];
-			}
-		if (!unchanged || set[i].surface_count != 0)
-			if (!resource_attach_surfaces_to_context(
-					(struct dc_surface **)set[i].surfaces,
-					set[i].surface_count,
-					&context->targets[i]->public,
-					context)) {
-				DC_ERROR("Failed to attach surface to target!\n");
-				return DC_FAIL_ATTACH_SURFACES;
-			}
-	}
+	enum dc_status result = DC_ERROR_UNEXPECTED;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	if (!resource_validate_attach_surfaces(
+			set, set_count, &dc->current_context, context)) {
+		DC_ERROR("Failed to attach surface to target!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
 	result = resource_map_pool_resources(dc, context);
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 91041e8..c13c224 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -301,13 +301,9 @@ struct resource_context {
 	uint8_t dp_clock_source_ref_count;
 };
 
-struct target_flags {
-	bool unchanged;
-};
 struct validate_context {
 	struct core_target *targets[MAX_PIPES];
 	struct dc_target_status target_status[MAX_PIPES];
-	struct target_flags target_flags[MAX_PIPES];
 	uint8_t target_count;
 
 	struct resource_context res_ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index e66f73e..22133f0 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -79,7 +79,16 @@ struct clock_source *dc_resource_find_first_free_pll(
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *surfaces[],
 		uint8_t surface_count,
-		struct dc_target *dc_target,
+		const struct dc_target *dc_target,
+		struct validate_context *context);
+
+bool resource_is_stream_unchanged(
+	const struct validate_context *old_context, struct core_stream *stream);
+
+bool resource_validate_attach_surfaces(
+		const struct dc_validation_set set[],
+		uint8_t set_count,
+		const struct validate_context *old_context,
 		struct validate_context *context);
 
 void resource_validate_ctx_copy_construct(
-- 
2.7.4

