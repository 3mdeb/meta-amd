From 170c5b4c8cd7dbca7c656dbf334fc0147f64a005 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Sat, 22 Jul 2017 20:05:20 -0400
Subject: [PATCH 2734/2831] drm/amd/display: Roll core_link into dc_link

Change-Id: Ibbc981040f6ba6c4e8bf9cdb463e995958d6eba8
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h           |   2 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.c    |   4 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.h    |   2 +-
 drivers/gpu/drm/amd/display/dc/core/dc.c           | 100 ++++----
 drivers/gpu/drm/amd/display/dc/core/dc_link.c      | 229 +++++++++---------
 drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c  |   6 +-
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c   | 264 ++++++++++-----------
 drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c |  40 ++--
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  |   8 +-
 drivers/gpu/drm/amd/display/dc/core/dc_sink.c      |   9 +-
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |   4 +-
 drivers/gpu/drm/amd/display/dc/dc.h                | 112 ++++++---
 drivers/gpu/drm/amd/display/dc/dc_ddc_types.h      |   2 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c      |   4 +-
 .../gpu/drm/amd/display/dc/dce/dce_link_encoder.c  |   2 +-
 .../drm/amd/display/dc/dce100/dce100_resource.c    |   2 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    |  16 +-
 .../drm/amd/display/dc/dce110/dce110_resource.c    |   2 +-
 .../drm/amd/display/dc/dce112/dce112_resource.c    |   2 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |   2 +-
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  |   4 +-
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/core_dc.h       |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |  58 +----
 drivers/gpu/drm/amd/display/dc/inc/dc_link_ddc.h   |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h    |  16 +-
 drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h       |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/link_hwss.h     |  22 +-
 .../gpu/drm/amd/display/include/logger_interface.h |   8 +-
 29 files changed, 444 insertions(+), 484 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index 00b6471..2375c23 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
@@ -567,7 +567,7 @@ struct amdgpu_connector {
 	/* The 'old' sink - before an HPD.
 	 * The 'current' sink is in dc_link->sink. */
 	const struct dc_sink *dc_sink;
-	const struct dc_link *dc_link;
+	struct dc_link *dc_link;
 	const struct dc_sink *dc_em_sink;
 	const struct dc_stream *stream;
 	void *con_priv;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
index 73a1187..1f1077f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
@@ -2015,7 +2015,7 @@ void amdgpu_dm_connector_init_helper(
 	struct amdgpu_display_manager *dm,
 	struct amdgpu_connector *aconnector,
 	int connector_type,
-	const struct dc_link *link,
+	struct dc_link *link,
 	int link_index)
 {
 	struct amdgpu_device *adev = dm->ddev->dev_private;
@@ -2146,7 +2146,7 @@ int amdgpu_dm_connector_init(
 	int res = 0;
 	int connector_type;
 	struct dc *dc = dm->dc;
-	const struct dc_link *link = dc_get_link_at_index(dc, link_index);
+	struct dc_link *link = dc_get_link_at_index(dc, link_index);
 	struct amdgpu_i2c_adapter *i2c;
 	((struct dc_link *)link)->priv = aconnector;
 
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
index 115d908..c565787 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
@@ -114,7 +114,7 @@ void amdgpu_dm_connector_init_helper(
 	struct amdgpu_display_manager *dm,
 	struct amdgpu_connector *aconnector,
 	int connector_type,
-	const struct dc_link *link,
+	struct dc_link *link,
 	int link_index);
 
 int amdgpu_dm_connector_mode_valid(
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ec4c9c4..b62401a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -94,7 +94,7 @@ static bool create_links(
 
 	for (i = 0; i < connectors_num; i++) {
 		struct link_init_data link_init_params = {0};
-		struct core_link *link;
+		struct dc_link *link;
 
 		link_init_params.ctx = dc->ctx;
 		/* next BIOS object table connector */
@@ -111,7 +111,7 @@ static bool create_links(
 	}
 
 	for (i = 0; i < num_virtual_links; i++) {
-		struct core_link *link = dm_alloc(sizeof(*link));
+		struct dc_link *link = dm_alloc(sizeof(*link));
 		struct encoder_init_data enc_init = {0};
 
 		if (link == NULL) {
@@ -121,7 +121,7 @@ static bool create_links(
 
 		link->ctx = dc->ctx;
 		link->dc = dc;
-		link->public.connector_signal = SIGNAL_TYPE_VIRTUAL;
+		link->connector_signal = SIGNAL_TYPE_VIRTUAL;
 		link->link_id.type = OBJECT_TYPE_CONNECTOR;
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
@@ -137,7 +137,7 @@ static bool create_links(
 		enc_init.encoder.enum_id = ENUM_ID_1;
 		virtual_link_encoder_construct(link->link_enc, &enc_init);
 
-		link->public.link_index = dc->link_count;
+		link->link_index = dc->link_count;
 		dc->links[dc->link_count] = link;
 		dc->link_count++;
 	}
@@ -278,14 +278,14 @@ static void set_drive_settings(struct dc *dc,
 	int i;
 
 	for (i = 0; i < core_dc->link_count; i++) {
-		if (&core_dc->links[i]->public == link)
+		if (core_dc->links[i] == link)
 			break;
 	}
 
 	if (i >= core_dc->link_count)
 		ASSERT_CRITICAL(false);
 
-	dc_link_dp_set_drive_settings(&core_dc->links[i]->public, lt_settings);
+	dc_link_dp_set_drive_settings(core_dc->links[i], lt_settings);
 }
 
 static void perform_link_training(struct dc *dc,
@@ -297,20 +297,17 @@ static void perform_link_training(struct dc *dc,
 
 	for (i = 0; i < core_dc->link_count; i++)
 		dc_link_dp_perform_link_training(
-			&core_dc->links[i]->public,
+			core_dc->links[i],
 			link_setting,
 			skip_video_pattern);
 }
 
 static void set_preferred_link_settings(struct dc *dc,
 		struct dc_link_settings *link_setting,
-		const struct dc_link *link)
+		struct dc_link *link)
 {
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
-
-	core_link->public.preferred_link_setting =
-				*link_setting;
-	dp_retrain_link_dp_test(core_link, link_setting, false);
+	link->preferred_link_setting = *link_setting;
+	dp_retrain_link_dp_test(link, link_setting, false);
 }
 
 static void enable_hpd(const struct dc_link *link)
@@ -325,7 +322,7 @@ static void disable_hpd(const struct dc_link *link)
 
 
 static void set_test_pattern(
-		const struct dc_link *link,
+		struct dc_link *link,
 		enum dp_test_pattern test_pattern,
 		const struct link_training_settings *p_link_settings,
 		const unsigned char *p_custom_pattern,
@@ -345,9 +342,8 @@ void set_dither_option(const struct dc_stream *dc_stream,
 {
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct bit_depth_reduction_params params;
-	struct core_link *core_link = DC_LINK_TO_CORE(stream->status.link);
-	struct pipe_ctx *pipes =
-			core_link->dc->current_context->res_ctx.pipe_ctx;
+	struct dc_link *link = stream->status.link;
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
 
 	memset(&params, 0, sizeof(params));
 	if (!stream)
@@ -1693,10 +1689,10 @@ struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 	return NULL;
 }
 
-const struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
+struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return &core_dc->links[link_index]->public;
+	return core_dc->links[link_index];
 }
 
 const struct graphics_object_id dc_get_link_id_at_index(
@@ -1710,7 +1706,7 @@ enum dc_irq_source dc_get_hpd_irq_source_at_index(
 	struct dc *dc, uint32_t link_index)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return core_dc->links[link_index]->public.irq_source_hpd;
+	return core_dc->links[link_index]->irq_source_hpd;
 }
 
 const struct audio **dc_get_audios(struct dc *dc)
@@ -1828,9 +1824,9 @@ bool dc_read_aux_dpcd(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			false,
 			I2C_MOT_UNDEF,
 			address,
@@ -1847,10 +1843,10 @@ bool dc_write_aux_dpcd(
 		uint32_t size)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			false,
 			I2C_MOT_UNDEF,
 			address,
@@ -1869,9 +1865,9 @@ bool dc_read_aux_i2c(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-		struct core_link *link = core_dc->links[link_index];
+		struct dc_link *link = core_dc->links[link_index];
 		enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			true,
 			mot,
 			address,
@@ -1889,10 +1885,10 @@ bool dc_write_aux_i2c(
 		uint32_t size)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			true,
 			mot,
 			address,
@@ -1912,10 +1908,10 @@ bool dc_query_ddc_data(
 
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	bool result = dal_ddc_service_query_ddc_data(
-			link->public.ddc,
+			link->ddc,
 			address,
 			write_buf,
 			write_size,
@@ -1932,8 +1928,8 @@ bool dc_submit_i2c(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_link *link = core_dc->links[link_index];
-	struct ddc_service *ddc = link->public.ddc;
+	struct dc_link *link = core_dc->links[link_index];
+	struct ddc_service *ddc = link->ddc;
 
 	return dal_i2caux_submit_i2c_command(
 		ddc->ctx->i2caux,
@@ -1941,10 +1937,8 @@ bool dc_submit_i2c(
 		cmd);
 }
 
-static bool link_add_remote_sink_helper(struct core_link *core_link, struct dc_sink *sink)
+static bool link_add_remote_sink_helper(struct dc_link *dc_link, struct dc_sink *sink)
 {
-	struct dc_link *dc_link = &core_link->public;
-
 	if (dc_link->sink_count >= MAX_SINKS_PER_LINK) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -1959,14 +1953,13 @@ static bool link_add_remote_sink_helper(struct core_link *core_link, struct dc_s
 }
 
 struct dc_sink *dc_link_add_remote_sink(
-		const struct dc_link *link,
+		struct dc_link *link,
 		const uint8_t *edid,
 		int len,
 		struct dc_sink_init_data *init_data)
 {
 	struct dc_sink *dc_sink;
 	enum dc_edid_status edid_status;
-	struct core_link *core_link = DC_LINK_TO_LINK(link);
 
 	if (len > MAX_EDID_BUFFER_SIZE) {
 		dm_error("Max EDID buffer size breached!\n");
@@ -1992,12 +1985,12 @@ struct dc_sink *dc_link_add_remote_sink(
 	dc_sink->dc_edid.length = len;
 
 	if (!link_add_remote_sink_helper(
-			core_link,
+			link,
 			dc_sink))
 		goto fail_add_sink;
 
 	edid_status = dm_helpers_parse_edid_caps(
-			core_link->ctx,
+			link->ctx,
 			&dc_sink->dc_edid,
 			&dc_sink->edid_caps);
 
@@ -2012,43 +2005,38 @@ struct dc_sink *dc_link_add_remote_sink(
 	return NULL;
 }
 
-void dc_link_set_sink(const struct dc_link *link, struct dc_sink *sink)
+void dc_link_set_sink(struct dc_link *link, struct dc_sink *sink)
 {
-	struct core_link *core_link = DC_LINK_TO_LINK(link);
-	struct dc_link *dc_link = &core_link->public;
-
-	dc_link->local_sink = sink;
+	link->local_sink = sink;
 
 	if (sink == NULL) {
-		dc_link->type = dc_connection_none;
+		link->type = dc_connection_none;
 	} else {
-		dc_link->type = dc_connection_single;
+		link->type = dc_connection_single;
 	}
 }
 
-void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink *sink)
+void dc_link_remove_remote_sink(struct dc_link *link, const struct dc_sink *sink)
 {
 	int i;
-	struct core_link *core_link = DC_LINK_TO_LINK(link);
-	struct dc_link *dc_link = &core_link->public;
 
 	if (!link->sink_count) {
 		BREAK_TO_DEBUGGER();
 		return;
 	}
 
-	for (i = 0; i < dc_link->sink_count; i++) {
-		if (dc_link->remote_sinks[i] == sink) {
+	for (i = 0; i < link->sink_count; i++) {
+		if (link->remote_sinks[i] == sink) {
 			dc_sink_release(sink);
-			dc_link->remote_sinks[i] = NULL;
+			link->remote_sinks[i] = NULL;
 
 			/* shrink array to remove empty place */
-			while (i < dc_link->sink_count - 1) {
-				dc_link->remote_sinks[i] = dc_link->remote_sinks[i+1];
+			while (i < link->sink_count - 1) {
+				link->remote_sinks[i] = link->remote_sinks[i+1];
 				i++;
 			}
-			dc_link->remote_sinks[i] = NULL;
-			dc_link->sink_count--;
+			link->remote_sinks[i] = NULL;
+			link->sink_count--;
 			return;
 		}
 	}
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index 036d22f..428dbff 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -62,24 +62,24 @@ enum {
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static void destruct(struct core_link *link)
+static void destruct(struct dc_link *link)
 {
 	int i;
 
-	if (link->public.ddc)
-		dal_ddc_service_destroy(&link->public.ddc);
+	if (link->ddc)
+		dal_ddc_service_destroy(&link->ddc);
 
 	if(link->link_enc)
 		link->link_enc->funcs->destroy(&link->link_enc);
 
-	if (link->public.local_sink)
-		dc_sink_release(link->public.local_sink);
+	if (link->local_sink)
+		dc_sink_release(link->local_sink);
 
-	for (i = 0; i < link->public.sink_count; ++i)
-		dc_sink_release(link->public.remote_sinks[i]);
+	for (i = 0; i < link->sink_count; ++i)
+		dc_sink_release(link->remote_sinks[i]);
 }
 
-static struct gpio *get_hpd_gpio(const struct core_link *link)
+static struct gpio *get_hpd_gpio(const struct dc_link *link)
 {
 	enum bp_result bp_result;
 	struct dc_bios *dcb = link->ctx->dc_bios;
@@ -116,7 +116,7 @@ static struct gpio *get_hpd_gpio(const struct core_link *link)
  *     true on success, false otherwise
  */
 static bool program_hpd_filter(
-	const struct core_link *link)
+	const struct dc_link *link)
 {
 	bool result = false;
 
@@ -126,7 +126,7 @@ static bool program_hpd_filter(
 	int delay_on_disconnect_in_ms = 0;
 
 	/* Verify feature is supported */
-	switch (link->public.connector_signal) {
+	switch (link->connector_signal) {
 	case SIGNAL_TYPE_DVI_SINGLE_LINK:
 	case SIGNAL_TYPE_DVI_DUAL_LINK:
 	case SIGNAL_TYPE_HDMI_TYPE_A:
@@ -181,7 +181,7 @@ static bool program_hpd_filter(
 	return result;
 }
 
-static bool detect_sink(struct core_link *link, enum dc_connection_type *type)
+static bool detect_sink(struct dc_link *link, enum dc_connection_type *type)
 {
 	uint32_t is_hpd_high = 0;
 	struct gpio *hpd_pin;
@@ -306,7 +306,7 @@ static enum signal_type get_basic_signal_type(
  * @brief
  * Check whether there is a dongle on DP connector
  */
-static bool is_dp_sink_present(struct core_link *link)
+static bool is_dp_sink_present(struct dc_link *link)
 {
 	enum gpio_result gpio_result;
 	uint32_t clock_pin = 0;
@@ -320,7 +320,7 @@ static bool is_dp_sink_present(struct core_link *link)
 		((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||
 		(connector_id == CONNECTOR_ID_EDP));
 
-	ddc = dal_ddc_service_get_ddc_pin(link->public.ddc);
+	ddc = dal_ddc_service_get_ddc_pin(link->ddc);
 
 	if (!ddc) {
 		BREAK_TO_DEBUGGER();
@@ -356,7 +356,7 @@ static bool is_dp_sink_present(struct core_link *link)
  * @brief
  * Detect output sink type
  */
-static enum signal_type link_detect_sink(struct core_link *link)
+static enum signal_type link_detect_sink(struct dc_link *link)
 {
 	enum signal_type result = get_basic_signal_type(
 		link->link_enc->id, link->link_id);
@@ -446,18 +446,18 @@ static enum signal_type dp_passive_dongle_detection(
 			audio_support);
 }
 
-static void link_disconnect_sink(struct core_link *link)
+static void link_disconnect_sink(struct dc_link *link)
 {
-	if (link->public.local_sink) {
-		dc_sink_release(link->public.local_sink);
-		link->public.local_sink = NULL;
+	if (link->local_sink) {
+		dc_sink_release(link->local_sink);
+		link->local_sink = NULL;
 	}
 
 	link->dpcd_sink_count = 0;
 }
 
 static void detect_dp(
-	struct core_link *link,
+	struct dc_link *link,
 	struct display_sink_capability *sink_caps,
 	bool *converter_disable_audio,
 	struct audio_support *audio_support,
@@ -473,7 +473,7 @@ static void detect_dp(
 
 		/* DP active dongles */
 		if (is_dp_active_dongle(link)) {
-			link->public.type = dc_connection_active_dongle;
+			link->type = dc_connection_active_dongle;
 			if (!link->dpcd_caps.sink_count.bits.SINK_COUNT) {
 				/*
 				 * active dongle unplug processing for short irq
@@ -517,8 +517,8 @@ static void detect_dp(
 
 			if (dm_helpers_dp_mst_start_top_mgr(
 				link->ctx,
-				&link->public, boot)) {
-				link->public.type = dc_connection_mst_branch;
+				link, boot)) {
+				link->type = dc_connection_mst_branch;
 			} else {
 				/* MST not supported */
 				sink_caps->signal = SIGNAL_TYPE_DISPLAY_PORT;
@@ -526,15 +526,14 @@ static void detect_dp(
 		}
 	} else {
 		/* DP passive dongles */
-		sink_caps->signal = dp_passive_dongle_detection(link->public.ddc,
+		sink_caps->signal = dp_passive_dongle_detection(link->ddc,
 				sink_caps,
 				audio_support);
 	}
 }
 
-bool dc_link_detect(const struct dc_link *dc_link, bool boot)
+bool dc_link_detect(struct dc_link *link, bool boot)
 {
-	struct core_link *link = DC_LINK_TO_LINK(dc_link);
 	struct dc_sink_init_data sink_init_data = { 0 };
 	struct display_sink_capability sink_caps = { 0 };
 	uint8_t i;
@@ -546,7 +545,7 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 	struct core_sink *sink = NULL;
 	enum dc_connection_type new_connection_type = dc_connection_none;
 
-	if (link->public.connector_signal == SIGNAL_TYPE_VIRTUAL)
+	if (link->connector_signal == SIGNAL_TYPE_VIRTUAL)
 		return false;
 
 	if (false == detect_sink(link, &new_connection_type)) {
@@ -554,17 +553,17 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 		return false;
 	}
 
-	if (link->public.connector_signal == SIGNAL_TYPE_EDP &&
-			link->public.local_sink)
+	if (link->connector_signal == SIGNAL_TYPE_EDP &&
+			link->local_sink)
 		return true;
 
 	link_disconnect_sink(link);
 
 	if (new_connection_type != dc_connection_none) {
-		link->public.type = new_connection_type;
+		link->type = new_connection_type;
 
 		/* From Disconnected-to-Connected. */
-		switch (link->public.connector_signal) {
+		switch (link->connector_signal) {
 		case SIGNAL_TYPE_HDMI_TYPE_A: {
 			sink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;
 			if (aud_support->hdmi_audio_native)
@@ -602,14 +601,14 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 				aud_support, boot);
 
 			/* Active dongle downstream unplug */
-			if (link->public.type == dc_connection_active_dongle
+			if (link->type == dc_connection_active_dongle
 					&& link->dpcd_caps.sink_count.
 					bits.SINK_COUNT == 0)
 				return true;
 
-			if (link->public.type == dc_connection_mst_branch) {
+			if (link->type == dc_connection_mst_branch) {
 				LINK_INFO("link=%d, mst branch is now Connected\n",
-					link->public.link_index);
+					link->link_index);
 				return false;
 			}
 
@@ -618,7 +617,7 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 
 		default:
 			DC_ERROR("Invalid connector type! signal:%d\n",
-				link->public.connector_signal);
+				link->connector_signal);
 			return false;
 		} /* switch() */
 
@@ -629,13 +628,13 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 				link->dpcd_sink_count = 1;
 
 		dal_ddc_service_set_transaction_type(
-						link->public.ddc,
+						link->ddc,
 						sink_caps.transaction_type);
 
-		link->public.aux_mode = dal_ddc_service_is_in_aux_transaction_mode(
-				link->public.ddc);
+		link->aux_mode = dal_ddc_service_is_in_aux_transaction_mode(
+				link->ddc);
 
-		sink_init_data.link = &link->public;
+		sink_init_data.link = link;
 		sink_init_data.sink_signal = sink_caps.signal;
 
 		dc_sink = dc_sink_create(&sink_init_data);
@@ -648,11 +647,11 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 		dc_sink->converter_disable_audio = converter_disable_audio;
 
 		sink = DC_SINK_TO_CORE(dc_sink);
-		link->public.local_sink = &sink->public;
+		link->local_sink = &sink->public;
 
 		edid_status = dm_helpers_read_local_edid(
 				link->ctx,
-				&link->public,
+				link,
 				&sink->public);
 
 		switch (edid_status) {
@@ -719,21 +718,21 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 
 	} else {
 		/* From Connected-to-Disconnected. */
-		if (link->public.type == dc_connection_mst_branch) {
+		if (link->type == dc_connection_mst_branch) {
 			LINK_INFO("link=%d, mst branch is now Disconnected\n",
-				link->public.link_index);
-			dm_helpers_dp_mst_stop_top_mgr(link->ctx, &link->public);
+				link->link_index);
+			dm_helpers_dp_mst_stop_top_mgr(link->ctx, link);
 
 			link->mst_stream_alloc_table.stream_count = 0;
 			memset(link->mst_stream_alloc_table.stream_allocations, 0, sizeof(link->mst_stream_alloc_table.stream_allocations));
 		}
 
-		link->public.type = dc_connection_none;
+		link->type = dc_connection_none;
 		sink_caps.signal = SIGNAL_TYPE_NONE;
 	}
 
 	LINK_INFO("link=%d, dc_sink_in=%p is now %s\n",
-		link->public.link_index, &sink->public,
+		link->link_index, &sink->public,
 		(sink_caps.signal == SIGNAL_TYPE_NONE ?
 			"Disconnected":"Connected"));
 
@@ -741,7 +740,7 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot)
 }
 
 static enum hpd_source_id get_hpd_line(
-		struct core_link *link)
+		struct dc_link *link)
 {
 	struct gpio *hpd;
 	enum hpd_source_id hpd_id = HPD_SOURCEID_UNKNOWN;
@@ -779,12 +778,12 @@ static enum hpd_source_id get_hpd_line(
 	return hpd_id;
 }
 
-static enum channel_id get_ddc_line(struct core_link *link)
+static enum channel_id get_ddc_line(struct dc_link *link)
 {
 	struct ddc *ddc;
 	enum channel_id channel = CHANNEL_ID_UNKNOWN;
 
-	ddc = dal_ddc_service_get_ddc_pin(link->public.ddc);
+	ddc = dal_ddc_service_get_ddc_pin(link->ddc);
 
 	if (ddc) {
 		switch (dal_ddc_get_line(ddc)) {
@@ -887,7 +886,7 @@ static enum transmitter translate_encoder_to_transmitter(
 }
 
 static bool construct(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct link_init_data *init_params)
 {
 	uint8_t i;
@@ -899,14 +898,14 @@ static bool construct(
 	struct dc_bios *bios = init_params->dc->ctx->dc_bios;
 	const struct dc_vbios_funcs *bp_funcs = bios->funcs;
 
-	link->public.irq_source_hpd = DC_IRQ_SOURCE_INVALID;
-	link->public.irq_source_hpd_rx = DC_IRQ_SOURCE_INVALID;
+	link->irq_source_hpd = DC_IRQ_SOURCE_INVALID;
+	link->irq_source_hpd_rx = DC_IRQ_SOURCE_INVALID;
 
 	link->link_status.dpcd_caps = &link->dpcd_caps;
 
 	link->dc = init_params->dc;
 	link->ctx = dc_ctx;
-	link->public.link_index = init_params->link_index;
+	link->link_index = init_params->link_index;
 
 	link->link_id = bios->funcs->get_connector_id(bios, init_params->connector_index);
 
@@ -919,35 +918,35 @@ static bool construct(
 	hpd_gpio = get_hpd_gpio(link);
 
 	if (hpd_gpio != NULL)
-		link->public.irq_source_hpd = dal_irq_get_source(hpd_gpio);
+		link->irq_source_hpd = dal_irq_get_source(hpd_gpio);
 
 	switch (link->link_id.id) {
 	case CONNECTOR_ID_HDMI_TYPE_A:
-		link->public.connector_signal = SIGNAL_TYPE_HDMI_TYPE_A;
+		link->connector_signal = SIGNAL_TYPE_HDMI_TYPE_A;
 
 		break;
 	case CONNECTOR_ID_SINGLE_LINK_DVID:
 	case CONNECTOR_ID_SINGLE_LINK_DVII:
-		link->public.connector_signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
+		link->connector_signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
 		break;
 	case CONNECTOR_ID_DUAL_LINK_DVID:
 	case CONNECTOR_ID_DUAL_LINK_DVII:
-		link->public.connector_signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+		link->connector_signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		break;
 	case CONNECTOR_ID_DISPLAY_PORT:
-		link->public.connector_signal =	SIGNAL_TYPE_DISPLAY_PORT;
+		link->connector_signal =	SIGNAL_TYPE_DISPLAY_PORT;
 
 		if (hpd_gpio != NULL)
-			link->public.irq_source_hpd_rx =
+			link->irq_source_hpd_rx =
 					dal_irq_get_rx_source(hpd_gpio);
 
 		break;
 	case CONNECTOR_ID_EDP:
-		link->public.connector_signal = SIGNAL_TYPE_EDP;
+		link->connector_signal = SIGNAL_TYPE_EDP;
 
 		if (hpd_gpio != NULL) {
-			link->public.irq_source_hpd = DC_IRQ_SOURCE_INVALID;
-			link->public.irq_source_hpd_rx =
+			link->irq_source_hpd = DC_IRQ_SOURCE_INVALID;
+			link->irq_source_hpd_rx =
 					dal_irq_get_rx_source(hpd_gpio);
 		}
 		break;
@@ -966,21 +965,21 @@ static bool construct(
 	LINK_INFO("Connector[%d] description:"
 			"signal %d\n",
 			init_params->connector_index,
-			link->public.connector_signal);
+			link->connector_signal);
 
 	ddc_service_init_data.ctx = link->ctx;
 	ddc_service_init_data.id = link->link_id;
 	ddc_service_init_data.link = link;
-	link->public.ddc = dal_ddc_service_create(&ddc_service_init_data);
+	link->ddc = dal_ddc_service_create(&ddc_service_init_data);
 
-	if (link->public.ddc == NULL) {
+	if (link->ddc == NULL) {
 		DC_ERROR("Failed to create ddc_service!\n");
 		goto ddc_create_fail;
 	}
 
-	link->public.ddc_hw_inst =
+	link->ddc_hw_inst =
 		dal_ddc_get_line(
-			dal_ddc_service_get_ddc_pin(link->public.ddc));
+			dal_ddc_service_get_ddc_pin(link->ddc));
 
 	enc_init_data.ctx = dc_ctx;
 	bp_funcs->get_src_obj(dc_ctx->dc_bios, link->link_id, 0, &enc_init_data.encoder);
@@ -988,7 +987,7 @@ static bool construct(
 	enc_init_data.channel = get_ddc_line(link);
 	enc_init_data.hpd_source = get_hpd_line(link);
 
-	link->public.hpd_src = enc_init_data.hpd_source;
+	link->hpd_src = enc_init_data.hpd_source;
 
 	enc_init_data.transmitter =
 			translate_encoder_to_transmitter(enc_init_data.encoder);
@@ -1000,7 +999,7 @@ static bool construct(
 		goto link_enc_create_fail;
 	}
 
-	link->public.link_enc_hw_inst = link->link_enc->transmitter;
+	link->link_enc_hw_inst = link->link_enc->transmitter;
 
 	for (i = 0; i < 4; i++) {
 		if (BP_RESULT_OK !=
@@ -1015,10 +1014,10 @@ static bool construct(
 		if (!bp_funcs->is_device_id_supported(dc_ctx->dc_bios, link->device_tag.dev_id))
 			continue;
 		if (link->device_tag.dev_id.device_type == DEVICE_TYPE_CRT
-			&& link->public.connector_signal != SIGNAL_TYPE_RGB)
+			&& link->connector_signal != SIGNAL_TYPE_RGB)
 			continue;
 		if (link->device_tag.dev_id.device_type == DEVICE_TYPE_LCD
-			&& link->public.connector_signal == SIGNAL_TYPE_RGB)
+			&& link->connector_signal == SIGNAL_TYPE_RGB)
 			continue;
 		break;
 	}
@@ -1052,7 +1051,7 @@ static bool construct(
 device_tag_fail:
 	link->link_enc->funcs->destroy(&link->link_enc);
 link_enc_create_fail:
-	dal_ddc_service_destroy(&link->public.ddc);
+	dal_ddc_service_destroy(&link->ddc);
 ddc_create_fail:
 create_fail:
 
@@ -1066,9 +1065,9 @@ static bool construct(
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-struct core_link *link_create(const struct link_init_data *init_params)
+struct dc_link *link_create(const struct link_init_data *init_params)
 {
-	struct core_link *link =
+	struct dc_link *link =
 			dm_alloc(sizeof(*link));
 
 	if (NULL == link)
@@ -1086,7 +1085,7 @@ struct core_link *link_create(const struct link_init_data *init_params)
 	return NULL;
 }
 
-void link_destroy(struct core_link **link)
+void link_destroy(struct dc_link **link)
 {
 	destruct(*link);
 	dm_free(*link);
@@ -1094,7 +1093,7 @@ void link_destroy(struct core_link **link)
 }
 
 static void dpcd_configure_panel_mode(
-	struct core_link *link,
+	struct dc_link *link,
 	enum dp_panel_mode panel_mode)
 {
 	union dpcd_edp_config edp_config_set;
@@ -1139,7 +1138,7 @@ static void dpcd_configure_panel_mode(
 	dm_logger_write(link->ctx->logger, LOG_DETECTION_DP_CAPS,
 			"Link: %d eDP panel mode supported: %d "
 			"eDP panel mode enabled: %d \n",
-			link->public.link_index,
+			link->link_index,
 			link->dpcd_caps.panel_mode_edp,
 			panel_mode_edp);
 }
@@ -1147,7 +1146,7 @@ static void dpcd_configure_panel_mode(
 static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	union down_spread_ctrl downspread;
 
 	core_link_read_dpcd(link, DP_DOWNSPREAD_CTRL,
@@ -1165,7 +1164,7 @@ static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 	struct core_stream *stream = pipe_ctx->stream;
 	enum dc_status status;
 	bool skip_video_pattern;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	struct dc_link_settings link_settings = {0};
 	enum dp_panel_mode panel_mode;
 	enum dc_link_rate max_link_rate = LINK_RATE_HIGH2;
@@ -1224,7 +1223,7 @@ static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 			&link_settings,
 			skip_video_pattern,
 			LINK_TRAINING_ATTEMPTS)) {
-		link->public.cur_link_settings = link_settings;
+		link->cur_link_settings = link_settings;
 		status = DC_OK;
 	}
 	else
@@ -1237,12 +1236,12 @@ static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 
 static enum dc_status enable_link_dp_mst(struct pipe_ctx *pipe_ctx)
 {
-	struct core_link *link = pipe_ctx->stream->sink->link;
+	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* sink signal type after MST branch is MST. Multiple MST sinks
 	 * share one link. Link DP PHY is enable or training only once.
 	 */
-	if (link->public.cur_link_settings.lane_count != LANE_COUNT_UNKNOWN)
+	if (link->cur_link_settings.lane_count != LANE_COUNT_UNKNOWN)
 		return DC_OK;
 
 	/* set the sink to MST mode before enabling the link */
@@ -1254,16 +1253,16 @@ static enum dc_status enable_link_dp_mst(struct pipe_ctx *pipe_ctx)
 static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	enum dc_color_depth display_color_depth;
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
 		dal_ddc_service_write_scdc_data(
-			stream->sink->link->public.ddc,
+			stream->sink->link->ddc,
 			stream->phy_pix_clk,
 			stream->public.timing.flags.LTE_340MCSC_SCRAMBLE);
 
-	memset(&stream->sink->link->public.cur_link_settings, 0,
+	memset(&stream->sink->link->cur_link_settings, 0,
 			sizeof(struct dc_link_settings));
 
 	display_color_depth = stream->public.timing.display_color_depth;
@@ -1279,7 +1278,7 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 			stream->phy_pix_clk);
 
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_HDMI_TYPE_A)
-		dal_ddc_service_read_scdc_data(link->public.ddc);
+		dal_ddc_service_read_scdc_data(link->ddc);
 }
 
 /****************************enable_link***********************************/
@@ -1321,7 +1320,7 @@ static enum dc_status enable_link(struct pipe_ctx *pipe_ctx)
 	return status;
 }
 
-static void disable_link(struct core_link *link, enum signal_type signal)
+static void disable_link(struct dc_link *link, enum signal_type signal)
 {
 	/*
 	 * TODO: implement call for dp_set_hw_test_pattern
@@ -1345,7 +1344,7 @@ static void disable_link(struct core_link *link, enum signal_type signal)
 
 enum dc_status dc_link_validate_mode_timing(
 		const struct core_stream *stream,
-		struct core_link *link,
+		struct dc_link *link,
 		const struct dc_crtc_timing *timing)
 {
 	uint32_t max_pix_clk = stream->sink->public.dongle_max_pix_clk;
@@ -1353,7 +1352,7 @@ enum dc_status dc_link_validate_mode_timing(
 	/* A hack to avoid failing any modes for EDID override feature on
 	 * topology change such as lower quality cable for DP or different dongle
 	 */
-	if (link->public.remote_sinks[0])
+	if (link->remote_sinks[0])
 		return DC_OK;
 
 	if (0 != max_pix_clk && timing->pix_clk_khz > max_pix_clk)
@@ -1376,10 +1375,9 @@ enum dc_status dc_link_validate_mode_timing(
 }
 
 
-bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
+bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
 		uint32_t frame_ramp, const struct dc_stream *stream)
 {
-	struct core_link *link = DC_LINK_TO_CORE(dc_link);
 	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct core_stream *core_stream = NULL;
 	struct abm *abm = core_dc->res_pool->abm;
@@ -1392,7 +1390,7 @@ bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
 	dm_logger_write(link->ctx->logger, LOG_BACKLIGHT,
 			"New Backlight level: %d (0x%X)\n", level, level);
 
-	if (dc_is_embedded_signal(dc_link->connector_signal)) {
+	if (dc_is_embedded_signal(link->connector_signal)) {
 		if (stream != NULL) {
 			core_stream = DC_STREAM_TO_CORE(stream);
 			for (i = 0; i < MAX_PIPES; i++) {
@@ -1419,9 +1417,8 @@ bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
 }
 
 
-bool dc_link_set_abm_disable(const struct dc_link *dc_link)
+bool dc_link_set_abm_disable(const struct dc_link *link)
 {
-	struct core_link *link = DC_LINK_TO_CORE(dc_link);
 	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct abm *abm = core_dc->res_pool->abm;
 
@@ -1434,11 +1431,9 @@ bool dc_link_set_abm_disable(const struct dc_link *dc_link)
 }
 
 
-bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable)
+bool dc_link_set_psr_enable(const struct dc_link *link, bool enable)
 {
-	struct core_link *link = DC_LINK_TO_CORE(dc_link);
-	struct dc_context *ctx = link->ctx;
-	struct core_dc *core_dc = DC_TO_CORE(ctx->dc);
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 
 	if (dmcu != NULL && link->psr_enabled)
@@ -1447,11 +1442,9 @@ bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable)
 	return true;
 }
 
-bool dc_link_get_psr_state(const struct dc_link *dc_link, uint32_t *psr_state)
+bool dc_link_get_psr_state(const struct dc_link *link, uint32_t *psr_state)
 {
-	struct core_link *link = DC_LINK_TO_CORE(dc_link);
-	struct dc_context *ctx = link->ctx;
-	struct core_dc *core_dc = DC_TO_CORE(ctx->dc);
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 
 	if (dmcu != NULL && link->psr_enabled)
@@ -1460,20 +1453,18 @@ bool dc_link_get_psr_state(const struct dc_link *dc_link, uint32_t *psr_state)
 	return true;
 }
 
-bool dc_link_setup_psr(const struct dc_link *dc_link,
+bool dc_link_setup_psr(struct dc_link *link,
 		const struct dc_stream *stream, struct psr_config *psr_config,
 		struct psr_context *psr_context)
 {
-	struct core_link *link = DC_LINK_TO_CORE(dc_link);
-	struct dc_context *ctx = link->ctx;
-	struct core_dc *core_dc = DC_TO_CORE(ctx->dc);
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i;
 
 	psr_context->controllerId = CONTROLLER_ID_UNDEFINED;
 
-	if (dc_link != NULL &&
+	if (link != NULL &&
 		dmcu != NULL) {
 		/* updateSinkPsrDpcdConfig*/
 		union dpcd_psr_configuration psr_configuration;
@@ -1501,12 +1492,12 @@ bool dc_link_setup_psr(const struct dc_link *dc_link,
 
 		dm_helpers_dp_write_dpcd(
 			link->ctx,
-			dc_link,
+			link,
 			368,
 			&psr_configuration.raw,
 			sizeof(psr_configuration.raw));
 
-		psr_context->channel = link->public.ddc->ddc_pin->hw_info.ddc_channel;
+		psr_context->channel = link->ddc->ddc_pin->hw_info.ddc_channel;
 		psr_context->transmitterId = link->link_enc->transmitter;
 		psr_context->engineId = link->link_enc->preferred_engine;
 
@@ -1584,23 +1575,21 @@ bool dc_link_setup_psr(const struct dc_link *dc_link,
 
 }
 
-const struct dc_link_status *dc_link_get_status(const struct dc_link *dc_link)
+const struct dc_link_status *dc_link_get_status(const struct dc_link *link)
 {
-	struct core_link *link = DC_LINK_TO_CORE(dc_link);
-
 	return &link->link_status;
 }
 
-void core_link_resume(struct core_link *link)
+void core_link_resume(struct dc_link *link)
 {
-	if (link->public.connector_signal != SIGNAL_TYPE_VIRTUAL)
+	if (link->connector_signal != SIGNAL_TYPE_VIRTUAL)
 		program_hpd_filter(link);
 }
 
 static struct fixed31_32 get_pbn_per_slot(struct core_stream *stream)
 {
 	struct dc_link_settings *link_settings =
-			&stream->sink->link->public.cur_link_settings;
+			&stream->sink->link->cur_link_settings;
 	uint32_t link_rate_in_mbps =
 			link_settings->link_rate * LINK_RATE_REF_FREQ_IN_MHZ;
 	struct fixed31_32 mbps = dal_fixed31_32_from_int(
@@ -1653,7 +1642,7 @@ static struct fixed31_32 get_pbn_from_timing(struct pipe_ctx *pipe_ctx)
 }
 
 static void update_mst_stream_alloc_table(
-	struct core_link *link,
+	struct dc_link *link,
 	struct stream_encoder *stream_enc,
 	const struct dp_mst_stream_allocation_table *proposed_table)
 {
@@ -1668,7 +1657,7 @@ static void update_mst_stream_alloc_table(
 	ASSERT(proposed_table->stream_count -
 			link->mst_stream_alloc_table.stream_count < 2);
 
-	/* copy proposed_table to core_link, add stream encoder */
+	/* copy proposed_table to link, add stream encoder */
 	for (i = 0; i < proposed_table->stream_count; i++) {
 
 		for (j = 0; j < link->mst_stream_alloc_table.stream_count; j++) {
@@ -1707,7 +1696,7 @@ static void update_mst_stream_alloc_table(
 static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	struct link_encoder *link_encoder = link->link_enc;
 	struct stream_encoder *stream_encoder = pipe_ctx->stream_enc;
 	struct dp_mst_stream_allocation_table proposed_table = {0};
@@ -1789,13 +1778,13 @@ static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	struct link_encoder *link_encoder = link->link_enc;
 	struct stream_encoder *stream_encoder = pipe_ctx->stream_enc;
 	struct dp_mst_stream_allocation_table proposed_table = {0};
 	struct fixed31_32 avg_time_slots_per_mtp = dal_fixed31_32_from_int(0);
 	uint8_t i;
-	bool mst_mode = (link->public.type == dc_connection_mst_branch);
+	bool mst_mode = (link->type == dc_connection_mst_branch);
 
 	/* deallocate_mst_payload is called before disable link. When mode or
 	 * disable/enable monitor, new stream is created which is not in link
@@ -1875,7 +1864,7 @@ void core_link_enable_stream(struct pipe_ctx *pipe_ctx)
 	if (status != DC_OK) {
 			dm_logger_write(pipe_ctx->stream->ctx->logger,
 			LOG_WARNING, "enabling link %u failed: %d\n",
-			pipe_ctx->stream->sink->link->public.link_index,
+			pipe_ctx->stream->sink->link->link_index,
 			status);
 
 			/* Abort stream enable *unless* the failure was due to
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c
index 2f5a89c..d09e539 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_ddc.c
@@ -354,7 +354,7 @@ static uint32_t defer_delay_converter_wa(
 	struct ddc_service *ddc,
 	uint32_t defer_delay)
 {
-	struct core_link *link = ddc->link;
+	struct dc_link *link = ddc->link;
 
 	if (link->dpcd_caps.branch_dev_id == DP_BRANCH_DEVICE_ID_4 &&
 		!memcmp(link->dpcd_caps.branch_dev_name,
@@ -423,7 +423,7 @@ static bool i2c_read(
 
 	return dm_helpers_submit_i2c(
 			ddc->ctx,
-			&ddc->link->public,
+			ddc->link,
 			&command);
 }
 
@@ -624,7 +624,7 @@ bool dal_ddc_service_query_ddc_data(
 
 		ret = dm_helpers_submit_i2c(
 				ddc->ctx,
-				&ddc->link->public,
+				ddc->link,
 				&command);
 
 		dal_ddc_i2c_payloads_destroy(&payloads);
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index e90b3eb..c7b4007 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -34,7 +34,7 @@ enum {
 };
 
 static void wait_for_training_aux_rd_interval(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t default_wait_in_micro_secs)
 {
 	union training_aux_rd_interval training_rd_interval;
@@ -63,7 +63,7 @@ static void wait_for_training_aux_rd_interval(
 }
 
 static void dpcd_set_training_pattern(
-	struct core_link* link,
+	struct dc_link *link,
 	union dpcd_training_pattern dpcd_pattern)
 {
 	core_link_write_dpcd(
@@ -80,7 +80,7 @@ static void dpcd_set_training_pattern(
 }
 
 static void dpcd_set_link_settings(
-	struct core_link* link,
+	struct dc_link *link,
 	const struct link_training_settings *lt_settings)
 {
 	uint8_t rate = (uint8_t)
@@ -123,7 +123,7 @@ static void dpcd_set_link_settings(
 
 static enum dpcd_training_patterns
 	hw_training_pattern_to_dpcd_training_pattern(
-	struct core_link* link,
+	struct dc_link *link,
 	enum hw_dp_training_pattern pattern)
 {
 	enum dpcd_training_patterns dpcd_tr_pattern =
@@ -155,7 +155,7 @@ static enum dpcd_training_patterns
 }
 
 static void dpcd_set_lt_pattern_and_lane_settings(
-	struct core_link* link,
+	struct dc_link *link,
 	const struct link_training_settings *lt_settings,
 	enum hw_dp_training_pattern pattern)
 {
@@ -246,7 +246,7 @@ static void dpcd_set_lt_pattern_and_lane_settings(
 				dpcd_lt_buffer,
 				size_in_bytes + sizeof(dpcd_pattern.raw) );
 
-	link->public.cur_lane_setting = lt_settings->lane_settings[0];
+	link->cur_lane_setting = lt_settings->lane_settings[0];
 }
 
 static bool is_cr_done(enum dc_lane_count ln_count,
@@ -419,7 +419,7 @@ static void find_max_drive_settings(
 }
 
 static void get_lane_status_and_drive_settings(
-	struct core_link* link,
+	struct dc_link *link,
 	const struct link_training_settings *link_training_setting,
 	union lane_status *ln_status,
 	union lane_align_status_updated *ln_status_updated,
@@ -500,7 +500,7 @@ static void get_lane_status_and_drive_settings(
 }
 
 static void dpcd_set_lane_settings(
-	struct core_link* link,
+	struct dc_link *link,
 	const struct link_training_settings *link_training_setting)
 {
 	union dpcd_training_lane dpcd_lane[LANE_COUNT_DP_MAX] = {{{0}}};
@@ -560,7 +560,7 @@ static void dpcd_set_lane_settings(
 		dpcd_lane[0].bits.MAX_SWING_REACHED,
 		dpcd_lane[0].bits.MAX_PRE_EMPHASIS_REACHED);
 
-	link->public.cur_lane_setting = link_training_setting->lane_settings[0];
+	link->cur_lane_setting = link_training_setting->lane_settings[0];
 
 }
 
@@ -580,19 +580,18 @@ static bool is_max_vs_reached(
 }
 
 void dc_link_dp_set_drive_settings(
-	const struct dc_link *link,
+	struct dc_link *link,
 	struct link_training_settings *lt_settings)
 {
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
 	/* program ASIC PHY settings*/
-	dp_set_hw_lane_settings(core_link, lt_settings);
+	dp_set_hw_lane_settings(link, lt_settings);
 
 	/* Notify DP sink the PHY settings from source */
-	dpcd_set_lane_settings(core_link, lt_settings);
+	dpcd_set_lane_settings(link, lt_settings);
 }
 
 static bool perform_post_lt_adj_req_sequence(
-	struct core_link *link,
+	struct dc_link *link,
 	struct link_training_settings *lt_settings)
 {
 	enum dc_lane_count lane_count =
@@ -656,7 +655,7 @@ static bool perform_post_lt_adj_req_sequence(
 				update_drive_settings(
 					lt_settings,req_settings);
 
-				dc_link_dp_set_drive_settings(&link->public,
+				dc_link_dp_set_drive_settings(link,
 						lt_settings);
 				break;
 			}
@@ -682,7 +681,7 @@ static bool perform_post_lt_adj_req_sequence(
 
 }
 
-static enum hw_dp_training_pattern get_supported_tp(struct core_link *link)
+static enum hw_dp_training_pattern get_supported_tp(struct dc_link *link)
 {
 	enum hw_dp_training_pattern highest_tp = HW_DP_TRAINING_PATTERN_2;
 	struct encoder_feature_support *features = &link->link_enc->features;
@@ -706,7 +705,7 @@ static enum hw_dp_training_pattern get_supported_tp(struct core_link *link)
 }
 
 static enum link_training_result perform_channel_equalization_sequence(
-	struct core_link *link,
+	struct dc_link *link,
 	struct link_training_settings *lt_settings)
 {
 	struct link_training_settings req_settings;
@@ -768,7 +767,7 @@ static enum link_training_result perform_channel_equalization_sequence(
 }
 
 static bool perform_clock_recovery_sequence(
-	struct core_link *link,
+	struct dc_link *link,
 	struct link_training_settings *lt_settings)
 {
 	uint32_t retries_cr;
@@ -877,7 +876,7 @@ static bool perform_clock_recovery_sequence(
 }
 
 static inline bool perform_link_training_int(
-	struct core_link *link,
+	struct dc_link *link,
 	struct link_training_settings *lt_settings,
 	bool status)
 {
@@ -923,7 +922,6 @@ enum link_training_result dc_link_dp_perform_link_training(
 	bool skip_video_pattern)
 {
 	enum link_training_result status = LINK_TRAINING_SUCCESS;
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
 
 	char *link_rate = "Unknown";
 	struct link_training_settings lt_settings;
@@ -945,19 +943,19 @@ enum link_training_result dc_link_dp_perform_link_training(
 	lt_settings.link_settings.link_spread = LINK_SPREAD_05_DOWNSPREAD_30KHZ;
 
 	/* 1. set link rate, lane count and spread*/
-	dpcd_set_link_settings(core_link, &lt_settings);
+	dpcd_set_link_settings(link, &lt_settings);
 
 	/* 2. perform link training (set link training done
 	 *  to false is done as well)*/
-	if (!perform_clock_recovery_sequence(core_link, &lt_settings)) {
+	if (!perform_clock_recovery_sequence(link, &lt_settings)) {
 		status = LINK_TRAINING_CR_FAIL;
 	} else {
-		status = perform_channel_equalization_sequence(core_link,
+		status = perform_channel_equalization_sequence(link,
 				&lt_settings);
 	}
 
 	if ((status == LINK_TRAINING_SUCCESS) || !skip_video_pattern) {
-		if (!perform_link_training_int(core_link,
+		if (!perform_link_training_int(link,
 				&lt_settings,
 				status == LINK_TRAINING_SUCCESS)) {
 			/* the next link training setting in this case
@@ -990,7 +988,7 @@ enum link_training_result dc_link_dp_perform_link_training(
 	}
 
 	/* Connectivity log: link training */
-	CONN_MSG_LT(core_link, "%sx%d %s VS=%d, PE=%d",
+	CONN_MSG_LT(link, "%sx%d %s VS=%d, PE=%d",
 			link_rate,
 			lt_settings.link_settings.lane_count,
 			(status ==  LINK_TRAINING_SUCCESS) ? "pass" :
@@ -1004,7 +1002,7 @@ enum link_training_result dc_link_dp_perform_link_training(
 
 
 bool perform_link_training_with_retries(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct dc_link_settings *link_setting,
 	bool skip_video_pattern,
 	int attempts)
@@ -1015,7 +1013,7 @@ bool perform_link_training_with_retries(
 	for (j = 0; j < attempts; ++j) {
 
 		if (dc_link_dp_perform_link_training(
-				&link->public,
+				link,
 				link_setting,
 				skip_video_pattern) == LINK_TRAINING_SUCCESS)
 			return true;
@@ -1027,7 +1025,7 @@ bool perform_link_training_with_retries(
 	return false;
 }
 
-static struct dc_link_settings get_max_link_cap(struct core_link *link)
+static struct dc_link_settings get_max_link_cap(struct dc_link *link)
 {
 	/* Set Default link settings */
 	struct dc_link_settings max_link_cap = {LANE_COUNT_FOUR, LINK_RATE_HIGH,
@@ -1041,21 +1039,21 @@ static struct dc_link_settings get_max_link_cap(struct core_link *link)
 		max_link_cap.link_rate = LINK_RATE_HIGH3;
 
 	/* Lower link settings based on sink's link cap */
-	if (link->public.reported_link_cap.lane_count < max_link_cap.lane_count)
+	if (link->reported_link_cap.lane_count < max_link_cap.lane_count)
 		max_link_cap.lane_count =
-				link->public.reported_link_cap.lane_count;
-	if (link->public.reported_link_cap.link_rate < max_link_cap.link_rate)
+				link->reported_link_cap.lane_count;
+	if (link->reported_link_cap.link_rate < max_link_cap.link_rate)
 		max_link_cap.link_rate =
-				link->public.reported_link_cap.link_rate;
-	if (link->public.reported_link_cap.link_spread <
+				link->reported_link_cap.link_rate;
+	if (link->reported_link_cap.link_spread <
 			max_link_cap.link_spread)
 		max_link_cap.link_spread =
-				link->public.reported_link_cap.link_spread;
+				link->reported_link_cap.link_spread;
 	return max_link_cap;
 }
 
 bool dp_hbr_verify_link_cap(
-	struct core_link *link,
+	struct dc_link *link,
 	struct dc_link_settings *known_limit_link_setting)
 {
 	struct dc_link_settings max_link_cap = {0};
@@ -1080,7 +1078,7 @@ bool dp_hbr_verify_link_cap(
 	 * find the physical link capability
 	 */
 	/* disable PHY done possible by BIOS, will be done by driver itself */
-	dp_disable_link_phy(link, link->public.connector_signal);
+	dp_disable_link_phy(link, link->connector_signal);
 
 	dp_cs = link->dc->res_pool->dp_clock_source;
 
@@ -1109,7 +1107,7 @@ bool dp_hbr_verify_link_cap(
 
 		dp_enable_link_phy(
 				link,
-				link->public.connector_signal,
+				link->connector_signal,
 				dp_cs_id,
 				cur);
 
@@ -1117,7 +1115,7 @@ bool dp_hbr_verify_link_cap(
 			success = true;
 		else {
 			status = dc_link_dp_perform_link_training(
-							&link->public,
+							link,
 							cur,
 							skip_video_pattern);
 			if (status == LINK_TRAINING_SUCCESS)
@@ -1125,13 +1123,13 @@ bool dp_hbr_verify_link_cap(
 		}
 
 		if (success)
-			link->public.verified_link_cap = *cur;
+			link->verified_link_cap = *cur;
 
 		/* always disable the link before trying another
 		 * setting or before returning we'll enable it later
 		 * based on the actual mode we're driving
 		 */
-		dp_disable_link_phy(link, link->public.connector_signal);
+		dp_disable_link_phy(link, link->connector_signal);
 	} while (!success && decide_fallback_link_setting(
 			initial_link_settings, cur, status));
 
@@ -1142,14 +1140,14 @@ bool dp_hbr_verify_link_cap(
 		/* If all LT fails for all settings,
 		 * set verified = failed safe (1 lane low)
 		 */
-		link->public.verified_link_cap.lane_count = LANE_COUNT_ONE;
-		link->public.verified_link_cap.link_rate = LINK_RATE_LOW;
+		link->verified_link_cap.lane_count = LANE_COUNT_ONE;
+		link->verified_link_cap.link_rate = LINK_RATE_LOW;
 
-		link->public.verified_link_cap.link_spread =
+		link->verified_link_cap.link_spread =
 		LINK_SPREAD_DISABLED;
 	}
 
-	link->public.max_link_setting = link->public.verified_link_cap;
+	link->max_link_setting = link->verified_link_cap;
 
 	return success;
 }
@@ -1391,7 +1389,7 @@ static uint32_t bandwidth_in_kbps_from_link_settings(
 }
 
 bool dp_validate_mode_timing(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct dc_crtc_timing *timing)
 {
 	uint32_t req_bw;
@@ -1406,12 +1404,12 @@ bool dp_validate_mode_timing(
 		return true;
 
 	/* We always use verified link settings */
-	link_setting = &link->public.verified_link_cap;
+	link_setting = &link->verified_link_cap;
 
 	/* TODO: DYNAMIC_VALIDATION needs to be implemented */
 	/*if (flags.DYNAMIC_VALIDATION == 1 &&
-		link->public.verified_link_cap.lane_count != LANE_COUNT_UNKNOWN)
-		link_setting = &link->public.verified_link_cap;
+		link->verified_link_cap.lane_count != LANE_COUNT_UNKNOWN)
+		link_setting = &link->verified_link_cap;
 	*/
 
 	req_bw = bandwidth_in_kbps_from_timing(timing);
@@ -1444,7 +1442,7 @@ void decide_link_settings(struct core_stream *stream,
 		LANE_COUNT_ONE, LINK_RATE_LOW, LINK_SPREAD_DISABLED};
 	struct dc_link_settings current_link_setting =
 			initial_link_setting;
-	struct core_link* link;
+	struct dc_link *link;
 	uint32_t req_bw;
 	uint32_t link_bw;
 
@@ -1456,11 +1454,11 @@ void decide_link_settings(struct core_stream *stream,
 	/* if preferred is specified through AMDDP, use it, if it's enough
 	 * to drive the mode
 	 */
-	if (link->public.preferred_link_setting.lane_count !=
+	if (link->preferred_link_setting.lane_count !=
 			LANE_COUNT_UNKNOWN &&
-			link->public.preferred_link_setting.link_rate !=
+			link->preferred_link_setting.link_rate !=
 					LINK_RATE_UNKNOWN) {
-		*link_setting =  link->public.preferred_link_setting;
+		*link_setting =  link->preferred_link_setting;
 		return;
 	}
 
@@ -1469,7 +1467,7 @@ void decide_link_settings(struct core_stream *stream,
      * 2. could support the b/w requested by the timing
      */
 	while (current_link_setting.link_rate <=
-			link->public.max_link_setting.link_rate) {
+			link->max_link_setting.link_rate) {
 		link_bw = bandwidth_in_kbps_from_link_settings(
 				&current_link_setting);
 		if (req_bw <= link_bw) {
@@ -1478,7 +1476,7 @@ void decide_link_settings(struct core_stream *stream,
 		}
 
 		if (current_link_setting.lane_count <
-				link->public.max_link_setting.lane_count) {
+				link->max_link_setting.lane_count) {
 			current_link_setting.lane_count =
 					increase_lane_count(
 							current_link_setting.lane_count);
@@ -1492,16 +1490,15 @@ void decide_link_settings(struct core_stream *stream,
 	}
 
 	BREAK_TO_DEBUGGER();
-	ASSERT(link->public.verified_link_cap.lane_count !=
-			LANE_COUNT_UNKNOWN);
+	ASSERT(link->verified_link_cap.lane_count != LANE_COUNT_UNKNOWN);
 
-	*link_setting = link->public.verified_link_cap;
+	*link_setting = link->verified_link_cap;
 }
 
 /*************************Short Pulse IRQ***************************/
 
 static bool hpd_rx_irq_check_link_loss_status(
-	struct core_link *link,
+	struct dc_link *link,
 	union hpd_irq_data *hpd_irq_dpcd_data)
 {
 	uint8_t irq_reg_rx_power_state;
@@ -1514,7 +1511,7 @@ static bool hpd_rx_irq_check_link_loss_status(
 	sink_status_changed = false;
 	return_code = false;
 
-	if (link->public.cur_link_settings.lane_count == 0)
+	if (link->cur_link_settings.lane_count == 0)
 		return return_code;
 	/*1. Check that we can handle interrupt: Not in FS DOS,
 	 *  Not in "Display Timeout" state, Link is trained.
@@ -1538,7 +1535,7 @@ static bool hpd_rx_irq_check_link_loss_status(
 
 		/*parse lane status*/
 		for (lane = 0;
-			lane < link->public.cur_link_settings.lane_count;
+			lane < link->cur_link_settings.lane_count;
 			lane++) {
 
 			/* check status of lanes 0,1
@@ -1577,7 +1574,7 @@ static bool hpd_rx_irq_check_link_loss_status(
 }
 
 static enum dc_status read_hpd_rx_irq_data(
-	struct core_link *link,
+	struct dc_link *link,
 	union hpd_irq_data *irq_data)
 {
 	/* The HW reads 16 bytes from 200h on HPD,
@@ -1593,7 +1590,7 @@ static enum dc_status read_hpd_rx_irq_data(
 	sizeof(union hpd_irq_data));
 }
 
-static bool allow_hpd_rx_irq(const struct core_link *link)
+static bool allow_hpd_rx_irq(const struct dc_link *link)
 {
 	/*
 	 * Don't handle RX IRQ unless one of following is met:
@@ -1602,15 +1599,15 @@ static bool allow_hpd_rx_irq(const struct core_link *link)
 	 * 3) We know we're dealing with an active dongle
 	 */
 
-	if ((link->public.cur_link_settings.lane_count != LANE_COUNT_UNKNOWN) ||
-		(link->public.type == dc_connection_mst_branch) ||
+	if ((link->cur_link_settings.lane_count != LANE_COUNT_UNKNOWN) ||
+		(link->type == dc_connection_mst_branch) ||
 		is_dp_active_dongle(link))
 		return true;
 
 	return false;
 }
 
-static bool handle_hpd_irq_psr_sink(const struct core_link *link)
+static bool handle_hpd_irq_psr_sink(const struct dc_link *link)
 {
 	union dpcd_psr_configuration psr_configuration;
 
@@ -1619,7 +1616,7 @@ static bool handle_hpd_irq_psr_sink(const struct core_link *link)
 
 	dm_helpers_dp_read_dpcd(
 		link->ctx,
-		&link->public,
+		link,
 		368,/*DpcdAddress_PSR_Enable_Cfg*/
 		&psr_configuration.raw,
 		sizeof(psr_configuration.raw));
@@ -1632,7 +1629,7 @@ static bool handle_hpd_irq_psr_sink(const struct core_link *link)
 
 		dm_helpers_dp_read_dpcd(
 			link->ctx,
-			&link->public,
+			link,
 			0x2006, /*DpcdAddress_PSR_Error_Status*/
 			(unsigned char *) dpcdbuf,
 			sizeof(dpcdbuf));
@@ -1647,14 +1644,14 @@ static bool handle_hpd_irq_psr_sink(const struct core_link *link)
 			/* Acknowledge and clear error bits */
 			dm_helpers_dp_write_dpcd(
 				link->ctx,
-				&link->public,
+				link,
 				8198,/*DpcdAddress_PSR_Error_Status*/
 				&psr_error_status.raw,
 				sizeof(psr_error_status.raw));
 
 			/* PSR error, disable and re-enable PSR */
-			dc_link_set_psr_enable(&link->public, false);
-			dc_link_set_psr_enable(&link->public, true);
+			dc_link_set_psr_enable(link, false);
+			dc_link_set_psr_enable(link, true);
 
 			return true;
 		} else if (psr_sink_psr_status.bits.SINK_SELF_REFRESH_STATUS ==
@@ -1670,7 +1667,7 @@ static bool handle_hpd_irq_psr_sink(const struct core_link *link)
 	return false;
 }
 
-static void dp_test_send_link_training(struct core_link *link)
+static void dp_test_send_link_training(struct dc_link *link)
 {
 	struct dc_link_settings link_settings = {0};
 
@@ -1686,13 +1683,13 @@ static void dp_test_send_link_training(struct core_link *link)
 			1);
 
 	/* Set preferred link settings */
-	link->public.verified_link_cap.lane_count = link_settings.lane_count;
-	link->public.verified_link_cap.link_rate = link_settings.link_rate;
+	link->verified_link_cap.lane_count = link_settings.lane_count;
+	link->verified_link_cap.link_rate = link_settings.link_rate;
 
 	dp_retrain_link_dp_test(link, &link_settings, false);
 }
 
-static void dp_test_send_phy_test_pattern(struct core_link *link)
+static void dp_test_send_phy_test_pattern(struct dc_link *link)
 {
 	union phy_test_pattern dpcd_test_pattern;
 	union lane_adjust dpcd_lane_adjustment[2];
@@ -1771,10 +1768,10 @@ static void dp_test_send_phy_test_pattern(struct core_link *link)
 				sizeof(test_80_bit_pattern));
 
 	/* prepare link training settings */
-	link_settings.link = link->public.cur_link_settings;
+	link_settings.link = link->cur_link_settings;
 
 	for (lane = 0; lane <
-		(unsigned int)(link->public.cur_link_settings.lane_count);
+		(unsigned int)(link->cur_link_settings.lane_count);
 		lane++) {
 		dpcd_lane_adjust.raw =
 			get_nibble_at_index(&dpcd_lane_adjustment[0].raw, lane);
@@ -1802,7 +1799,7 @@ static void dp_test_send_phy_test_pattern(struct core_link *link)
 	 * forward request to DS
 	 */
 	dc_link_dp_set_test_pattern(
-		&link->public,
+		link,
 		test_pattern,
 		&link_training_settings,
 		test_80_bit_pattern,
@@ -1810,7 +1807,7 @@ static void dp_test_send_phy_test_pattern(struct core_link *link)
 		DP_TEST_80BIT_CUSTOM_PATTERN_7_0)+1);
 }
 
-static void dp_test_send_link_test_pattern(struct core_link *link)
+static void dp_test_send_link_test_pattern(struct dc_link *link)
 {
 	union link_test_pattern dpcd_test_pattern;
 	union test_misc dpcd_test_params;
@@ -1850,14 +1847,14 @@ static void dp_test_send_link_test_pattern(struct core_link *link)
 	}
 
 	dc_link_dp_set_test_pattern(
-			&link->public,
+			link,
 			test_pattern,
 			NULL,
 			NULL,
 			0);
 }
 
-static void handle_automated_test(struct core_link *link)
+static void handle_automated_test(struct dc_link *link)
 {
 	union test_request test_request;
 	union test_response test_response;
@@ -1904,9 +1901,8 @@ static void handle_automated_test(struct core_link *link)
 			sizeof(test_response));
 }
 
-bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link, union hpd_irq_data *out_hpd_irq_dpcd_data)
+bool dc_link_handle_hpd_rx_irq(struct dc_link *link, union hpd_irq_data *out_hpd_irq_dpcd_data)
 {
-	struct core_link *link = DC_LINK_TO_LINK(dc_link);
 	union hpd_irq_data hpd_irq_dpcd_data = {{{{0}}}};
 	union device_service_irq device_service_clear = { { 0 } };
 	enum dc_status result = DDC_RESULT_UNKNOWN;
@@ -1917,7 +1913,7 @@ bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link, union hpd_irq_data
 
 	dm_logger_write(link->ctx->logger, LOG_HW_HPD_IRQ,
 		"%s: Got short pulse HPD on link %d\n",
-		__func__, link->public.link_index);
+		__func__, link->link_index);
 
 
 	 /* All the "handle_hpd_irq_xxx()" methods
@@ -1951,7 +1947,7 @@ bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link, union hpd_irq_data
 	if (!allow_hpd_rx_irq(link)) {
 		dm_logger_write(link->ctx->logger, LOG_HW_HPD_IRQ,
 			"%s: skipping HPD handling on %d\n",
-			__func__, link->public.link_index);
+			__func__, link->link_index);
 		return false;
 	}
 
@@ -1984,13 +1980,13 @@ bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link, union hpd_irq_data
 					"Status: ");
 
 		perform_link_training_with_retries(link,
-			&link->public.cur_link_settings,
+			&link->cur_link_settings,
 			true, LINK_TRAINING_ATTEMPTS);
 
 		status = false;
 	}
 
-	if (link->public.type == dc_connection_active_dongle &&
+	if (link->type == dc_connection_active_dongle &&
 		hpd_irq_dpcd_data.bytes.sink_cnt.bits.SINK_COUNT
 			!= link->dpcd_sink_count)
 		status = true;
@@ -2010,7 +2006,7 @@ bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link, union hpd_irq_data
 }
 
 /*query dpcd for version and mst cap addresses*/
-bool is_mst_supported(struct core_link *link)
+bool is_mst_supported(struct dc_link *link)
 {
 	bool mst          = false;
 	enum dc_status st = DC_OK;
@@ -2034,7 +2030,7 @@ bool is_mst_supported(struct core_link *link)
 
 }
 
-bool is_dp_active_dongle(const struct core_link *link)
+bool is_dp_active_dongle(const struct dc_link *link)
 {
 	enum display_dongle_type dongle_type = link->dpcd_caps.dongle_type;
 
@@ -2044,14 +2040,14 @@ bool is_dp_active_dongle(const struct core_link *link)
 }
 
 static void get_active_converter_info(
-	uint8_t data, struct core_link *link)
+	uint8_t data, struct dc_link *link)
 {
 	union dp_downstream_port_present ds_port = { .byte = data };
 
 	/* decode converter info*/
 	if (!ds_port.fields.PORT_PRESENT) {
 		link->dpcd_caps.dongle_type = DISPLAY_DONGLE_NONE;
-		ddc_service_set_dongle_type(link->public.ddc,
+		ddc_service_set_dongle_type(link->ddc,
 				link->dpcd_caps.dongle_type);
 		return;
 	}
@@ -2121,7 +2117,7 @@ static void get_active_converter_info(
 		}
 	}
 
-	ddc_service_set_dongle_type(link->public.ddc, link->dpcd_caps.dongle_type);
+	ddc_service_set_dongle_type(link->ddc, link->dpcd_caps.dongle_type);
 
 	{
 		struct dp_device_vendor_id dp_id;
@@ -2158,7 +2154,7 @@ static void get_active_converter_info(
 	}
 }
 
-static void dp_wa_power_up_0010FA(struct core_link *link, uint8_t *dpcd_data,
+static void dp_wa_power_up_0010FA(struct dc_link *link, uint8_t *dpcd_data,
 		int length)
 {
 	int retry = 0;
@@ -2199,7 +2195,7 @@ static void dp_wa_power_up_0010FA(struct core_link *link, uint8_t *dpcd_data,
 		link->wa_flags.dp_keep_receiver_powered = false;
 }
 
-static void retrieve_link_cap(struct core_link *link)
+static void retrieve_link_cap(struct dc_link *link)
 {
 	uint8_t dpcd_data[DP_TRAINING_AUX_RD_INTERVAL - DP_DPCD_REV + 1];
 
@@ -2253,11 +2249,11 @@ static void retrieve_link_cap(struct core_link *link)
 	link->dpcd_caps.max_down_spread.raw = dpcd_data[
 		DP_MAX_DOWNSPREAD - DP_DPCD_REV];
 
-	link->public.reported_link_cap.lane_count =
+	link->reported_link_cap.lane_count =
 		link->dpcd_caps.max_ln_count.bits.MAX_LANE_COUNT;
-	link->public.reported_link_cap.link_rate = dpcd_data[
+	link->reported_link_cap.link_rate = dpcd_data[
 		DP_MAX_LINK_RATE - DP_DPCD_REV];
-	link->public.reported_link_cap.link_spread =
+	link->reported_link_cap.link_spread =
 		link->dpcd_caps.max_down_spread.bits.MAX_DOWN_SPREAD ?
 		LINK_SPREAD_05_DOWNSPREAD_30KHZ : LINK_SPREAD_DISABLED;
 
@@ -2266,8 +2262,8 @@ static void retrieve_link_cap(struct core_link *link)
 	link->dpcd_caps.panel_mode_edp =
 		edp_config_cap.bits.ALT_SCRAMBLER_RESET;
 
-	link->public.test_pattern_enabled = false;
-	link->public.compliance_test_state.raw = 0;
+	link->test_pattern_enabled = false;
+	link->compliance_test_state.raw = 0;
 
 	/* read sink count */
 	core_link_read_dpcd(link,
@@ -2279,7 +2275,7 @@ static void retrieve_link_cap(struct core_link *link)
 	CONN_DATA_DETECT(link, dpcd_data, sizeof(dpcd_data), "Rx Caps: ");
 }
 
-void detect_dp_sink_caps(struct core_link *link)
+void detect_dp_sink_caps(struct dc_link *link)
 {
 	retrieve_link_cap(link);
 
@@ -2291,18 +2287,17 @@ void detect_dp_sink_caps(struct core_link *link)
 	 */
 
 	if (is_mst_supported(link)) {
-		link->public.verified_link_cap = link->public.reported_link_cap;
+		link->verified_link_cap = link->reported_link_cap;
 	} else {
 		dp_hbr_verify_link_cap(link,
-			&link->public.reported_link_cap);
+			&link->reported_link_cap);
 	}
 	/* TODO save sink caps in link->sink */
 }
 
 void dc_link_dp_enable_hpd(const struct dc_link *link)
 {
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
-	struct link_encoder *encoder = core_link->link_enc;
+	struct link_encoder *encoder = link->link_enc;
 
 	if (encoder != NULL && encoder->funcs->enable_hpd != NULL)
 		encoder->funcs->enable_hpd(encoder);
@@ -2310,8 +2305,7 @@ void dc_link_dp_enable_hpd(const struct dc_link *link)
 
 void dc_link_dp_disable_hpd(const struct dc_link *link)
 {
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
-	struct link_encoder *encoder = core_link->link_enc;
+	struct link_encoder *encoder = link->link_enc;
 
 	if (encoder != NULL && encoder->funcs->enable_hpd != NULL)
 		encoder->funcs->disable_hpd(encoder);
@@ -2327,7 +2321,7 @@ static bool is_dp_phy_pattern(enum dp_test_pattern test_pattern)
 		return false;
 }
 
-static void set_crtc_test_pattern(struct core_link *link,
+static void set_crtc_test_pattern(struct dc_link *link,
 				struct pipe_ctx *pipe_ctx,
 				enum dp_test_pattern test_pattern)
 {
@@ -2402,15 +2396,13 @@ static void set_crtc_test_pattern(struct core_link *link,
 }
 
 bool dc_link_dp_set_test_pattern(
-	const struct dc_link *link,
+	struct dc_link *link,
 	enum dp_test_pattern test_pattern,
 	const struct link_training_settings *p_link_settings,
 	const unsigned char *p_custom_pattern,
 	unsigned int cust_pattern_size)
 {
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
-	struct pipe_ctx *pipes =
-			core_link->dc->current_context->res_ctx.pipe_ctx;
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
 	struct pipe_ctx pipe_ctx = pipes[0];
 	unsigned int lane;
 	unsigned int i;
@@ -2421,7 +2413,7 @@ bool dc_link_dp_set_test_pattern(
 	memset(&training_pattern, 0, sizeof(training_pattern));
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (pipes[i].stream->sink->link == core_link) {
+		if (pipes[i].stream->sink->link == link) {
 			pipe_ctx = pipes[i];
 			break;
 		}
@@ -2431,24 +2423,24 @@ bool dc_link_dp_set_test_pattern(
 	 * is VideoMode Reset DP Phy Test Pattern if it is currently running
 	 * and request is VideoMode
 	 */
-	if (core_link->public.test_pattern_enabled && test_pattern ==
+	if (link->test_pattern_enabled && test_pattern ==
 			DP_TEST_PATTERN_VIDEO_MODE) {
 		/* Set CRTC Test Pattern */
-		set_crtc_test_pattern(core_link, &pipe_ctx, test_pattern);
-		dp_set_hw_test_pattern(core_link, test_pattern,
+		set_crtc_test_pattern(link, &pipe_ctx, test_pattern);
+		dp_set_hw_test_pattern(link, test_pattern,
 				(uint8_t *)p_custom_pattern,
 				(uint32_t)cust_pattern_size);
 
 		/* Unblank Stream */
-		core_link->dc->hwss.unblank_stream(
+		link->dc->hwss.unblank_stream(
 			&pipe_ctx,
-			&core_link->public.verified_link_cap);
+			&link->verified_link_cap);
 		/* TODO:m_pHwss->MuteAudioEndpoint
 		 * (pPathMode->pDisplayPath, false);
 		 */
 
 		/* Reset Test Pattern state */
-		core_link->public.test_pattern_enabled = false;
+		link->test_pattern_enabled = false;
 
 		return true;
 	}
@@ -2457,8 +2449,8 @@ bool dc_link_dp_set_test_pattern(
 	if (is_dp_phy_pattern(test_pattern)) {
 		/* Set DPCD Lane Settings before running test pattern */
 		if (p_link_settings != NULL) {
-			dp_set_hw_lane_settings(core_link, p_link_settings);
-			dpcd_set_lane_settings(core_link, p_link_settings);
+			dp_set_hw_lane_settings(link, p_link_settings);
+			dpcd_set_lane_settings(link, p_link_settings);
 		}
 
 		/* Blank stream if running test pattern */
@@ -2471,15 +2463,15 @@ bool dc_link_dp_set_test_pattern(
 			pipes->stream_enc->funcs->dp_blank(pipe_ctx.stream_enc);
 		}
 
-		dp_set_hw_test_pattern(core_link, test_pattern,
+		dp_set_hw_test_pattern(link, test_pattern,
 				(uint8_t *)p_custom_pattern,
 				(uint32_t)cust_pattern_size);
 
 		if (test_pattern != DP_TEST_PATTERN_VIDEO_MODE) {
 			/* Set Test Pattern state */
-			core_link->public.test_pattern_enabled = true;
+			link->test_pattern_enabled = true;
 			if (p_link_settings != NULL)
-				dpcd_set_link_settings(core_link,
+				dpcd_set_link_settings(link,
 						p_link_settings);
 		}
 
@@ -2516,7 +2508,7 @@ bool dc_link_dp_set_test_pattern(
 		/*TODO:&& !pPathMode->pDisplayPath->IsTargetPoweredOn()*/)
 			return false;
 
-		if (core_link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {
+		if (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {
 			/* tell receiver that we are sending qualification
 			 * pattern DP 1.2 or later - DP receiver's link quality
 			 * pattern is set using DPCD LINK_QUAL_LANEx_SET
@@ -2526,12 +2518,12 @@ bool dc_link_dp_set_test_pattern(
 				link_qual_pattern[lane] =
 						(unsigned char)(pattern);
 
-			core_link_write_dpcd(core_link,
+			core_link_write_dpcd(link,
 					DP_LINK_QUAL_LANE0_SET,
 					link_qual_pattern,
 					sizeof(link_qual_pattern));
-		} else if (core_link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_10 ||
-				core_link->dpcd_caps.dpcd_rev.raw == 0) {
+		} else if (link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_10 ||
+			   link->dpcd_caps.dpcd_rev.raw == 0) {
 			/* tell receiver that we are sending qualification
 			 * pattern DP 1.1a or earlier - DP receiver's link
 			 * quality pattern is set using
@@ -2539,27 +2531,25 @@ bool dc_link_dp_set_test_pattern(
 			 * register (0x102). We will use v_1.3 when we are
 			 * setting test pattern for DP 1.1.
 			 */
-			core_link_read_dpcd(core_link,
-					DP_TRAINING_PATTERN_SET,
-					&training_pattern.raw,
-					sizeof(training_pattern));
+			core_link_read_dpcd(link, DP_TRAINING_PATTERN_SET,
+					    &training_pattern.raw,
+					    sizeof(training_pattern));
 			training_pattern.v1_3.LINK_QUAL_PATTERN_SET = pattern;
-			core_link_write_dpcd(core_link,
-					DP_TRAINING_PATTERN_SET,
-					&training_pattern.raw,
-					sizeof(training_pattern));
+			core_link_write_dpcd(link, DP_TRAINING_PATTERN_SET,
+					     &training_pattern.raw,
+					     sizeof(training_pattern));
 		}
 	} else {
 	/* CRTC Patterns */
-		set_crtc_test_pattern(core_link, &pipe_ctx, test_pattern);
+		set_crtc_test_pattern(link, &pipe_ctx, test_pattern);
 		/* Set Test Pattern state */
-		core_link->public.test_pattern_enabled = true;
+		link->test_pattern_enabled = true;
 	}
 
 	return true;
 }
 
-void dp_enable_mst_on_sink(struct core_link *link, bool enable)
+void dp_enable_mst_on_sink(struct dc_link *link, bool enable)
 {
 	unsigned char mstmCntl;
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 0092e70..aac2420 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -16,13 +16,13 @@
 #include "dpcd_defs.h"
 
 enum dc_status core_link_read_dpcd(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t address,
 	uint8_t *data,
 	uint32_t size)
 {
 	if (!dm_helpers_dp_read_dpcd(link->ctx,
-			&link->public,
+			link,
 			address, data, size))
 			return DC_ERROR_UNEXPECTED;
 
@@ -30,20 +30,20 @@ enum dc_status core_link_read_dpcd(
 }
 
 enum dc_status core_link_write_dpcd(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t address,
 	const uint8_t *data,
 	uint32_t size)
 {
 	if (!dm_helpers_dp_write_dpcd(link->ctx,
-			&link->public,
+			link,
 			address, data, size))
 				return DC_ERROR_UNEXPECTED;
 
 	return DC_OK;
 }
 
-void dp_receiver_power_ctrl(struct core_link *link, bool on)
+void dp_receiver_power_ctrl(struct dc_link *link, bool on)
 {
 	uint8_t state;
 
@@ -54,7 +54,7 @@ void dp_receiver_power_ctrl(struct core_link *link, bool on)
 }
 
 void dp_enable_link_phy(
-	struct core_link *link,
+	struct dc_link *link,
 	enum signal_type signal,
 	enum clock_source_id clock_source,
 	const struct dc_link_settings *link_settings)
@@ -107,7 +107,7 @@ void dp_enable_link_phy(
 	dp_receiver_power_ctrl(link, true);
 }
 
-void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
+void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {
 	if (!link->wa_flags.dp_keep_receiver_powered)
 		dp_receiver_power_ctrl(link, false);
@@ -120,11 +120,11 @@ void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
 	link->link_enc->funcs->disable_output(link->link_enc, signal);
 
 	/* Clear current link setting.*/
-	memset(&link->public.cur_link_settings, 0,
-			sizeof(link->public.cur_link_settings));
+	memset(&link->cur_link_settings, 0,
+			sizeof(link->cur_link_settings));
 }
 
-void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal)
+void dp_disable_link_phy_mst(struct dc_link *link, enum signal_type signal)
 {
 	/* MST disable link only when no stream use the link */
 	if (link->mst_stream_alloc_table.stream_count > 0)
@@ -137,7 +137,7 @@ void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal)
 }
 
 bool dp_set_hw_training_pattern(
-	struct core_link *link,
+	struct dc_link *link,
 	enum hw_dp_training_pattern pattern)
 {
 	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
@@ -165,7 +165,7 @@ bool dp_set_hw_training_pattern(
 }
 
 void dp_set_hw_lane_settings(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct link_training_settings *link_settings)
 {
 	struct link_encoder *encoder = link->link_enc;
@@ -174,13 +174,13 @@ void dp_set_hw_lane_settings(
 	encoder->funcs->dp_set_lane_settings(encoder, link_settings);
 }
 
-enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
+enum dp_panel_mode dp_get_panel_mode(struct dc_link *link)
 {
 	/* We need to explicitly check that connector
 	 * is not DP. Some Travis_VGA get reported
 	 * by video bios as DP.
 	 */
-	if (link->public.connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+	if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
 
 		switch (link->dpcd_caps.branch_dev_id) {
 		case DP_BRANCH_DEVICE_ID_2:
@@ -215,7 +215,7 @@ enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
 }
 
 void dp_set_hw_test_pattern(
-	struct core_link *link,
+	struct dc_link *link,
 	enum dp_test_pattern test_pattern,
 	uint8_t *custom_pattern,
 	uint32_t custom_pattern_size)
@@ -231,7 +231,7 @@ void dp_set_hw_test_pattern(
 	encoder->funcs->dp_set_phy_pattern(encoder, &pattern_param);
 }
 
-void dp_retrain_link_dp_test(struct core_link *link,
+void dp_retrain_link_dp_test(struct dc_link *link,
 			struct dc_link_settings *link_setting,
 			bool skip_video_pattern)
 {
@@ -263,8 +263,8 @@ void dp_retrain_link_dp_test(struct core_link *link,
 					SIGNAL_TYPE_DISPLAY_PORT);
 
 			/* Clear current link setting. */
-			memset(&link->public.cur_link_settings, 0,
-				sizeof(link->public.cur_link_settings));
+			memset(&link->cur_link_settings, 0,
+				sizeof(link->cur_link_settings));
 
 			link->link_enc->funcs->enable_dp_output(
 						link->link_enc,
@@ -274,11 +274,11 @@ void dp_retrain_link_dp_test(struct core_link *link,
 			dp_receiver_power_ctrl(link, true);
 
 			dc_link_dp_perform_link_training(
-					&link->public,
+					link,
 					link_setting,
 					skip_video_pattern);
 
-			link->public.cur_link_settings = *link_setting;
+			link->cur_link_settings = *link_setting;
 
 			link->dc->hwss.enable_stream(&pipes[i]);
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 857a2a3..ec4714e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1269,7 +1269,7 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 {
 	int i;
 	int j = -1;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (!res_ctx->is_stream_enc_acquired[i] &&
@@ -1322,9 +1322,7 @@ static void update_stream_signal(struct core_stream *stream)
 		const struct dc_sink *dc_sink = stream->public.sink;
 
 		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-			stream->signal =
-					stream->sink->link->
-					public.connector_signal;
+			stream->signal = stream->sink->link->connector_signal;
 		else
 			stream->signal = dc_sink->sink_signal;
 	} else {
@@ -1380,7 +1378,7 @@ static struct core_stream *find_pll_sharable_stream(
 		if (resource_are_streams_timing_synchronizable(
 			stream_needs_pll, stream_has_pll)
 			&& !dc_is_dp_signal(stream_has_pll->signal)
-			&& stream_has_pll->sink->link->public.connector_signal
+			&& stream_has_pll->sink->link->connector_signal
 			!= SIGNAL_TYPE_VIRTUAL)
 			return stream_has_pll;
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_sink.c b/drivers/gpu/drm/amd/display/dc/core/dc_sink.c
index da99556..7f0ba72 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_sink.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_sink.c
@@ -54,15 +54,14 @@ static void destruct(struct sink *sink)
 static bool construct(struct sink *sink, const struct dc_sink_init_data *init_params)
 {
 
-	struct core_link *core_link = DC_LINK_TO_LINK(init_params->link);
+	struct dc_link *link = init_params->link;
 
-	if (!core_link) {
+	if (!link)
 		return false;
-	}
 
 	sink->protected.public.sink_signal = init_params->sink_signal;
-	sink->protected.link = core_link;
-	sink->protected.ctx = core_link->ctx;
+	sink->protected.link = link;
+	sink->protected.ctx = link->ctx;
 	sink->protected.public.dongle_max_pix_clk = init_params->dongle_max_pix_clk;
 	sink->protected.public.converter_disable_audio =
 			init_params->converter_disable_audio;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 73712fd..a329709 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -91,7 +91,7 @@ static bool construct(struct core_stream *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
-	stream->status.link = &stream->sink->link->public;
+	stream->status.link = stream->sink->link;
 	return true;
 }
 
@@ -355,5 +355,5 @@ void dc_stream_log(
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tlink: %d\n",
-			core_stream->sink->link->public.link_index);
+			core_stream->sink->link->link_index);
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 5d8f5e8..6079737 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -31,6 +31,7 @@
 #include "logger_types.h"
 #include "gpio_types.h"
 #include "link_service_types.h"
+#include "grph_object_ctrl_defs.h"
 
 #define MAX_SURFACES 3
 #define MAX_STREAMS 6
@@ -141,11 +142,11 @@ struct dc_link_funcs {
 			bool skip_video_pattern);
 	void (*set_preferred_link_settings)(struct dc *dc,
 			struct dc_link_settings *link_setting,
-			const struct dc_link *link);
+			struct dc_link *link);
 	void (*enable_hpd)(const struct dc_link *link);
 	void (*disable_hpd)(const struct dc_link *link);
 	void (*set_test_pattern)(
-			const struct dc_link *link,
+			struct dc_link *link,
 			enum dp_test_pattern test_pattern,
 			const struct link_training_settings *p_link_settings,
 			const unsigned char *p_custom_pattern,
@@ -653,7 +654,7 @@ struct dc_stream_status {
 	/*
 	 * link this stream passes through
 	 */
-	const struct dc_link *link;
+	struct dc_link *link;
 };
 
 struct dc_stream_status *dc_stream_get_status(
@@ -674,6 +675,50 @@ void dc_release_validate_context(struct validate_context *context);
  * Link Interfaces
  ******************************************************************************/
 
+struct dpcd_caps {
+	union dpcd_rev dpcd_rev;
+	union max_lane_count max_ln_count;
+	union max_down_spread max_down_spread;
+
+	/* dongle type (DP converter, CV smart dongle) */
+	enum display_dongle_type dongle_type;
+	/* Dongle's downstream count. */
+	union sink_count sink_count;
+	/* If dongle_type == DISPLAY_DONGLE_DP_HDMI_CONVERTER,
+	indicates 'Frame Sequential-to-lllFrame Pack' conversion capability.*/
+	struct dc_dongle_caps dongle_caps;
+
+	uint32_t sink_dev_id;
+	uint32_t branch_dev_id;
+	int8_t branch_dev_name[6];
+	int8_t branch_hw_revision;
+
+	bool allow_invalid_MSA_timing_param;
+	bool panel_mode_edp;
+};
+
+struct dc_link_status {
+	struct dpcd_caps *dpcd_caps;
+};
+
+/* DP MST stream allocation (payload bandwidth number) */
+struct link_mst_stream_allocation {
+	/* DIG front */
+	const struct stream_encoder *stream_enc;
+	/* associate DRM payload table with DC stream encoder */
+	uint8_t vcp_id;
+	/* number of slots required for the DP stream in transport packet */
+	uint8_t slot_count;
+};
+
+/* DP MST stream allocation table */
+struct link_mst_stream_allocation_table {
+	/* number of DP video streams */
+	int stream_count;
+	/* array of stream allocations */
+	struct link_mst_stream_allocation stream_allocations[MAX_CONTROLLER_NUM];
+};
+
 /*
  * A link contains one or more sinks and their connected status.
  * The currently active signal type (HDMI, DP-SST, DP-MST) is also reported.
@@ -711,32 +756,31 @@ struct dc_link {
 	struct ddc_service *ddc;
 
 	bool aux_mode;
-};
 
-struct dpcd_caps {
-	union dpcd_rev dpcd_rev;
-	union max_lane_count max_ln_count;
-	union max_down_spread max_down_spread;
+	/* Private to DC core */
 
-	/* dongle type (DP converter, CV smart dongle) */
-	enum display_dongle_type dongle_type;
-	/* Dongle's downstream count. */
-	union sink_count sink_count;
-	/* If dongle_type == DISPLAY_DONGLE_DP_HDMI_CONVERTER,
-	indicates 'Frame Sequential-to-lllFrame Pack' conversion capability.*/
-	struct dc_dongle_caps dongle_caps;
+	const struct core_dc *dc;
 
-	uint32_t sink_dev_id;
-	uint32_t branch_dev_id;
-	int8_t branch_dev_name[6];
-	int8_t branch_hw_revision;
+	struct dc_context *ctx;
 
-	bool allow_invalid_MSA_timing_param;
-	bool panel_mode_edp;
-};
+	struct link_encoder *link_enc;
+	struct graphics_object_id link_id;
+	union ddi_channel_mapping ddi_channel_mapping;
+	struct connector_device_tag_info device_tag;
+	struct dpcd_caps dpcd_caps;
+	unsigned int dpcd_sink_count;
+
+	enum edp_revision edp_revision;
+	bool psr_enabled;
+
+	/* MST record stream using this link */
+	struct link_flags {
+		bool dp_keep_receiver_powered;
+	} wa_flags;
+	struct link_mst_stream_allocation_table mst_stream_alloc_table;
+
+	struct dc_link_status link_status;
 
-struct dc_link_status {
-	struct dpcd_caps *dpcd_caps;
 };
 
 const struct dc_link_status *dc_link_get_status(const struct dc_link *dc_link);
@@ -746,7 +790,7 @@ const struct dc_link_status *dc_link_get_status(const struct dc_link *dc_link);
  * boot time.  They cannot be created or destroyed.
  * Use dc_get_caps() to get number of links.
  */
-const struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index);
+struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index);
 
 /* Return id of physical connector represented by a dc_link at link_index.*/
 const struct graphics_object_id dc_get_link_id_at_index(
@@ -762,7 +806,7 @@ bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable);
 
 bool dc_link_get_psr_state(const struct dc_link *dc_link, uint32_t *psr_state);
 
-bool dc_link_setup_psr(const struct dc_link *dc_link,
+bool dc_link_setup_psr(struct dc_link *dc_link,
 		const struct dc_stream *stream, struct psr_config *psr_config,
 		struct psr_context *psr_context);
 
@@ -772,7 +816,7 @@ bool dc_link_setup_psr(const struct dc_link *dc_link,
  * true otherwise. True meaning further action is required (status update
  * and OS notification).
  */
-bool dc_link_detect(const struct dc_link *dc_link, bool boot);
+bool dc_link_detect(struct dc_link *dc_link, bool boot);
 
 /* Notify DC about DP RX Interrupt (aka Short Pulse Interrupt).
  * Return:
@@ -780,26 +824,26 @@ bool dc_link_detect(const struct dc_link *dc_link, bool boot);
  * detection.
  * false - no change in Downstream port status. No further action required
  * from DM. */
-bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link,
+bool dc_link_handle_hpd_rx_irq(struct dc_link *dc_link,
 		union hpd_irq_data *hpd_irq_dpcd_data);
 
 struct dc_sink_init_data;
 
 struct dc_sink *dc_link_add_remote_sink(
-		const struct dc_link *dc_link,
+		struct dc_link *dc_link,
 		const uint8_t *edid,
 		int len,
 		struct dc_sink_init_data *init_data);
 
 void dc_link_remove_remote_sink(
-	const struct dc_link *link,
+	struct dc_link *link,
 	const struct dc_sink *sink);
 
 /* Used by diagnostics for virtual link at the moment */
-void dc_link_set_sink(const struct dc_link *link, struct dc_sink *sink);
+void dc_link_set_sink(struct dc_link *link, struct dc_sink *sink);
 
 void dc_link_dp_set_drive_settings(
-	const struct dc_link *link,
+	struct dc_link *link,
 	struct link_training_settings *lt_settings);
 
 enum link_training_result dc_link_dp_perform_link_training(
@@ -812,7 +856,7 @@ void dc_link_dp_enable_hpd(const struct dc_link *link);
 void dc_link_dp_disable_hpd(const struct dc_link *link);
 
 bool dc_link_dp_set_test_pattern(
-	const struct dc_link *link,
+	struct dc_link *link,
 	enum dp_test_pattern test_pattern,
 	const struct link_training_settings *p_link_settings,
 	const unsigned char *p_custom_pattern,
@@ -856,7 +900,7 @@ const struct audio **dc_get_audios(struct dc *dc);
 
 struct dc_sink_init_data {
 	enum signal_type sink_signal;
-	const struct dc_link *link;
+	struct dc_link *link;
 	uint32_t dongle_max_pix_clk;
 	bool converter_disable_audio;
 };
diff --git a/drivers/gpu/drm/amd/display/dc/dc_ddc_types.h b/drivers/gpu/drm/amd/display/dc/dc_ddc_types.h
index b143fe8..e1affeb 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_ddc_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_ddc_types.h
@@ -105,7 +105,7 @@ struct ddc_service {
 	enum ddc_transaction_type transaction_type;
 	enum display_dongle_type dongle_type;
 	struct dc_context *ctx;
-	struct core_link *link;
+	struct dc_link *link;
 
 	uint32_t address;
 	uint32_t edid_buf_len;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c b/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
index 0fe3ee8..aaff946 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
@@ -142,7 +142,7 @@ static void dce_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable)
 }
 
 static void dce_dmcu_setup_psr(struct dmcu *dmcu,
-		struct core_link *link,
+		struct dc_link *link,
 		struct psr_context *psr_context)
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
@@ -382,7 +382,7 @@ static void dcn10_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable)
 }
 
 static void dcn10_dmcu_setup_psr(struct dmcu *dmcu,
-		struct core_link *link,
+		struct dc_link *link,
 		struct psr_context *psr_context)
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
index 5663d3d..318673d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
@@ -1020,7 +1020,7 @@ bool dce110_link_encoder_validate_output_with_stream(
 	case SIGNAL_TYPE_DVI_DUAL_LINK:
 		is_valid = dce110_link_encoder_validate_dvi_output(
 			enc110,
-			stream->sink->link->public.connector_signal,
+			stream->sink->link->connector_signal,
 			pipe_ctx->stream->signal,
 			&stream->public.timing);
 	break;
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index 716f664..6938158 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -661,7 +661,7 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct core_link *link = stream->sink->link;
+		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index cf6bf20..fe8084e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -700,10 +700,10 @@ void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 {
 	enum dc_lane_count lane_count =
-		pipe_ctx->stream->sink->link->public.cur_link_settings.lane_count;
+		pipe_ctx->stream->sink->link->cur_link_settings.lane_count;
 
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
-	struct core_link *link = pipe_ctx->stream->sink->link;
+	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* 1. update AVI info frame (HDMI, DP)
 	 * we always need to update info frame
@@ -746,7 +746,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 
 	if (pipe_ctx->audio) {
 		pipe_ctx->audio->funcs->az_disable(pipe_ctx->audio);
@@ -1111,7 +1111,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	dce110_update_info_frame(pipe_ctx);
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			dce110_unblank_stream(pipe_ctx,
-				&stream->sink->link->public.cur_link_settings);
+				&stream->sink->link->cur_link_settings);
 	}
 
 	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
@@ -2220,7 +2220,7 @@ static void init_hw(struct core_dc *dc)
 		/* Power up AND update implementation according to the
 		 * required signal (which may be different from the
 		 * default signal on connector). */
-		struct core_link *link = dc->links[i];
+		struct dc_link *link = dc->links[i];
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
 
@@ -2283,11 +2283,11 @@ void dce110_fill_display_configs(
 		cfg->transmitter =
 			stream->sink->link->link_enc->transmitter;
 		cfg->link_settings.lane_count =
-			stream->sink->link->public.cur_link_settings.lane_count;
+			stream->sink->link->cur_link_settings.lane_count;
 		cfg->link_settings.link_rate =
-			stream->sink->link->public.cur_link_settings.link_rate;
+			stream->sink->link->cur_link_settings.link_rate;
 		cfg->link_settings.link_spread =
-			stream->sink->link->public.cur_link_settings.link_spread;
+			stream->sink->link->cur_link_settings.link_spread;
 		cfg->sym_clock = stream->phy_pix_clk;
 		/* Round v_refresh*/
 		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 0fcb1cf..015306a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -781,7 +781,7 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct core_link *link = stream->sink->link;
+		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index 80f0673..ca1e13e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -730,7 +730,7 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct core_link *link = stream->sink->link;
+		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5861b3f..b2319db 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -677,7 +677,7 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct core_link *link = stream->sink->link;
+		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4390023..c25a392 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -628,7 +628,7 @@ static void dcn10_init_hw(struct core_dc *dc)
 		 * required signal (which may be different from the
 		 * default signal on connector).
 		 */
-		struct core_link *link = dc->links[i];
+		struct dc_link *link = dc->links[i];
 
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
@@ -2259,7 +2259,7 @@ static void dcn10_config_stereo_parameters(
 			timing_3d_format == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA ||
 			timing_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {
 			enum display_dongle_type dongle = \
-					stream->sink->link->public.ddc->dongle_type;
+					stream->sink->link->ddc->dongle_type;
 			if (dongle == DISPLAY_DONGLE_DP_VGA_CONVERTER ||
 				dongle == DISPLAY_DONGLE_DP_DVI_CONVERTER ||
 				dongle == DISPLAY_DONGLE_DP_HDMI_CONVERTER)
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index eec0d5b..0110a43 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -845,7 +845,7 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct core_link *link = stream->sink->link;
+		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_dc.h b/drivers/gpu/drm/amd/display/dc/inc/core_dc.h
index 17f5e46..408ed3a 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_dc.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_dc.h
@@ -20,7 +20,7 @@ struct core_dc {
 	struct dc_context *ctx;
 
 	uint8_t link_count;
-	struct core_link *links[MAX_PIPES * 2];
+	struct dc_link *links[MAX_PIPES * 2];
 
 	struct validate_context *current_context;
 	struct resource_pool *res_pool;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 07a1aec..6cdfeeb 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -92,13 +92,11 @@ struct core_sink {
 
 	/** The 'protected' area - read/write access, for use only inside DC **/
 	/* not used for now */
-	struct core_link *link;
+	struct dc_link *link;
 	struct dc_context *ctx;
 };
 
 /************ link *****************/
-#define DC_LINK_TO_CORE(dc_link) container_of(dc_link, struct core_link, public)
-
 struct link_init_data {
 	const struct core_dc *dc;
 	struct dc_context *ctx; /* TODO: remove 'dal' when DC is complete. */
@@ -107,61 +105,15 @@ struct link_init_data {
 				TODO: remove it when DC is complete. */
 };
 
-/* DP MST stream allocation (payload bandwidth number) */
-struct link_mst_stream_allocation {
-	/* DIG front */
-	const struct stream_encoder *stream_enc;
-	/* associate DRM payload table with DC stream encoder */
-	uint8_t vcp_id;
-	/* number of slots required for the DP stream in transport packet */
-	uint8_t slot_count;
-};
-
-/* DP MST stream allocation table */
-struct link_mst_stream_allocation_table {
-	/* number of DP video streams */
-	int stream_count;
-	/* array of stream allocations */
-	struct link_mst_stream_allocation
-	stream_allocations[MAX_CONTROLLER_NUM];
-};
-
-struct core_link {
-	struct dc_link public;
-	const struct core_dc *dc;
-
-	struct dc_context *ctx; /* TODO: AUTO remove 'dal' when DC is complete*/
-
-	struct link_encoder *link_enc;
-	struct graphics_object_id link_id;
-	union ddi_channel_mapping ddi_channel_mapping;
-	struct connector_device_tag_info device_tag;
-	struct dpcd_caps dpcd_caps;
-	unsigned int dpcd_sink_count;
-
-	enum edp_revision edp_revision;
-	bool psr_enabled;
-
-	/* MST record stream using this link */
-	struct link_flags {
-		bool dp_keep_receiver_powered;
-	} wa_flags;
-	struct link_mst_stream_allocation_table mst_stream_alloc_table;
-
-	struct dc_link_status link_status;
-};
-
-#define DC_LINK_TO_LINK(dc_link) container_of(dc_link, struct core_link, public)
-
-struct core_link *link_create(const struct link_init_data *init_params);
-void link_destroy(struct core_link **link);
+struct dc_link *link_create(const struct link_init_data *init_params);
+void link_destroy(struct dc_link **link);
 
 enum dc_status dc_link_validate_mode_timing(
 		const struct core_stream *stream,
-		struct core_link *link,
+		struct dc_link *link,
 		const struct dc_crtc_timing *timing);
 
-void core_link_resume(struct core_link *link);
+void core_link_resume(struct dc_link *link);
 
 void core_link_enable_stream(struct pipe_ctx *pipe_ctx);
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dc_link_ddc.h b/drivers/gpu/drm/amd/display/dc/inc/dc_link_ddc.h
index 9c2f670..af7ea5e 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dc_link_ddc.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dc_link_ddc.h
@@ -84,7 +84,7 @@ void dal_ddc_aux_payloads_add(
 struct ddc_service_init_data {
 	struct graphics_object_id id;
 	struct dc_context *ctx;
-	struct core_link *link;
+	struct dc_link *link;
 };
 
 struct ddc_service *dal_ddc_service_create(
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
index b6ef1bf..d9af028 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
@@ -29,12 +29,12 @@
 #define LINK_TRAINING_ATTEMPTS 4
 #define LINK_TRAINING_RETRY_DELAY 50 /* ms */
 
-struct core_link;
+struct dc_link;
 struct core_stream;
 struct dc_link_settings;
 
 bool dp_hbr_verify_link_cap(
-	struct core_link *link,
+	struct dc_link *link,
 	struct dc_link_settings *known_limit_link_setting);
 
 bool decide_fallback_link_setting(struct dc_link_settings link_setting_init,
@@ -46,7 +46,7 @@ struct dc_link_settings get_common_supported_link_settings (
 		struct dc_link_settings link_setting_b);
 
 bool dp_validate_mode_timing(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct dc_crtc_timing *timing);
 
 void decide_link_settings(
@@ -54,17 +54,17 @@ void decide_link_settings(
 	struct dc_link_settings *link_setting);
 
 bool perform_link_training_with_retries(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct dc_link_settings *link_setting,
 	bool skip_video_pattern,
 	int attempts);
 
-bool is_mst_supported(struct core_link *link);
+bool is_mst_supported(struct dc_link *link);
 
-void detect_dp_sink_caps(struct core_link *link);
+void detect_dp_sink_caps(struct dc_link *link);
 
-bool is_dp_active_dongle(const struct core_link *link);
+bool is_dp_active_dongle(const struct dc_link *link);
 
-void dp_enable_mst_on_sink(struct core_link *link, bool enable);
+void dp_enable_mst_on_sink(struct dc_link *link, bool enable);
 
 #endif /* __DC_LINK_DP_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h
index 6067f46..e34b259 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h
@@ -39,7 +39,7 @@ struct dmcu_funcs {
 			unsigned int bytes);
 	void (*set_psr_enable)(struct dmcu *dmcu, bool enable);
 	void (*setup_psr)(struct dmcu *dmcu,
-			struct core_link *link,
+			struct dc_link *link,
 			struct psr_context *psr_context);
 	void (*get_psr_state)(struct dmcu *dmcu, uint32_t *psr_state);
 	void (*set_psr_wait_loop)(struct dmcu *dmcu,
diff --git a/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h b/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h
index 75d10e9..f7994cf 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/link_hwss.h
@@ -29,46 +29,46 @@
 #include "inc/core_status.h"
 
 enum dc_status core_link_read_dpcd(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t address,
 	uint8_t *data,
 	uint32_t size);
 
 enum dc_status core_link_write_dpcd(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t address,
 	const uint8_t *data,
 	uint32_t size);
 
 void dp_enable_link_phy(
-	struct core_link *link,
+	struct dc_link *link,
 	enum signal_type signal,
 	enum clock_source_id clock_source,
 	const struct dc_link_settings *link_settings);
 
-void dp_receiver_power_ctrl(struct core_link *link, bool on);
+void dp_receiver_power_ctrl(struct dc_link *link, bool on);
 
-void dp_disable_link_phy(struct core_link *link, enum signal_type signal);
+void dp_disable_link_phy(struct dc_link *link, enum signal_type signal);
 
-void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal);
+void dp_disable_link_phy_mst(struct dc_link *link, enum signal_type signal);
 
 bool dp_set_hw_training_pattern(
-	struct core_link *link,
+	struct dc_link *link,
 	enum hw_dp_training_pattern pattern);
 
 void dp_set_hw_lane_settings(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct link_training_settings *link_settings);
 
 void dp_set_hw_test_pattern(
-	struct core_link *link,
+	struct dc_link *link,
 	enum dp_test_pattern test_pattern,
 	uint8_t *custom_pattern,
 	uint32_t custom_pattern_size);
 
-enum dp_panel_mode dp_get_panel_mode(struct core_link *link);
+enum dp_panel_mode dp_get_panel_mode(struct dc_link *link);
 
-void dp_retrain_link_dp_test(struct core_link *link,
+void dp_retrain_link_dp_test(struct dc_link *link,
 		struct dc_link_settings *link_setting,
 		bool skip_video_pattern);
 
diff --git a/drivers/gpu/drm/amd/display/include/logger_interface.h b/drivers/gpu/drm/amd/display/include/logger_interface.h
index 6e6fd4e..3adf3cf 100644
--- a/drivers/gpu/drm/amd/display/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/display/include/logger_interface.h
@@ -140,19 +140,19 @@ void context_clock_trace(
  */
 
 #define CONN_DATA_DETECT(link, hex_data, hex_len, ...) \
-		dc_conn_log(link->ctx, &link->public, hex_data, hex_len, \
+		dc_conn_log(link->ctx, link, hex_data, hex_len, \
 				LOG_EVENT_DETECTION, ##__VA_ARGS__)
 
 #define CONN_DATA_LINK_LOSS(link, hex_data, hex_len, ...) \
-		dc_conn_log(link->ctx, &link->public, hex_data, hex_len, \
+		dc_conn_log(link->ctx, link, hex_data, hex_len, \
 				LOG_EVENT_LINK_LOSS, ##__VA_ARGS__)
 
 #define CONN_MSG_LT(link, ...) \
-		dc_conn_log(link->ctx, &link->public, NULL, 0, \
+		dc_conn_log(link->ctx, link, NULL, 0, \
 				LOG_EVENT_LINK_TRAINING, ##__VA_ARGS__)
 
 #define CONN_MSG_MODE(link, ...) \
-		dc_conn_log(link->ctx, &link->public, NULL, 0, \
+		dc_conn_log(link->ctx, link, NULL, 0, \
 				LOG_EVENT_MODE_SET, ##__VA_ARGS__)
 
 #endif /* __DAL_LOGGER_INTERFACE_H__ */
-- 
2.7.4

