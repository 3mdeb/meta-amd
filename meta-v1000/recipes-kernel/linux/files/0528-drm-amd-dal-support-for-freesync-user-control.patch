From 612cbefce4fda9f78217b22e3cf9d2c3b9f261b9 Mon Sep 17 00:00:00 2001
From: Amy Zhang <Amy.Zhang@amd.com>
Date: Thu, 12 May 2016 16:49:46 -0400
Subject: [PATCH 0528/1722] drm/amd/dal: support for freesync user control.

Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../gpu/drm/amd/dal/modules/freesync/freesync.c    | 198 ++++++++++++++++-----
 drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h |  24 ++-
 2 files changed, 172 insertions(+), 50 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
index fda9fe9..a50a0c1 100644
--- a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
@@ -30,25 +30,26 @@
 static const MOD_FREESYNC_MAX_CONCURRENT_SINKS = 32;
 
 struct sink_caps {
-	const struct dc_sink *sink;
-	struct mod_freesync_caps caps;
+        const struct dc_sink *sink;
+        struct mod_freesync_caps caps;
 };
 
 struct freesync_state {
-     bool fullscreen;
-     bool static_screen;
+        bool fullscreen;
+        bool static_screen;
 };
 
 struct core_freesync {
-	struct mod_freesync public;
-	struct dc *dc;
-	struct sink_caps *caps;
+        struct mod_freesync public;
+        struct dc *dc;
+        struct sink_caps *caps;
         struct freesync_state *state;
-	int num_sinks;
+        struct mod_freesync_user_enable *user_enable;
+        int num_sinks;
 };
 
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
-		container_of(mod_freesync, struct core_freesync, public)
+                container_of(mod_freesync, struct core_freesync, public)
 
 static bool check_dc_support(const struct dc *dc)
 {
@@ -60,22 +61,32 @@ static bool check_dc_support(const struct dc *dc)
 
 struct mod_freesync *mod_freesync_create(struct dc *dc)
 {
-	struct core_freesync *core_freesync = dm_alloc(sizeof(struct core_freesync));
+	struct core_freesync *core_freesync =
+			dm_alloc(sizeof(struct core_freesync));
 	int i = 0;
 
 	if (core_freesync == NULL)
 		goto fail_alloc_context;
 
-	core_freesync->caps = dm_alloc(sizeof(struct sink_caps) * MOD_FREESYNC_MAX_CONCURRENT_SINKS);
+	core_freesync->caps = dm_alloc(sizeof(struct sink_caps) *
+			MOD_FREESYNC_MAX_CONCURRENT_SINKS);
 
 	if (core_freesync->caps == NULL)
 		goto fail_alloc_caps;
 
-	core_freesync->state = dm_alloc(sizeof(struct freesync_state) * MOD_FREESYNC_MAX_CONCURRENT_SINKS);
+	core_freesync->state = dm_alloc(sizeof(struct freesync_state) *
+			MOD_FREESYNC_MAX_CONCURRENT_SINKS);
 
 	if (core_freesync->state == NULL)
 		goto fail_alloc_state;
 
+	core_freesync->user_enable =
+			dm_alloc(sizeof(struct mod_freesync_user_enable) *
+					MOD_FREESYNC_MAX_CONCURRENT_SINKS);
+
+	if (core_freesync->user_enable == NULL)
+		goto fail_alloc_user_enable;
+
 	for (i = 0; i < MOD_FREESYNC_MAX_CONCURRENT_SINKS; i++)
 		core_freesync->caps[i].sink = NULL;
 
@@ -92,6 +103,9 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	return &core_freesync->public;
 
 fail_construct:
+	dm_free(core_freesync->user_enable);
+
+fail_alloc_user_enable:
 	dm_free(core_freesync->state);
 
 fail_alloc_state:
@@ -108,15 +122,18 @@ void mod_freesync_destroy(struct mod_freesync *mod_freesync)
 {
 	if (mod_freesync != NULL) {
 		int i;
-		struct core_freesync *core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+		struct core_freesync *core_freesync =
+				MOD_FREESYNC_TO_CORE(mod_freesync);
 
 		for (i = 0; i < core_freesync->num_sinks; i++)
 			dc_sink_release(core_freesync->caps[i].sink);
 
-		dm_free(core_freesync->caps);
+		dm_free(core_freesync->user_enable);
 
 		dm_free(core_freesync->state);
 
+		dm_free(core_freesync->caps);
+
 		dm_free(core_freesync);
 	}
 }
@@ -125,7 +142,8 @@ bool mod_freesync_add_sink(struct mod_freesync *mod_freesync,
 		const struct dc_sink *sink, struct mod_freesync_caps *caps)
 {
 	int i = 0;
-	struct core_freesync *core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	if (core_freesync->num_sinks < MOD_FREESYNC_MAX_CONCURRENT_SINKS) {
 		dc_sink_retain(sink);
@@ -144,14 +162,17 @@ bool mod_freesync_remove_sink(struct mod_freesync *mod_freesync,
 		const struct dc_sink *sink)
 {
 	int i = 0, j = 0;
-	struct core_freesync *core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	for (i = 0; i < core_freesync->num_sinks; i++) {
 		if (core_freesync->caps[i].sink == sink) {
-			/* To remove this sink, shift everything after it down */
+			/* To remove this sink, shift everything after down */
 			for (j = i; j < core_freesync->num_sinks - 1; j++) {
-				core_freesync->caps[j].sink = core_freesync->caps[j + 1].sink;
-				core_freesync->caps[j].caps = core_freesync->caps[j + 1].caps;
+				core_freesync->caps[j].sink =
+						core_freesync->caps[j + 1].sink;
+				core_freesync->caps[j].caps =
+						core_freesync->caps[j + 1].caps;
 			}
 
 			core_freesync->num_sinks--;
@@ -169,14 +190,13 @@ void mod_freesync_update_stream(struct mod_freesync *mod_freesync,
 		struct dc_stream *stream)
 {
 	int i = 0;
-	struct core_freesync *core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
 
-	for (i = 0; i < core_freesync->num_sinks; i++) {
+	for (i = 0; i < core_freesync->num_sinks; i++)
 		if (core_freesync->caps[i].sink == stream->sink &&
-			core_freesync->caps[i].caps.supported) {
+				core_freesync->caps[i].caps.supported)
 			stream->ignore_msa_timing_param = 1;
-		}
-	}
 }
 
 static void calc_vmin_vmax (const struct dc_stream *stream,
@@ -186,15 +206,18 @@ static void calc_vmin_vmax (const struct dc_stream *stream,
 
 	unsigned int min_frame_duration_in_ns = 0, max_frame_duration_in_ns = 0;
 
-	min_frame_duration_in_ns = (unsigned int)((1000000000ULL * 1000000) / caps->maxRefreshInMicroHz);
-	max_frame_duration_in_ns = (unsigned int)((1000000000ULL * 1000000) / caps->minRefreshInMicroHz);
+	min_frame_duration_in_ns = (unsigned int)
+			((1000000000ULL * 1000000) / caps->maxRefreshInMicroHz);
+	max_frame_duration_in_ns = (unsigned int)
+			((1000000000ULL * 1000000) / caps->minRefreshInMicroHz);
 
-	*vmax = (unsigned long long)(max_frame_duration_in_ns) * stream->timing.pix_clk_khz / stream->timing.h_total / 1000000;
-	*vmin = (unsigned long long)(min_frame_duration_in_ns) * stream->timing.pix_clk_khz / stream->timing.h_total / 1000000;
+	*vmax = (unsigned long long)(max_frame_duration_in_ns) *
+		stream->timing.pix_clk_khz / stream->timing.h_total / 1000000;
+	*vmin = (unsigned long long)(min_frame_duration_in_ns) *
+		stream->timing.pix_clk_khz / stream->timing.h_total / 1000000;
 
-	if (*vmin < stream->timing.v_total) {
-	    *vmin = stream->timing.v_total;
-	}
+	if (*vmin < stream->timing.v_total)
+		*vmin = stream->timing.v_total;
 }
 
 
@@ -217,18 +240,19 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 	 * matter if it is static screen. We should not check the
 	 * static_screen bit - we want to enable freesync regardless.
 	 */
-	if (core_freesync->state->fullscreen == true) {
+	if (core_freesync->user_enable->enable_for_gaming == true &&
+			core_freesync->state->fullscreen == true) {
 		/* Enable freesync */
 		for (i = 0; i < core_freesync->num_sinks; i++) {
 			if (core_freesync->caps[i].sink == streams[0]->sink &&
-				core_freesync->caps[i].caps.supported) {
+					core_freesync->caps[i].caps.supported) {
 
 				calc_vmin_vmax(streams[0],
-							   &core_freesync->caps[i].caps,
-							   &v_total_min, &v_total_max);
+						&core_freesync->caps[i].caps,
+						&v_total_min, &v_total_max);
 
 				core_freesync->dc->stream_funcs.
-					dc_stream_adjust_vmin_vmax(
+				dc_stream_adjust_vmin_vmax(
 						core_freesync->dc, streams,
 						num_streams, v_total_min,
 						v_total_max);
@@ -236,18 +260,19 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 				return true;
 			}
 		}
-	} else if (core_freesync->state->static_screen == true)	{
+	} else if ( core_freesync->user_enable->enable_for_static == true &&
+			core_freesync->state->static_screen == true)	{
 		/* Enable Static Screen */
 		for (i = 0; i < core_freesync->num_sinks; i++) {
 			if (core_freesync->caps[i].sink == streams[0]->sink &&
-				core_freesync->caps[i].caps.supported) {
+					core_freesync->caps[i].caps.supported) {
 
 				calc_vmin_vmax(streams[0],
-							   &core_freesync->caps[i].caps,
-							   &v_total_min, &v_total_max);
+						&core_freesync->caps[i].caps,
+						&v_total_min, &v_total_max);
 
 				core_freesync->dc->stream_funcs.
-					dc_stream_adjust_vmin_vmax(
+				dc_stream_adjust_vmin_vmax(
 						core_freesync->dc, streams,
 						num_streams, v_total_max,
 						v_total_max);
@@ -260,7 +285,7 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 		v_total_nominal = streams[0]->timing.v_total;
 
 		core_freesync->dc->stream_funcs.
-			dc_stream_adjust_vmin_vmax(
+		dc_stream_adjust_vmin_vmax(
 				core_freesync->dc, streams, num_streams,
 				v_total_nominal, v_total_nominal);
 
@@ -270,27 +295,51 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 	return false;
 }
 
+
+/* Given a specific dc_sink* this function finds its equivalent
+ * on the dc_sink array and returns the corresponding index
+ */
+static unsigned int sink_index_from_sink(struct core_freesync *core_freesync,
+		const struct dc_sink * sink)
+{
+	unsigned int index;
+
+	for(index = 0; index < core_freesync->num_sinks; index++)
+		if(core_freesync->caps[index].sink == sink)
+			break;
+
+	return index;
+}
+
+
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams,
-		unsigned int displayIndex,
 		enum mod_freesync_state freesyncState, bool enable)
 {
-	struct core_freesync *core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int stream_index;
+
+	for(stream_index = 0; stream_index < num_streams;
+			stream_index++){
 
-	switch (freesyncState)
-	{
+		unsigned int sink_index = sink_index_from_sink(core_freesync,
+				streams[stream_index]->sink);
+
+		switch (freesyncState){
 		case FREESYNC_STATE_FULLSCREEN:
-			core_freesync->state[displayIndex].fullscreen = enable;
+			core_freesync->state[sink_index].fullscreen = enable;
 			break;
 
 		case FREESYNC_STATE_STATIC_SCREEN:
-			core_freesync->state[displayIndex].static_screen = enable;
+			core_freesync->state[sink_index].static_screen = enable;
 			break;
+		}
 	}
 
 	/* Program freesync according to current state*/
 	set_freesync_on_streams(core_freesync, streams, num_streams);
-
 }
 
 void mod_freesync_vupdate_callback(struct mod_freesync *mod_freesync,
@@ -298,3 +347,54 @@ void mod_freesync_vupdate_callback(struct mod_freesync *mod_freesync,
 {
 
 }
+
+
+bool mod_freesync_get_freesync_caps(struct mod_freesync *mod_freesync,
+		const struct dc_sink *sink, struct mod_freesync_caps *caps)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int sink_index = sink_index_from_sink(core_freesync, sink);
+
+	*caps = core_freesync->caps[sink_index].caps;
+
+	return true;
+}
+
+bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams,
+		struct mod_freesync_user_enable *user_enable)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int stream_index;
+
+	for(stream_index = 0; stream_index < num_streams;
+			stream_index++){
+
+		unsigned int sink_index = sink_index_from_sink(core_freesync,
+				streams[stream_index]->sink);
+
+		core_freesync->user_enable[sink_index] = *user_enable;
+	}
+
+	set_freesync_on_streams(core_freesync, streams, num_streams);
+
+	return true;
+}
+
+bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
+		const struct dc_sink *sink,
+		struct mod_freesync_user_enable *user_enable)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int sink_index = sink_index_from_sink(core_freesync, sink);
+
+	*user_enable = core_freesync->user_enable[sink_index];
+
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h b/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h
index c3622e9..48cd7d3 100644
--- a/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h
+++ b/drivers/gpu/drm/amd/dal/modules/inc/mod_freesync.h
@@ -37,6 +37,18 @@ enum mod_freesync_state {
     FREESYNC_STATE_STATIC_SCREEN
 };
 
+enum mod_freesync_user_enable_mask {
+    FREESYNC_USER_ENABLE_STATIC = 0x1,
+    FREESYNC_USER_ENABLE_VIDEO = 0x2,
+    FREESYNC_USER_ENABLE_GAMING = 0x4
+};
+
+struct mod_freesync_user_enable {
+	bool enable_for_static;
+	bool enable_for_video;
+	bool enable_for_gaming;
+};
+
 struct mod_freesync_caps {
 	bool supported;
 	int minRefreshInMicroHz;
@@ -71,7 +83,6 @@ void mod_freesync_update_stream(struct mod_freesync *mod_freesync,
  */
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams,
-		unsigned int displayIndex,
 		enum mod_freesync_state freesyncState, bool enable);
 
 /*
@@ -82,4 +93,15 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 void mod_freesync_vupdate_callback(struct mod_freesync *mod_freesync,
 	struct dc_stream *stream);
 
+bool mod_freesync_get_freesync_caps(struct mod_freesync *mod_freesync,
+		const struct dc_sink *sink, struct mod_freesync_caps *caps);
+
+bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams,
+		struct mod_freesync_user_enable *user_enable);
+
+bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
+		const struct dc_sink *sink,
+		struct mod_freesync_user_enable *user_enable);
+
 #endif
-- 
2.7.4

