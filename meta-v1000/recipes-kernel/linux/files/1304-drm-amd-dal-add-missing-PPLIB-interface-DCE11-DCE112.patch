From e7f88e3ff7fb13c1d0b02f54b5432ec483bfd15f Mon Sep 17 00:00:00 2001
From: Hersen Wu <hersenxs.wu@amd.com>
Date: Tue, 4 Oct 2016 17:35:46 -0400
Subject: [PATCH 1304/1722] drm/amd/dal: add missing PPLIB interface DCE11,
 DCE112

Change-Id: I8226e38226b8faab408eee4e673ce9ac7c5e8fc4
Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c |  50 +++
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  20 ++
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  13 +
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 207 ++++++------
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  54 ++++
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.h    |   3 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    | 346 ++++++++++++++++++---
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  54 ++++
 drivers/gpu/drm/amd/dal/dc/dm_services.h           |  26 ++
 drivers/gpu/drm/amd/dal/dc/dm_services_types.h     |  86 ++++-
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |  29 +-
 .../amd/dal/dc/gpu/dce112/display_clock_dce112.c   |  34 +-
 .../drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c |  36 ++-
 drivers/gpu/drm/amd/dal/dc/gpu/display_clock.h     |  23 ++
 .../drm/amd/dal/include/display_clock_interface.h  |  18 +-
 15 files changed, 829 insertions(+), 170 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
index fd7d93f..1361595 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
@@ -404,6 +404,56 @@ bool dm_pp_get_clock_levels_by_type(
 	return true;
 }
 
+bool dm_pp_get_clock_levels_by_type_with_latency(
+	const struct dc_context *ctx,
+	enum dm_pp_clock_type clk_type,
+	struct dm_pp_clock_levels_with_latency *clk_level_info)
+{
+	/* TODO: to be implemented */
+	return true;
+}
+
+bool dm_pp_get_clock_levels_by_type_with_voltage(
+	const struct dc_context *ctx,
+	enum dm_pp_clock_type clk_type,
+	struct dm_pp_clock_levels_with_voltage *clk_level_info)
+{
+	/* TODO: to be implemented */
+	return true;
+}
+
+bool dm_pp_notify_wm_clock_changes(
+	const struct dc_context *ctx,
+	struct dm_pp_wm_sets_with_clock_ranges *wm_with_clock_ranges)
+{
+	/* TODO: to be implemented */
+	return true;
+}
+
+bool dm_pp_apply_power_level_change_request(
+	const struct dc_context *ctx,
+	struct dm_pp_power_level_change_request *level_change_req)
+{
+	/* TODO: to be implemented */
+	return true;
+}
+
+bool dm_pp_apply_clock_for_voltage_request(
+	const struct dc_context *ctx,
+	struct dm_pp_clock_for_voltage_req *clock_for_voltage_req)
+{
+	/* TODO: to be implemented */
+	return true;
+}
+
+bool dm_pp_get_static_clocks(
+	const struct dc_context *ctx,
+	struct dm_pp_static_clock_info *static_clk_info)
+{
+	/* TODO: to be implemented */
+	return true;
+}
+
 /**** end of power component interfaces ****/
 
 /* Calls to notification */
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 9b46159..0cc6d3e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -1220,9 +1220,29 @@ static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 	struct core_link *link = stream->sink->link;
 	struct dc_link_settings link_settings = {0};
 	enum dp_panel_mode panel_mode;
+	enum clocks_state cur_min_clock_state;
+	enum dc_link_rate max_link_rate = LINK_RATE_HIGH2;
 
 	/* get link settings for video mode timing */
 	decide_link_settings(stream, &link_settings);
+
+	/* raise clock state for HBR3 if required. Confirmed with HW DCE/DPCS
+	 * logic for HBR3 still needs Nominal (0.8V) on VDDC rail
+	 */
+
+	if (link->link_enc->features.flags.bits.IS_HBR3_CAPABLE)
+		max_link_rate = LINK_RATE_HIGH3;
+
+	if (link_settings.link_rate == max_link_rate) {
+		cur_min_clock_state = dal_display_clock_get_min_clocks_state(
+				pipe_ctx->dis_clk);
+
+		if (cur_min_clock_state < CLOCKS_STATE_NOMINAL)
+			dal_display_clock_set_min_clocks_state(
+					pipe_ctx->dis_clk,
+					CLOCKS_STATE_NOMINAL);
+	}
+
 	dp_enable_link_phy(
 		link,
 		pipe_ctx->stream->signal,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 6cb7465..2cf3be4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -793,6 +793,7 @@ static bool construct(
 	struct dc_context *ctx = dc->ctx;
 	struct firmware_info info;
 	struct dc_bios *bp;
+	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	pool->base.adapter_srv = as;
 	pool->base.funcs = &dce100_res_pool_funcs;
@@ -852,6 +853,18 @@ static bool construct(
 		goto disp_clk_create_fail;
 	}
 
+	/* get static clock information for PPLIB or firmware, save
+	 * max_clock_state
+	 */
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info)) {
+		enum clocks_state max_clocks_state =
+			dce110_resource_convert_clock_state_pp_to_dc(
+					static_clk_info.max_clocks_state);
+
+		dal_display_clock_store_max_clocks_state(
+				pool->base.display_clock, max_clocks_state);
+	}
+
 	{
 		struct irq_service_init_data init_data;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 6e63007..636f9fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -975,115 +975,6 @@ static void enable_accelerated_mode(struct core_dc *dc)
 	dce110_set_scratch_acc_mode_change(dc->ctx);
 }
 
-#if 0
-static enum clocks_state get_required_clocks_state(
-	struct display_clock *display_clock,
-	struct state_dependent_clocks *req_state_dep_clks)
-{
-	enum clocks_state clocks_required_state;
-	enum clocks_state dp_link_required_state;
-	enum clocks_state overall_required_state;
-
-	clocks_required_state = dal_display_clock_get_required_clocks_state(
-			display_clock, req_state_dep_clks);
-
-	dp_link_required_state = CLOCKS_STATE_ULTRA_LOW;
-
-	/* overall required state is the max of required state for clocks
-	 * (pixel, display clock) and the required state for DP link. */
-	overall_required_state =
-		clocks_required_state > dp_link_required_state ?
-			clocks_required_state : dp_link_required_state;
-
-	/* return the min required state */
-	return overall_required_state;
-}
-
-static bool dc_pre_clock_change(
-		struct dc_context *ctx,
-		struct minimum_clocks_calculation_result *min_clk_in,
-		enum clocks_state required_clocks_state,
-		struct power_to_dal_info *output)
-{
-	struct dal_to_power_info input = {0};
-
-	input.min_deep_sleep_sclk = min_clk_in->min_deep_sleep_sclk;
-	input.min_mclk = min_clk_in->min_mclk_khz;
-	input.min_sclk = min_clk_in->min_sclk_khz;
-
-	switch (required_clocks_state) {
-	case CLOCKS_STATE_ULTRA_LOW:
-		input.required_clock = PP_CLOCKS_STATE_ULTRA_LOW;
-		break;
-	case CLOCKS_STATE_LOW:
-		input.required_clock = PP_CLOCKS_STATE_LOW;
-		break;
-	case CLOCKS_STATE_NOMINAL:
-		input.required_clock = PP_CLOCKS_STATE_NOMINAL;
-		break;
-	case CLOCKS_STATE_PERFORMANCE:
-		input.required_clock = PP_CLOCKS_STATE_PERFORMANCE;
-		break;
-	default:
-		input.required_clock = PP_CLOCKS_STATE_NOMINAL;
-		break;
-	}
-
-	if (!dc_service_pp_pre_dce_clock_change(ctx, &input, output)) {
-		dm_error("DC: dc_service_pp_pre_dce_clock_change failed!\n");
-		return false;
-	}
-
-	return true;
-}
-
-static bool dc_set_clocks_and_clock_state (
-		struct validate_context *context)
-{
-	struct power_to_dal_info output = {0};
-
-	struct display_clock *disp_clk = context->res_ctx.pool->display_clock;
-	struct dc_context *ctx = context->targets[0]->ctx;
-
-	if (!dc_pre_clock_change(
-			ctx,
-			&context->res_ctx.min_clocks,
-			get_required_clocks_state(
-					context->res_ctx.pool->display_clock,
-					&context->res_ctx.state_clocks),
-			&output)) {
-		/* "output" was not updated by PPLib.
-		 * DAL will use default values for set mode.
-		 *
-		 * Do NOT fail this call. */
-		return true;
-	}
-
-	/* PPLib accepted the "clock state" that we need, that means we
-	 * can store it as minimum state because PPLib guarantees not go below
-	 * that state.
-	 *
-	 * Update the clock state here (prior to setting Pixel clock,
-	 * or Display clock)
-	 **/
-	if (!dal_display_clock_set_min_clocks_state(
-			disp_clk, context->res_ctx.required_clocks_state)) {
-		BREAK_TO_DEBUGGER();
-		dm_error("DC: failed to set minimum clock state!\n");
-	}
-
-	/*bm_clk_info.max_mclk_khz = output.max_mclk;
-	bm_clk_info.min_mclk_khz = output.min_mclk;
-	bm_clk_info.max_sclk_khz = output.max_sclk;
-	bm_clk_info.min_sclk_khz = output.min_sclk;*/
-
-	/* Now let Bandwidth Manager know about values we got from PPLib. */
-	/*dal_bandwidth_manager_set_dynamic_clock_info(bw_mgr, &bm_clk_info);*/
-
-	return true;
-}
-#endif
-
 /**
  * Call display_engine_clock_dce80 to perform the Dclk programming.
  */
@@ -1330,7 +1221,8 @@ static void reset_single_pipe_hw_ctx(
 	pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
 	pipe_ctx->mi->funcs->free_mem_input(
 				pipe_ctx->mi, context->target_count);
-	resource_unreference_clock_source(&context->res_ctx, pipe_ctx->clock_source);
+	resource_unreference_clock_source(
+			&context->res_ctx, pipe_ctx->clock_source);
 
 	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
 
@@ -1346,7 +1238,9 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;
 
-	/* TODO: If multiple pipes are to be supported, you need some GSL stuff */
+	/* TODO: If multiple pipes are to be supported, you need
+	 * some GSL stuff
+	 */
 
 	for (i = 0; i < num_pipes; i++) {
 		pipe_ctx[i]->tg->funcs->set_drr(pipe_ctx[i]->tg, &params);
@@ -1362,6 +1256,90 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		pipe_ctx[i]->tg->funcs->
 			set_static_screen_control(pipe_ctx[i]->tg, value);
 }
+
+/* unit: in_khz before mode set, get pixel clock from context. ASIC register
+ * may not be programmed yet.
+ * TODO: after mode set, pre_mode_set = false,
+ * may read PLL register to get pixel clock
+ */
+static uint32_t get_max_pixel_clock_for_all_paths(
+	struct core_dc *dc,
+	struct validate_context *context,
+	bool pre_mode_set)
+{
+	uint32_t max_pix_clk = 0;
+	int i;
+
+	if (!pre_mode_set) {
+		/* TODO: read ASIC register to get pixel clock */
+		ASSERT(0);
+	}
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		/* do not check under lay */
+		if (pipe_ctx->top_pipe)
+			continue;
+
+		if (pipe_ctx->pix_clk_params.requested_pix_clk > max_pix_clk)
+			max_pix_clk =
+				pipe_ctx->pix_clk_params.requested_pix_clk;
+	}
+
+	if (max_pix_clk == 0)
+		ASSERT(0);
+
+	return max_pix_clk;
+}
+
+/* Find clock state based on clock requested. if clock value is 0, simply
+ * set clock state as requested without finding clock state by clock value
+ */
+static void set_clock_state(
+	struct core_dc *dc,
+	struct validate_context *context,
+	enum clocks_state *clocks_state,
+	bool set_stsate_only)
+{
+	struct state_dependent_clocks req_clocks = {0};
+	struct pipe_ctx *pipe_ctx;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		if (pipe_ctx->dis_clk != NULL)
+			break;
+	}
+
+	if (set_stsate_only) {
+		/* set clock_state without verification */
+		dal_display_clock_set_min_clocks_state(
+				pipe_ctx->dis_clk, *clocks_state);
+
+		return;
+	}
+
+	/* get the required state based on state dependent clocks:
+	 * display clock and pixel clock
+	 */
+	req_clocks.display_clk_khz = context->bw_results.dispclk_khz;
+
+	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
+			dc, context, true);
+
+	*clocks_state =
+		dal_display_clock_get_required_clocks_state(
+				pipe_ctx->dis_clk, &req_clocks);
+
+
+	dal_display_clock_set_min_clocks_state(
+			pipe_ctx->dis_clk, *clocks_state);
+}
+
 /*TODO: const validate_context*/
 static enum dc_status apply_ctx_to_hw(
 		struct core_dc *dc,
@@ -1370,6 +1348,7 @@ static enum dc_status apply_ctx_to_hw(
 	enum dc_status status;
 	int i;
 	bool programmed_audio_dto = false;
+	enum clocks_state clocks_state = CLOCKS_STATE_INVALID;
 
 	/* Reset old context */
 	/* look up the targets that have been removed since last commit */
@@ -1426,7 +1405,8 @@ static enum dc_status apply_ctx_to_hw(
 
 	set_safe_displaymarks(&context->res_ctx);
 	/*TODO: when pplib works*/
-	/*dc_set_clocks_and_clock_state(context);*/
+	/* dc_set_clocks_and_clock_state(context); */
+	set_clock_state(dc, context, &clocks_state, false);
 
 	if (context->bw_results.dispclk_khz
 		> dc->current_context->bw_results.dispclk_khz)
@@ -1508,6 +1488,9 @@ static enum dc_status apply_ctx_to_hw(
 
 	dc->hwss.set_displaymarks(dc, context);
 
+	/* TODO dc_set_clocks_and_clock_state(context); to save power */
+	set_clock_state(dc, context, &clocks_state, true);
+
 	update_bios_scratch_critical_state(context->res_ctx.pool->adapter_srv, false);
 
 	switch_dp_clock_sources(dc, &context->res_ctx);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index ae71f1b..c4c9cb86 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -1046,6 +1046,47 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 		1000);
 }
 
+enum clocks_state dce110_resource_convert_clock_state_pp_to_dc(
+	enum dm_pp_clocks_state pp_clock_state)
+{
+	enum clocks_state dc_clocks_state = CLOCKS_STATE_INVALID;
+
+	switch (pp_clock_state) {
+	case DM_PP_CLOCKS_STATE_INVALID:
+		dc_clocks_state = CLOCKS_STATE_INVALID;
+		break;
+	case DM_PP_CLOCKS_STATE_ULTRA_LOW:
+		dc_clocks_state = CLOCKS_STATE_ULTRA_LOW;
+		break;
+	case DM_PP_CLOCKS_STATE_LOW:
+		dc_clocks_state = CLOCKS_STATE_LOW;
+		break;
+	case DM_PP_CLOCKS_STATE_NOMINAL:
+		dc_clocks_state = CLOCKS_STATE_NOMINAL;
+		break;
+	case DM_PP_CLOCKS_STATE_PERFORMANCE:
+		dc_clocks_state = CLOCKS_STATE_PERFORMANCE;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_4:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_4;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_5:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_5;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_6:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_6;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_7:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_7;
+		break;
+	default:
+		dc_clocks_state = CLOCKS_STATE_INVALID;
+		break;
+	}
+
+	return dc_clocks_state;
+}
+
 static bool construct(
 	struct adapter_service *as,
 	uint8_t num_virtual_links,
@@ -1057,6 +1098,7 @@ static bool construct(
 	struct dc_context *ctx = dc->ctx;
 	struct firmware_info info;
 	struct dc_bios *bp;
+	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	pool->base.adapter_srv = as;
 	pool->base.funcs = &dce110_res_pool_funcs;
@@ -1127,6 +1169,18 @@ static bool construct(
 		goto disp_clk_create_fail;
 	}
 
+	/* get static clock information for PPLIB or firmware, save
+	 * max_clock_state
+	 */
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info)) {
+		enum clocks_state max_clocks_state =
+			dce110_resource_convert_clock_state_pp_to_dc(
+					static_clk_info.max_clocks_state);
+
+		dal_display_clock_store_max_clocks_state(
+				pool->base.display_clock, max_clocks_state);
+	}
+
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
index 05b571e..00799f3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
@@ -41,7 +41,8 @@ struct dce110_resource_pool {
 
 enum dc_status dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx);
 
-
+enum clocks_state dce110_resource_convert_clock_state_pp_to_dc(
+	enum dm_pp_clocks_state pp_clock_state);
 
 struct resource_pool *dce110_create_resource_pool(
 	struct adapter_service *as,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index e256803..5cd46cd 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -961,45 +961,273 @@ static const struct resource_funcs dce112_res_pool_funcs = {
 
 static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 {
-	struct dm_pp_clock_levels clks = {0};
+	struct dm_pp_clock_levels_with_latency eng_clks = {0};
+	struct dm_pp_clock_levels_with_latency mem_clks = {0};
+	struct dm_pp_wm_sets_with_clock_ranges wm_clocks = {0};
 
 	/*do system clock*/
-	dm_pp_get_clock_levels_by_type(
+	dm_pp_get_clock_levels_by_type_with_latency(
 			dc->ctx,
 			DM_PP_CLOCK_TYPE_ENGINE_CLK,
-			&clks);
-	/* convert all the clock fro kHz to fix point mHz */
+			&eng_clks);
+	/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */
 	dc->bw_vbios.high_sclk = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels-1], 1000);
+		eng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);
 	dc->bw_vbios.mid1_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels/8], 1000);
+		eng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);
 	dc->bw_vbios.mid2_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels*2/8], 1000);
+		eng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);
 	dc->bw_vbios.mid3_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels*3/8], 1000);
+		eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);
 	dc->bw_vbios.mid4_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels*4/8], 1000);
+		eng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);
 	dc->bw_vbios.mid5_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels*5/8], 1000);
+		eng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);
 	dc->bw_vbios.mid6_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[clks.num_levels*6/8], 1000);
+		eng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);
 	dc->bw_vbios.low_sclk  = bw_frc_to_fixed(
-			clks.clocks_in_khz[0], 1000);
+			eng_clks.data[0].clocks_in_khz, 1000);
 
 	/*do memory clock*/
-	dm_pp_get_clock_levels_by_type(
+	dm_pp_get_clock_levels_by_type_with_latency(
 			dc->ctx,
 			DM_PP_CLOCK_TYPE_MEMORY_CLK,
-			&clks);
+			&mem_clks);
 
 	dc->bw_vbios.low_yclk = bw_frc_to_fixed(
-		clks.clocks_in_khz[0] * MEMORY_TYPE_MULTIPLIER, 1000);
+		mem_clks.data[0].clocks_in_khz * MEMORY_TYPE_MULTIPLIER, 1000);
 	dc->bw_vbios.mid_yclk = bw_frc_to_fixed(
-		clks.clocks_in_khz[clks.num_levels>>1] * MEMORY_TYPE_MULTIPLIER,
+mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
 	dc->bw_vbios.high_yclk = bw_frc_to_fixed(
-		clks.clocks_in_khz[clks.num_levels-1] * MEMORY_TYPE_MULTIPLIER,
+mem_clks.data[mem_clks.num_levels-1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
+
+	/* Now notify PPLib/SMU about which Watermarks sets they should select
+	 * depending on DPM state they are in. And update BW MGR GFX Engine and
+	 * Memory clock member variables for Watermarks calculations for each
+	 * Watermark Set
+	 */
+
+	/* default expected case: engineClkInfoWithLatency.numLevels == 8
+	 * && memoryClkInfoWithLatency.numLevels == 3
+	 */
+	wm_clocks.num_wm_sets = 4;
+	wm_clocks.wm_clk_ranges[0].wm_set_id = WM_SET_A;
+	wm_clocks.wm_clk_ranges[0].wm_min_eng_clk_in_khz =
+			eng_clks.data[0].clocks_in_khz;
+	wm_clocks.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
+			eng_clks.data[3].clocks_in_khz - 1;
+	wm_clocks.wm_clk_ranges[0].wm_min_memg_clk_in_khz =
+			mem_clks.data[0].clocks_in_khz;
+	wm_clocks.wm_clk_ranges[0].wm_max_mem_clk_in_khz =
+			mem_clks.data[1].clocks_in_khz - 1;
+
+	/* TODO  TODO TODO  : below is for DWB. Will be-revisted later */
+	/* this GFX E clock is used for Watermark Set A and DWB Watermark
+	 * Set B calculations
+	 */
+	/* m_wmSetClocks.wmSetEngineClocks[WMSetA].clockInKHz =
+	 * m_wmDWBSetBEngineClock = eng_clks.data[0].clocks_in_khz;
+	 */
+	/* this M clock is used for Watermark Set A and DWB Watermark Set B
+	 * calculations
+	 */
+	/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].clockInKHz =
+	 * m_wmDWBSetBMemoryClock = mem_clks.data[0].clocks_in_khz;
+	 */
+	/* this GFX E clock is used for Watermark Set A and DWB Watermark Set
+	 *B calculations
+	 */
+	/* m_wmSetClocks.wmSetEngineClocks[WMSetA].latencyInUs =
+	 * eng_clks.data[0].latency_in_us;
+	 */
+	/* this M clock is used for Watermark Set A and DWB Watermark Set B
+	 * calculations
+	 */
+	/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].latencyInUs =
+	 * mem_clks.data[0].latency_in_us;
+	 */
+
+	wm_clocks.wm_clk_ranges[1].wm_set_id = WM_SET_B;
+	wm_clocks.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
+			eng_clks.data[3].clocks_in_khz;
+	/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */
+	wm_clocks.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;
+	wm_clocks.wm_clk_ranges[1].wm_min_memg_clk_in_khz =
+			mem_clks.data[0].clocks_in_khz;
+	wm_clocks.wm_clk_ranges[1].wm_max_mem_clk_in_khz =
+			mem_clks.data[1].clocks_in_khz - 1;
+
+	wm_clocks.wm_clk_ranges[2].wm_set_id = WM_SET_C;
+	wm_clocks.wm_clk_ranges[2].wm_min_eng_clk_in_khz =
+			eng_clks.data[0].clocks_in_khz;
+	wm_clocks.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
+			eng_clks.data[3].clocks_in_khz - 1;
+	wm_clocks.wm_clk_ranges[2].wm_min_memg_clk_in_khz =
+			mem_clks.data[1].clocks_in_khz;
+	/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */
+	wm_clocks.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;
+
+	wm_clocks.wm_clk_ranges[3].wm_set_id = WM_SET_D;
+	wm_clocks.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
+			eng_clks.data[3].clocks_in_khz;
+	/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */
+	wm_clocks.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;
+	wm_clocks.wm_clk_ranges[3].wm_min_memg_clk_in_khz =
+			mem_clks.data[1].clocks_in_khz;
+	/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */
+	wm_clocks.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;
+
+	/* need to adjust above entries if engineClkInfoWithLatency.numLevels
+	 * != 8 does not need to adjust if memoryClkInfoWithLatency.numLevels
+	 * != 3
+	 */
+	switch (eng_clks.num_levels) {
+	case 8:
+	case 7:
+	default:
+		break;
+
+	case 6:
+	case 5:
+	case 4:
+		wm_clocks.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
+				eng_clks.data[2].clocks_in_khz - 1;
+		wm_clocks.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
+				eng_clks.data[2].clocks_in_khz;
+
+		/* this GFX E clock is used for Watermark Set B calculations
+		 * m_wmSetClocks.wmSetEngineClocks[WMSetB].clockInKHz =
+		 * eng_clks.data[2].clockInKHz;
+		 */
+
+		wm_clocks.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
+				eng_clks.data[2].clocks_in_khz - 1;
+		wm_clocks.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
+				eng_clks.data[2].clocks_in_khz;
+
+		/* this GFX E clock is used for Watermark Set D and DWB
+		 * Watermark Set A calculations
+		 * m_wmSetClocks.wmSetEngineClocks[WMSetD].clockInKHz =
+		 * m_wmDWBSetAEngineClock = eng_clks.data[2].clockInKHz;
+		 */
+		break;
+
+	case 3:
+	case 2:
+		wm_clocks.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
+				eng_clks.data[1].clocks_in_khz - 1;
+		wm_clocks.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
+				eng_clks.data[1].clocks_in_khz;
+
+		/* this GFX E clock is used for Watermark Set B calculations
+		 * m_wmSetClocks.wmSetEngineClocks[WMSetB].clockInKHz =
+		 * eng_clks.data[1].clockInKHz;
+		 */
+
+		wm_clocks.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
+				eng_clks.data[1].clocks_in_khz - 1;
+		wm_clocks.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
+				eng_clks.data[1].clocks_in_khz;
+
+		/* this GFX E clock is used for Watermark Set D and DWB
+		 * Watermark Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetEngineClocks[WMSetD].clockInKHz =
+		 * m_wmDWBSetAEngineClock = eng_clks.data[1].clockInKHz;
+		 */
+		break;
+	}
+
+	/* use same memory clock and latency for all 4 watermark levels if we
+	 * only have one MCLK reported
+	 */
+	if (mem_clks.num_levels == 1) {
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].clockInKHz  =
+		 * m_wmDWBSetBMemoryClock = 250000;
+		 */
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].latencyInUs = 45; */
+
+		wm_clocks.wm_clk_ranges[WM_SET_A].wm_min_memg_clk_in_khz =
+				250000;
+		wm_clocks.wm_clk_ranges[WM_SET_A].wm_max_mem_clk_in_khz =
+				mem_clks.data[0].clocks_in_khz - 1;
+
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetB].clockInKHz
+		 *  = 250000;
+		 */
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetB].latencyInUs = 45; */
+
+		wm_clocks.wm_clk_ranges[WM_SET_B].wm_min_memg_clk_in_khz =
+				250000;
+		wm_clocks.wm_clk_ranges[WM_SET_B].wm_max_mem_clk_in_khz =
+				mem_clks.data[0].clocks_in_khz - 1;
+
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetC].clockInKHz =
+		 * memoryClkInfoWithLatency.data[0].clockInKHz;
+		 */
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetC].latencyInUs =
+		 * memoryClkInfoWithLatency.data[0].latencyInMicros;
+		 */
+
+		wm_clocks.wm_clk_ranges[WM_SET_C].wm_min_memg_clk_in_khz =
+				mem_clks.data[0].clocks_in_khz;
+		wm_clocks.wm_clk_ranges[WM_SET_C].wm_max_mem_clk_in_khz =
+				5000000;
+
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetD].clockInKHz  =
+		 * m_wmDWBSetAMemoryClock =
+		 * memoryClkInfoWithLatency.data[0].clockInKHz;
+		 */
+		/* this M clock is used for Watermark Set D and DWB Watermark
+		 * Set A calculations
+		 */
+		/* m_wmSetClocks.wmSetMemoryClocks[WMSetD].latencyInUs =
+		 * memoryClkInfoWithLatency.data[0].latencyInMicros;
+		 */
+
+		wm_clocks.wm_clk_ranges[WM_SET_D].wm_min_memg_clk_in_khz =
+				mem_clks.data[0].clocks_in_khz;
+		wm_clocks.wm_clk_ranges[WM_SET_D].wm_max_mem_clk_in_khz =
+				5000000;
+	}
+
+	/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */
+	dm_pp_notify_wm_clock_changes(dc->ctx, &wm_clocks);
+
+	/* we don't need to call PPLIB for validation clock any more since they
+	 * also give us the highest sclk and highest mclk (UMA clock).
+	 * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):
+	 * YCLK = UMACLK*m_memoryTypeMultiplier
+	 */
+	/* m_validationMemoryClockInKHz  =
+	 * m_clockLevels.memoryClocksInKHz[m_clockLevels.numMemclkLevels - 1];
+	 */
+	/* m_validationEngineClockInKHz  =
+	 * m_clockLevels.engineClocksInKHz[m_clockLevels.numEngclkLevels - 1];
+	 */
 }
 
 
@@ -1011,6 +1239,7 @@ static bool construct(
 {
 	unsigned int i;
 	struct dc_context *ctx = dc->ctx;
+	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	pool->base.adapter_srv = adapter_serv;
 	pool->base.funcs = &dce112_res_pool_funcs;
@@ -1021,7 +1250,8 @@ static bool construct(
 	pool->base.underlay_pipe_index = -1;
 	pool->base.pipe_count =
 		dal_adapter_service_get_func_controllers_num(adapter_serv);
-	pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(adapter_serv);
+	pool->base.stream_enc_count =
+		dal_adapter_service_get_stream_engines_num(adapter_serv);
 	dc->public.caps.max_downscale_ratio = 200;
 	dc->public.caps.i2c_speed_in_khz = 100;
 
@@ -1036,24 +1266,36 @@ static bool construct(
 	pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
 	pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
 
-	pool->base.clock_sources[DCE112_CLK_SRC_PLL0] = dce112_clock_source_create(
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL0] =
+			dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0], false);
-	pool->base.clock_sources[DCE112_CLK_SRC_PLL1] = dce112_clock_source_create(
+		CLOCK_SOURCE_COMBO_PHY_PLL0,
+		&dce112_clk_src_reg_offsets[0], false);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL1] =
+			dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1], false);
-	pool->base.clock_sources[DCE112_CLK_SRC_PLL2] = dce112_clock_source_create(
+		CLOCK_SOURCE_COMBO_PHY_PLL1,
+		&dce112_clk_src_reg_offsets[1], false);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL2] =
+			dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2], false);
-	pool->base.clock_sources[DCE112_CLK_SRC_PLL3] = dce112_clock_source_create(
+		CLOCK_SOURCE_COMBO_PHY_PLL2,
+		&dce112_clk_src_reg_offsets[2], false);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL3] =
+			dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3], false);
-	pool->base.clock_sources[DCE112_CLK_SRC_PLL4] = dce112_clock_source_create(
+		CLOCK_SOURCE_COMBO_PHY_PLL3,
+		&dce112_clk_src_reg_offsets[3], false);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL4] =
+			dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4], false);
-	pool->base.clock_sources[DCE112_CLK_SRC_PLL5] = dce112_clock_source_create(
+		CLOCK_SOURCE_COMBO_PHY_PLL4,
+		&dce112_clk_src_reg_offsets[4], false);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL5] =
+			dce112_clock_source_create(
 		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-		CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5], false);
+		CLOCK_SOURCE_COMBO_PHY_PLL5,
+		&dce112_clk_src_reg_offsets[5], false);
 	pool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;
 
 	pool->base.dp_clock_source =  dce112_clock_source_create(
@@ -1068,13 +1310,27 @@ static bool construct(
 		}
 	}
 
-	pool->base.display_clock = dal_display_clock_dce112_create(ctx, adapter_serv);
+	pool->base.display_clock = dal_display_clock_dce112_create(
+			ctx, adapter_serv);
+
 	if (pool->base.display_clock == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto disp_clk_create_fail;
 	}
 
+	/* get static clock information for PPLIB or firmware, save
+	 * max_clock_state
+	 */
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info)) {
+		enum clocks_state max_clocks_state =
+			dce110_resource_convert_clock_state_pp_to_dc(
+					static_clk_info.max_clocks_state);
+
+		dal_display_clock_store_max_clocks_state(
+				pool->base.display_clock, max_clocks_state);
+	}
+
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;
@@ -1095,11 +1351,12 @@ static bool construct(
 	}
 
 	for (i = 0; i < pool->base.pipe_count; i++) {
-		pool->base.timing_generators[i] = dce112_timing_generator_create(
-				adapter_serv,
-				ctx,
-				i,
-				&dce112_tg_offsets[i]);
+		pool->base.timing_generators[i] =
+				dce112_timing_generator_create(
+					adapter_serv,
+					ctx,
+					i,
+					&dce112_tg_offsets[i]);
 		if (pool->base.timing_generators[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error("DC: failed to create tg!\n");
@@ -1125,7 +1382,7 @@ static bool construct(
 		if (pool->base.ipps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
-				"DC: failed to create input pixel processor!\n");
+				"DC:failed to create input pixel processor!\n");
 			goto controller_create_fail;
 		}
 
@@ -1150,7 +1407,7 @@ static bool construct(
 		if (pool->base.opps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
-				"DC: failed to create output pixel processor!\n");
+				"DC:failed to create output pixel processor!\n");
 			goto controller_create_fail;
 		}
 	}
@@ -1166,7 +1423,7 @@ static bool construct(
 		}
 
 		pool->base.audios[i] = dce110_audio_create(
-				ctx, i, &audio_regs[i], &audio_shift, &audio_mask);
+			ctx, i, &audio_regs[i], &audio_shift, &audio_mask);
 
 		if (pool->base.audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
@@ -1179,11 +1436,12 @@ static bool construct(
 	for (i = 0; i < pool->base.stream_enc_count; i++) {
 		/* TODO: rework fragile code*/
 		if (pool->base.stream_engines.u_all & 1 << i) {
-			pool->base.stream_enc[i] = dce112_stream_encoder_create(
-				i, dc->ctx,
-				dal_adapter_service_get_bios_parser(
-					adapter_serv),
-				&stream_enc_regs[i]);
+			pool->base.stream_enc[i] =
+				dce112_stream_encoder_create(
+					i, dc->ctx,
+					dal_adapter_service_get_bios_parser(
+						adapter_serv),
+					&stream_enc_regs[i]);
 			if (pool->base.stream_enc[i] == NULL) {
 				BREAK_TO_DEBUGGER();
 				dm_error("DC: failed to create stream_encoder!\n");
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 5b62906..fb6c039 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -728,6 +728,47 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_bandwidth = dce80_validate_bandwidth
 };
 
+static enum clocks_state dce80_resource_convert_clock_state_pp_to_dc(
+	enum dm_pp_clocks_state pp_clock_state)
+{
+	enum clocks_state dc_clocks_state = CLOCKS_STATE_INVALID;
+
+	switch (pp_clock_state) {
+	case DM_PP_CLOCKS_STATE_INVALID:
+		dc_clocks_state = CLOCKS_STATE_INVALID;
+		break;
+	case DM_PP_CLOCKS_STATE_ULTRA_LOW:
+		dc_clocks_state = CLOCKS_STATE_ULTRA_LOW;
+		break;
+	case DM_PP_CLOCKS_STATE_LOW:
+		dc_clocks_state = CLOCKS_STATE_LOW;
+		break;
+	case DM_PP_CLOCKS_STATE_NOMINAL:
+		dc_clocks_state = CLOCKS_STATE_NOMINAL;
+		break;
+	case DM_PP_CLOCKS_STATE_PERFORMANCE:
+		dc_clocks_state = CLOCKS_STATE_PERFORMANCE;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_4:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_4;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_5:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_5;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_6:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_6;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_7:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_7;
+		break;
+	default:
+		dc_clocks_state = CLOCKS_STATE_INVALID;
+		break;
+	}
+
+	return dc_clocks_state;
+}
+
 static bool construct(
 	struct adapter_service *as,
 	uint8_t num_virtual_links,
@@ -738,6 +779,7 @@ static bool construct(
 	struct dc_context *ctx = dc->ctx;
 	struct firmware_info info;
 	struct dc_bios *bp;
+	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	pool->base.adapter_srv = as;
 	pool->base.funcs = &dce80_res_pool_funcs;
@@ -810,6 +852,18 @@ static bool construct(
 		goto disp_clk_create_fail;
 	}
 
+	/* get static clock information for PPLIB or firmware, save
+	 * max_clock_state
+	 */
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info)) {
+		enum clocks_state max_clocks_state =
+				dce80_resource_convert_clock_state_pp_to_dc(
+					static_clk_info.max_clocks_state);
+
+		dal_display_clock_store_max_clocks_state(
+				pool->base.display_clock, max_clocks_state);
+	}
+
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services.h b/drivers/gpu/drm/amd/dal/dc/dm_services.h
index fddd939..6dcf86a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services.h
@@ -201,6 +201,20 @@ bool dm_pp_get_clock_levels_by_type(
 	enum dm_pp_clock_type clk_type,
 	struct dm_pp_clock_levels *clk_level_info);
 
+bool dm_pp_get_clock_levels_by_type_with_latency(
+	const struct dc_context *ctx,
+	enum dm_pp_clock_type clk_type,
+	struct dm_pp_clock_levels_with_latency *clk_level_info);
+
+bool dm_pp_get_clock_levels_by_type_with_voltage(
+	const struct dc_context *ctx,
+	enum dm_pp_clock_type clk_type,
+	struct dm_pp_clock_levels_with_voltage *clk_level_info);
+
+bool dm_pp_notify_wm_clock_changes(
+	const struct dc_context *ctx,
+	struct dm_pp_wm_sets_with_clock_ranges *wm_with_clock_ranges);
+
 bool dm_pp_apply_safe_state(
 		const struct dc_context *ctx);
 
@@ -219,6 +233,18 @@ bool dm_pp_apply_display_requirements(
 	const struct dc_context *ctx,
 	const struct dm_pp_display_configuration *pp_display_cfg);
 
+bool dm_pp_apply_power_level_change_request(
+	const struct dc_context *ctx,
+	struct dm_pp_power_level_change_request *level_change_req);
+
+bool dm_pp_apply_clock_for_voltage_request(
+	const struct dc_context *ctx,
+	struct dm_pp_clock_for_voltage_req *clock_for_voltage_req);
+
+bool dm_pp_get_static_clocks(
+	const struct dc_context *ctx,
+	struct dm_pp_static_clock_info *static_clk_info);
+
 /****** end of PP interfaces ******/
 
 enum platform_method {
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
index 61d59c6..0223053 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services_types.h
@@ -95,7 +95,11 @@ struct dm_pp_gpu_clock_range {
 enum dm_pp_clock_type {
 	DM_PP_CLOCK_TYPE_DISPLAY_CLK = 1,
 	DM_PP_CLOCK_TYPE_ENGINE_CLK, /* System clock */
-	DM_PP_CLOCK_TYPE_MEMORY_CLK
+	DM_PP_CLOCK_TYPE_MEMORY_CLK,
+	DM_PP_CLOCK_TYPE_DCFCLK,
+	DM_PP_CLOCK_TYPE_SOCCLK,
+	DM_PP_CLOCK_TYPE_PIXELCLK,
+	DM_PP_CLOCK_TYPE_DISPLAYPHYCLK
 };
 
 #define DC_DECODE_PP_CLOCK_TYPE(clk_type) \
@@ -108,11 +112,26 @@ enum dm_pp_clock_type {
 struct dm_pp_clock_levels {
 	uint32_t num_levels;
 	uint32_t clocks_in_khz[DM_PP_MAX_CLOCK_LEVELS];
+};
+
+struct dm_pp_clock_with_latency {
+	uint32_t clocks_in_khz;
+	uint32_t latency_in_us;
+};
 
-	/* TODO: add latency for polaris11
-	 * do we need to know invalid (unsustainable boost) level for watermark
-	 * programming? if not we can just report less elements in array
-	 */
+struct dm_pp_clock_levels_with_latency {
+	uint32_t num_levels;
+	struct dm_pp_clock_with_latency data[DM_PP_MAX_CLOCK_LEVELS];
+};
+
+struct dm_pp_clock_with_voltage {
+	uint32_t clocks_in_khz;
+	uint32_t voltage_in_mv;
+};
+
+struct dm_pp_clock_levels_with_voltage {
+	uint32_t num_levels;
+	struct dm_pp_clock_with_voltage data[DM_PP_MAX_CLOCK_LEVELS];
 };
 
 struct dm_pp_single_disp_config {
@@ -127,6 +146,29 @@ struct dm_pp_single_disp_config {
 	struct dc_link_settings link_settings; /* DP only */
 };
 
+#define MAX_WM_SETS 4
+
+enum dm_pp_wm_set_id {
+	WM_SET_A = 0,
+	WM_SET_B,
+	WM_SET_C,
+	WM_SET_D,
+	WM_SET_INVALID = 0xffff,
+};
+
+struct dm_pp_clock_range_for_wm_set {
+	enum dm_pp_wm_set_id wm_set_id;
+	uint32_t wm_min_eng_clk_in_khz;
+	uint32_t wm_max_eng_clk_in_khz;
+	uint32_t wm_min_memg_clk_in_khz;
+	uint32_t wm_max_mem_clk_in_khz;
+};
+
+struct dm_pp_wm_sets_with_clock_ranges {
+	uint32_t num_wm_sets;
+	struct dm_pp_clock_range_for_wm_set wm_clk_ranges[MAX_WM_SETS];
+};
+
 #define MAX_DISPLAY_CONFIGS 6
 
 struct dm_pp_display_configuration {
@@ -193,4 +235,38 @@ enum dm_acpi_display_type {
 	AcpiDisplayType_DFP6 = 12
 };
 
+enum dm_pp_power_level {
+	DM_PP_POWER_LEVEL_INVALID,
+	DM_PP_POWER_LEVEL_ULTRA_LOW,
+	DM_PP_POWER_LEVEL_LOW,
+	DM_PP_POWER_LEVEL_NOMINAL,
+	DM_PP_POWER_LEVEL_PERFORMANCE,
+
+	DM_PP_POWER_LEVEL_0 = DM_PP_POWER_LEVEL_ULTRA_LOW,
+	DM_PP_POWER_LEVEL_1 = DM_PP_POWER_LEVEL_LOW,
+	DM_PP_POWER_LEVEL_2 = DM_PP_POWER_LEVEL_NOMINAL,
+	DM_PP_POWER_LEVEL_3 = DM_PP_POWER_LEVEL_PERFORMANCE,
+	DM_PP_POWER_LEVEL_4 = DM_PP_CLOCKS_DPM_STATE_LEVEL_3 + 1,
+	DM_PP_POWER_LEVEL_5 = DM_PP_CLOCKS_DPM_STATE_LEVEL_4 + 1,
+	DM_PP_POWER_LEVEL_6 = DM_PP_CLOCKS_DPM_STATE_LEVEL_5 + 1,
+	DM_PP_POWER_LEVEL_7 = DM_PP_CLOCKS_DPM_STATE_LEVEL_6 + 1,
+};
+
+struct dm_pp_power_level_change_request {
+	enum dm_pp_power_level power_level;
+};
+
+struct dm_pp_clock_for_voltage_req {
+	enum dm_pp_clock_type clk_type;
+	uint32_t clocks_in_khz;
+};
+
+struct dm_pp_static_clock_info {
+	uint32_t max_sclk_khz;
+	uint32_t max_mclk_khz;
+
+	/* max possible display block clocks state */
+	enum dm_pp_clocks_state max_clocks_state;
+};
+
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index a1a00ee..f4f6e2e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -145,6 +145,8 @@ static bool set_min_clocks_state(
 	enum clocks_state clocks_state)
 {
 	struct display_clock_dce110 *dc = DCLCK110_FROM_BASE(base);
+	struct dm_pp_power_level_change_request level_change_req = {
+			DM_PP_POWER_LEVEL_INVALID};
 
 	if (clocks_state > dc->max_clks_state) {
 		/*Requested state exceeds max supported state.*/
@@ -159,7 +161,32 @@ static bool set_min_clocks_state(
 		return true;
 	}
 
-	base->cur_min_clks_state = clocks_state;
+	switch (clocks_state) {
+	case CLOCKS_STATE_ULTRA_LOW:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_ULTRA_LOW;
+		break;
+	case CLOCKS_STATE_LOW:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_LOW;
+		break;
+	case CLOCKS_STATE_NOMINAL:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_NOMINAL;
+		break;
+	case CLOCKS_STATE_PERFORMANCE:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_PERFORMANCE;
+		break;
+	case CLOCKS_STATE_INVALID:
+	default:
+		dal_logger_write(base->ctx->logger,
+				LOG_MAJOR_WARNING,
+				LOG_MINOR_COMPONENT_GPU,
+				"Requested state invalid state");
+		return false;
+	}
+
+	/* get max clock state from PPLIB */
+	if (dm_pp_apply_power_level_change_request(
+			base->ctx, &level_change_req))
+		base->cur_min_clks_state = clocks_state;
 
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
index faaeac9..089712c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
@@ -120,6 +120,8 @@ bool dispclk_dce112_set_min_clocks_state(
 	enum clocks_state clocks_state)
 {
 	struct display_clock_dce112 *dc = DCLCK112_FROM_BASE(base);
+	struct dm_pp_power_level_change_request level_change_req = {
+			DM_PP_POWER_LEVEL_INVALID};
 
 	if (clocks_state > dc->max_clks_state) {
 		/*Requested state exceeds max supported state.*/
@@ -134,7 +136,32 @@ bool dispclk_dce112_set_min_clocks_state(
 		return true;
 	}
 
-	base->cur_min_clks_state = clocks_state;
+	switch (clocks_state) {
+	case CLOCKS_STATE_ULTRA_LOW:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_ULTRA_LOW;
+		break;
+	case CLOCKS_STATE_LOW:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_LOW;
+		break;
+	case CLOCKS_STATE_NOMINAL:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_NOMINAL;
+		break;
+	case CLOCKS_STATE_PERFORMANCE:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_PERFORMANCE;
+		break;
+	case CLOCKS_STATE_INVALID:
+	default:
+		dal_logger_write(base->ctx->logger,
+				LOG_MAJOR_WARNING,
+				LOG_MINOR_COMPONENT_GPU,
+				"Requested state invalid state");
+		return false;
+	}
+
+	/* get max clock state from PPLIB */
+	if (dm_pp_apply_power_level_change_request(
+			base->ctx, &level_change_req))
+		base->cur_min_clks_state = clocks_state;
 
 	return true;
 }
@@ -227,7 +254,9 @@ uint32_t dispclk_dce112_get_validation_clock(struct display_clock *dc)
 
 	switch (disp_clk->max_clks_state) {
 	case CLOCKS_STATE_ULTRA_LOW:
-		/*Currently not supported, it has 0 in table entry*/
+		clk = (disp_clk->max_clks_by_state + CLOCKS_STATE_ULTRA_LOW)->
+			display_clk_khz;
+
 	case CLOCKS_STATE_LOW:
 		clk = (disp_clk->max_clks_by_state + CLOCKS_STATE_LOW)->
 			display_clk_khz;
@@ -833,6 +862,7 @@ bool dal_display_clock_dce112_construct(
 	struct dc_context *ctx,
 	struct adapter_service *as)
 {
+	struct dm_pp_static_clock_info *static_clk_info = {0};
 	struct display_clock *dc_base = &dc112->disp_clk_base;
 
 	if (NULL == as)
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
index aa367bb..3809e62 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
@@ -582,17 +582,47 @@ static bool set_min_clocks_state(
 {
 	struct display_clock_dce80 *disp_clk = FROM_DISPLAY_CLOCK(dc);
 
+	struct dm_pp_power_level_change_request level_change_req = {
+			DM_PP_POWER_LEVEL_INVALID};
+
 	if (clocks_state > disp_clk->max_clks_state) {
 		/*Requested state exceeds max supported state.*/
-		BREAK_TO_DEBUGGER();
+		dal_logger_write(dc->ctx->logger,
+				LOG_MAJOR_WARNING,
+				LOG_MINOR_COMPONENT_GPU,
+				"Requested state exceeds max supported state");
 		return false;
-	} else if (clocks_state == disp_clk->cur_min_clks_state) {
+	} else if (clocks_state == dc->cur_min_clks_state) {
 		/*if we're trying to set the same state, we can just return
 		 * since nothing needs to be done*/
 		return true;
 	}
 
-	disp_clk->cur_min_clks_state = clocks_state;
+	switch (clocks_state) {
+	case CLOCKS_STATE_ULTRA_LOW:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_ULTRA_LOW;
+		break;
+	case CLOCKS_STATE_LOW:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_LOW;
+		break;
+	case CLOCKS_STATE_NOMINAL:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_NOMINAL;
+		break;
+	case CLOCKS_STATE_PERFORMANCE:
+		level_change_req.power_level = DM_PP_POWER_LEVEL_PERFORMANCE;
+		break;
+	case CLOCKS_STATE_INVALID:
+	default:
+		dal_logger_write(dc->ctx->logger,
+				LOG_MAJOR_WARNING,
+				LOG_MINOR_COMPONENT_GPU,
+				"Requested state invalid state");
+		return false;
+	}
+
+	/* get max clock state from PPLIB */
+	if (dm_pp_apply_power_level_change_request(dc->ctx, &level_change_req))
+		dc->cur_min_clks_state = clocks_state;
 
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.h b/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.h
index 845393b..ce5dd3d 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/display_clock.h
@@ -55,6 +55,10 @@ struct display_clock_funcs {
 	struct display_clock_state (*get_clock_state)(
 		struct display_clock *disp_clk);
 	uint32_t (*get_dfs_bypass_threshold)(struct display_clock *disp_clk);
+	bool (*apply_clock_voltage_request)(
+		struct display_clock *disp_clk,
+		enum dm_pp_clock_type clocks_type,
+		uint32_t clocks_in_khz);
 };
 
 struct display_clock {
@@ -79,4 +83,23 @@ bool dal_display_clock_construct_base(
 	struct display_clock *base,
 	struct dc_context *ctx,
 	struct adapter_service *as);
+
+enum clocks_state dal_display_clock_get_min_clocks_state(
+	struct display_clock *disp_clk);
+
+enum clocks_state dal_display_clock_get_required_clocks_state(
+	struct display_clock *disp_clk,
+	struct state_dependent_clocks *req_clocks);
+
+bool dal_display_clock_set_min_clocks_state(
+	struct display_clock *disp_clk,
+	enum clocks_state clocks_state);
+
+uint32_t dal_display_clock_get_validation_clock(struct display_clock *disp_clk);
+
+void dal_display_clock_store_max_clocks_state(
+	struct display_clock *disp_clk,
+	enum clocks_state max_clocks_state);
+
+
 #endif /* __DAL_DISPLAY_CLOCK_H__*/
diff --git a/drivers/gpu/drm/amd/dal/include/display_clock_interface.h b/drivers/gpu/drm/amd/dal/include/display_clock_interface.h
index 98d6f05..06c6715 100644
--- a/drivers/gpu/drm/amd/dal/include/display_clock_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/display_clock_interface.h
@@ -87,11 +87,21 @@ struct minimum_clocks_calculation_result {
 
 /* Enumeration of all clocks states */
 enum clocks_state {
-	CLOCKS_STATE_INVALID,
+	CLOCKS_STATE_INVALID = 0,
 	CLOCKS_STATE_ULTRA_LOW,
 	CLOCKS_STATE_LOW,
 	CLOCKS_STATE_NOMINAL,
-	CLOCKS_STATE_PERFORMANCE
+	CLOCKS_STATE_PERFORMANCE,
+	/* Starting from DCE11, Max 8 level DPM state supported */
+	CLOCKS_DPM_STATE_LEVEL_INVALID = CLOCKS_STATE_INVALID,
+	CLOCKS_DPM_STATE_LEVEL_0 = CLOCKS_STATE_ULTRA_LOW,
+	CLOCKS_DPM_STATE_LEVEL_1 = CLOCKS_STATE_LOW,
+	CLOCKS_DPM_STATE_LEVEL_2 = CLOCKS_STATE_NOMINAL,
+	CLOCKS_DPM_STATE_LEVEL_3 = CLOCKS_STATE_PERFORMANCE,
+	CLOCKS_DPM_STATE_LEVEL_4 = CLOCKS_DPM_STATE_LEVEL_3 + 1,
+	CLOCKS_DPM_STATE_LEVEL_5 = CLOCKS_DPM_STATE_LEVEL_4 + 1,
+	CLOCKS_DPM_STATE_LEVEL_6 = CLOCKS_DPM_STATE_LEVEL_5 + 1,
+	CLOCKS_DPM_STATE_LEVEL_7 = CLOCKS_DPM_STATE_LEVEL_6 + 1,
 };
 
 /* Structure containing all state-dependent clocks
@@ -169,5 +179,9 @@ uint32_t dal_display_clock_get_dfs_bypass_threshold(
 	struct display_clock *disp_clk);
 void dal_display_clock_invalid_clock_state(
 	struct display_clock *disp_clk);
+bool dal_display_clock_apply_clock_voltage_request(
+	struct display_clock *disp_clk,
+	enum dm_pp_clock_type clocks_type,
+	uint32_t clocks_in_khz);
 
 #endif /* __DISPLAY_CLOCK_INTERFACE_H__ */
-- 
2.7.4

