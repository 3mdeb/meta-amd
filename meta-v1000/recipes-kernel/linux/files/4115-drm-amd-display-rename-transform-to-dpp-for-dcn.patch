From ba9d293778a3741520cdc48c3d4e769b8bdfc2ff Mon Sep 17 00:00:00 2001
From: Yue Hin Lau <Yuehin.Lau@amd.com>
Date: Thu, 5 Oct 2017 16:47:49 -0400
Subject: [PATCH 4115/5855] drm/amd/display: rename transform to dpp for dcn

Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Pavan Kumar Ramayanam <pavan.ramayanam@amd.com>
---
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |   1 +
 drivers/gpu/drm/amd/display/dc/core/dc.c           |   1 +
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  |  16 +-
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |  16 +-
 drivers/gpu/drm/amd/display/dc/core/dc_surface.c   |   1 +
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c   | 147 ++++++------
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h   |   8 +-
 .../gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c    | 261 +++++++++++----------
 .../gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c  |  92 ++++----
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  |  59 ++---
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |  10 +-
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |   3 +
 drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h        | 134 +++++++++++
 13 files changed, 454 insertions(+), 295 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h

diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index c37f130..cf0c145 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -488,6 +488,7 @@ static void split_stream_across_pipes(
 	secondary_pipe->plane_res.hubp = pool->hubps[secondary_pipe->pipe_idx];
 	secondary_pipe->plane_res.ipp = pool->ipps[secondary_pipe->pipe_idx];
 	secondary_pipe->plane_res.xfm = pool->transforms[secondary_pipe->pipe_idx];
+	secondary_pipe->plane_res.dpp = pool->dpps[secondary_pipe->pipe_idx];
 	if (primary_pipe->bottom_pipe) {
 		ASSERT(primary_pipe->bottom_pipe != secondary_pipe);
 		secondary_pipe->bottom_pipe = primary_pipe->bottom_pipe;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f424a51..a01b635 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -38,6 +38,7 @@
 #include "bios_parser_interface.h"
 #include "include/irq_service_interface.h"
 #include "transform.h"
+#include "dpp.h"
 #include "timing_generator.h"
 #include "virtual/virtual_link_encoder.h"
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c80bde9..303d7ec 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -31,6 +31,7 @@
 #include "opp.h"
 #include "timing_generator.h"
 #include "transform.h"
+#include "dpp.h"
 #include "core_types.h"
 #include "set_mode_types.h"
 #include "virtual/virtual_stream_encoder.h"
@@ -853,8 +854,13 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable;
 
 	/* Taps calculations */
-	res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+	if (pipe_ctx->plane_res.xfm != NULL)
+		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
+				pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+
+	if (pipe_ctx->plane_res.dpp != NULL)
+		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
+				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
@@ -862,6 +868,9 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
 			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+
+		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
+			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -1026,7 +1035,7 @@ static int acquire_first_split_pipe(
 			pipe_ctx->stream_res.tg = pool->timing_generators[i];
 			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
-			pipe_ctx->plane_res.xfm = pool->transforms[i];
+			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
 			pipe_ctx->pipe_idx = i;
 
@@ -1359,6 +1368,7 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
+			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
 			pipe_ctx->pipe_idx = i;
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 10421ea..97f040a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -200,7 +200,7 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.xfm)
+		if (pipe_ctx->stream != stream || (!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
@@ -221,9 +221,15 @@ bool dc_stream_set_cursor_attributes(
 					pipe_ctx->plane_res.mi, attributes);
 
 
-		if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
+		if (pipe_ctx->plane_res.xfm != NULL &&
+				pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
 				pipe_ctx->plane_res.xfm, attributes);
+
+		if (pipe_ctx->plane_res.dpp != NULL &&
+				pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes != NULL)
+			pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(
+				pipe_ctx->plane_res.dpp, attributes);
 	}
 
 	stream->cursor_attributes = *attributes;
@@ -258,6 +264,7 @@ bool dc_stream_set_cursor_position(
 		struct mem_input *mi = pipe_ctx->plane_res.mi;
 		struct hubp *hubp = pipe_ctx->plane_res.hubp;
 		struct transform *xfm = pipe_ctx->plane_res.xfm;
+		struct dpp *dpp = pipe_ctx->plane_res.dpp;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = stream->timing.pix_clk_khz,
@@ -270,7 +277,7 @@ bool dc_stream_set_cursor_position(
 		if (pipe_ctx->stream != stream ||
 				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
 				!pipe_ctx->plane_state ||
-				!pipe_ctx->plane_res.xfm)
+				(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
 			continue;
 
 		if (pipe_ctx->plane_state->address.type
@@ -293,6 +300,9 @@ bool dc_stream_set_cursor_position(
 		if (xfm != NULL && xfm->funcs->set_cursor_position != NULL)
 			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, hubp->curs_attr.width);
 
+		if (dpp != NULL && dpp->funcs->set_cursor_position != NULL)
+			dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width);
+
 	}
 
 	return true;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 2a64b10..0d969ee 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -30,6 +30,7 @@
 /* DC core (private) */
 #include "core_types.h"
 #include "transform.h"
+#include "dpp.h"
 
 /*******************************************************************************
  * Private functions
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index fb3c788..32bfd33 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -39,14 +39,14 @@
 #define BLACK_OFFSET_CBCR  0x8000
 
 #define REG(reg)\
-	xfm->tf_regs->reg
+	dpp->tf_regs->reg
 
 #define CTX \
-	xfm->base.ctx
+	dpp->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+	dpp->tf_shift->field_name, dpp->tf_mask->field_name
 
 enum pixel_format_description {
 	PIXEL_FORMAT_FIXED = 0,
@@ -99,7 +99,7 @@ enum gamut_remap_select {
 };
 
 /* Program gamut remap in bypass mode */
-void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
+void dpp_set_gamut_remap_bypass(struct dcn10_dpp *dpp)
 {
 	REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
 			CM_GAMUT_REMAP_MODE, 0);
@@ -110,7 +110,7 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 
 
 bool dpp_get_optimal_number_of_taps(
-		struct transform *xfm,
+		struct dpp *dpp,
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)
 {
@@ -154,7 +154,7 @@ bool dpp_get_optimal_number_of_taps(
 	else
 		scl_data->taps.h_taps_c = in_taps->h_taps_c;
 
-	if (!xfm->ctx->dc->debug.always_scale) {
+	if (!dpp->ctx->dc->debug.always_scale) {
 		if (IDENTITY_RATIO(scl_data->ratios.horz))
 			scl_data->taps.h_taps = 1;
 		if (IDENTITY_RATIO(scl_data->ratios.vert))
@@ -169,43 +169,42 @@ bool dpp_get_optimal_number_of_taps(
 	return true;
 }
 
-void dpp_reset(struct transform *xfm_base)
+void dpp_reset(struct dpp *dpp_base)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
-	xfm->filter_h_c = NULL;
-	xfm->filter_v_c = NULL;
-	xfm->filter_h = NULL;
-	xfm->filter_v = NULL;
+	dpp->filter_h_c = NULL;
+	dpp->filter_v_c = NULL;
+	dpp->filter_h = NULL;
+	dpp->filter_v = NULL;
 
 	/* set boundary mode to 0 */
 	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
 }
 
 
-
-static void dcn10_dpp_cm_set_regamma_pwl(
-	struct transform *xfm_base, const struct pwl_params *params)
+static void dpp1_cm_set_regamma_pwl(
+	struct dpp *dpp_base, const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
-	dcn10_dpp_cm_power_on_regamma_lut(xfm_base, true);
-	dcn10_dpp_cm_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
+	dpp1_cm_power_on_regamma_lut(dpp_base, true);
+	dpp1_cm_configure_regamma_lut(dpp_base, dpp->is_write_to_ram_a_safe);
 
-	if (xfm->is_write_to_ram_a_safe)
-		dcn10_dpp_cm_program_regamma_luta_settings(xfm_base, params);
+	if (dpp->is_write_to_ram_a_safe)
+		dpp1_cm_program_regamma_luta_settings(dpp_base, params);
 	else
-		dcn10_dpp_cm_program_regamma_lutb_settings(xfm_base, params);
+		dpp1_cm_program_regamma_lutb_settings(dpp_base, params);
 
-	dcn10_dpp_cm_program_regamma_lut(
-			xfm_base, params->rgb_resulted, params->hw_points_num);
+	dpp1_cm_program_regamma_lut(
+			dpp_base, params->rgb_resulted, params->hw_points_num);
 }
 
-static void dcn10_dpp_cm_set_regamma_mode(
-	struct transform *xfm_base,
+static void dpp1_cm_set_regamma_mode(
+	struct dpp *dpp_base,
 	enum opp_regamma mode)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t re_mode = 0;
 	uint32_t obuf_bypass = 0; /* need for pipe split */
 	uint32_t obuf_hupscale = 0;
@@ -221,8 +220,8 @@ static void dcn10_dpp_cm_set_regamma_mode(
 		re_mode = 2;
 		break;
 	case OPP_REGAMMA_USER:
-		re_mode = xfm->is_write_to_ram_a_safe ? 3 : 4;
-		xfm->is_write_to_ram_a_safe = !xfm->is_write_to_ram_a_safe;
+		re_mode = dpp->is_write_to_ram_a_safe ? 3 : 4;
+		dpp->is_write_to_ram_a_safe = !dpp->is_write_to_ram_a_safe;
 		break;
 	default:
 		break;
@@ -234,7 +233,7 @@ static void dcn10_dpp_cm_set_regamma_mode(
 			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
 }
 
-static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
+static void dpp1_setup_format_flags(enum surface_pixel_format input_format,\
 						enum pixel_format_description *fmt)
 {
 
@@ -247,11 +246,11 @@ static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
 		*fmt = PIXEL_FORMAT_FIXED;
 }
 
-static void ippn10_set_degamma_format_float(
-		struct transform *xfm_base,
+static void dpp1_set_degamma_format_float(
+		struct dpp *dpp_base,
 		bool is_float)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (is_float) {
 		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);
@@ -262,8 +261,8 @@ static void ippn10_set_degamma_format_float(
 	}
 }
 
-void ippn10_cnv_setup (
-		struct transform *xfm_base,
+void dpp1_cnv_setup (
+		struct dpp *dpp_base,
 		enum surface_pixel_format input_format,
 		enum expansion_mode mode)
 {
@@ -273,10 +272,10 @@ void ippn10_cnv_setup (
 	enum dc_color_space color_space;
 	enum dcn10_input_csc_select select;
 	bool is_float;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	bool force_disable_cursor = false;
 
-	ippn10_setup_format_flags(input_format, &fmt);
+	dpp1_setup_format_flags(input_format, &fmt);
 	alpha_en = 1;
 	pixel_format = 0;
 	color_space = COLOR_SPACE_SRGB;
@@ -304,7 +303,7 @@ void ippn10_cnv_setup (
 		break;
 	}
 
-	ippn10_set_degamma_format_float(xfm_base, is_float);
+	dpp1_set_degamma_format_float(dpp_base, is_float);
 
 	switch (input_format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
@@ -362,7 +361,7 @@ void ippn10_cnv_setup (
 			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
 	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
 
-	ippn10_program_input_csc(xfm_base, color_space, select);
+	dpp1_program_input_csc(dpp_base, color_space, select);
 
 	if (force_disable_cursor) {
 		REG_UPDATE(CURSOR_CONTROL,
@@ -373,10 +372,10 @@ void ippn10_cnv_setup (
 }
 
 void dcn10_set_cursor_attributes(
-		struct transform *xfm_base,
+		struct dpp *dpp_base,
 		const struct dc_cursor_attributes *attr)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	enum dc_cursor_color_format color_format = attr->color_format;
 
 	REG_UPDATE_2(CURSOR0_CONTROL,
@@ -401,12 +400,12 @@ void dcn10_set_cursor_attributes(
 
 
 void dcn10_set_cursor_position(
-		struct transform *xfm_base,
+		struct dpp *dpp_base,
 		const struct dc_cursor_position *pos,
 		const struct dc_cursor_mi_param *param,
 		uint32_t width)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int src_x_offset = pos->x - pos->x_hotspot - param->viewport_x_start;
 	uint32_t cur_en = pos->enable ? 1 : 0;
 
@@ -421,25 +420,25 @@ void dcn10_set_cursor_position(
 
 }
 
-static const struct transform_funcs dcn10_dpp_funcs = {
-		.transform_reset = dpp_reset,
-		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
-		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
-		.transform_set_gamut_remap = dcn10_dpp_cm_set_gamut_remap,
-		.opp_set_csc_adjustment = dcn10_dpp_cm_set_output_csc_adjustment,
-		.opp_set_csc_default = dcn10_dpp_cm_set_output_csc_default,
-		.opp_power_on_regamma_lut = dcn10_dpp_cm_power_on_regamma_lut,
-		.opp_program_regamma_lut = dcn10_dpp_cm_program_regamma_lut,
-		.opp_configure_regamma_lut = dcn10_dpp_cm_configure_regamma_lut,
-		.opp_program_regamma_lutb_settings = dcn10_dpp_cm_program_regamma_lutb_settings,
-		.opp_program_regamma_luta_settings = dcn10_dpp_cm_program_regamma_luta_settings,
-		.opp_program_regamma_pwl = dcn10_dpp_cm_set_regamma_pwl,
-		.opp_set_regamma_mode = dcn10_dpp_cm_set_regamma_mode,
-		.ipp_set_degamma = ippn10_set_degamma,
-		.ipp_program_input_lut		= ippn10_program_input_lut,
-		.ipp_program_degamma_pwl	= ippn10_set_degamma_pwl,
-		.ipp_setup			= ippn10_cnv_setup,
-		.ipp_full_bypass		= ippn10_full_bypass,
+static const struct dpp_funcs dcn10_dpp_funcs = {
+		.dpp_reset = dpp_reset,
+		.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,
+		.dpp_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
+		.dpp_set_gamut_remap = dpp1_cm_set_gamut_remap,
+		.opp_set_csc_adjustment = dpp1_cm_set_output_csc_adjustment,
+		.opp_set_csc_default = dpp1_cm_set_output_csc_default,
+		.opp_power_on_regamma_lut = dpp1_cm_power_on_regamma_lut,
+		.opp_program_regamma_lut = dpp1_cm_program_regamma_lut,
+		.opp_configure_regamma_lut = dpp1_cm_configure_regamma_lut,
+		.opp_program_regamma_lutb_settings = dpp1_cm_program_regamma_lutb_settings,
+		.opp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
+		.opp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
+		.opp_set_regamma_mode = dpp1_cm_set_regamma_mode,
+		.ipp_set_degamma = dpp1_set_degamma,
+		.ipp_program_input_lut		= dpp1_program_input_lut,
+		.ipp_program_degamma_pwl	= dpp1_set_degamma_pwl,
+		.ipp_setup			= dpp1_cnv_setup,
+		.ipp_full_bypass		= dpp1_full_bypass,
 		.set_cursor_attributes = dcn10_set_cursor_attributes,
 		.set_cursor_position = dcn10_set_cursor_position,
 };
@@ -452,30 +451,28 @@ static struct dpp_caps dcn10_dpp_cap = {
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
-
-void dcn10_dpp_construct(
-	struct dcn10_dpp *xfm,
+void dpp1_construct(
+	struct dcn10_dpp *dpp,
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dcn_dpp_registers *tf_regs,
 	const struct dcn_dpp_shift *tf_shift,
 	const struct dcn_dpp_mask *tf_mask)
 {
-	xfm->base.ctx = ctx;
-
-	xfm->base.inst = inst;
-	xfm->base.funcs = &dcn10_dpp_funcs;
-	xfm->base.caps = &dcn10_dpp_cap;
+	dpp->base.ctx = ctx;
+	dpp->base.inst = inst;
+	dpp->base.funcs = &dcn10_dpp_funcs;
+	dpp->base.caps = &dcn10_dpp_cap;
 
-	xfm->tf_regs = tf_regs;
-	xfm->tf_shift = tf_shift;
-	xfm->tf_mask = tf_mask;
+	dpp->tf_regs = tf_regs;
+	dpp->tf_shift = tf_shift;
+	dpp->tf_mask = tf_mask;
 
-	xfm->lb_pixel_depth_supported =
+	dpp->lb_pixel_depth_supported =
 		LB_PIXEL_DEPTH_18BPP |
 		LB_PIXEL_DEPTH_24BPP |
 		LB_PIXEL_DEPTH_30BPP;
 
-	xfm->lb_bits_per_entry = LB_BITS_PER_ENTRY;
-	xfm->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
+	dpp->lb_bits_per_entry = LB_BITS_PER_ENTRY;
+	dpp->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
index c2e3ff8..6df4ac1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
@@ -25,10 +25,10 @@
 #ifndef __DAL_DPP_DCN10_H__
 #define __DAL_DPP_DCN10_H__
 
-#include "transform.h"
+#include "dpp.h"
 
-#define TO_DCN10_DPP(transform)\
-	container_of(transform, struct dcn10_dpp, base)
+#define TO_DCN10_DPP(dpp)\
+	container_of(dpp, struct dcn10_dpp, base)
 
 /* TODO: Use correct number of taps. Using polaris values for now */
 #define LB_TOTAL_NUMBER_OF_ENTRIES 5124
@@ -1252,7 +1252,7 @@ struct dcn_dpp_registers {
 };
 
 struct dcn10_dpp {
-	struct transform base;
+	struct dpp base;
 
 	const struct dcn_dpp_registers *tf_regs;
 	const struct dcn_dpp_shift *tf_shift;
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index b01d180..bf4779f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -40,14 +40,14 @@
 #define BLACK_OFFSET_CBCR  0x8000
 
 #define REG(reg)\
-	xfm->tf_regs->reg
+	dpp->tf_regs->reg
 
 #define CTX \
-	xfm->base.ctx
+	dpp->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+	dpp->tf_shift->field_name, dpp->tf_mask->field_name
 
 struct dcn10_input_csc_matrix {
 	enum dc_color_space color_space;
@@ -177,7 +177,7 @@ static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
 
 
 static void program_gamut_remap(
-		struct dcn10_dpp *xfm,
+		struct dcn10_dpp *dpp,
 		const uint16_t *regval,
 		enum gamut_remap_select select)
 {
@@ -203,10 +203,10 @@ static void program_gamut_remap(
 		break;
 	}
 
-	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_GAMUT_REMAP_C11;
-	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_GAMUT_REMAP_C11;
-	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_GAMUT_REMAP_C12;
-	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_GAMUT_REMAP_C12;
+	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_GAMUT_REMAP_C11;
+	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_GAMUT_REMAP_C11;
+	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_GAMUT_REMAP_C12;
+	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_GAMUT_REMAP_C12;
 
 
 	if (select == GAMUT_REMAP_COEFF) {
@@ -214,7 +214,7 @@ static void program_gamut_remap(
 		gam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 
@@ -224,7 +224,7 @@ static void program_gamut_remap(
 		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 
@@ -234,7 +234,7 @@ static void program_gamut_remap(
 		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 	}
@@ -245,15 +245,15 @@ static void program_gamut_remap(
 
 }
 
-void dcn10_dpp_cm_set_gamut_remap(
-	struct transform *xfm,
-	const struct xfm_grph_csc_adjustment *adjust)
+void dpp1_cm_set_gamut_remap(
+	struct dpp *dpp_base,
+	const struct dpp_grph_csc_adjustment *adjust)
 {
-	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
 		/* Bypass if type is bypass or hw */
-		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
+		program_gamut_remap(dpp, NULL, GAMUT_REMAP_BYPASS);
 	else {
 		struct fixed31_32 arr_matrix[12];
 		uint16_t arr_reg_val[12];
@@ -276,16 +276,16 @@ void dcn10_dpp_cm_set_gamut_remap(
 		convert_float_matrix(
 			arr_reg_val, arr_matrix, 12);
 
-		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
+		program_gamut_remap(dpp, arr_reg_val, GAMUT_REMAP_COEFF);
 	}
 }
 
-void dcn10_dpp_cm_set_output_csc_default(
-		struct transform *xfm_base,
+void dpp1_cm_set_output_csc_default(
+		struct dpp *dpp_base,
 		const struct default_adjustment *default_adjust)
 {
 
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t ocsc_mode = 0;
 
 	if (default_adjust != NULL) {
@@ -317,35 +317,35 @@ void dcn10_dpp_cm_set_output_csc_default(
 
 }
 
-static void dcn10_dpp_cm_get_reg_field(
-		struct dcn10_dpp *xfm,
+static void dpp1_cm_get_reg_field(
+		struct dcn10_dpp *dpp,
 		struct xfer_func_reg *reg)
 {
-	reg->shifts.exp_region0_lut_offset = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
-	reg->masks.exp_region0_lut_offset = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
-	reg->shifts.exp_region0_num_segments = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
-	reg->masks.exp_region0_num_segments = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
-	reg->shifts.exp_region1_lut_offset = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
-	reg->masks.exp_region1_lut_offset = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
-	reg->shifts.exp_region1_num_segments = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
-	reg->masks.exp_region1_num_segments = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
-
-	reg->shifts.field_region_end = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
-	reg->masks.field_region_end = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
-	reg->shifts.field_region_end_slope = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
-	reg->masks.field_region_end_slope = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
-	reg->shifts.field_region_end_base = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
-	reg->masks.field_region_end_base = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
-	reg->shifts.field_region_linear_slope = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
-	reg->masks.field_region_linear_slope = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
-	reg->shifts.exp_region_start = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
-	reg->masks.exp_region_start = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
-	reg->shifts.exp_resion_start_segment = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
-	reg->masks.exp_resion_start_segment = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->masks.exp_region0_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+	reg->masks.exp_region1_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+
+	reg->shifts.field_region_end = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->masks.field_region_end = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->shifts.field_region_end_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->masks.field_region_end_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->shifts.field_region_end_base = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->masks.field_region_end_base = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->shifts.field_region_linear_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->masks.field_region_linear_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->shifts.exp_region_start = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->masks.exp_region_start = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->masks.exp_resion_start_segment = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
 }
 
-static void dcn10_dpp_cm_program_color_matrix(
-		struct dcn10_dpp *xfm,
+static void dpp1_cm_program_color_matrix(
+		struct dcn10_dpp *dpp,
 		const struct out_csc_color_matrix *tbl_entry)
 {
 	uint32_t mode;
@@ -358,10 +358,10 @@ static void dcn10_dpp_cm_program_color_matrix(
 		return;
 	}
 
-	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_OCSC_C11;
-	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_OCSC_C11;
-	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_OCSC_C12;
-	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_OCSC_C12;
+	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_OCSC_C11;
+	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_OCSC_C11;
+	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_OCSC_C12;
+	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_OCSC_C12;
 
 	if (mode == 4) {
 
@@ -369,7 +369,7 @@ static void dcn10_dpp_cm_program_color_matrix(
 		gam_regs.csc_c33_c34 = REG(CM_OCSC_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				tbl_entry->regval,
 				&gam_regs);
 
@@ -379,17 +379,17 @@ static void dcn10_dpp_cm_program_color_matrix(
 		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				tbl_entry->regval,
 				&gam_regs);
 	}
 }
 
-void dcn10_dpp_cm_set_output_csc_adjustment(
-		struct transform *xfm_base,
+void dpp1_cm_set_output_csc_adjustment(
+		struct dpp *dpp_base,
 		const struct out_csc_color_matrix *tbl_entry)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
 	uint32_t ocsc_mode = 4;
 
@@ -421,26 +421,26 @@ void dcn10_dpp_cm_set_output_csc_adjustment(
 	*/
 
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	dcn10_dpp_cm_program_color_matrix(xfm, tbl_entry);
+	dpp1_cm_program_color_matrix(dpp, tbl_entry);
 }
 
-void dcn10_dpp_cm_power_on_regamma_lut(
-	struct transform *xfm_base,
+void dpp1_cm_power_on_regamma_lut(
+	struct dpp *dpp_base,
 	bool power_on)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	REG_SET(CM_MEM_PWR_CTRL, 0,
 			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
 
 }
 
-void dcn10_dpp_cm_program_regamma_lut(
-		struct transform *xfm_base,
+void dpp1_cm_program_regamma_lut(
+		struct dpp *dpp_base,
 		const struct pwl_result_data *rgb,
 		uint32_t num)
 {
 	uint32_t i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	for (i = 0 ; i < num; i++) {
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
@@ -457,11 +457,11 @@ void dcn10_dpp_cm_program_regamma_lut(
 
 }
 
-void dcn10_dpp_cm_configure_regamma_lut(
-		struct transform *xfm_base,
+void dpp1_cm_configure_regamma_lut(
+		struct dpp *dpp_base,
 		bool is_ram_a)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
 			CM_RGAM_LUT_WRITE_EN_MASK, 7);
@@ -471,14 +471,14 @@ void dcn10_dpp_cm_configure_regamma_lut(
 }
 
 /*program re gamma RAM A*/
-void dcn10_dpp_cm_program_regamma_luta_settings(
-		struct transform *xfm_base,
+void dpp1_cm_program_regamma_luta_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_RGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_RGAM_RAMA_START_CNTL_G);
@@ -495,19 +495,19 @@ void dcn10_dpp_cm_program_regamma_luta_settings(
 	gam_regs.region_start = REG(CM_RGAM_RAMA_REGION_0_1);
 	gam_regs.region_end = REG(CM_RGAM_RAMA_REGION_32_33);
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 
 }
 
 /*program re gamma RAM B*/
-void dcn10_dpp_cm_program_regamma_lutb_settings(
-		struct transform *xfm_base,
+void dpp1_cm_program_regamma_lutb_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_RGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_RGAM_RAMB_START_CNTL_G);
@@ -524,15 +524,15 @@ void dcn10_dpp_cm_program_regamma_lutb_settings(
 	gam_regs.region_start = REG(CM_RGAM_RAMB_REGION_0_1);
 	gam_regs.region_end = REG(CM_RGAM_RAMB_REGION_32_33);
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 }
 
-void ippn10_program_input_csc(
-		struct transform *xfm_base,
+void dpp1_program_input_csc(
+		struct dpp *dpp_base,
 		enum dc_color_space color_space,
 		enum dcn10_input_csc_select select)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int i;
 	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
 	const uint16_t *regval = NULL;
@@ -560,10 +560,10 @@ void ippn10_program_input_csc(
 	REG_SET(CM_ICSC_CONTROL, 0,
 			CM_ICSC_MODE, selection);
 
-	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_ICSC_C11;
-	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_ICSC_C11;
-	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_ICSC_C12;
-	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_ICSC_C12;
+	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_ICSC_C11;
+	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_ICSC_C11;
+	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_ICSC_C12;
+	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_ICSC_C12;
 
 
 	if (select == INPUT_CSC_SELECT_ICSC) {
@@ -572,7 +572,7 @@ void ippn10_program_input_csc(
 		gam_regs.csc_c33_c34 = REG(CM_ICSC_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 	} else {
@@ -581,21 +581,21 @@ void ippn10_program_input_csc(
 		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 	}
 }
 
 /*program de gamma RAM B*/
-void ippn10_program_degamma_lutb_settings(
-		struct transform *xfm_base,
+void dpp1_program_degamma_lutb_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);
@@ -613,18 +613,18 @@ void ippn10_program_degamma_lutb_settings(
 	gam_regs.region_end = REG(CM_DGAM_RAMB_REGION_14_15);
 
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 }
 
 /*program de gamma RAM A*/
-void ippn10_program_degamma_luta_settings(
-		struct transform *xfm_base,
+void dpp1_program_degamma_luta_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);
@@ -641,34 +641,35 @@ void ippn10_program_degamma_luta_settings(
 	gam_regs.region_start = REG(CM_DGAM_RAMA_REGION_0_1);
 	gam_regs.region_end = REG(CM_DGAM_RAMA_REGION_14_15);
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 }
 
-void ippn10_power_on_degamma_lut(
-		struct transform *xfm_base,
+void dpp1_power_on_degamma_lut(
+		struct dpp *dpp_base,
 	bool power_on)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_SET(CM_MEM_PWR_CTRL, 0,
 			SHARED_MEM_PWR_DIS, power_on == true ? 0:1);
 
 }
 
-static void ippn10_enable_cm_block(
-		struct transform *xfm_base)
+static void dpp1_enable_cm_block(
+		struct dpp *dpp_base)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
 	REG_UPDATE(CM_CMOUT_CONTROL, CM_CMOUT_ROUND_TRUNC_MODE, 8);
 	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
 }
 
-void ippn10_set_degamma(
-		struct transform *xfm_base,
+void dpp1_set_degamma(
+		struct dpp *dpp_base,
 		enum ipp_degamma_mode mode)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	ippn10_enable_cm_block(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+	dpp1_enable_cm_block(dpp_base);
 
 	switch (mode) {
 	case IPP_DEGAMMA_MODE_BYPASS:
@@ -687,11 +688,11 @@ void ippn10_set_degamma(
 	}
 }
 
-void ippn10_degamma_ram_select(
-		struct transform *xfm_base,
+void dpp1_degamma_ram_select(
+		struct dpp *dpp_base,
 							bool use_ram_a)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (use_ram_a)
 		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
@@ -700,13 +701,13 @@ void ippn10_degamma_ram_select(
 
 }
 
-static bool ippn10_degamma_ram_inuse(
-		struct transform *xfm_base,
+static bool dpp1_degamma_ram_inuse(
+		struct dpp *dpp_base,
 							bool *ram_a_inuse)
 {
 	bool ret = false;
 	uint32_t status_reg = 0;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
 			&status_reg);
@@ -721,15 +722,15 @@ static bool ippn10_degamma_ram_inuse(
 	return ret;
 }
 
-void ippn10_program_degamma_lut(
-		struct transform *xfm_base,
+void dpp1_program_degamma_lut(
+		struct dpp *dpp_base,
 		const struct pwl_result_data *rgb,
 		uint32_t num,
 		bool is_ram_a)
 {
 	uint32_t i;
 
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);
 	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,
 				   CM_DGAM_LUT_WRITE_EN_MASK, 7);
@@ -751,27 +752,27 @@ void ippn10_program_degamma_lut(
 	}
 }
 
-void ippn10_set_degamma_pwl(struct transform *xfm_base,
+void dpp1_set_degamma_pwl(struct dpp *dpp_base,
 								 const struct pwl_params *params)
 {
 	bool is_ram_a = true;
 
-	ippn10_power_on_degamma_lut(xfm_base, true);
-	ippn10_enable_cm_block(xfm_base);
-	ippn10_degamma_ram_inuse(xfm_base, &is_ram_a);
+	dpp1_power_on_degamma_lut(dpp_base, true);
+	dpp1_enable_cm_block(dpp_base);
+	dpp1_degamma_ram_inuse(dpp_base, &is_ram_a);
 	if (is_ram_a == true)
-		ippn10_program_degamma_lutb_settings(xfm_base, params);
+		dpp1_program_degamma_lutb_settings(dpp_base, params);
 	else
-		ippn10_program_degamma_luta_settings(xfm_base, params);
+		dpp1_program_degamma_luta_settings(dpp_base, params);
 
-	ippn10_program_degamma_lut(xfm_base, params->rgb_resulted,
+	dpp1_program_degamma_lut(dpp_base, params->rgb_resulted,
 							params->hw_points_num, !is_ram_a);
-	ippn10_degamma_ram_select(xfm_base, !is_ram_a);
+	dpp1_degamma_ram_select(dpp_base, !is_ram_a);
 }
 
-void ippn10_full_bypass(struct transform *xfm_base)
+void dpp1_full_bypass(struct dpp *dpp_base)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	/* Input pixel format: ARGB8888 */
 	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
@@ -784,19 +785,19 @@ void ippn10_full_bypass(struct transform *xfm_base)
 			FORMAT_EXPANSION_MODE, 0);
 
 	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
-	if (xfm->tf_mask->CM_BYPASS_EN)
+	if (dpp->tf_mask->CM_BYPASS_EN)
 		REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
 
 	/* Setting degamma bypass for now */
 	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
 }
 
-static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,
+static bool dpp1_ingamma_ram_inuse(struct dpp *dpp_base,
 							bool *ram_a_inuse)
 {
 	bool in_use = false;
 	uint32_t status_reg = 0;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
 				&status_reg);
@@ -822,19 +823,19 @@ static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,
  * In the future, this function should support additional input gamma methods,
  * such as piecewise linear mapping, and input gamma bypass.
  */
-void ippn10_program_input_lut(
-		struct transform *xfm_base,
+void dpp1_program_input_lut(
+		struct dpp *dpp_base,
 		const struct dc_gamma *gamma)
 {
 	int i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	bool rama_occupied = false;
 	uint32_t ram_num;
 	// Power on LUT memory.
 	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 1);
-	ippn10_enable_cm_block(xfm_base);
+	dpp1_enable_cm_block(dpp_base);
 	// Determine whether to use RAM A or RAM B
-	ippn10_ingamma_ram_inuse(xfm_base, &rama_occupied);
+	dpp1_ingamma_ram_inuse(dpp_base, &rama_occupied);
 	if (!rama_occupied)
 		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 0);
 	else
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c
index e57b9d8..d401a7d4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c
@@ -40,14 +40,14 @@
 #define BLACK_OFFSET_CBCR  0x8000
 
 #define REG(reg)\
-	xfm->tf_regs->reg
+	dpp->tf_regs->reg
 
 #define CTX \
-	xfm->base.ctx
+	dpp->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+	dpp->tf_shift->field_name, dpp->tf_mask->field_name
 
 enum dcn10_coef_filter_type_sel {
 	SCL_COEF_LUMA_VERT_FILTER = 0,
@@ -86,7 +86,7 @@ enum dscl_mode_sel {
 };
 
 static void dpp_set_overscan(
-	struct dcn10_dpp *xfm,
+	struct dcn10_dpp *dpp,
 	const struct scaler_data *data)
 {
 	uint32_t left = data->recout.x;
@@ -114,7 +114,7 @@ static void dpp_set_overscan(
 }
 
 static void dpp_set_otg_blank(
-		struct dcn10_dpp *xfm, const struct scaler_data *data)
+		struct dcn10_dpp *dpp, const struct scaler_data *data)
 {
 	uint32_t h_blank_start = data->h_active;
 	uint32_t h_blank_end = 0;
@@ -165,13 +165,13 @@ static bool is_420_format(enum pixel_format format)
 }
 
 static enum dscl_mode_sel get_dscl_mode(
-		struct transform *xfm_base,
+		struct dpp *dpp_base,
 		const struct scaler_data *data,
 		bool dbg_always_scale)
 {
 	const long long one = dal_fixed31_32_one.value;
 
-	if (xfm_base->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT) {
+	if (dpp_base->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT) {
 		/* DSCL is processing data in fixed format */
 		if (data->format == PIXEL_FORMAT_FP16)
 			return DSCL_MODE_DSCL_BYPASS;
@@ -199,12 +199,12 @@ static enum dscl_mode_sel get_dscl_mode(
 }
 
 static void dpp_set_lb(
-	struct dcn10_dpp *xfm,
+	struct dcn10_dpp *dpp,
 	const struct line_buffer_params *lb_params,
 	enum lb_memory_config mem_size_config)
 {
 	/* LB */
-	if (xfm->base.caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT) {
+	if (dpp->base.caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT) {
 		/* DSCL caps: pixel data processed in fixed format */
 		uint32_t pixel_depth = get_pixel_depth_val(lb_params->depth);
 		uint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;
@@ -250,7 +250,7 @@ static const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)
 }
 
 static void dpp_set_scaler_filter(
-		struct dcn10_dpp *xfm,
+		struct dcn10_dpp *dpp,
 		uint32_t taps,
 		enum dcn10_coef_filter_type_sel filter_type,
 		const uint16_t *filter)
@@ -288,7 +288,7 @@ static void dpp_set_scaler_filter(
 }
 
 static void dpp_set_scl_filter(
-		struct dcn10_dpp *xfm,
+		struct dcn10_dpp *dpp,
 		const struct scaler_data *scl_data,
 		bool chroma_coef_mode)
 {
@@ -330,16 +330,16 @@ static void dpp_set_scl_filter(
 		filter_v = get_filter_coeffs_64p(
 				scl_data->taps.v_taps, scl_data->ratios.vert);
 
-		filter_updated = (filter_h && (filter_h != xfm->filter_h))
-				|| (filter_v && (filter_v != xfm->filter_v));
+		filter_updated = (filter_h && (filter_h != dpp->filter_h))
+				|| (filter_v && (filter_v != dpp->filter_v));
 
 		if (chroma_coef_mode) {
 			filter_h_c = get_filter_coeffs_64p(
 					scl_data->taps.h_taps_c, scl_data->ratios.horz_c);
 			filter_v_c = get_filter_coeffs_64p(
 					scl_data->taps.v_taps_c, scl_data->ratios.vert_c);
-			filter_updated = filter_updated || (filter_h_c && (filter_h_c != xfm->filter_h_c))
-							|| (filter_v_c && (filter_v_c != xfm->filter_v_c));
+			filter_updated = filter_updated || (filter_h_c && (filter_h_c != dpp->filter_h_c))
+							|| (filter_v_c && (filter_v_c != dpp->filter_v_c));
 		}
 
 		if (filter_updated) {
@@ -347,34 +347,34 @@ static void dpp_set_scl_filter(
 
 			if (!h_2tap_hardcode_coef_en && filter_h) {
 				dpp_set_scaler_filter(
-					xfm, scl_data->taps.h_taps,
+					dpp, scl_data->taps.h_taps,
 					SCL_COEF_LUMA_HORZ_FILTER, filter_h);
 			}
-			xfm->filter_h = filter_h;
+			dpp->filter_h = filter_h;
 			if (!v_2tap_hardcode_coef_en && filter_v) {
 				dpp_set_scaler_filter(
-					xfm, scl_data->taps.v_taps,
+					dpp, scl_data->taps.v_taps,
 					SCL_COEF_LUMA_VERT_FILTER, filter_v);
 			}
-			xfm->filter_v = filter_v;
+			dpp->filter_v = filter_v;
 			if (chroma_coef_mode) {
 				if (!h_2tap_hardcode_coef_en && filter_h_c) {
 					dpp_set_scaler_filter(
-						xfm, scl_data->taps.h_taps_c,
+						dpp, scl_data->taps.h_taps_c,
 						SCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);
 				}
 				if (!v_2tap_hardcode_coef_en && filter_v_c) {
 					dpp_set_scaler_filter(
-						xfm, scl_data->taps.v_taps_c,
+						dpp, scl_data->taps.v_taps_c,
 						SCL_COEF_CHROMA_VERT_FILTER, filter_v_c);
 				}
 			}
-			xfm->filter_h_c = filter_h_c;
-			xfm->filter_v_c = filter_v_c;
+			dpp->filter_h_c = filter_h_c;
+			dpp->filter_v_c = filter_v_c;
 
 			coef_ram_current = get_reg_field_value_ex(
-				scl_mode, xfm->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
-				xfm->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
+				scl_mode, dpp->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
+				dpp->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
 
 			/* Swap coefficient RAM and set chroma coefficient mode */
 			REG_SET_2(SCL_MODE, scl_mode,
@@ -458,27 +458,27 @@ bool is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)
 }
 
 void dpp_set_scaler_auto_scale(
-	struct transform *xfm_base,
+	struct dpp *dpp_base,
 	const struct scaler_data *scl_data)
 {
 	enum lb_memory_config lb_config;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	enum dscl_mode_sel dscl_mode = get_dscl_mode(
-			xfm_base, scl_data, xfm_base->ctx->dc->debug.always_scale);
+			dpp_base, scl_data, dpp_base->ctx->dc->debug.always_scale);
 	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
 				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
 
-	dpp_set_overscan(xfm, scl_data);
+	dpp_set_overscan(dpp, scl_data);
 
-	dpp_set_otg_blank(xfm, scl_data);
+	dpp_set_otg_blank(dpp, scl_data);
 
 	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
 
 	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
 		return;
 
-	lb_config =  find_lb_memory_config(xfm, scl_data);
-	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
+	lb_config =  find_lb_memory_config(dpp, scl_data);
+	dpp_set_lb(dpp, &scl_data->lb_params, lb_config);
 
 	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
 		return;
@@ -506,12 +506,12 @@ void dpp_set_scaler_auto_scale(
 		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
 		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
 
-	dpp_set_scl_filter(xfm, scl_data, ycbcr);
+	dpp_set_scl_filter(dpp, scl_data, ycbcr);
 }
 
 
 static void dpp_set_manual_ratio_init(
-		struct dcn10_dpp *xfm, const struct scaler_data *data)
+		struct dcn10_dpp *dpp, const struct scaler_data *data)
 {
 	uint32_t init_frac = 0;
 	uint32_t init_int = 0;
@@ -571,7 +571,7 @@ static void dpp_set_manual_ratio_init(
 
 
 static void dpp_set_recout(
-			struct dcn10_dpp *xfm, const struct rect *recout)
+			struct dcn10_dpp *dpp, const struct rect *recout)
 {
 	REG_SET_2(RECOUT_START, 0,
 		/* First pixel of RECOUT */
@@ -584,24 +584,24 @@ static void dpp_set_recout(
 			 RECOUT_WIDTH, recout->width,
 		/* Number of RECOUT vertical lines */
 			 RECOUT_HEIGHT, recout->height
-			 - xfm->base.ctx->dc->debug.surface_visual_confirm * 4 *
-			 (xfm->base.inst + 1));
+			 - dpp->base.ctx->dc->debug.surface_visual_confirm * 4 *
+			 (dpp->base.inst + 1));
 }
 
 /* Main function to program scaler and line buffer in manual scaling mode */
-void dcn10_dpp_dscl_set_scaler_manual_scale(
-	struct transform *xfm_base,
+void dpp1_dscl_set_scaler_manual_scale(
+	struct dpp *dpp_base,
 	const struct scaler_data *scl_data)
 {
 	enum lb_memory_config lb_config;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	enum dscl_mode_sel dscl_mode = get_dscl_mode(
-			xfm_base, scl_data, xfm_base->ctx->dc->debug.always_scale);
+			dpp_base, scl_data, dpp_base->ctx->dc->debug.always_scale);
 	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
 				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
 
 	/* Recout */
-	dpp_set_recout(xfm, &scl_data->recout);
+	dpp_set_recout(dpp, &scl_data->recout);
 
 	/* MPC Size */
 	REG_SET_2(MPC_SIZE, 0,
@@ -617,8 +617,8 @@ void dcn10_dpp_dscl_set_scaler_manual_scale(
 		return;
 
 	/* LB */
-	lb_config =  find_lb_memory_config(xfm, scl_data);
-	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
+	lb_config =  find_lb_memory_config(dpp, scl_data);
+	dpp_set_lb(dpp, &scl_data->lb_params, lb_config);
 
 	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
 		return;
@@ -641,7 +641,7 @@ void dcn10_dpp_dscl_set_scaler_manual_scale(
 				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
 
 	/* Manually calculate scale ratio and init values */
-	dpp_set_manual_ratio_init(xfm, scl_data);
+	dpp_set_manual_ratio_init(dpp, scl_data);
 
 	/* HTaps/VTaps */
 	REG_SET_4(SCL_TAP_CONTROL, 0,
@@ -650,5 +650,5 @@ void dcn10_dpp_dscl_set_scaler_manual_scale(
 		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
 		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
 
-	dpp_set_scl_filter(xfm, scl_data, ycbcr);
+	dpp_set_scl_filter(dpp, scl_data, ycbcr);
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 13bc672..da0c854 100755
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -948,10 +948,10 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct transform *xfm = dc->res_pool->transforms[i];
+		struct dpp *dpp = dc->res_pool->dpps[i];
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
-		xfm->funcs->transform_reset(xfm);
+		dpp->funcs->dpp_reset(dpp);
 		dc->res_pool->mpc->funcs->remove(
 				dc->res_pool->mpc, &(dc->res_pool->opps[i]->mpc_tree),
 				dc->res_pool->opps[i]->inst, i);
@@ -1199,14 +1199,14 @@ static void plane_atomic_disable(struct dc *dc,
 static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct transform *xfm = dc->res_pool->transforms[fe_idx];
+	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
 		dpp_pg_control(hws, fe_idx, false);
 		hubp_pg_control(hws, fe_idx, false);
-		xfm->funcs->transform_reset(xfm);
+		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
 		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
@@ -1256,7 +1256,7 @@ static void reset_front_end(
 static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct transform *xfm = dc->res_pool->transforms[fe_idx];
+	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
 
 	reset_front_end(dc, fe_idx);
 
@@ -1264,7 +1264,7 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 			IP_REQUEST_EN, 1);
 	dpp_pg_control(hws, fe_idx, false);
 	hubp_pg_control(hws, fe_idx, false);
-	xfm->funcs->transform_reset(xfm);
+	dpp->funcs->dpp_reset(dpp);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
@@ -1420,34 +1420,34 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 static bool dcn10_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
-	struct transform *xfm_base = pipe_ctx->plane_res.xfm;
+	struct dpp *dpp_base = pipe_ctx->plane_res.dpp;
 	const struct dc_transfer_func *tf = NULL;
 	bool result = true;
 
-	if (xfm_base == NULL)
+	if (dpp_base == NULL)
 		return false;
 
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction && dce_use_lut(plane_state))
-		xfm_base->funcs->ipp_program_input_lut(xfm_base,
+		dpp_base->funcs->ipp_program_input_lut(dpp_base,
 				plane_state->gamma_correction);
 
 	if (tf == NULL)
-		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
+		dpp_base->funcs->ipp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			dpp_base->funcs->ipp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			dpp_base->funcs->ipp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			dpp_base->funcs->ipp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
@@ -1458,7 +1458,7 @@ static bool dcn10_set_input_transfer_func(
 			break;
 		}
 	} else if (tf->type == TF_TYPE_BYPASS) {
-		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
+		dpp_base->funcs->ipp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS*/
 		result = false;
@@ -1785,25 +1785,25 @@ static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct dc_stream_state *stream)
 {
-	struct transform *xfm = pipe_ctx->plane_res.xfm;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 
-	if (xfm == NULL)
+	if (dpp == NULL)
 		return false;
 
-	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
+	dpp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->out_transfer_func &&
 		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
 		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
-		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
+		dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
-				stream->out_transfer_func, &xfm->regamma_params)) {
-			xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
-			xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
+				stream->out_transfer_func, &dpp->regamma_params)) {
+			dpp->funcs->opp_program_regamma_pwl(dpp, &dpp->regamma_params);
+			dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_USER);
 	} else {
-		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_BYPASS);
+		dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_BYPASS);
 	}
 
 	return true;
@@ -2088,7 +2088,7 @@ static void dcn10_power_on_fe(
 
 static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 {
-	struct xfm_grph_csc_adjustment adjust;
+	struct dpp_grph_csc_adjustment adjust;
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
@@ -2124,7 +2124,7 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 				gamut_remap_matrix.matrix[10];
 	}
 
-	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);
 }
 
 
@@ -2146,7 +2146,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
-			pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.xfm, &tbl_entry);
+			pipe_ctx->plane_res.dpp->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
 	}
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
@@ -2330,7 +2330,7 @@ static void update_dchubp_dpp(
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct transform *xfm = pipe_ctx->plane_res.xfm;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
 	struct mpcc_cfg mpcc_cfg = {0};
@@ -2372,7 +2372,7 @@ static void update_dchubp_dpp(
 				hws
 				);
 
-	xfm->funcs->ipp_setup(xfm,
+	dpp->funcs->ipp_setup(dpp,
 			plane_state->format,
 			EXPANSION_MODE_ZERO);
 
@@ -2401,8 +2401,9 @@ static void update_dchubp_dpp(
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
-	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(
-			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data);
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(
+			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
+
 	hubp->funcs->mem_program_viewport(hubp,
 			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index 60810f9..fecbef9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -702,8 +702,8 @@ static void destruct(struct dcn10_resource_pool *pool)
 		if (pool->base.opps[i] != NULL)
 			pool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);
 
-		if (pool->base.transforms[i] != NULL)
-			dcn10_dpp_destroy(&pool->base.transforms[i]);
+		if (pool->base.dpps[i] != NULL)
+			dcn10_dpp_destroy(&pool->base.dpps[i]);
 
 		if (pool->base.ipps[i] != NULL)
 			pool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);
@@ -924,7 +924,7 @@ static struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(
 
 	idle_pipe->plane_res.hubp = pool->hubps[idle_pipe->pipe_idx];
 	idle_pipe->plane_res.ipp = pool->ipps[idle_pipe->pipe_idx];
-	idle_pipe->plane_res.xfm = pool->transforms[idle_pipe->pipe_idx];
+	idle_pipe->plane_res.dpp = pool->dpps[idle_pipe->pipe_idx];
 
 	return idle_pipe;
 }
@@ -1377,8 +1377,8 @@ static bool construct(
 			goto ipp_create_fail;
 		}
 
-		pool->base.transforms[j] = dcn10_dpp_create(ctx, i);
-		if (pool->base.transforms[j] == NULL) {
+		pool->base.dpps[j] = dcn10_dpp_create(ctx, i);
+		if (pool->base.dpps[j] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
 				"DC: failed to create dpp!\n");
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index a20114c..72badc7 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -84,6 +84,7 @@ void core_link_set_avmute(struct pipe_ctx *pipe_ctx, bool enable);
 /********** DAL Core*********************/
 #include "display_clock.h"
 #include "transform.h"
+#include "dpp.h"
 
 struct resource_pool;
 struct dc_state;
@@ -133,6 +134,7 @@ struct resource_pool {
 	struct hubp *hubps[MAX_PIPES];
 	struct input_pixel_processor *ipps[MAX_PIPES];
 	struct transform *transforms[MAX_PIPES];
+	struct dpp *dpps[MAX_PIPES];
 	struct output_pixel_processor *opps[MAX_PIPES];
 	struct timing_generator *timing_generators[MAX_PIPES];
 	struct stream_encoder *stream_enc[MAX_PIPES * 2];
@@ -184,6 +186,7 @@ struct plane_resource {
 	struct mem_input *mi;
 	struct input_pixel_processor *ipp;
 	struct transform *xfm;
+	struct dpp *dpp;
 };
 
 struct pipe_ctx {
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
new file mode 100644
index 0000000..83a6846
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+
+#ifndef __DAL_DPP_H__
+#define __DAL_DPP_H__
+
+#include "transform.h"
+
+struct dpp {
+	const struct dpp_funcs *funcs;
+	struct dc_context *ctx;
+	int inst;
+	struct dpp_caps *caps;
+	struct pwl_params regamma_params;
+};
+
+struct dpp_grph_csc_adjustment {
+	struct fixed31_32 temperature_matrix[CSC_TEMPERATURE_MATRIX_SIZE];
+	enum graphics_gamut_adjust_type gamut_adjust_type;
+};
+
+struct dpp_funcs {
+	void (*dpp_reset)(struct dpp *dpp);
+
+	void (*dpp_set_scaler)(struct dpp *dpp,
+			const struct scaler_data *scl_data);
+
+	void (*dpp_set_pixel_storage_depth)(
+			struct dpp *dpp,
+			enum lb_pixel_depth depth,
+			const struct bit_depth_reduction_params *bit_depth_params);
+
+	bool (*dpp_get_optimal_number_of_taps)(
+			struct dpp *dpp,
+			struct scaler_data *scl_data,
+			const struct scaling_taps *in_taps);
+
+	void (*dpp_set_gamut_remap)(
+			struct dpp *dpp,
+			const struct dpp_grph_csc_adjustment *adjust);
+
+	void (*opp_set_csc_default)(
+		struct dpp *dpp,
+		const struct default_adjustment *default_adjust);
+
+	void (*opp_set_csc_adjustment)(
+		struct dpp *dpp,
+		const struct out_csc_color_matrix *tbl_entry);
+
+	void (*opp_power_on_regamma_lut)(
+		struct dpp *dpp,
+		bool power_on);
+
+	void (*opp_program_regamma_lut)(
+			struct dpp *dpp,
+			const struct pwl_result_data *rgb,
+			uint32_t num);
+
+	void (*opp_configure_regamma_lut)(
+			struct dpp *dpp,
+			bool is_ram_a);
+
+	void (*opp_program_regamma_lutb_settings)(
+			struct dpp *dpp,
+			const struct pwl_params *params);
+
+	void (*opp_program_regamma_luta_settings)(
+			struct dpp *dpp,
+			const struct pwl_params *params);
+
+	void (*opp_program_regamma_pwl)(
+		struct dpp *dpp, const struct pwl_params *params);
+
+	void (*opp_set_regamma_mode)(
+			struct dpp *dpp_base,
+			enum opp_regamma mode);
+
+	void (*ipp_set_degamma)(
+			struct dpp *dpp_base,
+			enum ipp_degamma_mode mode);
+
+	void (*ipp_program_input_lut)(
+			struct dpp *dpp_base,
+			const struct dc_gamma *gamma);
+
+	void (*ipp_program_degamma_pwl)(struct dpp *dpp_base,
+									 const struct pwl_params *params);
+
+	void (*ipp_setup)(
+			struct dpp *dpp_base,
+			enum surface_pixel_format input_format,
+			enum expansion_mode mode);
+
+	void (*ipp_full_bypass)(struct dpp *dpp_base);
+
+	void (*set_cursor_attributes)(
+			struct dpp *dpp_base,
+			const struct dc_cursor_attributes *attr);
+
+	void (*set_cursor_position)(
+			struct dpp *dpp_base,
+			const struct dc_cursor_position *pos,
+			const struct dc_cursor_mi_param *param,
+			uint32_t width
+			);
+
+};
+
+
+
+#endif
-- 
2.7.4

