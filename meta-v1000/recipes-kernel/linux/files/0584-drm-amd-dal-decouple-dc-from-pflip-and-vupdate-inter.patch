From 69c87db2bab082a50a9afb18cda42e4d4ea2acf3 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Wed, 15 Jun 2016 17:53:00 -0400
Subject: [PATCH 0584/1722] drm/amd/dal: decouple dc from pflip and vupdate
 interrupts

Change-Id: I65941d16a446c4582d65cf773872f26b774f58dd
Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      | 21 ++++-----
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    | 17 ++++++++
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 50 ----------------------
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  6 +++
 drivers/gpu/drm/amd/dal/dc/core/dc_target.c        |  2 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    | 10 ++---
 6 files changed, 35 insertions(+), 71 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index 3d2d0a3..025c7ba 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -132,9 +132,9 @@ static int dm_soft_reset(void *handle)
 	return 0;
 }
 
-static struct amdgpu_crtc *get_crtc_by_target(
+static struct amdgpu_crtc *get_crtc_by_otg_inst(
 	struct amdgpu_device *adev,
-	const struct dc_target *dc_target)
+	int otg_inst)
 {
 	struct drm_device *dev = adev->ddev;
 	struct drm_crtc *crtc;
@@ -144,7 +144,7 @@ static struct amdgpu_crtc *get_crtc_by_target(
 	 * following if is check inherited from both functions where this one is
 	 * used now. Need to be checked why it could happen.
 	 */
-	if (dc_target == NULL) {
+	if (otg_inst == -1) {
 		WARN_ON(1);
 		return adev->mode_info.crtcs[0];
 	}
@@ -152,7 +152,7 @@ static struct amdgpu_crtc *get_crtc_by_target(
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 		amdgpu_crtc = to_amdgpu_crtc(crtc);
 
-		if (amdgpu_crtc->target == dc_target)
+		if (amdgpu_crtc->otg_inst == otg_inst)
 			return amdgpu_crtc;
 	}
 
@@ -166,11 +166,8 @@ static void dm_pflip_high_irq(void *interrupt_params)
 	struct common_irq_params *irq_params = interrupt_params;
 	struct amdgpu_device *adev = irq_params->adev;
 	unsigned long flags;
-	const struct dc *dc = irq_params->adev->dm.dc;
-	const struct dc_target *dc_target =
-			dc_get_target_on_irq_source(dc, irq_params->irq_src);
 
-	amdgpu_crtc = get_crtc_by_target(adev, dc_target);
+	amdgpu_crtc = get_crtc_by_otg_inst(adev, irq_params->irq_src - IRQ_TYPE_PFLIP);
 
 	/* IRQ could occur when in initial stage */
 	/*TODO work and BO cleanup */
@@ -216,17 +213,15 @@ static void dm_crtc_high_irq(void *interrupt_params)
 {
 	struct common_irq_params *irq_params = interrupt_params;
 	struct amdgpu_device *adev = irq_params->adev;
-	const struct dc *dc = irq_params->adev->dm.dc;
-	const struct dc_target *dc_target =
-			dc_get_target_on_irq_source(dc, irq_params->irq_src);
 	uint8_t crtc_index = 0;
-	struct amdgpu_crtc *acrtc = get_crtc_by_target(adev, dc_target);
+	struct amdgpu_crtc *acrtc;
+
+	acrtc = get_crtc_by_otg_inst(adev, irq_params->irq_src - IRQ_TYPE_VUPDATE);
 
 	if (acrtc)
 		crtc_index = acrtc->crtc_id;
 
 	drm_handle_vblank(adev->ddev, crtc_index);
-
 }
 
 static int dm_set_clockgating_state(void *handle,
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index 21c02bd..daa16cc 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -2269,6 +2269,7 @@ int amdgpu_dm_atomic_commit(
 				/* this is the update mode case */
 				dc_target_release(acrtc->target);
 				acrtc->target = NULL;
+				acrtc->otg_inst = -1;
 			}
 
 			/*
@@ -2321,6 +2322,14 @@ int amdgpu_dm_atomic_commit(
 	/* DC is optimized not to do anything if 'targets' didn't change. */
 	dc_commit_targets(dm->dc, commit_targets, commit_targets_count);
 
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+
+		if (acrtc->target != NULL)
+			acrtc->otg_inst =
+				dc_target_get_status(acrtc->target)->primary_otg_inst;
+	}
+
 	/* update planes when needed */
 	for_each_plane_in_state(state, plane, old_plane_state, i) {
 		struct drm_plane_state *plane_state = plane->state;
@@ -2501,6 +2510,14 @@ void dm_restore_drm_connector_state(struct drm_device *dev, struct drm_connector
 			return;
 		}
 
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+			struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+
+			if (acrtc->target != NULL)
+				acrtc->otg_inst =
+					dc_target_get_status(acrtc->target)->primary_otg_inst;
+		}
+
 		dc_target_release(current_target);
 
 		dm_dc_surface_commit(dc, &disconnected_acrtc->base,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 1a350da..a239250 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -1123,56 +1123,6 @@ void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 	dal_irq_service_ack(core_dc->res_pool.irqs, src);
 }
 
-const struct dc_target *dc_get_target_on_irq_source(
-		const struct dc *dc,
-		enum dc_irq_source src)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-
-	uint8_t i, j;
-	uint8_t crtc_idx;
-
-	switch (src) {
-	case DC_IRQ_SOURCE_VUPDATE1:
-	case DC_IRQ_SOURCE_VUPDATE2:
-	case DC_IRQ_SOURCE_VUPDATE3:
-	case DC_IRQ_SOURCE_VUPDATE4:
-	case DC_IRQ_SOURCE_VUPDATE5:
-	case DC_IRQ_SOURCE_VUPDATE6:
-		crtc_idx = src - DC_IRQ_SOURCE_VUPDATE1;
-		break;
-	case DC_IRQ_SOURCE_PFLIP1:
-	case DC_IRQ_SOURCE_PFLIP2:
-	case DC_IRQ_SOURCE_PFLIP3:
-	case DC_IRQ_SOURCE_PFLIP4:
-	case DC_IRQ_SOURCE_PFLIP5:
-	case DC_IRQ_SOURCE_PFLIP6:
-	case DC_IRQ_SOURCE_PFLIP_UNDERLAY0:
-		crtc_idx = src - DC_IRQ_SOURCE_PFLIP1;
-		break;
-	default:
-		dm_error("%s: invalid irq source: %d\n!" ,__func__, src);
-		return NULL;
-	}
-
-	for (i = 0; i < core_dc->current_context->target_count; i++) {
-		struct core_target *target = core_dc->current_context->targets[i];
-		struct dc_target *dc_target = &target->public;
-
-		for (j = 0; j < target->public.stream_count; j++) {
-			const struct core_stream *stream =
-				DC_STREAM_TO_CORE(dc_target->streams[j]);
-
-			if (core_dc->current_context->res_ctx.
-					pipe_ctx[crtc_idx].stream == stream)
-				return dc_target;
-		}
-	}
-
-	dm_error("%s: 'dc_target' is NULL for irq source: %d\n!", __func__, src);
-	return NULL;
-}
-
 void dc_set_power_state(
 	struct dc *dc,
 	enum dc_acpi_cm_power_state power_state,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 8a096bb..2b978ab 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -29,6 +29,7 @@
 #include "link_encoder.h"
 #include "stream_encoder.h"
 #include "opp.h"
+#include "timing_generator.h"
 #include "transform.h"
 #include "set_mode_types.h"
 
@@ -1076,6 +1077,11 @@ enum dc_status resource_map_pool_resources(
 						&context->res_ctx,
 						pipe_ctx->audio);
 			}
+
+			if (j == 0) {
+				context->target_status[i].primary_otg_inst =
+						pipe_ctx->tg->inst;
+			}
 		}
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
index ff1ec0e..d9f9cef 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
@@ -92,7 +92,7 @@ const struct dc_target_status *dc_target_get_status(
 {
 	uint8_t i;
 	struct core_target* target = DC_TARGET_TO_CORE(dc_target);
-    struct core_dc *dc = DC_TO_CORE(target->ctx->dc);
+	struct core_dc *dc = DC_TO_CORE(target->ctx->dc);
 
 	for (i = 0; i < dc->current_context->target_count; i++)
 		if (target == dc->current_context->targets[i])
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 100a677..70cbd6f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -225,11 +225,10 @@ struct dc_target {
  * the IRQ source, current frame counter and currently attached surfaces.
  */
 struct dc_target_status {
-	enum dc_irq_source page_flip_src;
-	enum dc_irq_source v_update_src;
-	uint32_t cur_frame_count;
+	int primary_otg_inst;
+	int cur_frame_count;
+	int surface_count;
 	const struct dc_surface *surfaces[MAX_SURFACE_NUM];
-	uint8_t surface_count;
 };
 
 struct dc_target *dc_create_target_for_streams(
@@ -524,9 +523,6 @@ void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable);
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src);
 enum dc_irq_source dc_get_hpd_irq_source_at_index(
 		struct dc *dc, uint32_t link_index);
-const struct dc_target *dc_get_target_on_irq_source(
-		const struct dc *dc,
-		enum dc_irq_source src);
 
 /*******************************************************************************
  * Power Interfaces
-- 
2.7.4

