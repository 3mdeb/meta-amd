From d7d65d86cb9b97e33df620b6f2ffe65d13f96771 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Thu, 2 Jun 2016 14:56:52 -0400
Subject: [PATCH 0525/1722] drm/amd/dal: Pull apply_ctx_to_surface into
 separate function

This change allows us to overwrite this for new DCEs

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 103 +-----------------
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 116 +++++++++++++++++++++
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |   5 +
 3 files changed, 123 insertions(+), 101 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 45e170bb..8d55e1a 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -977,107 +977,8 @@ bool dc_commit_surfaces_to_target(
 		target_disable_memory_requests(dc_target,
 				&core_dc->current_context->res_ctx);
 
-	for (i = 0; i < new_surface_count; i++)
-		for (j = 0; j < context->res_ctx.pool.pipe_count; j++) {
-			struct dc_surface *dc_surface = new_surfaces[i];
-			struct core_surface *surface =
-						DC_SURFACE_TO_CORE(dc_surface);
-			struct pipe_ctx *pipe_ctx =
-						&context->res_ctx.pipe_ctx[j];
-			struct core_gamma *gamma = NULL;
-			int lock_mask =
-				PIPE_LOCK_CONTROL_GRAPHICS |
-				PIPE_LOCK_CONTROL_SCL |
-				PIPE_LOCK_CONTROL_BLENDER |
-				PIPE_LOCK_CONTROL_MODE;
-
-			if (pipe_ctx->surface !=
-					DC_SURFACE_TO_CORE(new_surfaces[i]))
-				continue;
-
-			dal_logger_write(core_dc->ctx->logger,
-					LOG_MAJOR_INTERFACE_TRACE,
-					LOG_MINOR_COMPONENT_DC,
-					"Pipe:%d 0x%x: addr hi:0x%x, "
-					"addr low:0x%x, "
-					"src: %d, %d, %d,"
-					" %d; dst: %d, %d, %d, %d;\n",
-					pipe_ctx->pipe_idx,
-					dc_surface,
-					dc_surface->address.grph.addr.high_part,
-					dc_surface->address.grph.addr.low_part,
-					dc_surface->src_rect.x,
-					dc_surface->src_rect.y,
-					dc_surface->src_rect.width,
-					dc_surface->src_rect.height,
-					dc_surface->dst_rect.x,
-					dc_surface->dst_rect.y,
-					dc_surface->dst_rect.width,
-					dc_surface->dst_rect.height);
-
-
-			dal_logger_write(core_dc->ctx->logger,
-					LOG_MAJOR_HW_TRACE,
-					LOG_MINOR_HW_TRACE_SET_MODE,
-					"Pipe %d: width, height, x, y\n"
-					"viewport:%d, %d, %d, %d\n"
-					"recout:  %d, %d, %d, %d\n",
-					pipe_ctx->pipe_idx,
-					pipe_ctx->scl_data.viewport.width,
-					pipe_ctx->scl_data.viewport.height,
-					pipe_ctx->scl_data.viewport.x,
-					pipe_ctx->scl_data.viewport.y,
-					pipe_ctx->scl_data.recout.width,
-					pipe_ctx->scl_data.recout.height,
-					pipe_ctx->scl_data.recout.x,
-					pipe_ctx->scl_data.recout.y);
-
-			if (!pipe_ctx->surface->public.flip_immediate)
-				lock_mask |= PIPE_LOCK_CONTROL_SURFACE;
-
-			core_dc->hwss.pipe_control_lock(
-					core_dc->ctx,
-					pipe_ctx->pipe_idx,
-					lock_mask,
-					true);
-
-			core_dc->hwss.set_plane_config(
-					core_dc, pipe_ctx, &context->res_ctx);
-
-			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-
-			if (surface->public.gamma_correction)
-				gamma = DC_GAMMA_TO_CORE(
-					surface->public.gamma_correction);
-
-			core_dc->hwss.set_gamma_correction(
-					pipe_ctx->ipp,
-					pipe_ctx->opp,
-					gamma, surface);
-		}
-
-	/* Go in reverse order so that all pipes are unlocked simultaneously
-	 * when pipe 0 is unlocked
-	 * Need PIPE_LOCK_CONTROL_MODE to be 1 for this
-	 */
-	for (j = context->res_ctx.pool.pipe_count - 1; j >= 0; j--)
-		for (i = new_surface_count - 1; i >= 0; i--) {
-			struct pipe_ctx *pipe_ctx =
-						&context->res_ctx.pipe_ctx[j];
-
-			if (pipe_ctx->surface !=
-					DC_SURFACE_TO_CORE(new_surfaces[i]))
-				continue;
-
-			core_dc->hwss.pipe_control_lock(
-					core_dc->ctx,
-					pipe_ctx->pipe_idx,
-					PIPE_LOCK_CONTROL_GRAPHICS |
-					PIPE_LOCK_CONTROL_SCL |
-					PIPE_LOCK_CONTROL_BLENDER |
-					PIPE_LOCK_CONTROL_SURFACE,
-					false);
-		}
+        core_dc->hwss.apply_ctx_to_surface(core_dc, context, new_surfaces,
+                        new_surface_count);
 
 	/* Lower display clock if necessary */
 	if (prev_disp_clk > context->bw_results.dispclk_khz) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 4f81352..d0c1058 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1593,9 +1593,125 @@ static void init_hw(struct core_dc *dc)
 	}
 }
 
+static enum dc_status apply_ctx_to_surface(
+		struct core_dc *dc,
+		struct validate_context *context,
+		struct dc_surface *new_surfaces[],
+		uint8_t new_surface_count)
+{
+	int i, j;
+
+	for (i = 0; i < new_surface_count; i++)
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct dc_surface *dc_surface = new_surfaces[i];
+			struct core_surface *surface =
+						DC_SURFACE_TO_CORE(dc_surface);
+			struct pipe_ctx *pipe_ctx =
+						&context->res_ctx.pipe_ctx[j];
+			struct core_gamma *gamma = NULL;
+			int lock_mask =
+				PIPE_LOCK_CONTROL_GRAPHICS |
+				PIPE_LOCK_CONTROL_SCL |
+				PIPE_LOCK_CONTROL_BLENDER |
+				PIPE_LOCK_CONTROL_MODE;
+
+			if (pipe_ctx->surface !=
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+
+			dal_logger_write(dc->ctx->logger,
+					LOG_MAJOR_INTERFACE_TRACE,
+					LOG_MINOR_COMPONENT_DC,
+					"Pipe:%d 0x%x: addr hi:0x%x, "
+					"addr low:0x%x, "
+					"src: %d, %d, %d,"
+					" %d; dst: %d, %d, %d, %d;\n",
+					pipe_ctx->pipe_idx,
+					dc_surface,
+					dc_surface->address.grph.addr.high_part,
+					dc_surface->address.grph.addr.low_part,
+					dc_surface->src_rect.x,
+					dc_surface->src_rect.y,
+					dc_surface->src_rect.width,
+					dc_surface->src_rect.height,
+					dc_surface->dst_rect.x,
+					dc_surface->dst_rect.y,
+					dc_surface->dst_rect.width,
+					dc_surface->dst_rect.height);
+
+
+			dal_logger_write(dc->ctx->logger,
+					LOG_MAJOR_HW_TRACE,
+					LOG_MINOR_HW_TRACE_SET_MODE,
+					"Pipe %d: width, height, x, y\n"
+					"viewport:%d, %d, %d, %d\n"
+					"recout:  %d, %d, %d, %d\n",
+					pipe_ctx->pipe_idx,
+					pipe_ctx->scl_data.viewport.width,
+					pipe_ctx->scl_data.viewport.height,
+					pipe_ctx->scl_data.viewport.x,
+					pipe_ctx->scl_data.viewport.y,
+					pipe_ctx->scl_data.recout.width,
+					pipe_ctx->scl_data.recout.height,
+					pipe_ctx->scl_data.recout.x,
+					pipe_ctx->scl_data.recout.y);
+
+			if (!pipe_ctx->surface->public.flip_immediate)
+				lock_mask |= PIPE_LOCK_CONTROL_SURFACE;
+
+			dc->hwss.pipe_control_lock(
+					dc->ctx,
+					pipe_ctx->pipe_idx,
+					lock_mask,
+					true);
+
+			dc->hwss.set_plane_config(
+					dc, pipe_ctx, &context->res_ctx);
+
+			dc->hwss.update_plane_addr(dc, pipe_ctx);
+
+			if (surface->public.gamma_correction)
+				gamma = DC_GAMMA_TO_CORE(
+					surface->public.gamma_correction);
+
+			dc->hwss.set_gamma_correction(
+					pipe_ctx->ipp,
+					pipe_ctx->opp,
+					gamma, surface);
+
+		}
+
+	/* Go in reverse order so that all pipes are unlocked simultaneously
+	 * when pipe 0 is unlocked
+	 * Need PIPE_LOCK_CONTROL_MODE to be 1 for this
+	 */
+	for (j = context->res_ctx.pool->pipe_count - 1; j >= 0; j--)
+		for (i = new_surface_count - 1; i >= 0; i--) {
+			struct pipe_ctx *pipe_ctx =
+						&context->res_ctx.pipe_ctx[j];
+
+			if (pipe_ctx->surface !=
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+			dc->hwss.pipe_control_lock(
+					dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_GRAPHICS |
+					PIPE_LOCK_CONTROL_SCL |
+					PIPE_LOCK_CONTROL_BLENDER |
+					PIPE_LOCK_CONTROL_SURFACE,
+					false);
+		}
+
+	return DC_OK;
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = apply_ctx_to_hw,
+	.apply_ctx_to_surface = apply_ctx_to_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
 	.set_gamma_correction = set_gamma_ramp,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 36e91d2..ba4abe0 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -50,6 +50,11 @@ struct hw_sequencer_funcs {
 	enum dc_status (*apply_ctx_to_hw)(
 			struct core_dc *dc, struct validate_context *context);
 
+	enum dc_status (*apply_ctx_to_surface)(
+			struct core_dc *dc, struct validate_context *context,
+			struct dc_surface *new_surfaces[],
+			uint8_t new_surface_count);
+
 	void (*set_plane_config)(
 			const struct core_dc *dc,
 			struct pipe_ctx *pipe_ctx,
-- 
2.7.4

