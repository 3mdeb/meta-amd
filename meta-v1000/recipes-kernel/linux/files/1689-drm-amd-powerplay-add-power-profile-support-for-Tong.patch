From 4432733537421960689e562b8fd2890948f1311b Mon Sep 17 00:00:00 2001
From: Ayyappa Ch <ayyappa.chandolu@amd.com>
Date: Fri, 27 Jan 2017 18:14:36 +0530
Subject: [PATCH 1689/1722] drm/amd/powerplay: add power profile support for
 Tonga

Change-Id: I817a96e0bfe015dacfd801d28cd27b6924bd5ce9
Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
Signed-off-by: Ayyappa Ch <ayyappa.chandolu@amd.com>
---
 drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c | 174 ++++++++++++++++++----
 1 file changed, 148 insertions(+), 26 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c b/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c
index e884d34..8a42fac 100644
--- a/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c
@@ -2880,6 +2880,30 @@ int tonga_populate_smc_initial_state(struct pp_hwmgr *hwmgr,
 	return 0;
 }
 
+static void tonga_save_default_power_profile(struct pp_hwmgr *hwmgr)
+{
+	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+	struct SMU72_Discrete_GraphicsLevel *levels =
+				data->smc_state_table.GraphicsLevel;
+
+	hwmgr->default_gfx_power_profile.activity_threshold =
+			be16_to_cpu(levels[0].ActivityLevel);
+	hwmgr->default_gfx_power_profile.up_hyst = levels[0].UpHyst;
+	hwmgr->default_gfx_power_profile.down_hyst = levels[0].DownHyst;
+	hwmgr->default_gfx_power_profile.type = PP_GFX_PROFILE;
+
+	hwmgr->default_compute_power_profile = hwmgr->default_gfx_power_profile;
+	hwmgr->default_compute_power_profile.type = PP_COMPUTE_PROFILE;
+
+	/* Workaround for SDMA instability: disable lowest SCLK DPM state */
+	hwmgr->default_compute_power_profile.min_sclk =
+			be32_to_cpu(levels[1].SclkFrequency);
+	/* TODO: Optimize hysteresis and threshold for compute workloads */
+
+	hwmgr->gfx_power_profile = hwmgr->default_gfx_power_profile;
+	hwmgr->compute_power_profile = hwmgr->default_compute_power_profile;
+}
+
 /**
  * Initializes the SMC table and uploads it
  *
@@ -3115,6 +3139,8 @@ static int tonga_init_smc_table(struct pp_hwmgr *hwmgr)
 	PP_ASSERT_WITH_CODE(0 == result,
 		"Failed to upload dpm data to SMC memory!", return result;);
 
+	tonga_save_default_power_profile(hwmgr);
+
 	return result;
 }
 
@@ -6282,28 +6308,123 @@ static int tonga_get_mclk_od(struct pp_hwmgr *hwmgr)
 
 static int tonga_set_mclk_od(struct pp_hwmgr *hwmgr, uint32_t value)
 {
-        struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
-        struct tonga_single_dpm_table *golden_mclk_table =
-                        &(data->golden_dpm_table.mclk_table);
-        struct pp_power_state  *ps;
-        struct tonga_power_state  *tonga_ps;
- 
-        if (value > 20)
-                value = 20;
- 
-        ps = hwmgr->request_ps;
- 
-        if (ps == NULL)
-                return -EINVAL;
- 
-        tonga_ps = cast_phw_tonga_power_state(&ps->hardware);
- 
-        tonga_ps->performance_levels[tonga_ps->performance_level_count - 1].memory_clock =
-                        golden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value *
-                        value / 100 +
-                        golden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value;
- 
-        return 0;
+	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+	struct tonga_single_dpm_table *golden_mclk_table =
+			&(data->golden_dpm_table.mclk_table);
+	struct pp_power_state  *ps;
+	struct tonga_power_state  *tonga_ps;
+
+	if (value > 20)
+		value = 20;
+
+	ps = hwmgr->request_ps;
+
+	if (ps == NULL)
+		return -EINVAL;
+
+	tonga_ps = cast_phw_tonga_power_state(&ps->hardware);
+
+	tonga_ps->performance_levels[tonga_ps->performance_level_count - 1].memory_clock =
+			golden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value *
+			value / 100 +
+			golden_mclk_table->dpm_levels[golden_mclk_table->count - 1].value;
+
+	return 0;
+}
+
+static int tonga_populate_requested_graphic_levels(struct pp_hwmgr *hwmgr,
+		struct pp_profile *request)
+{
+	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+	struct tonga_dpm_table *dpm_table = &(data->dpm_table);
+	struct SMU72_Discrete_GraphicsLevel *levels =
+			data->smc_state_table.GraphicsLevel;
+	uint32_t array = data->dpm_table_start +
+			offsetof(SMU72_Discrete_DpmTable, GraphicsLevel);
+	uint32_t array_size = sizeof(struct SMU72_Discrete_GraphicsLevel) *
+			SMU72_MAX_LEVELS_GRAPHICS;
+	uint32_t i;
+
+	for (i = 0; i < dpm_table->sclk_table.count; i++) {
+		levels[i].ActivityLevel =
+				cpu_to_be16(request->activity_threshold);
+		levels[i].EnabledForActivity = 1;
+		levels[i].UpHyst = request->up_hyst;
+		levels[i].DownHyst = request->down_hyst;
+	}
+
+	return tonga_copy_bytes_to_smc(hwmgr->smumgr, array, (uint8_t *)levels,
+				array_size, data->sram_end);
+}
+
+static void tonga_find_min_clock_masks(struct pp_hwmgr *hwmgr,
+		uint32_t *sclk_mask, uint32_t *mclk_mask,
+		uint32_t min_sclk, uint32_t min_mclk)
+{
+	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+	struct tonga_dpm_table *dpm_table = &(data->dpm_table);
+	uint32_t i;
+
+	for (i = 0; i < dpm_table->sclk_table.count; i++) {
+		if (dpm_table->sclk_table.dpm_levels[i].enabled &&
+			dpm_table->sclk_table.dpm_levels[i].value >= min_sclk)
+			*sclk_mask |= 1 << i;
+	}
+
+	for (i = 0; i < dpm_table->mclk_table.count; i++) {
+		if (dpm_table->mclk_table.dpm_levels[i].enabled &&
+			dpm_table->mclk_table.dpm_levels[i].value >= min_mclk)
+			*mclk_mask |= 1 << i;
+	}
+}
+
+static int tonga_set_power_profile_state(struct pp_hwmgr *hwmgr,
+		struct pp_profile *request)
+{
+	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+	int tmp_result, result = 0;
+	uint32_t sclk_mask = 0, mclk_mask = 0;
+
+	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_AUTO)
+		return -EINVAL;
+
+	tmp_result = tonga_freeze_sclk_mclk_dpm(hwmgr);
+	PP_ASSERT_WITH_CODE(!tmp_result,
+			"Failed to freeze SCLK MCLK DPM!",
+			result = tmp_result);
+
+	tmp_result = tonga_populate_requested_graphic_levels(hwmgr, request);
+	PP_ASSERT_WITH_CODE(!tmp_result,
+			"Failed to populate requested graphic levels!",
+			result = tmp_result);
+
+	tmp_result = tonga_unfreeze_sclk_mclk_dpm(hwmgr);
+	PP_ASSERT_WITH_CODE(!tmp_result,
+			"Failed to unfreeze SCLK MCLK DPM!",
+			result = tmp_result);
+
+	tonga_find_min_clock_masks(hwmgr, &sclk_mask, &mclk_mask,
+			request->min_sclk, request->min_mclk);
+
+	if (sclk_mask) {
+		if (!data->sclk_dpm_key_disabled)
+			smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
+				PPSMC_MSG_SCLKDPM_SetEnabledMask,
+				data->dpm_level_enable_mask.
+				sclk_dpm_enable_mask &
+				sclk_mask);
+	}
+
+	if (mclk_mask) {
+		if (!data->mclk_dpm_key_disabled)
+			smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
+				PPSMC_MSG_MCLKDPM_SetEnabledMask,
+				data->dpm_level_enable_mask.
+				mclk_dpm_enable_mask &
+				mclk_mask);
+	}
+
+	return result;
 }
 
 static const struct pp_hwmgr_func tonga_hwmgr_funcs = {
@@ -6347,10 +6468,11 @@ static const struct pp_hwmgr_func tonga_hwmgr_funcs = {
 	.get_fan_control_mode = tonga_get_fan_control_mode,
 	.force_clock_level = tonga_force_clock_level,
 	.print_clock_levels = tonga_print_clock_levels,
-        .get_sclk_od = tonga_get_sclk_od,
-        .set_sclk_od = tonga_set_sclk_od,
-        .get_mclk_od = tonga_get_mclk_od,
-        .set_mclk_od = tonga_set_mclk_od,
+	.get_sclk_od = tonga_get_sclk_od,
+	.set_sclk_od = tonga_set_sclk_od,
+	.get_mclk_od = tonga_get_mclk_od,
+	.set_mclk_od = tonga_set_mclk_od,
+	.set_power_profile_state = tonga_set_power_profile_state,
 };
 
 int tonga_hwmgr_init(struct pp_hwmgr *hwmgr)
-- 
2.7.4

