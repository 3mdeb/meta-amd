From ae6986b5488f74bdaf02ff7f7f0791f3ccaf5733 Mon Sep 17 00:00:00 2001
From: Mykola Lysenko <mykola.lysenko@amd.com>
Date: Mon, 24 Aug 2015 19:02:58 +0800
Subject: [PATCH 389/401] gpu/drm/amdgpu: [DM] enable vblank properly in
 special cases

Cases:
1. unplug display -> headless -> plug display
2. s3 sequence

Signed-off-by: Mykola Lysenko <mykola.lysenko@amd.com>
Reviewed-by: Aric Cyr <aric.cyr@amd.com>
Reviewed-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c       | 72 ++++++++++++++++------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm_irq.c   |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c | 40 ++++++++++++----
 3 files changed, 75 insertions(+), 41 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
index 7a73ba9..6abafc6 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
@@ -353,7 +353,6 @@ static void amdgpu_dm_pflip_high_irq(void *interrupt_params)
 	queue_work(amdgpu_crtc->pflip_queue, &works->unpin_work);
 }
 
-
 static void amdgpu_dm_crtc_high_irq(void *interrupt_params)
 {
 	struct common_irq_params *irq_params = interrupt_params;
@@ -364,7 +363,6 @@ static void amdgpu_dm_crtc_high_irq(void *interrupt_params)
 		dal_get_display_index_from_int_src(adev->dm.dal, src);
 
 	drm_handle_vblank(adev->ddev, display_index);
-
 }
 
 static void hpd_low_irq_helper_func(
@@ -376,13 +374,33 @@ static void hpd_low_irq_helper_func(
 	*display_index = pm->display_path_index;
 }
 
+static inline struct amdgpu_connector *find_connector_by_display_index(
+	struct drm_device *dev,
+	uint32_t display_index)
+{
+	struct drm_connector *connector = NULL;
+	struct amdgpu_connector *aconnector = NULL;
+
+	list_for_each_entry(
+		connector,
+		&dev->mode_config.connector_list,
+		head) {
+		aconnector = to_amdgpu_connector(connector);
+
+		/*aconnector->connector_id means display_index*/
+		if (aconnector->connector_id == display_index)
+			break;
+	}
+
+	return aconnector;
+}
+
 static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 {
 	struct amdgpu_device *adev = interrupt_params;
 	struct dal *dal = adev->dm.dal;
 	struct drm_device *dev = adev->ddev;
-	uint32_t connected_displays = dal_get_connected_targets_vector(dal);
-	struct drm_connector *connector = NULL;
+	uint32_t connected_displays;
 	struct amdgpu_connector *aconnector = NULL;
 	bool trigger_drm_hpd_event = false;
 
@@ -394,6 +412,8 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 	 * calling into DAL and preempted by a call from user-mode. */
 	mutex_lock(&adev->dm.dal_mutex);
 
+	connected_displays = dal_get_connected_targets_vector(dal);
+
 	if (connected_displays == 0) {
 		uint32_t display_index = INVALID_DISPLAY_INDEX;
 
@@ -403,18 +423,15 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 			INVALID_DISPLAY_INDEX,
 			hpd_low_irq_helper_func);
 
+		mutex_unlock(&adev->dm.dal_mutex);
+
 		adev->dm.fake_display_index = display_index;
 
-		list_for_each_entry(
-			connector,
-			&dev->mode_config.connector_list,
-			head) {
-			aconnector = to_amdgpu_connector(connector);
+		aconnector =
+			find_connector_by_display_index(dev, display_index);
 
-			/*aconnector->connector_id means display_index*/
-			if (aconnector->connector_id == display_index)
-				break;
-		}
+		if (!aconnector)
+			return;
 
 		/*
 		 * force connected status on fake display connector
@@ -428,6 +445,8 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 		/* we assume only one display is connected */
 		uint32_t connected_display_index = 0;
 
+		mutex_unlock(&adev->dm.dal_mutex);
+
 		/* identify first connected display index */
 		while (connected_displays) {
 			if (1 & connected_displays)
@@ -437,30 +456,23 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 			connected_displays >>= 1;
 		}
 
+		aconnector =
+			find_connector_by_display_index(
+				dev,
+				adev->dm.fake_display_index);
+
+		if (!aconnector)
+			return;
+
 		/*
 		 * if there is display on another connector get connected
 		 * we need to clean-up connection status on fake display
 		 */
 		if (connected_display_index != adev->dm.fake_display_index) {
-			list_for_each_entry(
-				connector,
-				&dev->mode_config.connector_list,
-				head) {
-				aconnector = to_amdgpu_connector(connector);
-
-				/*aconnector->connector_id means display_index*/
-				if (aconnector->connector_id ==
-					adev->dm.fake_display_index)
-					break;
-			}
-
 			/* reset connected status on fake display connector */
 			aconnector->base.status = connector_status_disconnected;
 		} else {
-			dal_reset_path_mode(
-				dal,
-				1,
-				&adev->dm.fake_display_index);
+			amdgpu_dm_mode_reset(aconnector->base.encoder->crtc);
 		}
 
 		adev->dm.fake_display_index = INVALID_DISPLAY_INDEX;
@@ -468,8 +480,6 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 		trigger_drm_hpd_event = true;
 	}
 
-	mutex_unlock(&adev->dm.dal_mutex);
-
 	if (true == trigger_drm_hpd_event)
 		drm_kms_helper_hotplug_event(dev);
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_irq.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_irq.c
index 2e016e8..26cf079 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_irq.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_irq.c
@@ -462,7 +462,7 @@ int amdgpu_dm_irq_suspend(
 	DRM_DEBUG_KMS("DM_IRQ: suspend\n");
 
 	/* disable HW interrupt */
-	for (src = DAL_IRQ_SOURCE_HPD1; src < DAL_IRQ_SOURCES_NUMBER; src++) {
+	for (src = DAL_IRQ_SOURCE_HPD1; src <= DAL_IRQ_SOURCE_HPD6; src++) {
 		hnd_list_l = &adev->dm.irq_handler_list_low_tab[src].head;
 		hnd_list_h = &adev->dm.irq_handler_list_high_tab[src];
 		if (!list_empty(hnd_list_l) || !list_empty(hnd_list_h))
@@ -488,7 +488,7 @@ int amdgpu_dm_irq_resume(
 	DRM_DEBUG_KMS("DM_IRQ: resume\n");
 
 	/* re-enable HW interrupt */
-	for (src = DAL_IRQ_SOURCE_HPD1; src < DAL_IRQ_SOURCES_NUMBER; src++) {
+	for (src = DAL_IRQ_SOURCE_HPD1; src <= DAL_IRQ_SOURCE_HPD6; src++) {
 		hnd_list_l = &adev->dm.irq_handler_list_low_tab[src].head;
 		hnd_list_h = &adev->dm.irq_handler_list_high_tab[src];
 		if (!list_empty(hnd_list_l) || !list_empty(hnd_list_h))
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
index a54516e..0542daa 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
@@ -591,15 +591,24 @@ bool amdgpu_dm_mode_reset(struct drm_crtc *crtc)
 	/* Turn vblank off before reset */
 	drm_crtc_vblank_off(crtc);
 
-	/* Blank the display */
-	dal_set_blanking(adev->dm.dal, acrtc->crtc_id, true);
+	/* When we will get called from drm asking to reset mode
+	 * when fb is null, it will lead us reset mode unnecessarily.
+	 * So change the sequence, we won't do the actual reset mode call
+	 * when display is connected, as that's harmful for glitchless mode
+	 * change (when we only reprogram pipe front end). */
+	if ((dal_get_connected_targets_vector(adev->dm.dal)
+			& (1 << display_index)) &&
+		adev->dm.fake_display_index == INVALID_DISPLAY_INDEX) {
+
+		/*
+		 * Blank the display, as buffer will be invalidated.
+		 * For the else case it would be done as part of dal reset mode
+		 * sequence.
+		 */
+		mutex_lock(&adev->dm.dal_mutex);
+		dal_set_blanking(adev->dm.dal, acrtc->crtc_id, true);
+		mutex_unlock(&adev->dm.dal_mutex);
 
-	/* Somehow we will get called from drm ask us reset mode
-	 * when fb is null, it will lead us remove mode unnecessarily
-	 * so change the code,we won't do the actual reset mode call
-	 * when display is connected,as that's unnecessarily and harmful.*/
-	if (dal_get_connected_targets_vector(adev->dm.dal)
-			& (1 << display_index)) {
 		ret = true;
 		DRM_DEBUG_KMS(
 			"Skip reset mode for disp_index %d\n",
@@ -1398,8 +1407,23 @@ static const struct drm_connector_funcs amdgpu_dm_connector_funcs = {
 	.force = amdgpu_dm_connector_force
 };
 
+static void dm_crtc_helper_dpms(struct drm_crtc *crtc, int mode)
+{
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		drm_crtc_vblank_on(crtc);
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	case DRM_MODE_DPMS_OFF:
+		drm_crtc_vblank_off(crtc);
+		break;
+	}
+}
+
 static const struct drm_crtc_helper_funcs amdgpu_dm_crtc_helper_funcs = {
 	.disable = amdgpu_dm_crtc_disable,
+	.dpms = dm_crtc_helper_dpms,
 	.load_lut = NULL
 };
 
-- 
1.9.1

