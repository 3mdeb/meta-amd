From d95d302fb6b74202851a4e4930a2e5ef3c9388fa Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Mon, 24 Apr 2017 15:20:24 -0400
Subject: [PATCH 2921/3082] drm/amd/display: dce120 to dce ipp refactor

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
---
 drivers/gpu/drm/amd/display/dc/dce/Makefile        |   2 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_ipp.c       | 252 +++++++++++++++++++++
 drivers/gpu/drm/amd/display/dc/dce/dce_ipp.h       | 226 ++++++++++++++++++
 drivers/gpu/drm/amd/display/dc/dce/dce_transform.h |   2 +-
 drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp.h |   2 +-
 .../drm/amd/display/dc/dce110/dce110_ipp_gamma.c   |   4 +-
 drivers/gpu/drm/amd/display/dc/dce120/Makefile     |   1 -
 drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.c |  58 -----
 drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.h |  62 -----
 .../drm/amd/display/dc/dce120/dce120_ipp_cursor.c  | 193 ----------------
 .../drm/amd/display/dc/dce120/dce120_ipp_gamma.c   | 167 --------------
 .../drm/amd/display/dc/dce120/dce120_resource.c    |  69 +++---
 drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h  |   3 +
 drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h        |   5 +-
 14 files changed, 521 insertions(+), 525 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/display/dc/dce/dce_ipp.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dce/dce_ipp.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_cursor.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_gamma.c

diff --git a/drivers/gpu/drm/amd/display/dc/dce/Makefile b/drivers/gpu/drm/amd/display/dc/dce/Makefile
index 0556255..8abec0b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce/Makefile
@@ -7,7 +7,7 @@
 
 DCE = dce_audio.o dce_stream_encoder.o dce_link_encoder.o dce_hwseq.o \
 dce_mem_input.o dce_clock_source.o dce_scl_filters.o dce_transform.o \
-dce_clocks.o dce_opp.o dce_dmcu.o dce_abm.o
+dce_clocks.o dce_opp.o dce_dmcu.o dce_abm.o dce_ipp.o
 
 
 AMD_DAL_DCE = $(addprefix $(AMDDALPATH)/dc/dce/,$(DCE))
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.c b/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.c
new file mode 100644
index 0000000..d6bf606
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dce_ipp.h"
+#include "reg_helper.h"
+#include "dm_services.h"
+
+#define REG(reg) \
+	(ipp_dce->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	ipp_dce->ipp_shift->field_name, ipp_dce->ipp_mask->field_name
+
+#define CTX \
+	ipp_dce->base.ctx
+
+static void dce_ipp_cursor_set_position(
+	struct input_pixel_processor *ipp,
+	const struct dc_cursor_position *position,
+	const struct dc_cursor_mi_param *param)
+{
+	struct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);
+
+	/* lock cursor registers */
+	REG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, true);
+
+	/* Flag passed in structure differentiates cursor enable/disable. */
+	/* Update if it differs from cached state. */
+	REG_UPDATE(CUR_CONTROL, CURSOR_EN, position->enable);
+
+	REG_SET_2(CUR_POSITION, 0,
+		CURSOR_X_POSITION, position->x,
+		CURSOR_Y_POSITION, position->y);
+
+	REG_SET_2(CUR_HOT_SPOT, 0,
+		CURSOR_HOT_SPOT_X, position->x_hotspot,
+		CURSOR_HOT_SPOT_Y, position->y_hotspot);
+
+	/* unlock cursor registers */
+	REG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, false);
+}
+
+static void dce_ipp_cursor_set_attributes(
+	struct input_pixel_processor *ipp,
+	const struct dc_cursor_attributes *attributes)
+{
+	struct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);
+	int mode;
+
+	/* Lock cursor registers */
+	REG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, true);
+
+	/* Program cursor control */
+	switch (attributes->color_format) {
+	case CURSOR_MODE_MONO:
+		mode = 0;
+		break;
+	case CURSOR_MODE_COLOR_1BIT_AND:
+		mode = 1;
+		break;
+	case CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:
+		mode = 2;
+		break;
+	case CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:
+		mode = 3;
+		break;
+	default:
+		BREAK_TO_DEBUGGER(); /* unsupported */
+		mode = 0;
+	}
+
+	REG_UPDATE_3(CUR_CONTROL,
+		CURSOR_MODE, mode,
+		CURSOR_2X_MAGNIFY, attributes->attribute_flags.bits.ENABLE_MAGNIFICATION,
+		CUR_INV_TRANS_CLAMP, attributes->attribute_flags.bits.INVERSE_TRANSPARENT_CLAMPING);
+
+	if (attributes->color_format == CURSOR_MODE_MONO) {
+		REG_SET_3(CUR_COLOR1, 0,
+			CUR_COLOR1_BLUE, 0,
+			CUR_COLOR1_GREEN, 0,
+			CUR_COLOR1_RED, 0);
+
+		REG_SET_3(CUR_COLOR2, 0,
+			CUR_COLOR2_BLUE, 0xff,
+			CUR_COLOR2_GREEN, 0xff,
+			CUR_COLOR2_RED, 0xff);
+	}
+
+	/*
+	 * Program cursor size -- NOTE: HW spec specifies that HW register
+	 * stores size as (height - 1, width - 1)
+	 */
+	REG_SET_2(CUR_SIZE, 0,
+		CURSOR_WIDTH, attributes->width-1,
+		CURSOR_HEIGHT, attributes->height-1);
+
+	/* Program cursor surface address */
+	/* SURFACE_ADDRESS_HIGH: Higher order bits (39:32) of hardware cursor
+	 * surface base address in byte. It is 4K byte aligned.
+	 * The correct way to program cursor surface address is to first write
+	 * to CUR_SURFACE_ADDRESS_HIGH, and then write to CUR_SURFACE_ADDRESS
+	 */
+	REG_SET(CUR_SURFACE_ADDRESS_HIGH, 0,
+		CURSOR_SURFACE_ADDRESS_HIGH, attributes->address.high_part);
+
+	REG_SET(CUR_SURFACE_ADDRESS, 0,
+		CURSOR_SURFACE_ADDRESS, attributes->address.low_part);
+
+	/* Unlock Cursor registers. */
+	REG_UPDATE(CUR_UPDATE, CURSOR_UPDATE_LOCK, false);
+}
+
+static void dce_ipp_program_prescale(
+	struct input_pixel_processor *ipp,
+	struct ipp_prescale_params *params)
+{
+	struct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);
+
+	/* set to bypass mode first before change */
+	REG_UPDATE(PRESCALE_GRPH_CONTROL,
+		GRPH_PRESCALE_BYPASS,
+		1);
+
+	REG_SET_2(PRESCALE_VALUES_GRPH_R, 0,
+		GRPH_PRESCALE_SCALE_R, params->scale,
+		GRPH_PRESCALE_BIAS_R, params->bias);
+
+	REG_SET_2(PRESCALE_VALUES_GRPH_G, 0,
+		GRPH_PRESCALE_SCALE_G, params->scale,
+		GRPH_PRESCALE_BIAS_G, params->bias);
+
+	REG_SET_2(PRESCALE_VALUES_GRPH_B, 0,
+		GRPH_PRESCALE_SCALE_B, params->scale,
+		GRPH_PRESCALE_BIAS_B, params->bias);
+
+	if (params->mode != IPP_PRESCALE_MODE_BYPASS) {
+		REG_UPDATE(PRESCALE_GRPH_CONTROL,
+				GRPH_PRESCALE_BYPASS, 0);
+
+		/* If prescale is in use, then legacy lut should be bypassed */
+		REG_UPDATE(INPUT_GAMMA_CONTROL,
+				GRPH_INPUT_GAMMA_MODE, 1);
+	}
+}
+
+static void dce_ipp_program_input_lut(
+	struct input_pixel_processor *ipp,
+	const struct dc_gamma *gamma)
+{
+	int i;
+	struct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);
+
+	/* power on LUT memory */
+	REG_SET(DCFE_MEM_PWR_CTRL, 0, DCP_LUT_MEM_PWR_DIS, 1);
+
+	/* enable all */
+	REG_SET(DC_LUT_WRITE_EN_MASK, 0, DC_LUT_WRITE_EN_MASK, 0x7);
+
+	/* 256 entry mode */
+	REG_UPDATE(DC_LUT_RW_MODE, DC_LUT_RW_MODE, 0);
+
+	/* LUT-256, unsigned, integer, new u0.12 format */
+	REG_SET_3(DC_LUT_CONTROL, 0,
+		DC_LUT_DATA_R_FORMAT, 3,
+		DC_LUT_DATA_G_FORMAT, 3,
+		DC_LUT_DATA_B_FORMAT, 3);
+
+	/* start from index 0 */
+	REG_SET(DC_LUT_RW_INDEX, 0,
+		DC_LUT_RW_INDEX, 0);
+
+	for (i = 0; i < INPUT_LUT_ENTRIES; i++) {
+		REG_SET(DC_LUT_SEQ_COLOR, 0, DC_LUT_SEQ_COLOR, gamma->red[i]);
+		REG_SET(DC_LUT_SEQ_COLOR, 0, DC_LUT_SEQ_COLOR, gamma->green[i]);
+		REG_SET(DC_LUT_SEQ_COLOR, 0, DC_LUT_SEQ_COLOR, gamma->blue[i]);
+	}
+
+	/* power off LUT memory */
+	REG_SET(DCFE_MEM_PWR_CTRL, 0, DCP_LUT_MEM_PWR_DIS, 0);
+
+	/* bypass prescale, enable legacy LUT */
+	REG_UPDATE(PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_BYPASS, 1);
+	REG_UPDATE(INPUT_GAMMA_CONTROL, GRPH_INPUT_GAMMA_MODE, 0);
+}
+
+static void dce_ipp_set_degamma(
+	struct input_pixel_processor *ipp,
+	enum ipp_degamma_mode mode)
+{
+	struct dce_ipp *ipp_dce = TO_DCE_IPP(ipp);
+	uint32_t degamma_type = (mode == IPP_DEGAMMA_MODE_HW_sRGB) ? 1 : 0;
+
+	ASSERT(mode == IPP_DEGAMMA_MODE_BYPASS ||
+			mode == IPP_DEGAMMA_MODE_HW_sRGB);
+
+	REG_SET_3(DEGAMMA_CONTROL, 0,
+		GRPH_DEGAMMA_MODE, degamma_type,
+		CURSOR_DEGAMMA_MODE, degamma_type,
+		CURSOR2_DEGAMMA_MODE, degamma_type);
+}
+
+static const struct ipp_funcs dce_ipp_funcs = {
+	.ipp_cursor_set_attributes = dce_ipp_cursor_set_attributes,
+	.ipp_cursor_set_position = dce_ipp_cursor_set_position,
+	.ipp_program_prescale = dce_ipp_program_prescale,
+	.ipp_program_input_lut = dce_ipp_program_input_lut,
+	.ipp_set_degamma = dce_ipp_set_degamma
+};
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+void dce_ipp_construct(
+	struct dce_ipp *ipp_dce,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_ipp_registers *regs,
+	const struct dce_ipp_shift *ipp_shift,
+	const struct dce_ipp_mask *ipp_mask)
+{
+	ipp_dce->base.ctx = ctx;
+	ipp_dce->base.inst = inst;
+	ipp_dce->base.funcs = &dce_ipp_funcs;
+
+	ipp_dce->regs = regs;
+	ipp_dce->ipp_shift = ipp_shift;
+	ipp_dce->ipp_mask = ipp_mask;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.h b/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.h
new file mode 100644
index 0000000..23f25b1
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_ipp.h
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef _DCE_DCE_IPP_H_
+#define _DCE_DCE_IPP_H_
+
+#include "ipp.h"
+
+#define TO_DCE_IPP(ipp)\
+	container_of(ipp, struct dce_ipp, base)
+
+#define IPP_COMMON_REG_LIST_DCE_BASE(id) \
+	SRI(CUR_UPDATE, DCP, id), \
+	SRI(CUR_CONTROL, DCP, id), \
+	SRI(CUR_POSITION, DCP, id), \
+	SRI(CUR_HOT_SPOT, DCP, id), \
+	SRI(CUR_COLOR1, DCP, id), \
+	SRI(CUR_COLOR2, DCP, id), \
+	SRI(CUR_SIZE, DCP, id), \
+	SRI(CUR_SURFACE_ADDRESS_HIGH, DCP, id), \
+	SRI(CUR_SURFACE_ADDRESS, DCP, id), \
+	SRI(PRESCALE_GRPH_CONTROL, DCP, id), \
+	SRI(PRESCALE_VALUES_GRPH_R, DCP, id), \
+	SRI(PRESCALE_VALUES_GRPH_G, DCP, id), \
+	SRI(PRESCALE_VALUES_GRPH_B, DCP, id), \
+	SRI(INPUT_GAMMA_CONTROL, DCP, id), \
+	SRI(DCFE_MEM_PWR_CTRL, DCFE, id), \
+	SRI(DC_LUT_WRITE_EN_MASK, DCP, id), \
+	SRI(DC_LUT_RW_MODE, DCP, id), \
+	SRI(DC_LUT_CONTROL, DCP, id), \
+	SRI(DC_LUT_RW_INDEX, DCP, id), \
+	SRI(DC_LUT_SEQ_COLOR, DCP, id), \
+	SRI(DEGAMMA_CONTROL, DCP, id)
+
+#define IPP_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define IPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(mask_sh) \
+	IPP_SF(CUR_UPDATE, CURSOR_UPDATE_LOCK, mask_sh), \
+	IPP_SF(CUR_CONTROL, CURSOR_EN, mask_sh), \
+	IPP_SF(CUR_CONTROL, CURSOR_MODE, mask_sh), \
+	IPP_SF(CUR_CONTROL, CURSOR_2X_MAGNIFY, mask_sh), \
+	IPP_SF(CUR_CONTROL, CUR_INV_TRANS_CLAMP, mask_sh), \
+	IPP_SF(CUR_POSITION, CURSOR_X_POSITION, mask_sh), \
+	IPP_SF(CUR_POSITION, CURSOR_Y_POSITION, mask_sh), \
+	IPP_SF(CUR_HOT_SPOT, CURSOR_HOT_SPOT_X, mask_sh), \
+	IPP_SF(CUR_HOT_SPOT, CURSOR_HOT_SPOT_Y, mask_sh), \
+	IPP_SF(CUR_COLOR1, CUR_COLOR1_BLUE, mask_sh), \
+	IPP_SF(CUR_COLOR1, CUR_COLOR1_GREEN, mask_sh), \
+	IPP_SF(CUR_COLOR1, CUR_COLOR1_RED, mask_sh), \
+	IPP_SF(CUR_COLOR2, CUR_COLOR2_BLUE, mask_sh), \
+	IPP_SF(CUR_COLOR2, CUR_COLOR2_GREEN, mask_sh), \
+	IPP_SF(CUR_COLOR2, CUR_COLOR2_RED, mask_sh), \
+	IPP_SF(CUR_SIZE, CURSOR_WIDTH, mask_sh), \
+	IPP_SF(CUR_SIZE, CURSOR_HEIGHT, mask_sh), \
+	IPP_SF(CUR_SURFACE_ADDRESS_HIGH, CURSOR_SURFACE_ADDRESS_HIGH, mask_sh), \
+	IPP_SF(CUR_SURFACE_ADDRESS, CURSOR_SURFACE_ADDRESS, mask_sh), \
+	IPP_SF(PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_BYPASS, mask_sh), \
+	IPP_SF(PRESCALE_VALUES_GRPH_R, GRPH_PRESCALE_SCALE_R, mask_sh), \
+	IPP_SF(PRESCALE_VALUES_GRPH_R, GRPH_PRESCALE_BIAS_R, mask_sh), \
+	IPP_SF(PRESCALE_VALUES_GRPH_G, GRPH_PRESCALE_SCALE_G, mask_sh), \
+	IPP_SF(PRESCALE_VALUES_GRPH_G, GRPH_PRESCALE_BIAS_G, mask_sh), \
+	IPP_SF(PRESCALE_VALUES_GRPH_B, GRPH_PRESCALE_SCALE_B, mask_sh), \
+	IPP_SF(PRESCALE_VALUES_GRPH_B, GRPH_PRESCALE_BIAS_B, mask_sh), \
+	IPP_SF(INPUT_GAMMA_CONTROL, GRPH_INPUT_GAMMA_MODE, mask_sh), \
+	IPP_SF(DCFE_MEM_PWR_CTRL, DCP_LUT_MEM_PWR_DIS, mask_sh), \
+	IPP_SF(DC_LUT_WRITE_EN_MASK, DC_LUT_WRITE_EN_MASK, mask_sh), \
+	IPP_SF(DC_LUT_RW_MODE, DC_LUT_RW_MODE, mask_sh), \
+	IPP_SF(DC_LUT_CONTROL, DC_LUT_DATA_R_FORMAT, mask_sh), \
+	IPP_SF(DC_LUT_CONTROL, DC_LUT_DATA_G_FORMAT, mask_sh), \
+	IPP_SF(DC_LUT_CONTROL, DC_LUT_DATA_B_FORMAT, mask_sh), \
+	IPP_SF(DC_LUT_RW_INDEX, DC_LUT_RW_INDEX, mask_sh), \
+	IPP_SF(DC_LUT_SEQ_COLOR, DC_LUT_SEQ_COLOR, mask_sh), \
+	IPP_SF(DEGAMMA_CONTROL, GRPH_DEGAMMA_MODE, mask_sh), \
+	IPP_SF(DEGAMMA_CONTROL, CURSOR_DEGAMMA_MODE, mask_sh), \
+	IPP_SF(DEGAMMA_CONTROL, CURSOR2_DEGAMMA_MODE, mask_sh)
+
+#define IPP_COMMON_MASK_SH_LIST_SOC_BASE(mask_sh) \
+	IPP_SF(DCP0_CUR_UPDATE, CURSOR_UPDATE_LOCK, mask_sh), \
+	IPP_SF(DCP0_CUR_CONTROL, CURSOR_EN, mask_sh), \
+	IPP_SF(DCP0_CUR_CONTROL, CURSOR_MODE, mask_sh), \
+	IPP_SF(DCP0_CUR_CONTROL, CURSOR_2X_MAGNIFY, mask_sh), \
+	IPP_SF(DCP0_CUR_CONTROL, CUR_INV_TRANS_CLAMP, mask_sh), \
+	IPP_SF(DCP0_CUR_POSITION, CURSOR_X_POSITION, mask_sh), \
+	IPP_SF(DCP0_CUR_POSITION, CURSOR_Y_POSITION, mask_sh), \
+	IPP_SF(DCP0_CUR_HOT_SPOT, CURSOR_HOT_SPOT_X, mask_sh), \
+	IPP_SF(DCP0_CUR_HOT_SPOT, CURSOR_HOT_SPOT_Y, mask_sh), \
+	IPP_SF(DCP0_CUR_COLOR1, CUR_COLOR1_BLUE, mask_sh), \
+	IPP_SF(DCP0_CUR_COLOR1, CUR_COLOR1_GREEN, mask_sh), \
+	IPP_SF(DCP0_CUR_COLOR1, CUR_COLOR1_RED, mask_sh), \
+	IPP_SF(DCP0_CUR_COLOR2, CUR_COLOR2_BLUE, mask_sh), \
+	IPP_SF(DCP0_CUR_COLOR2, CUR_COLOR2_GREEN, mask_sh), \
+	IPP_SF(DCP0_CUR_COLOR2, CUR_COLOR2_RED, mask_sh), \
+	IPP_SF(DCP0_CUR_SIZE, CURSOR_WIDTH, mask_sh), \
+	IPP_SF(DCP0_CUR_SIZE, CURSOR_HEIGHT, mask_sh), \
+	IPP_SF(DCP0_CUR_SURFACE_ADDRESS_HIGH, CURSOR_SURFACE_ADDRESS_HIGH, mask_sh), \
+	IPP_SF(DCP0_CUR_SURFACE_ADDRESS, CURSOR_SURFACE_ADDRESS, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_BYPASS, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_VALUES_GRPH_R, GRPH_PRESCALE_SCALE_R, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_VALUES_GRPH_R, GRPH_PRESCALE_BIAS_R, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_VALUES_GRPH_G, GRPH_PRESCALE_SCALE_G, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_VALUES_GRPH_G, GRPH_PRESCALE_BIAS_G, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_VALUES_GRPH_B, GRPH_PRESCALE_SCALE_B, mask_sh), \
+	IPP_SF(DCP0_PRESCALE_VALUES_GRPH_B, GRPH_PRESCALE_BIAS_B, mask_sh), \
+	IPP_SF(DCP0_INPUT_GAMMA_CONTROL, GRPH_INPUT_GAMMA_MODE, mask_sh), \
+	IPP_SF(DCFE0_DCFE_MEM_PWR_CTRL, DCP_LUT_MEM_PWR_DIS, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_WRITE_EN_MASK, DC_LUT_WRITE_EN_MASK, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_RW_MODE, DC_LUT_RW_MODE, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_CONTROL, DC_LUT_DATA_R_FORMAT, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_CONTROL, DC_LUT_DATA_G_FORMAT, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_CONTROL, DC_LUT_DATA_B_FORMAT, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_RW_INDEX, DC_LUT_RW_INDEX, mask_sh), \
+	IPP_SF(DCP0_DC_LUT_SEQ_COLOR, DC_LUT_SEQ_COLOR, mask_sh), \
+	IPP_SF(DCP0_DEGAMMA_CONTROL, GRPH_DEGAMMA_MODE, mask_sh), \
+	IPP_SF(DCP0_DEGAMMA_CONTROL, CURSOR_DEGAMMA_MODE, mask_sh), \
+	IPP_SF(DCP0_DEGAMMA_CONTROL, CURSOR2_DEGAMMA_MODE, mask_sh)
+
+#define IPP_REG_FIELD_LIST(type) \
+	type CURSOR_UPDATE_LOCK; \
+	type CURSOR_EN; \
+	type CURSOR_X_POSITION; \
+	type CURSOR_Y_POSITION; \
+	type CURSOR_HOT_SPOT_X; \
+	type CURSOR_HOT_SPOT_Y; \
+	type CURSOR_MODE; \
+	type CURSOR_2X_MAGNIFY; \
+	type CUR_INV_TRANS_CLAMP; \
+	type CUR_COLOR1_BLUE; \
+	type CUR_COLOR1_GREEN; \
+	type CUR_COLOR1_RED; \
+	type CUR_COLOR2_BLUE; \
+	type CUR_COLOR2_GREEN; \
+	type CUR_COLOR2_RED; \
+	type CURSOR_WIDTH; \
+	type CURSOR_HEIGHT; \
+	type CURSOR_SURFACE_ADDRESS_HIGH; \
+	type CURSOR_SURFACE_ADDRESS; \
+	type GRPH_PRESCALE_BYPASS; \
+	type GRPH_PRESCALE_SCALE_R; \
+	type GRPH_PRESCALE_BIAS_R; \
+	type GRPH_PRESCALE_SCALE_G; \
+	type GRPH_PRESCALE_BIAS_G; \
+	type GRPH_PRESCALE_SCALE_B; \
+	type GRPH_PRESCALE_BIAS_B; \
+	type GRPH_INPUT_GAMMA_MODE; \
+	type DCP_LUT_MEM_PWR_DIS; \
+	type DC_LUT_WRITE_EN_MASK; \
+	type DC_LUT_RW_MODE; \
+	type DC_LUT_DATA_R_FORMAT; \
+	type DC_LUT_DATA_G_FORMAT; \
+	type DC_LUT_DATA_B_FORMAT; \
+	type DC_LUT_RW_INDEX; \
+	type DC_LUT_SEQ_COLOR; \
+	type GRPH_DEGAMMA_MODE; \
+	type CURSOR_DEGAMMA_MODE; \
+	type CURSOR2_DEGAMMA_MODE
+
+struct dce_ipp_shift {
+	IPP_REG_FIELD_LIST(uint8_t);
+};
+
+struct dce_ipp_mask {
+	IPP_REG_FIELD_LIST(uint32_t);
+};
+
+struct dce_ipp_registers {
+	uint32_t CUR_UPDATE;
+	uint32_t CUR_CONTROL;
+	uint32_t CUR_POSITION;
+	uint32_t CUR_HOT_SPOT;
+	uint32_t CUR_COLOR1;
+	uint32_t CUR_COLOR2;
+	uint32_t CUR_SIZE;
+	uint32_t CUR_SURFACE_ADDRESS_HIGH;
+	uint32_t CUR_SURFACE_ADDRESS;
+	uint32_t PRESCALE_GRPH_CONTROL;
+	uint32_t PRESCALE_VALUES_GRPH_R;
+	uint32_t PRESCALE_VALUES_GRPH_G;
+	uint32_t PRESCALE_VALUES_GRPH_B;
+	uint32_t INPUT_GAMMA_CONTROL;
+	uint32_t DCFE_MEM_PWR_CTRL;
+	uint32_t DC_LUT_WRITE_EN_MASK;
+	uint32_t DC_LUT_RW_MODE;
+	uint32_t DC_LUT_CONTROL;
+	uint32_t DC_LUT_RW_INDEX;
+	uint32_t DC_LUT_SEQ_COLOR;
+	uint32_t DEGAMMA_CONTROL;
+};
+
+struct dce_ipp {
+	struct input_pixel_processor base;
+	const struct dce_ipp_registers *regs;
+	const struct dce_ipp_shift *ipp_shift;
+	const struct dce_ipp_mask *ipp_mask;
+};
+
+void dce_ipp_construct(struct dce_ipp *ipp_dce,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_ipp_registers *regs,
+	const struct dce_ipp_shift *ipp_shift,
+	const struct dce_ipp_mask *ipp_mask);
+
+#endif /* _DCE_DCE_IPP_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h b/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h
index da2a024..ca6c621 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h
@@ -369,7 +369,7 @@ struct dce_transform {
 	bool prescaler_on;
 };
 
-bool dce_transform_construct(struct dce_transform *xfm110,
+bool dce_transform_construct(struct dce_transform *xfm_dce,
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dce_transform_registers *regs,
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp.h b/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp.h
index 434fe2f..8684e6a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp.h
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp.h
@@ -59,7 +59,7 @@ void dce110_ipp_cursor_set_attributes(
 	const struct dc_cursor_attributes *attributes);
 
 /* DEGAMMA RELATED */
-bool dce110_ipp_set_degamma(
+void dce110_ipp_set_degamma(
 	struct input_pixel_processor *ipp,
 	enum ipp_degamma_mode mode);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp_gamma.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp_gamma.c
index f05cc9e..0bcd8a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp_gamma.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_ipp_gamma.c
@@ -66,7 +66,7 @@
 
 
 
-bool dce110_ipp_set_degamma(
+void dce110_ipp_set_degamma(
 	struct input_pixel_processor *ipp,
 	enum ipp_degamma_mode mode)
 {
@@ -82,8 +82,6 @@ bool dce110_ipp_set_degamma(
 		GRPH_DEGAMMA_MODE, degamma_type,
 		CURSOR_DEGAMMA_MODE, degamma_type,
 		CURSOR2_DEGAMMA_MODE, degamma_type);
-
-	return true;
 }
 
 void dce110_ipp_program_prescale(
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/Makefile b/drivers/gpu/drm/amd/display/dc/dce120/Makefile
index 3c6b3fa..826c12e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dce120/Makefile
@@ -4,7 +4,6 @@
 
 
 DCE120 = dce120_resource.o dce120_timing_generator.o \
-dce120_ipp.o dce120_ipp_cursor.o dce120_ipp_gamma.o \
 dce120_mem_input.o dce120_hw_sequencer.o
 
 AMD_DAL_DCE120 = $(addprefix $(AMDDALPATH)/dc/dce120/,$(DCE120))
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.c
deleted file mode 100644
index f450569..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-#include "include/logger_interface.h"
-
-#include "vega10/DC/dce_12_0_offset.h"
-#include "vega10/DC/dce_12_0_sh_mask.h"
-#include "vega10/soc15ip.h"
-
-#include "dce120_ipp.h"
-
-static const struct ipp_funcs funcs = {
-		.ipp_cursor_set_attributes = dce120_ipp_cursor_set_attributes,
-		.ipp_cursor_set_position = dce120_ipp_cursor_set_position,
-		.ipp_program_prescale = dce120_ipp_program_prescale,
-		.ipp_program_input_lut = dce120_ipp_program_input_lut,
-		.ipp_set_degamma = dce120_ipp_set_degamma,
-};
-
-bool dce120_ipp_construct(
-	struct dce110_ipp *ipp,
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_ipp_reg_offsets *offset)
-{
-	if (!dce110_ipp_construct(ipp, ctx, inst, offset)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	ipp->base.funcs = &funcs;
-
-	return true;
-}
-
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.h b/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.h
deleted file mode 100644
index 7f645fd..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_IPP_DCE120_H__
-#define __DC_IPP_DCE120_H__
-
-#include "ipp.h"
-#include "../dce110/dce110_ipp.h"
-
-
-bool dce120_ipp_construct(
-	struct dce110_ipp *ipp,
-	struct dc_context *ctx,
-	enum controller_id id,
-	const struct dce110_ipp_reg_offsets *offset);
-
-/* CURSOR RELATED */
-void dce120_ipp_cursor_set_position(
-	struct input_pixel_processor *ipp,
-	const struct dc_cursor_position *position,
-	const struct dc_cursor_mi_param *param);
-
-void dce120_ipp_cursor_set_attributes(
-	struct input_pixel_processor *ipp,
-	const struct dc_cursor_attributes *attributes);
-
-/* DEGAMMA RELATED */
-bool dce120_ipp_set_degamma(
-	struct input_pixel_processor *ipp,
-	enum ipp_degamma_mode mode);
-
-void dce120_ipp_program_prescale(
-	struct input_pixel_processor *ipp,
-	struct ipp_prescale_params *params);
-
-void dce120_ipp_program_input_lut(
-	struct input_pixel_processor *ipp,
-	const struct dc_gamma *gamma);
-
-#endif /*__DC_IPP_DCE120_H__*/
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_cursor.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_cursor.c
deleted file mode 100644
index dc81d32..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_cursor.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-#include "include/logger_interface.h"
-
-#include "vega10/DC/dce_12_0_offset.h"
-#include "vega10/DC/dce_12_0_sh_mask.h"
-#include "vega10/soc15ip.h"
-
-#include "../dce110/dce110_ipp.h"
-
-
-#define DCP_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(ipp110->base.ctx, ipp110->offsets.dcp_offset, reg_name, n, __VA_ARGS__)
-
-#define DCP_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_set_soc15(ipp110->base.ctx, ipp110->offsets.dcp_offset, reg_name, n, __VA_ARGS__)
-
-#define DCP_REG_UPDATE(reg, field, val)	\
-		DCP_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define DCP_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		DCP_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DCP_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DCP_REG_UPDATE_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-#define DCP_REG_SET(reg, field, val)	\
-		DCP_REG_SET_N(reg, 1, FD(reg##__##field), val)
-
-#define DCP_REG_SET_2(reg, field1, val1, field2, val2)	\
-		DCP_REG_SET_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DCP_REG_SET_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DCP_REG_SET_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-/* TODO: DAL3 does not implement cursor memory control
- * MCIF_MEM_CONTROL, DMIF_CURSOR_MEM_CONTROL
- */
-static void lock(
-	struct dce110_ipp *ipp110, bool lock)
-{
-	DCP_REG_UPDATE(DCP0_CUR_UPDATE, CURSOR_UPDATE_LOCK, lock);
-}
-
-static bool program_control(
-	struct dce110_ipp *ipp110,
-	enum dc_cursor_color_format color_format,
-	bool enable_magnification,
-	bool inverse_transparent_clamping)
-{
-	uint32_t mode = 0;
-
-	switch (color_format) {
-	case CURSOR_MODE_MONO:
-		mode = 0;
-		break;
-	case CURSOR_MODE_COLOR_1BIT_AND:
-		mode = 1;
-		break;
-	case CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:
-		mode = 2;
-		break;
-	case CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:
-		mode = 3;
-		break;
-	default:
-		return false;
-	}
-
-	DCP_REG_UPDATE_3(
-		DCP0_CUR_CONTROL,
-		CURSOR_MODE, mode,
-		CURSOR_2X_MAGNIFY, enable_magnification,
-		CUR_INV_TRANS_CLAMP, inverse_transparent_clamping);
-
-	if (color_format == CURSOR_MODE_MONO) {
-		DCP_REG_SET_3(
-			DCP0_CUR_COLOR1,
-			CUR_COLOR1_BLUE, 0,
-			CUR_COLOR1_GREEN, 0,
-			CUR_COLOR1_RED, 0);
-
-		DCP_REG_SET_3(
-			DCP0_CUR_COLOR2,
-			CUR_COLOR2_BLUE, 0xff,
-			CUR_COLOR2_GREEN, 0xff,
-			CUR_COLOR2_RED, 0xff);
-	}
-	return true;
-}
-
-static void program_address(
-	struct dce110_ipp *ipp110,
-	PHYSICAL_ADDRESS_LOC address)
-{
-	/* SURFACE_ADDRESS_HIGH: Higher order bits (39:32) of hardware cursor
-	 * surface base address in byte. It is 4K byte aligned.
-	 * The correct way to program cursor surface address is to first write
-	 * to CUR_SURFACE_ADDRESS_HIGH, and then write to CUR_SURFACE_ADDRESS
-	 */
-
-	DCP_REG_SET(
-		DCP0_CUR_SURFACE_ADDRESS_HIGH,
-		CURSOR_SURFACE_ADDRESS_HIGH, address.high_part);
-
-	DCP_REG_SET(
-		DCP0_CUR_SURFACE_ADDRESS,
-		CURSOR_SURFACE_ADDRESS, address.low_part);
-}
-
-void dce120_ipp_cursor_set_position(
-	struct input_pixel_processor *ipp,
-	const struct dc_cursor_position *position,
-	const struct dc_cursor_mi_param *param)
-{
-	struct dce110_ipp *ipp110 = TO_DCE110_IPP(ipp);
-
-	/* lock cursor registers */
-	lock(ipp110, true);
-
-	/* Flag passed in structure differentiates cursor enable/disable. */
-	/* Update if it differs from cached state. */
-	DCP_REG_UPDATE(DCP0_CUR_CONTROL, CURSOR_EN, position->enable);
-
-	DCP_REG_SET_2(
-		DCP0_CUR_POSITION,
-		CURSOR_X_POSITION, position->x,
-		CURSOR_Y_POSITION, position->y);
-
-	DCP_REG_SET_2(
-		DCP0_CUR_HOT_SPOT,
-		CURSOR_HOT_SPOT_X, position->x_hotspot,
-		CURSOR_HOT_SPOT_Y, position->y_hotspot);
-
-	/* unlock cursor registers */
-	lock(ipp110, false);
-}
-
-void dce120_ipp_cursor_set_attributes(
-	struct input_pixel_processor *ipp,
-	const struct dc_cursor_attributes *attributes)
-{
-	struct dce110_ipp *ipp110 = TO_DCE110_IPP(ipp);
-	/* Lock cursor registers */
-	lock(ipp110, true);
-
-	/* Program cursor control */
-	program_control(
-		ipp110,
-		attributes->color_format,
-		attributes->attribute_flags.bits.ENABLE_MAGNIFICATION,
-		attributes->attribute_flags.bits.INVERSE_TRANSPARENT_CLAMPING);
-
-	/*
-	 * Program cursor size -- NOTE: HW spec specifies that HW register
-	 * stores size as (height - 1, width - 1)
-	 */
-	DCP_REG_SET_2(
-		DCP0_CUR_SIZE,
-		CURSOR_WIDTH, attributes->width-1,
-		CURSOR_HEIGHT, attributes->height-1);
-
-	/* Program cursor surface address */
-	program_address(ipp110, attributes->address);
-
-	/* Unlock Cursor registers. */
-	lock(ipp110, false);
-}
-
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_gamma.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_gamma.c
deleted file mode 100644
index 7aa5a49..0000000
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_ipp_gamma.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-#include "include/logger_interface.h"
-#include "include/fixed31_32.h"
-#include "basics/conversion.h"
-
-#include "vega10/DC/dce_12_0_offset.h"
-#include "vega10/DC/dce_12_0_sh_mask.h"
-#include "vega10/soc15ip.h"
-
-#include "../dce110/dce110_ipp.h"
-
-#define DCP_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(ipp110->base.ctx, ipp110->offsets.dcp_offset, reg_name, n, __VA_ARGS__)
-
-#define DCP_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_set_soc15(ipp110->base.ctx, ipp110->offsets.dcp_offset, reg_name, n, __VA_ARGS__)
-
-#define DCP_REG_UPDATE(reg, field, val)	\
-		DCP_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define DCP_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		DCP_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DCP_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DCP_REG_UPDATE_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-#define DCP_REG_SET(reg, field, val)	\
-		DCP_REG_SET_N(reg, 1, FD(reg##__##field), val)
-
-#define DCP_REG_SET_2(reg, field1, val1, field2, val2)	\
-		DCP_REG_SET_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define DCP_REG_SET_3(reg, field1, val1, field2, val2, field3, val3)	\
-		DCP_REG_SET_N(reg, 3, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-
-bool dce120_ipp_set_degamma(
-	struct input_pixel_processor *ipp,
-	enum ipp_degamma_mode mode)
-{
-	struct dce110_ipp *ipp110 = TO_DCE110_IPP(ipp);
-	uint32_t degamma_type = (mode == IPP_DEGAMMA_MODE_HW_sRGB) ? 1 : 0;
-
-	ASSERT(mode == IPP_DEGAMMA_MODE_BYPASS ||
-			mode == IPP_DEGAMMA_MODE_HW_sRGB);
-
-	DCP_REG_SET_3(
-		DCP0_DEGAMMA_CONTROL,
-		GRPH_DEGAMMA_MODE, degamma_type,
-		CURSOR_DEGAMMA_MODE, degamma_type,
-		CURSOR2_DEGAMMA_MODE, degamma_type);
-
-	return true;
-}
-
-void dce120_ipp_program_prescale(
-	struct input_pixel_processor *ipp,
-	struct ipp_prescale_params *params)
-{
-	struct dce110_ipp *ipp110 = TO_DCE110_IPP(ipp);
-
-	/* set to bypass mode first before change */
-	DCP_REG_UPDATE(
-		DCP0_PRESCALE_GRPH_CONTROL,
-		GRPH_PRESCALE_BYPASS,
-		1);
-
-	DCP_REG_SET_2(
-		DCP0_PRESCALE_VALUES_GRPH_R,
-		GRPH_PRESCALE_SCALE_R, params->scale,
-		GRPH_PRESCALE_BIAS_R, params->bias);
-
-	DCP_REG_SET_2(
-		DCP0_PRESCALE_VALUES_GRPH_G,
-		GRPH_PRESCALE_SCALE_G, params->scale,
-		GRPH_PRESCALE_BIAS_G, params->bias);
-
-	DCP_REG_SET_2(
-		DCP0_PRESCALE_VALUES_GRPH_B,
-		GRPH_PRESCALE_SCALE_B, params->scale,
-		GRPH_PRESCALE_BIAS_B, params->bias);
-
-	if (params->mode != IPP_PRESCALE_MODE_BYPASS) {
-		DCP_REG_UPDATE(DCP0_PRESCALE_GRPH_CONTROL,
-			       GRPH_PRESCALE_BYPASS, 0);
-
-		/* If prescale is in use, then legacy lut should be bypassed */
-		DCP_REG_UPDATE(DCP0_INPUT_GAMMA_CONTROL,
-			       GRPH_INPUT_GAMMA_MODE, 1);
-	}
-}
-
-static void dce120_helper_select_lut(struct dce110_ipp *ipp110)
-{
-	/* enable all */
-	DCP_REG_SET(
-		DCP0_DC_LUT_WRITE_EN_MASK,
-		DC_LUT_WRITE_EN_MASK,
-		0x7);
-
-	/* 256 entry mode */
-	DCP_REG_UPDATE(DCP0_DC_LUT_RW_MODE, DC_LUT_RW_MODE, 0);
-
-	/* LUT-256, unsigned, integer, new u0.12 format */
-	DCP_REG_SET_3(
-		DCP0_DC_LUT_CONTROL,
-		DC_LUT_DATA_R_FORMAT, 3,
-		DC_LUT_DATA_G_FORMAT, 3,
-		DC_LUT_DATA_B_FORMAT, 3);
-
-	/* start from index 0 */
-	DCP_REG_SET(
-		DCP0_DC_LUT_RW_INDEX,
-		DC_LUT_RW_INDEX,
-		0);
-}
-
-void dce120_ipp_program_input_lut(
-	struct input_pixel_processor *ipp,
-	const struct dc_gamma *gamma)
-{
-	int i;
-	struct dce110_ipp *ipp110 = TO_DCE110_IPP(ipp);
-
-	/* power on LUT memory */
-	DCP_REG_SET(DCFE0_DCFE_MEM_PWR_CTRL, DCP_LUT_MEM_PWR_DIS, 1);
-
-	dce120_helper_select_lut(ipp110);
-
-	for (i = 0; i < INPUT_LUT_ENTRIES; i++) {
-		DCP_REG_SET(DCP0_DC_LUT_SEQ_COLOR, DC_LUT_SEQ_COLOR, gamma->red[i]);
-		DCP_REG_SET(DCP0_DC_LUT_SEQ_COLOR, DC_LUT_SEQ_COLOR, gamma->green[i]);
-		DCP_REG_SET(DCP0_DC_LUT_SEQ_COLOR, DC_LUT_SEQ_COLOR, gamma->blue[i]);
-	}
-
-	/* power off LUT memory */
-	DCP_REG_SET(DCFE0_DCFE_MEM_PWR_CTRL, DCP_LUT_MEM_PWR_DIS, 0);
-
-	/* bypass prescale, enable legacy LUT */
-	DCP_REG_UPDATE(DCP0_PRESCALE_GRPH_CONTROL, GRPH_PRESCALE_BYPASS, 1);
-	DCP_REG_UPDATE(DCP0_INPUT_GAMMA_CONTROL, GRPH_INPUT_GAMMA_MODE, 0);
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
index f677a77..207d07b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
@@ -40,7 +40,7 @@
 #include "dce/dce_opp.h"
 #include "dce/dce_clock_source.h"
 #include "dce/dce_clocks.h"
-#include "dce120_ipp.h"
+#include "dce/dce_ipp.h"
 #include "dce110/dce110_mem_input.h"
 #include "dce120/dce120_mem_input.h"
 
@@ -174,6 +174,28 @@ static const struct dce_abm_mask abm_mask = {
 		ABM_MASK_SH_LIST_DCE110(_MASK)
 };
 
+#define ipp_regs(id)\
+[id] = {\
+		IPP_COMMON_REG_LIST_DCE_BASE(id)\
+}
+
+static const struct dce_ipp_registers ipp_regs[] = {
+		ipp_regs(0),
+		ipp_regs(1),
+		ipp_regs(2),
+		ipp_regs(3),
+		ipp_regs(4),
+		ipp_regs(5)
+};
+
+static const struct dce_ipp_shift ipp_shift = {
+		IPP_COMMON_MASK_SH_LIST_SOC_BASE(__SHIFT)
+};
+
+static const struct dce_ipp_mask ipp_mask = {
+		IPP_COMMON_MASK_SH_LIST_SOC_BASE(_MASK)
+};
+
 #define transform_regs(id)\
 [id] = {\
 		XFM_COMMON_REG_LIST_DCE110(id)\
@@ -354,27 +376,6 @@ struct output_pixel_processor *dce120_opp_create(
 	return NULL;
 }
 
-static const struct dce110_ipp_reg_offsets dce120_ipp_reg_offsets[] = {
-	{
-		.dcp_offset = (mmDCP0_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-	},
-	{
-		.dcp_offset = (mmDCP1_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-	},
-	{
-		.dcp_offset = (mmDCP2_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-	},
-	{
-		.dcp_offset = (mmDCP3_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-	},
-	{
-		.dcp_offset = (mmDCP4_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-	},
-	{
-		.dcp_offset = (mmDCP5_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-	}
-};
-
 static const struct dce110_mem_input_reg_offsets dce120_mi_reg_offsets[] = {
 	{
 		.dcp = (mmDCP0_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
@@ -498,7 +499,7 @@ static struct timing_generator *dce120_timing_generator_create(
 
 static void dce120_ipp_destroy(struct input_pixel_processor **ipp)
 {
-	dm_free(TO_DCE110_IPP(*ipp));
+	dm_free(TO_DCE_IPP(*ipp));
 	*ipp = NULL;
 }
 
@@ -622,21 +623,18 @@ struct link_encoder *dce120_link_encoder_create(
 }
 
 static struct input_pixel_processor *dce120_ipp_create(
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_ipp_reg_offsets *offset)
+	struct dc_context *ctx, uint32_t inst)
 {
-	struct dce110_ipp *ipp = dm_alloc(sizeof(struct dce110_ipp));
+	struct dce_ipp *ipp = dm_alloc(sizeof(struct dce_ipp));
 
-	if (!ipp)
+	if (!ipp) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
+	}
 
-	if (dce120_ipp_construct(ipp, ctx, inst, offset))
-		return &ipp->base;
-
-	BREAK_TO_DEBUGGER();
-	dm_free(ipp);
-	return NULL;
+	dce_ipp_construct(ipp, ctx, inst,
+			&ipp_regs[inst], &ipp_shift, &ipp_mask);
+	return &ipp->base;
 }
 
 static struct stream_encoder *dce120_stream_encoder_create(
@@ -1025,8 +1023,7 @@ static bool construct(
 			goto controller_create_fail;
 		}
 
-		pool->base.ipps[i] = dce120_ipp_create(ctx, i,
-				&dce120_ipp_reg_offsets[i]);
+		pool->base.ipps[i] = dce120_ipp_create(ctx, i);
 		if (pool->base.ipps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h b/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
index dfe5901..907e0a9 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
@@ -26,6 +26,9 @@
 #ifndef __DAL_HW_SHARED_H__
 #define __DAL_HW_SHARED_H__
 
+#include "os_types.h"
+#include "fixed31_32.h"
+
 /******************************************************************************
  * Data types shared between different Virtual HW blocks
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
index 7928e23..2f3dc2e 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Advanced Micro Devices, Inc.
+ * Copyright 2017 Advanced Micro Devices, Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -27,6 +27,7 @@
 #define __DAL_IPP_H__
 
 #include "hw_shared.h"
+#include "dc_hw_types.h"
 
 #define MAXTRIX_COEFFICIENTS_NUMBER 12
 #define MAXTRIX_COEFFICIENTS_WRAP_NUMBER (MAXTRIX_COEFFICIENTS_NUMBER + 4)
@@ -113,7 +114,7 @@ struct ipp_funcs {
 			const struct dc_gamma *gamma);
 
 	/*** DEGAMMA RELATED ***/
-	bool (*ipp_set_degamma)(
+	void (*ipp_set_degamma)(
 		struct input_pixel_processor *ipp,
 		enum ipp_degamma_mode mode);
 
-- 
2.7.4

