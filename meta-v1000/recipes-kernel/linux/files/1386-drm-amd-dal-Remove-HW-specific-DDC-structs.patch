From 765a40f5a5cac89495c70ef04202582857055be0 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 13 Oct 2016 18:36:46 -0400
Subject: [PATCH 1386/1722] drm/amd/dal: Remove HW specific DDC structs

Change-Id: I1220db7a6adfd218b01401d55b2a3421f8190521
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c |  24 +-
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h |   8 -
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c   | 478 ++++++++++-----------
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h   |   8 -
 4 files changed, 238 insertions(+), 280 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
index c3aba92..ae3748f 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
@@ -36,15 +36,15 @@
 
 
 static void destruct(
-	struct hw_ddc_dce110 *pin)
+	struct hw_ddc *pin)
 {
-	dal_hw_ddc_destruct(&pin->base);
+	dal_hw_ddc_destruct(pin);
 }
 
 static void destroy(
 	struct hw_gpio_pin **ptr)
 {
-	struct hw_ddc_dce110 *pin = DDC_DCE110_FROM_BASE(*ptr);
+	struct hw_ddc *pin = HW_DDC_FROM_BASE(*ptr);
 
 	destruct(pin);
 
@@ -454,7 +454,7 @@ static enum gpio_result set_config(
 	struct hw_gpio_pin *ptr,
 	const struct gpio_config_data *config_data)
 {
-	struct hw_ddc_dce110 *pin = DDC_DCE110_FROM_BASE(ptr);
+	struct hw_ddc *pin = HW_DDC_FROM_BASE(ptr);
 	struct hw_gpio *hw_gpio = NULL;
 	uint32_t addr;
 	uint32_t regval;
@@ -462,7 +462,7 @@ static enum gpio_result set_config(
 	uint32_t ddc_clk_pd_en = 0;
 	uint32_t aux_pad_mode = 0;
 
-	hw_gpio = &pin->base.base;
+	hw_gpio = &pin->base;
 
 	if (hw_gpio == NULL) {
 		ASSERT_CRITICAL(false);
@@ -640,7 +640,7 @@ static const struct hw_gpio_pin_funcs funcs = {
 };
 
 static bool construct(
-	struct hw_ddc_dce110 *pin,
+	struct hw_ddc *pin,
 	enum gpio_id id,
 	uint32_t en,
 	struct dc_context *ctx)
@@ -652,25 +652,25 @@ static bool construct(
 		return false;
 	}
 
-	if (!dal_hw_ddc_construct(&pin->base, id, en, ctx)) {
+	if (!dal_hw_ddc_construct(pin, id, en, ctx)) {
 		ASSERT_CRITICAL(false);
 		return false;
 	}
 
-	pin->base.base.base.funcs = &funcs;
+	pin->base.base.funcs = &funcs;
 
 	switch (id) {
 	case GPIO_ID_DDC_DATA:
 		init = hw_ddc_dce110_init_data + en;
 
-		pin->base.base.pin_reg = init->hw_gpio_data_reg;
+		pin->base.pin_reg = init->hw_gpio_data_reg;
 		pin->i2c_ddc_setup = init->i2c_ddc_setup;
 
 		return true;
 	case GPIO_ID_DDC_CLOCK:
 		init = hw_ddc_dce110_init_clock + en;
 
-		pin->base.base.pin_reg = init->hw_gpio_data_reg;
+		pin->base.pin_reg = init->hw_gpio_data_reg;
 		pin->i2c_ddc_setup = init->i2c_ddc_setup;
 
 		return true;
@@ -686,7 +686,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc_dce110 *pin = dm_alloc(sizeof(struct hw_ddc_dce110));
+	struct hw_ddc *pin = dm_alloc(sizeof(struct hw_ddc));
 
 	if (!pin) {
 		ASSERT_CRITICAL(false);
@@ -694,7 +694,7 @@ struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 	}
 
 	if (construct(pin, id, en, ctx))
-		return &pin->base.base.base;
+		return &pin->base.base;
 
 	ASSERT_CRITICAL(false);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h
index 4d954a0..8472692 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h
@@ -26,14 +26,6 @@
 #ifndef __DAL_HW_DDC_DCE110_H__
 #define __DAL_HW_DDC_DCE110_H__
 
-struct hw_ddc_dce110 {
-	struct hw_ddc base;
-	uint32_t i2c_ddc_setup;
-};
-
-#define DDC_DCE110_FROM_BASE(ddc_base) \
-	container_of((HW_DDC_FROM_BASE(ddc_base)), struct hw_ddc_dce110, base)
-
 struct hw_gpio_pin *dal_hw_ddc_dce110_create(
 	struct dc_context *ctx,
 	enum gpio_id id,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
index b27d23d..2f12511 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
@@ -25,49 +25,25 @@
 
 #include "dm_services.h"
 
-/*
- * Pre-requisites: headers required by header of this unit
- */
 #include "include/gpio_types.h"
 #include "../hw_gpio.h"
 #include "../hw_ddc.h"
 
-/*
- * Header of this unit
- */
-
 #include "hw_ddc_dce80.h"
 
-/*
- * Post-requisites: headers required by this unit
- */
-
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
-/*
- * This unit
- */
-
-#define FROM_HW_DDC(ptr) \
-	container_of((ptr), struct hw_ddc_dce80, base)
-
-#define FROM_HW_GPIO(ptr) \
-	FROM_HW_DDC(container_of((ptr), struct hw_ddc, base))
-
-#define FROM_HW_GPIO_PIN(ptr) \
-	FROM_HW_GPIO(container_of((ptr), struct hw_gpio, base))
-
 static void destruct(
-	struct hw_ddc_dce80 *pin)
+	struct hw_ddc *pin)
 {
-	dal_hw_ddc_destruct(&pin->base);
+	dal_hw_ddc_destruct(pin);
 }
 
 static void destroy(
 	struct hw_gpio_pin **ptr)
 {
-	struct hw_ddc_dce80 *pin = FROM_HW_GPIO_PIN(*ptr);
+	struct hw_ddc *pin = HW_DDC_FROM_BASE(*ptr);
 
 	destruct(pin);
 
@@ -76,217 +52,6 @@ static void destroy(
 	*ptr = NULL;
 }
 
-static void setup_i2c_polling(
-	struct dc_context *ctx,
-	const uint32_t addr,
-	bool enable_detect,
-	bool detect_mode)
-{
-	uint32_t value;
-
-	value = dm_read_reg(ctx, addr);
-
-	set_reg_field_value(
-		value,
-		enable_detect,
-		DC_I2C_DDC1_SETUP,
-		DC_I2C_DDC1_ENABLE);
-
-	set_reg_field_value(
-		value,
-		enable_detect,
-		DC_I2C_DDC1_SETUP,
-		DC_I2C_DDC1_EDID_DETECT_ENABLE);
-
-	if (enable_detect)
-		set_reg_field_value(
-			value,
-			detect_mode,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_EDID_DETECT_MODE);
-
-	dm_write_reg(ctx, addr, value);
-}
-
-static enum gpio_result set_config(
-	struct hw_gpio_pin *ptr,
-	const struct gpio_config_data *config_data)
-{
-	struct hw_ddc_dce80 *pin = FROM_HW_GPIO_PIN(ptr);
-	struct hw_gpio *hw_gpio = NULL;
-	uint32_t addr;
-	uint32_t regval;
-	uint32_t ddc_data_pd_en = 0;
-	uint32_t ddc_clk_pd_en = 0;
-	uint32_t aux_pad_mode = 0;
-
-	hw_gpio = &pin->base.base;
-
-	if (hw_gpio == NULL) {
-		ASSERT_CRITICAL(false);
-		return GPIO_RESULT_NULL_HANDLE;
-	}
-
-	/* switch dual mode GPIO to I2C/AUX mode */
-
-	addr = hw_gpio->pin_reg.DC_GPIO_DATA_MASK.addr;
-
-	regval = dm_read_reg(ptr->ctx, addr);
-
-	ddc_data_pd_en = get_reg_field_value(
-			regval,
-			DC_GPIO_DDC1_MASK,
-			DC_GPIO_DDC1DATA_PD_EN);
-
-	ddc_clk_pd_en = get_reg_field_value(
-			regval,
-			DC_GPIO_DDC1_MASK,
-			DC_GPIO_DDC1CLK_PD_EN);
-
-	aux_pad_mode = get_reg_field_value(
-			regval,
-			DC_GPIO_DDC1_MASK,
-			AUX_PAD1_MODE);
-
-	switch (config_data->config.ddc.type) {
-	case GPIO_DDC_CONFIG_TYPE_MODE_I2C:
-		/* On plug-in, there is a transient level on the pad
-		 * which must be discharged through the internal pull-down.
-		 * Enable internal pull-down, 2.5msec discharge time
-		 * is required for detection of AUX mode */
-		if (hw_gpio->base.en != GPIO_DDC_LINE_VIP_PAD) {
-			if (!ddc_data_pd_en || !ddc_clk_pd_en) {
-				set_reg_field_value(
-					regval,
-					1,
-					DC_GPIO_DDC1_MASK,
-					DC_GPIO_DDC1DATA_PD_EN);
-
-				set_reg_field_value(
-					regval,
-					1,
-					DC_GPIO_DDC1_MASK,
-					DC_GPIO_DDC1CLK_PD_EN);
-
-				dm_write_reg(ptr->ctx, addr, regval);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-		} else {
-			uint32_t reg2 = regval;
-			uint32_t sda_pd_dis = 0;
-			uint32_t scl_pd_dis = 0;
-
-			sda_pd_dis = get_reg_field_value(
-					reg2,
-					DC_GPIO_I2CPAD_MASK,
-					DC_GPIO_SDA_PD_DIS);
-
-			scl_pd_dis = get_reg_field_value(
-					reg2,
-					DC_GPIO_I2CPAD_MASK,
-					DC_GPIO_SCL_PD_DIS);
-
-			if (sda_pd_dis) {
-				sda_pd_dis = 0;
-
-				dm_write_reg(ptr->ctx, addr, reg2);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-
-			if (!scl_pd_dis) {
-				scl_pd_dis = 1;
-
-				dm_write_reg(ptr->ctx, addr, reg2);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-		}
-
-		if (aux_pad_mode) {
-			/* let pins to get de-asserted
-			 * before setting pad to I2C mode */
-			if (config_data->config.ddc.data_en_bit_present ||
-				config_data->config.ddc.clock_en_bit_present)
-				/* [anaumov] in DAL2, there was
-				 * dc_service_delay_in_microseconds(2000); */
-				msleep(2);
-
-			/* set the I2C pad mode */
-			/* read the register again,
-			 * some bits may have been changed */
-			regval = dm_read_reg(ptr->ctx, addr);
-
-			set_reg_field_value(
-				regval,
-				0,
-				DC_GPIO_DDC1_MASK,
-				AUX_PAD1_MODE);
-
-			dm_write_reg(ptr->ctx, addr, regval);
-		}
-
-		return GPIO_RESULT_OK;
-	case GPIO_DDC_CONFIG_TYPE_MODE_AUX:
-		/* set the AUX pad mode */
-		if (!aux_pad_mode) {
-			set_reg_field_value(
-				regval,
-				1,
-				DC_GPIO_DDC1_MASK,
-				AUX_PAD1_MODE);
-
-			dm_write_reg(ptr->ctx, addr, regval);
-		}
-
-		return GPIO_RESULT_OK;
-	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_CONNECT:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			setup_i2c_polling(
-				ptr->ctx, pin->i2c_ddc_setup, 1, 0);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_DISCONNECT:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			setup_i2c_polling(
-				ptr->ctx, pin->i2c_ddc_setup, 1, 1);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	case GPIO_DDC_CONFIG_TYPE_DISABLE_POLLING:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			setup_i2c_polling(
-				ptr->ctx, pin->i2c_ddc_setup, 0, 0);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	}
-
-	BREAK_TO_DEBUGGER();
-
-	return GPIO_RESULT_NON_SPECIFIC_ERROR;
-}
-
 struct hw_ddc_dce80_init {
 	struct hw_gpio_pin_reg hw_gpio_data_reg;
 	uint32_t i2c_ddc_setup;
@@ -652,6 +417,217 @@ static const struct hw_ddc_dce80_init
 	}
 };
 
+static void setup_i2c_polling(
+	struct dc_context *ctx,
+	const uint32_t addr,
+	bool enable_detect,
+	bool detect_mode)
+{
+	uint32_t value;
+
+	value = dm_read_reg(ctx, addr);
+
+	set_reg_field_value(
+		value,
+		enable_detect,
+		DC_I2C_DDC1_SETUP,
+		DC_I2C_DDC1_ENABLE);
+
+	set_reg_field_value(
+		value,
+		enable_detect,
+		DC_I2C_DDC1_SETUP,
+		DC_I2C_DDC1_EDID_DETECT_ENABLE);
+
+	if (enable_detect)
+		set_reg_field_value(
+			value,
+			detect_mode,
+			DC_I2C_DDC1_SETUP,
+			DC_I2C_DDC1_EDID_DETECT_MODE);
+
+	dm_write_reg(ctx, addr, value);
+}
+
+static enum gpio_result set_config(
+	struct hw_gpio_pin *ptr,
+	const struct gpio_config_data *config_data)
+{
+	struct hw_ddc *pin = HW_DDC_FROM_BASE(ptr);
+	struct hw_gpio *hw_gpio = NULL;
+	uint32_t addr;
+	uint32_t regval;
+	uint32_t ddc_data_pd_en = 0;
+	uint32_t ddc_clk_pd_en = 0;
+	uint32_t aux_pad_mode = 0;
+
+	hw_gpio = &pin->base;
+
+	if (hw_gpio == NULL) {
+		ASSERT_CRITICAL(false);
+		return GPIO_RESULT_NULL_HANDLE;
+	}
+
+	/* switch dual mode GPIO to I2C/AUX mode */
+
+	addr = hw_gpio->pin_reg.DC_GPIO_DATA_MASK.addr;
+
+	regval = dm_read_reg(ptr->ctx, addr);
+
+	ddc_data_pd_en = get_reg_field_value(
+			regval,
+			DC_GPIO_DDC1_MASK,
+			DC_GPIO_DDC1DATA_PD_EN);
+
+	ddc_clk_pd_en = get_reg_field_value(
+			regval,
+			DC_GPIO_DDC1_MASK,
+			DC_GPIO_DDC1CLK_PD_EN);
+
+	aux_pad_mode = get_reg_field_value(
+			regval,
+			DC_GPIO_DDC1_MASK,
+			AUX_PAD1_MODE);
+
+	switch (config_data->config.ddc.type) {
+	case GPIO_DDC_CONFIG_TYPE_MODE_I2C:
+		/* On plug-in, there is a transient level on the pad
+		 * which must be discharged through the internal pull-down.
+		 * Enable internal pull-down, 2.5msec discharge time
+		 * is required for detection of AUX mode */
+		if (hw_gpio->base.en != GPIO_DDC_LINE_VIP_PAD) {
+			if (!ddc_data_pd_en || !ddc_clk_pd_en) {
+				set_reg_field_value(
+					regval,
+					1,
+					DC_GPIO_DDC1_MASK,
+					DC_GPIO_DDC1DATA_PD_EN);
+
+				set_reg_field_value(
+					regval,
+					1,
+					DC_GPIO_DDC1_MASK,
+					DC_GPIO_DDC1CLK_PD_EN);
+
+				dm_write_reg(ptr->ctx, addr, regval);
+
+				if (config_data->type ==
+					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
+					/* should not affect normal I2C R/W */
+					/* [anaumov] in DAL2, there was
+					 * dc_service_delay_in_microseconds(2500); */
+					msleep(3);
+			}
+		} else {
+			uint32_t reg2 = regval;
+			uint32_t sda_pd_dis = 0;
+			uint32_t scl_pd_dis = 0;
+
+			sda_pd_dis = get_reg_field_value(
+					reg2,
+					DC_GPIO_I2CPAD_MASK,
+					DC_GPIO_SDA_PD_DIS);
+
+			scl_pd_dis = get_reg_field_value(
+					reg2,
+					DC_GPIO_I2CPAD_MASK,
+					DC_GPIO_SCL_PD_DIS);
+
+			if (sda_pd_dis) {
+				sda_pd_dis = 0;
+
+				dm_write_reg(ptr->ctx, addr, reg2);
+
+				if (config_data->type ==
+					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
+					/* should not affect normal I2C R/W */
+					/* [anaumov] in DAL2, there was
+					 * dc_service_delay_in_microseconds(2500); */
+					msleep(3);
+			}
+
+			if (!scl_pd_dis) {
+				scl_pd_dis = 1;
+
+				dm_write_reg(ptr->ctx, addr, reg2);
+
+				if (config_data->type ==
+					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
+					/* should not affect normal I2C R/W */
+					/* [anaumov] in DAL2, there was
+					 * dc_service_delay_in_microseconds(2500); */
+					msleep(3);
+			}
+		}
+
+		if (aux_pad_mode) {
+			/* let pins to get de-asserted
+			 * before setting pad to I2C mode */
+			if (config_data->config.ddc.data_en_bit_present ||
+				config_data->config.ddc.clock_en_bit_present)
+				/* [anaumov] in DAL2, there was
+				 * dc_service_delay_in_microseconds(2000); */
+				msleep(2);
+
+			/* set the I2C pad mode */
+			/* read the register again,
+			 * some bits may have been changed */
+			regval = dm_read_reg(ptr->ctx, addr);
+
+			set_reg_field_value(
+				regval,
+				0,
+				DC_GPIO_DDC1_MASK,
+				AUX_PAD1_MODE);
+
+			dm_write_reg(ptr->ctx, addr, regval);
+		}
+
+		return GPIO_RESULT_OK;
+	case GPIO_DDC_CONFIG_TYPE_MODE_AUX:
+		/* set the AUX pad mode */
+		if (!aux_pad_mode) {
+			set_reg_field_value(
+				regval,
+				1,
+				DC_GPIO_DDC1_MASK,
+				AUX_PAD1_MODE);
+
+			dm_write_reg(ptr->ctx, addr, regval);
+		}
+
+		return GPIO_RESULT_OK;
+	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_CONNECT:
+		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
+			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
+			setup_i2c_polling(
+				ptr->ctx, pin->i2c_ddc_setup, 1, 0);
+			return GPIO_RESULT_OK;
+		}
+	break;
+	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_DISCONNECT:
+		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
+			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
+			setup_i2c_polling(
+				ptr->ctx, pin->i2c_ddc_setup, 1, 1);
+			return GPIO_RESULT_OK;
+		}
+	break;
+	case GPIO_DDC_CONFIG_TYPE_DISABLE_POLLING:
+		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
+			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
+			setup_i2c_polling(
+				ptr->ctx, pin->i2c_ddc_setup, 0, 0);
+			return GPIO_RESULT_OK;
+		}
+	break;
+	}
+
+	BREAK_TO_DEBUGGER();
+
+	return GPIO_RESULT_NON_SPECIFIC_ERROR;
+}
+
 static const struct hw_gpio_pin_funcs funcs = {
 	.destroy = destroy,
 	.open = dal_hw_ddc_open,
@@ -663,7 +639,7 @@ static const struct hw_gpio_pin_funcs funcs = {
 };
 
 static bool construct(
-	struct hw_ddc_dce80 *pin,
+	struct hw_ddc *pin,
 	enum gpio_id id,
 	uint32_t en,
 	struct dc_context *ctx)
@@ -671,38 +647,36 @@ static bool construct(
 	const struct hw_ddc_dce80_init *init;
 
 	if ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {
-		BREAK_TO_DEBUGGER();
+		ASSERT_CRITICAL(false);
 		return false;
 	}
 
-	if (!dal_hw_ddc_construct(&pin->base, id, en, ctx)) {
-		BREAK_TO_DEBUGGER();
+	if (!dal_hw_ddc_construct(pin, id, en, ctx)) {
+		ASSERT_CRITICAL(false);
 		return false;
 	}
 
-	pin->base.base.base.funcs = &funcs;
+	pin->base.base.funcs = &funcs;
 
 	switch (id) {
 	case GPIO_ID_DDC_DATA:
 		init = hw_ddc_dce80_init_data + en;
 
-		pin->base.base.pin_reg = init->hw_gpio_data_reg;
+		pin->base.pin_reg = init->hw_gpio_data_reg;
 		pin->i2c_ddc_setup = init->i2c_ddc_setup;
 
 		return true;
 	case GPIO_ID_DDC_CLOCK:
 		init = hw_ddc_dce80_init_clock + en;
 
-		pin->base.base.pin_reg = init->hw_gpio_data_reg;
+		pin->base.pin_reg = init->hw_gpio_data_reg;
 		pin->i2c_ddc_setup = init->i2c_ddc_setup;
 
 		return true;
 	default:
-		BREAK_TO_DEBUGGER();
+		ASSERT_CRITICAL(false);
 	}
 
-	dal_hw_ddc_destruct(&pin->base);
-
 	return false;
 }
 
@@ -711,17 +685,17 @@ struct hw_gpio_pin *dal_hw_ddc_dce80_create(
 	enum gpio_id id,
 	uint32_t en)
 {
-	struct hw_ddc_dce80 *pin = dm_alloc(sizeof(struct hw_ddc_dce80));
+	struct hw_ddc *pin = dm_alloc(sizeof(struct hw_ddc));
 
 	if (!pin) {
-		BREAK_TO_DEBUGGER();
+		ASSERT_CRITICAL(false);
 		return NULL;
 	}
 
 	if (construct(pin, id, en, ctx))
-		return &pin->base.base.base;
+		return &pin->base.base;
 
-	BREAK_TO_DEBUGGER();
+	ASSERT_CRITICAL(false);
 
 	dm_free(pin);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h
index 19e6773..1f14be3 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h
@@ -26,17 +26,9 @@
 #ifndef __DAL_HW_DDC_DCE80_H__
 #define __DAL_HW_DDC_DCE80_H__
 
-struct hw_ddc_dce80 {
-	struct hw_ddc base;
-	uint32_t i2c_ddc_setup;
-};
-
 struct hw_gpio_pin *dal_hw_ddc_dce80_create(
 	struct dc_context *ctx,
 	enum gpio_id id,
 	uint32_t en);
 
-#define DDC_DCE80_FROM_BASE(ddc_base) \
-	container_of(HW_DDC_FROM_BASE(ddc_base), struct hw_ddc_dce80, base)
-
 #endif
-- 
2.7.4

