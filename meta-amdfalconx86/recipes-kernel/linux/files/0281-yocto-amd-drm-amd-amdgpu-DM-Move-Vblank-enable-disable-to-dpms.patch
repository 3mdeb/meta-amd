From 3e548340d96444d997377a87d90f8c5677211ca0 Mon Sep 17 00:00:00 2001
From: Mykola Lysenko <mykola.lysenko@amd.com>
Date: Thu, 27 Aug 2015 22:43:46 +0800
Subject: [PATCH 398/401] drm/amd/amdgpu: [DM] Move Vblank enable/disable to
 dpms

1. Fix backtrace for set mode, after reset mode called from fake
    display code;
2. Adjust fake display reset mode code.
3. Send DPMS off on reset

Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c       | 25 ++++++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c | 99 ++++++++++++++++------------
 2 files changed, 80 insertions(+), 44 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
index 76a306b..1164e87 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
@@ -444,6 +444,7 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 	} else if (adev->dm.fake_display_index != INVALID_DISPLAY_INDEX) {
 		/* we assume only one display is connected */
 		uint32_t connected_display_index = 0;
+		struct drm_crtc *crtc;
 
 		mutex_unlock(&adev->dm.dal_mutex);
 
@@ -472,15 +473,33 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 			/* reset connected status on fake display connector */
 			aconnector->base.status = connector_status_disconnected;
 		} else {
-			amdgpu_dm_mode_reset(aconnector->base.encoder->crtc);
+			crtc = aconnector->base.encoder->crtc;
+
+			DRM_DEBUG_KMS("Setting connector DPMS state to off\n");
+			DRM_DEBUG_KMS("\t[CONNECTOR:%d] set DPMS off\n",
+					aconnector->base.base.id);
+			aconnector->base.funcs->dpms(
+					&aconnector->base, DRM_MODE_DPMS_OFF);
+
+			amdgpu_dm_mode_reset(crtc);
+
+			/*
+			 * as mode reset is done for fake display, we should
+			 * unreference drm fb and assign NULL pointer to the
+			 * primary drm frame, so we will receive full set mode
+			 * sequence later
+			 */
+
+			drm_framebuffer_unreference(crtc->primary->fb);
+
+			crtc->primary->fb = NULL;
 		}
 
 		adev->dm.fake_display_index = INVALID_DISPLAY_INDEX;
 
 		trigger_drm_hpd_event = true;
-	} else {
+	} else
 		mutex_unlock(&adev->dm.dal_mutex);
-	}
 
 	if (true == trigger_drm_hpd_event)
 		drm_kms_helper_hotplug_event(dev);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
index e0a69bd..48628dd 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
@@ -623,7 +623,7 @@ bool amdgpu_dm_mode_reset(struct drm_crtc *crtc)
 	}
 
 	/* unpin the FB */
-	if (crtc->primary->fb)	{
+	if (crtc->primary->fb)  {
 		struct amdgpu_framebuffer *afb;
 		struct amdgpu_bo *rbo;
 		int r;
@@ -766,6 +766,17 @@ int amdgpu_dm_set_config(struct drm_mode_set *set)
 
 		DRM_DEBUG_KMS("[CRTC:%d] [NOFB]\n", set->crtc->base.id);
 
+		DRM_DEBUG_KMS("Setting connector DPMS state to off\n");
+		for (i = 0; i < set->num_connectors; i++) {
+			DRM_DEBUG_KMS(
+				"\t[CONNECTOR:%d] set DPMS off\n",
+				set->connectors[i]->base.id);
+
+			set->connectors[i]->funcs->dpms(
+				set->connectors[i], DRM_MODE_DPMS_OFF);
+
+		}
+
 		if (!amdgpu_dm_mode_reset(set->crtc)) {
 			DRM_ERROR("### Failed to reset mode on [CRTC:%d] ###\n",
 					set->crtc->base.id);
@@ -1171,44 +1182,6 @@ static void add_to_mq_helper(void *what, const struct path_mode *pm)
 	dal_mode_query_pin_path_mode(what, pm);
 }
 
-
-static void amdgpu_dm_connector_dpms(struct drm_connector *connector, int mode)
-{
-	struct drm_device *dev = connector->dev;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
-	uint32_t display_index = aconnector->connector_id;
-	enum dal_power_state ps;
-
-	if (mode == connector->dpms)
-		return;
-
-	switch (mode) {
-	case DRM_MODE_DPMS_ON:
-		ps = DAL_POWER_STATE_ON;
-		break;
-	case DRM_MODE_DPMS_OFF:
-		ps = DAL_POWER_STATE_OFF;
-		break;
-	case DRM_MODE_DPMS_STANDBY:
-		ps = DAL_POWER_STATE_STANDBY;
-		break;
-	case DRM_MODE_DPMS_SUSPEND:
-		ps = DAL_POWER_STATE_SUSPEND;
-		break;
-	default:
-		DRM_ERROR("Invalid DPMS mode requested\n");
-		return;
-	}
-
-	dal_set_display_dpms(adev->dm.dal, display_index, ps);
-
-	connector->dpms = mode;
-
-	/* adjust pm to dpms */
-	amdgpu_pm_compute_clocks(adev);
-}
-
 static enum drm_connector_status
 amdgpu_dm_connector_detect(struct drm_connector *connector, bool force)
 {
@@ -1393,6 +1366,47 @@ static void amdgpu_dm_connector_force(struct drm_connector *connector)
 	DRM_ERROR("NOT IMPLEMENTED\n");
 }
 
+static inline enum dal_power_state to_dal_power_state(int mode)
+{
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		return DAL_POWER_STATE_ON;
+	case DRM_MODE_DPMS_OFF:
+		return DAL_POWER_STATE_OFF;
+	case DRM_MODE_DPMS_STANDBY:
+		return DAL_POWER_STATE_STANDBY;
+	case DRM_MODE_DPMS_SUSPEND:
+		return DAL_POWER_STATE_SUSPEND;
+	default:
+		/*
+		 * if unknown dpms mode passed for any reason display would be
+		 * disabled, with log notification
+		 */
+		DRM_ERROR("Invalid DPMS mode requested\n");
+		return DAL_POWER_STATE_OFF;
+	}
+}
+
+
+static void amdgpu_dm_connector_dpms(struct drm_connector *connector, int mode)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+	uint32_t display_index = aconnector->connector_id;
+	enum dal_power_state ps = to_dal_power_state(mode);
+
+	if (mode == connector->dpms)
+		return;
+
+	dal_set_display_dpms(adev->dm.dal, display_index, ps);
+
+	connector->dpms = mode;
+
+	/* adjust pm to dpms */
+	amdgpu_pm_compute_clocks(adev);
+}
+
 static const struct drm_connector_funcs amdgpu_dm_connector_funcs = {
 	.dpms = amdgpu_dm_connector_dpms,
 /*	.save = NULL,
@@ -1407,16 +1421,19 @@ static const struct drm_connector_funcs amdgpu_dm_connector_funcs = {
 
 static void dm_crtc_helper_dpms(struct drm_crtc *crtc, int mode)
 {
+
 	switch (mode) {
 	case DRM_MODE_DPMS_ON:
 		drm_crtc_vblank_on(crtc);
 		break;
-	case DRM_MODE_DPMS_STANDBY:
-	case DRM_MODE_DPMS_SUSPEND:
 	case DRM_MODE_DPMS_OFF:
+	case DRM_MODE_DPMS_SUSPEND:
+	case DRM_MODE_DPMS_STANDBY:
+	default:
 		drm_crtc_vblank_off(crtc);
 		break;
 	}
+
 }
 
 static const struct drm_crtc_helper_funcs amdgpu_dm_crtc_helper_funcs = {
-- 
1.9.1

