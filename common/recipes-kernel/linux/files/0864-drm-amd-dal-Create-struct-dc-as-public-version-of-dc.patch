From 43f8163624df6de327571c0d5cd6a4cbd517058c Mon Sep 17 00:00:00 2001
From: Jun Lei <Jun.Lei@amd.com>
Date: Sat, 27 Feb 2016 16:31:53 -0500
Subject: [PATCH 0864/1110] drm/amd/dal: Create struct dc as public version of
 dc handle rather than forward declare pointer to struct core_dc

Signed-off-by: Jun Lei <Jun.Lei@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      |  17 +-
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h      |   2 +-
 .../drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c    |   2 +-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    |   6 +-
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 235 +++++++++++----------
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  16 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_surface.c       |  11 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_target.c        |  19 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  60 +++---
 drivers/gpu/drm/amd/dal/dc/dc_types.h              |   3 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_dc.h           |   4 +
 11 files changed, 205 insertions(+), 170 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index ed2cdc5..2f2077e1 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -162,7 +162,7 @@ static void dm_pflip_high_irq(void *interrupt_params)
 	struct common_irq_params *irq_params = interrupt_params;
 	struct amdgpu_device *adev = irq_params->adev;
 	unsigned long flags;
-	const struct core_dc *dc = irq_params->adev->dm.dc;
+	const struct dc *dc = irq_params->adev->dm.dc;
 	const struct dc_target *dc_target =
 			dc_get_target_on_irq_source(dc, irq_params->irq_src);
 
@@ -204,7 +204,7 @@ static void dm_crtc_high_irq(void *interrupt_params)
 {
 	struct common_irq_params *irq_params = interrupt_params;
 	struct amdgpu_device *adev = irq_params->adev;
-	const struct core_dc *dc = irq_params->adev->dm.dc;
+	const struct dc *dc = irq_params->adev->dm.dc;
 	const struct dc_target *dc_target =
 			dc_get_target_on_irq_source(dc, irq_params->irq_src);
 	uint8_t crtc_index = 0;
@@ -759,14 +759,11 @@ static void register_hpd_handlers(struct amdgpu_device *adev)
 /* Register IRQ sources and initialize IRQ callbacks */
 static int dce110_register_irq_handlers(struct amdgpu_device *adev)
 {
-	struct core_dc *dc = adev->dm.dc;
+	struct dc *dc = adev->dm.dc;
 	struct common_irq_params *c_irq_params;
 	struct dc_interrupt_params int_params = {0};
 	int r;
 	int i;
-	struct dc_caps caps = { 0 };
-
-	dc_get_caps(dc, &caps);
 
 	int_params.requested_polarity = INTERRUPT_POLARITY_DEFAULT;
 	int_params.current_polarity = INTERRUPT_POLARITY_DEFAULT;
@@ -928,18 +925,16 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 	struct amdgpu_connector *aconnector;
 	struct amdgpu_encoder *aencoder;
 	struct amdgpu_crtc *acrtc;
-	struct dc_caps caps = { 0 };
 	uint32_t link_cnt;
 
-	dc_get_caps(dm->dc, &caps);
-	link_cnt = caps.max_links;
+	link_cnt = dm->dc->caps.max_links;
 
 	if (amdgpu_dm_mode_config_init(dm->adev)) {
 		DRM_ERROR("DM: Failed to initialize mode config\n");
 		return -1;
 	}
 
-	for (i = 0; i < caps.max_targets; i++) {
+	for (i = 0; i < dm->dc->caps.max_targets; i++) {
 		acrtc = kzalloc(sizeof(struct amdgpu_crtc), GFP_KERNEL);
 		if (!acrtc)
 			goto fail;
@@ -954,7 +949,7 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 		}
 	}
 
-	dm->display_indexes_num = caps.max_targets;
+	dm->display_indexes_num = dm->dc->caps.max_targets;
 
 	/* loops over all connectors on the board */
 	for (i = 0; i < link_cnt; i++) {
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h
index 4f3bf97..94c20d5 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.h
@@ -74,7 +74,7 @@ struct irq_list_head {
 
 struct amdgpu_display_manager {
 	struct dal *dal;
-	struct core_dc *dc;
+	struct dc *dc;
 	void *cgs_device;
 	/* lock to be used when DAL is called from SYNC IRQ context */
 	spinlock_t dal_lock;
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
index ed0b9d7..2ab2703 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -80,7 +80,7 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg
 	struct pci_dev *pdev = to_pci_dev(aux->dev);
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 	struct amdgpu_device *adev = drm_dev->dev_private;
-	struct core_dc *dc = adev->dm.dc;
+	struct dc *dc = adev->dm.dc;
 	bool res;
 
 	switch (msg->request) {
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index 1c767f3..a8a2e10 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -622,7 +622,7 @@ static void calculate_stream_scaling_settings(
 }
 
 static void dm_dc_surface_commit(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct drm_crtc *crtc,
 		struct dm_connector_state *dm_state)
 {
@@ -1873,7 +1873,7 @@ int amdgpu_dm_connector_init(
 {
 	int res = 0;
 	int connector_type;
-	struct core_dc *dc = dm->dc;
+	struct dc *dc = dm->dc;
 	const struct dc_link *link = dc_get_link_at_index(dc, link_index);
 	struct amdgpu_i2c_adapter *i2c;
 
@@ -2488,7 +2488,7 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 	struct dc_validation_set set[MAX_TARGET_NUM] = {{ 0 }};
 	struct dc_target *new_targets[MAX_TARGET_NUM] = { 0 };
 	struct amdgpu_device *adev = dev->dev_private;
-	struct core_dc *dc = adev->dm.dc;
+	struct dc *dc = adev->dm.dc;
 	bool need_to_validate = false;
 
 	ret = drm_atomic_helper_check(dev, state);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 9ae1bc7..339c82f 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -304,7 +304,6 @@ static bool construct(struct core_dc *dc, const struct dc_init_data *init_params
 	struct adapter_service *as;
 	struct dc_context *dc_ctx = dm_alloc(sizeof(*dc_ctx));
 
-
 	if (!dc_ctx) {
 		dm_error("%s: failed to create ctx\n", __func__);
 		goto ctx_fail;
@@ -312,7 +311,7 @@ static bool construct(struct core_dc *dc, const struct dc_init_data *init_params
 
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
-	dc_ctx->dc = dc;
+	dc_ctx->dc = &dc->public;
 
 	/* Create logger */
 	logger = dal_logger_create(dc_ctx);
@@ -409,7 +408,8 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
 */
 static int8_t acquire_first_free_underlay(
 		struct resource_context *res_ctx,
-		struct core_stream *stream)
+		struct core_stream *stream,
+		struct core_dc* core_dc)
 {
 	if (!res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX].stream) {
 		struct dc_bios *dcb;
@@ -426,8 +426,8 @@ static int8_t acquire_first_free_underlay(
 		dcb = dal_adapter_service_get_bios_parser(
 						res_ctx->pool.adapter_srv);
 
-		stream->ctx->dc->hwss.enable_display_power_gating(
-			stream->ctx->dc->ctx,
+		core_dc->hwss.enable_display_power_gating(
+			core_dc->ctx,
 			DCE110_UNDERLAY_IDX,
 			dcb, PIPE_GATING_CONTROL_DISABLE);
 
@@ -454,7 +454,7 @@ static int8_t acquire_first_free_underlay(
  * Public functions
  ******************************************************************************/
 
-struct core_dc *dc_create(const struct dc_init_data *init_params)
+struct dc *dc_create(const struct dc_init_data *init_params)
  {
 	struct dc_context ctx = {
 		.driver_context = init_params->driver,
@@ -465,14 +465,18 @@ struct core_dc *dc_create(const struct dc_init_data *init_params)
 	if (NULL == dc)
 		goto alloc_fail;
 
-	ctx.dc = dc;
+	ctx.dc = &dc->public;
 	if (false == construct(dc, init_params))
 		goto construct_fail;
 
 	/*TODO: separate HW and SW initialization*/
 	init_hw(dc);
 
-	return dc;
+	dc->public.caps.max_targets = dc->res_pool.pipe_count;
+	dc->public.caps.max_links = dc->link_count;
+	dc->public.caps.max_audios = dc->res_pool.audio_count;
+
+	return &dc->public;
 
 construct_fail:
 	dm_free(dc);
@@ -481,18 +485,20 @@ alloc_fail:
 	return NULL;
 }
 
-void dc_destroy(struct core_dc **dc)
+void dc_destroy(struct dc **dc)
 {
-	destruct(*dc);
-	dm_free(*dc);
+	struct core_dc *core_dc = DC_TO_CORE(*dc);
+	destruct(core_dc);
+	dm_free(core_dc);
 	*dc = NULL;
 }
 
 bool dc_validate_resources(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		const struct dc_validation_set set[],
 		uint8_t set_count)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
@@ -500,8 +506,8 @@ bool dc_validate_resources(
 	if(context == NULL)
 		goto context_alloc_fail;
 
-	result = dc->res_pool.funcs->validate_with_context(
-						dc, set, set_count, context);
+	result = core_dc->res_pool.funcs->validate_with_context(
+						core_dc, set, set_count, context);
 
 	val_ctx_destruct(context);
 	dm_free(context);
@@ -512,7 +518,7 @@ context_alloc_fail:
 }
 
 static void program_timing_sync(
-		struct dc_context *dc_ctx,
+		struct core_dc *core_dc,
 		struct validate_context *ctx)
 {
 	uint8_t i;
@@ -552,7 +558,7 @@ static void program_timing_sync(
 	}
 
 	if(group_size > 1) {
-		dc_ctx->dc->hwss.enable_timing_synchronization(dc_ctx, group_size, tg_set);
+		core_dc->hwss.enable_timing_synchronization(core_dc->ctx, group_size, tg_set);
 	}
 }
 
@@ -574,12 +580,11 @@ static bool targets_changed(
 	return false;
 }
 
-static void target_enable_memory_requests(struct dc_target *dc_target)
+static void target_enable_memory_requests(struct dc_target *dc_target,
+		struct resource_context *res_ctx)
 {
 	uint8_t i, j;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
-	struct resource_context *res_ctx =
-		&target->ctx->dc->current_context.res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -597,12 +602,11 @@ static void target_enable_memory_requests(struct dc_target *dc_target)
 	}
 }
 
-static void target_disable_memory_requests(struct dc_target *dc_target)
+static void target_disable_memory_requests(struct dc_target *dc_target,
+		struct resource_context *res_ctx)
 {
 	uint8_t i, j;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
-	struct resource_context *res_ctx =
-		&target->ctx->dc->current_context.res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -621,19 +625,20 @@ static void target_disable_memory_requests(struct dc_target *dc_target)
 }
 
 bool dc_commit_targets(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct dc_target *targets[],
 	uint8_t target_count)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 	struct dc_validation_set set[4];
 	uint8_t i;
 
-	if (false == targets_changed(dc, targets, target_count))
+	if (false == targets_changed(core_dc, targets, target_count))
 		return DC_OK;
 
-	dal_logger_write(dc->ctx->logger,
+	dal_logger_write(core_dc->ctx->logger,
 				LOG_MAJOR_INTERFACE_TRACE,
 				LOG_MINOR_COMPONENT_DC,
 				"%s: %d targets\n",
@@ -644,7 +649,7 @@ bool dc_commit_targets(
 		struct dc_target *target = targets[i];
 
 		dc_target_log(target,
-				dc->ctx->logger,
+				core_dc->ctx->logger,
 				LOG_MAJOR_INTERFACE_TRACE,
 				LOG_MINOR_COMPONENT_DC);
 
@@ -657,46 +662,46 @@ bool dc_commit_targets(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	result = dc->res_pool.funcs->validate_with_context(dc, set, target_count, context);
+	result = core_dc->res_pool.funcs->validate_with_context(core_dc, set, target_count, context);
 	if (result != DC_OK){
 		BREAK_TO_DEBUGGER();
 		val_ctx_destruct(context);
 		goto fail;
 	}
 
-	pplib_apply_safe_state(dc);
+	pplib_apply_safe_state(core_dc);
 
 	if (!dal_adapter_service_is_in_accelerated_mode(
-						dc->res_pool.adapter_srv)) {
-		dc->hwss.enable_accelerated_mode(dc);
+						core_dc->res_pool.adapter_srv)) {
+		core_dc->hwss.enable_accelerated_mode(core_dc);
 	}
 
-	for (i = 0; i < dc->current_context.target_count; i++) {
+	for (i = 0; i < core_dc->current_context.target_count; i++) {
 		/*TODO: optimize this to happen only when necessary*/
 		target_disable_memory_requests(
-				&dc->current_context.targets[i]->public);
+				&core_dc->current_context.targets[i]->public, &core_dc->current_context.res_ctx);
 	}
 
 	if (result == DC_OK) {
-		dc->hwss.reset_hw_ctx(dc, context);
+		core_dc->hwss.reset_hw_ctx(core_dc, context);
 
 		if (context->target_count > 0)
-			result = dc->hwss.apply_ctx_to_hw(dc, context);
+			result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
 	}
 
 	for (i = 0; i < context->target_count; i++) {
 		struct dc_target *dc_target = &context->targets[i]->public;
 		if (context->target_status[i].surface_count > 0)
-			target_enable_memory_requests(dc_target);
+			target_enable_memory_requests(dc_target, &core_dc->current_context.res_ctx);
 	}
 
-	program_timing_sync(dc->ctx, context);
+	program_timing_sync(core_dc, context);
 
-	pplib_apply_display_requirements(dc, context, &context->pp_display_cfg);
+	pplib_apply_display_requirements(core_dc, context, &context->pp_display_cfg);
 
-	val_ctx_destruct(&dc->current_context);
+	val_ctx_destruct(&core_dc->current_context);
 
-	dc->current_context = *context;
+	core_dc->current_context = *context;
 
 fail:
 	dm_free(context);
@@ -706,14 +711,16 @@ context_alloc_fail:
 }
 
 bool dc_commit_surfaces_to_target(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct dc_surface *new_surfaces[],
 		uint8_t new_surface_count,
 		struct dc_target *dc_target)
 
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
 	int i, j;
-	uint32_t prev_disp_clk = dc->current_context.bw_results.dispclk_khz;
+	uint32_t prev_disp_clk = core_dc->current_context.bw_results.dispclk_khz;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 	struct dc_target_status *target_status = NULL;
 	struct validate_context *context;
@@ -723,7 +730,7 @@ bool dc_commit_surfaces_to_target(
 
 	context = dm_alloc(sizeof(struct validate_context));
 
-	val_ctx_copy_construct(&dc->current_context, context);
+	val_ctx_copy_construct(&core_dc->current_context, context);
 
 	/* Cannot commit surface to a target that is not commited */
 	for (i = 0; i < context->target_count; i++)
@@ -733,7 +740,7 @@ bool dc_commit_surfaces_to_target(
 	target_status = &context->target_status[i];
 
 	if (!dal_adapter_service_is_in_accelerated_mode(
-						dc->res_pool.adapter_srv)
+						core_dc->res_pool.adapter_srv)
 		|| i == context->target_count) {
 		BREAK_TO_DEBUGGER();
 		goto unexpected_fail;
@@ -750,14 +757,14 @@ bool dc_commit_surfaces_to_target(
 	/* TODO unhack mpo */
 	if (new_surface_count == 2 && target_status->surface_count < 2) {
 		acquire_first_free_underlay(&context->res_ctx,
-				DC_STREAM_TO_CORE(dc_target->streams[0]));
+				DC_STREAM_TO_CORE(dc_target->streams[0]), core_dc);
 		is_mpo_turning_on = true;
 	} else if (new_surface_count < 2 && target_status->surface_count == 2) {
 		context->res_ctx.pipe_ctx[DCE110_UNDERLAY_IDX].stream = NULL;
 		context->res_ctx.pipe_ctx[DCE110_UNDERLAY_IDX].surface = NULL;
 	}
 
-	dal_logger_write(dc->ctx->logger,
+	dal_logger_write(core_dc->ctx->logger,
 				LOG_MAJOR_INTERFACE_TRACE,
 				LOG_MINOR_COMPONENT_DC,
 				"%s: commit %d surfaces to target 0x%x\n",
@@ -782,7 +789,7 @@ bool dc_commit_surfaces_to_target(
 				new_surfaces[i], &context->res_ctx.pipe_ctx[j]);
 		}
 
-	if (dc->res_pool.funcs->validate_bandwidth(dc, context) != DC_OK) {
+	if (core_dc->res_pool.funcs->validate_bandwidth(core_dc, context) != DC_OK) {
 		BREAK_TO_DEBUGGER();
 		goto unexpected_fail;
 	}
@@ -790,13 +797,13 @@ bool dc_commit_surfaces_to_target(
 	if (prev_disp_clk < context->bw_results.dispclk_khz ||
 		(is_mpo_turning_on &&
 			prev_disp_clk == context->bw_results.dispclk_khz)) {
-		dc->hwss.program_bw(dc, context);
-		pplib_apply_display_requirements(dc, context,
+		core_dc->hwss.program_bw(core_dc, context);
+		pplib_apply_display_requirements(core_dc, context,
 						&context->pp_display_cfg);
 	}
 
 	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
-		target_disable_memory_requests(dc_target);
+		target_disable_memory_requests(dc_target, &core_dc->current_context.res_ctx);
 
 	for (i = 0; i < new_surface_count; i++)
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -811,7 +818,7 @@ bool dc_commit_surfaces_to_target(
 					DC_SURFACE_TO_CORE(new_surfaces[i]))
 				continue;
 
-			dal_logger_write(dc->ctx->logger,
+			dal_logger_write(core_dc->ctx->logger,
 						LOG_MAJOR_INTERFACE_TRACE,
 						LOG_MINOR_COMPONENT_DC,
 						"Pipe:%d 0x%x: src: %d, %d, %d,"
@@ -831,26 +838,26 @@ bool dc_commit_surfaces_to_target(
 				gamma = DC_GAMMA_TO_CORE(
 					surface->public.gamma_correction);
 
-			dc->hwss.set_gamma_correction(
+			core_dc->hwss.set_gamma_correction(
 					pipe_ctx->ipp,
 					pipe_ctx->opp,
 					gamma, surface);
 
-			dc->hwss.set_plane_config(
-				dc, pipe_ctx, &context->res_ctx);
+			core_dc->hwss.set_plane_config(
+				core_dc, pipe_ctx, &context->res_ctx);
 		}
 
-	dc->hwss.update_plane_addrs(dc, &context->res_ctx);
+	core_dc->hwss.update_plane_addrs(core_dc, &context->res_ctx);
 
 	/* Lower display clock if necessary */
 	if (prev_disp_clk > context->bw_results.dispclk_khz) {
-		dc->hwss.program_bw(dc, context);
-		pplib_apply_display_requirements(dc, context,
+		core_dc->hwss.program_bw(core_dc, context);
+		pplib_apply_display_requirements(core_dc, context,
 						&context->pp_display_cfg);
 	}
 
-	val_ctx_destruct(&dc->current_context);
-	dc->current_context = *context;
+	val_ctx_destruct(&(core_dc->current_context));
+	core_dc->current_context = *context;
 	dm_free(context);
 	return true;
 
@@ -862,59 +869,61 @@ unexpected_fail:
 	return false;
 }
 
-uint8_t dc_get_current_target_count(const struct core_dc *dc)
+uint8_t dc_get_current_target_count(const struct dc *dc)
 {
-	return dc->current_context.target_count;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->current_context.target_count;
 }
 
-struct dc_target *dc_get_target_at_index(const struct core_dc *dc, uint8_t i)
+struct dc_target *dc_get_target_at_index(const struct dc *dc, uint8_t i)
 {
-	if (i < dc->current_context.target_count)
-		return &dc->current_context.targets[i]->public;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	if (i < core_dc->current_context.target_count)
+		return &(core_dc->current_context.targets[i]->public);
 	return NULL;
 }
 
-const struct dc_link *dc_get_link_at_index(struct core_dc *dc, uint32_t link_index)
+const struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)
 {
-	return &dc->links[link_index]->public;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return &core_dc->links[link_index]->public;
 }
 
 const struct graphics_object_id dc_get_link_id_at_index(
-	struct core_dc *dc, uint32_t link_index)
+	struct dc *dc, uint32_t link_index)
 {
-	return dc->links[link_index]->link_id;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->link_id;
 }
 
 const struct ddc_service *dc_get_ddc_at_index(
-	struct core_dc *dc, uint32_t link_index)
+	struct dc *dc, uint32_t link_index)
 {
-	return dc->links[link_index]->ddc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->ddc;
 }
 
 const enum dc_irq_source dc_get_hpd_irq_source_at_index(
-	struct core_dc *dc, uint32_t link_index)
+	struct dc *dc, uint32_t link_index)
 {
-	return dc->links[link_index]->public.irq_source_hpd;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->public.irq_source_hpd;
 }
 
-const struct audio **dc_get_audios(struct core_dc *dc)
+const struct audio **dc_get_audios(struct dc *dc)
 {
-	return (const struct audio **)dc->res_pool.audios;
-}
-
-void dc_get_caps(const struct core_dc *dc, struct dc_caps *caps)
-{
-	caps->max_targets = dc->res_pool.pipe_count;
-	caps->max_links = dc->link_count;
-	caps->max_audios = dc->res_pool.audio_count;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return (const struct audio **)core_dc->res_pool.audios;
 }
 
 void dc_flip_surface_addrs(
-		struct core_dc *dc,
+		struct dc *dc,
 		const struct dc_surface *const surfaces[],
 		struct dc_flip_addrs flip_addrs[],
 		uint32_t count)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
 	uint8_t i;
 	for (i = 0; i < count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
@@ -925,31 +934,36 @@ void dc_flip_surface_addrs(
 		surface->public.address = flip_addrs[i].address;
 		surface->public.flip_immediate = flip_addrs[i].flip_immediate;
 	}
-	dc->hwss.update_plane_addrs(dc, &dc->current_context.res_ctx);
+	core_dc->hwss.update_plane_addrs(core_dc, &core_dc->current_context.res_ctx);
 }
 
 enum dc_irq_source dc_interrupt_to_irq_source(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t src_id,
 		uint32_t ext_id)
 {
-	return dal_irq_service_to_irq_source(dc->res_pool.irqs, src_id, ext_id);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return dal_irq_service_to_irq_source(core_dc->res_pool.irqs, src_id, ext_id);
 }
 
-void dc_interrupt_set(const struct core_dc *dc, enum dc_irq_source src, bool enable)
+void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable)
 {
-	dal_irq_service_set(dc->res_pool.irqs, src, enable);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	dal_irq_service_set(core_dc->res_pool.irqs, src, enable);
 }
 
-void dc_interrupt_ack(struct core_dc *dc, enum dc_irq_source src)
+void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 {
-	dal_irq_service_ack(dc->res_pool.irqs, src);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	dal_irq_service_ack(core_dc->res_pool.irqs, src);
 }
 
 const struct dc_target *dc_get_target_on_irq_source(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		enum dc_irq_source src)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
 	uint8_t i, j;
 	uint8_t crtc_idx;
 
@@ -976,15 +990,15 @@ const struct dc_target *dc_get_target_on_irq_source(
 		return NULL;
 	}
 
-	for (i = 0; i < dc->current_context.target_count; i++) {
-		struct core_target *target = dc->current_context.targets[i];
+	for (i = 0; i < core_dc->current_context.target_count; i++) {
+		struct core_target *target = core_dc->current_context.targets[i];
 		struct dc_target *dc_target = &target->public;
 
 		for (j = 0; j < target->public.stream_count; j++) {
 			const struct core_stream *stream =
 				DC_STREAM_TO_CORE(dc_target->streams[j]);
 
-			if (dc->current_context.res_ctx.
+			if (core_dc->current_context.res_ctx.
 					pipe_ctx[crtc_idx].stream == stream)
 				return dc_target;
 		}
@@ -995,44 +1009,49 @@ const struct dc_target *dc_get_target_on_irq_source(
 }
 
 void dc_set_power_state(
-	struct core_dc *dc,
+	struct dc *dc,
 	enum dc_acpi_cm_power_state power_state,
 	enum dc_video_power_state video_power_state)
 {
-	dc->previous_power_state = dc->current_power_state;
-	dc->current_power_state = video_power_state;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	core_dc->previous_power_state = core_dc->current_power_state;
+	core_dc->current_power_state = video_power_state;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
-		init_hw(dc);
+		init_hw(core_dc);
 		break;
 	default:
 		/* NULL means "reset/release all DC targets" */
 		dc_commit_targets(dc, NULL, 0);
 
-		dc->hwss.power_down(dc);
+		core_dc->hwss.power_down(core_dc);
 		break;
 	}
 
 }
 
-void dc_resume(const struct core_dc *dc)
+void dc_resume(const struct dc *dc)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
 	uint32_t i;
 
-	for (i = 0; i < dc->link_count; i++)
-		core_link_resume(dc->links[i]);
+	for (i = 0; i < core_dc->link_count; i++)
+		core_link_resume(core_dc->links[i]);
 }
 
 bool dc_read_dpcd(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t link_index,
 		uint32_t address,
 		uint8_t *data,
 		uint32_t size)
 {
-	struct core_link *link = dc->links[link_index];
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
+	struct core_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
 			link->ddc,
 			address,
@@ -1042,13 +1061,15 @@ bool dc_read_dpcd(
 }
 
 bool dc_write_dpcd(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t link_index,
 		uint32_t address,
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct core_link *link = dc->links[link_index];
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
@@ -1059,11 +1080,13 @@ bool dc_write_dpcd(
 }
 
 bool dc_submit_i2c(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t link_index,
 		struct i2c_command *cmd)
 {
-	struct core_link *link = dc->links[link_index];
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
 	struct ddc_service *ddc = link->ddc;
 
 	return dal_i2caux_submit_i2c_command(
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 58c7d43..01c28f2 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -58,11 +58,13 @@ enum {
  ******************************************************************************/
 static void destruct(struct core_link *link)
 {
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
+
 	if (link->ddc)
 		dal_ddc_service_destroy(&link->ddc);
 
 	if(link->link_enc)
-		link->ctx->dc->res_pool.funcs->link_enc_destroy(&link->link_enc);
+		core_dc->res_pool.funcs->link_enc_destroy(&link->link_enc);
 }
 
 /*
@@ -988,7 +990,7 @@ static bool construct(
 	enc_init_data.hpd_source = get_hpd_line(link, as);
 	enc_init_data.transmitter =
 			translate_encoder_to_transmitter(enc_init_data.encoder);
-	link->link_enc = dc_ctx->dc->res_pool.funcs->link_enc_create(
+	link->link_enc = link->dc->res_pool.funcs->link_enc_create(
 								&enc_init_data);
 
 	if( link->link_enc == NULL) {
@@ -1049,7 +1051,7 @@ static bool construct(
 
 	return true;
 device_tag_fail:
-	link->ctx->dc->res_pool.funcs->link_enc_destroy(&link->link_enc);
+	link->dc->res_pool.funcs->link_enc_destroy(&link->link_enc);
 link_enc_create_fail:
 	dal_ddc_service_destroy(&link->ddc);
 ddc_create_fail:
@@ -1621,14 +1623,14 @@ static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 
 void core_link_enable_stream(struct pipe_ctx *pipe_ctx)
 {
-    struct core_dc *dc = pipe_ctx->stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(pipe_ctx->stream->ctx->dc);
 
 	if (DC_OK != enable_link(pipe_ctx)) {
 			BREAK_TO_DEBUGGER();
 			return;
 	}
 
-	dc->hwss.enable_stream(pipe_ctx);
+	core_dc->hwss.enable_stream(pipe_ctx);
 
 	pipe_ctx->stream->status.link = &pipe_ctx->stream->sink->link->public;
 
@@ -1638,13 +1640,13 @@ void core_link_enable_stream(struct pipe_ctx *pipe_ctx)
 
 void core_link_disable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct core_dc *dc = pipe_ctx->stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(pipe_ctx->stream->ctx->dc);
 
 	pipe_ctx->stream->status.link = NULL;
 	if (pipe_ctx->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)
 		deallocate_mst_payload(pipe_ctx);
 
-	dc->hwss.disable_stream(pipe_ctx);
+	core_dc->hwss.disable_stream(pipe_ctx);
 
 	pipe_ctx->stream->status.link = NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
index 4a3d18d..5c586ba 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
@@ -79,14 +79,16 @@ void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_surface *dc_create_surface(const struct core_dc *dc)
+struct dc_surface *dc_create_surface(const struct dc *dc)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
 	struct surface *surface = dm_alloc(sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
 
-	if (false == construct(dc->ctx, surface))
+	if (false == construct(core_dc->ctx, surface))
 		goto construct_fail;
 
 	dc_surface_retain(&surface->protected.public);
@@ -146,14 +148,15 @@ void dc_gamma_release(const struct dc_gamma *dc_gamma)
 	}
 }
 
-struct dc_gamma *dc_create_gamma(const struct core_dc *dc)
+struct dc_gamma *dc_create_gamma(const struct dc *dc)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct gamma *gamma = dm_alloc(sizeof(*gamma));
 
 	if (gamma == NULL)
 		goto alloc_fail;
 
-	if (false == construct_gamma(dc->ctx, gamma))
+	if (false == construct_gamma(core_dc->ctx, gamma))
 		goto construct_fail;
 
 	dc_gamma_retain(&gamma->protected.public);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
index c697a5e..44fe442 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
@@ -92,7 +92,7 @@ const struct dc_target_status *dc_target_get_status(
 {
 	uint8_t i;
 	struct core_target* target = DC_TARGET_TO_CORE(dc_target);
-    struct core_dc *dc = target->ctx->dc;
+    struct core_dc *dc = DC_TO_CORE(target->ctx->dc);
 
 	for (i = 0; i < dc->current_context.target_count; i++)
 		if (target == dc->current_context.targets[i])
@@ -151,6 +151,7 @@ bool dc_target_set_cursor_attributes(
 {
 	uint8_t i, j;
 	struct core_target *target;
+	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
 	if (NULL == dc_target) {
@@ -165,7 +166,8 @@ bool dc_target_set_cursor_attributes(
 	}
 
 	target = DC_TARGET_TO_CORE(dc_target);
-	res_ctx = &target->ctx->dc->current_context.res_ctx;
+	core_dc = DC_TO_CORE(target->ctx->dc);
+	res_ctx = &core_dc->current_context.res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -195,6 +197,7 @@ bool dc_target_set_cursor_position(
 {
 	uint8_t i, j;
 	struct core_target *target;
+	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
 	if (NULL == dc_target) {
@@ -208,7 +211,8 @@ bool dc_target_set_cursor_position(
 	}
 
 	target = DC_TARGET_TO_CORE(dc_target);
-	res_ctx = &target->ctx->dc->current_context.res_ctx;
+	core_dc = DC_TO_CORE(target->ctx->dc);
+	res_ctx = &core_dc->current_context.res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -235,8 +239,9 @@ uint32_t dc_target_get_vblank_counter(const struct dc_target *dc_target)
 {
 	uint8_t i, j;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
+	struct core_dc *core_dc = DC_TO_CORE(target->ctx->dc);
 	struct resource_context *res_ctx =
-		&target->ctx->dc->current_context.res_ctx;
+		&core_dc->current_context.res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -254,17 +259,19 @@ uint32_t dc_target_get_vblank_counter(const struct dc_target *dc_target)
 }
 
 enum dc_irq_source dc_target_get_irq_src(
-	const struct core_dc *dc,
+	const struct dc *dc,
 	const struct dc_target *dc_target,
 	const enum irq_type irq_type)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
 	uint8_t i;
 	struct core_target *core_target = DC_TARGET_TO_CORE(dc_target);
 	struct core_stream *stream =
 			DC_STREAM_TO_CORE(core_target->public.streams[0]);
 
 	for (i = 0; i < MAX_PIPES; i++)
-		if (dc->current_context.res_ctx.pipe_ctx[i].stream == stream)
+		if (core_dc->current_context.res_ctx.pipe_ctx[i].stream == stream)
 			return irq_type + i;
 
 	return irq_type;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 41010f7..5660790 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -45,7 +45,9 @@ struct dc_caps {
     uint32_t max_audios;
 };
 
-void dc_get_caps(const struct core_dc *dc, struct dc_caps *caps);
+struct dc {
+	struct dc_caps caps;
+};
 
 struct dc_init_data {
 	struct hw_asic_id asic_id;
@@ -62,8 +64,8 @@ struct dc_init_data {
 	enum dce_environment dce_environment;
 };
 
-struct core_dc *dc_create(const struct dc_init_data *init_params);
-void dc_destroy(struct core_dc **dc);
+struct dc *dc_create(const struct dc_init_data *init_params);
+void dc_destroy(struct dc **dc);
 
 /*******************************************************************************
  * Surface Interfaces
@@ -140,7 +142,7 @@ struct dc_surface_status {
 /*
  * Create a new surface with default parameters;
  */
-struct dc_surface *dc_create_surface(const struct core_dc *dc);
+struct dc_surface *dc_create_surface(const struct dc *dc);
 const struct dc_surface_status* dc_surface_get_status(
 						struct dc_surface *dc_surface);
 
@@ -148,7 +150,7 @@ void dc_surface_retain(const struct dc_surface *dc_surface);
 void dc_surface_release(const struct dc_surface *dc_surface);
 
 void dc_gamma_release(const struct dc_gamma *dc_gamma);
-struct dc_gamma *dc_create_gamma(const struct core_dc *dc);
+struct dc_gamma *dc_create_gamma(const struct dc *dc);
 
 /*
  * This structure holds a surface address.  There could be multiple addresses
@@ -169,7 +171,7 @@ struct dc_flip_addrs {
  *   Surface addresses and flip attributes are programmed.
  *   Surface flip occur at next configured time (h_sync or v_sync flip)
  */
-void dc_flip_surface_addrs(struct core_dc *dc,
+void dc_flip_surface_addrs(struct dc *dc,
 		const struct dc_surface *const surfaces[],
 		struct dc_flip_addrs flip_addrs[],
 		uint32_t count);
@@ -185,7 +187,7 @@ void dc_flip_surface_addrs(struct core_dc *dc,
  *   This does not trigger a flip.  No surface address is programmed.
  */
 bool dc_commit_surfaces_to_target(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct dc_surface *dc_surfaces[],
 		uint8_t surface_count,
 		struct dc_target *dc_target);
@@ -230,8 +232,8 @@ void dc_target_log(
 	enum log_major log_major,
 	enum log_minor log_minor);
 
-uint8_t dc_get_current_target_count(const struct core_dc *dc);
-struct dc_target *dc_get_target_at_index(const struct core_dc *dc, uint8_t i);
+uint8_t dc_get_current_target_count(const struct dc *dc);
+struct dc_target *dc_get_target_at_index(const struct dc *dc, uint8_t i);
 
 bool dc_target_is_connected_to_sink(
 		const struct dc_target *dc_target,
@@ -241,7 +243,7 @@ uint8_t dc_target_get_controller_id(const struct dc_target *dc_target);
 
 uint32_t dc_target_get_vblank_counter(const struct dc_target *dc_target);
 enum dc_irq_source dc_target_get_irq_src(
-	const struct core_dc *dc,
+	const struct dc *dc,
 	const struct dc_target *dc_target,
 	const enum irq_type irq_type);
 
@@ -261,7 +263,7 @@ struct dc_validation_set {
  *   No hardware is programmed for call.  Only validation is done.
  */
 bool dc_validate_resources(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		const struct dc_validation_set set[],
 		uint8_t set_count);
 
@@ -274,7 +276,7 @@ bool dc_validate_resources(
  *   New targets are enabled with blank stream; no memory read.
  */
 bool dc_commit_targets(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct dc_target *targets[],
 		uint8_t target_count);
 
@@ -355,11 +357,11 @@ struct dc_link {
  * boot time.  They cannot be created or destroyed.
  * Use dc_get_caps() to get number of links.
  */
-const struct dc_link *dc_get_link_at_index(struct core_dc *dc, uint32_t link_index);
+const struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index);
 
 /* Return id of physical connector represented by a dc_link at link_index.*/
 const struct graphics_object_id dc_get_link_id_at_index(
-		struct core_dc *dc, uint32_t link_index);
+		struct dc *dc, uint32_t link_index);
 
 /* Set backlight level of an embedded panel (eDP, LVDS). */
 bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level);
@@ -405,7 +407,7 @@ struct dc_sink {
 void dc_sink_retain(const struct dc_sink *sink);
 void dc_sink_release(const struct dc_sink *sink);
 
-const struct audio **dc_get_audios(struct core_dc *dc);
+const struct audio **dc_get_audios(struct dc *dc);
 
 struct dc_sink_init_data {
 	enum signal_type sink_signal;
@@ -438,7 +440,7 @@ struct dc_cursor {
  * Create a new cursor with default values for a given target.
  */
 struct dc_cursor *dc_create_cursor_for_target(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		struct dc_target *dc_target);
 
 /**
@@ -450,7 +452,7 @@ struct dc_cursor *dc_create_cursor_for_target(
  *   Cursor position is unmodified.
  */
 bool dc_commit_cursor(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		struct dc_cursor *cursor);
 
 /*
@@ -460,7 +462,7 @@ bool dc_commit_cursor(
  *   Cursor position will be programmed as well as enable/disable bit.
  */
 bool dc_set_cursor_position(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		struct dc_cursor *cursor,
 		struct dc_cursor_position *pos);
 
@@ -468,15 +470,15 @@ bool dc_set_cursor_position(
  * Interrupt interfaces
  ******************************************************************************/
 enum dc_irq_source dc_interrupt_to_irq_source(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t src_id,
 		uint32_t ext_id);
-void dc_interrupt_set(const struct core_dc *dc, enum dc_irq_source src, bool enable);
-void dc_interrupt_ack(struct core_dc *dc, enum dc_irq_source src);
+void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable);
+void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src);
 const enum dc_irq_source dc_get_hpd_irq_source_at_index(
-		struct core_dc *dc, uint32_t link_index);
+		struct dc *dc, uint32_t link_index);
 const struct dc_target *dc_get_target_on_irq_source(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		enum dc_irq_source src);
 
 /*******************************************************************************
@@ -484,38 +486,38 @@ const struct dc_target *dc_get_target_on_irq_source(
  ******************************************************************************/
 
 void dc_set_power_state(
-		struct core_dc *dc,
+		struct dc *dc,
 		enum dc_acpi_cm_power_state power_state,
 		enum dc_video_power_state video_power_state);
-void dc_resume(const struct core_dc *dc);
+void dc_resume(const struct dc *dc);
 
 /*******************************************************************************
  * DDC Interfaces
  ******************************************************************************/
 
 const struct ddc_service *dc_get_ddc_at_index(
-		struct core_dc *dc, uint32_t link_index);
+		struct dc *dc, uint32_t link_index);
 
 /*
  * DPCD access interfaces
  */
 
 bool dc_read_dpcd(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t link_index,
 		uint32_t address,
 		uint8_t *data,
 		uint32_t size);
 
 bool dc_write_dpcd(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t link_index,
 		uint32_t address,
 		const uint8_t *data,
 	uint32_t size);
 
 bool dc_submit_i2c(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t link_index,
 		struct i2c_command *cmd);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_types.h b/drivers/gpu/drm/amd/dal/dc/dc_types.h
index 0fb4822..e849972 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_types.h
@@ -33,7 +33,6 @@
 #include "signal_types.h"
 
 /* forward declarations */
-struct core_dc;
 struct dc_surface;
 struct dc_target;
 struct dc_stream;
@@ -69,7 +68,7 @@ enum dce_environment {
 /********************************/
 
 struct dc_context {
-	struct core_dc *dc;
+	struct dc *dc;
 
 #if defined(BUILD_DAL_TEST)
 	struct test_driver_context *driver_context;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
index 6d20575..21860e4 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
@@ -11,7 +11,11 @@
 #include "core_types.h"
 #include "hw_sequencer.h"
 
+#define DC_TO_CORE(dc)\
+	container_of(dc, struct core_dc, public)
+
 struct core_dc {
+	struct dc public;
 	struct dc_context *ctx;
 
 	uint8_t link_count;
-- 
2.7.4

