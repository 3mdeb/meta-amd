From f96a94fdd254d3b489fa7a3add3b643fbccc6d93 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Wed, 12 Oct 2016 16:51:05 -0400
Subject: [PATCH 1315/1722] drm/amd/dal: Stop using adapter service
 obtain/release for HPD

Change-Id: I7f730472f4acc99fafb3123b98d0ebb411025186
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c   | 57 ---------------------
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          | 58 ++++++++++++++--------
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    | 38 ++++++++++++--
 .../amd/dal/include/adapter_service_interface.h    | 10 ----
 4 files changed, 73 insertions(+), 90 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index 34049d3..ca75705 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -533,20 +533,6 @@ static bool get_bool_value(
 }
 
 /*
- * get_hpd_info
- *
- * Get HPD information from BIOS
- */
-static bool get_hpd_info(struct adapter_service *as,
-	struct graphics_object_id id,
-	struct graphics_object_hpd_info *info)
-{
-	struct dc_bios *dcb = as->ctx->dc_bios;
-
-	return BP_RESULT_OK == dcb->funcs->get_hpd_info(dcb, id, info);
-}
-
-/*
  * lookup_feature_entry
  *
  * Find the entry index of a given feature in feature table
@@ -1053,49 +1039,6 @@ bool dal_adapter_service_is_feature_supported(struct adapter_service *as,
 }
 
 /*
- * dal_adapter_service_obtain_hpd_irq
- *
- * Obtain HPD interrupt request
- */
-struct irq *dal_adapter_service_obtain_hpd_irq(
-	struct adapter_service *as,
-	struct graphics_object_id id)
-{
-	enum bp_result bp_result;
-	struct dc_bios *dcb = as->ctx->dc_bios;
-	struct graphics_object_hpd_info hpd_info;
-	struct gpio_pin_info pin_info;
-
-	if (!get_hpd_info(as, id, &hpd_info))
-		return NULL;
-
-	bp_result = dcb->funcs->get_gpio_pin_info(dcb,
-		hpd_info.hpd_int_gpio_uid, &pin_info);
-
-	if (bp_result != BP_RESULT_OK) {
-		ASSERT(bp_result == BP_RESULT_NORECORD);
-		return NULL;
-	}
-
-	return dal_gpio_service_create_irq(
-		as->gpio_service,
-		pin_info.offset,
-		pin_info.mask);
-}
-
-/*
- * dal_adapter_service_release_irq
- *
- * Release interrupt request
- */
-void dal_adapter_service_release_irq(
-	struct adapter_service *as,
-	struct irq *irq)
-{
-	dal_gpio_service_destroy_irq(&irq);
-}
-
-/*
  * dal_adapter_service_get_ss_info_num
  *
  * Get number of spread spectrum entries from BIOS
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 54475f9..3c53767 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -41,6 +41,10 @@
 #include "adapter/adapter_service.h"
 #include "include/asic_capability_interface.h"
 
+
+/* TODO remove - only needed for gpio_service */
+#include "adapter/adapter_service.h"
+
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_enum.h"
 #include "dce/dce_11_0_sh_mask.h"
@@ -87,6 +91,31 @@ static void destruct(struct core_link *link)
 		dc_sink_release(link->public.remote_sinks[i]);
 }
 
+static struct irq *get_hpd_gpio(
+		const struct core_link *link)
+{
+	enum bp_result bp_result;
+	struct dc_bios *dcb = link->ctx->dc_bios;
+	struct graphics_object_hpd_info hpd_info;
+	struct gpio_pin_info pin_info;
+
+	if (!dcb->funcs->get_hpd_info(dcb, link->link_id, &hpd_info))
+		return NULL;
+
+	bp_result = dcb->funcs->get_gpio_pin_info(dcb,
+		hpd_info.hpd_int_gpio_uid, &pin_info);
+
+	if (bp_result != BP_RESULT_OK) {
+		ASSERT(bp_result == BP_RESULT_NORECORD);
+		return NULL;
+	}
+
+	return dal_gpio_service_create_irq(
+		link->adapter_srv->gpio_service,
+		pin_info.offset,
+		pin_info.mask);
+}
+
 /*
  *  Function: program_hpd_filter
  *
@@ -138,8 +167,7 @@ static bool program_hpd_filter(
 	}
 
 	/* Obtain HPD handle */
-	hpd = dal_adapter_service_obtain_hpd_irq(
-		link->adapter_srv, link->link_id);
+	hpd = get_hpd_gpio(link);
 
 	if (!hpd)
 		return result;
@@ -161,7 +189,7 @@ static bool program_hpd_filter(
 	}
 
 	/* Release HPD handle */
-	dal_adapter_service_release_irq(link->adapter_srv, hpd);
+	dal_gpio_service_destroy_irq(&hpd);
 
 	return result;
 }
@@ -172,18 +200,14 @@ static bool detect_sink(struct core_link *link, enum dc_connection_type *type)
 	struct irq *hpd_pin;
 
 	/* todo: may need to lock gpio access */
-	hpd_pin = dal_adapter_service_obtain_hpd_irq(
-			link->adapter_srv,
-			link->link_id);
+	hpd_pin = get_hpd_gpio(link);
 	if (hpd_pin == NULL)
 		goto hpd_gpio_failure;
 
 	dal_irq_open(hpd_pin);
 	dal_irq_get_value(hpd_pin, &is_hpd_high);
 	dal_irq_close(hpd_pin);
-	dal_adapter_service_release_irq(
-		link->adapter_srv,
-		hpd_pin);
+	dal_gpio_service_destroy_irq(&hpd_pin);
 
 	if (is_hpd_high) {
 		*type = dc_connection_single;
@@ -436,9 +460,6 @@ static enum signal_type dp_passive_dongle_detection(
 		struct display_sink_capability *sink_cap,
 		union audio_support *audio_support)
 {
-	/* TODO:These 2 functions should be protected for upstreaming purposes
-	 * in case hackers want to save 10 cents hdmi license fee
-	 */
 	dal_ddc_service_i2c_query_dp_dual_mode_adaptor(
 						ddc, sink_cap);
 	return decide_signal_from_strap_and_dongle_type(
@@ -787,7 +808,7 @@ static enum hpd_source_id get_hpd_line(
 	struct irq *hpd;
 	enum hpd_source_id hpd_id = HPD_SOURCEID_UNKNOWN;
 
-	hpd = dal_adapter_service_obtain_hpd_irq(as, link->link_id);
+	hpd = get_hpd_gpio(link);
 
 	if (hpd) {
 		switch (dal_irq_get_source(hpd)) {
@@ -814,7 +835,7 @@ static enum hpd_source_id get_hpd_line(
 		break;
 		}
 
-		dal_adapter_service_release_irq(as, hpd);
+		dal_gpio_service_destroy_irq(&hpd);
 	}
 
 	return hpd_id;
@@ -958,7 +979,7 @@ static bool construct(
 		goto create_fail;
 	}
 
-	hpd_gpio = dal_adapter_service_obtain_hpd_irq(as, link->link_id);
+	hpd_gpio = get_hpd_gpio(link);
 
 	if (hpd_gpio != NULL)
 		link->public.irq_source_hpd = dal_irq_get_source(hpd_gpio);
@@ -1001,9 +1022,7 @@ static bool construct(
 	}
 
 	if (hpd_gpio != NULL) {
-		dal_adapter_service_release_irq(
-			as, hpd_gpio);
-
+		dal_gpio_service_destroy_irq(&hpd_gpio);
 		hpd_gpio = NULL;
 	}
 
@@ -1105,8 +1124,7 @@ ddc_create_fail:
 create_fail:
 
 	if (hpd_gpio != NULL) {
-		dal_adapter_service_release_irq(
-			as, hpd_gpio);
+		dal_gpio_service_destroy_irq(&hpd_gpio);
 	}
 
 	return false;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index d0db398..1500dfc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -32,6 +32,11 @@
 #include "i2caux_interface.h"
 #include "dc_bios_types.h"
 
+#include "gpio_service_interface.h"
+
+/* TODO remove - only needed for gpio_service */
+#include "adapter/adapter_service.h"
+
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 #include "dce/dce_11_0_enum.h"
@@ -542,6 +547,33 @@ static bool is_panel_powered_on(struct dce110_link_encoder *enc110)
 	return ret == 1;
 }
 
+
+/* TODO duplicate of dc_link.c version */
+static struct irq *get_hpd_gpio(
+		const struct link_encoder *enc)
+{
+	enum bp_result bp_result;
+	struct dc_bios *dcb = enc->ctx->dc_bios;
+	struct graphics_object_hpd_info hpd_info;
+	struct gpio_pin_info pin_info;
+
+	if (!dcb->funcs->get_hpd_info(dcb, enc->connector, &hpd_info))
+		return NULL;
+
+	bp_result = dcb->funcs->get_gpio_pin_info(dcb,
+		hpd_info.hpd_int_gpio_uid, &pin_info);
+
+	if (bp_result != BP_RESULT_OK) {
+		ASSERT(bp_result == BP_RESULT_NORECORD);
+		return NULL;
+	}
+
+	return dal_gpio_service_create_irq(
+		enc->adapter_service->gpio_service,
+		pin_info.offset,
+		pin_info.mask);
+}
+
 /*
  * @brief
  * eDP only.
@@ -575,8 +607,8 @@ static void link_encoder_edp_wait_for_hpd_ready(
 	 * we need to wait until SENSE bit is high/low */
 
 	/* obtain HPD */
-
-	hpd = dal_adapter_service_obtain_hpd_irq(as, connector);
+	/* TODO what to do with this? */
+	hpd = get_hpd_gpio(&enc110->base);
 
 	if (!hpd) {
 		BREAK_TO_DEBUGGER();
@@ -604,7 +636,7 @@ static void link_encoder_edp_wait_for_hpd_ready(
 
 	dal_irq_close(hpd);
 
-	dal_adapter_service_release_irq(as, hpd);
+	dal_gpio_service_destroy_irq(&hpd);
 
 	if (false == edp_hpd_high) {
 		dal_logger_write(ctx->logger,
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
index adb1570..1f0802f 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
@@ -385,16 +385,6 @@ bool dal_adapter_service_get_feature_value(struct adapter_service *as,
 	void *data,
 	uint32_t size);
 
-/* Obtain HPD interrupt request */
-struct irq *dal_adapter_service_obtain_hpd_irq(
-	struct adapter_service *as,
-	struct graphics_object_id id);
-
-/* Release interrupt request */
-void dal_adapter_service_release_irq(
-	struct adapter_service *as,
-	struct irq *irq);
-
 /* Get SW I2C speed */
 uint32_t dal_adapter_service_get_sw_i2c_speed(struct adapter_service *as);
 
-- 
2.7.4

