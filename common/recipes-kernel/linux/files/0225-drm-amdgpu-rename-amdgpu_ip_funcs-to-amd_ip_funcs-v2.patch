From 5fc3aeeb9e553a20ce62544f7176c6c4aca52d71 Mon Sep 17 00:00:00 2001
From: yanyang1 <young.yang@amd.com>
Date: Fri, 22 May 2015 14:39:35 -0400
Subject: [PATCH 0225/1050] drm/amdgpu: rename amdgpu_ip_funcs to amd_ip_funcs
 (v2)

The structure is renamed and moved to amd_shared.h to make
the component independent.  This makes it easier to add
new components in the future.

v2: fix include path

Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
Signed-off-by: yanyang1 <young.yang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/Makefile        |   3 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h        |  75 ++---------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c |  50 +++++------
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c    |  24 +++---
 drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c    |   2 +-
 drivers/gpu/drm/amd/amdgpu/ci_dpm.c        |  57 ++++++++-----
 drivers/gpu/drm/amd/amdgpu/cik.c           | 130 +++++++++++++++--------------
 drivers/gpu/drm/amd/amdgpu/cik.h           |   2 +-
 drivers/gpu/drm/amd/amdgpu/cik_dpm.h       |   4 +-
 drivers/gpu/drm/amd/amdgpu/cik_ih.c        |  54 ++++++++----
 drivers/gpu/drm/amd/amdgpu/cik_ih.h        |   2 +-
 drivers/gpu/drm/amd/amdgpu/cik_sdma.c      |  53 +++++++-----
 drivers/gpu/drm/amd/amdgpu/cik_sdma.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/cz_dpm.c        |  53 +++++++-----
 drivers/gpu/drm/amd/amdgpu/cz_ih.c         |  53 ++++++++----
 drivers/gpu/drm/amd/amdgpu/cz_ih.h         |   2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v10_0.c     |  50 ++++++-----
 drivers/gpu/drm/amd/amdgpu/dce_v10_0.h     |   2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v11_0.c     |  50 ++++++-----
 drivers/gpu/drm/amd/amdgpu/dce_v11_0.h     |   2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c      |  50 ++++++-----
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c      |  57 ++++++++-----
 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c      |  51 +++++++----
 drivers/gpu/drm/amd/amdgpu/gfx_v8_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c      |  52 +++++++-----
 drivers/gpu/drm/amd/amdgpu/gmc_v7_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c      |  51 ++++++-----
 drivers/gpu/drm/amd/amdgpu/gmc_v8_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/iceland_dpm.c   |  34 +++++---
 drivers/gpu/drm/amd/amdgpu/iceland_ih.c    |  55 +++++++-----
 drivers/gpu/drm/amd/amdgpu/iceland_ih.h    |   2 +-
 drivers/gpu/drm/amd/amdgpu/kv_dpm.c        |  89 +++++++++++---------
 drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c     |  51 ++++++-----
 drivers/gpu/drm/amd/amdgpu/sdma_v2_4.h     |   2 +-
 drivers/gpu/drm/amd/amdgpu/sdma_v3_0.c     |  52 +++++++-----
 drivers/gpu/drm/amd/amdgpu/sdma_v3_0.h     |   2 +-
 drivers/gpu/drm/amd/amdgpu/tonga_dpm.c     |  35 +++++---
 drivers/gpu/drm/amd/amdgpu/tonga_ih.c      |  51 +++++++----
 drivers/gpu/drm/amd/amdgpu/tonga_ih.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c      |  53 ++++++++----
 drivers/gpu/drm/amd/amdgpu/uvd_v4_2.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c      |  52 +++++++-----
 drivers/gpu/drm/amd/amdgpu/uvd_v5_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c      |  52 +++++++-----
 drivers/gpu/drm/amd/amdgpu/uvd_v6_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/vce_v2_0.c      |  54 +++++++-----
 drivers/gpu/drm/amd/amdgpu/vce_v2_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/vce_v3_0.c      |  52 +++++++-----
 drivers/gpu/drm/amd/amdgpu/vce_v3_0.h      |   2 +-
 drivers/gpu/drm/amd/amdgpu/vi.c            |  96 +++++++++++----------
 drivers/gpu/drm/amd/amdgpu/vi.h            |   2 +-
 drivers/gpu/drm/amd/amdgpu/vi_dpm.h        |   6 +-
 drivers/gpu/drm/amd/include/amd_shared.h   |  81 ++++++++++++++++++
 55 files changed, 1067 insertions(+), 707 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/include/amd_shared.h

diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index 9a573e8..616dfd4 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -2,7 +2,8 @@
 # Makefile for the drm device driver.  This driver provides support for the
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 
-ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/amd/include/asic_reg
+ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/amd/include/asic_reg \
+	-Idrivers/gpu/drm/amd/include
 
 amdgpu-y := amdgpu_drv.o
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 411cfb9..80f0bea 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -44,6 +44,7 @@
 
 #include <drm/drm_gem.h>
 
+#include "amd_shared.h"
 #include "amdgpu_family.h"
 #include "amdgpu_mode.h"
 #include "amdgpu_ih.h"
@@ -205,86 +206,28 @@ enum amdgpu_thermal_irq {
 	AMDGPU_THERMAL_IRQ_LAST
 };
 
-/*
- * IP block functions
- */
-enum amdgpu_ip_block_type {
-	AMDGPU_IP_BLOCK_TYPE_COMMON,
-	AMDGPU_IP_BLOCK_TYPE_GMC,
-	AMDGPU_IP_BLOCK_TYPE_IH,
-	AMDGPU_IP_BLOCK_TYPE_SMC,
-	AMDGPU_IP_BLOCK_TYPE_DCE,
-	AMDGPU_IP_BLOCK_TYPE_GFX,
-	AMDGPU_IP_BLOCK_TYPE_SDMA,
-	AMDGPU_IP_BLOCK_TYPE_UVD,
-	AMDGPU_IP_BLOCK_TYPE_VCE,
-};
-
-enum amdgpu_clockgating_state {
-	AMDGPU_CG_STATE_GATE = 0,
-	AMDGPU_CG_STATE_UNGATE,
-};
-
-enum amdgpu_powergating_state {
-	AMDGPU_PG_STATE_GATE = 0,
-	AMDGPU_PG_STATE_UNGATE,
-};
-
-struct amdgpu_ip_funcs {
-	/* sets up early driver state (pre sw_init), does not configure hw - Optional */
-	int (*early_init)(struct amdgpu_device *adev);
-	/* sets up late driver/hw state (post hw_init) - Optional */
-	int (*late_init)(struct amdgpu_device *adev);
-	/* sets up driver state, does not configure hw */
-	int (*sw_init)(struct amdgpu_device *adev);
-	/* tears down driver state, does not configure hw */
-	int (*sw_fini)(struct amdgpu_device *adev);
-	/* sets up the hw state */
-	int (*hw_init)(struct amdgpu_device *adev);
-	/* tears down the hw state */
-	int (*hw_fini)(struct amdgpu_device *adev);
-	/* handles IP specific hw/sw changes for suspend */
-	int (*suspend)(struct amdgpu_device *adev);
-	/* handles IP specific hw/sw changes for resume */
-	int (*resume)(struct amdgpu_device *adev);
-	/* returns current IP block idle status */
-	bool (*is_idle)(struct amdgpu_device *adev);
-	/* poll for idle */
-	int (*wait_for_idle)(struct amdgpu_device *adev);
-	/* soft reset the IP block */
-	int (*soft_reset)(struct amdgpu_device *adev);
-	/* dump the IP block status registers */
-	void (*print_status)(struct amdgpu_device *adev);
-	/* enable/disable cg for the IP block */
-	int (*set_clockgating_state)(struct amdgpu_device *adev,
-				     enum amdgpu_clockgating_state state);
-	/* enable/disable pg for the IP block */
-	int (*set_powergating_state)(struct amdgpu_device *adev,
-				     enum amdgpu_powergating_state state);
-};
-
 int amdgpu_set_clockgating_state(struct amdgpu_device *adev,
-				  enum amdgpu_ip_block_type block_type,
-				  enum amdgpu_clockgating_state state);
+				  enum amd_ip_block_type block_type,
+				  enum amd_clockgating_state state);
 int amdgpu_set_powergating_state(struct amdgpu_device *adev,
-				  enum amdgpu_ip_block_type block_type,
-				  enum amdgpu_powergating_state state);
+				  enum amd_ip_block_type block_type,
+				  enum amd_powergating_state state);
 
 struct amdgpu_ip_block_version {
-	enum amdgpu_ip_block_type type;
+	enum amd_ip_block_type type;
 	u32 major;
 	u32 minor;
 	u32 rev;
-	const struct amdgpu_ip_funcs *funcs;
+	const struct amd_ip_funcs *funcs;
 };
 
 int amdgpu_ip_block_version_cmp(struct amdgpu_device *adev,
-				enum amdgpu_ip_block_type type,
+				enum amd_ip_block_type type,
 				u32 major, u32 minor);
 
 const struct amdgpu_ip_block_version * amdgpu_get_ip_block(
 					struct amdgpu_device *adev,
-					enum amdgpu_ip_block_type type);
+					enum amd_ip_block_type type);
 
 /* provided by hw blocks that can move/clear data.  e.g., gfx or sdma */
 struct amdgpu_buffer_funcs {
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 3448d9f..d9d26f2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -1081,14 +1081,14 @@ static const struct vga_switcheroo_client_ops amdgpu_switcheroo_ops = {
 };
 
 int amdgpu_set_clockgating_state(struct amdgpu_device *adev,
-				  enum amdgpu_ip_block_type block_type,
-				  enum amdgpu_clockgating_state state)
+				  enum amd_ip_block_type block_type,
+				  enum amd_clockgating_state state)
 {
 	int i, r = 0;
 
 	for (i = 0; i < adev->num_ip_blocks; i++) {
 		if (adev->ip_blocks[i].type == block_type) {
-			r = adev->ip_blocks[i].funcs->set_clockgating_state(adev,
+			r = adev->ip_blocks[i].funcs->set_clockgating_state((void *)adev,
 									    state);
 			if (r)
 				return r;
@@ -1098,14 +1098,14 @@ int amdgpu_set_clockgating_state(struct amdgpu_device *adev,
 }
 
 int amdgpu_set_powergating_state(struct amdgpu_device *adev,
-				  enum amdgpu_ip_block_type block_type,
-				  enum amdgpu_powergating_state state)
+				  enum amd_ip_block_type block_type,
+				  enum amd_powergating_state state)
 {
 	int i, r = 0;
 
 	for (i = 0; i < adev->num_ip_blocks; i++) {
 		if (adev->ip_blocks[i].type == block_type) {
-			r = adev->ip_blocks[i].funcs->set_powergating_state(adev,
+			r = adev->ip_blocks[i].funcs->set_powergating_state((void *)adev,
 									    state);
 			if (r)
 				return r;
@@ -1116,7 +1116,7 @@ int amdgpu_set_powergating_state(struct amdgpu_device *adev,
 
 const struct amdgpu_ip_block_version * amdgpu_get_ip_block(
 					struct amdgpu_device *adev,
-					enum amdgpu_ip_block_type type)
+					enum amd_ip_block_type type)
 {
 	int i;
 
@@ -1131,7 +1131,7 @@ const struct amdgpu_ip_block_version * amdgpu_get_ip_block(
  * amdgpu_ip_block_version_cmp
  *
  * @adev: amdgpu_device pointer
- * @type: enum amdgpu_ip_block_type
+ * @type: enum amd_ip_block_type
  * @major: major version
  * @minor: minor version
  *
@@ -1139,7 +1139,7 @@ const struct amdgpu_ip_block_version * amdgpu_get_ip_block(
  * return 1 if smaller or the ip_block doesn't exist
  */
 int amdgpu_ip_block_version_cmp(struct amdgpu_device *adev,
-				enum amdgpu_ip_block_type type,
+				enum amd_ip_block_type type,
 				u32 major, u32 minor)
 {
 	const struct amdgpu_ip_block_version *ip_block;
@@ -1204,7 +1204,7 @@ static int amdgpu_early_init(struct amdgpu_device *adev)
 			adev->ip_block_enabled[i] = false;
 		} else {
 			if (adev->ip_blocks[i].funcs->early_init) {
-				r = adev->ip_blocks[i].funcs->early_init(adev);
+				r = adev->ip_blocks[i].funcs->early_init((void *)adev);
 				if (r)
 					return r;
 			}
@@ -1222,15 +1222,15 @@ static int amdgpu_init(struct amdgpu_device *adev)
 	for (i = 0; i < adev->num_ip_blocks; i++) {
 		if (!adev->ip_block_enabled[i])
 			continue;
-		r = adev->ip_blocks[i].funcs->sw_init(adev);
+		r = adev->ip_blocks[i].funcs->sw_init((void *)adev);
 		if (r)
 			return r;
 		/* need to do gmc hw init early so we can allocate gpu mem */
-		if (adev->ip_blocks[i].type == AMDGPU_IP_BLOCK_TYPE_GMC) {
+		if (adev->ip_blocks[i].type == AMD_IP_BLOCK_TYPE_GMC) {
 			r = amdgpu_vram_scratch_init(adev);
 			if (r)
 				return r;
-			r = adev->ip_blocks[i].funcs->hw_init(adev);
+			r = adev->ip_blocks[i].funcs->hw_init((void *)adev);
 			if (r)
 				return r;
 			r = amdgpu_wb_init(adev);
@@ -1243,9 +1243,9 @@ static int amdgpu_init(struct amdgpu_device *adev)
 		if (!adev->ip_block_enabled[i])
 			continue;
 		/* gmc hw init is done early */
-		if (adev->ip_blocks[i].type == AMDGPU_IP_BLOCK_TYPE_GMC)
+		if (adev->ip_blocks[i].type == AMD_IP_BLOCK_TYPE_GMC)
 			continue;
-		r = adev->ip_blocks[i].funcs->hw_init(adev);
+		r = adev->ip_blocks[i].funcs->hw_init((void *)adev);
 		if (r)
 			return r;
 	}
@@ -1261,12 +1261,12 @@ static int amdgpu_late_init(struct amdgpu_device *adev)
 		if (!adev->ip_block_enabled[i])
 			continue;
 		/* enable clockgating to save power */
-		r = adev->ip_blocks[i].funcs->set_clockgating_state(adev,
-								    AMDGPU_CG_STATE_GATE);
+		r = adev->ip_blocks[i].funcs->set_clockgating_state((void *)adev,
+								    AMD_CG_STATE_GATE);
 		if (r)
 			return r;
 		if (adev->ip_blocks[i].funcs->late_init) {
-			r = adev->ip_blocks[i].funcs->late_init(adev);
+			r = adev->ip_blocks[i].funcs->late_init((void *)adev);
 			if (r)
 				return r;
 		}
@@ -1282,23 +1282,23 @@ static int amdgpu_fini(struct amdgpu_device *adev)
 	for (i = adev->num_ip_blocks - 1; i >= 0; i--) {
 		if (!adev->ip_block_enabled[i])
 			continue;
-		if (adev->ip_blocks[i].type == AMDGPU_IP_BLOCK_TYPE_GMC) {
+		if (adev->ip_blocks[i].type == AMD_IP_BLOCK_TYPE_GMC) {
 			amdgpu_wb_fini(adev);
 			amdgpu_vram_scratch_fini(adev);
 		}
 		/* ungate blocks before hw fini so that we can shutdown the blocks safely */
-		r = adev->ip_blocks[i].funcs->set_clockgating_state(adev,
-								    AMDGPU_CG_STATE_UNGATE);
+		r = adev->ip_blocks[i].funcs->set_clockgating_state((void *)adev,
+								    AMD_CG_STATE_UNGATE);
 		if (r)
 			return r;
-		r = adev->ip_blocks[i].funcs->hw_fini(adev);
+		r = adev->ip_blocks[i].funcs->hw_fini((void *)adev);
 		/* XXX handle errors */
 	}
 
 	for (i = adev->num_ip_blocks - 1; i >= 0; i--) {
 		if (!adev->ip_block_enabled[i])
 			continue;
-		r = adev->ip_blocks[i].funcs->sw_fini(adev);
+		r = adev->ip_blocks[i].funcs->sw_fini((void *)adev);
 		/* XXX handle errors */
 		adev->ip_block_enabled[i] = false;
 	}
@@ -1314,8 +1314,8 @@ static int amdgpu_suspend(struct amdgpu_device *adev)
 		if (!adev->ip_block_enabled[i])
 			continue;
 		/* ungate blocks so that suspend can properly shut them down */
-		r = adev->ip_blocks[i].funcs->set_clockgating_state(adev,
-								    AMDGPU_CG_STATE_UNGATE);
+		r = adev->ip_blocks[i].funcs->set_clockgating_state((void *)adev,
+								    AMD_CG_STATE_UNGATE);
 		/* XXX handle errors */
 		r = adev->ip_blocks[i].funcs->suspend(adev);
 		/* XXX handle errors */
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
index 35185d6..b6dd375 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
@@ -186,7 +186,7 @@ static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file
 		return copy_to_user(out, &ui32, min(size, 4u)) ? -EFAULT : 0;
 	case AMDGPU_INFO_HW_IP_INFO: {
 		struct drm_amdgpu_info_hw_ip ip = {};
-		enum amdgpu_ip_block_type type;
+		enum amd_ip_block_type type;
 		uint32_t ring_mask = 0;
 
 		if (info->query_hw_ip.ip_instance >= AMDGPU_HW_IP_INSTANCE_MAX_COUNT)
@@ -194,26 +194,26 @@ static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file
 
 		switch (info->query_hw_ip.type) {
 		case AMDGPU_HW_IP_GFX:
-			type = AMDGPU_IP_BLOCK_TYPE_GFX;
+			type = AMD_IP_BLOCK_TYPE_GFX;
 			for (i = 0; i < adev->gfx.num_gfx_rings; i++)
 				ring_mask |= ((adev->gfx.gfx_ring[i].ready ? 1 : 0) << i);
 			break;
 		case AMDGPU_HW_IP_COMPUTE:
-			type = AMDGPU_IP_BLOCK_TYPE_GFX;
+			type = AMD_IP_BLOCK_TYPE_GFX;
 			for (i = 0; i < adev->gfx.num_compute_rings; i++)
 				ring_mask |= ((adev->gfx.compute_ring[i].ready ? 1 : 0) << i);
 			break;
 		case AMDGPU_HW_IP_DMA:
-			type = AMDGPU_IP_BLOCK_TYPE_SDMA;
+			type = AMD_IP_BLOCK_TYPE_SDMA;
 			ring_mask = adev->sdma[0].ring.ready ? 1 : 0;
 			ring_mask |= ((adev->sdma[1].ring.ready ? 1 : 0) << 1);
 			break;
 		case AMDGPU_HW_IP_UVD:
-			type = AMDGPU_IP_BLOCK_TYPE_UVD;
+			type = AMD_IP_BLOCK_TYPE_UVD;
 			ring_mask = adev->uvd.ring.ready ? 1 : 0;
 			break;
 		case AMDGPU_HW_IP_VCE:
-			type = AMDGPU_IP_BLOCK_TYPE_VCE;
+			type = AMD_IP_BLOCK_TYPE_VCE;
 			for (i = 0; i < AMDGPU_MAX_VCE_RINGS; i++)
 				ring_mask |= ((adev->vce.ring[i].ready ? 1 : 0) << i);
 			break;
@@ -235,24 +235,24 @@ static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file
 				    min((size_t)size, sizeof(ip))) ? -EFAULT : 0;
 	}
 	case AMDGPU_INFO_HW_IP_COUNT: {
-		enum amdgpu_ip_block_type type;
+		enum amd_ip_block_type type;
 		uint32_t count = 0;
 
 		switch (info->query_hw_ip.type) {
 		case AMDGPU_HW_IP_GFX:
-			type = AMDGPU_IP_BLOCK_TYPE_GFX;
+			type = AMD_IP_BLOCK_TYPE_GFX;
 			break;
 		case AMDGPU_HW_IP_COMPUTE:
-			type = AMDGPU_IP_BLOCK_TYPE_GFX;
+			type = AMD_IP_BLOCK_TYPE_GFX;
 			break;
 		case AMDGPU_HW_IP_DMA:
-			type = AMDGPU_IP_BLOCK_TYPE_SDMA;
+			type = AMD_IP_BLOCK_TYPE_SDMA;
 			break;
 		case AMDGPU_HW_IP_UVD:
-			type = AMDGPU_IP_BLOCK_TYPE_UVD;
+			type = AMD_IP_BLOCK_TYPE_UVD;
 			break;
 		case AMDGPU_HW_IP_VCE:
-			type = AMDGPU_IP_BLOCK_TYPE_VCE;
+			type = AMD_IP_BLOCK_TYPE_VCE;
 			break;
 		default:
 			return -EINVAL;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c
index 4b0be90..375759c 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c
@@ -185,7 +185,7 @@ int amdgpu_uvd_sw_init(struct amdgpu_device *adev)
 	}
 
 	/* from uvd v5.0 HW addressing capacity increased to 64 bits */
-	if (!amdgpu_ip_block_version_cmp(adev, AMDGPU_IP_BLOCK_TYPE_UVD, 5, 0))
+	if (!amdgpu_ip_block_version_cmp(adev, AMD_IP_BLOCK_TYPE_UVD, 5, 0))
 		adev->uvd.address_64_bit = true;
 
 	return 0;
diff --git a/drivers/gpu/drm/amd/amdgpu/ci_dpm.c b/drivers/gpu/drm/amd/amdgpu/ci_dpm.c
index 5a9dad8..03809f1 100644
--- a/drivers/gpu/drm/amd/amdgpu/ci_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/ci_dpm.c
@@ -4227,8 +4227,8 @@ static int ci_update_vce_dpm(struct amdgpu_device *adev,
 	if (amdgpu_current_state->evclk != amdgpu_new_state->evclk) {
 		if (amdgpu_new_state->evclk) {
 			/* turn the clocks on when encoding */
-			ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_VCE,
-							    AMDGPU_CG_STATE_UNGATE);
+			ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_VCE,
+							    AMD_CG_STATE_UNGATE);
 			if (ret)
 				return ret;
 
@@ -4241,8 +4241,8 @@ static int ci_update_vce_dpm(struct amdgpu_device *adev,
 			ret = ci_enable_vce_dpm(adev, true);
 		} else {
 			/* turn the clocks off when not encoding */
-			ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_VCE,
-							    AMDGPU_CG_STATE_GATE);
+			ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_VCE,
+							    AMD_CG_STATE_GATE);
 			if (ret)
 				return ret;
 
@@ -6171,17 +6171,20 @@ static int ci_set_temperature_range(struct amdgpu_device *adev)
 	return ret;
 }
 
-static int ci_dpm_early_init(struct amdgpu_device *adev)
+static int ci_dpm_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	ci_dpm_set_dpm_funcs(adev);
 	ci_dpm_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int ci_dpm_late_init(struct amdgpu_device *adev)
+static int ci_dpm_late_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (!amdgpu_dpm)
 		return 0;
@@ -6195,9 +6198,10 @@ static int ci_dpm_late_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int ci_dpm_sw_init(struct amdgpu_device *adev)
+static int ci_dpm_sw_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	ret = amdgpu_irq_add_id(adev, 230, &adev->pm.dpm.thermal.irq);
 	if (ret)
@@ -6243,8 +6247,10 @@ dpm_failed:
 	return ret;
 }
 
-static int ci_dpm_sw_fini(struct amdgpu_device *adev)
+static int ci_dpm_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	mutex_lock(&adev->pm.mutex);
 	amdgpu_pm_sysfs_fini(adev);
 	ci_dpm_fini(adev);
@@ -6253,10 +6259,12 @@ static int ci_dpm_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int ci_dpm_hw_init(struct amdgpu_device *adev)
+static int ci_dpm_hw_init(void *handle)
 {
 	int ret;
 
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (!amdgpu_dpm)
 		return 0;
 
@@ -6272,8 +6280,10 @@ static int ci_dpm_hw_init(struct amdgpu_device *adev)
 	return ret;
 }
 
-static int ci_dpm_hw_fini(struct amdgpu_device *adev)
+static int ci_dpm_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (adev->pm.dpm_enabled) {
 		mutex_lock(&adev->pm.mutex);
 		ci_dpm_disable(adev);
@@ -6283,8 +6293,10 @@ static int ci_dpm_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int ci_dpm_suspend(struct amdgpu_device *adev)
+static int ci_dpm_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (adev->pm.dpm_enabled) {
 		mutex_lock(&adev->pm.mutex);
 		/* disable dpm */
@@ -6296,9 +6308,10 @@ static int ci_dpm_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int ci_dpm_resume(struct amdgpu_device *adev)
+static int ci_dpm_resume(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->pm.dpm_enabled) {
 		/* asic init will reset to the boot state */
@@ -6316,20 +6329,22 @@ static int ci_dpm_resume(struct amdgpu_device *adev)
 	return 0;
 }
 
-static bool ci_dpm_is_idle(struct amdgpu_device *adev)
+static bool ci_dpm_is_idle(void *handle)
 {
 	/* XXX */
 	return true;
 }
 
-static int ci_dpm_wait_for_idle(struct amdgpu_device *adev)
+static int ci_dpm_wait_for_idle(void *handle)
 {
 	/* XXX */
 	return 0;
 }
 
-static void ci_dpm_print_status(struct amdgpu_device *adev)
+static void ci_dpm_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "CIK DPM registers\n");
 	dev_info(adev->dev, "  BIOS_SCRATCH_4=0x%08X\n",
 		 RREG32(mmBIOS_SCRATCH_4));
@@ -6535,7 +6550,7 @@ static void ci_dpm_print_status(struct amdgpu_device *adev)
 		 RREG32_SMC(ixSMC_PC_C));
 }
 
-static int ci_dpm_soft_reset(struct amdgpu_device *adev)
+static int ci_dpm_soft_reset(void *handle)
 {
 	return 0;
 }
@@ -6618,19 +6633,19 @@ static int ci_dpm_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int ci_dpm_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int ci_dpm_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int ci_dpm_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int ci_dpm_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs ci_dpm_ip_funcs = {
+const struct amd_ip_funcs ci_dpm_ip_funcs = {
 	.early_init = ci_dpm_early_init,
 	.late_init = ci_dpm_late_init,
 	.sw_init = ci_dpm_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 74ce0be..5dab578 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1892,63 +1892,63 @@ static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &ci_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -1960,63 +1960,63 @@ static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &ci_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 5,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 3,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2028,63 +2028,63 @@ static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &kv_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 3,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2096,63 +2096,63 @@ static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &kv_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 3,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2164,63 +2164,63 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &kv_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 1,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 1,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2278,8 +2278,10 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.wait_for_mc_idle = &gmc_v7_0_mc_wait_for_idle,
 };
 
-static int cik_common_early_init(struct amdgpu_device *adev)
+static int cik_common_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	adev->smc_rreg = &cik_smc_rreg;
 	adev->smc_wreg = &cik_smc_wreg;
 	adev->pcie_rreg = &cik_pcie_rreg;
@@ -2417,18 +2419,20 @@ static int cik_common_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cik_common_sw_init(struct amdgpu_device *adev)
+static int cik_common_sw_init(void *handle)
 {
 	return 0;
 }
 
-static int cik_common_sw_fini(struct amdgpu_device *adev)
+static int cik_common_sw_fini(void *handle)
 {
 	return 0;
 }
 
-static int cik_common_hw_init(struct amdgpu_device *adev)
+static int cik_common_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	/* move the golden regs per IP block */
 	cik_init_golden_registers(adev);
 	/* enable pcie gen2/3 link */
@@ -2439,55 +2443,59 @@ static int cik_common_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cik_common_hw_fini(struct amdgpu_device *adev)
+static int cik_common_hw_fini(void *handle)
 {
 	return 0;
 }
 
-static int cik_common_suspend(struct amdgpu_device *adev)
+static int cik_common_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cik_common_hw_fini(adev);
 }
 
-static int cik_common_resume(struct amdgpu_device *adev)
+static int cik_common_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cik_common_hw_init(adev);
 }
 
-static bool cik_common_is_idle(struct amdgpu_device *adev)
+static bool cik_common_is_idle(void *handle)
 {
 	return true;
 }
 
-static int cik_common_wait_for_idle(struct amdgpu_device *adev)
+static int cik_common_wait_for_idle(void *handle)
 {
 	return 0;
 }
 
-static void cik_common_print_status(struct amdgpu_device *adev)
+static void cik_common_print_status(void *handle)
 {
 
 }
 
-static int cik_common_soft_reset(struct amdgpu_device *adev)
+static int cik_common_soft_reset(void *handle)
 {
 	/* XXX hard reset?? */
 	return 0;
 }
 
-static int cik_common_set_clockgating_state(struct amdgpu_device *adev,
-					    enum amdgpu_clockgating_state state)
+static int cik_common_set_clockgating_state(void *handle,
+					    enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int cik_common_set_powergating_state(struct amdgpu_device *adev,
-					    enum amdgpu_powergating_state state)
+static int cik_common_set_powergating_state(void *handle,
+					    enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs cik_common_ip_funcs = {
+const struct amd_ip_funcs cik_common_ip_funcs = {
 	.early_init = cik_common_early_init,
 	.late_init = NULL,
 	.sw_init = cik_common_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/cik.h b/drivers/gpu/drm/amd/amdgpu/cik.h
index 967d630..5ebd2d7 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.h
+++ b/drivers/gpu/drm/amd/amdgpu/cik.h
@@ -24,7 +24,7 @@
 #ifndef __CIK_H__
 #define __CIK_H__
 
-extern const struct amdgpu_ip_funcs cik_common_ip_funcs;
+extern const struct amd_ip_funcs cik_common_ip_funcs;
 
 void cik_srbm_select(struct amdgpu_device *adev,
 		     u32 me, u32 pipe, u32 queue, u32 vmid);
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_dpm.h b/drivers/gpu/drm/amd/amdgpu/cik_dpm.h
index 35d8efd..b1c8e7b 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_dpm.h
+++ b/drivers/gpu/drm/amd/amdgpu/cik_dpm.h
@@ -24,7 +24,7 @@
 #ifndef __CIK_DPM_H__
 #define __CIK_DPM_H__
 
-extern const struct amdgpu_ip_funcs ci_dpm_ip_funcs;
-extern const struct amdgpu_ip_funcs kv_dpm_ip_funcs;
+extern const struct amd_ip_funcs ci_dpm_ip_funcs;
+extern const struct amd_ip_funcs kv_dpm_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_ih.c b/drivers/gpu/drm/amd/amdgpu/cik_ih.c
index 81e8bbab..8993c50 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_ih.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik_ih.c
@@ -271,16 +271,19 @@ static void cik_ih_set_rptr(struct amdgpu_device *adev)
 	WREG32(mmIH_RB_RPTR, adev->irq.ih.rptr);
 }
 
-static int cik_ih_early_init(struct amdgpu_device *adev)
+static int cik_ih_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cik_ih_set_interrupt_funcs(adev);
 
 	return 0;
 }
 
-static int cik_ih_sw_init(struct amdgpu_device *adev)
+static int cik_ih_sw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_ih_ring_init(adev, 64 * 1024, false);
 	if (r)
@@ -291,17 +294,20 @@ static int cik_ih_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int cik_ih_sw_fini(struct amdgpu_device *adev)
+static int cik_ih_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_irq_fini(adev);
 	amdgpu_ih_ring_fini(adev);
 
 	return 0;
 }
 
-static int cik_ih_hw_init(struct amdgpu_device *adev)
+static int cik_ih_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = cik_ih_irq_init(adev);
 	if (r)
@@ -310,25 +316,32 @@ static int cik_ih_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cik_ih_hw_fini(struct amdgpu_device *adev)
+static int cik_ih_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cik_ih_irq_disable(adev);
 
 	return 0;
 }
 
-static int cik_ih_suspend(struct amdgpu_device *adev)
+static int cik_ih_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cik_ih_hw_fini(adev);
 }
 
-static int cik_ih_resume(struct amdgpu_device *adev)
+static int cik_ih_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cik_ih_hw_init(adev);
 }
 
-static bool cik_ih_is_idle(struct amdgpu_device *adev)
+static bool cik_ih_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & SRBM_STATUS__IH_BUSY_MASK)
@@ -337,10 +350,11 @@ static bool cik_ih_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int cik_ih_wait_for_idle(struct amdgpu_device *adev)
+static int cik_ih_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -352,8 +366,10 @@ static int cik_ih_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void cik_ih_print_status(struct amdgpu_device *adev)
+static void cik_ih_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "CIK IH registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
 		RREG32(mmSRBM_STATUS));
@@ -379,8 +395,10 @@ static void cik_ih_print_status(struct amdgpu_device *adev)
 		 RREG32(mmIH_RB_WPTR));
 }
 
-static int cik_ih_soft_reset(struct amdgpu_device *adev)
+static int cik_ih_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	u32 srbm_soft_reset = 0;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
@@ -388,7 +406,7 @@ static int cik_ih_soft_reset(struct amdgpu_device *adev)
 		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_IH_MASK;
 
 	if (srbm_soft_reset) {
-		cik_ih_print_status(adev);
+		cik_ih_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -405,25 +423,25 @@ static int cik_ih_soft_reset(struct amdgpu_device *adev)
 		/* Wait a little for things to settle down */
 		udelay(50);
 
-		cik_ih_print_status(adev);
+		cik_ih_print_status((void *)adev);
 	}
 
 	return 0;
 }
 
-static int cik_ih_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int cik_ih_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int cik_ih_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int cik_ih_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs cik_ih_ip_funcs = {
+const struct amd_ip_funcs cik_ih_ip_funcs = {
 	.early_init = cik_ih_early_init,
 	.late_init = NULL,
 	.sw_init = cik_ih_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_ih.h b/drivers/gpu/drm/amd/amdgpu/cik_ih.h
index f701625..6b0f375 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_ih.h
+++ b/drivers/gpu/drm/amd/amdgpu/cik_ih.h
@@ -24,6 +24,6 @@
 #ifndef __CIK_IH_H__
 #define __CIK_IH_H__
 
-extern const struct amdgpu_ip_funcs cik_ih_ip_funcs;
+extern const struct amd_ip_funcs cik_ih_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
index d5055ea..7c816b5 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
@@ -927,8 +927,10 @@ static void cik_enable_sdma_mgls(struct amdgpu_device *adev,
 	}
 }
 
-static int cik_sdma_early_init(struct amdgpu_device *adev)
+static int cik_sdma_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cik_sdma_set_ring_funcs(adev);
 	cik_sdma_set_irq_funcs(adev);
 	cik_sdma_set_buffer_funcs(adev);
@@ -937,9 +939,10 @@ static int cik_sdma_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cik_sdma_sw_init(struct amdgpu_device *adev)
+static int cik_sdma_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int r;
 
 	r = cik_sdma_init_microcode(adev);
@@ -990,17 +993,20 @@ static int cik_sdma_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int cik_sdma_sw_fini(struct amdgpu_device *adev)
+static int cik_sdma_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_ring_fini(&adev->sdma[0].ring);
 	amdgpu_ring_fini(&adev->sdma[1].ring);
 
 	return 0;
 }
 
-static int cik_sdma_hw_init(struct amdgpu_device *adev)
+static int cik_sdma_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = cik_sdma_start(adev);
 	if (r)
@@ -1009,27 +1015,32 @@ static int cik_sdma_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int cik_sdma_hw_fini(struct amdgpu_device *adev)
+static int cik_sdma_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cik_sdma_enable(adev, false);
 
 	return 0;
 }
 
-static int cik_sdma_suspend(struct amdgpu_device *adev)
+static int cik_sdma_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	return cik_sdma_hw_fini(adev);
 }
 
-static int cik_sdma_resume(struct amdgpu_device *adev)
+static int cik_sdma_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	return cik_sdma_hw_init(adev);
 }
 
-static bool cik_sdma_is_idle(struct amdgpu_device *adev)
+static bool cik_sdma_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS2);
 
 	if (tmp & (SRBM_STATUS2__SDMA_BUSY_MASK |
@@ -1039,10 +1050,11 @@ static bool cik_sdma_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int cik_sdma_wait_for_idle(struct amdgpu_device *adev)
+static int cik_sdma_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		tmp = RREG32(mmSRBM_STATUS2) & (SRBM_STATUS2__SDMA_BUSY_MASK |
@@ -1055,9 +1067,10 @@ static int cik_sdma_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void cik_sdma_print_status(struct amdgpu_device *adev)
+static void cik_sdma_print_status(void *handle)
 {
 	int i, j;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "CIK SDMA registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS2=0x%08X\n",
@@ -1103,9 +1116,10 @@ static void cik_sdma_print_status(struct amdgpu_device *adev)
 	}
 }
 
-static int cik_sdma_soft_reset(struct amdgpu_device *adev)
+static int cik_sdma_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS2);
 
 	if (tmp & SRBM_STATUS2__SDMA_BUSY_MASK) {
@@ -1124,7 +1138,7 @@ static int cik_sdma_soft_reset(struct amdgpu_device *adev)
 	}
 
 	if (srbm_soft_reset) {
-		cik_sdma_print_status(adev);
+		cik_sdma_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -1141,7 +1155,7 @@ static int cik_sdma_soft_reset(struct amdgpu_device *adev)
 		/* Wait a little for things to settle down */
 		udelay(50);
 
-		cik_sdma_print_status(adev);
+		cik_sdma_print_status((void *)adev);
 	}
 
 	return 0;
@@ -1243,12 +1257,13 @@ static int cik_sdma_process_illegal_inst_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int cik_sdma_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int cik_sdma_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	bool gate = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (state == AMDGPU_CG_STATE_GATE)
+	if (state == AMD_CG_STATE_GATE)
 		gate = true;
 
 	cik_enable_sdma_mgcg(adev, gate);
@@ -1257,13 +1272,13 @@ static int cik_sdma_set_clockgating_state(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int cik_sdma_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int cik_sdma_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs cik_sdma_ip_funcs = {
+const struct amd_ip_funcs cik_sdma_ip_funcs = {
 	.early_init = cik_sdma_early_init,
 	.late_init = NULL,
 	.sw_init = cik_sdma_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.h b/drivers/gpu/drm/amd/amdgpu/cik_sdma.h
index 42b5996..027727c 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.h
+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.h
@@ -24,6 +24,6 @@
 #ifndef __CIK_SDMA_H__
 #define __CIK_SDMA_H__
 
-extern const struct amdgpu_ip_funcs cik_sdma_ip_funcs;
+extern const struct amd_ip_funcs cik_sdma_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/cz_dpm.c b/drivers/gpu/drm/amd/amdgpu/cz_dpm.c
index 2649b50..f275b5d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cz_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/cz_dpm.c
@@ -542,24 +542,29 @@ static void cz_dpm_print_power_state(struct amdgpu_device *adev,
 
 static void cz_dpm_set_funcs(struct amdgpu_device *adev);
 
-static int cz_dpm_early_init(struct amdgpu_device *adev)
+static int cz_dpm_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cz_dpm_set_funcs(adev);
 
 	return 0;
 }
 
 
-static int cz_dpm_late_init(struct amdgpu_device *adev)
+static int cz_dpm_late_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	/* powerdown unused blocks for now */
 	cz_dpm_powergate_uvd(adev, true);
 
 	return 0;
 }
 
-static int cz_dpm_sw_init(struct amdgpu_device *adev)
+static int cz_dpm_sw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int ret = 0;
 	/* fix me to add thermal support TODO */
 
@@ -602,8 +607,10 @@ dpm_init_failed:
 	return ret;
 }
 
-static int cz_dpm_sw_fini(struct amdgpu_device *adev)
+static int cz_dpm_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	mutex_lock(&adev->pm.mutex);
 	amdgpu_pm_sysfs_fini(adev);
 	cz_dpm_fini(adev);
@@ -1216,8 +1223,9 @@ static int cz_dpm_enable(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cz_dpm_hw_init(struct amdgpu_device *adev)
+static int cz_dpm_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int ret = 0;
 
 	mutex_lock(&adev->pm.mutex);
@@ -1282,9 +1290,10 @@ static int cz_dpm_disable(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cz_dpm_hw_fini(struct amdgpu_device *adev)
+static int cz_dpm_hw_fini(void *handle)
 {
 	int ret = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	mutex_lock(&adev->pm.mutex);
 
@@ -1305,9 +1314,10 @@ static int cz_dpm_hw_fini(struct amdgpu_device *adev)
 	return ret;
 }
 
-static int cz_dpm_suspend(struct amdgpu_device *adev)
+static int cz_dpm_suspend(void *handle)
 {
 	int ret = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->pm.dpm_enabled) {
 		mutex_lock(&adev->pm.mutex);
@@ -1324,9 +1334,10 @@ static int cz_dpm_suspend(struct amdgpu_device *adev)
 	return ret;
 }
 
-static int cz_dpm_resume(struct amdgpu_device *adev)
+static int cz_dpm_resume(void *handle)
 {
 	int ret = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	mutex_lock(&adev->pm.mutex);
 	ret = cz_smu_init(adev);
@@ -1368,14 +1379,14 @@ static int cz_dpm_resume(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cz_dpm_set_clockgating_state(struct amdgpu_device *adev,
-					enum amdgpu_clockgating_state state)
+static int cz_dpm_set_clockgating_state(void *handle,
+					enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int cz_dpm_set_powergating_state(struct amdgpu_device *adev,
-					enum amdgpu_powergating_state state)
+static int cz_dpm_set_powergating_state(void *handle,
+					enum amd_powergating_state state)
 {
 	return 0;
 }
@@ -1733,11 +1744,11 @@ static void cz_dpm_powergate_uvd(struct amdgpu_device *adev, bool gate)
 	if (gate) {
 		if (pi->caps_uvd_pg) {
 			/* disable clockgating so we can properly shut down the block */
-			ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_CG_STATE_UNGATE);
+			ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_CG_STATE_UNGATE);
 			/* shutdown the UVD block */
-			ret = amdgpu_set_powergating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_PG_STATE_GATE);
+			ret = amdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_PG_STATE_GATE);
 			/* XXX: check for errors */
 		}
 		cz_update_uvd_dpm(adev, gate);
@@ -1752,18 +1763,18 @@ static void cz_dpm_powergate_uvd(struct amdgpu_device *adev, bool gate)
 			else
 				cz_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_UVDPowerON, 0);
 			/* re-init the UVD block */
-			ret = amdgpu_set_powergating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_PG_STATE_UNGATE);
+			ret = amdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_PG_STATE_UNGATE);
 			/* enable clockgating. hw will dynamically gate/ungate clocks on the fly */
-			ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_CG_STATE_GATE);
+			ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_CG_STATE_GATE);
 			/* XXX: check for errors */
 		}
 		cz_update_uvd_dpm(adev, gate);
 	}
 }
 
-const struct amdgpu_ip_funcs cz_dpm_ip_funcs = {
+const struct amd_ip_funcs cz_dpm_ip_funcs = {
 	.early_init = cz_dpm_early_init,
 	.late_init = cz_dpm_late_init,
 	.sw_init = cz_dpm_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/cz_ih.c b/drivers/gpu/drm/amd/amdgpu/cz_ih.c
index 80d508e..bc751bf 100644
--- a/drivers/gpu/drm/amd/amdgpu/cz_ih.c
+++ b/drivers/gpu/drm/amd/amdgpu/cz_ih.c
@@ -250,15 +250,18 @@ static void cz_ih_set_rptr(struct amdgpu_device *adev)
 	WREG32(mmIH_RB_RPTR, adev->irq.ih.rptr);
 }
 
-static int cz_ih_early_init(struct amdgpu_device *adev)
+static int cz_ih_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cz_ih_set_interrupt_funcs(adev);
 	return 0;
 }
 
-static int cz_ih_sw_init(struct amdgpu_device *adev)
+static int cz_ih_sw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_ih_ring_init(adev, 64 * 1024, false);
 	if (r)
@@ -269,17 +272,20 @@ static int cz_ih_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int cz_ih_sw_fini(struct amdgpu_device *adev)
+static int cz_ih_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_irq_fini(adev);
 	amdgpu_ih_ring_fini(adev);
 
 	return 0;
 }
 
-static int cz_ih_hw_init(struct amdgpu_device *adev)
+static int cz_ih_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = cz_ih_irq_init(adev);
 	if (r)
@@ -288,25 +294,32 @@ static int cz_ih_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cz_ih_hw_fini(struct amdgpu_device *adev)
+static int cz_ih_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	cz_ih_irq_disable(adev);
 
 	return 0;
 }
 
-static int cz_ih_suspend(struct amdgpu_device *adev)
+static int cz_ih_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cz_ih_hw_fini(adev);
 }
 
-static int cz_ih_resume(struct amdgpu_device *adev)
+static int cz_ih_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cz_ih_hw_init(adev);
 }
 
-static bool cz_ih_is_idle(struct amdgpu_device *adev)
+static bool cz_ih_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (REG_GET_FIELD(tmp, SRBM_STATUS, IH_BUSY))
@@ -315,10 +328,11 @@ static bool cz_ih_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int cz_ih_wait_for_idle(struct amdgpu_device *adev)
+static int cz_ih_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -330,8 +344,10 @@ static int cz_ih_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void cz_ih_print_status(struct amdgpu_device *adev)
+static void cz_ih_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "CZ IH registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
 		RREG32(mmSRBM_STATUS));
@@ -357,9 +373,10 @@ static void cz_ih_print_status(struct amdgpu_device *adev)
 		 RREG32(mmIH_RB_WPTR));
 }
 
-static int cz_ih_soft_reset(struct amdgpu_device *adev)
+static int cz_ih_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & SRBM_STATUS__IH_BUSY_MASK)
@@ -367,7 +384,7 @@ static int cz_ih_soft_reset(struct amdgpu_device *adev)
 						SOFT_RESET_IH, 1);
 
 	if (srbm_soft_reset) {
-		cz_ih_print_status(adev);
+		cz_ih_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -384,27 +401,27 @@ static int cz_ih_soft_reset(struct amdgpu_device *adev)
 		/* Wait a little for things to settle down */
 		udelay(50);
 
-		cz_ih_print_status(adev);
+		cz_ih_print_status((void *)adev);
 	}
 
 	return 0;
 }
 
-static int cz_ih_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int cz_ih_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	// TODO
 	return 0;
 }
 
-static int cz_ih_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int cz_ih_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	// TODO
 	return 0;
 }
 
-const struct amdgpu_ip_funcs cz_ih_ip_funcs = {
+const struct amd_ip_funcs cz_ih_ip_funcs = {
 	.early_init = cz_ih_early_init,
 	.late_init = NULL,
 	.sw_init = cz_ih_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/cz_ih.h b/drivers/gpu/drm/amd/amdgpu/cz_ih.h
index 1bce136..fc4057a 100644
--- a/drivers/gpu/drm/amd/amdgpu/cz_ih.h
+++ b/drivers/gpu/drm/amd/amdgpu/cz_ih.h
@@ -24,6 +24,6 @@
 #ifndef __CZ_IH_H__
 #define __CZ_IH_H__
 
-extern const struct amdgpu_ip_funcs cz_ih_ip_funcs;
+extern const struct amd_ip_funcs cz_ih_ip_funcs;
 
 #endif /* __CZ_IH_H__ */
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
index 37b9623..da9a4b9 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
@@ -2864,8 +2864,10 @@ static int dce_v10_0_crtc_init(struct amdgpu_device *adev, int index)
 	return 0;
 }
 
-static int dce_v10_0_early_init(struct amdgpu_device *adev)
+static int dce_v10_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	adev->audio_endpt_rreg = &dce_v10_0_audio_endpt_rreg;
 	adev->audio_endpt_wreg = &dce_v10_0_audio_endpt_wreg;
 
@@ -2886,9 +2888,10 @@ static int dce_v10_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v10_0_sw_init(struct amdgpu_device *adev)
+static int dce_v10_0_sw_init(void *handle)
 {
 	int r, i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
 		r = amdgpu_irq_add_id(adev, i + 1, &adev->crtc_irq);
@@ -2950,8 +2953,10 @@ static int dce_v10_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int dce_v10_0_sw_fini(struct amdgpu_device *adev)
+static int dce_v10_0_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	kfree(adev->mode_info.bios_hardcoded_edid);
 
 	drm_kms_helper_poll_fini(adev->ddev);
@@ -2966,9 +2971,10 @@ static int dce_v10_0_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v10_0_hw_init(struct amdgpu_device *adev)
+static int dce_v10_0_hw_init(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v10_0_init_golden_registers(adev);
 
@@ -2986,9 +2992,10 @@ static int dce_v10_0_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v10_0_hw_fini(struct amdgpu_device *adev)
+static int dce_v10_0_hw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v10_0_hpd_fini(adev);
 
@@ -2999,9 +3006,10 @@ static int dce_v10_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v10_0_suspend(struct amdgpu_device *adev)
+static int dce_v10_0_suspend(void *handle)
 {
 	struct drm_connector *connector;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	drm_kms_helper_poll_disable(adev->ddev);
 
@@ -3017,9 +3025,10 @@ static int dce_v10_0_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v10_0_resume(struct amdgpu_device *adev)
+static int dce_v10_0_resume(void *handle)
 {
 	struct drm_connector *connector;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v10_0_init_golden_registers(adev);
 
@@ -3051,33 +3060,34 @@ static int dce_v10_0_resume(struct amdgpu_device *adev)
 	return 0;
 }
 
-static bool dce_v10_0_is_idle(struct amdgpu_device *adev)
+static bool dce_v10_0_is_idle(void *handle)
 {
-	/* XXX todo */
 	return true;
 }
 
-static int dce_v10_0_wait_for_idle(struct amdgpu_device *adev)
+static int dce_v10_0_wait_for_idle(void *handle)
 {
-	/* XXX todo */
 	return 0;
 }
 
-static void dce_v10_0_print_status(struct amdgpu_device *adev)
+static void dce_v10_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "DCE 10.x registers\n");
 	/* XXX todo */
 }
 
-static int dce_v10_0_soft_reset(struct amdgpu_device *adev)
+static int dce_v10_0_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0, tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (dce_v10_0_is_display_hung(adev))
 		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_DC_MASK;
 
 	if (srbm_soft_reset) {
-		dce_v10_0_print_status(adev);
+		dce_v10_0_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -3093,7 +3103,7 @@ static int dce_v10_0_soft_reset(struct amdgpu_device *adev)
 
 		/* Wait a little for things to settle down */
 		udelay(50);
-		dce_v10_0_print_status(adev);
+		dce_v10_0_print_status((void *)adev);
 	}
 	return 0;
 }
@@ -3449,19 +3459,19 @@ static int dce_v10_0_hpd_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int dce_v10_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int dce_v10_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int dce_v10_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int dce_v10_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs dce_v10_0_ip_funcs = {
+const struct amd_ip_funcs dce_v10_0_ip_funcs = {
 	.early_init = dce_v10_0_early_init,
 	.late_init = NULL,
 	.sw_init = dce_v10_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.h b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.h
index 72ca20d..1bfa48d 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.h
@@ -24,6 +24,6 @@
 #ifndef __DCE_V10_0_H__
 #define __DCE_V10_0_H__
 
-extern const struct amdgpu_ip_funcs dce_v10_0_ip_funcs;
+extern const struct amd_ip_funcs dce_v10_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
index 04a5d4c..edd9d17 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
@@ -2863,8 +2863,10 @@ static int dce_v11_0_crtc_init(struct amdgpu_device *adev, int index)
 	return 0;
 }
 
-static int dce_v11_0_early_init(struct amdgpu_device *adev)
+static int dce_v11_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	adev->audio_endpt_rreg = &dce_v11_0_audio_endpt_rreg;
 	adev->audio_endpt_wreg = &dce_v11_0_audio_endpt_wreg;
 
@@ -2885,9 +2887,10 @@ static int dce_v11_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v11_0_sw_init(struct amdgpu_device *adev)
+static int dce_v11_0_sw_init(void *handle)
 {
 	int r, i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
 		r = amdgpu_irq_add_id(adev, i + 1, &adev->crtc_irq);
@@ -2949,8 +2952,10 @@ static int dce_v11_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int dce_v11_0_sw_fini(struct amdgpu_device *adev)
+static int dce_v11_0_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	kfree(adev->mode_info.bios_hardcoded_edid);
 
 	drm_kms_helper_poll_fini(adev->ddev);
@@ -2964,9 +2969,10 @@ static int dce_v11_0_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v11_0_hw_init(struct amdgpu_device *adev)
+static int dce_v11_0_hw_init(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v11_0_init_golden_registers(adev);
 
@@ -2984,9 +2990,10 @@ static int dce_v11_0_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v11_0_hw_fini(struct amdgpu_device *adev)
+static int dce_v11_0_hw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v11_0_hpd_fini(adev);
 
@@ -2997,9 +3004,10 @@ static int dce_v11_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v11_0_suspend(struct amdgpu_device *adev)
+static int dce_v11_0_suspend(void *handle)
 {
 	struct drm_connector *connector;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	drm_kms_helper_poll_disable(adev->ddev);
 
@@ -3015,9 +3023,10 @@ static int dce_v11_0_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v11_0_resume(struct amdgpu_device *adev)
+static int dce_v11_0_resume(void *handle)
 {
 	struct drm_connector *connector;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v11_0_init_golden_registers(adev);
 
@@ -3050,33 +3059,34 @@ static int dce_v11_0_resume(struct amdgpu_device *adev)
 	return 0;
 }
 
-static bool dce_v11_0_is_idle(struct amdgpu_device *adev)
+static bool dce_v11_0_is_idle(void *handle)
 {
-	/* XXX todo */
 	return true;
 }
 
-static int dce_v11_0_wait_for_idle(struct amdgpu_device *adev)
+static int dce_v11_0_wait_for_idle(void *handle)
 {
-	/* XXX todo */
 	return 0;
 }
 
-static void dce_v11_0_print_status(struct amdgpu_device *adev)
+static void dce_v11_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "DCE 10.x registers\n");
 	/* XXX todo */
 }
 
-static int dce_v11_0_soft_reset(struct amdgpu_device *adev)
+static int dce_v11_0_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0, tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (dce_v11_0_is_display_hung(adev))
 		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_DC_MASK;
 
 	if (srbm_soft_reset) {
-		dce_v11_0_print_status(adev);
+		dce_v11_0_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -3092,7 +3102,7 @@ static int dce_v11_0_soft_reset(struct amdgpu_device *adev)
 
 		/* Wait a little for things to settle down */
 		udelay(50);
-		dce_v11_0_print_status(adev);
+		dce_v11_0_print_status((void *)adev);
 	}
 	return 0;
 }
@@ -3448,19 +3458,19 @@ static int dce_v11_0_hpd_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int dce_v11_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int dce_v11_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int dce_v11_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int dce_v11_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs dce_v11_0_ip_funcs = {
+const struct amd_ip_funcs dce_v11_0_ip_funcs = {
 	.early_init = dce_v11_0_early_init,
 	.late_init = NULL,
 	.sw_init = dce_v11_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.h b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.h
index eeb9a56..84e4618 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.h
@@ -24,6 +24,6 @@
 #ifndef __DCE_V11_0_H__
 #define __DCE_V11_0_H__
 
-extern const struct amdgpu_ip_funcs dce_v11_0_ip_funcs;
+extern const struct amd_ip_funcs dce_v11_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index 9f2ff8d..1d291f1d 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -2794,8 +2794,10 @@ static int dce_v8_0_crtc_init(struct amdgpu_device *adev, int index)
 	return 0;
 }
 
-static int dce_v8_0_early_init(struct amdgpu_device *adev)
+static int dce_v8_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	adev->audio_endpt_rreg = &dce_v8_0_audio_endpt_rreg;
 	adev->audio_endpt_wreg = &dce_v8_0_audio_endpt_wreg;
 
@@ -2828,9 +2830,10 @@ static int dce_v8_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v8_0_sw_init(struct amdgpu_device *adev)
+static int dce_v8_0_sw_init(void *handle)
 {
 	int r, i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
 		r = amdgpu_irq_add_id(adev, i + 1, &adev->crtc_irq);
@@ -2892,8 +2895,10 @@ static int dce_v8_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int dce_v8_0_sw_fini(struct amdgpu_device *adev)
+static int dce_v8_0_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	kfree(adev->mode_info.bios_hardcoded_edid);
 
 	drm_kms_helper_poll_fini(adev->ddev);
@@ -2908,9 +2913,10 @@ static int dce_v8_0_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v8_0_hw_init(struct amdgpu_device *adev)
+static int dce_v8_0_hw_init(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* init dig PHYs, disp eng pll */
 	amdgpu_atombios_encoder_init_dig(adev);
@@ -2926,9 +2932,10 @@ static int dce_v8_0_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v8_0_hw_fini(struct amdgpu_device *adev)
+static int dce_v8_0_hw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dce_v8_0_hpd_fini(adev);
 
@@ -2939,9 +2946,10 @@ static int dce_v8_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v8_0_suspend(struct amdgpu_device *adev)
+static int dce_v8_0_suspend(void *handle)
 {
 	struct drm_connector *connector;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	drm_kms_helper_poll_disable(adev->ddev);
 
@@ -2957,9 +2965,10 @@ static int dce_v8_0_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int dce_v8_0_resume(struct amdgpu_device *adev)
+static int dce_v8_0_resume(void *handle)
 {
 	struct drm_connector *connector;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	amdgpu_atombios_scratch_regs_restore(adev);
 
@@ -2989,33 +2998,34 @@ static int dce_v8_0_resume(struct amdgpu_device *adev)
 	return 0;
 }
 
-static bool dce_v8_0_is_idle(struct amdgpu_device *adev)
+static bool dce_v8_0_is_idle(void *handle)
 {
-	/* XXX todo */
 	return true;
 }
 
-static int dce_v8_0_wait_for_idle(struct amdgpu_device *adev)
+static int dce_v8_0_wait_for_idle(void *handle)
 {
-	/* XXX todo */
 	return 0;
 }
 
-static void dce_v8_0_print_status(struct amdgpu_device *adev)
+static void dce_v8_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "DCE 8.x registers\n");
 	/* XXX todo */
 }
 
-static int dce_v8_0_soft_reset(struct amdgpu_device *adev)
+static int dce_v8_0_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0, tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (dce_v8_0_is_display_hung(adev))
 		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_DC_MASK;
 
 	if (srbm_soft_reset) {
-		dce_v8_0_print_status(adev);
+		dce_v8_0_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -3031,7 +3041,7 @@ static int dce_v8_0_soft_reset(struct amdgpu_device *adev)
 
 		/* Wait a little for things to settle down */
 		udelay(50);
-		dce_v8_0_print_status(adev);
+		dce_v8_0_print_status((void *)adev);
 	}
 	return 0;
 }
@@ -3409,19 +3419,19 @@ static int dce_v8_0_hpd_irq(struct amdgpu_device *adev,
 
 }
 
-static int dce_v8_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int dce_v8_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int dce_v8_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int dce_v8_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs dce_v8_0_ip_funcs = {
+const struct amd_ip_funcs dce_v8_0_ip_funcs = {
 	.early_init = dce_v8_0_early_init,
 	.late_init = NULL,
 	.sw_init = dce_v8_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.h b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.h
index 3a0a73b4..7701685 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.h
@@ -24,6 +24,6 @@
 #ifndef __DCE_V8_0_H__
 #define __DCE_V8_0_H__
 
-extern const struct amdgpu_ip_funcs dce_v8_0_ip_funcs;
+extern const struct amd_ip_funcs dce_v8_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
index 5315c13..0057699 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
@@ -4682,8 +4682,9 @@ static void gfx_v7_0_ring_emit_gds_switch(struct amdgpu_ring *ring,
 	amdgpu_ring_write(ring, (1 << (oa_size + oa_base)) - (1 << oa_base));
 }
 
-static int gfx_v7_0_early_init(struct amdgpu_device *adev)
+static int gfx_v7_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	adev->gfx.num_gfx_rings = GFX7_NUM_GFX_RINGS;
 	adev->gfx.num_compute_rings = GFX7_NUM_COMPUTE_RINGS;
@@ -4694,9 +4695,10 @@ static int gfx_v7_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v7_0_sw_init(struct amdgpu_device *adev)
+static int gfx_v7_0_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int i, r;
 
 	/* EOP Event */
@@ -4805,9 +4807,10 @@ static int gfx_v7_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gfx_v7_0_sw_fini(struct amdgpu_device *adev)
+static int gfx_v7_0_sw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	amdgpu_bo_unref(&adev->gds.oa_gfx_bo);
 	amdgpu_bo_unref(&adev->gds.gws_gfx_bo);
@@ -4827,9 +4830,10 @@ static int gfx_v7_0_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v7_0_hw_init(struct amdgpu_device *adev)
+static int gfx_v7_0_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	gfx_v7_0_gpu_init(adev);
 
@@ -4845,8 +4849,10 @@ static int gfx_v7_0_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gfx_v7_0_hw_fini(struct amdgpu_device *adev)
+static int gfx_v7_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	gfx_v7_0_cp_enable(adev, false);
 	gfx_v7_0_rlc_stop(adev);
 	gfx_v7_0_fini_pg(adev);
@@ -4854,28 +4860,35 @@ static int gfx_v7_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v7_0_suspend(struct amdgpu_device *adev)
+static int gfx_v7_0_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return gfx_v7_0_hw_fini(adev);
 }
 
-static int gfx_v7_0_resume(struct amdgpu_device *adev)
+static int gfx_v7_0_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return gfx_v7_0_hw_init(adev);
 }
 
-static bool gfx_v7_0_is_idle(struct amdgpu_device *adev)
+static bool gfx_v7_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (RREG32(mmGRBM_STATUS) & GRBM_STATUS__GUI_ACTIVE_MASK)
 		return false;
 	else
 		return true;
 }
 
-static int gfx_v7_0_wait_for_idle(struct amdgpu_device *adev)
+static int gfx_v7_0_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -4888,9 +4901,10 @@ static int gfx_v7_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void gfx_v7_0_print_status(struct amdgpu_device *adev)
+static void gfx_v7_0_print_status(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "GFX 7.x registers\n");
 	dev_info(adev->dev, "  GRBM_STATUS=0x%08X\n",
@@ -5147,10 +5161,11 @@ static void gfx_v7_0_print_status(struct amdgpu_device *adev)
 	mutex_unlock(&adev->srbm_mutex);
 }
 
-static int gfx_v7_0_soft_reset(struct amdgpu_device *adev)
+static int gfx_v7_0_soft_reset(void *handle)
 {
 	u32 grbm_soft_reset = 0, srbm_soft_reset = 0;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* GRBM_STATUS */
 	tmp = RREG32(mmGRBM_STATUS);
@@ -5179,7 +5194,7 @@ static int gfx_v7_0_soft_reset(struct amdgpu_device *adev)
 		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;
 
 	if (grbm_soft_reset || srbm_soft_reset) {
-		gfx_v7_0_print_status(adev);
+		gfx_v7_0_print_status((void *)adev);
 		/* disable CG/PG */
 		gfx_v7_0_fini_pg(adev);
 		gfx_v7_0_update_cg(adev, false);
@@ -5222,7 +5237,7 @@ static int gfx_v7_0_soft_reset(struct amdgpu_device *adev)
 		}
 		/* Wait a little for things to settle down */
 		udelay(50);
-		gfx_v7_0_print_status(adev);
+		gfx_v7_0_print_status((void *)adev);
 	}
 	return 0;
 }
@@ -5425,12 +5440,13 @@ static int gfx_v7_0_priv_inst_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int gfx_v7_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int gfx_v7_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	bool gate = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (state == AMDGPU_CG_STATE_GATE)
+	if (state == AMD_CG_STATE_GATE)
 		gate = true;
 
 	gfx_v7_0_enable_gui_idle_interrupt(adev, false);
@@ -5447,12 +5463,13 @@ static int gfx_v7_0_set_clockgating_state(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int gfx_v7_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int gfx_v7_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	bool gate = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (state == AMDGPU_PG_STATE_GATE)
+	if (state == AMD_PG_STATE_GATE)
 		gate = true;
 
 	if (adev->pg_flags & (AMDGPU_PG_SUPPORT_GFX_PG |
@@ -5471,7 +5488,7 @@ static int gfx_v7_0_set_powergating_state(struct amdgpu_device *adev,
 	return 0;
 }
 
-const struct amdgpu_ip_funcs gfx_v7_0_ip_funcs = {
+const struct amd_ip_funcs gfx_v7_0_ip_funcs = {
 	.early_init = gfx_v7_0_early_init,
 	.late_init = NULL,
 	.sw_init = gfx_v7_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.h b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.h
index 668b91a..c04bfba 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.h
@@ -24,7 +24,7 @@
 #ifndef __GFX_V7_0_H__
 #define __GFX_V7_0_H__
 
-extern const struct amdgpu_ip_funcs gfx_v7_0_ip_funcs;
+extern const struct amd_ip_funcs gfx_v7_0_ip_funcs;
 
 /* XXX these shouldn't be exported */
 void gfx_v7_0_enter_rlc_safe_mode(struct amdgpu_device *adev);
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
index 4597256..a7d687d 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c
@@ -784,10 +784,11 @@ static int gfx_v8_0_mec_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v8_0_sw_init(struct amdgpu_device *adev)
+static int gfx_v8_0_sw_init(void *handle)
 {
 	int i, r;
 	struct amdgpu_ring *ring;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* EOP Event */
 	r = amdgpu_irq_add_id(adev, 181, &adev->gfx.eop_irq);
@@ -897,9 +898,10 @@ static int gfx_v8_0_sw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v8_0_sw_fini(struct amdgpu_device *adev)
+static int gfx_v8_0_sw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	amdgpu_bo_unref(&adev->gds.oa_gfx_bo);
 	amdgpu_bo_unref(&adev->gds.gws_gfx_bo);
@@ -3148,9 +3150,10 @@ static void gfx_v8_0_cp_enable(struct amdgpu_device *adev, bool enable)
 	gfx_v8_0_cp_compute_enable(adev, enable);
 }
 
-static int gfx_v8_0_hw_init(struct amdgpu_device *adev)
+static int gfx_v8_0_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	gfx_v8_0_init_golden_registers(adev);
 
@@ -3167,8 +3170,10 @@ static int gfx_v8_0_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gfx_v8_0_hw_fini(struct amdgpu_device *adev)
+static int gfx_v8_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	gfx_v8_0_cp_enable(adev, false);
 	gfx_v8_0_rlc_stop(adev);
 	gfx_v8_0_cp_compute_fini(adev);
@@ -3176,28 +3181,35 @@ static int gfx_v8_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v8_0_suspend(struct amdgpu_device *adev)
+static int gfx_v8_0_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return gfx_v8_0_hw_fini(adev);
 }
 
-static int gfx_v8_0_resume(struct amdgpu_device *adev)
+static int gfx_v8_0_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return gfx_v8_0_hw_init(adev);
 }
 
-static bool gfx_v8_0_is_idle(struct amdgpu_device *adev)
+static bool gfx_v8_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (REG_GET_FIELD(RREG32(mmGRBM_STATUS), GRBM_STATUS, GUI_ACTIVE))
 		return false;
 	else
 		return true;
 }
 
-static int gfx_v8_0_wait_for_idle(struct amdgpu_device *adev)
+static int gfx_v8_0_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -3210,9 +3222,10 @@ static int gfx_v8_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void gfx_v8_0_print_status(struct amdgpu_device *adev)
+static void gfx_v8_0_print_status(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "GFX 8.x registers\n");
 	dev_info(adev->dev, "  GRBM_STATUS=0x%08X\n",
@@ -3398,10 +3411,11 @@ static void gfx_v8_0_print_status(struct amdgpu_device *adev)
 	mutex_unlock(&adev->srbm_mutex);
 }
 
-static int gfx_v8_0_soft_reset(struct amdgpu_device *adev)
+static int gfx_v8_0_soft_reset(void *handle)
 {
 	u32 grbm_soft_reset = 0, srbm_soft_reset = 0;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* GRBM_STATUS */
 	tmp = RREG32(mmGRBM_STATUS);
@@ -3437,7 +3451,7 @@ static int gfx_v8_0_soft_reset(struct amdgpu_device *adev)
 						SRBM_SOFT_RESET, SOFT_RESET_GRBM, 1);
 
 	if (grbm_soft_reset || srbm_soft_reset) {
-		gfx_v8_0_print_status(adev);
+		gfx_v8_0_print_status((void *)adev);
 		/* stop the rlc */
 		gfx_v8_0_rlc_stop(adev);
 
@@ -3476,7 +3490,7 @@ static int gfx_v8_0_soft_reset(struct amdgpu_device *adev)
 		}
 		/* Wait a little for things to settle down */
 		udelay(50);
-		gfx_v8_0_print_status(adev);
+		gfx_v8_0_print_status((void *)adev);
 	}
 	return 0;
 }
@@ -3549,8 +3563,9 @@ static void gfx_v8_0_ring_emit_gds_switch(struct amdgpu_ring *ring,
 	amdgpu_ring_write(ring, (1 << (oa_size + oa_base)) - (1 << oa_base));
 }
 
-static int gfx_v8_0_early_init(struct amdgpu_device *adev)
+static int gfx_v8_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	adev->gfx.num_gfx_rings = GFX8_NUM_GFX_RINGS;
 	adev->gfx.num_compute_rings = GFX8_NUM_COMPUTE_RINGS;
@@ -3561,14 +3576,14 @@ static int gfx_v8_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gfx_v8_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int gfx_v8_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-static int gfx_v8_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int gfx_v8_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
@@ -4116,7 +4131,7 @@ static int gfx_v8_0_priv_inst_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-const struct amdgpu_ip_funcs gfx_v8_0_ip_funcs = {
+const struct amd_ip_funcs gfx_v8_0_ip_funcs = {
 	.early_init = gfx_v8_0_early_init,
 	.late_init = NULL,
 	.sw_init = gfx_v8_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.h b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.h
index be8a5f8..021e051 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v8_0.h
@@ -24,7 +24,7 @@
 #ifndef __GFX_V8_0_H__
 #define __GFX_V8_0_H__
 
-extern const struct amdgpu_ip_funcs gfx_v8_0_ip_funcs;
+extern const struct amd_ip_funcs gfx_v8_0_ip_funcs;
 
 uint64_t gfx_v8_0_get_gpu_clock_counter(struct amdgpu_device *adev);
 void gfx_v8_0_select_se_sh(struct amdgpu_device *adev, u32 se_num, u32 sh_num);
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
index ab09672..01cd6b2 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
@@ -812,8 +812,10 @@ static void gmc_v7_0_enable_hdp_ls(struct amdgpu_device *adev,
 		WREG32(mmHDP_MEM_POWER_LS, data);
 }
 
-static int gmc_v7_0_early_init(struct amdgpu_device *adev)
+static int gmc_v7_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	gmc_v7_0_set_gart_funcs(adev);
 	gmc_v7_0_set_irq_funcs(adev);
 
@@ -832,10 +834,11 @@ static int gmc_v7_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gmc_v7_0_sw_init(struct amdgpu_device *adev)
+static int gmc_v7_0_sw_init(void *handle)
 {
 	int r;
 	int dma_bits;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_gem_init(adev);
 	if (r)
@@ -911,9 +914,10 @@ static int gmc_v7_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gmc_v7_0_sw_fini(struct amdgpu_device *adev)
+static int gmc_v7_0_sw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->vm_manager.enabled) {
 		for (i = 0; i < AMDGPU_NUM_VM; ++i)
@@ -928,9 +932,10 @@ static int gmc_v7_0_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gmc_v7_0_hw_init(struct amdgpu_device *adev)
+static int gmc_v7_0_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	gmc_v7_0_mc_program(adev);
 
@@ -949,16 +954,19 @@ static int gmc_v7_0_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gmc_v7_0_hw_fini(struct amdgpu_device *adev)
+static int gmc_v7_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	gmc_v7_0_gart_disable(adev);
 
 	return 0;
 }
 
-static int gmc_v7_0_suspend(struct amdgpu_device *adev)
+static int gmc_v7_0_suspend(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->vm_manager.enabled) {
 		for (i = 0; i < AMDGPU_NUM_VM; ++i)
@@ -971,9 +979,10 @@ static int gmc_v7_0_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gmc_v7_0_resume(struct amdgpu_device *adev)
+static int gmc_v7_0_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = gmc_v7_0_hw_init(adev);
 	if (r)
@@ -991,8 +1000,9 @@ static int gmc_v7_0_resume(struct amdgpu_device *adev)
 	return r;
 }
 
-static bool gmc_v7_0_is_idle(struct amdgpu_device *adev)
+static bool gmc_v7_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & (SRBM_STATUS__MCB_BUSY_MASK | SRBM_STATUS__MCB_NON_DISPLAY_BUSY_MASK |
@@ -1002,10 +1012,11 @@ static bool gmc_v7_0_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int gmc_v7_0_wait_for_idle(struct amdgpu_device *adev)
+static int gmc_v7_0_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -1022,9 +1033,10 @@ static int gmc_v7_0_wait_for_idle(struct amdgpu_device *adev)
 
 }
 
-static void gmc_v7_0_print_status(struct amdgpu_device *adev)
+static void gmc_v7_0_print_status(void *handle)
 {
 	int i, j;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "GMC 8.x registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
@@ -1129,8 +1141,9 @@ static void gmc_v7_0_print_status(struct amdgpu_device *adev)
 		 RREG32(mmBIF_FB_EN));
 }
 
-static int gmc_v7_0_soft_reset(struct amdgpu_device *adev)
+static int gmc_v7_0_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_mode_mc_save save;
 	u32 srbm_soft_reset = 0;
 	u32 tmp = RREG32(mmSRBM_STATUS);
@@ -1147,7 +1160,7 @@ static int gmc_v7_0_soft_reset(struct amdgpu_device *adev)
 	}
 
 	if (srbm_soft_reset) {
-		gmc_v7_0_print_status(adev);
+		gmc_v7_0_print_status((void *)adev);
 
 		gmc_v7_0_mc_stop(adev, &save);
 		if (gmc_v7_0_wait_for_idle(adev)) {
@@ -1173,7 +1186,7 @@ static int gmc_v7_0_soft_reset(struct amdgpu_device *adev)
 		gmc_v7_0_mc_resume(adev, &save);
 		udelay(50);
 
-		gmc_v7_0_print_status(adev);
+		gmc_v7_0_print_status((void *)adev);
 	}
 
 	return 0;
@@ -1242,12 +1255,13 @@ static int gmc_v7_0_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int gmc_v7_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int gmc_v7_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	bool gate = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (state == AMDGPU_CG_STATE_GATE)
+	if (state == AMD_CG_STATE_GATE)
 		gate = true;
 
 	if (!(adev->flags & AMDGPU_IS_APU)) {
@@ -1261,13 +1275,13 @@ static int gmc_v7_0_set_clockgating_state(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int gmc_v7_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int gmc_v7_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs gmc_v7_0_ip_funcs = {
+const struct amd_ip_funcs gmc_v7_0_ip_funcs = {
 	.early_init = gmc_v7_0_early_init,
 	.late_init = NULL,
 	.sw_init = gmc_v7_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.h b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.h
index ab1a2fa..36fcbbc 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.h
@@ -24,7 +24,7 @@
 #ifndef __GMC_V7_0_H__
 #define __GMC_V7_0_H__
 
-extern const struct amdgpu_ip_funcs gmc_v7_0_ip_funcs;
+extern const struct amd_ip_funcs gmc_v7_0_ip_funcs;
 
 /* XXX these shouldn't be exported */
 void gmc_v7_0_mc_stop(struct amdgpu_device *adev,
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c
index f816165..675483a 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c
@@ -786,8 +786,10 @@ static void gmc_v8_0_vm_decode_fault(struct amdgpu_device *adev,
 	       "write" : "read", block, mc_client, mc_id);
 }
 
-static int gmc_v8_0_early_init(struct amdgpu_device *adev)
+static int gmc_v8_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	gmc_v8_0_set_gart_funcs(adev);
 	gmc_v8_0_set_irq_funcs(adev);
 
@@ -806,10 +808,11 @@ static int gmc_v8_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gmc_v8_0_sw_init(struct amdgpu_device *adev)
+static int gmc_v8_0_sw_init(void *handle)
 {
 	int r;
 	int dma_bits;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_gem_init(adev);
 	if (r)
@@ -885,9 +888,10 @@ static int gmc_v8_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gmc_v8_0_sw_fini(struct amdgpu_device *adev)
+static int gmc_v8_0_sw_fini(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->vm_manager.enabled) {
 		for (i = 0; i < AMDGPU_NUM_VM; ++i)
@@ -902,9 +906,10 @@ static int gmc_v8_0_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gmc_v8_0_hw_init(struct amdgpu_device *adev)
+static int gmc_v8_0_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	gmc_v8_0_init_golden_registers(adev);
 
@@ -925,16 +930,19 @@ static int gmc_v8_0_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int gmc_v8_0_hw_fini(struct amdgpu_device *adev)
+static int gmc_v8_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	gmc_v8_0_gart_disable(adev);
 
 	return 0;
 }
 
-static int gmc_v8_0_suspend(struct amdgpu_device *adev)
+static int gmc_v8_0_suspend(void *handle)
 {
 	int i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->vm_manager.enabled) {
 		for (i = 0; i < AMDGPU_NUM_VM; ++i)
@@ -947,9 +955,10 @@ static int gmc_v8_0_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int gmc_v8_0_resume(struct amdgpu_device *adev)
+static int gmc_v8_0_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = gmc_v8_0_hw_init(adev);
 	if (r)
@@ -967,8 +976,9 @@ static int gmc_v8_0_resume(struct amdgpu_device *adev)
 	return r;
 }
 
-static bool gmc_v8_0_is_idle(struct amdgpu_device *adev)
+static bool gmc_v8_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & (SRBM_STATUS__MCB_BUSY_MASK | SRBM_STATUS__MCB_NON_DISPLAY_BUSY_MASK |
@@ -978,10 +988,11 @@ static bool gmc_v8_0_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int gmc_v8_0_wait_for_idle(struct amdgpu_device *adev)
+static int gmc_v8_0_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -999,9 +1010,10 @@ static int gmc_v8_0_wait_for_idle(struct amdgpu_device *adev)
 
 }
 
-static void gmc_v8_0_print_status(struct amdgpu_device *adev)
+static void gmc_v8_0_print_status(void *handle)
 {
 	int i, j;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "GMC 8.x registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
@@ -1103,10 +1115,11 @@ static void gmc_v8_0_print_status(struct amdgpu_device *adev)
 		 RREG32(mmBIF_FB_EN));
 }
 
-static int gmc_v8_0_soft_reset(struct amdgpu_device *adev)
+static int gmc_v8_0_soft_reset(void *handle)
 {
 	struct amdgpu_mode_mc_save save;
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & SRBM_STATUS__VMC_BUSY_MASK)
@@ -1121,7 +1134,7 @@ static int gmc_v8_0_soft_reset(struct amdgpu_device *adev)
 	}
 
 	if (srbm_soft_reset) {
-		gmc_v8_0_print_status(adev);
+		gmc_v8_0_print_status((void *)adev);
 
 		gmc_v8_0_mc_stop(adev, &save);
 		if (gmc_v8_0_wait_for_idle(adev)) {
@@ -1147,7 +1160,7 @@ static int gmc_v8_0_soft_reset(struct amdgpu_device *adev)
 		gmc_v8_0_mc_resume(adev, &save);
 		udelay(50);
 
-		gmc_v8_0_print_status(adev);
+		gmc_v8_0_print_status((void *)adev);
 	}
 
 	return 0;
@@ -1217,21 +1230,19 @@ static int gmc_v8_0_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int gmc_v8_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int gmc_v8_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	/* XXX handled via the smc on VI */
-
 	return 0;
 }
 
-static int gmc_v8_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int gmc_v8_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs gmc_v8_0_ip_funcs = {
+const struct amd_ip_funcs gmc_v8_0_ip_funcs = {
 	.early_init = gmc_v8_0_early_init,
 	.late_init = NULL,
 	.sw_init = gmc_v8_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.h b/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.h
index 2dd7f80..9734360 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.h
@@ -24,7 +24,7 @@
 #ifndef __GMC_V8_0_H__
 #define __GMC_V8_0_H__
 
-extern const struct amdgpu_ip_funcs gmc_v8_0_ip_funcs;
+extern const struct amd_ip_funcs gmc_v8_0_ip_funcs;
 
 /* XXX these shouldn't be exported */
 void gmc_v8_0_mc_stop(struct amdgpu_device *adev,
diff --git a/drivers/gpu/drm/amd/amdgpu/iceland_dpm.c b/drivers/gpu/drm/amd/amdgpu/iceland_dpm.c
index 0688b88..4b773f2 100644
--- a/drivers/gpu/drm/amd/amdgpu/iceland_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/iceland_dpm.c
@@ -30,8 +30,10 @@ MODULE_FIRMWARE("amdgpu/topaz_smc.bin");
 
 static void iceland_dpm_set_funcs(struct amdgpu_device *adev);
 
-static int iceland_dpm_early_init(struct amdgpu_device *adev)
+static int iceland_dpm_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	iceland_dpm_set_funcs(adev);
 
 	return 0;
@@ -56,9 +58,10 @@ out:
 	return err;
 }
 
-static int iceland_dpm_sw_init(struct amdgpu_device *adev)
+static int iceland_dpm_sw_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	ret = iceland_dpm_init_microcode(adev);
 	if (ret)
@@ -67,14 +70,15 @@ static int iceland_dpm_sw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int iceland_dpm_sw_fini(struct amdgpu_device *adev)
+static int iceland_dpm_sw_fini(void *handle)
 {
 	return 0;
 }
 
-static int iceland_dpm_hw_init(struct amdgpu_device *adev)
+static int iceland_dpm_hw_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	mutex_lock(&adev->pm.mutex);
 
@@ -99,41 +103,47 @@ fail:
 	return -EINVAL;
 }
 
-static int iceland_dpm_hw_fini(struct amdgpu_device *adev)
+static int iceland_dpm_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	mutex_lock(&adev->pm.mutex);
 	iceland_smu_fini(adev);
 	mutex_unlock(&adev->pm.mutex);
 	return 0;
 }
 
-static int iceland_dpm_suspend(struct amdgpu_device *adev)
+static int iceland_dpm_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	iceland_dpm_hw_fini(adev);
 
 	return 0;
 }
 
-static int iceland_dpm_resume(struct amdgpu_device *adev)
+static int iceland_dpm_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	iceland_dpm_hw_init(adev);
 
 	return 0;
 }
 
-static int iceland_dpm_set_clockgating_state(struct amdgpu_device *adev,
-			enum amdgpu_clockgating_state state)
+static int iceland_dpm_set_clockgating_state(void *handle,
+			enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int iceland_dpm_set_powergating_state(struct amdgpu_device *adev,
-			enum amdgpu_powergating_state state)
+static int iceland_dpm_set_powergating_state(void *handle,
+			enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs iceland_dpm_ip_funcs = {
+const struct amd_ip_funcs iceland_dpm_ip_funcs = {
 	.early_init = iceland_dpm_early_init,
 	.late_init = NULL,
 	.sw_init = iceland_dpm_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/iceland_ih.c b/drivers/gpu/drm/amd/amdgpu/iceland_ih.c
index 2de8adf..779532d 100644
--- a/drivers/gpu/drm/amd/amdgpu/iceland_ih.c
+++ b/drivers/gpu/drm/amd/amdgpu/iceland_ih.c
@@ -250,15 +250,18 @@ static void iceland_ih_set_rptr(struct amdgpu_device *adev)
 	WREG32(mmIH_RB_RPTR, adev->irq.ih.rptr);
 }
 
-static int iceland_ih_early_init(struct amdgpu_device *adev)
+static int iceland_ih_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	iceland_ih_set_interrupt_funcs(adev);
 	return 0;
 }
 
-static int iceland_ih_sw_init(struct amdgpu_device *adev)
+static int iceland_ih_sw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_ih_ring_init(adev, 64 * 1024, false);
 	if (r)
@@ -269,17 +272,20 @@ static int iceland_ih_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int iceland_ih_sw_fini(struct amdgpu_device *adev)
+static int iceland_ih_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_irq_fini(adev);
 	amdgpu_ih_ring_fini(adev);
 
 	return 0;
 }
 
-static int iceland_ih_hw_init(struct amdgpu_device *adev)
+static int iceland_ih_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = iceland_ih_irq_init(adev);
 	if (r)
@@ -288,25 +294,32 @@ static int iceland_ih_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int iceland_ih_hw_fini(struct amdgpu_device *adev)
+static int iceland_ih_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	iceland_ih_irq_disable(adev);
 
 	return 0;
 }
 
-static int iceland_ih_suspend(struct amdgpu_device *adev)
+static int iceland_ih_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return iceland_ih_hw_fini(adev);
 }
 
-static int iceland_ih_resume(struct amdgpu_device *adev)
+static int iceland_ih_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return iceland_ih_hw_init(adev);
 }
 
-static bool iceland_ih_is_idle(struct amdgpu_device *adev)
+static bool iceland_ih_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (REG_GET_FIELD(tmp, SRBM_STATUS, IH_BUSY))
@@ -315,10 +328,11 @@ static bool iceland_ih_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int iceland_ih_wait_for_idle(struct amdgpu_device *adev)
+static int iceland_ih_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -330,8 +344,10 @@ static int iceland_ih_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void iceland_ih_print_status(struct amdgpu_device *adev)
+static void iceland_ih_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "ICELAND IH registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
 		RREG32(mmSRBM_STATUS));
@@ -357,9 +373,10 @@ static void iceland_ih_print_status(struct amdgpu_device *adev)
 		 RREG32(mmIH_RB_WPTR));
 }
 
-static int iceland_ih_soft_reset(struct amdgpu_device *adev)
+static int iceland_ih_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & SRBM_STATUS__IH_BUSY_MASK)
@@ -367,7 +384,7 @@ static int iceland_ih_soft_reset(struct amdgpu_device *adev)
 						SOFT_RESET_IH, 1);
 
 	if (srbm_soft_reset) {
-		iceland_ih_print_status(adev);
+		iceland_ih_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -384,27 +401,25 @@ static int iceland_ih_soft_reset(struct amdgpu_device *adev)
 		/* Wait a little for things to settle down */
 		udelay(50);
 
-		iceland_ih_print_status(adev);
+		iceland_ih_print_status((void *)adev);
 	}
 
 	return 0;
 }
 
-static int iceland_ih_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int iceland_ih_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	// TODO
 	return 0;
 }
 
-static int iceland_ih_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int iceland_ih_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
-	// TODO
 	return 0;
 }
 
-const struct amdgpu_ip_funcs iceland_ih_ip_funcs = {
+const struct amd_ip_funcs iceland_ih_ip_funcs = {
 	.early_init = iceland_ih_early_init,
 	.late_init = NULL,
 	.sw_init = iceland_ih_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/iceland_ih.h b/drivers/gpu/drm/amd/amdgpu/iceland_ih.h
index d001895..57558cd 100644
--- a/drivers/gpu/drm/amd/amdgpu/iceland_ih.h
+++ b/drivers/gpu/drm/amd/amdgpu/iceland_ih.h
@@ -24,6 +24,6 @@
 #ifndef __ICELAND_IH_H__
 #define __ICELAND_IH_H__
 
-extern const struct amdgpu_ip_funcs iceland_ih_ip_funcs;
+extern const struct amd_ip_funcs iceland_ih_ip_funcs;
 
 #endif /* __ICELAND_IH_H__ */
diff --git a/drivers/gpu/drm/amd/amdgpu/kv_dpm.c b/drivers/gpu/drm/amd/amdgpu/kv_dpm.c
index cd90241..94ec04a 100644
--- a/drivers/gpu/drm/amd/amdgpu/kv_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/kv_dpm.c
@@ -1552,8 +1552,8 @@ static int kv_update_vce_dpm(struct amdgpu_device *adev,
 	if (amdgpu_new_state->evclk > 0 && amdgpu_current_state->evclk == 0) {
 		kv_dpm_powergate_vce(adev, false);
 		/* turn the clocks on when encoding */
-		ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_VCE,
-						    AMDGPU_CG_STATE_UNGATE);
+		ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_VCE,
+						    AMD_CG_STATE_UNGATE);
 		if (ret)
 			return ret;
 		if (pi->caps_stable_p_state)
@@ -1579,8 +1579,8 @@ static int kv_update_vce_dpm(struct amdgpu_device *adev,
 	} else if (amdgpu_new_state->evclk == 0 && amdgpu_current_state->evclk > 0) {
 		kv_enable_vce_dpm(adev, false);
 		/* turn the clocks off when not encoding */
-		ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_VCE,
-						    AMDGPU_CG_STATE_GATE);
+		ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_VCE,
+						    AMD_CG_STATE_GATE);
 		if (ret)
 			return ret;
 		kv_dpm_powergate_vce(adev, true);
@@ -1697,11 +1697,11 @@ static void kv_dpm_powergate_uvd(struct amdgpu_device *adev, bool gate)
 	if (gate) {
 		if (pi->caps_uvd_pg) {
 			/* disable clockgating so we can properly shut down the block */
-			ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_CG_STATE_UNGATE);
+			ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_CG_STATE_UNGATE);
 			/* shutdown the UVD block */
-			ret = amdgpu_set_powergating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_PG_STATE_GATE);
+			ret = amdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_PG_STATE_GATE);
 			/* XXX: check for errors */
 		}
 		kv_update_uvd_dpm(adev, gate);
@@ -1713,11 +1713,11 @@ static void kv_dpm_powergate_uvd(struct amdgpu_device *adev, bool gate)
 			/* power on the UVD block */
 			amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_UVDPowerON);
 			/* re-init the UVD block */
-			ret = amdgpu_set_powergating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_PG_STATE_UNGATE);
+			ret = amdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_PG_STATE_UNGATE);
 			/* enable clockgating. hw will dynamically gate/ungate clocks on the fly */
-			ret = amdgpu_set_clockgating_state(adev, AMDGPU_IP_BLOCK_TYPE_UVD,
-							    AMDGPU_CG_STATE_GATE);
+			ret = amdgpu_set_clockgating_state(adev, AMD_IP_BLOCK_TYPE_UVD,
+							    AMD_CG_STATE_GATE);
 			/* XXX: check for errors */
 		}
 		kv_update_uvd_dpm(adev, gate);
@@ -1737,8 +1737,8 @@ static void kv_dpm_powergate_vce(struct amdgpu_device *adev, bool gate)
 	if (gate) {
 		if (pi->caps_vce_pg) {
 			/* shutdown the VCE block */
-			ret = amdgpu_set_powergating_state(adev, AMDGPU_IP_BLOCK_TYPE_VCE,
-							    AMDGPU_PG_STATE_GATE);
+			ret = amdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_VCE,
+							    AMD_PG_STATE_GATE);
 			/* XXX: check for errors */
 			/* power off the VCE block */
 			amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_VCEPowerOFF);
@@ -1748,8 +1748,8 @@ static void kv_dpm_powergate_vce(struct amdgpu_device *adev, bool gate)
 			/* power on the VCE block */
 			amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_VCEPowerON);
 			/* re-init the VCE block */
-			ret = amdgpu_set_powergating_state(adev, AMDGPU_IP_BLOCK_TYPE_VCE,
-							    AMDGPU_PG_STATE_UNGATE);
+			ret = amdgpu_set_powergating_state(adev, AMD_IP_BLOCK_TYPE_VCE,
+							    AMD_PG_STATE_UNGATE);
 			/* XXX: check for errors */
 		}
 	}
@@ -2981,20 +2981,21 @@ static int kv_dpm_get_temp(struct amdgpu_device *adev)
 	return actual_temp;
 }
 
-static int kv_dpm_early_init(struct amdgpu_device *adev)
+static int kv_dpm_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	kv_dpm_set_dpm_funcs(adev);
 	kv_dpm_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int kv_dpm_late_init(struct amdgpu_device *adev)
+static int kv_dpm_late_init(void *handle)
 {
-	if (!amdgpu_dpm)
-		return 0;
-
 	/* powerdown unused blocks for now */
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	kv_dpm_powergate_acp(adev, true);
 	kv_dpm_powergate_samu(adev, true);
 	kv_dpm_powergate_vce(adev, true);
@@ -3003,9 +3004,10 @@ static int kv_dpm_late_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int kv_dpm_sw_init(struct amdgpu_device *adev)
+static int kv_dpm_sw_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	ret = amdgpu_irq_add_id(adev, 230, &adev->pm.dpm.thermal.irq);
 	if (ret)
@@ -3051,8 +3053,10 @@ dpm_failed:
 	return ret;
 }
 
-static int kv_dpm_sw_fini(struct amdgpu_device *adev)
+static int kv_dpm_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	mutex_lock(&adev->pm.mutex);
 	amdgpu_pm_sysfs_fini(adev);
 	kv_dpm_fini(adev);
@@ -3061,12 +3065,10 @@ static int kv_dpm_sw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int kv_dpm_hw_init(struct amdgpu_device *adev)
+static int kv_dpm_hw_init(void *handle)
 {
 	int ret;
-
-	if (!amdgpu_dpm)
-		return 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	mutex_lock(&adev->pm.mutex);
 	kv_dpm_setup_asic(adev);
@@ -3080,8 +3082,10 @@ static int kv_dpm_hw_init(struct amdgpu_device *adev)
 	return ret;
 }
 
-static int kv_dpm_hw_fini(struct amdgpu_device *adev)
+static int kv_dpm_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (adev->pm.dpm_enabled) {
 		mutex_lock(&adev->pm.mutex);
 		kv_dpm_disable(adev);
@@ -3091,8 +3095,10 @@ static int kv_dpm_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int kv_dpm_suspend(struct amdgpu_device *adev)
+static int kv_dpm_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	if (adev->pm.dpm_enabled) {
 		mutex_lock(&adev->pm.mutex);
 		/* disable dpm */
@@ -3104,9 +3110,10 @@ static int kv_dpm_suspend(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int kv_dpm_resume(struct amdgpu_device *adev)
+static int kv_dpm_resume(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->pm.dpm_enabled) {
 		/* asic init will reset to the boot state */
@@ -3124,20 +3131,20 @@ static int kv_dpm_resume(struct amdgpu_device *adev)
 	return 0;
 }
 
-static bool kv_dpm_is_idle(struct amdgpu_device *adev)
+static bool kv_dpm_is_idle(void *handle)
 {
-	/* XXX */
 	return true;
 }
 
-static int kv_dpm_wait_for_idle(struct amdgpu_device *adev)
+static int kv_dpm_wait_for_idle(void *handle)
 {
-	/* XXX */
 	return 0;
 }
 
-static void kv_dpm_print_status(struct amdgpu_device *adev)
+static void kv_dpm_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "KV/KB DPM registers\n");
 	dev_info(adev->dev, "  DIDT_SQ_CTRL0=0x%08X\n",
 		 RREG32_DIDT(ixDIDT_SQ_CTRL0));
@@ -3191,7 +3198,7 @@ static void kv_dpm_print_status(struct amdgpu_device *adev)
 		 RREG32(mmSMC_IND_ACCESS_CNTL));
 }
 
-static int kv_dpm_soft_reset(struct amdgpu_device *adev)
+static int kv_dpm_soft_reset(void *handle)
 {
 	return 0;
 }
@@ -3274,19 +3281,19 @@ static int kv_dpm_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int kv_dpm_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int kv_dpm_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int kv_dpm_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int kv_dpm_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs kv_dpm_ip_funcs = {
+const struct amd_ip_funcs kv_dpm_ip_funcs = {
 	.early_init = kv_dpm_early_init,
 	.late_init = kv_dpm_late_init,
 	.sw_init = kv_dpm_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c b/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c
index 99b8b32..64de8f6 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c
@@ -955,8 +955,10 @@ static void sdma_v2_4_ring_emit_vm_flush(struct amdgpu_ring *ring,
 			  SDMA_PKT_POLL_REGMEM_DW5_INTERVAL(10)); /* retry count, poll interval */
 }
 
-static int sdma_v2_4_early_init(struct amdgpu_device *adev)
+static int sdma_v2_4_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	sdma_v2_4_set_ring_funcs(adev);
 	sdma_v2_4_set_buffer_funcs(adev);
 	sdma_v2_4_set_vm_pte_funcs(adev);
@@ -965,10 +967,11 @@ static int sdma_v2_4_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int sdma_v2_4_sw_init(struct amdgpu_device *adev)
+static int sdma_v2_4_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* SDMA trap event */
 	r = amdgpu_irq_add_id(adev, 224, &adev->sdma_trap_irq);
@@ -1020,17 +1023,20 @@ static int sdma_v2_4_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int sdma_v2_4_sw_fini(struct amdgpu_device *adev)
+static int sdma_v2_4_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_ring_fini(&adev->sdma[0].ring);
 	amdgpu_ring_fini(&adev->sdma[1].ring);
 
 	return 0;
 }
 
-static int sdma_v2_4_hw_init(struct amdgpu_device *adev)
+static int sdma_v2_4_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	sdma_v2_4_init_golden_registers(adev);
 
@@ -1041,27 +1047,32 @@ static int sdma_v2_4_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int sdma_v2_4_hw_fini(struct amdgpu_device *adev)
+static int sdma_v2_4_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	sdma_v2_4_enable(adev, false);
 
 	return 0;
 }
 
-static int sdma_v2_4_suspend(struct amdgpu_device *adev)
+static int sdma_v2_4_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	return sdma_v2_4_hw_fini(adev);
 }
 
-static int sdma_v2_4_resume(struct amdgpu_device *adev)
+static int sdma_v2_4_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	return sdma_v2_4_hw_init(adev);
 }
 
-static bool sdma_v2_4_is_idle(struct amdgpu_device *adev)
+static bool sdma_v2_4_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS2);
 
 	if (tmp & (SRBM_STATUS2__SDMA_BUSY_MASK |
@@ -1071,10 +1082,11 @@ static bool sdma_v2_4_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int sdma_v2_4_wait_for_idle(struct amdgpu_device *adev)
+static int sdma_v2_4_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		tmp = RREG32(mmSRBM_STATUS2) & (SRBM_STATUS2__SDMA_BUSY_MASK |
@@ -1087,9 +1099,10 @@ static int sdma_v2_4_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void sdma_v2_4_print_status(struct amdgpu_device *adev)
+static void sdma_v2_4_print_status(void *handle)
 {
 	int i, j;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "VI SDMA registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS2=0x%08X\n",
@@ -1133,9 +1146,10 @@ static void sdma_v2_4_print_status(struct amdgpu_device *adev)
 	}
 }
 
-static int sdma_v2_4_soft_reset(struct amdgpu_device *adev)
+static int sdma_v2_4_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS2);
 
 	if (tmp & SRBM_STATUS2__SDMA_BUSY_MASK) {
@@ -1154,7 +1168,7 @@ static int sdma_v2_4_soft_reset(struct amdgpu_device *adev)
 	}
 
 	if (srbm_soft_reset) {
-		sdma_v2_4_print_status(adev);
+		sdma_v2_4_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -1171,7 +1185,7 @@ static int sdma_v2_4_soft_reset(struct amdgpu_device *adev)
 		/* Wait a little for things to settle down */
 		udelay(50);
 
-		sdma_v2_4_print_status(adev);
+		sdma_v2_4_print_status((void *)adev);
 	}
 
 	return 0;
@@ -1272,21 +1286,20 @@ static int sdma_v2_4_process_illegal_inst_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int sdma_v2_4_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int sdma_v2_4_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	/* XXX handled via the smc on VI */
-
 	return 0;
 }
 
-static int sdma_v2_4_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int sdma_v2_4_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs sdma_v2_4_ip_funcs = {
+const struct amd_ip_funcs sdma_v2_4_ip_funcs = {
 	.early_init = sdma_v2_4_early_init,
 	.late_init = NULL,
 	.sw_init = sdma_v2_4_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.h b/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.h
index 6cdf894..07349f5 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.h
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.h
@@ -24,6 +24,6 @@
 #ifndef __SDMA_V2_4_H__
 #define __SDMA_V2_4_H__
 
-extern const struct amdgpu_ip_funcs sdma_v2_4_ip_funcs;
+extern const struct amd_ip_funcs sdma_v2_4_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.c b/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.c
index 86a5278..bf3cefc 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.c
@@ -1018,8 +1018,10 @@ static void sdma_v3_0_ring_emit_vm_flush(struct amdgpu_ring *ring,
 			  SDMA_PKT_POLL_REGMEM_DW5_INTERVAL(10)); /* retry count, poll interval */
 }
 
-static int sdma_v3_0_early_init(struct amdgpu_device *adev)
+static int sdma_v3_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	sdma_v3_0_set_ring_funcs(adev);
 	sdma_v3_0_set_buffer_funcs(adev);
 	sdma_v3_0_set_vm_pte_funcs(adev);
@@ -1028,10 +1030,11 @@ static int sdma_v3_0_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int sdma_v3_0_sw_init(struct amdgpu_device *adev)
+static int sdma_v3_0_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* SDMA trap event */
 	r = amdgpu_irq_add_id(adev, 224, &adev->sdma_trap_irq);
@@ -1085,17 +1088,20 @@ static int sdma_v3_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int sdma_v3_0_sw_fini(struct amdgpu_device *adev)
+static int sdma_v3_0_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_ring_fini(&adev->sdma[0].ring);
 	amdgpu_ring_fini(&adev->sdma[1].ring);
 
 	return 0;
 }
 
-static int sdma_v3_0_hw_init(struct amdgpu_device *adev)
+static int sdma_v3_0_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	sdma_v3_0_init_golden_registers(adev);
 
@@ -1106,27 +1112,32 @@ static int sdma_v3_0_hw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int sdma_v3_0_hw_fini(struct amdgpu_device *adev)
+static int sdma_v3_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	sdma_v3_0_enable(adev, false);
 
 	return 0;
 }
 
-static int sdma_v3_0_suspend(struct amdgpu_device *adev)
+static int sdma_v3_0_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	return sdma_v3_0_hw_fini(adev);
 }
 
-static int sdma_v3_0_resume(struct amdgpu_device *adev)
+static int sdma_v3_0_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	return sdma_v3_0_hw_init(adev);
 }
 
-static bool sdma_v3_0_is_idle(struct amdgpu_device *adev)
+static bool sdma_v3_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS2);
 
 	if (tmp & (SRBM_STATUS2__SDMA_BUSY_MASK |
@@ -1136,10 +1147,11 @@ static bool sdma_v3_0_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int sdma_v3_0_wait_for_idle(struct amdgpu_device *adev)
+static int sdma_v3_0_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		tmp = RREG32(mmSRBM_STATUS2) & (SRBM_STATUS2__SDMA_BUSY_MASK |
@@ -1152,9 +1164,10 @@ static int sdma_v3_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void sdma_v3_0_print_status(struct amdgpu_device *adev)
+static void sdma_v3_0_print_status(void *handle)
 {
 	int i, j;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	dev_info(adev->dev, "VI SDMA registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS2=0x%08X\n",
@@ -1200,9 +1213,10 @@ static void sdma_v3_0_print_status(struct amdgpu_device *adev)
 	}
 }
 
-static int sdma_v3_0_soft_reset(struct amdgpu_device *adev)
+static int sdma_v3_0_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS2);
 
 	if (tmp & SRBM_STATUS2__SDMA_BUSY_MASK) {
@@ -1221,7 +1235,7 @@ static int sdma_v3_0_soft_reset(struct amdgpu_device *adev)
 	}
 
 	if (srbm_soft_reset) {
-		sdma_v3_0_print_status(adev);
+		sdma_v3_0_print_status((void *)adev);
 
 		tmp = RREG32(mmSRBM_SOFT_RESET);
 		tmp |= srbm_soft_reset;
@@ -1238,7 +1252,7 @@ static int sdma_v3_0_soft_reset(struct amdgpu_device *adev)
 		/* Wait a little for things to settle down */
 		udelay(50);
 
-		sdma_v3_0_print_status(adev);
+		sdma_v3_0_print_status((void *)adev);
 	}
 
 	return 0;
@@ -1339,21 +1353,19 @@ static int sdma_v3_0_process_illegal_inst_irq(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int sdma_v3_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int sdma_v3_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	/* XXX handled via the smc on VI */
-
 	return 0;
 }
 
-static int sdma_v3_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int sdma_v3_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs sdma_v3_0_ip_funcs = {
+const struct amd_ip_funcs sdma_v3_0_ip_funcs = {
 	.early_init = sdma_v3_0_early_init,
 	.late_init = NULL,
 	.sw_init = sdma_v3_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.h b/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.h
index 85bf2ac..0cb9698 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v3_0.h
@@ -24,6 +24,6 @@
 #ifndef __SDMA_V3_0_H__
 #define __SDMA_V3_0_H__
 
-extern const struct amdgpu_ip_funcs sdma_v3_0_ip_funcs;
+extern const struct amd_ip_funcs sdma_v3_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/tonga_dpm.c b/drivers/gpu/drm/amd/amdgpu/tonga_dpm.c
index cf97d49..2d5b1bd 100644
--- a/drivers/gpu/drm/amd/amdgpu/tonga_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/tonga_dpm.c
@@ -30,8 +30,10 @@ MODULE_FIRMWARE("amdgpu/tonga_smc.bin");
 
 static void tonga_dpm_set_funcs(struct amdgpu_device *adev);
 
-static int tonga_dpm_early_init(struct amdgpu_device *adev)
+static int tonga_dpm_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	tonga_dpm_set_funcs(adev);
 
 	return 0;
@@ -41,7 +43,6 @@ static int tonga_dpm_init_microcode(struct amdgpu_device *adev)
 {
 	char fw_name[30] = "amdgpu/tonga_smc.bin";
 	int err;
-
 	err = request_firmware(&adev->pm.fw, fw_name, adev->dev);
 	if (err)
 		goto out;
@@ -56,9 +57,10 @@ out:
 	return err;
 }
 
-static int tonga_dpm_sw_init(struct amdgpu_device *adev)
+static int tonga_dpm_sw_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	ret = tonga_dpm_init_microcode(adev);
 	if (ret)
@@ -67,14 +69,15 @@ static int tonga_dpm_sw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int tonga_dpm_sw_fini(struct amdgpu_device *adev)
+static int tonga_dpm_sw_fini(void *handle)
 {
 	return 0;
 }
 
-static int tonga_dpm_hw_init(struct amdgpu_device *adev)
+static int tonga_dpm_hw_init(void *handle)
 {
 	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	mutex_lock(&adev->pm.mutex);
 
@@ -99,41 +102,47 @@ fail:
 	return -EINVAL;
 }
 
-static int tonga_dpm_hw_fini(struct amdgpu_device *adev)
+static int tonga_dpm_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	mutex_lock(&adev->pm.mutex);
 	tonga_smu_fini(adev);
 	mutex_unlock(&adev->pm.mutex);
 	return 0;
 }
 
-static int tonga_dpm_suspend(struct amdgpu_device *adev)
+static int tonga_dpm_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	tonga_dpm_hw_fini(adev);
 
 	return 0;
 }
 
-static int tonga_dpm_resume(struct amdgpu_device *adev)
+static int tonga_dpm_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	tonga_dpm_hw_init(adev);
 
 	return 0;
 }
 
-static int tonga_dpm_set_clockgating_state(struct amdgpu_device *adev,
-			enum amdgpu_clockgating_state state)
+static int tonga_dpm_set_clockgating_state(void *handle,
+			enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int tonga_dpm_set_powergating_state(struct amdgpu_device *adev,
-			enum amdgpu_powergating_state state)
+static int tonga_dpm_set_powergating_state(void *handle,
+			enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs tonga_dpm_ip_funcs = {
+const struct amd_ip_funcs tonga_dpm_ip_funcs = {
 	.early_init = tonga_dpm_early_init,
 	.late_init = NULL,
 	.sw_init = tonga_dpm_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/tonga_ih.c b/drivers/gpu/drm/amd/amdgpu/tonga_ih.c
index cff1b8b..743c372 100644
--- a/drivers/gpu/drm/amd/amdgpu/tonga_ih.c
+++ b/drivers/gpu/drm/amd/amdgpu/tonga_ih.c
@@ -270,15 +270,18 @@ static void tonga_ih_set_rptr(struct amdgpu_device *adev)
 	}
 }
 
-static int tonga_ih_early_init(struct amdgpu_device *adev)
+static int tonga_ih_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	tonga_ih_set_interrupt_funcs(adev);
 	return 0;
 }
 
-static int tonga_ih_sw_init(struct amdgpu_device *adev)
+static int tonga_ih_sw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_ih_ring_init(adev, 4 * 1024, true);
 	if (r)
@@ -292,17 +295,20 @@ static int tonga_ih_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int tonga_ih_sw_fini(struct amdgpu_device *adev)
+static int tonga_ih_sw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	amdgpu_irq_fini(adev);
 	amdgpu_ih_ring_fini(adev);
 
 	return 0;
 }
 
-static int tonga_ih_hw_init(struct amdgpu_device *adev)
+static int tonga_ih_hw_init(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = tonga_ih_irq_init(adev);
 	if (r)
@@ -311,25 +317,32 @@ static int tonga_ih_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int tonga_ih_hw_fini(struct amdgpu_device *adev)
+static int tonga_ih_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	tonga_ih_irq_disable(adev);
 
 	return 0;
 }
 
-static int tonga_ih_suspend(struct amdgpu_device *adev)
+static int tonga_ih_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return tonga_ih_hw_fini(adev);
 }
 
-static int tonga_ih_resume(struct amdgpu_device *adev)
+static int tonga_ih_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return tonga_ih_hw_init(adev);
 }
 
-static bool tonga_ih_is_idle(struct amdgpu_device *adev)
+static bool tonga_ih_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (REG_GET_FIELD(tmp, SRBM_STATUS, IH_BUSY))
@@ -338,10 +351,11 @@ static bool tonga_ih_is_idle(struct amdgpu_device *adev)
 	return true;
 }
 
-static int tonga_ih_wait_for_idle(struct amdgpu_device *adev)
+static int tonga_ih_wait_for_idle(void *handle)
 {
 	unsigned i;
 	u32 tmp;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		/* read MC_STATUS */
@@ -353,8 +367,10 @@ static int tonga_ih_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static void tonga_ih_print_status(struct amdgpu_device *adev)
+static void tonga_ih_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "TONGA IH registers\n");
 	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
 		RREG32(mmSRBM_STATUS));
@@ -380,9 +396,10 @@ static void tonga_ih_print_status(struct amdgpu_device *adev)
 		 RREG32(mmIH_RB_WPTR));
 }
 
-static int tonga_ih_soft_reset(struct amdgpu_device *adev)
+static int tonga_ih_soft_reset(void *handle)
 {
 	u32 srbm_soft_reset = 0;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	u32 tmp = RREG32(mmSRBM_STATUS);
 
 	if (tmp & SRBM_STATUS__IH_BUSY_MASK)
@@ -413,21 +430,19 @@ static int tonga_ih_soft_reset(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int tonga_ih_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int tonga_ih_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	// TODO
 	return 0;
 }
 
-static int tonga_ih_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int tonga_ih_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
-	// TODO
 	return 0;
 }
 
-const struct amdgpu_ip_funcs tonga_ih_ip_funcs = {
+const struct amd_ip_funcs tonga_ih_ip_funcs = {
 	.early_init = tonga_ih_early_init,
 	.late_init = NULL,
 	.sw_init = tonga_ih_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/tonga_ih.h b/drivers/gpu/drm/amd/amdgpu/tonga_ih.h
index 7c9bae8..7392d70 100644
--- a/drivers/gpu/drm/amd/amdgpu/tonga_ih.h
+++ b/drivers/gpu/drm/amd/amdgpu/tonga_ih.h
@@ -24,6 +24,6 @@
 #ifndef __TONGA_IH_H__
 #define __TONGA_IH_H__
 
-extern const struct amdgpu_ip_funcs tonga_ih_ip_funcs;
+extern const struct amd_ip_funcs tonga_ih_ip_funcs;
 
 #endif /* __CZ_IH_H__ */
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c b/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c
index 6e4cb60..292932a 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c
@@ -83,17 +83,20 @@ static void uvd_v4_2_ring_set_wptr(struct amdgpu_ring *ring)
 	WREG32(mmUVD_RBC_RB_WPTR, ring->wptr);
 }
 
-static int uvd_v4_2_early_init(struct amdgpu_device *adev)
+static int uvd_v4_2_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	uvd_v4_2_set_ring_funcs(adev);
 	uvd_v4_2_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int uvd_v4_2_sw_init(struct amdgpu_device *adev)
+static int uvd_v4_2_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int r;
 
 	/* UVD TRAP */
@@ -117,9 +120,10 @@ static int uvd_v4_2_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int uvd_v4_2_sw_fini(struct amdgpu_device *adev)
+static int uvd_v4_2_sw_fini(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_uvd_suspend(adev);
 	if (r)
@@ -139,8 +143,9 @@ static int uvd_v4_2_sw_fini(struct amdgpu_device *adev)
  *
  * Initialize the hardware, boot up the VCPU and do some testing
  */
-static int uvd_v4_2_hw_init(struct amdgpu_device *adev)
+static int uvd_v4_2_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring = &adev->uvd.ring;
 	uint32_t tmp;
 	int r;
@@ -203,8 +208,9 @@ done:
  *
  * Stop the UVD block, mark ring as not ready any more
  */
-static int uvd_v4_2_hw_fini(struct amdgpu_device *adev)
+static int uvd_v4_2_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring = &adev->uvd.ring;
 
 	uvd_v4_2_stop(adev);
@@ -213,9 +219,10 @@ static int uvd_v4_2_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int uvd_v4_2_suspend(struct amdgpu_device *adev)
+static int uvd_v4_2_suspend(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = uvd_v4_2_hw_fini(adev);
 	if (r)
@@ -228,9 +235,10 @@ static int uvd_v4_2_suspend(struct amdgpu_device *adev)
 	return r;
 }
 
-static int uvd_v4_2_resume(struct amdgpu_device *adev)
+static int uvd_v4_2_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_uvd_resume(adev);
 	if (r)
@@ -662,14 +670,17 @@ static void uvd_v4_2_init_cg(struct amdgpu_device *adev)
 	}
 }
 
-static bool uvd_v4_2_is_idle(struct amdgpu_device *adev)
+static bool uvd_v4_2_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);
 }
 
-static int uvd_v4_2_wait_for_idle(struct amdgpu_device *adev)
+static int uvd_v4_2_wait_for_idle(void *handle)
 {
 	unsigned i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		if (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))
@@ -678,8 +689,10 @@ static int uvd_v4_2_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static int uvd_v4_2_soft_reset(struct amdgpu_device *adev)
+static int uvd_v4_2_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	uvd_v4_2_stop(adev);
 
 	WREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,
@@ -689,8 +702,9 @@ static int uvd_v4_2_soft_reset(struct amdgpu_device *adev)
 	return uvd_v4_2_start(adev);
 }
 
-static void uvd_v4_2_print_status(struct amdgpu_device *adev)
+static void uvd_v4_2_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	dev_info(adev->dev, "UVD 4.2 registers\n");
 	dev_info(adev->dev, "  UVD_SEMA_ADDR_LOW=0x%08X\n",
 		 RREG32(mmUVD_SEMA_ADDR_LOW));
@@ -810,12 +824,13 @@ static int uvd_v4_2_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int uvd_v4_2_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int uvd_v4_2_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	bool gate = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (state == AMDGPU_CG_STATE_GATE)
+	if (state == AMD_CG_STATE_GATE)
 		gate = true;
 
 	uvd_v4_2_enable_mgcg(adev, gate);
@@ -823,8 +838,8 @@ static int uvd_v4_2_set_clockgating_state(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int uvd_v4_2_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int uvd_v4_2_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	/* This doesn't actually powergate the UVD block.
 	 * That's done in the dpm code via the SMC.  This
@@ -833,7 +848,9 @@ static int uvd_v4_2_set_powergating_state(struct amdgpu_device *adev,
 	 * revisit this when there is a cleaner line between
 	 * the smc and the hw blocks
 	 */
-	if (state == AMDGPU_PG_STATE_GATE) {
+	 struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (state == AMD_PG_STATE_GATE) {
 		uvd_v4_2_stop(adev);
 		return 0;
 	} else {
@@ -841,7 +858,7 @@ static int uvd_v4_2_set_powergating_state(struct amdgpu_device *adev,
 	}
 }
 
-const struct amdgpu_ip_funcs uvd_v4_2_ip_funcs = {
+const struct amd_ip_funcs uvd_v4_2_ip_funcs = {
 	.early_init = uvd_v4_2_early_init,
 	.late_init = NULL,
 	.sw_init = uvd_v4_2_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.h b/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.h
index 323a6d8..0a615dd 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.h
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v4_2.h
@@ -24,6 +24,6 @@
 #ifndef __UVD_V4_2_H__
 #define __UVD_V4_2_H__
 
-extern const struct amdgpu_ip_funcs uvd_v4_2_ip_funcs;
+extern const struct amd_ip_funcs uvd_v4_2_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c b/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c
index f3b3026..004c564 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c
@@ -79,17 +79,20 @@ static void uvd_v5_0_ring_set_wptr(struct amdgpu_ring *ring)
 	WREG32(mmUVD_RBC_RB_WPTR, ring->wptr);
 }
 
-static int uvd_v5_0_early_init(struct amdgpu_device *adev)
+static int uvd_v5_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	uvd_v5_0_set_ring_funcs(adev);
 	uvd_v5_0_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int uvd_v5_0_sw_init(struct amdgpu_device *adev)
+static int uvd_v5_0_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int r;
 
 	/* UVD TRAP */
@@ -113,9 +116,10 @@ static int uvd_v5_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int uvd_v5_0_sw_fini(struct amdgpu_device *adev)
+static int uvd_v5_0_sw_fini(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_uvd_suspend(adev);
 	if (r)
@@ -135,8 +139,9 @@ static int uvd_v5_0_sw_fini(struct amdgpu_device *adev)
  *
  * Initialize the hardware, boot up the VCPU and do some testing
  */
-static int uvd_v5_0_hw_init(struct amdgpu_device *adev)
+static int uvd_v5_0_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring = &adev->uvd.ring;
 	uint32_t tmp;
 	int r;
@@ -199,8 +204,9 @@ done:
  *
  * Stop the UVD block, mark ring as not ready any more
  */
-static int uvd_v5_0_hw_fini(struct amdgpu_device *adev)
+static int uvd_v5_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring = &adev->uvd.ring;
 
 	uvd_v5_0_stop(adev);
@@ -209,9 +215,10 @@ static int uvd_v5_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int uvd_v5_0_suspend(struct amdgpu_device *adev)
+static int uvd_v5_0_suspend(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = uvd_v5_0_hw_fini(adev);
 	if (r)
@@ -224,9 +231,10 @@ static int uvd_v5_0_suspend(struct amdgpu_device *adev)
 	return r;
 }
 
-static int uvd_v5_0_resume(struct amdgpu_device *adev)
+static int uvd_v5_0_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_uvd_resume(adev);
 	if (r)
@@ -605,14 +613,17 @@ error:
 	return r;
 }
 
-static bool uvd_v5_0_is_idle(struct amdgpu_device *adev)
+static bool uvd_v5_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);
 }
 
-static int uvd_v5_0_wait_for_idle(struct amdgpu_device *adev)
+static int uvd_v5_0_wait_for_idle(void *handle)
 {
 	unsigned i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		if (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))
@@ -621,8 +632,10 @@ static int uvd_v5_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static int uvd_v5_0_soft_reset(struct amdgpu_device *adev)
+static int uvd_v5_0_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	uvd_v5_0_stop(adev);
 
 	WREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,
@@ -632,8 +645,9 @@ static int uvd_v5_0_soft_reset(struct amdgpu_device *adev)
 	return uvd_v5_0_start(adev);
 }
 
-static void uvd_v5_0_print_status(struct amdgpu_device *adev)
+static void uvd_v5_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	dev_info(adev->dev, "UVD 5.0 registers\n");
 	dev_info(adev->dev, "  UVD_SEMA_ADDR_LOW=0x%08X\n",
 		 RREG32(mmUVD_SEMA_ADDR_LOW));
@@ -757,16 +771,14 @@ static int uvd_v5_0_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int uvd_v5_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int uvd_v5_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	//TODO
-
 	return 0;
 }
 
-static int uvd_v5_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int uvd_v5_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	/* This doesn't actually powergate the UVD block.
 	 * That's done in the dpm code via the SMC.  This
@@ -775,7 +787,9 @@ static int uvd_v5_0_set_powergating_state(struct amdgpu_device *adev,
 	 * revisit this when there is a cleaner line between
 	 * the smc and the hw blocks
 	 */
-	if (state == AMDGPU_PG_STATE_GATE) {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (state == AMD_PG_STATE_GATE) {
 		uvd_v5_0_stop(adev);
 		return 0;
 	} else {
@@ -783,7 +797,7 @@ static int uvd_v5_0_set_powergating_state(struct amdgpu_device *adev,
 	}
 }
 
-const struct amdgpu_ip_funcs uvd_v5_0_ip_funcs = {
+const struct amd_ip_funcs uvd_v5_0_ip_funcs = {
 	.early_init = uvd_v5_0_early_init,
 	.late_init = NULL,
 	.sw_init = uvd_v5_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.h b/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.h
index 7d7a152..e3b3c49 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v5_0.h
@@ -24,6 +24,6 @@
 #ifndef __UVD_V5_0_H__
 #define __UVD_V5_0_H__
 
-extern const struct amdgpu_ip_funcs uvd_v5_0_ip_funcs;
+extern const struct amd_ip_funcs uvd_v5_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c b/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c
index f59942d..8c790fb 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c
@@ -79,18 +79,21 @@ static void uvd_v6_0_ring_set_wptr(struct amdgpu_ring *ring)
 	WREG32(mmUVD_RBC_RB_WPTR, ring->wptr);
 }
 
-static int uvd_v6_0_early_init(struct amdgpu_device *adev)
+static int uvd_v6_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	uvd_v6_0_set_ring_funcs(adev);
 	uvd_v6_0_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int uvd_v6_0_sw_init(struct amdgpu_device *adev)
+static int uvd_v6_0_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* UVD TRAP */
 	r = amdgpu_irq_add_id(adev, 124, &adev->uvd.irq);
@@ -113,9 +116,10 @@ static int uvd_v6_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int uvd_v6_0_sw_fini(struct amdgpu_device *adev)
+static int uvd_v6_0_sw_fini(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_uvd_suspend(adev);
 	if (r)
@@ -135,8 +139,9 @@ static int uvd_v6_0_sw_fini(struct amdgpu_device *adev)
  *
  * Initialize the hardware, boot up the VCPU and do some testing
  */
-static int uvd_v6_0_hw_init(struct amdgpu_device *adev)
+static int uvd_v6_0_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring = &adev->uvd.ring;
 	uint32_t tmp;
 	int r;
@@ -193,8 +198,9 @@ done:
  *
  * Stop the UVD block, mark ring as not ready any more
  */
-static int uvd_v6_0_hw_fini(struct amdgpu_device *adev)
+static int uvd_v6_0_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring = &adev->uvd.ring;
 
 	uvd_v6_0_stop(adev);
@@ -203,9 +209,10 @@ static int uvd_v6_0_hw_fini(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int uvd_v6_0_suspend(struct amdgpu_device *adev)
+static int uvd_v6_0_suspend(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = uvd_v6_0_hw_fini(adev);
 	if (r)
@@ -218,9 +225,10 @@ static int uvd_v6_0_suspend(struct amdgpu_device *adev)
 	return r;
 }
 
-static int uvd_v6_0_resume(struct amdgpu_device *adev)
+static int uvd_v6_0_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_uvd_resume(adev);
 	if (r)
@@ -593,14 +601,17 @@ error:
 	return r;
 }
 
-static bool uvd_v6_0_is_idle(struct amdgpu_device *adev)
+static bool uvd_v6_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return !(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK);
 }
 
-static int uvd_v6_0_wait_for_idle(struct amdgpu_device *adev)
+static int uvd_v6_0_wait_for_idle(void *handle)
 {
 	unsigned i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		if (!(RREG32(mmSRBM_STATUS) & SRBM_STATUS__UVD_BUSY_MASK))
@@ -609,8 +620,10 @@ static int uvd_v6_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static int uvd_v6_0_soft_reset(struct amdgpu_device *adev)
+static int uvd_v6_0_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	uvd_v6_0_stop(adev);
 
 	WREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_UVD_MASK,
@@ -620,8 +633,9 @@ static int uvd_v6_0_soft_reset(struct amdgpu_device *adev)
 	return uvd_v6_0_start(adev);
 }
 
-static void uvd_v6_0_print_status(struct amdgpu_device *adev)
+static void uvd_v6_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	dev_info(adev->dev, "UVD 6.0 registers\n");
 	dev_info(adev->dev, "  UVD_SEMA_ADDR_LOW=0x%08X\n",
 		 RREG32(mmUVD_SEMA_ADDR_LOW));
@@ -737,16 +751,14 @@ static int uvd_v6_0_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int uvd_v6_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int uvd_v6_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	//TODO
-
 	return 0;
 }
 
-static int uvd_v6_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int uvd_v6_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	/* This doesn't actually powergate the UVD block.
 	 * That's done in the dpm code via the SMC.  This
@@ -755,7 +767,9 @@ static int uvd_v6_0_set_powergating_state(struct amdgpu_device *adev,
 	 * revisit this when there is a cleaner line between
 	 * the smc and the hw blocks
 	 */
-	if (state == AMDGPU_PG_STATE_GATE) {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (state == AMD_PG_STATE_GATE) {
 		uvd_v6_0_stop(adev);
 		return 0;
 	} else {
@@ -763,7 +777,7 @@ static int uvd_v6_0_set_powergating_state(struct amdgpu_device *adev,
 	}
 }
 
-const struct amdgpu_ip_funcs uvd_v6_0_ip_funcs = {
+const struct amd_ip_funcs uvd_v6_0_ip_funcs = {
 	.early_init = uvd_v6_0_early_init,
 	.late_init = NULL,
 	.sw_init = uvd_v6_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.h b/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.h
index bc21afc..6b92a23 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.h
@@ -24,6 +24,6 @@
 #ifndef __UVD_V6_0_H__
 #define __UVD_V6_0_H__
 
-extern const struct amdgpu_ip_funcs uvd_v6_0_ip_funcs;
+extern const struct amd_ip_funcs uvd_v6_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v2_0.c b/drivers/gpu/drm/amd/amdgpu/vce_v2_0.c
index f200df3..303d961d 100644
--- a/drivers/gpu/drm/amd/amdgpu/vce_v2_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/vce_v2_0.c
@@ -169,18 +169,21 @@ static int vce_v2_0_start(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int vce_v2_0_early_init(struct amdgpu_device *adev)
+static int vce_v2_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	vce_v2_0_set_ring_funcs(adev);
 	vce_v2_0_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int vce_v2_0_sw_init(struct amdgpu_device *adev)
+static int vce_v2_0_sw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	/* VCE */
 	r = amdgpu_irq_add_id(adev, 167, &adev->vce.irq);
@@ -213,9 +216,10 @@ static int vce_v2_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int vce_v2_0_sw_fini(struct amdgpu_device *adev)
+static int vce_v2_0_sw_fini(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_vce_suspend(adev);
 	if (r)
@@ -228,10 +232,11 @@ static int vce_v2_0_sw_fini(struct amdgpu_device *adev)
 	return r;
 }
 
-static int vce_v2_0_hw_init(struct amdgpu_device *adev)
+static int vce_v2_0_hw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = vce_v2_0_start(adev);
 	if (r)
@@ -258,15 +263,15 @@ static int vce_v2_0_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int vce_v2_0_hw_fini(struct amdgpu_device *adev)
+static int vce_v2_0_hw_fini(void *handle)
 {
-	// TODO
 	return 0;
 }
 
-static int vce_v2_0_suspend(struct amdgpu_device *adev)
+static int vce_v2_0_suspend(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = vce_v2_0_hw_fini(adev);
 	if (r)
@@ -279,9 +284,10 @@ static int vce_v2_0_suspend(struct amdgpu_device *adev)
 	return r;
 }
 
-static int vce_v2_0_resume(struct amdgpu_device *adev)
+static int vce_v2_0_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_vce_resume(adev);
 	if (r)
@@ -442,14 +448,17 @@ static void vce_v2_0_mc_resume(struct amdgpu_device *adev)
 	vce_v2_0_init_cg(adev);
 }
 
-static bool vce_v2_0_is_idle(struct amdgpu_device *adev)
+static bool vce_v2_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return !(RREG32(mmSRBM_STATUS2) & SRBM_STATUS2__VCE_BUSY_MASK);
 }
 
-static int vce_v2_0_wait_for_idle(struct amdgpu_device *adev)
+static int vce_v2_0_wait_for_idle(void *handle)
 {
 	unsigned i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		if (!(RREG32(mmSRBM_STATUS2) & SRBM_STATUS2__VCE_BUSY_MASK))
@@ -458,8 +467,10 @@ static int vce_v2_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static int vce_v2_0_soft_reset(struct amdgpu_device *adev)
+static int vce_v2_0_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	WREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_VCE_MASK,
 			~SRBM_SOFT_RESET__SOFT_RESET_VCE_MASK);
 	mdelay(5);
@@ -467,8 +478,10 @@ static int vce_v2_0_soft_reset(struct amdgpu_device *adev)
 	return vce_v2_0_start(adev);
 }
 
-static void vce_v2_0_print_status(struct amdgpu_device *adev)
+static void vce_v2_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "VCE 2.0 registers\n");
 	dev_info(adev->dev, "  VCE_STATUS=0x%08X\n",
 		 RREG32(mmVCE_STATUS));
@@ -569,12 +582,13 @@ static int vce_v2_0_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int vce_v2_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int vce_v2_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
 	bool gate = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (state == AMDGPU_CG_STATE_GATE)
+	if (state == AMD_CG_STATE_GATE)
 		gate = true;
 
 	vce_v2_0_enable_mgcg(adev, gate);
@@ -582,8 +596,8 @@ static int vce_v2_0_set_clockgating_state(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int vce_v2_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int vce_v2_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	/* This doesn't actually powergate the VCE block.
 	 * That's done in the dpm code via the SMC.  This
@@ -592,14 +606,16 @@ static int vce_v2_0_set_powergating_state(struct amdgpu_device *adev,
 	 * revisit this when there is a cleaner line between
 	 * the smc and the hw blocks
 	 */
-	if (state == AMDGPU_PG_STATE_GATE)
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (state == AMD_PG_STATE_GATE)
 		/* XXX do we need a vce_v2_0_stop()? */
 		return 0;
 	else
 		return vce_v2_0_start(adev);
 }
 
-const struct amdgpu_ip_funcs vce_v2_0_ip_funcs = {
+const struct amd_ip_funcs vce_v2_0_ip_funcs = {
 	.early_init = vce_v2_0_early_init,
 	.late_init = NULL,
 	.sw_init = vce_v2_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v2_0.h b/drivers/gpu/drm/amd/amdgpu/vce_v2_0.h
index 8eb1cf2..0d2ae8a 100644
--- a/drivers/gpu/drm/amd/amdgpu/vce_v2_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/vce_v2_0.h
@@ -24,6 +24,6 @@
 #ifndef __VCE_V2_0_H__
 #define __VCE_V2_0_H__
 
-extern const struct amdgpu_ip_funcs vce_v2_0_ip_funcs;
+extern const struct amd_ip_funcs vce_v2_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
index 57e0e16..d62c4002 100644
--- a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
@@ -190,16 +190,19 @@ static int vce_v3_0_start(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int vce_v3_0_early_init(struct amdgpu_device *adev)
+static int vce_v3_0_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	vce_v3_0_set_ring_funcs(adev);
 	vce_v3_0_set_irq_funcs(adev);
 
 	return 0;
 }
 
-static int vce_v3_0_sw_init(struct amdgpu_device *adev)
+static int vce_v3_0_sw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct amdgpu_ring *ring;
 	int r;
 
@@ -234,9 +237,10 @@ static int vce_v3_0_sw_init(struct amdgpu_device *adev)
 	return r;
 }
 
-static int vce_v3_0_sw_fini(struct amdgpu_device *adev)
+static int vce_v3_0_sw_fini(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_vce_suspend(adev);
 	if (r)
@@ -249,10 +253,11 @@ static int vce_v3_0_sw_fini(struct amdgpu_device *adev)
 	return r;
 }
 
-static int vce_v3_0_hw_init(struct amdgpu_device *adev)
+static int vce_v3_0_hw_init(void *handle)
 {
 	struct amdgpu_ring *ring;
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = vce_v3_0_start(adev);
 	if (r)
@@ -279,15 +284,15 @@ static int vce_v3_0_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int vce_v3_0_hw_fini(struct amdgpu_device *adev)
+static int vce_v3_0_hw_fini(void *handle)
 {
-	// TODO
 	return 0;
 }
 
-static int vce_v3_0_suspend(struct amdgpu_device *adev)
+static int vce_v3_0_suspend(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = vce_v3_0_hw_fini(adev);
 	if (r)
@@ -300,9 +305,10 @@ static int vce_v3_0_suspend(struct amdgpu_device *adev)
 	return r;
 }
 
-static int vce_v3_0_resume(struct amdgpu_device *adev)
+static int vce_v3_0_resume(void *handle)
 {
 	int r;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	r = amdgpu_vce_resume(adev);
 	if (r)
@@ -362,14 +368,17 @@ static void vce_v3_0_mc_resume(struct amdgpu_device *adev, int idx)
 		 ~VCE_SYS_INT_EN__VCE_SYS_INT_TRAP_INTERRUPT_EN_MASK);
 }
 
-static bool vce_v3_0_is_idle(struct amdgpu_device *adev)
+static bool vce_v3_0_is_idle(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return !(RREG32(mmSRBM_STATUS2) & SRBM_STATUS2__VCE_BUSY_MASK);
 }
 
-static int vce_v3_0_wait_for_idle(struct amdgpu_device *adev)
+static int vce_v3_0_wait_for_idle(void *handle)
 {
 	unsigned i;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
 		if (!(RREG32(mmSRBM_STATUS2) & SRBM_STATUS2__VCE_BUSY_MASK))
@@ -378,8 +387,10 @@ static int vce_v3_0_wait_for_idle(struct amdgpu_device *adev)
 	return -ETIMEDOUT;
 }
 
-static int vce_v3_0_soft_reset(struct amdgpu_device *adev)
+static int vce_v3_0_soft_reset(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	WREG32_P(mmSRBM_SOFT_RESET, SRBM_SOFT_RESET__SOFT_RESET_VCE_MASK,
 			~SRBM_SOFT_RESET__SOFT_RESET_VCE_MASK);
 	mdelay(5);
@@ -387,8 +398,10 @@ static int vce_v3_0_soft_reset(struct amdgpu_device *adev)
 	return vce_v3_0_start(adev);
 }
 
-static void vce_v3_0_print_status(struct amdgpu_device *adev)
+static void vce_v3_0_print_status(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	dev_info(adev->dev, "VCE 3.0 registers\n");
 	dev_info(adev->dev, "  VCE_STATUS=0x%08X\n",
 		 RREG32(mmVCE_STATUS));
@@ -487,15 +500,14 @@ static int vce_v3_0_process_interrupt(struct amdgpu_device *adev,
 	return 0;
 }
 
-static int vce_v3_0_set_clockgating_state(struct amdgpu_device *adev,
-					  enum amdgpu_clockgating_state state)
+static int vce_v3_0_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
 {
-	//TODO
 	return 0;
 }
 
-static int vce_v3_0_set_powergating_state(struct amdgpu_device *adev,
-					  enum amdgpu_powergating_state state)
+static int vce_v3_0_set_powergating_state(void *handle,
+					  enum amd_powergating_state state)
 {
 	/* This doesn't actually powergate the VCE block.
 	 * That's done in the dpm code via the SMC.  This
@@ -504,14 +516,16 @@ static int vce_v3_0_set_powergating_state(struct amdgpu_device *adev,
 	 * revisit this when there is a cleaner line between
 	 * the smc and the hw blocks
 	 */
-	if (state == AMDGPU_PG_STATE_GATE)
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (state == AMD_PG_STATE_GATE)
 		/* XXX do we need a vce_v3_0_stop()? */
 		return 0;
 	else
 		return vce_v3_0_start(adev);
 }
 
-const struct amdgpu_ip_funcs vce_v3_0_ip_funcs = {
+const struct amd_ip_funcs vce_v3_0_ip_funcs = {
 	.early_init = vce_v3_0_early_init,
 	.late_init = NULL,
 	.sw_init = vce_v3_0_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.h b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.h
index f3c2ba9..b45af65 100644
--- a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.h
+++ b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.h
@@ -24,6 +24,6 @@
 #ifndef __VCE_V3_0_H__
 #define __VCE_V3_0_H__
 
-extern const struct amdgpu_ip_funcs vce_v3_0_ip_funcs;
+extern const struct amd_ip_funcs vce_v3_0_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/vi.c b/drivers/gpu/drm/amd/amdgpu/vi.c
index 59a073a..be7c176 100644
--- a/drivers/gpu/drm/amd/amdgpu/vi.c
+++ b/drivers/gpu/drm/amd/amdgpu/vi.c
@@ -994,42 +994,42 @@ static const struct amdgpu_ip_block_version topaz_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &vi_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 4,
 		.rev = 0,
 		.funcs = &iceland_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 1,
 		.rev = 0,
 		.funcs = &iceland_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gfx_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 4,
 		.rev = 0,
@@ -1041,63 +1041,63 @@ static const struct amdgpu_ip_block_version tonga_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &vi_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 3,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &tonga_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 1,
 		.rev = 0,
 		.funcs = &tonga_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 10,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &dce_v10_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gfx_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 3,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &sdma_v3_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 5,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &uvd_v5_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 3,
 		.minor = 0,
 		.rev = 0,
@@ -1109,63 +1109,63 @@ static const struct amdgpu_ip_block_version cz_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &vi_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 3,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cz_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cz_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 11,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &dce_v11_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 8,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gfx_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 3,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &sdma_v3_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 6,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &uvd_v6_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 3,
 		.minor = 0,
 		.rev = 0,
@@ -1225,9 +1225,10 @@ static const struct amdgpu_asic_funcs vi_asic_funcs =
 	.wait_for_mc_idle = &gmc_v8_0_mc_wait_for_idle,
 };
 
-static int vi_common_early_init(struct amdgpu_device *adev)
+static int vi_common_early_init(void *handle)
 {
 	bool smc_enabled = false;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	adev->smc_rreg = &vi_smc_rreg;
 	adev->smc_wreg = &vi_smc_wreg;
@@ -1240,8 +1241,8 @@ static int vi_common_early_init(struct amdgpu_device *adev)
 
 	adev->asic_funcs = &vi_asic_funcs;
 
-	if (amdgpu_get_ip_block(adev, AMDGPU_IP_BLOCK_TYPE_SMC) &&
-		(amdgpu_ip_block_mask & (1 << AMDGPU_IP_BLOCK_TYPE_SMC)))
+	if (amdgpu_get_ip_block(adev, AMD_IP_BLOCK_TYPE_SMC) &&
+		(amdgpu_ip_block_mask & (1 << AMD_IP_BLOCK_TYPE_SMC)))
 		smc_enabled = true;
 
 	adev->rev_id = vi_get_rev_id(adev);
@@ -1279,18 +1280,20 @@ static int vi_common_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int vi_common_sw_init(struct amdgpu_device *adev)
+static int vi_common_sw_init(void *handle)
 {
 	return 0;
 }
 
-static int vi_common_sw_fini(struct amdgpu_device *adev)
+static int vi_common_sw_fini(void *handle)
 {
 	return 0;
 }
 
-static int vi_common_hw_init(struct amdgpu_device *adev)
+static int vi_common_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	/* move the golden regs per IP block */
 	vi_init_golden_registers(adev);
 	/* enable pcie gen2/3 link */
@@ -1303,58 +1306,63 @@ static int vi_common_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int vi_common_hw_fini(struct amdgpu_device *adev)
+static int vi_common_hw_fini(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	/* enable the doorbell aperture */
 	vi_enable_doorbell_aperture(adev, false);
 
 	return 0;
 }
 
-static int vi_common_suspend(struct amdgpu_device *adev)
+static int vi_common_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return vi_common_hw_fini(adev);
 }
 
-static int vi_common_resume(struct amdgpu_device *adev)
+static int vi_common_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return vi_common_hw_init(adev);
 }
 
-static bool vi_common_is_idle(struct amdgpu_device *adev)
+static bool vi_common_is_idle(void *handle)
 {
 	return true;
 }
 
-static int vi_common_wait_for_idle(struct amdgpu_device *adev)
+static int vi_common_wait_for_idle(void *handle)
 {
 	return 0;
 }
 
-static void vi_common_print_status(struct amdgpu_device *adev)
+static void vi_common_print_status(void *handle)
 {
-
+	return;
 }
 
-static int vi_common_soft_reset(struct amdgpu_device *adev)
+static int vi_common_soft_reset(void *handle)
 {
-	/* XXX hard reset?? */
 	return 0;
 }
 
-static int vi_common_set_clockgating_state(struct amdgpu_device *adev,
-					    enum amdgpu_clockgating_state state)
+static int vi_common_set_clockgating_state(void *handle,
+					    enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int vi_common_set_powergating_state(struct amdgpu_device *adev,
-					    enum amdgpu_powergating_state state)
+static int vi_common_set_powergating_state(void *handle,
+					    enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs vi_common_ip_funcs = {
+const struct amd_ip_funcs vi_common_ip_funcs = {
 	.early_init = vi_common_early_init,
 	.late_init = NULL,
 	.sw_init = vi_common_sw_init,
diff --git a/drivers/gpu/drm/amd/amdgpu/vi.h b/drivers/gpu/drm/amd/amdgpu/vi.h
index d16a5f7..5020940 100644
--- a/drivers/gpu/drm/amd/amdgpu/vi.h
+++ b/drivers/gpu/drm/amd/amdgpu/vi.h
@@ -24,7 +24,7 @@
 #ifndef __VI_H__
 #define __VI_H__
 
-extern const struct amdgpu_ip_funcs vi_common_ip_funcs;
+extern const struct amd_ip_funcs vi_common_ip_funcs;
 
 void vi_srbm_select(struct amdgpu_device *adev,
 		    u32 me, u32 pipe, u32 queue, u32 vmid);
diff --git a/drivers/gpu/drm/amd/amdgpu/vi_dpm.h b/drivers/gpu/drm/amd/amdgpu/vi_dpm.h
index 11cb1f7..3b45332 100644
--- a/drivers/gpu/drm/amd/amdgpu/vi_dpm.h
+++ b/drivers/gpu/drm/amd/amdgpu/vi_dpm.h
@@ -24,13 +24,13 @@
 #ifndef __VI_DPM_H__
 #define __VI_DPM_H__
 
-extern const struct amdgpu_ip_funcs cz_dpm_ip_funcs;
+extern const struct amd_ip_funcs cz_dpm_ip_funcs;
 int cz_smu_init(struct amdgpu_device *adev);
 int cz_smu_start(struct amdgpu_device *adev);
 int cz_smu_fini(struct amdgpu_device *adev);
 
-extern const struct amdgpu_ip_funcs tonga_dpm_ip_funcs;
+extern const struct amd_ip_funcs tonga_dpm_ip_funcs;
 
-extern const struct amdgpu_ip_funcs iceland_dpm_ip_funcs;
+extern const struct amd_ip_funcs iceland_dpm_ip_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/include/amd_shared.h b/drivers/gpu/drm/amd/include/amd_shared.h
new file mode 100644
index 0000000..5bdf1b4
--- /dev/null
+++ b/drivers/gpu/drm/amd/include/amd_shared.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __AMD_SHARED_H__
+#define __AMD_SHARED_H__
+
+enum amd_ip_block_type {
+	AMD_IP_BLOCK_TYPE_COMMON,
+	AMD_IP_BLOCK_TYPE_GMC,
+	AMD_IP_BLOCK_TYPE_IH,
+	AMD_IP_BLOCK_TYPE_SMC,
+	AMD_IP_BLOCK_TYPE_DCE,
+	AMD_IP_BLOCK_TYPE_GFX,
+	AMD_IP_BLOCK_TYPE_SDMA,
+	AMD_IP_BLOCK_TYPE_UVD,
+	AMD_IP_BLOCK_TYPE_VCE,
+};
+
+enum amd_clockgating_state {
+	AMD_CG_STATE_GATE = 0,
+	AMD_CG_STATE_UNGATE,
+};
+
+enum amd_powergating_state {
+	AMD_PG_STATE_GATE = 0,
+	AMD_PG_STATE_UNGATE,
+};
+
+struct amd_ip_funcs {
+	/* sets up early driver state (pre sw_init), does not configure hw - Optional */
+	int (*early_init)(void *handle);
+	/* sets up late driver/hw state (post hw_init) - Optional */
+	int (*late_init)(void *handle);
+	/* sets up driver state, does not configure hw */
+	int (*sw_init)(void *handle);
+	/* tears down driver state, does not configure hw */
+	int (*sw_fini)(void *handle);
+	/* sets up the hw state */
+	int (*hw_init)(void *handle);
+	/* tears down the hw state */
+	int (*hw_fini)(void *handle);
+	/* handles IP specific hw/sw changes for suspend */
+	int (*suspend)(void *handle);
+	/* handles IP specific hw/sw changes for resume */
+	int (*resume)(void *handle);
+	/* returns current IP block idle status */
+	bool (*is_idle)(void *handle);
+	/* poll for idle */
+	int (*wait_for_idle)(void *handle);
+	/* soft reset the IP block */
+	int (*soft_reset)(void *handle);
+	/* dump the IP block status registers */
+	void (*print_status)(void *handle);
+	/* enable/disable cg for the IP block */
+	int (*set_clockgating_state)(void *handle,
+				     enum amd_clockgating_state state);
+	/* enable/disable pg for the IP block */
+	int (*set_powergating_state)(void *handle,
+				     enum amd_powergating_state state);
+};
+
+#endif /* __AMD_SHARED_H__ */
-- 
1.9.1

