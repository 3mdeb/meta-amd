From 7e16f4509c45d335fec0a460139b7add65b07d76 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Wed, 12 Oct 2016 15:34:45 -0400
Subject: [PATCH 1313/1722] drm/amd/dal: Fix build warnings

Change-Id: I2e41d43b925064b8bd8fa949394b2c33a79f98c9
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../dal/dc/bios/dce110/bios_parser_helper_dce110.c | 70 ---------------------
 .../dal/dc/bios/dce112/bios_parser_helper_dce112.c | 71 ---------------------
 .../dal/dc/bios/dce80/bios_parser_helper_dce80.c   | 72 ----------------------
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  6 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c       |  4 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  2 +
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c   |  7 ---
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |  7 +--
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  | 18 ------
 .../amd/dal/dc/i2caux/dce110/aux_engine_dce110.c   | 12 ----
 .../dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c    |  2 -
 11 files changed, 8 insertions(+), 263 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c b/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c
index 2806e1e..5b7c13f 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce110/bios_parser_helper_dce110.c
@@ -82,76 +82,6 @@ static bool is_accelerated_mode(
 
 #define BIOS_SCRATCH0_DAC_B_SHIFT 8
 
-/**
- * detect_sink
- *
- * @brief
- *  read VBIOS scratch register to determine whether display for the specified
- *  signal is present and return the actual sink signal type
- *  For analog signals VBIOS load detection has to be called prior reading the
- *  register
- *
- * @param
- *  encoder - encoder id (to specify DAC)
- *  connector - connector id (to check CV on DIN)
- *  signal - signal (as display type) to check
- *
- * @return
- *  signal_type - actual (on the sink) signal type detected
- */
-static enum signal_type detect_sink(
-	struct dc_context *ctx,
-	struct graphics_object_id encoder,
-	struct graphics_object_id connector,
-	enum signal_type signal)
-{
-	uint32_t bios_scratch0;
-	uint32_t encoder_id = encoder.id;
-	/* after DCE 10.x does not support DAC2, so assert and return
-	 * SIGNAL_TYPE_NONE */
-	if (encoder_id == ENCODER_ID_INTERNAL_DAC2
-		|| encoder_id == ENCODER_ID_INTERNAL_KLDSCP_DAC2) {
-		ASSERT(false);
-		return SIGNAL_TYPE_NONE;
-	}
-
-	bios_scratch0 = dm_read_reg(ctx,
-		mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF);
-
-	/* In further processing we use DACB masks. If we want detect load on
-	 * DACA, we need to shift the register so DACA bits will be in place of
-	 * DACB bits
-	 */
-	if (encoder_id == ENCODER_ID_INTERNAL_DAC1
-		|| encoder_id == ENCODER_ID_INTERNAL_KLDSCP_DAC1
-		|| encoder_id == ENCODER_ID_EXTERNAL_NUTMEG
-		|| encoder_id == ENCODER_ID_EXTERNAL_TRAVIS) {
-		bios_scratch0 <<= BIOS_SCRATCH0_DAC_B_SHIFT;
-	}
-
-	switch (signal) {
-	case SIGNAL_TYPE_RGB: {
-		if (bios_scratch0 & ATOM_S0_CRT2_MASK)
-			return SIGNAL_TYPE_RGB;
-		break;
-	}
-	case SIGNAL_TYPE_LVDS: {
-		if (bios_scratch0 & ATOM_S0_LCD1)
-			return SIGNAL_TYPE_LVDS;
-		break;
-	}
-	case SIGNAL_TYPE_EDP: {
-		if (bios_scratch0 & ATOM_S0_LCD1)
-			return SIGNAL_TYPE_EDP;
-		break;
-	}
-	default:
-		break;
-	}
-
-	return SIGNAL_TYPE_NONE;
-}
-
 void dce110_set_scratch_critical_state(struct dc_context *ctx,
 				       bool state)
 {
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c b/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
index f9e72d2..23415d4 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
@@ -81,77 +81,6 @@ static bool is_accelerated_mode(
 	return (value & ATOM_S6_ACC_MODE) ? true : false;
 }
 
-#define BIOS_SCRATCH0_DAC_B_SHIFT 8
-
-/**
- * detect_sink
- *
- * @brief
- *  read VBIOS scratch register to determine whether display for the specified
- *  signal is present and return the actual sink signal type
- *  For analog signals VBIOS load detection has to be called prior reading the
- *  register
- *
- * @param
- *  encoder - encoder id (to specify DAC)
- *  connector - connector id (to check CV on DIN)
- *  signal - signal (as display type) to check
- *
- * @return
- *  signal_type - actual (on the sink) signal type detected
- */
-static enum signal_type detect_sink(
-	struct dc_context *ctx,
-	struct graphics_object_id encoder,
-	struct graphics_object_id connector,
-	enum signal_type signal)
-{
-	uint32_t bios_scratch0;
-	uint32_t encoder_id = encoder.id;
-	/* after DCE 10.x does not support DAC2, so assert and return SIGNAL_TYPE_NONE */
-	if (encoder_id == ENCODER_ID_INTERNAL_DAC2
-		|| encoder_id == ENCODER_ID_INTERNAL_KLDSCP_DAC2) {
-		ASSERT(false);
-		return SIGNAL_TYPE_NONE;
-	}
-
-	bios_scratch0 = dm_read_reg(ctx,
-		mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF);
-
-	/* In further processing we use DACB masks. If we want detect load on
-	 * DACA, we need to shift the register so DACA bits will be in place of
-	 * DACB bits
-	 */
-	if (encoder_id == ENCODER_ID_INTERNAL_DAC1
-		|| encoder_id == ENCODER_ID_INTERNAL_KLDSCP_DAC1
-		|| encoder_id == ENCODER_ID_EXTERNAL_NUTMEG
-		|| encoder_id == ENCODER_ID_EXTERNAL_TRAVIS) {
-		bios_scratch0 <<= BIOS_SCRATCH0_DAC_B_SHIFT;
-	}
-
-	switch (signal) {
-	case SIGNAL_TYPE_RGB: {
-		if (bios_scratch0 & ATOM_S0_CRT2_MASK)
-			return SIGNAL_TYPE_RGB;
-		break;
-	}
-	case SIGNAL_TYPE_LVDS: {
-		if (bios_scratch0 & ATOM_S0_LCD1)
-			return SIGNAL_TYPE_LVDS;
-		break;
-	}
-	case SIGNAL_TYPE_EDP: {
-		if (bios_scratch0 & ATOM_S0_LCD1)
-			return SIGNAL_TYPE_EDP;
-		break;
-	}
-	default:
-		break;
-	}
-
-	return SIGNAL_TYPE_NONE;
-}
-
 /* function table */
 static const struct bios_parser_helper bios_parser_helper_funcs = {
 	.is_accelerated_mode = is_accelerated_mode,
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c b/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c
index fcddd79..a919e62 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce80/bios_parser_helper_dce80.c
@@ -38,78 +38,6 @@
 
 #include "../bios_parser_helper.h"
 
-static const uint8_t bios_scratch0_dacb_shift = 8;
-
-/**
- * detect_sink
- *
- * @brief
- *  read VBIOS scratch register to determine whether display for the specified
- *  signal is present and return the actual sink signal type
- *  For analog signals VBIOS load detection has to be called prior reading the
- *  register
- *
- * @param
- *  encoder - encoder id (to specify DAC)
- *  connector - connector id (to check CV on DIN)
- *  signal - signal (as display type) to check
- *
- * @return
- *  signal_type - actual (on the sink) signal type detected
- */
-static enum signal_type detect_sink(
-	struct dc_context *ctx,
-	struct graphics_object_id encoder,
-	struct graphics_object_id connector,
-	enum signal_type signal)
-{
-	enum signal_type sink = SIGNAL_TYPE_NONE;
-	/* VBIOS does not provide bitfield definitions */
-	uint32_t reg;
-	/* DCE 8.0 does not support DAC2 */
-	if (encoder.id == ENCODER_ID_INTERNAL_DAC2
-		|| encoder.id == ENCODER_ID_INTERNAL_KLDSCP_DAC2) {
-		BREAK_TO_DEBUGGER();
-		/* TODO: DALASSERT_MSG(false, ("%s: DCE 8.0 Does not support
-		 * DAC2!", __FUNCTION__)); */
-		return SIGNAL_TYPE_NONE;
-	}
-
-	reg = dm_read_reg(ctx,
-			mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF);
-
-	/* In further processing we use DACB masks. If we want detect load on
-	 * DACA, we need to shift
-	 * the register so DACA bits will be in place of DACB bits
-	 */
-	if (encoder.id == ENCODER_ID_INTERNAL_DAC1
-			|| encoder.id == ENCODER_ID_INTERNAL_KLDSCP_DAC1
-			|| encoder.id == ENCODER_ID_EXTERNAL_NUTMEG
-			|| encoder.id == ENCODER_ID_EXTERNAL_TRAVIS) {
-		reg <<= bios_scratch0_dacb_shift;
-	}
-
-	switch (signal) {
-	case SIGNAL_TYPE_RGB:
-		if (reg & ATOM_S0_CRT2_MASK)
-			sink = SIGNAL_TYPE_RGB;
-		break;
-	case SIGNAL_TYPE_LVDS:
-		if (reg & ATOM_S0_LCD1)
-			sink = SIGNAL_TYPE_LVDS;
-		break;
-	case SIGNAL_TYPE_EDP:
-		if (reg & ATOM_S0_LCD1)
-			sink = SIGNAL_TYPE_EDP;
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		break;
-	}
-
-	return sink;
-}
-
 /**
  * is_accelerated_mode
  *
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 76dc9ac..d6a0258 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -1281,9 +1281,9 @@ bool dc_commit_surfaces_to_target(
 		struct dc_target *dc_target)
 {
 	struct dc_surface_update updates[MAX_SURFACES] = { 0 };
-	struct dc_flip_addrs flip_addr[MAX_SURFACES] = {{ 0 } };
-	struct dc_plane_info plane_info[MAX_SURFACES] = {{ 0 } };
-	struct dc_scaling_info scaling_info[MAX_SURFACES] = {{ 0 } };
+	struct dc_flip_addrs flip_addr[MAX_SURFACES] = { 0 };
+	struct dc_plane_info plane_info[MAX_SURFACES] = { 0 };
+	struct dc_scaling_info scaling_info[MAX_SURFACES] = { 0 };
 	int i;
 
 	if (!dc_pre_update_surfaces_to_target(
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
index ab545ef..2c47feb 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
@@ -1493,11 +1493,11 @@ static bool allow_hpd_rx_irq(const struct core_link *link)
 
 static bool handle_hpd_irq_psr_sink(const struct core_link *link)
 {
+	union dpcd_psr_configuration psr_configuration;
+
 	if (link->public.psr_caps.psr_version == 0)
 		return false;
 
-	union dpcd_psr_configuration psr_configuration;
-
 	dal_ddc_service_read_dpcd_data(
 					link->ddc,
 					368 /*DpcdAddress_PSR_Enable_Cfg*/,
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 2ba7ae9..6f0947e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -77,6 +77,8 @@ struct dc_stream_funcs {
 	bool (*setup_psr)(struct dc *dc, const struct dc_stream *stream);
 };
 
+struct link_training_settings;
+
 struct dc_link_funcs {
 	void (*set_drive_settings)(struct dc *dc,
 			struct link_training_settings *lt_settings);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
index c6964c3..a5af24c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
@@ -296,7 +296,6 @@ static void set_high_bit_rate_capable(
 	struct audio *audio,
 	bool capable)
 {
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
 	uint32_t value = 0;
 
 	/* set high bit rate audio capable*/
@@ -314,8 +313,6 @@ static void set_video_latency(
 	struct audio *audio,
 	int latency_in_ms)
 {
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
 	uint32_t value = 0;
 
 	if ((latency_in_ms < 0) || (latency_in_ms > 255))
@@ -356,8 +353,6 @@ static void set_audio_latency(
 
 void dce110_aud_az_enable(struct audio *audio)
 {
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
 	uint32_t value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
 
 	if (get_reg_field_value(value,
@@ -372,8 +367,6 @@ void dce110_aud_az_enable(struct audio *audio)
 
 void dce110_aud_az_disable(struct audio *audio)
 {
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
 	uint32_t value;
 
 	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index b1f519f..d0db398 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -290,7 +290,7 @@ static void set_dp_phy_pattern_symbol_error(
 	struct dce110_link_encoder *enc110)
 {
 	/* Disable PHY Bypass mode to setup the test pattern */
-	struct dc_context *ctx = enc110->base.ctx;
+	uint32_t value = 0x0;
 
 	enable_phy_bypass_mode(enc110, false);
 
@@ -299,7 +299,6 @@ static void set_dp_phy_pattern_symbol_error(
 		ASSERT(REG(DP_DPHY_INTERNAL_CTRL));
 		/*DCE 120 does not have this reg*/
 
-		uint32_t value = 0x0;
 		REG_WRITE(DP_DPHY_INTERNAL_CTRL, value);
 	}
 
@@ -786,8 +785,6 @@ static bool is_dig_enabled(const struct dce110_link_encoder *enc110)
 
 static void link_encoder_disable(struct dce110_link_encoder *enc110)
 {
-	struct dc_context *ctx = enc110->base.ctx;
-
 	/* reset training pattern */
 	REG_SET(DP_DPHY_TRAINING_PATTERN_SEL, 0,
 			DPHY_TRAINING_PATTERN_SEL, 0);
@@ -1801,7 +1798,6 @@ void dce110_link_encoder_init_dmcu_backlight_settings(
 	struct link_encoder *enc)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t bl_pwm_cntl;
 	uint32_t pwmCntl;
 	uint32_t pwmCntl2;
@@ -2130,7 +2126,6 @@ void dce110_link_encoder_connect_dig_be_to_fe(
 	bool connect)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t field;
 
 	if (engine != ENGINE_ID_UNKNOWN) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index 4288e8a..b96b47a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -59,7 +59,6 @@ static void dce110_update_generic_info_packet(
 	uint32_t packet_index,
 	const struct encoder_info_packet *info_packet)
 {
-	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t regval;
 	/* choose which generic packet to use */
 	{
@@ -246,7 +245,6 @@ static void dce110_stream_encoder_hdmi_set_stream_attribute(
 	bool enable_audio)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	struct bp_encoder_control cntl = {0};
 
 	cntl.action = ENCODER_CONTROL_SETUP;
@@ -348,9 +346,6 @@ static void dce110_stream_encoder_dvi_set_stream_attribute(
 	bool is_dual_link)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
-	uint32_t addr = REG(DIG_FE_CNTL);
-	uint32_t value = dm_read_reg(ctx, addr);
 	struct bp_encoder_control cntl = {0};
 
 	cntl.action = ENCODER_CONTROL_SETUP;
@@ -442,7 +437,6 @@ static void dce110_stream_encoder_update_hdmi_info_packets(
 	const struct encoder_info_frame *info_frame)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 
 	if (info_frame->avi.valid) {
 		const uint32_t *content =
@@ -482,9 +476,6 @@ static void dce110_stream_encoder_stop_hdmi_info_packets(
 	struct stream_encoder *enc)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
-	uint32_t addr = 0;
-	uint32_t value = 0;
 
 	/* stop generic packets 0 & 1 on HDMI */
 	REG_SET_6(HDMI_GENERIC_PACKET_CONTROL0, 0,
@@ -515,8 +506,6 @@ static void dce110_stream_encoder_update_dp_info_packets(
 	const struct encoder_info_frame *info_frame)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
-	uint32_t addr = REG(DP_SEC_CNTL);
 	uint32_t value = REG_READ(DP_SEC_CNTL);
 
 	if (info_frame->vsc.valid)
@@ -546,7 +535,6 @@ static void dce110_stream_encoder_stop_dp_info_packets(
 {
 	/* stop generic packets on DP */
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t value = REG_READ(DP_SEC_CNTL);
 
 	REG_SET_7(DP_SEC_CNTL, 0,
@@ -571,7 +559,6 @@ static void dce110_stream_encoder_dp_blank(
 	struct stream_encoder *enc)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t value;
 	uint32_t retries = 0;
 	uint32_t max_retries = DP_BLANK_MAX_RETRY * 10;
@@ -631,7 +618,6 @@ static void dce110_stream_encoder_dp_unblank(
 	const struct encoder_unblank_param *param)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 
 	if (param->link_settings.link_rate != LINK_RATE_UNKNOWN) {
 		uint32_t n_vid = 0x8000;
@@ -1003,8 +989,6 @@ static void dce110_se_setup_hdmi_audio(
 
 	struct audio_clock_info audio_clock_info = {0};
 	uint32_t max_packets_per_line;
-	uint32_t addr = 0;
-	uint32_t value = 0;
 
 	/* For now still do calculation, although this field is ignored when
 	above HDMI_PACKET_GEN_VERSION set to 1 */
@@ -1086,8 +1070,6 @@ static void dce110_se_setup_dp_audio(
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 
 	/* --- DP Audio packet configurations --- */
-	uint32_t addr = 0;
-	uint32_t value = 0;
 
 	/* ATP Configuration */
 	REG_SET(DP_SEC_AUD_N, 0,
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
index 5df563f..79d6769 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/aux_engine_dce110.c
@@ -106,8 +106,6 @@ static bool acquire_engine(
 				AUX_EN);
 
 	if (field == 0) {
-		uint8_t counter = 0;
-
 		set_reg_field_value(
 				value,
 				1,
@@ -156,16 +154,6 @@ static bool acquire_engine(
 	return (field == SW_CAN_ACCESS_AUX);
 }
 
-static void configure(
-	struct aux_engine *engine,
-	union aux_config cfg)
-{
-	struct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);
-
-	REG_UPDATE(AUX_CONTROL, AUX_IGNORE_HPD_DISCON,
-			(0 != cfg.bits.ALLOW_AUX_WHEN_HPD_LOW));
-}
-
 #define COMPOSE_AUX_SW_DATA_16_20(command, address) \
 	((command) | ((0xF0000 & (address)) >> 16))
 
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
index 5f01bd2..3a20c43 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
@@ -103,8 +103,6 @@ static void disable_i2c_hw_engine(
 	struct i2c_hw_engine_dce110 *hw_engine)
 {
 	uint32_t value = 0;
-	struct dc_context *ctx = NULL;
-
 	value = REG_READ(SETUP);
 
 	set_reg_field_value(
-- 
2.7.4

