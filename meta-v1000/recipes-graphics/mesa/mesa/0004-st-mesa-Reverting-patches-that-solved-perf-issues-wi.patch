From 345436540fbba97a22170c7fff4bed1d461d7fd7 Mon Sep 17 00:00:00 2001
From: Awais Belal <awais_belal@mentor.com>
Date: Fri, 15 Dec 2017 15:35:08 +0500
Subject: [PATCH] st/mesa: Reverting patches that solved perf issues with mesa 
 12.0.3

This patch reverts below patches to solve performance issue

patch1: This patch needs to be applied
Revert "st/vdpau: use linear layout for output surfaces"

patch2:
Subject: st/mesa: directly compute level=0 texture size in st_finalize_texture

patch3:
Subject: st/mesa: Replace GLvoid with void

patch4:
Subject: st/mesa: fix reference counting bug in st_vdpau

Signed-off-by: Avinash M N <avimn@amd.com>
Signed-off-by: Awais Belal <awais_belal@mentor.com>
---
 src/gallium/state_trackers/vdpau/output.c |   2 +-
 src/mesa/state_tracker/st_texture.h       |   6 +
 src/mesa/state_tracker/st_vdpau.c         | 186 +++++++-----------------------
 3 files changed, 50 insertions(+), 144 deletions(-)

diff --git a/src/gallium/state_trackers/vdpau/output.c b/src/gallium/state_trackers/vdpau/output.c
index 8ef8268..c13bbaf 100644
--- a/src/gallium/state_trackers/vdpau/output.c
+++ b/src/gallium/state_trackers/vdpau/output.c
@@ -89,7 +89,7 @@ vlVdpOutputSurfaceCreate(VdpDevice device,
    res_tmpl.depth0 = 1;
    res_tmpl.array_size = 1;
    res_tmpl.bind = PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_RENDER_TARGET |
-                   PIPE_BIND_SHARED | PIPE_BIND_SCANOUT;
+                   PIPE_BIND_SHARED;
    res_tmpl.usage = PIPE_USAGE_DEFAULT;
 
    mtx_lock(&dev->mutex);
diff --git a/src/mesa/state_tracker/st_texture.h b/src/mesa/state_tracker/st_texture.h
index 8b549b8..6ed4294 100644
--- a/src/mesa/state_tracker/st_texture.h
+++ b/src/mesa/state_tracker/st_texture.h
@@ -97,6 +97,12 @@ struct st_texture_object
     */
    GLuint lastLevel;
 
+   /** The size of the level=0 mipmap image.
+    * Note that the number of 1D array layers will be in height0 and the
+    * number of 2D array layers will be in depth0, as in GL.
+    */
+   GLuint width0, height0, depth0;
+
    unsigned int validated_first_level;
    unsigned int validated_last_level;
 
diff --git a/src/mesa/state_tracker/st_vdpau.c b/src/mesa/state_tracker/st_vdpau.c
index 19611e7..aeb66df 100644
--- a/src/mesa/state_tracker/st_vdpau.c
+++ b/src/mesa/state_tracker/st_vdpau.c
@@ -38,6 +38,7 @@
 
 #include "pipe/p_state.h"
 #include "pipe/p_video_codec.h"
+#include "state_tracker/vdpau_interop.h"
 
 #include "util/u_inlines.h"
 
@@ -50,140 +51,14 @@
 
 #ifdef HAVE_ST_VDPAU
 
-#include "state_tracker/vdpau_interop.h"
-#include "state_tracker/vdpau_dmabuf.h"
-#include "state_tracker/vdpau_funcs.h"
-#include "state_tracker/drm_driver.h"
-
-static struct pipe_resource *
-st_vdpau_video_surface_gallium(struct gl_context *ctx, const void *vdpSurface,
-                               GLuint index)
-{
-   int (*getProcAddr)(uint32_t device, uint32_t id, void **ptr);
-   uint32_t device = (uintptr_t)ctx->vdpDevice;
-   struct pipe_sampler_view *sv;
-   VdpVideoSurfaceGallium *f;
-
-   struct pipe_video_buffer *buffer;
-   struct pipe_sampler_view **samplers;
-   struct pipe_resource *res = NULL;
-
-   getProcAddr = (void *)ctx->vdpGetProcAddress;
-   if (getProcAddr(device, VDP_FUNC_ID_VIDEO_SURFACE_GALLIUM, (void**)&f))
-      return NULL;
-
-   buffer = f((uintptr_t)vdpSurface);
-   if (!buffer)
-      return NULL;
-
-   samplers = buffer->get_sampler_view_planes(buffer);
-   if (!samplers)
-      return NULL;
-
-   sv = samplers[index >> 1];
-   if (!sv)
-      return NULL;
-
-   pipe_resource_reference(&res, sv->texture);
-   return res;
-}
-
-static struct pipe_resource *
-st_vdpau_output_surface_gallium(struct gl_context *ctx, const void *vdpSurface)
-{
-   int (*getProcAddr)(uint32_t device, uint32_t id, void **ptr);
-   uint32_t device = (uintptr_t)ctx->vdpDevice;
-   struct pipe_resource *res = NULL;
-   VdpOutputSurfaceGallium *f;
-
-   getProcAddr = (void *)ctx->vdpGetProcAddress;
-   if (getProcAddr(device, VDP_FUNC_ID_OUTPUT_SURFACE_GALLIUM, (void**)&f))
-      return NULL;
-
-   pipe_resource_reference(&res, f((uintptr_t)vdpSurface));
-   return res;
-}
-
-static struct pipe_resource *
-st_vdpau_resource_from_description(struct gl_context *ctx,
-                                   const struct VdpSurfaceDMABufDesc *desc)
-{
-   struct st_context *st = st_context(ctx);
-   struct pipe_resource templ, *res;
-   struct winsys_handle whandle;
-
-   if (desc->handle == -1)
-      return NULL;
-
-   memset(&templ, 0, sizeof(templ));
-   templ.target = PIPE_TEXTURE_2D;
-   templ.last_level = 0;
-   templ.depth0 = 1;
-   templ.array_size = 1;
-   templ.width0 = desc->width;
-   templ.height0 = desc->height;
-   templ.format = VdpFormatRGBAToPipe(desc->format);
-   templ.bind = PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_RENDER_TARGET;
-   templ.usage = PIPE_USAGE_DEFAULT;
-
-   memset(&whandle, 0, sizeof(whandle));
-   whandle.type = DRM_API_HANDLE_TYPE_FD;
-   whandle.handle = desc->handle;
-   whandle.offset = desc->offset;
-   whandle.stride = desc->stride;
-
-   res = st->pipe->screen->resource_from_handle(st->pipe->screen, &templ, &whandle,
-						PIPE_HANDLE_USAGE_READ_WRITE);
-   close(desc->handle);
-
-   return res;
-}
-
-static struct pipe_resource *
-st_vdpau_output_surface_dma_buf(struct gl_context *ctx, const void *vdpSurface)
-{
-   int (*getProcAddr)(uint32_t device, uint32_t id, void **ptr);
-   uint32_t device = (uintptr_t)ctx->vdpDevice;
-
-   struct VdpSurfaceDMABufDesc desc;
-   VdpOutputSurfaceDMABuf *f;
-
-   getProcAddr = (void *)ctx->vdpGetProcAddress;
-   if (getProcAddr(device, VDP_FUNC_ID_OUTPUT_SURFACE_DMA_BUF, (void**)&f))
-      return NULL;
-
-   if (f((uintptr_t)vdpSurface, &desc) != VDP_STATUS_OK)
-      return NULL;
-
-   return st_vdpau_resource_from_description(ctx, &desc);
-}
-
-static struct pipe_resource *
-st_vdpau_video_surface_dma_buf(struct gl_context *ctx, const void *vdpSurface,
-                               GLuint index)
-{
-   int (*getProcAddr)(uint32_t device, uint32_t id, void **ptr);
-   uint32_t device = (uintptr_t)ctx->vdpDevice;
-
-   struct VdpSurfaceDMABufDesc desc;
-   VdpVideoSurfaceDMABuf *f;
-
-   getProcAddr = (void *)ctx->vdpGetProcAddress;
-   if (getProcAddr(device, VDP_FUNC_ID_VIDEO_SURFACE_DMA_BUF, (void**)&f))
-      return NULL;
-
-   if (f((uintptr_t)vdpSurface, index, &desc) != VDP_STATUS_OK)
-      return NULL;
-
-   return st_vdpau_resource_from_description(ctx, &desc);
-}
-
 static void
 st_vdpau_map_surface(struct gl_context *ctx, GLenum target, GLenum access,
                      GLboolean output, struct gl_texture_object *texObj,
                      struct gl_texture_image *texImage,
-                     const void *vdpSurface, GLuint index)
+                     const GLvoid *vdpSurface, GLuint index)
 {
+   int (*getProcAddr)(uint32_t device, uint32_t id, void **ptr);
+   uint32_t device = (uintptr_t)ctx->vdpDevice;
    struct st_context *st = st_context(ctx);
    struct st_texture_object *stObj = st_texture_object(texObj);
    struct st_texture_image *stImage = st_texture_image(texImage);
@@ -192,21 +67,45 @@ st_vdpau_map_surface(struct gl_context *ctx, GLenum target, GLenum access,
    mesa_format texFormat;
    uint layer_override = 0;
 
+   getProcAddr = (void *)ctx->vdpGetProcAddress;
    if (output) {
-      res = st_vdpau_output_surface_dma_buf(ctx, vdpSurface);
-
-      if (!res)
-         res = st_vdpau_output_surface_gallium(ctx, vdpSurface);
-
-   } else {
-      res = st_vdpau_video_surface_dma_buf(ctx, vdpSurface, index);
+      VdpOutputSurfaceGallium *f;
+      if (getProcAddr(device, VDP_FUNC_ID_OUTPUT_SURFACE_GALLIUM, (void**)&f)) {
+         _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
+         return;
+      }
+      res = f((uintptr_t)vdpSurface);
 
       if (!res) {
-         res = st_vdpau_video_surface_gallium(ctx, vdpSurface, index);
-         layer_override = index & 1;
+         _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
+         return;
       }
-   }
-
+   } else {
+      struct pipe_sampler_view *sv;
+      VdpVideoSurfaceGallium *f;
+      struct pipe_video_buffer *buffer;
+      struct pipe_sampler_view **samplers;
+      if (getProcAddr(device, VDP_FUNC_ID_VIDEO_SURFACE_GALLIUM, (void**)&f)) {
+         _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
+         return;
+      }
+      buffer = f((uintptr_t)vdpSurface);
+      if (!buffer) {
+         _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
+         return;
+      }
+      samplers = buffer->get_sampler_view_planes(buffer);
+      if (!samplers) {
+         _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
+         return;
+      }
+      sv = samplers[index >> 1];
+      if (!sv) {
+         _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
+         return;
+      }
+      res = sv->texture;
+    }
    if (!res) {
       _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
       return;
@@ -215,7 +114,6 @@ st_vdpau_map_surface(struct gl_context *ctx, GLenum target, GLenum access,
    /* do we have different screen objects ? */
    if (res->screen != st->pipe->screen) {
       _mesa_error(ctx, GL_INVALID_OPERATION, "VDPAUMapSurfacesNV");
-      pipe_resource_reference(&res, NULL);
       return;
    }
 
@@ -235,19 +133,21 @@ st_vdpau_map_surface(struct gl_context *ctx, GLenum target, GLenum access,
    st_texture_release_all_sampler_views(st, stObj);
    pipe_resource_reference(&stImage->pt, res);
 
+   stObj->width0 = res->width0;
+   stObj->height0 = res->height0;
+   stObj->depth0 = 1;
    stObj->surface_format = res->format;
    stObj->level_override = 0;
    stObj->layer_override = layer_override;
 
    _mesa_dirty_texobj(ctx, texObj);
-   pipe_resource_reference(&res, NULL);
 }
 
 static void
 st_vdpau_unmap_surface(struct gl_context *ctx, GLenum target, GLenum access,
                        GLboolean output, struct gl_texture_object *texObj,
                        struct gl_texture_image *texImage,
-                       const void *vdpSurface, GLuint index)
+                       const GLvoid *vdpSurface, GLuint index)
 {
    struct st_context *st = st_context(ctx);
    struct st_texture_object *stObj = st_texture_object(texObj);
-- 
2.11.1

