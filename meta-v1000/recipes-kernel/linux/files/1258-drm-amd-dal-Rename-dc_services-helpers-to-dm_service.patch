From c90c6a728e00520139ddd506e36f52ff1477204b Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 29 Jan 2016 12:02:29 -0500
Subject: [PATCH 1258/1722] drm/amd/dal: Rename dc_services/helpers to
 dm_services/helpers

Also renaming functions to keep consistency.

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c    | 251 --------
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c  | 350 -----------
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      |   4 +-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c  |  35 +-
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.h  |   4 +-
 .../drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c    |   7 +-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    | 125 +++-
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c   |  42 +-
 .../drm/amd/dal/dc/adapter/wireless_data_source.c  |   2 +-
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c      | 577 +++++-------------
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h      |   4 +-
 .../dal/dc/bios/dce112/bios_parser_helper_dce112.c |  12 +-
 drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c | 243 +++-----
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |   9 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c       |   2 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 124 ++--
 drivers/gpu/drm/amd/dal/dc/core/dc_surface.c       |  11 +-
 .../drm/amd/dal/dc/dce100/dce100_hw_sequencer.c    |  22 +-
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    | 575 +++++++++---------
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.h    |   9 +-
 .../drm/amd/dal/dc/dce110/dce110_clock_source.c    |  47 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 136 ++---
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |   2 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    | 668 +++++++++++----------
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.h    |  23 +-
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  | 275 ++++-----
 .../amd/dal/dc/dce110/dce110_timing_generator.c    |   6 +-
 .../drm/amd/dal/dc/dce112/dce112_clock_source.c    |  16 +-
 .../drm/amd/dal/dc/dce112/dce112_hw_sequencer.c    |  21 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    | 642 ++++++++++----------
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.h    |   7 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c  |  21 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c  |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  | 606 ++++++++++---------
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.h  |   7 +-
 .../drm/amd/dal/dc/dce80/dce80_stream_encoder.c    |   8 +-
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |   2 +-
 .../amd/dal/dc/gpu/dce112/display_clock_dce112.c   |   8 +-
 .../drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c |   2 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_dc.h           |   8 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   6 +-
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |  11 +-
 .../gpu/drm/amd/dal/modules/freesync/freesync.c    |  95 ++-
 43 files changed, 2034 insertions(+), 2993 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c
 delete mode 100644 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c
deleted file mode 100644
index a497093..0000000
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dal_services.c
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Copyright 2015 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include <linux/string.h>
-#include <linux/acpi.h>
-
-#include <drm/drmP.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/amdgpu_drm.h>
-
-#include "amdgpu.h"
-#include "dal_services.h"
-#include "amdgpu_dm.h"
-#include "amdgpu_dm_irq.h"
-#include "amdgpu_dm_types.h"
-#include "amdgpu_pm.h"
-
-/*
-#include "logger_interface.h"
-#include "acpimethod_atif.h"
-#include "amdgpu_powerplay.h"
-#include "amdgpu_notifications.h"
-*/
-
-/* if the pointer is not NULL, the allocated memory is zeroed */
-void *dc_service_alloc(struct dc_context *ctx, uint32_t size)
-{
-	return kzalloc(size, GFP_KERNEL);
-}
-
-/* Reallocate memory. The contents will remain unchanged.*/
-void *dc_service_realloc(struct dc_context *ctx, const void *ptr, uint32_t size)
-{
-	return krealloc(ptr, size, GFP_KERNEL);
-}
-
-void dc_service_memmove(void *dst, const void *src, uint32_t size)
-{
-	memmove(dst, src, size);
-}
-
-void dc_service_free(struct dc_context *ctx, void *p)
-{
-	kfree(p);
-}
-
-void dc_service_memset(void *p, int32_t c, uint32_t count)
-{
-	memset(p, c, count);
-}
-
-int32_t dal_memcmp(const void *p1, const void *p2, uint32_t count)
-{
-	return memcmp(p1, p2, count);
-}
-
-int32_t dal_strncmp(const int8_t *p1, const int8_t *p2, uint32_t count)
-{
-	return strncmp(p1, p2, count);
-}
-
-void dc_service_sleep_in_milliseconds(struct dc_context *ctx, uint32_t milliseconds)
-{
-	if (milliseconds >= 20)
-		msleep(milliseconds);
-	else
-		usleep_range(milliseconds*1000, milliseconds*1000+1);
-}
-
-void dal_delay_in_nanoseconds(uint32_t nanoseconds)
-{
-	ndelay(nanoseconds);
-}
-
-void dc_service_delay_in_microseconds(struct dc_context *ctx, uint32_t microseconds)
-{
-	udelay(microseconds);
-}
-
-/******************************************************************************
- * IRQ Interfaces.
- *****************************************************************************/
-
-void dal_register_timer_interrupt(
-	struct dc_context *ctx,
-	struct dc_timer_interrupt_params *int_params,
-	interrupt_handler ih,
-	void *args)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-
-	if (!adev || !int_params) {
-		DRM_ERROR("DM_IRQ: invalid input!\n");
-		return;
-	}
-
-	if (int_params->int_context != INTERRUPT_LOW_IRQ_CONTEXT) {
-		/* only low irq ctx is supported. */
-		DRM_ERROR("DM_IRQ: invalid context: %d!\n",
-				int_params->int_context);
-		return;
-	}
-
-	amdgpu_dm_irq_register_timer(adev, int_params, ih, args);
-}
-
-void dal_isr_acquire_lock(struct dc_context *ctx)
-{
-	/*TODO*/
-}
-
-void dal_isr_release_lock(struct dc_context *ctx)
-{
-	/*TODO*/
-}
-
-/******************************************************************************
- * End-of-IRQ Interfaces.
- *****************************************************************************/
-
-bool dal_get_platform_info(struct dc_context *ctx,
-			struct platform_info_params *params)
-{
-	/*TODO*/
-	return false;
-}
-
-/* Next calls are to power component */
-bool dc_service_pp_pre_dce_clock_change(struct dc_context *ctx,
-				struct dal_to_power_info *input,
-				struct power_to_dal_info *output)
-{
-	/*TODO*/
-	return false;
-}
-
-bool dc_service_pp_post_dce_clock_change(struct dc_context *ctx,
-	const struct dc_pp_display_configuration *pp_display_cfg)
-{
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	struct amdgpu_device *adev = ctx->driver_context;
-
-	if (adev->pm.dpm_enabled) {
-
-		memset(&adev->pm.pm_display_cfg, 0,
-				sizeof(adev->pm.pm_display_cfg));
-
-		adev->pm.pm_display_cfg.cpu_cc6_disable =
-			pp_display_cfg->cpu_cc6_disable;
-
-		adev->pm.pm_display_cfg.cpu_pstate_disable =
-			pp_display_cfg->cpu_pstate_disable;
-
-		adev->pm.pm_display_cfg.cpu_pstate_separation_time =
-			pp_display_cfg->cpu_pstate_separation_time;
-
-		adev->pm.pm_display_cfg.nb_pstate_switch_disable =
-			pp_display_cfg->nb_pstate_switch_disable;
-
-		amd_powerplay_display_configuration_change(
-				adev->powerplay.pp_handle,
-				&adev->pm.pm_display_cfg);
-
-		/* TODO: replace by a separate call to 'apply display cfg'? */
-		amdgpu_pm_compute_clocks(adev);
-	}
-	return true;
-#else
-	return false;
-#endif
-}
-
-bool dc_service_get_system_clocks_range(struct dc_context *ctx,
-				struct dal_system_clock_range *sys_clks)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-
-	/* Default values, in case PPLib is not compiled-in. */
-	sys_clks->max_mclk = 80000;
-	sys_clks->min_mclk = 80000;
-
-	sys_clks->max_sclk = 60000;
-	sys_clks->min_sclk = 30000;
-
-#ifdef CONFIG_DRM_AMD_POWERPLAY
-	if (adev->pm.dpm_enabled) {
-		sys_clks->max_mclk = amdgpu_dpm_get_mclk(adev, false);
-		sys_clks->min_mclk = amdgpu_dpm_get_mclk(adev, true);
-
-		sys_clks->max_sclk = amdgpu_dpm_get_sclk(adev, false);
-		sys_clks->min_sclk = amdgpu_dpm_get_sclk(adev, true);
-	}
-#endif
-
-	return true;
-}
-
-
-bool dc_service_pp_set_display_clock(struct dc_context *ctx,
-			     struct dal_to_power_dclk *dclk)
-{
-	/* TODO: need power component to provide appropriate interface */
-	return false;
-}
-
-/* end of calls to power component */
-
-/* Calls to notification */
-
-void dal_notify_setmode_complete(struct dc_context *ctx,
-	uint32_t h_total,
-	uint32_t v_total,
-	uint32_t h_active,
-	uint32_t v_active,
-	uint32_t pix_clk_in_khz)
-{
-	/*TODO*/
-}
-/* End of calls to notification */
-
-long dal_get_pid(void)
-{
-	return current->pid;
-}
-
-long dal_get_tgid(void)
-{
-	return current->tgid;
-}
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c
deleted file mode 100644
index beaef70..0000000
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dc_helpers.c
+++ /dev/null
@@ -1,350 +0,0 @@
-/*
- * Copyright 2015 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include <linux/string.h>
-#include <linux/acpi.h>
-
-#include <drm/drmP.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/amdgpu_drm.h>
-#include <drm/drm_edid.h>
-
-#include "dc_types.h"
-#include "amdgpu.h"
-#include "dc.h"
-#include "dc_services.h"
-
-#include "amdgpu_dm.h"
-#include "amdgpu_dm_irq.h"
-#include "amdgpu_dm_types.h"
-
-/* dc_helpers_parse_edid_caps
- *
- * Parse edid caps
- *
- * @edid:	[in] pointer to edid
- *  edid_caps:	[in] pointer to edid caps
- * @return
- *	void
- * */
-enum dc_edid_status dc_helpers_parse_edid_caps(
-		struct dc_context *ctx,
-		const struct dc_edid *edid,
-		struct dc_edid_caps *edid_caps)
-{
-	struct edid *edid_buf = (struct edid *) edid->raw_edid;
-	struct cea_sad *sads;
-	int sad_count = -1;
-	int sadb_count = -1;
-	int i = 0;
-	int j = 0;
-	uint8_t *sadb = NULL;
-
-	enum dc_edid_status result = EDID_OK;
-
-	if (!edid_caps || !edid)
-		return EDID_BAD_INPUT;
-
-	if (!drm_edid_is_valid(edid_buf))
-		result = EDID_BAD_CHECKSUM;
-
-	edid_caps->manufacturer_id = (uint16_t) edid_buf->mfg_id[0] |
-					((uint16_t) edid_buf->mfg_id[1])<<8;
-	edid_caps->product_id = (uint16_t) edid_buf->prod_code[0] |
-					((uint16_t) edid_buf->prod_code[1])<<8;
-	edid_caps->serial_number = edid_buf->serial;
-	edid_caps->manufacture_week = edid_buf->mfg_week;
-	edid_caps->manufacture_year = edid_buf->mfg_year;
-
-	/* One of the four detailed_timings stores the monitor name. It's
-	 * stored in an array of length 13. */
-	for (i = 0; i < 4; i++) {
-		if (edid_buf->detailed_timings[i].data.other_data.type == 0xfc) {
-			while (edid_buf->detailed_timings[i].data.other_data.data.str.str[j] && j < 13) {
-				if (edid_buf->detailed_timings[i].data.other_data.data.str.str[j] == '\n')
-					break;
-
-				edid_caps->display_name[j] =
-					edid_buf->detailed_timings[i].data.other_data.data.str.str[j];
-				j++;
-			}
-		}
-	}
-
-	sad_count = drm_edid_to_sad((struct edid *) edid->raw_edid, &sads);
-	if (sad_count <= 0) {
-		DRM_INFO("SADs count is: %d, don't need to read it\n",
-				sad_count);
-		return result;
-	}
-
-	edid_caps->audio_mode_count = sad_count < DC_MAX_AUDIO_DESC_COUNT ? sad_count : DC_MAX_AUDIO_DESC_COUNT;
-	for (i = 0; i < edid_caps->audio_mode_count; ++i) {
-		struct cea_sad *sad = &sads[i];
-
-		edid_caps->audio_modes[i].format_code = sad->format;
-		edid_caps->audio_modes[i].channel_count = sad->channels;
-		edid_caps->audio_modes[i].sample_rate = sad->freq;
-		edid_caps->audio_modes[i].sample_size = sad->byte2;
-	}
-
-	sadb_count = drm_edid_to_speaker_allocation((struct edid *) edid->raw_edid, &sadb);
-
-	if (sadb_count < 0) {
-		DRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sadb_count);
-		sadb_count = 0;
-	}
-
-	if (sadb_count)
-		edid_caps->speaker_flags = sadb[0];
-	else
-		edid_caps->speaker_flags = DEFAULT_SPEAKER_LOCATION;
-
-	kfree(sads);
-	kfree(sadb);
-
-	return result;
-}
-
-
-static struct amdgpu_connector *get_connector_for_sink(
-	struct drm_device *dev,
-	const struct dc_sink *sink)
-{
-	struct drm_connector *connector;
-	struct amdgpu_connector *aconnector = NULL;
-
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_connector(connector);
-		if (aconnector->dc_sink == sink)
-			break;
-	}
-
-	return aconnector;
-}
-
-static struct amdgpu_connector *get_connector_for_link(
-	struct drm_device *dev,
-	const struct dc_link *link)
-{
-	struct drm_connector *connector;
-	struct amdgpu_connector *aconnector = NULL;
-
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_connector(connector);
-		if (aconnector->dc_link == link)
-			break;
-	}
-
-	return aconnector;
-}
-
-/*
- * Writes payload allocation table in immediate downstream device.
- */
-bool dc_helpers_dp_mst_write_payload_allocation_table(
-		struct dc_context *ctx,
-		const struct dc_sink *sink,
-		struct dp_mst_stream_allocation *alloc_entity,
-		bool enable)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector;
-	struct drm_crtc *crtc;
-	struct drm_dp_mst_topology_mgr *mst_mgr;
-	struct drm_dp_mst_port *mst_port;
-	int slots = 0;
-	bool ret;
-	int clock;
-	int bpp;
-	int pbn = 0;
-
-	aconnector = get_connector_for_sink(dev, sink);
-	crtc = aconnector->base.state->crtc;
-
-	if (!aconnector->mst_port)
-		return false;
-
-	mst_mgr = &aconnector->mst_port->mst_mgr;
-	mst_port = aconnector->port;
-
-	if (enable) {
-		clock = crtc->state->mode.clock;
-		/* TODO remove following hardcode value */
-		bpp = 30;
-
-		/* TODO need to know link rate */
-
-		pbn = drm_dp_calc_pbn_mode(clock, bpp);
-
-		ret = drm_dp_mst_allocate_vcpi(mst_mgr, mst_port, pbn, &slots);
-
-		if (!ret)
-			return false;
-
-	} else {
-		drm_dp_mst_reset_vcpi_slots(mst_mgr, mst_port);
-	}
-
-	alloc_entity->slot_count = slots;
-	alloc_entity->pbn = pbn;
-	alloc_entity->pbn_per_slot = mst_mgr->pbn_div;
-
-	ret = drm_dp_update_payload_part1(mst_mgr);
-	if (ret)
-		return false;
-
-	return true;
-}
-
-/*
- * Polls for ACT (allocation change trigger) handled and sends
- * ALLOCATE_PAYLOAD message.
- */
-bool dc_helpers_dp_mst_poll_for_allocation_change_trigger(
-		struct dc_context *ctx,
-		const struct dc_sink *sink)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector;
-	struct drm_dp_mst_topology_mgr *mst_mgr;
-	int ret;
-
-	aconnector = get_connector_for_sink(dev, sink);
-
-	if (!aconnector->mst_port)
-		return false;
-
-	mst_mgr = &aconnector->mst_port->mst_mgr;
-
-	ret = drm_dp_check_act_status(mst_mgr);
-
-	if (ret)
-		return false;
-
-	return true;
-}
-
-bool dc_helpers_dp_mst_send_payload_allocation(
-		struct dc_context *ctx,
-		const struct dc_sink *sink,
-		bool enable)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector;
-	struct drm_dp_mst_topology_mgr *mst_mgr;
-	struct drm_dp_mst_port *mst_port;
-	int ret;
-
-	aconnector = get_connector_for_sink(dev, sink);
-
-	mst_port = aconnector->port;
-
-	if (!aconnector->mst_port)
-		return false;
-
-	mst_mgr = &aconnector->mst_port->mst_mgr;
-
-	ret = drm_dp_update_payload_part2(mst_mgr);
-
-	if (ret)
-		return false;
-
-	if (!enable)
-		drm_dp_mst_deallocate_vcpi(mst_mgr, mst_port);
-
-	return true;
-}
-
-void dc_helpers_dp_mst_handle_mst_hpd_rx_irq(void *param)
-{
-	uint8_t esi[8] = { 0 };
-	uint8_t dret;
-	bool new_irq_handled = true;
-	struct amdgpu_connector *aconnector = (struct amdgpu_connector *)param;
-
-	/* DPCD 0x2002 - 0x2008 for down stream IRQ from MST, eDP etc. */
-	dret = drm_dp_dpcd_read(
-		&aconnector->dm_dp_aux.aux,
-		DP_SINK_COUNT_ESI, esi, 8);
-
-	while ((dret == 8) && new_irq_handled) {
-		uint8_t retry;
-
-		DRM_DEBUG_KMS("ESI %02x %02x %02x\n", esi[0], esi[1], esi[2]);
-
-		/* handle HPD short pulse irq */
-		drm_dp_mst_hpd_irq(&aconnector->mst_mgr, esi, &new_irq_handled);
-
-		if (new_irq_handled) {
-			/* ACK at DPCD to notify down stream */
-			for (retry = 0; retry < 3; retry++) {
-				uint8_t wret;
-
-				wret = drm_dp_dpcd_write(
-					&aconnector->dm_dp_aux.aux,
-					DP_SINK_COUNT_ESI + 1,
-					&esi[1],
-					3);
-				if (wret == 3)
-					break;
-			}
-
-			/* check if there is new irq to be handle */
-			dret = drm_dp_dpcd_read(
-				&aconnector->dm_dp_aux.aux,
-				DP_SINK_COUNT_ESI, esi, 8);
-		}
-	}
-}
-
-bool dc_helpers_dp_mst_start_top_mgr(
-		struct dc_context *ctx,
-		const struct dc_link *link)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
-
-	if (aconnector)
-		drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true);
-
-	return true;
-}
-
-void dc_helpers_dp_mst_stop_top_mgr(
-		struct dc_context *ctx,
-		const struct dc_link *link)
-{
-	struct amdgpu_device *adev = ctx->driver_context;
-	struct drm_device *dev = adev->ddev;
-	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
-
-	if (aconnector)
-		drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, false);
-}
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index 27e57c7..4006d63 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -1314,7 +1314,7 @@ static u8 dm_get_backlight_level(struct amdgpu_encoder *amdgpu_encoder)
 
 /**
  * dm_page_flip - called by amdgpu_flip_work_func(), which is triggered
- *			via DRM IOCTL, by user mode.
+ * 			via DRM IOCTL, by user mode.
  *
  * @adev: amdgpu_device pointer
  * @crtc_id: crtc to cleanup pageflip on
@@ -1323,7 +1323,7 @@ static u8 dm_get_backlight_level(struct amdgpu_encoder *amdgpu_encoder)
  * Does the actual pageflip (surface address update).
  */
 static void dm_page_flip(struct amdgpu_device *adev,
-			int crtc_id, u64 crtc_base)
+			 int crtc_id, u64 crtc_base, bool async)
 {
 	struct amdgpu_crtc *acrtc;
 	struct dc_target *target;
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
index 5b7562b..625abed 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_helpers.c
@@ -139,7 +139,6 @@ enum dc_edid_status dm_helpers_parse_edid_caps(
 	return result;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 static struct amdgpu_connector *get_connector_for_sink(
 	struct drm_device *dev,
 	const struct dc_sink *sink)
@@ -147,14 +146,13 @@ static struct amdgpu_connector *get_connector_for_sink(
 	struct drm_connector *connector;
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-                struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+		struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
 		if (aconnector->dc_sink == sink)
-                        return aconnector;
+			return aconnector;
 	}
 
-        return NULL;
+	return NULL;
 }
-#endif
 
 static struct amdgpu_connector *get_connector_for_link(
 	struct drm_device *dev,
@@ -163,16 +161,14 @@ static struct amdgpu_connector *get_connector_for_link(
 	struct drm_connector *connector;
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-                struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+		struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
 		if (aconnector->dc_link == link)
-			break;
-                        return aconnector;
+			return aconnector;
 	}
 
-        return NULL;
+	return NULL;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 static void get_payload_table(
 		struct amdgpu_connector *aconnector,
 		struct dp_mst_stream_allocation_table *proposed_table)
@@ -209,7 +205,6 @@ static void get_payload_table(
 
 	mutex_unlock(&mst_mgr->payload_lock);
 }
-#endif
 
 /*
  * Writes payload allocation table in immediate downstream device.
@@ -220,7 +215,6 @@ bool dm_helpers_dp_mst_write_payload_allocation_table(
 		struct dp_mst_stream_allocation_table *proposed_table,
 		bool enable)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 	struct amdgpu_device *adev = ctx->driver_context;
 	struct drm_device *dev = adev->ddev;
 	struct amdgpu_connector *aconnector;
@@ -300,9 +294,6 @@ bool dm_helpers_dp_mst_write_payload_allocation_table(
 		return false;
 
 	return true;
-#else
-	return false;
-#endif
 }
 
 /*
@@ -313,7 +304,6 @@ bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 		struct dc_context *ctx,
 		const struct dc_stream *stream)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 	struct amdgpu_device *adev = ctx->driver_context;
 	struct drm_device *dev = adev->ddev;
 	struct amdgpu_connector *aconnector;
@@ -336,9 +326,6 @@ bool dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 		return false;
 
 	return true;
-#else
-	return false;
-#endif
 }
 
 bool dm_helpers_dp_mst_send_payload_allocation(
@@ -346,7 +333,6 @@ bool dm_helpers_dp_mst_send_payload_allocation(
 		const struct dc_stream *stream,
 		bool enable)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 	struct amdgpu_device *adev = ctx->driver_context;
 	struct drm_device *dev = adev->ddev;
 	struct amdgpu_connector *aconnector;
@@ -375,9 +361,6 @@ bool dm_helpers_dp_mst_send_payload_allocation(
 		drm_dp_mst_deallocate_vcpi(mst_mgr, mst_port);
 
 	return true;
-#else
-	return false;
-#endif
 }
 
 bool dm_helpers_dp_mst_start_top_mgr(
@@ -385,7 +368,6 @@ bool dm_helpers_dp_mst_start_top_mgr(
 		const struct dc_link *link,
 		bool boot)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 	struct amdgpu_device *adev = ctx->driver_context;
 	struct drm_device *dev = adev->ddev;
 	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
@@ -405,16 +387,12 @@ bool dm_helpers_dp_mst_start_top_mgr(
 			aconnector, aconnector->base.base.id);
 
 	return (drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true) == 0);
-#else
-	return false;
-#endif
 }
 
 void dm_helpers_dp_mst_stop_top_mgr(
 		struct dc_context *ctx,
 		const struct dc_link *link)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 	struct amdgpu_device *adev = ctx->driver_context;
 	struct drm_device *dev = adev->ddev;
 	struct amdgpu_connector *aconnector = get_connector_for_link(dev, link);
@@ -429,7 +407,6 @@ void dm_helpers_dp_mst_stop_top_mgr(
 
 	if (aconnector->mst_mgr.mst_state == true)
 		drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, false);
-#endif
 }
 
 bool dm_helpers_dp_read_dpcd(
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.h b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.h
index 7f6d9ea..9339861 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.h
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_irq.h
@@ -60,8 +60,8 @@ void amdgpu_dm_irq_fini(
  * @handler_args: arguments which will be passed to ih
  *
  * Returns:
- *	IRQ Handler Index on success.
- *	NULL on failure.
+ * 	IRQ Handler Index on success.
+ * 	NULL on failure.
  *
  * Cannot be called from an interrupt handler.
  */
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
index d148717..7521efd 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -115,7 +115,6 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg
 	return msg->size;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 static enum drm_connector_status
 dm_dp_mst_detect(struct drm_connector *connector, bool force)
 {
@@ -212,7 +211,8 @@ dm_dp_create_fake_mst_encoder(struct amdgpu_connector *connector)
 		dev,
 		&amdgpu_encoder->base,
 		NULL,
-		DRM_MODE_ENCODER_DPMST);
+		DRM_MODE_ENCODER_DPMST,
+		NULL);
 
 	drm_encoder_helper_add(encoder, &amdgpu_dm_encoder_helper_funcs);
 
@@ -419,7 +419,6 @@ static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 	.hotplug = dm_dp_mst_hotplug,
 	.register_connector = dm_dp_mst_register_connector
 };
-#endif
 
 void amdgpu_dm_initialize_mst_connector(
 	struct amdgpu_display_manager *dm,
@@ -431,7 +430,6 @@ void amdgpu_dm_initialize_mst_connector(
 	aconnector->dm_dp_aux.link_index = aconnector->connector_id;
 
 	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
 	aconnector->mst_mgr.cbs = &dm_mst_cbs;
 	drm_dp_mst_topology_mgr_init(
 		&aconnector->mst_mgr,
@@ -440,6 +438,5 @@ void amdgpu_dm_initialize_mst_connector(
 		16,
 		4,
 		aconnector->connector_id);
-#endif
 }
 
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index 11ac421..1f3e95f 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -156,7 +156,7 @@ static int dm_crtc_pin_cursor_bo_new(
 
 		amdgpu_crtc = to_amdgpu_crtc(crtc);
 
-		obj = drm_gem_object_lookup(crtc->dev, file_priv, handle);
+		obj = drm_gem_object_lookup(file_priv, handle);
 
 		if (!obj) {
 			DRM_ERROR(
@@ -1366,11 +1366,11 @@ struct drm_connector_state *amdgpu_dm_connector_atomic_duplicate_state(
 		to_dm_connector_state(connector->state);
 
 	struct dm_connector_state *new_state =
-                        kmemdup(state, sizeof(*state), GFP_KERNEL);
+			kmemdup(state, sizeof(*state), GFP_KERNEL);
 
 	if (new_state) {
-                __drm_atomic_helper_connector_duplicate_state(connector,
-                                                                      &new_state->base);
+		__drm_atomic_helper_connector_duplicate_state(connector,
+								      &new_state->base);
 		return &new_state->base;
 	}
 
@@ -1809,10 +1809,7 @@ int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
 	if (!primary_plane)
 		goto fail_plane;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 3, 0)
-	/* this flag doesn't exist in older kernels */
 	primary_plane->format_default = true;
-#endif
 
 	res = drm_universal_plane_init(
 		dm->adev->ddev,
@@ -1821,7 +1818,7 @@ int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
 		&dm_plane_funcs,
 		rgb_formats,
 		ARRAY_SIZE(rgb_formats),
-		DRM_PLANE_TYPE_PRIMARY);
+		DRM_PLANE_TYPE_PRIMARY, NULL);
 
 	primary_plane->crtc = &acrtc->base;
 
@@ -1832,7 +1829,7 @@ int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
 			&acrtc->base,
 			primary_plane,
 			NULL,
-			&amdgpu_dm_crtc_funcs);
+			&amdgpu_dm_crtc_funcs, NULL);
 
 	if (res)
 		goto fail;
@@ -1909,6 +1906,88 @@ static void amdgpu_dm_get_native_mode(struct drm_connector *connector)
 	}
 }
 
+static struct drm_display_mode *amdgpu_dm_create_common_mode(
+		struct drm_encoder *encoder, char *name,
+		int hdisplay, int vdisplay)
+{
+	struct drm_device *dev = encoder->dev;
+	struct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);
+	struct drm_display_mode *mode = NULL;
+	struct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;
+
+	mode = drm_mode_duplicate(dev, native_mode);
+
+	if(mode == NULL)
+		return NULL;
+
+	mode->hdisplay = hdisplay;
+	mode->vdisplay = vdisplay;
+	mode->type &= ~DRM_MODE_TYPE_PREFERRED;
+	strncpy(mode->name, name, DRM_DISPLAY_MODE_LEN);
+
+	return mode;
+
+}
+
+static void amdgpu_dm_connector_add_common_modes(struct drm_encoder *encoder,
+					struct drm_connector *connector)
+{
+	struct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);
+	struct drm_display_mode *mode = NULL;
+	struct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;
+	struct amdgpu_connector *amdgpu_connector =
+				to_amdgpu_connector(connector);
+	int i;
+	int n;
+	struct mode_size {
+		char name[DRM_DISPLAY_MODE_LEN];
+		int w;
+		int h;
+	}common_modes[] = {
+		{  "640x480",  640,  480},
+		{  "800x600",  800,  600},
+		{ "1024x768", 1024,  768},
+		{ "1280x720", 1280,  720},
+		{ "1280x800", 1280,  800},
+		{"1280x1024", 1280, 1024},
+		{ "1440x900", 1440,  900},
+		{"1680x1050", 1680, 1050},
+		{"1600x1200", 1600, 1200},
+		{"1920x1080", 1920, 1080},
+		{"1920x1200", 1920, 1200}
+	};
+
+	n = sizeof(common_modes) / sizeof(common_modes[0]);
+
+	for (i = 0; i < n; i++) {
+		struct drm_display_mode *curmode = NULL;
+		bool mode_existed = false;
+
+		if (common_modes[i].w > native_mode->hdisplay ||
+			common_modes[i].h > native_mode->vdisplay ||
+			(common_modes[i].w == native_mode->hdisplay &&
+			common_modes[i].h == native_mode->vdisplay))
+				continue;
+
+		list_for_each_entry(curmode, &connector->probed_modes, head) {
+			if (common_modes[i].w == curmode->hdisplay &&
+				common_modes[i].h == curmode->vdisplay) {
+				mode_existed = true;
+				break;
+			}
+		}
+
+		if (mode_existed)
+			continue;
+
+		mode = amdgpu_dm_create_common_mode(encoder,
+				common_modes[i].name, common_modes[i].w,
+				common_modes[i].h);
+		drm_mode_probed_add(connector, mode);
+		amdgpu_connector->num_modes++;
+	}
+}
+
 static void amdgpu_dm_connector_ddc_get_modes(
 	struct drm_connector *connector,
 	struct edid *edid)
@@ -1941,7 +2020,7 @@ int amdgpu_dm_connector_get_modes(struct drm_connector *connector)
 	encoder = helper->best_encoder(connector);
 
 	amdgpu_dm_connector_ddc_get_modes(connector, edid);
-	//amdgpu_dm_connector_add_common_modes(encoder, connector);
+	amdgpu_dm_connector_add_common_modes(encoder, connector);
 	return amdgpu_connector->num_modes;
 }
 
@@ -2177,7 +2256,8 @@ int amdgpu_dm_encoder_init(
 	int res = drm_encoder_init(dev,
 				   &aencoder->base,
 				   &amdgpu_dm_encoder_funcs,
-				   DRM_MODE_ENCODER_TMDS);
+				   DRM_MODE_ENCODER_TMDS,
+				   NULL);
 
 	aencoder->base.possible_crtcs = amdgpu_dm_get_encoder_crtc_mask(adev);
 
@@ -2647,19 +2727,16 @@ int amdgpu_dm_atomic_commit(
 			!crtc->state->active)
 			continue;
 
-                if (page_flip_needed(plane_state, old_plane_state, false)) {
-                        ret = amdgpu_crtc_page_flip(
-                                                    crtc,
-                                                    fb,
-                                                    crtc->state->event,
-			                            acrtc->flip_flags);
-                        /*clean up the flags for next usage*/
-                        acrtc->flip_flags = 0;
-                }
-                        if (ret)
-                                return ret;
-                }
-
+		if (page_flip_needed(plane_state, old_plane_state, false)) {
+			ret = amdgpu_crtc_page_flip(crtc,
+						    fb,
+						    crtc->state->event,
+						    acrtc->flip_flags);
+			/*clean up the flags for next usage*/
+			acrtc->flip_flags = 0;
+			if (ret)
+				return ret;
+		}
 	}
 
 	/* In this state all old framebuffers would be unpinned */
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index dc0c99b..afd06a5 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -243,8 +243,8 @@ static void initialize_backlight_caps(
 			return;
 	}
 
-	if (dc_bios_get_firmware_info(dcb, &fw_info) != BP_RESULT_OK ||
-		dc_bios_get_embedded_panel_info(dcb, &panel_info) != BP_RESULT_OK)
+	if (dcb->funcs->get_firmware_info(dcb, &fw_info) != BP_RESULT_OK ||
+		dcb->funcs->get_embedded_panel_info(dcb, &panel_info) != BP_RESULT_OK)
 		return;
 
 	params.data = &caps;
@@ -549,7 +549,7 @@ static bool get_hpd_info(struct adapter_service *as,
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return BP_RESULT_OK == dc_bios_get_hpd_info(dcb, id, info);
+	return BP_RESULT_OK == dcb->funcs->get_hpd_info(dcb, id, info);
 }
 
 /*
@@ -702,7 +702,7 @@ static void adapter_service_destruct(
 	dal_gpio_service_destroy(&as->gpio_service);
 	dal_asic_capability_destroy(&as->asic_cap);
 
-	dc_bios_destroy_integrated_info(dcb, &as->integrated_info);
+	dcb->funcs->destroy_integrated_info(dcb, &as->integrated_info);
 }
 
 /*
@@ -797,10 +797,10 @@ static bool adapter_service_construct(
 	}
 
 	/* Integrated info is not provided on discrete ASIC. NULL is allowed */
-        if (dcb->funcs->create_integrated_info)
-                as->integrated_info = dcb->funcs->create_integrated_info(dcb);
-	
-	dc_bios_post_init(dcb, as);
+	if (dcb->funcs->create_integrated_info)
+		as->integrated_info = dcb->funcs->create_integrated_info(dcb);
+
+	dcb->funcs->post_init(dcb, as);
 
 	/* Generate backlight translation table and initializes
 			  other brightness properties */
@@ -957,7 +957,7 @@ struct graphics_object_id dal_adapter_service_get_src_obj(
 	if (is_wireless_object(id))
 		src_object_id = wireless_get_src_obj_id(as, id, index);
 	else {
-		if (BP_RESULT_OK != dc_bios_get_src_obj(dcb, id, index,
+		if (BP_RESULT_OK != dcb->funcs->get_src_obj(dcb, id, index,
 				&src_object_id)) {
 			src_object_id =
 				dal_graphics_object_id_init(
@@ -978,8 +978,8 @@ bool dal_adapter_service_get_device_tag(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	if (BP_RESULT_OK == dc_bios_get_device_tag(dcb,
-						   connector_object_id, device_tag_index, info))
+	if (BP_RESULT_OK == dcb->funcs->get_device_tag(dcb,
+			connector_object_id, device_tag_index, info))
 		return true;
 	else
 		return false;
@@ -991,7 +991,7 @@ bool dal_adapter_service_is_device_id_supported(struct adapter_service *as,
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dc_bios_is_device_id_supported(dcb, id);
+	return dcb->funcs->is_device_id_supported(dcb, id);
 }
 
 /*
@@ -1011,7 +1011,7 @@ uint8_t dal_adapter_service_get_clock_sources_num(
 	 * Check is system supports the use of the External clock source
 	 * as a clock source for DP
 	 */
-	enum bp_result bp_result = dc_bios_get_firmware_info(dcb, &fw_info);
+	enum bp_result bp_result = dcb->funcs->get_firmware_info(dcb, &fw_info);
 
 	if (BP_RESULT_OK == bp_result &&
 			fw_info.external_clock_source_frequency_for_dp != 0)
@@ -1093,7 +1093,7 @@ bool dal_adapter_service_get_i2c_info(
 		return false;
 	}
 
-	return BP_RESULT_OK == dc_bios_get_i2c_info(dcb, id, i2c_info);
+	return BP_RESULT_OK == dcb->funcs->get_i2c_info(dcb, id, i2c_info);
 }
 
 /*
@@ -1150,7 +1150,7 @@ struct irq *dal_adapter_service_obtain_hpd_irq(
 	if (!get_hpd_info(as, id, &hpd_info))
 		return NULL;
 
-	bp_result = dc_bios_get_gpio_pin_info(dcb,
+	bp_result = dcb->funcs->get_gpio_pin_info(dcb,
 		hpd_info.hpd_int_gpio_uid, &pin_info);
 
 	if (bp_result != BP_RESULT_OK) {
@@ -1187,7 +1187,7 @@ uint32_t dal_adapter_service_get_ss_info_num(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dc_bios_get_ss_entry_number(dcb, signal);
+	return dcb->funcs->get_ss_entry_number(dcb, signal);
 }
 
 /*
@@ -1203,8 +1203,8 @@ bool dal_adapter_service_get_ss_info(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	enum bp_result bp_result = dc_bios_get_spread_spectrum_info(dcb,
-								   signal, idx, info);
+	enum bp_result bp_result = dcb->funcs->get_spread_spectrum_info(dcb,
+			signal, idx, info);
 
 	return BP_RESULT_OK == bp_result;
 }
@@ -1296,7 +1296,7 @@ bool dal_adapter_service_get_firmware_info(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dc_bios_get_firmware_info(dcb, info) == BP_RESULT_OK;
+	return dcb->funcs->get_firmware_info(dcb, info) == BP_RESULT_OK;
 }
 
 /*
@@ -1422,7 +1422,7 @@ bool dal_adapter_service_get_embedded_panel_info(
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
 
-	result = dc_bios_get_embedded_panel_info(dcb, info);
+	result = dcb->funcs->get_embedded_panel_info(dcb, info);
 
 	return result == BP_RESULT_OK;
 }
@@ -1526,7 +1526,7 @@ bool dal_adapter_service_get_encoder_cap_info(
 	 * - dpHbr2Cap: indicates supported/not supported by HW Encoder
 	 * - dpHbr2En : indicates DP spec compliant/not compliant
 	 */
-	result = dc_bios_get_encoder_cap_info(dcb, id, &bp_cap_info);
+	result = dcb->funcs->get_encoder_cap_info(dcb, id, &bp_cap_info);
 
 	/* Set dp_hbr2_validated flag (it's equal to Enable) */
 	info->dp_hbr2_validated = bp_cap_info.DP_HBR2_EN;
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
index 1b6deb9..0b1151e 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
@@ -66,7 +66,7 @@ bool wireless_data_init(struct wireless_data *data,
 		 * Check if SBIOS sets remote display enable, exposed
 		 * through VBIOS. This is only valid for APU, not dGPU
 		 */
-		dc_bios_get_firmware_info(dcb, &info);
+		dcb->funcs->get_firmware_info(dcb, &info);
 
 		if ((REMOTE_DISPLAY_ENABLE == info.remote_display_config) &&
 				init_data->fusion) {
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
index 5308be1..63b4d4f 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
@@ -37,6 +37,7 @@
 #include "command_table.h"
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
 #include "bios_parser_helper.h"
+#include "dce110/bios_dce110.h"
 #endif
 #include "command_table_helper.h"
 #include "bios_parser.h"
@@ -100,8 +101,12 @@ static bool bios_parser_construct(
 	struct bp_init_data *init,
 	enum dce_version dce_version);
 
-enum bp_result dc_bios_get_embedded_panel_info(struct dc_bios *dcb,
-					       struct embedded_panel_info *info);
+static uint8_t bios_parser_get_connectors_number(
+	struct dc_bios *dcb);
+
+static enum bp_result bios_parser_get_embedded_panel_info(
+	struct dc_bios *dcb,
+	struct embedded_panel_info *info);
 
 /*****************************************************************************/
 
@@ -116,7 +121,7 @@ struct dc_bios *bios_parser_create(
 		return NULL;
 
 	if (bios_parser_construct(bp, init, dce_version))
-		return (struct dc_bios *)bp;
+		return &bp->base;
 
 	dm_free(bp);
 	BREAK_TO_DEBUGGER();
@@ -144,16 +149,6 @@ static void bios_parser_destroy(struct dc_bios **dcb)
 	*dcb = NULL;
 }
 
-void dc_bios_power_up(struct dc_bios *dcb)
-{
-#if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (bp->lcd_scale == LCD_SCALE_UNKNOWN)
-		bp->lcd_scale = bp->bios_helper->get_scratch_lcd_scale(bp->ctx);
-#endif
-}
-
 static uint8_t get_number_of_objects(struct bios_parser *bp, uint32_t offset)
 {
 	ATOM_OBJECT_TABLE *table;
@@ -168,15 +163,7 @@ static uint8_t get_number_of_objects(struct bios_parser *bp, uint32_t offset)
 		return table->ucNumberOfObjects;
 }
 
-uint8_t dc_bios_get_encoders_number(struct dc_bios *dcb)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	return get_number_of_objects(bp,
-		le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset));
-}
-
-uint8_t dc_bios_get_connectors_number(struct dc_bios *dcb)
+static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -184,32 +171,9 @@ uint8_t dc_bios_get_connectors_number(struct dc_bios *dcb)
 		le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset));
 }
 
-uint32_t dc_bios_get_oem_ddc_lines_number(struct dc_bios *dcb)
-{
-	uint32_t number = 0;
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (DATA_TABLES(OemInfo) != 0) {
-		ATOM_OEM_INFO *info;
-
-		info = GET_IMAGE(ATOM_OEM_INFO,
-			DATA_TABLES(OemInfo));
-
-		if (le16_to_cpu(info->sHeader.usStructureSize)
-			> sizeof(ATOM_COMMON_TABLE_HEADER)) {
-
-			number = (le16_to_cpu(info->sHeader.usStructureSize)
-				- sizeof(ATOM_COMMON_TABLE_HEADER))
-				/ sizeof(ATOM_I2C_ID_CONFIG_ACCESS);
-
-		}
-	}
-
-	return number;
-}
-
-struct graphics_object_id dc_bios_get_encoder_id(struct dc_bios *dcb,
-						 uint32_t i)
+static struct graphics_object_id bios_parser_get_encoder_id(
+	struct dc_bios *dcb,
+	uint32_t i)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct graphics_object_id object_id = dal_graphics_object_id_init(
@@ -230,8 +194,9 @@ struct graphics_object_id dc_bios_get_encoder_id(struct dc_bios *dcb,
 	return object_id;
 }
 
-struct graphics_object_id dc_bios_get_connector_id(struct dc_bios *dcb,
-						   uint8_t i)
+static struct graphics_object_id bios_parser_get_connector_id(
+	struct dc_bios *dcb,
+	uint8_t i)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct graphics_object_id object_id = dal_graphics_object_id_init(
@@ -252,33 +217,8 @@ struct graphics_object_id dc_bios_get_connector_id(struct dc_bios *dcb,
 	return object_id;
 }
 
-uint32_t dc_bios_get_src_number(struct dc_bios *dcb,
-				struct graphics_object_id id)
-{
-	uint32_t offset;
-	uint8_t *number;
-	ATOM_OBJECT *object;
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	object = get_bios_object(bp, id);
-
-	if (!object) {
-		BREAK_TO_DEBUGGER(); /* Invalid object id */
-		return 0;
-	}
-
-	offset = le16_to_cpu(object->usSrcDstTableOffset)
-			+ bp->object_info_tbl_offset;
-
-	number = GET_IMAGE(uint8_t, offset);
-	if (!number)
-		return 0;
-
-	return *number;
-}
-
-uint32_t dc_bios_get_dst_number(struct dc_bios *dcb,
-				struct graphics_object_id id)
+static uint32_t bios_parser_get_dst_number(struct dc_bios *dcb,
+	struct graphics_object_id id)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object = get_bios_object(bp, id);
@@ -286,10 +226,9 @@ uint32_t dc_bios_get_dst_number(struct dc_bios *dcb,
 	return get_dst_number_from_object(bp, object);
 }
 
-enum bp_result dc_bios_get_src_obj(struct dc_bios *dcb,
-				   struct graphics_object_id object_id,
-				   uint32_t index,
-				   struct graphics_object_id *src_object_id)
+static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
+	struct graphics_object_id object_id, uint32_t index,
+	struct graphics_object_id *src_object_id)
 {
 	uint32_t number;
 	uint16_t *id;
@@ -316,10 +255,9 @@ enum bp_result dc_bios_get_src_obj(struct dc_bios *dcb,
 	return BP_RESULT_OK;
 }
 
-enum bp_result dc_bios_get_dst_obj(struct dc_bios *dcb,
-				   struct graphics_object_id object_id,
-				   uint32_t index,
-				   struct graphics_object_id *dest_object_id)
+static enum bp_result bios_parser_get_dst_obj(struct dc_bios *dcb,
+	struct graphics_object_id object_id, uint32_t index,
+	struct graphics_object_id *dest_object_id)
 {
 	uint32_t number;
 	uint16_t *id;
@@ -341,46 +279,9 @@ enum bp_result dc_bios_get_dst_obj(struct dc_bios *dcb,
 	return BP_RESULT_OK;
 }
 
-enum bp_result dc_bios_get_oem_ddc_info(struct dc_bios *dcb,
-					uint32_t index,
-					struct graphics_object_i2c_info *info)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!info)
-		return BP_RESULT_BADINPUT;
-
-	if (DATA_TABLES(OemInfo) != 0) {
-		ATOM_OEM_INFO *tbl;
-
-		tbl = GET_IMAGE(ATOM_OEM_INFO, DATA_TABLES(OemInfo));
-
-		if (le16_to_cpu(tbl->sHeader.usStructureSize)
-			> sizeof(ATOM_COMMON_TABLE_HEADER)) {
-			ATOM_I2C_RECORD record;
-			ATOM_I2C_ID_CONFIG_ACCESS *config;
-
-			memset(&record, 0, sizeof(record));
-
-			config = &tbl->sucI2cId + index - 1;
-
-			record.sucI2cId.bfHW_Capable =
-				config->sbfAccess.bfHW_Capable;
-			record.sucI2cId.bfI2C_LineMux =
-				config->sbfAccess.bfI2C_LineMux;
-			record.sucI2cId.bfHW_EngineID =
-				config->sbfAccess.bfHW_EngineID;
-
-			return get_gpio_i2c_info(bp, &record, info);
-		}
-	}
-
-	return BP_RESULT_NORECORD;
-}
-
-enum bp_result dc_bios_get_i2c_info(struct dc_bios *dcb,
-				    struct graphics_object_id id,
-				    struct graphics_object_i2c_info *info)
+static enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,
+	struct graphics_object_id id,
+	struct graphics_object_i2c_info *info)
 {
 	uint32_t offset;
 	ATOM_OBJECT *object;
@@ -484,9 +385,10 @@ static enum bp_result get_voltage_ddc_info_v3(uint8_t *i2c_line,
 	return result;
 }
 
-enum bp_result dc_bios_get_thermal_ddc_info(struct dc_bios *dcb,
-					    uint32_t i2c_channel_id,
-					    struct graphics_object_i2c_info *info)
+static enum bp_result bios_parser_get_thermal_ddc_info(
+	struct dc_bios *dcb,
+	uint32_t i2c_channel_id,
+	struct graphics_object_i2c_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_I2C_ID_CONFIG_ACCESS *config;
@@ -504,9 +406,9 @@ enum bp_result dc_bios_get_thermal_ddc_info(struct dc_bios *dcb,
 	return get_gpio_i2c_info(bp, &record, info);
 }
 
-enum bp_result dc_bios_get_voltage_ddc_info(struct dc_bios *dcb,
-					    uint32_t index,
-					    struct graphics_object_i2c_info *info)
+static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
+	uint32_t index,
+	struct graphics_object_i2c_info *info)
 {
 	uint8_t i2c_line = 0;
 	enum bp_result result = BP_RESULT_NORECORD;
@@ -539,8 +441,8 @@ enum bp_result dc_bios_get_voltage_ddc_info(struct dc_bios *dcb,
 	}
 
 	if (result == BP_RESULT_OK)
-		result = dc_bios_get_thermal_ddc_info(dcb,
-						      i2c_line, info);
+		result = bios_parser_get_thermal_ddc_info(dcb,
+			i2c_line, info);
 
 	return result;
 }
@@ -613,9 +515,9 @@ static enum bp_result bios_parser_get_ddc_info_for_i2c_line(
 }
 #endif
 
-enum bp_result dc_bios_get_hpd_info(struct dc_bios *dcb,
-				    struct graphics_object_id id,
-				    struct graphics_object_hpd_info *info)
+static enum bp_result bios_parser_get_hpd_info(struct dc_bios *dcb,
+	struct graphics_object_id id,
+	struct graphics_object_hpd_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
@@ -640,10 +542,11 @@ enum bp_result dc_bios_get_hpd_info(struct dc_bios *dcb,
 	return BP_RESULT_NORECORD;
 }
 
-uint32_t dc_bios_get_gpio_record(struct dc_bios *dcb,
-				 struct graphics_object_id id,
-				 struct bp_gpio_cntl_info *gpio_record,
-				 uint32_t record_size)
+static uint32_t bios_parser_get_gpio_record(
+	struct dc_bios *dcb,
+	struct graphics_object_id id,
+	struct bp_gpio_cntl_info *gpio_record,
+	uint32_t record_size)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_COMMON_RECORD_HEADER *header = NULL;
@@ -750,10 +653,11 @@ enum bp_result bios_parser_get_device_tag_record(
 	return BP_RESULT_NORECORD;
 }
 
-enum bp_result dc_bios_get_device_tag(struct dc_bios *dcb,
-				      struct graphics_object_id connector_object_id,
-				      uint32_t device_tag_index,
-				      struct connector_device_tag_info *info)
+static enum bp_result bios_parser_get_device_tag(
+	struct dc_bios *dcb,
+	struct graphics_object_id connector_object_id,
+	uint32_t device_tag_index,
+	struct connector_device_tag_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
@@ -797,7 +701,7 @@ static enum bp_result get_firmware_info_v2_2(
 	struct bios_parser *bp,
 	struct firmware_info *info);
 
-enum bp_result dc_bios_get_firmware_info(
+static enum bp_result bios_parser_get_firmware_info(
 	struct dc_bios *dcb,
 	struct firmware_info *info)
 {
@@ -1148,8 +1052,9 @@ static enum bp_result get_ss_info_v3_1(
 	return BP_RESULT_NORECORD;
 }
 
-enum bp_result dc_bios_transmitter_control(struct dc_bios *dcb,
-					   struct bp_transmitter_control *cntl)
+static enum bp_result bios_parser_transmitter_control(
+	struct dc_bios *dcb,
+	struct bp_transmitter_control *cntl)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1159,8 +1064,9 @@ enum bp_result dc_bios_transmitter_control(struct dc_bios *dcb,
 	return bp->cmd_tbl.transmitter_control(bp, cntl);
 }
 
-enum bp_result dc_bios_encoder_control(struct dc_bios *dcb,
-					   struct bp_encoder_control *cntl)
+static enum bp_result bios_parser_encoder_control(
+	struct dc_bios *dcb,
+	struct bp_encoder_control *cntl)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1170,8 +1076,9 @@ enum bp_result dc_bios_encoder_control(struct dc_bios *dcb,
 	return bp->cmd_tbl.dig_encoder_control(bp, cntl);
 }
 
-enum bp_result dc_bios_adjust_pixel_clock(struct dc_bios *dcb,
-					  struct bp_adjust_pixel_clock_parameters *bp_params)
+static enum bp_result bios_parser_adjust_pixel_clock(
+	struct dc_bios *dcb,
+	struct bp_adjust_pixel_clock_parameters *bp_params)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1181,8 +1088,9 @@ enum bp_result dc_bios_adjust_pixel_clock(struct dc_bios *dcb,
 	return bp->cmd_tbl.adjust_display_pll(bp, bp_params);
 }
 
-enum bp_result dc_bios_set_pixel_clock(struct dc_bios *dcb,
-				       struct bp_pixel_clock_parameters *bp_params)
+static enum bp_result bios_parser_set_pixel_clock(
+	struct dc_bios *dcb,
+	struct bp_pixel_clock_parameters *bp_params)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1192,8 +1100,9 @@ enum bp_result dc_bios_set_pixel_clock(struct dc_bios *dcb,
 	return bp->cmd_tbl.set_pixel_clock(bp, bp_params);
 }
 
-enum bp_result dc_bios_set_dce_clock(struct dc_bios *dcb,
-					 struct bp_set_dce_clock_parameters *bp_params)
+static enum bp_result bios_parser_set_dce_clock(
+	struct dc_bios *dcb,
+	struct bp_set_dce_clock_parameters *bp_params)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1203,7 +1112,7 @@ enum bp_result dc_bios_set_dce_clock(struct dc_bios *dcb,
 	return bp->cmd_tbl.set_dce_clock(bp, bp_params);
 }
 
-enum bp_result dc_bios_enable_spread_spectrum_on_ppll(
+static enum bp_result bios_parser_enable_spread_spectrum_on_ppll(
 	struct dc_bios *dcb,
 	struct bp_spread_spectrum_parameters *bp_params,
 	bool enable)
@@ -1218,7 +1127,7 @@ enum bp_result dc_bios_enable_spread_spectrum_on_ppll(
 
 }
 
-enum bp_result dc_bios_program_crtc_timing(
+static enum bp_result bios_parser_program_crtc_timing(
 	struct dc_bios *dcb,
 	struct bp_hw_crtc_timing_parameters *bp_params)
 {
@@ -1230,7 +1139,7 @@ enum bp_result dc_bios_program_crtc_timing(
 	return bp->cmd_tbl.set_crtc_timing(bp, bp_params);
 }
 
-enum bp_result dc_bios_program_display_engine_pll(
+static enum bp_result bios_parser_program_display_engine_pll(
 	struct dc_bios *dcb,
 	struct bp_pixel_clock_parameters *bp_params)
 {
@@ -1243,33 +1152,8 @@ enum bp_result dc_bios_program_display_engine_pll(
 
 }
 
-enum signal_type dc_bios_dac_load_detect(struct dc_bios *dcb,
-					 struct graphics_object_id encoder,
-					 struct graphics_object_id connector,
-					 enum signal_type display_signal)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.dac_load_detection)
-		return SIGNAL_TYPE_NONE;
-
-	return bp->cmd_tbl.dac_load_detection(bp, encoder, connector,
-		display_signal);
-}
-
-enum bp_result dc_bios_get_divider_for_target_display_clock(
-	struct dc_bios *dcb,
-	struct bp_display_clock_parameters *bp_params)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.compute_memore_engine_pll)
-		return BP_RESULT_FAILURE;
-
-	return bp->cmd_tbl.compute_memore_engine_pll(bp, bp_params);
-}
 
-enum bp_result dc_bios_enable_crtc(
+static enum bp_result bios_parser_enable_crtc(
 	struct dc_bios *dcb,
 	enum controller_id id,
 	bool enable)
@@ -1282,20 +1166,7 @@ enum bp_result dc_bios_enable_crtc(
 	return bp->cmd_tbl.enable_crtc(bp, id, enable);
 }
 
-enum bp_result dc_bios_blank_crtc(
-	struct dc_bios *dcb,
-	struct bp_blank_crtc_parameters *bp_params,
-	bool blank)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.blank_crtc)
-		return BP_RESULT_FAILURE;
-
-	return bp->cmd_tbl.blank_crtc(bp, bp_params, blank);
-}
-
-enum bp_result dc_bios_crtc_source_select(
+static enum bp_result bios_parser_crtc_source_select(
 	struct dc_bios *dcb,
 	struct bp_crtc_source_select *bp_params)
 {
@@ -1307,44 +1178,7 @@ enum bp_result dc_bios_crtc_source_select(
 	return bp->cmd_tbl.select_crtc_source(bp, bp_params);
 }
 
-enum bp_result dc_bios_set_overscan(
-	struct dc_bios *dcb,
-	struct bp_hw_crtc_overscan_parameters *bp_params)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.set_crtc_overscan)
-		return BP_RESULT_FAILURE;
-
-	return bp->cmd_tbl.set_crtc_overscan(bp, bp_params);
-}
-
-enum bp_result dc_bios_enable_memory_requests(
-	struct dc_bios *dcb,
-	enum controller_id controller_id,
-	bool enable)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.enable_crtc_mem_req)
-		return BP_RESULT_FAILURE;
-
-	return bp->cmd_tbl.enable_crtc_mem_req(bp, controller_id, enable);
-}
-
-enum bp_result dc_bios_external_encoder_control(
-	struct dc_bios *dcb,
-	struct bp_external_encoder_control *cntl)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-	if (!bp->cmd_tbl.external_encoder_control)
-		return BP_RESULT_FAILURE;
-
-	return bp->cmd_tbl.external_encoder_control(bp, cntl);
-}
-
-enum bp_result dc_bios_enable_disp_power_gating(
+static enum bp_result bios_parser_enable_disp_power_gating(
 	struct dc_bios *dcb,
 	enum controller_id controller_id,
 	enum bp_pipe_control_action action)
@@ -1358,8 +1192,9 @@ enum bp_result dc_bios_enable_disp_power_gating(
 		action);
 }
 
-bool dc_bios_is_device_id_supported(struct dc_bios *dcb,
-				    struct device_id id)
+static bool bios_parser_is_device_id_supported(
+	struct dc_bios *dcb,
+	struct device_id id)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1368,7 +1203,7 @@ bool dc_bios_is_device_id_supported(struct dc_bios *dcb,
 	return (le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport) & mask) != 0;
 }
 
-enum bp_result dc_bios_crt_control(
+static enum bp_result bios_parser_crt_control(
 	struct dc_bios *dcb,
 	enum engine_id engine_id,
 	bool enable,
@@ -1510,7 +1345,7 @@ static enum bp_result get_ss_info_from_tbl(
 	uint32_t id,
 	struct spread_spectrum_info *ss_info);
 /**
- * dc_bios_get_spread_spectrum_info
+ * bios_parser_get_spread_spectrum_info
  * Get spread spectrum information from the ASIC_InternalSS_Info(ver 2.1 or
  * ver 3.1) or SS_Info table from the VBIOS. Currently ASIC_InternalSS_Info
  * ver 2.1 can co-exist with SS_Info table. Expect ASIC_InternalSS_Info ver 3.1,
@@ -1522,7 +1357,7 @@ static enum bp_result get_ss_info_from_tbl(
  * @param [out] ss_info, sprectrum information structure,
  * @return Bios parser result code
  */
-enum bp_result dc_bios_get_spread_spectrum_info(
+static enum bp_result bios_parser_get_spread_spectrum_info(
 	struct dc_bios *dcb,
 	enum as_signal_type signal,
 	uint32_t index,
@@ -1720,7 +1555,7 @@ static enum bp_result get_ss_info_from_ss_info_table(
 	{
 		struct embedded_panel_info panel_info;
 
-		if (dc_bios_get_embedded_panel_info((struct dc_bios *)bp, &panel_info)
+		if (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)
 				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
@@ -1776,7 +1611,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 	struct bios_parser *bp,
 	struct embedded_panel_info *info);
 
-enum bp_result dc_bios_get_embedded_panel_info(
+static enum bp_result bios_parser_get_embedded_panel_info(
 	struct dc_bios *dcb,
 	struct embedded_panel_info *info)
 {
@@ -2055,7 +1890,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 }
 
 /**
- * dc_bios_get_encoder_cap_info
+ * bios_parser_get_encoder_cap_info
  *
  * @brief
  *  Get encoder capability information of input object id
@@ -2066,9 +1901,10 @@ static enum bp_result get_embedded_panel_info_v1_3(
  * @return Bios parser result code
  *
  */
-enum bp_result dc_bios_get_encoder_cap_info(struct dc_bios *dcb,
-					    struct graphics_object_id object_id,
-					    struct bp_encoder_cap_info *info)
+static enum bp_result bios_parser_get_encoder_cap_info(
+	struct dc_bios *dcb,
+	struct graphics_object_id object_id,
+	struct bp_encoder_cap_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
@@ -2141,82 +1977,6 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 	return NULL;
 }
 
-/**
- * dc_bios_get_din_connector_info
- * @brief
- *   Get GPIO record for the DIN connector, this GPIO tells whether there is a
- *    CV dumb dongle
- *   attached to the DIN connector to perform load detection for the the
- *    appropriate signal
- *
- * @param id - DIN connector object id
- * @param info             - GPIO record infor
- * @return Bios parser result code
- */
-enum bp_result dc_bios_get_din_connector_info(struct dc_bios *dcb,
-					      struct graphics_object_id id,
-					      struct din_connector_info *info)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-	ATOM_COMMON_RECORD_HEADER *header;
-	ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD *record = NULL;
-	ATOM_OBJECT *object;
-	uint32_t offset;
-	enum bp_result result = BP_RESULT_NORECORD;
-
-	/* no output buffer provided */
-	if (!info) {
-		BREAK_TO_DEBUGGER(); /* Invalid output buffer */
-		return BP_RESULT_BADINPUT;
-	}
-
-	object = get_bios_object(bp, id);
-	if (!object) {
-		BREAK_TO_DEBUGGER(); /* Invalid object id */;
-		return BP_RESULT_BADINPUT;
-	}
-
-	offset = le16_to_cpu(object->usRecordOffset)
-						+ bp->object_info_tbl_offset;
-
-	for (;;) {
-		header = GET_IMAGE(ATOM_COMMON_RECORD_HEADER, offset);
-
-		if (!header) {
-			result = BP_RESULT_BADBIOSTABLE;
-			break;
-		}
-
-		offset += header->ucRecordSize;
-
-		/* get out of the loop if no more records */
-		if (LAST_RECORD_TYPE == header->ucRecordType ||
-				!header->ucRecordSize)
-			break;
-
-		if (ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD_TYPE !=
-				header->ucRecordType)
-			continue;
-
-		if (sizeof(ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD)
-				> header->ucRecordSize)
-			continue;
-
-		record = (ATOM_CONNECTOR_CVTV_SHARE_DIN_RECORD *)header;
-		result = BP_RESULT_OK;
-		break;
-	}
-
-	/* return if the record not found */
-	if (result != BP_RESULT_OK)
-		return result;
-
-	info->gpio_id = record->ucGPIOID;
-	info->gpio_tv_active_state = (record->ucTVActiveState != 0);
-
-	return result;
-}
-
 static uint32_t get_ss_entry_number(
 	struct bios_parser *bp,
 	uint32_t id);
@@ -2238,8 +1998,9 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
  * @param[in] signal, ASSignalType to be converted to SSid
  * @return number of SS Entry that match the signal
  */
-uint32_t dc_bios_get_ss_entry_number(struct dc_bios *dcb,
-				     enum as_signal_type signal)
+static uint32_t bios_parser_get_ss_entry_number(
+	struct dc_bios *dcb,
+	enum as_signal_type signal)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	uint32_t ss_id = 0;
@@ -2324,7 +2085,7 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 	case ASIC_INTERNAL_SS_ON_LVDS: {
 		struct embedded_panel_info panel_info;
 
-		if (dc_bios_get_embedded_panel_info((struct dc_bios *)bp, &panel_info)
+		if (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)
 				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
@@ -2453,7 +2214,7 @@ static uint32_t get_ss_entry_number_from_internal_ss_info_tbl_V3_1(
  *  2. in DATA_TABLE.GPIO_Pin_LUT, search all records, to get the registerA
  *  offset/mask
  */
-enum bp_result dc_bios_get_gpio_pin_info(
+static enum bp_result bios_parser_get_gpio_pin_info(
 	struct dc_bios *dcb,
 	uint32_t gpio_id,
 	struct gpio_pin_info *info)
@@ -3890,7 +3651,7 @@ static void process_ext_display_connection_info(struct bios_parser *bp,
 	}
 }
 
-void dc_bios_post_init(struct dc_bios *dcb,
+static void bios_parser_post_init(struct dc_bios *dcb,
 		       struct adapter_service *as)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
@@ -3898,7 +3659,8 @@ void dc_bios_post_init(struct dc_bios *dcb,
 	process_ext_display_connection_info(bp, as);
 }
 
-bool dc_bios_is_accelerated_mode(struct dc_bios *dcb)
+static bool bios_parser_is_accelerated_mode(
+	struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -3914,21 +3676,6 @@ bool dc_bios_is_accelerated_mode(struct dc_bios *dcb)
 #endif
 }
 
-void dc_bios_set_scratch_acc_mode_change(struct dc_bios *dcb)
-{
-	struct bios_parser *bp = BP_FROM_DCB(dcb);
-
-#ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
-	bp->bios_helper->set_scratch_acc_mode_change(
-			bp->ctx);
-#else
-	dal_logger_write(bp->ctx->logger,
-			LOG_MAJOR_BIOS,
-			LOG_MINOR_BIOS_CMD_TABLE,
-			"%s: VBIOS is not supported", __func__);
-#endif
-}
-
 /**
  * bios_parser_set_scratch_critical_state
  *
@@ -3939,19 +3686,19 @@ void dc_bios_set_scratch_acc_mode_change(struct dc_bios *dcb)
  *  bool - to set or reset state
  */
 static void bios_parser_set_scratch_critical_state(
-        struct dc_bios *dcb,
-        bool state)
+	struct dc_bios *dcb,
+	bool state)
 {
-        struct bios_parser *bp = BP_FROM_DCB(dcb);
+	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 #ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
-        dce110_set_scratch_critical_state(
-                        bp->base.ctx, state);
+	dce110_set_scratch_critical_state(
+			bp->base.ctx, state);
 #else
-        dal_logger_write(bp->base.ctx->logger,
-                        LOG_MAJOR_BIOS,
-                        LOG_MINOR_BIOS_CMD_TABLE,
-                        "%s: VBIOS is not supported", __func__);
+	dal_logger_write(bp->base.ctx->logger,
+			LOG_MAJOR_BIOS,
+			LOG_MINOR_BIOS_CMD_TABLE,
+			"%s: VBIOS is not supported", __func__);
 #endif
 }
 
@@ -4310,7 +4057,8 @@ static enum bp_result construct_integrated_info(
 	return result;
 }
 
-struct integrated_info *dc_bios_create_integrated_info(struct dc_bios *dcb)
+static struct integrated_info *bios_parser_create_integrated_info(
+	struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct integrated_info *info = NULL;
@@ -4330,8 +4078,9 @@ struct integrated_info *dc_bios_create_integrated_info(struct dc_bios *dcb)
 	return NULL;
 }
 
-void dc_bios_destroy_integrated_info(struct dc_bios *dcb,
-				     struct integrated_info **info)
+static void bios_parser_destroy_integrated_info(
+	struct dc_bios *dcb,
+	struct integrated_info **info)
 {
 	if (info == NULL) {
 		ASSERT_CRITICAL(0);
@@ -4344,107 +4093,90 @@ void dc_bios_destroy_integrated_info(struct dc_bios *dcb,
 	}
 }
 
-static void bios_parser_destroy_integrated_info(
-        struct dc_bios *dcb,
-        struct integrated_info **info)
-{
-        if (info == NULL) {
-                ASSERT_CRITICAL(0);
-                return;
-        }
-
-        if (*info != NULL) {
-                dm_free(*info);
-                *info = NULL;
-        }
-}
-
 /******************************************************************************/
 
 static const struct dc_vbios_funcs vbios_funcs = {
-        .get_connectors_number = bios_parser_get_connectors_number,
+	.get_connectors_number = bios_parser_get_connectors_number,
 
-        .get_encoder_id = bios_parser_get_encoder_id,
+	.get_encoder_id = bios_parser_get_encoder_id,
 
-        .get_connector_id = bios_parser_get_connector_id,
+	.get_connector_id = bios_parser_get_connector_id,
 
-        .get_dst_number = bios_parser_get_dst_number,
+	.get_dst_number = bios_parser_get_dst_number,
 
-        .get_gpio_record = bios_parser_get_gpio_record,
+	.get_gpio_record = bios_parser_get_gpio_record,
 
-        .get_src_obj = bios_parser_get_src_obj,
+	.get_src_obj = bios_parser_get_src_obj,
 
-        .get_dst_obj = bios_parser_get_dst_obj,
+	.get_dst_obj = bios_parser_get_dst_obj,
 
-        .get_i2c_info = bios_parser_get_i2c_info,
+	.get_i2c_info = bios_parser_get_i2c_info,
 
-        .get_voltage_ddc_info = bios_parser_get_voltage_ddc_info,
+	.get_voltage_ddc_info = bios_parser_get_voltage_ddc_info,
 
-        .get_thermal_ddc_info = bios_parser_get_thermal_ddc_info,
+	.get_thermal_ddc_info = bios_parser_get_thermal_ddc_info,
 
-        .get_hpd_info = bios_parser_get_hpd_info,
+	.get_hpd_info = bios_parser_get_hpd_info,
 
-        .get_device_tag = bios_parser_get_device_tag,
+	.get_device_tag = bios_parser_get_device_tag,
 
-        .get_firmware_info = bios_parser_get_firmware_info,
+	.get_firmware_info = bios_parser_get_firmware_info,
 
-        .get_spread_spectrum_info = bios_parser_get_spread_spectrum_info,
+	.get_spread_spectrum_info = bios_parser_get_spread_spectrum_info,
 
-        .get_ss_entry_number = bios_parser_get_ss_entry_number,
+	.get_ss_entry_number = bios_parser_get_ss_entry_number,
 
-        .get_embedded_panel_info = bios_parser_get_embedded_panel_info,
+	.get_embedded_panel_info = bios_parser_get_embedded_panel_info,
 
-        .get_gpio_pin_info = bios_parser_get_gpio_pin_info,
+	.get_gpio_pin_info = bios_parser_get_gpio_pin_info,
 
-        .get_embedded_panel_info = bios_parser_get_embedded_panel_info,
+	.get_embedded_panel_info = bios_parser_get_embedded_panel_info,
 
-        .get_gpio_pin_info = bios_parser_get_gpio_pin_info,
+	.get_gpio_pin_info = bios_parser_get_gpio_pin_info,
 
-        .get_encoder_cap_info = bios_parser_get_encoder_cap_info,
+	.get_encoder_cap_info = bios_parser_get_encoder_cap_info,
 
-         /* bios scratch register communication */
-        .is_accelerated_mode = bios_parser_is_accelerated_mode,
+	/* bios scratch register communication */
+	.is_accelerated_mode = bios_parser_is_accelerated_mode,
 
-        .set_scratch_critical_state = bios_parser_set_scratch_critical_state,
+	.set_scratch_critical_state = bios_parser_set_scratch_critical_state,
 
-        .is_device_id_supported = bios_parser_is_device_id_supported,
-	
-	 /* COMMANDS */
-        .encoder_control = bios_parser_encoder_control,
+	.is_device_id_supported = bios_parser_is_device_id_supported,
 
-        .transmitter_control = bios_parser_transmitter_control,
+	/* COMMANDS */
+	.encoder_control = bios_parser_encoder_control,
 
-        .crt_control = bios_parser_crt_control,  /* not used in DAL3.  keep for now in case we need to support VGA on Bonaire */
+	.transmitter_control = bios_parser_transmitter_control,
 
-        .enable_crtc = bios_parser_enable_crtc,
+	.crt_control = bios_parser_crt_control,  /* not used in DAL3.  keep for now in case we need to support VGA on Bonaire */
 
-        .adjust_pixel_clock = bios_parser_adjust_pixel_clock,
+	.enable_crtc = bios_parser_enable_crtc,
 
-        .set_pixel_clock = bios_parser_set_pixel_clock,
+	.adjust_pixel_clock = bios_parser_adjust_pixel_clock,
 
-        .set_dce_clock = bios_parser_set_dce_clock,
+	.set_pixel_clock = bios_parser_set_pixel_clock,
 
-        .enable_spread_spectrum_on_ppll = bios_parser_enable_spread_spectrum_on_ppll,
+	.set_dce_clock = bios_parser_set_dce_clock,
 
-        .program_crtc_timing = bios_parser_program_crtc_timing, /* still use.  should probably retire and program directly */
- 
-        .crtc_source_select = bios_parser_crtc_source_select,  /* still use.  should probably retire and program directly */
+	.enable_spread_spectrum_on_ppll = bios_parser_enable_spread_spectrum_on_ppll,
 
-        .program_display_engine_pll = bios_parser_program_display_engine_pll,
+	.program_crtc_timing = bios_parser_program_crtc_timing, /* still use.  should probably retire and program directly */
 
-        .enable_disp_power_gating = bios_parser_enable_disp_power_gating,
+	.crtc_source_select = bios_parser_crtc_source_select,  /* still use.  should probably retire and program directly */
 
-        /* SW init and patch */
-        .post_init = bios_parser_post_init,  /* patch vbios table for mxm module by reading i2c */
+	.program_display_engine_pll = bios_parser_program_display_engine_pll,
 
-        .create_integrated_info = bios_parser_create_integrated_info,
+	.enable_disp_power_gating = bios_parser_enable_disp_power_gating,
 
-        .destroy_integrated_info = bios_parser_destroy_integrated_info,
+	/* SW init and patch */
+	.post_init = bios_parser_post_init,  /* patch vbios table for mxm module by reading i2c */
 
-        .bios_parser_destroy = bios_parser_destroy,
-};
+	.create_integrated_info = bios_parser_create_integrated_info,
 
-/* Stub-functions */
+	.destroy_integrated_info = bios_parser_destroy_integrated_info,
+
+	.bios_parser_destroy = bios_parser_destroy,
+};
 
 static bool bios_parser_construct(
 	struct bios_parser *bp,
@@ -4461,12 +4193,13 @@ static bool bios_parser_construct(
 
 	if (!init->bios)
 		return false;
- 
-        bp->base.bios = init->bios;
-        bp->base.bios_size = bp->base.bios[BIOS_IMAGE_SIZE_OFFSET] * BIOS_IMAGE_SIZE_UNIT;
 
-        bp->base.ctx = init->ctx;
-        bp->base.bios_local_image = NULL;
+	bp->base.funcs = &vbios_funcs;
+	bp->base.bios = init->bios;
+	bp->base.bios_size = bp->base.bios[BIOS_IMAGE_SIZE_OFFSET] * BIOS_IMAGE_SIZE_UNIT;
+
+	bp->base.ctx = init->ctx;
+	bp->base.bios_local_image = NULL;
 
 	rom_header_offset =
 	GET_IMAGE(uint16_t, OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER);
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h
index 2cf9911..d6f1627 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h
@@ -27,7 +27,7 @@
 #define __DAL_BIOS_PARSER_H__
 
 struct dc_bios *bios_parser_create(
-        struct bp_init_data *init,
-        enum dce_version dce_version);
+	struct bp_init_data *init,
+	enum dce_version dce_version);
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c b/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
index 84296da..b03c8f9 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
@@ -47,16 +47,16 @@
  *  struct dc_context *ctx - [in] DAL context
  */
 static void set_scratch_acc_mode_change(
-	struct dc_context *ctx)
+        struct dc_context *ctx)
 {
-	uint32_t addr = mmBIOS_SCRATCH_6;
-	uint32_t value = 0;
+        uint32_t addr = mmBIOS_SCRATCH_6;
+        uint32_t value = 0;
 
-	value = dm_read_reg(ctx, addr);
+        value = dm_read_reg(ctx, addr);
 
-	value |= ATOM_S6_ACC_MODE;
+        value |= ATOM_S6_ACC_MODE;
 
-	dm_write_reg(ctx, addr, value);
+        dm_write_reg(ctx, addr, value);
 }
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
index e39daa6..c1fea6f 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
@@ -814,201 +814,116 @@ static void calculate_bandwidth(
 	/*the adjusted data buffer size is the product of the display bandwidth and the minimum effective data buffer size in terms of time,*/
 	/*rounded up to the chunk size in bytes, but should not exceed the original data buffer size*/
 	for (i = 0; i <= maximum_number_of_surfaces - 1; i++) {
-		if (results->enable[i]) {
+		if (data->enable[i]) {
+			if ((dceip->dmif_pipe_en_fbc_chunk_tracker + 3 == i && fbc_enabled == 0 && tiling_mode[i] != bw_def_linear)) {
+				data->max_chunks_non_fbc_mode[i] = 128 - dmif_chunk_buff_margin;
+			}
+			else {
+				data->max_chunks_non_fbc_mode[i] = 16 - dmif_chunk_buff_margin;
+			}
+		}
+		if (data->fbc_en[i] == 1) {
+			max_chunks_fbc_mode = 128 - dmif_chunk_buff_margin;
+		}
+	}
+	for (i = 0; i <= maximum_number_of_surfaces - 1; i++) {
+		if (data->enable[i]) {
 			switch (surface_type[i]) {
 			case bw_def_display_write_back420_luma:
-				results->data_buffer_size[i] =
-					bw_int_to_fixed(
-						dceip->display_write_back420_luma_mcifwr_buffer_size);
+				data->data_buffer_size[i] = bw_int_to_fixed(dceip->display_write_back420_luma_mcifwr_buffer_size);
 				break;
 			case bw_def_display_write_back420_chroma:
-				results->data_buffer_size[i] =
-					bw_int_to_fixed(
-						dceip->display_write_back420_chroma_mcifwr_buffer_size);
+				data->data_buffer_size[i] = bw_int_to_fixed(dceip->display_write_back420_chroma_mcifwr_buffer_size);
 				break;
 			case bw_def_underlay420_luma:
-				results->data_buffer_size[i] = bw_int_to_fixed(
-					dceip->underlay_luma_dmif_size);
+				data->data_buffer_size[i] = bw_int_to_fixed(dceip->underlay_luma_dmif_size);
 				break;
 			case bw_def_underlay420_chroma:
-				results->data_buffer_size[i] =
-					bw_div(
-						bw_int_to_fixed(
-							dceip->underlay_chroma_dmif_size),
-						bw_int_to_fixed(2));
+				data->data_buffer_size[i] = bw_div(bw_int_to_fixed(dceip->underlay_chroma_dmif_size), bw_int_to_fixed(2));
 				break;
-			case bw_def_underlay422:
-			case bw_def_underlay444:
-				if (results->orthogonal_rotation[i] == 0) {
-					results->data_buffer_size[i] =
-						bw_int_to_fixed(
-							dceip->underlay_luma_dmif_size);
-				} else {
-					results->data_buffer_size[i] =
-						bw_add(
-							bw_int_to_fixed(
-								dceip->underlay_luma_dmif_size),
-							bw_int_to_fixed(
-								dceip->underlay_chroma_dmif_size));
+			case bw_def_underlay422:case bw_def_underlay444:
+				if (data->orthogonal_rotation[i] == 0) {
+					data->data_buffer_size[i] = bw_int_to_fixed(dceip->underlay_luma_dmif_size);
+				}
+				else {
+					data->data_buffer_size[i] = bw_add(bw_int_to_fixed(dceip->underlay_luma_dmif_size), bw_int_to_fixed(dceip->underlay_chroma_dmif_size));
 				}
 				break;
 			default:
-				if (mode_data->number_of_displays == 1
-					&& bw_equ(
-						dceip->de_tiling_buffer,
-						bw_int_to_fixed(0))) {
-					if (mode_data->d0_fbc_enable) {
-						results->data_buffer_size[i] =
-							bw_mul(
-								bw_int_to_fixed(
-									dceip->max_dmif_buffer_allocated),
-								bw_int_to_fixed(
-									dceip->graphics_dmif_size));
-					} else {
-						/*the effective dmif buffer size in non-fbc mode is limited by the 16 entry chunk tracker*/
-						results->data_buffer_size[i] =
-							bw_mul(
-								bw_mul(
-									bw_int_to_fixed(
-										max_chunks_non_fbc_mode),
-									bw_int_to_fixed(
-										pixels_per_chunk)),
-								bw_int_to_fixed(
-									results->bytes_per_pixel[i]));
+				if (data->fbc_en[i] == 1) {
+					/*data_buffer_size(i) = max_dmif_buffer_allocated * graphics_dmif_size*/
+					if (data->number_of_displays == 1) {
+						data->data_buffer_size[i] = bw_min2(bw_mul(bw_mul(bw_int_to_fixed(max_chunks_fbc_mode), bw_int_to_fixed(pixels_per_chunk)), bw_int_to_fixed(data->bytes_per_pixel[i])), bw_mul(bw_int_to_fixed(dceip->max_dmif_buffer_allocated), bw_int_to_fixed(dceip->graphics_dmif_size)));
+					}
+					else {
+						data->data_buffer_size[i] = bw_min2(bw_mul(bw_mul(bw_int_to_fixed(max_chunks_fbc_mode), bw_int_to_fixed(pixels_per_chunk)), bw_int_to_fixed(data->bytes_per_pixel[i])), bw_int_to_fixed(dceip->graphics_dmif_size));
+					}
+				}
+				else {
+					/*the effective dmif buffer size in non-fbc mode is limited by the 16 entry chunk tracker*/
+					if (data->number_of_displays == 1) {
+						data->data_buffer_size[i] = bw_min2(bw_mul(bw_mul(bw_int_to_fixed(data->max_chunks_non_fbc_mode[i]), bw_int_to_fixed(pixels_per_chunk)), bw_int_to_fixed(data->bytes_per_pixel[i])), bw_mul(bw_int_to_fixed(dceip->max_dmif_buffer_allocated), bw_int_to_fixed(dceip->graphics_dmif_size)));
+					}
+					else {
+						data->data_buffer_size[i] = bw_min2(bw_mul(bw_mul(bw_int_to_fixed(data->max_chunks_non_fbc_mode[i]), bw_int_to_fixed(pixels_per_chunk)), bw_int_to_fixed(data->bytes_per_pixel[i])), bw_int_to_fixed(dceip->graphics_dmif_size));
 					}
-				} else {
-					results->data_buffer_size[i] =
-						bw_int_to_fixed(
-							dceip->graphics_dmif_size);
 				}
 				break;
 			}
-			if (surface_type[i] == bw_def_display_write_back420_luma
-				|| surface_type[i]
-					== bw_def_display_write_back420_chroma) {
-				results->memory_chunk_size_in_bytes[i] =
-					bw_int_to_fixed(1024);
-				results->pipe_chunk_size_in_bytes[i] =
-					bw_int_to_fixed(1024);
-			} else {
-				results->memory_chunk_size_in_bytes[i] =
-					bw_mul(
-						bw_mul(
-							bw_int_to_fixed(
-								dceip->chunk_width),
-							results->lines_interleaved_in_mem_access[i]),
-						bw_int_to_fixed(
-							results->bytes_per_pixel[i]));
-				results->pipe_chunk_size_in_bytes[i] =
-					bw_mul(
-						bw_mul(
-							bw_int_to_fixed(
-								dceip->chunk_width),
-							bw_int_to_fixed(
-								dceip->lines_interleaved_into_lb)),
-						bw_int_to_fixed(
-							results->bytes_per_pixel[i]));
-			}
-		}
-	}
-	results->min_dmif_size_in_time = bw_int_to_fixed(9999);
-	results->min_mcifwr_size_in_time = bw_int_to_fixed(9999);
+			if (surface_type[i] == bw_def_display_write_back420_luma || surface_type[i] == bw_def_display_write_back420_chroma) {
+				data->memory_chunk_size_in_bytes[i] = bw_int_to_fixed(1024);
+				data->pipe_chunk_size_in_bytes[i] = bw_int_to_fixed(1024);
+			}
+			else {
+				data->memory_chunk_size_in_bytes[i] = bw_mul(bw_mul(bw_int_to_fixed(dceip->chunk_width), data->lines_interleaved_in_mem_access[i]), bw_int_to_fixed(data->bytes_per_pixel[i]));
+				data->pipe_chunk_size_in_bytes[i] = bw_mul(bw_mul(bw_int_to_fixed(dceip->chunk_width), bw_int_to_fixed(dceip->lines_interleaved_into_lb)), bw_int_to_fixed(data->bytes_per_pixel[i]));
+			}
+		}
+	}
+	data->min_dmif_size_in_time = bw_int_to_fixed(9999);
+	data->min_mcifwr_size_in_time = bw_int_to_fixed(9999);
 	for (i = 0; i <= maximum_number_of_surfaces - 1; i++) {
-		if (results->enable[i]) {
-			if (surface_type[i] != bw_def_display_write_back420_luma
-				&& surface_type[i]
-					!= bw_def_display_write_back420_chroma) {
-				if (bw_ltn(
-					bw_div(
-						bw_div(
-							bw_mul(
-								results->data_buffer_size[i],
-								results->bytes_per_request[i]),
-							results->useful_bytes_per_request[i]),
-						results->display_bandwidth[i]),
-					results->min_dmif_size_in_time)) {
-					results->min_dmif_size_in_time =
-						bw_div(
-							bw_div(
-								bw_mul(
-									results->data_buffer_size[i],
-									results->bytes_per_request[i]),
-								results->useful_bytes_per_request[i]),
-							results->display_bandwidth[i]);
+		if (data->enable[i]) {
+			if (surface_type[i] != bw_def_display_write_back420_luma && surface_type[i] != bw_def_display_write_back420_chroma) {
+				if (bw_ltn(bw_div(bw_div(bw_mul(data->data_buffer_size[i], data->bytes_per_request[i]), data->useful_bytes_per_request[i]), data->display_bandwidth[i]), data->min_dmif_size_in_time)) {
+					data->min_dmif_size_in_time = bw_div(bw_div(bw_mul(data->data_buffer_size[i], data->bytes_per_request[i]), data->useful_bytes_per_request[i]), data->display_bandwidth[i]);
 				}
-			} else {
-				if (bw_ltn(
-					bw_div(
-						bw_div(
-							bw_mul(
-								results->data_buffer_size[i],
-								results->bytes_per_request[i]),
-							results->useful_bytes_per_request[i]),
-						results->display_bandwidth[i]),
-					results->min_mcifwr_size_in_time)) {
-					results->min_mcifwr_size_in_time =
-						bw_div(
-							bw_div(
-								bw_mul(
-									results->data_buffer_size[i],
-									results->bytes_per_request[i]),
-								results->useful_bytes_per_request[i]),
-							results->display_bandwidth[i]);
+			}
+			else {
+				if (bw_ltn(bw_div(bw_div(bw_mul(data->data_buffer_size[i], data->bytes_per_request[i]), data->useful_bytes_per_request[i]), data->display_bandwidth[i]), data->min_mcifwr_size_in_time)) {
+					data->min_mcifwr_size_in_time = bw_div(bw_div(bw_mul(data->data_buffer_size[i], data->bytes_per_request[i]), data->useful_bytes_per_request[i]), data->display_bandwidth[i]);
 				}
 			}
 		}
 	}
-	results->total_requests_for_dmif_size = bw_int_to_fixed(0);
+	data->total_requests_for_dmif_size = bw_int_to_fixed(0);
 	for (i = 0; i <= maximum_number_of_surfaces - 1; i++) {
-		if (results->enable[i]
-			&& surface_type[i] != bw_def_display_write_back420_luma
-			&& surface_type[i]
-				!= bw_def_display_write_back420_chroma) {
-			results->total_requests_for_dmif_size = bw_add(
-				results->total_requests_for_dmif_size,
-				bw_div(
-					results->data_buffer_size[i],
-					results->useful_bytes_per_request[i]));
+		if (data->enable[i] && surface_type[i] != bw_def_display_write_back420_luma && surface_type[i] != bw_def_display_write_back420_chroma) {
+			data->total_requests_for_dmif_size = bw_add(data->total_requests_for_dmif_size, bw_div(data->data_buffer_size[i], data->useful_bytes_per_request[i]));
 		}
 	}
 	for (i = 0; i <= maximum_number_of_surfaces - 1; i++) {
-		if (results->enable[i]) {
-			if (surface_type[i] != bw_def_display_write_back420_luma
-				&& surface_type[i]
-					!= bw_def_display_write_back420_chroma
-				&& dceip->limit_excessive_outstanding_dmif_requests
-				&& (mode_data->number_of_displays > 1
-					|| bw_mtn(
-						results->total_requests_for_dmif_size,
-						dceip->dmif_request_buffer_size))) {
-				results->adjusted_data_buffer_size[i] =
-					bw_min2(
-						results->data_buffer_size[i],
-						bw_ceil2(
-							bw_mul(
-								results->min_dmif_size_in_time,
-								results->display_bandwidth[i]),
-							results->memory_chunk_size_in_bytes[i]));
-			} else {
-				results->adjusted_data_buffer_size[i] =
-					results->data_buffer_size[i];
+		if (data->enable[i]) {
+			if (surface_type[i] != bw_def_display_write_back420_luma && surface_type[i] != bw_def_display_write_back420_chroma && dceip->limit_excessive_outstanding_dmif_requests && (data->number_of_displays > 1 || bw_mtn(data->total_requests_for_dmif_size, dceip->dmif_request_buffer_size))) {
+				data->adjusted_data_buffer_size[i] = bw_min2(data->data_buffer_size[i], bw_ceil2(bw_mul(data->min_dmif_size_in_time, data->display_bandwidth[i]), data->memory_chunk_size_in_bytes[i]));
+			}
+			else {
+				data->adjusted_data_buffer_size[i] = data->data_buffer_size[i];
 			}
 		}
 	}
 	for (i = 0; i <= maximum_number_of_surfaces - 1; i++) {
-		if (results->enable[i]) {
-			if ((mode_data->number_of_displays == 1
-				&& results->number_of_underlay_surfaces == 0)) {
+		if (data->enable[i]) {
+			if ((data->number_of_displays == 1 && data->number_of_underlay_surfaces == 0)) {
 				/*set maximum chunk limit if only one graphic pipe is enabled*/
-				results->outstanding_chunk_request_limit[i] =
-					bw_int_to_fixed(255);
-			} else {
-				results->outstanding_chunk_request_limit[i] =
-					bw_ceil2(
-						bw_div(
-							results->adjusted_data_buffer_size[i],
-							results->pipe_chunk_size_in_bytes[i]),
-						bw_int_to_fixed(1));
+				data->outstanding_chunk_request_limit[i] = bw_int_to_fixed(127);
+			}
+			else {
+				data->outstanding_chunk_request_limit[i] = bw_ceil2(bw_div(data->adjusted_data_buffer_size[i], data->pipe_chunk_size_in_bytes[i]), bw_int_to_fixed(1));
+				/*clamp maximum chunk limit in the graphic display pipe*/
+				if ((i >= 4)) {
+					data->outstanding_chunk_request_limit[i] = bw_max2(bw_int_to_fixed(127), data->outstanding_chunk_request_limit[i]);
+				}
 			}
 		}
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index d9a67ca..9b46159 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -122,10 +122,10 @@ static bool program_hpd_filter(
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
 		/* Program hpd filter to allow DP signal to settle */
 		/* 500:	not able to detect MST <-> SST switch as HPD is low for
-		 *	only 100ms on DELL U2413
+		 * 	only 100ms on DELL U2413
 		 * 0:	some passive dongle still show aux mode instead of i2c
 		 * 20-50:not enough to hide bouncing HPD with passive dongle.
-		 *	also see intermittent i2c read issues.
+		 * 	also see intermittent i2c read issues.
 		 */
 		delay_on_connect_in_ms = 80;
 		delay_on_disconnect_in_ms = 0;
@@ -1039,7 +1039,7 @@ static bool construct(
 	enc_init_data.hpd_source = get_hpd_line(link, as);
 	enc_init_data.transmitter =
 			translate_encoder_to_transmitter(enc_init_data.encoder);
-	link->link_enc = link->dc->res_pool.funcs->link_enc_create(
+	link->link_enc = link->dc->res_pool->funcs->link_enc_create(
 								&enc_init_data);
 
 	if( link->link_enc == NULL) {
@@ -1320,8 +1320,7 @@ static enum dc_status enable_link(struct pipe_ctx *pipe_ctx)
 
 	if (pipe_ctx->audio && status == DC_OK) {
 		/* notify audio driver for audio modes of monitor */
-		dal_audio_enable_azalia_audio_jack_presence(pipe_ctx->audio,
-				pipe_ctx->stream_enc->id);
+		pipe_ctx->audio->funcs->az_enable(pipe_ctx->audio);
 
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
index e330c57..ab545ef 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
@@ -1141,7 +1141,7 @@ bool dp_hbr_verify_link_cap(
 	/* disable PHY done possible by BIOS, will be done by driver itself */
 	dp_disable_link_phy(link, link->public.connector_signal);
 
-	dp_cs = link->dc->res_pool.dp_clock_source;
+	dp_cs = link->dc->res_pool->dp_clock_source;
 
 	if (dp_cs)
 		dp_cs_id = dp_cs->id;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 6c23e75c..82cac0a 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -86,32 +86,33 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 	return dc_version;
 }
 
-bool dc_construct_resource_pool(struct adapter_service *adapter_serv,
+struct resource_pool *dc_create_resource_pool(struct adapter_service *adapter_serv,
 				struct core_dc *dc,
 				int num_virtual_links,
-				enum dce_version dc_version)
+				enum dce_version dc_version,
+				struct hw_asic_id asic_id)
 {
 
 	switch (dc_version) {
 #if defined(CONFIG_DRM_AMD_DAL_DCE8_0)
 	case DCE_VERSION_8_0:
-		return dce80_construct_resource_pool(
-			adapter_serv, num_virtual_links, dc, &dc->res_pool);
+		return dce80_create_resource_pool(
+			adapter_serv, num_virtual_links, dc);
 #endif
 #if defined(CONFIG_DRM_AMD_DAL_DCE10_0)
 	case DCE_VERSION_10_0:
-		return dce100_construct_resource_pool(
-			adapter_serv, num_virtual_links, dc, &dc->res_pool);
+		return dce100_create_resource_pool(
+			adapter_serv, num_virtual_links, dc);
 #endif
 #if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
 	case DCE_VERSION_11_0:
-		return dce110_construct_resource_pool(
-			adapter_serv, num_virtual_links, dc, &dc->res_pool);
+		return dce110_create_resource_pool(
+			adapter_serv, num_virtual_links, dc, asic_id);
 #endif
 #if defined(CONFIG_DRM_AMD_DAL_DCE11_2)
 	case DCE_VERSION_11_2:
-		return dce112_construct_resource_pool(
-			adapter_serv, num_virtual_links, dc, &dc->res_pool);
+		return dce112_create_resource_pool(
+			adapter_serv, num_virtual_links, dc);
 #endif
 	default:
 		break;
@@ -120,48 +121,13 @@ bool dc_construct_resource_pool(struct adapter_service *adapter_serv,
 	return false;
 }
 
-struct resource_pool *dc_create_resource_pool(struct adapter_service *adapter_serv,
-                                struct core_dc *dc,
-                                int num_virtual_links,
-                                enum dce_version dc_version,
-                                struct hw_asic_id asic_id)
-{
-
-        switch (dc_version) {
-#if defined(CONFIG_DRM_AMD_DAL_DCE8_0)
-        case DCE_VERSION_8_0:
-                return dce80_create_resource_pool(
-                        adapter_serv, num_virtual_links, dc);
-#endif
-#if defined(CONFIG_DRM_AMD_DAL_DCE10_0)
-        case DCE_VERSION_10_0:
-                return dce100_create_resource_pool(
-                        adapter_serv, num_virtual_links, dc);
-#endif
-#if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
-        case DCE_VERSION_11_0:
-                return dce110_create_resource_pool(
-                        adapter_serv, num_virtual_links, dc, asic_id);
-#endif
-#if defined(CONFIG_DRM_AMD_DAL_DCE11_2)
-        case DCE_VERSION_11_2:
-                return dce112_create_resource_pool(
-                        adapter_serv, num_virtual_links, dc);
-#endif
-        default:
-                break;
-        }
-
-        return false;
-}
-
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
 		struct clock_source *clock_source)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool.clk_src_count; i++) {
-		if (res_ctx->pool.clock_sources[i] != clock_source)
+	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
+		if (res_ctx->pool->clock_sources[i] != clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]--;
@@ -172,7 +138,7 @@ void resource_unreference_clock_source(
 		break;
 	}
 
-	if (res_ctx->pool.dp_clock_source == clock_source) {
+	if (res_ctx->pool->dp_clock_source == clock_source) {
 		res_ctx->dp_clock_source_ref_count--;
 
 		if (res_ctx->dp_clock_source_ref_count == 0)
@@ -185,15 +151,15 @@ void resource_reference_clock_source(
 		struct clock_source *clock_source)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool.clk_src_count; i++) {
-		if (res_ctx->pool.clock_sources[i] != clock_source)
+	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
+		if (res_ctx->pool->clock_sources[i] != clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]++;
 		break;
 	}
 
-	if (res_ctx->pool.dp_clock_source == clock_source)
+	if (res_ctx->pool->dp_clock_source == clock_source)
 		res_ctx->dp_clock_source_ref_count++;
 }
 
@@ -454,7 +420,7 @@ static void calculate_scaling_ratios(
 
 	if (surface->stereo_format == PLANE_STEREO_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
-	else if (surface->stereo_format	== PLANE_STEREO_FORMAT_TOP_AND_BOTTOM)
+	else if (surface->stereo_format == PLANE_STEREO_FORMAT_TOP_AND_BOTTOM)
 		pipe_ctx->scl_data.ratios.vert.value *= 2;
 
 	pipe_ctx->scl_data.ratios.vert.value = div64_s64(
@@ -848,8 +814,8 @@ static void set_stream_engine_in_use(
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool.stream_enc_count; i++) {
-		if (res_ctx->pool.stream_enc[i] == stream_enc)
+	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
+		if (res_ctx->pool->stream_enc[i] == stream_enc)
 			res_ctx->is_stream_enc_acquired[i] = true;
 	}
 }
@@ -860,8 +826,8 @@ static void set_audio_in_use(
 		struct audio *audio)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool.audio_count; i++) {
-		if (res_ctx->pool.audios[i] == audio) {
+	for (i = 0; i < res_ctx->pool->audio_count; i++) {
+		if (res_ctx->pool->audios[i] == audio) {
 			res_ctx->is_audio_acquired[i] = true;
 		}
 	}
@@ -873,16 +839,16 @@ static int acquire_first_free_pipe(
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool.pipe_count; i++) {
+	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-			pipe_ctx->tg = res_ctx->pool.timing_generators[i];
-			pipe_ctx->mi = res_ctx->pool.mis[i];
-			pipe_ctx->ipp = res_ctx->pool.ipps[i];
-			pipe_ctx->xfm = res_ctx->pool.transforms[i];
-			pipe_ctx->opp = res_ctx->pool.opps[i];
-			pipe_ctx->dis_clk = res_ctx->pool.display_clock;
+			pipe_ctx->tg = res_ctx->pool->timing_generators[i];
+			pipe_ctx->mi = res_ctx->pool->mis[i];
+			pipe_ctx->ipp = res_ctx->pool->ipps[i];
+			pipe_ctx->xfm = res_ctx->pool->transforms[i];
+			pipe_ctx->opp = res_ctx->pool->opps[i];
+			pipe_ctx->dis_clk = res_ctx->pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -900,15 +866,15 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 	int j = -1;
 	struct core_link *link = stream->sink->link;
 
-	for (i = 0; i < res_ctx->pool.stream_enc_count; i++) {
+	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
 		if (!res_ctx->is_stream_enc_acquired[i] &&
-					res_ctx->pool.stream_enc[i]) {
+					res_ctx->pool->stream_enc[i]) {
 			/* Store first available for MST second display
 			 * in daisy chain use case */
 			j = i;
-			if (res_ctx->pool.stream_enc[i]->id ==
+			if (res_ctx->pool->stream_enc[i]->id ==
 					link->link_enc->preferred_engine)
-				return res_ctx->pool.stream_enc[i];
+				return res_ctx->pool->stream_enc[i];
 		}
 	}
 
@@ -926,7 +892,7 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 	 */
 
 	if (j >= 0 && dc_is_dp_signal(stream->signal))
-		return res_ctx->pool.stream_enc[j];
+		return res_ctx->pool->stream_enc[j];
 
 	return NULL;
 }
@@ -934,9 +900,9 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 static struct audio *find_first_free_audio(struct resource_context *res_ctx)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool.audio_count; i++) {
+	for (i = 0; i < res_ctx->pool->audio_count; i++) {
 		if (res_ctx->is_audio_acquired[i] == false) {
-			return res_ctx->pool.audios[i];
+			return res_ctx->pool->audios[i];
 		}
 	}
 
@@ -1117,7 +1083,7 @@ enum dc_status resource_map_pool_resources(
 				if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
 					!find_pll_sharable_stream(stream, context))
 					pipe_ctx->clock_source =
-						context->res_ctx.pool.dp_clock_source;
+						context->res_ctx.pool->dp_clock_source;
 
 				resource_reference_clock_source(
 					&context->res_ctx,
@@ -1747,14 +1713,14 @@ void resource_validate_ctx_copy_construct(
 
 	*dst_ctx = *src_ctx;
 
-	for (i = 0; i < dst_ctx->res_ctx.pool.pipe_count; i++) {
+	for (i = 0; i < dst_ctx->res_ctx.pool->pipe_count; i++) {
 		struct pipe_ctx *cur_pipe = &dst_ctx->res_ctx.pipe_ctx[i];
 
-                if (cur_pipe->top_pipe)
-                       cur_pipe->top_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+		if (cur_pipe->top_pipe)
+			cur_pipe->top_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
 
-                if (cur_pipe->bottom_pipe)
-                        cur_pipe->bottom_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+		if (cur_pipe->bottom_pipe)
+			cur_pipe->bottom_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
 
 	}
 
@@ -1771,9 +1737,9 @@ struct clock_source *dc_resource_find_first_free_pll(
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool.clk_src_count; ++i) {
+	for (i = 0; i < res_ctx->pool->clk_src_count; ++i) {
 		if (res_ctx->clock_source_ref_count[i] == 0)
-			return res_ctx->pool.clock_sources[i];
+			return res_ctx->pool->clock_sources[i];
 	}
 
 	return NULL;
@@ -1837,7 +1803,7 @@ enum dc_status resource_map_clock_resources(
 				if (dc_is_dp_signal(pipe_ctx->stream->signal)
 					|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
 					pipe_ctx->clock_source =
-						context->res_ctx.pool.dp_clock_source;
+						context->res_ctx.pool->dp_clock_source;
 				else {
 					pipe_ctx->clock_source =
 						resource_find_used_clk_src_for_sharing(
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
index 28fe8e4..045005e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_surface.c
@@ -109,8 +109,6 @@ const struct dc_surface_status *dc_surface_get_status(
 	struct core_dc *core_dc;
 	int i;
 
-	struct validate_context *context;
-
 	if (dc_surface == NULL)
 		return NULL;
 
@@ -126,18 +124,14 @@ const struct dc_surface_status *dc_surface_get_status(
 
 	core_dc = DC_TO_CORE(core_surface->ctx->dc);
 
-	context = core_dc->pending_context;
-
-	if (!context)
-		context = core_dc->current_context;
 
 	if (core_dc->current_context == NULL)
 		return NULL;
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count;
+	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count;
 			i++) {
 		struct pipe_ctx *pipe_ctx =
-				&context->res_ctx.pipe_ctx[i];
+				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->surface !=
 				DC_SURFACE_TO_CORE(dc_surface))
@@ -145,6 +139,7 @@ const struct dc_surface_status *dc_surface_get_status(
 
 		core_dc->hwss.update_pending_status(pipe_ctx);
 	}
+
 	return surface_status;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
index 43ebdd0..713291d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
@@ -215,16 +215,18 @@ static bool dce100_enable_display_power_gating(
 	else
 		cntl = ASIC_PIPE_DISABLE;
 
-        if (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0)){
-
-		bp_result = dc_bios_enable_disp_power_gating(dcb, controller_id + 1, cntl);
-                /* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
-                * by default when command table is called
-                */
-                dm_write_reg(ctx,
-                        HW_REG_CRTC(mmMASTER_UPDATE_MODE, controller_id),
-                        0);
-        }
+	if (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0)){
+
+		bp_result = dcb->funcs->enable_disp_power_gating(
+						dcb, controller_id + 1, cntl);
+
+		/* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
+		 * by default when command table is called
+		 */
+		dm_write_reg(ctx,
+			HW_REG_CRTC(mmMASTER_UPDATE_MODE, controller_id),
+			0);
+	}
 
 	if (bp_result == BP_RESULT_OK)
 		return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 75faec4..6d8c24c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -527,58 +527,58 @@ void dce100_clock_source_destroy(struct clock_source **clk_src)
 
 static void destruct(struct dce110_resource_pool *pool)
 {
-        unsigned int i;
+	unsigned int i;
 
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce100_opp_destroy(&pool->base.opps[i]);
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce100_opp_destroy(&pool->base.opps[i]);
 
-                if (pool->base.transforms[i] != NULL)
-                        dce100_transform_destroy(&pool->base.transforms[i]);
+		if (pool->base.transforms[i] != NULL)
+			dce100_transform_destroy(&pool->base.transforms[i]);
 
-                if (pool->base.ipps[i] != NULL)
-                        dce110_ipp_destroy(&pool->base.ipps[i]);
+		if (pool->base.ipps[i] != NULL)
+			dce110_ipp_destroy(&pool->base.ipps[i]);
 
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
 
-                if (pool->base.timing_generators[i] != NULL)    {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
 
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
 
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL)
-                        dce100_clock_source_destroy(&pool->base.clock_sources[i]);
-        }
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL)
+			dce100_clock_source_destroy(&pool->base.clock_sources[i]);
+	}
 
-        if (pool->base.dp_clock_source != NULL)
-                dce100_clock_source_destroy(&pool->base.dp_clock_source);
+	if (pool->base.dp_clock_source != NULL)
+		dce100_clock_source_destroy(&pool->base.dp_clock_source);
 
-        for (i = 0; i < pool->base.audio_count; i++)    {
-                if (pool->base.audios[i] != NULL)
-                        dce110_aud_destroy(&pool->base.audios[i]);
-        }
+	for (i = 0; i < pool->base.audio_count; i++)	{
+		if (pool->base.audios[i] != NULL)
+			dce110_aud_destroy(&pool->base.audios[i]);
+	}
 
-        if (pool->base.display_clock != NULL)
-                dal_display_clock_destroy(&pool->base.display_clock);
+	if (pool->base.display_clock != NULL)
+		dal_display_clock_destroy(&pool->base.display_clock);
 
-        if (pool->base.scaler_filter != NULL)
-                dal_scaler_filter_destroy(&pool->base.scaler_filter);
+	if (pool->base.scaler_filter != NULL)
+		dal_scaler_filter_destroy(&pool->base.scaler_filter);
 
-        if (pool->base.irqs != NULL)
-                dal_irq_service_destroy(&pool->base.irqs);
+	if (pool->base.irqs != NULL)
+		dal_irq_service_destroy(&pool->base.irqs);
 
-        if (pool->base.adapter_srv != NULL)
-                dal_adapter_service_destroy(&pool->base.adapter_srv);
+	if (pool->base.adapter_srv != NULL)
+		dal_adapter_service_destroy(&pool->base.adapter_srv);
 }
 
 static enum dc_status validate_mapped_resource(
@@ -752,8 +752,17 @@ enum dc_status dce100_validate_guaranteed(
 	return result;
 }
 
-static const struct resource_funcs dce100_res_pool_funcs = {ce100_res_pool_funcs = {
-	.destruct = dce100_destruct_resource_pool,
+static void dce100_destroy_resource_pool(struct resource_pool **pool)
+{
+	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
+
+	destruct(dce110_pool);
+	dm_free(dce110_pool);
+	*pool = NULL;
+}
+
+static const struct resource_funcs dce100_res_pool_funcs = {
+	.destroy = dce100_destroy_resource_pool,
 	.link_enc_create = dce100_link_encoder_create,
 	.validate_with_context = dce100_validate_with_context,
 	.validate_guaranteed = dce100_validate_guaranteed,
@@ -761,273 +770,273 @@ static const struct resource_funcs dce100_res_pool_funcs = {ce100_res_pool_funcs
 };
 
 static bool construct(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc,
-        struct dce110_resource_pool *pool)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool)
 {
-        unsigned int i;
-        struct dc_context *ctx = dc->ctx;
-        struct firmware_info info;
-        struct dc_bios *bp;
-
-        pool->base.adapter_srv = as;
-        pool->base.funcs = &dce100_res_pool_funcs;
-        pool->base.underlay_pipe_index = -1;
-
-        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-        bp = dal_adapter_service_get_bios_parser(as);
-
-        if (dal_adapter_service_get_firmware_info(as, &info) &&
-                info.external_clock_source_frequency_for_dp != 0) {
-                pool->base.dp_clock_source =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
-
-                pool->base.clock_sources[0] =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
-                pool->base.clock_sources[1] =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
-                pool->base.clock_sources[2] =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
-                pool->base.clk_src_count = 3;
-
-        } else {
-                pool->base.dp_clock_source =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
-                pool->base.clock_sources[0] =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
-                pool->base.clock_sources[1] =
-                                dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
-                pool->base.clk_src_count = 2;
-        }
-
-        if (pool->base.dp_clock_source == NULL) {
-                dm_error("DC: failed to create dp clock source!\n");
-                BREAK_TO_DEBUGGER();
-                goto clk_src_create_fail;
-        }
-
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] == NULL) {
-                        dm_error("DC: failed to create clock sources!\n");
-                        BREAK_TO_DEBUGGER();
-                        goto clk_src_create_fail;
-                }
-        }
-
-        pool->base.display_clock = dal_display_clock_dce110_create(ctx, as);
-        if (pool->base.display_clock == NULL) {
-                dm_error("DC: failed to create display clock!\n");
-                BREAK_TO_DEBUGGER();
-                goto disp_clk_create_fail;
-        }
-
-        {
-                struct irq_service_init_data init_data;
-
-                init_data.ctx = dc->ctx;
-                pool->base.irqs = dal_irq_service_create(
-                                dal_adapter_service_get_dce_version(
-                                        pool->base.adapter_srv),
-                                &init_data);
-                if (!pool->base.irqs)
-                        goto irqs_create_fail;
-
-        }
-
-        /*************************************************
-        *  Resource + asic cap harcoding                *
-        *************************************************/
-        pool->base.underlay_pipe_index = -1;
-        pool->base.pipe_count = dal_adapter_service_get_func_controllers_num(as);
-        pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
-        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
-        dc->public.caps.max_downscale_ratio = 200;
-        dc->public.caps.i2c_speed_in_khz = 40;
-
-        if (pool->base.scaler_filter == NULL) {
-                BREAK_TO_DEBUGGER();
-                dm_error("DC: failed to create filter!\n");
-                goto filter_create_fail;
-        }
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                pool->base.timing_generators[i] =
-                        dce100_timing_generator_create(
-                                as,
-                                ctx,
-                                i,
-                                &dce100_tg_offsets[i]);
-                if (pool->base.timing_generators[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create tg!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.mis[i] = dce100_mem_input_create(ctx, as, i,
-                                &dce100_mi_reg_offsets[i]);
-                if (pool->base.mis[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create memory input!\n");
-                        goto controller_create_fail;
-                }
-                pool->base.ipps[i] = dce100_ipp_create(ctx, i,
-                                &dce100_ipp_reg_offsets[i]);
-                if (pool->base.ipps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create input pixel processor!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.transforms[i] = dce100_transform_create(
-                                        ctx, i, &dce100_xfm_offsets[i]);
-                if (pool->base.transforms[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create transform!\n");
-                        goto controller_create_fail;
-                }
-                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
-                                pool->base.transforms[i],
-                                pool->base.scaler_filter);
-
-                pool->base.opps[i] = dce100_opp_create(ctx, i, &dce100_opp_reg_offsets[i]);
-                if (pool->base.opps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create output pixel processor!\n");
-                        goto controller_create_fail;
-                }
-        }
-
-        pool->base.audio_count = 0;
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                struct graphics_object_id obj_id;
-
-                obj_id = dal_adapter_service_enum_audio_object(as, i);
-                if (false == dal_graphics_object_id_is_valid(obj_id)) {
-                        /* no more valid audio objects */
-                        break;
-                }
-
-                pool->base.audios[i] = dce110_audio_create(
-                                ctx, i, &audio_regs[i]);
-
-                if (pool->base.audios[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create DPPs!\n");
-                        goto audio_create_fail;
-                }
-                pool->base.audio_count++;
-        }
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                /* TODO: rework fragile code*/
-                if (pool->base.stream_engines.u_all & 1 << i) {
-                        pool->base.stream_enc[i] = dce100_stream_encoder_create(
-                                i, dc->ctx,
-                                 dal_adapter_service_get_bios_parser(as),
-                                &stream_enc_regs[i]);
-                        if (pool->base.stream_enc[i] == NULL) {
-                                BREAK_TO_DEBUGGER();
-                                dm_error("DC: failed to create stream_encoder!\n");
-                                goto stream_enc_create_fail;
-                        }
-                }
-        }
-
-        for (i = 0; i < num_virtual_links; i++) {
-                pool->base.stream_enc[pool->base.stream_enc_count] =
-                        virtual_stream_encoder_create(
-                                dc->ctx,
-                                dal_adapter_service_get_bios_parser(as));
-                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create stream_encoder!\n");
-                        goto stream_enc_create_fail;
-                }
-                pool->base.stream_enc_count++;
-        }
-
-        /* Create hardware sequencer */
-        if (!dce100_hw_sequencer_construct(dc))
-                goto stream_enc_create_fail;
-
-        return true;
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+	struct firmware_info info;
+	struct dc_bios *bp;
+
+	pool->base.adapter_srv = as;
+	pool->base.funcs = &dce100_res_pool_funcs;
+	pool->base.underlay_pipe_index = -1;
+
+	pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+	bp = dal_adapter_service_get_bios_parser(as);
+
+	if (dal_adapter_service_get_firmware_info(as, &info) &&
+		info.external_clock_source_frequency_for_dp != 0) {
+		pool->base.dp_clock_source =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+
+		pool->base.clock_sources[0] =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
+		pool->base.clock_sources[1] =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
+		pool->base.clock_sources[2] =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
+		pool->base.clk_src_count = 3;
+
+	} else {
+		pool->base.dp_clock_source =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce100_clk_src_reg_offsets[0]);
+		pool->base.clock_sources[0] =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce100_clk_src_reg_offsets[1]);
+		pool->base.clock_sources[1] =
+				dce100_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce100_clk_src_reg_offsets[2]);
+		pool->base.clk_src_count = 2;
+	}
+
+	if (pool->base.dp_clock_source == NULL) {
+		dm_error("DC: failed to create dp clock source!\n");
+		BREAK_TO_DEBUGGER();
+		goto clk_src_create_fail;
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto clk_src_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dal_display_clock_dce110_create(ctx, as);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto disp_clk_create_fail;
+	}
+
+	{
+		struct irq_service_init_data init_data;
+
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_create(
+				dal_adapter_service_get_dce_version(
+					pool->base.adapter_srv),
+				&init_data);
+		if (!pool->base.irqs)
+			goto irqs_create_fail;
+
+	}
+
+	/*************************************************
+	*  Resource + asic cap harcoding                *
+	*************************************************/
+	pool->base.underlay_pipe_index = -1;
+	pool->base.pipe_count = dal_adapter_service_get_func_controllers_num(as);
+	pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
+	pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+
+	if (pool->base.scaler_filter == NULL) {
+		BREAK_TO_DEBUGGER();
+		dm_error("DC: failed to create filter!\n");
+		goto filter_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] =
+			dce100_timing_generator_create(
+				as,
+				ctx,
+				i,
+				&dce100_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.mis[i] = dce100_mem_input_create(ctx, as, i,
+				&dce100_mi_reg_offsets[i]);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create memory input!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.ipps[i] = dce100_ipp_create(ctx, i,
+				&dce100_ipp_reg_offsets[i]);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create input pixel processor!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.transforms[i] = dce100_transform_create(
+					ctx, i, &dce100_xfm_offsets[i]);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create transform!\n");
+			goto controller_create_fail;
+		}
+		pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+				pool->base.transforms[i],
+				pool->base.scaler_filter);
+
+		pool->base.opps[i] = dce100_opp_create(ctx, i, &dce100_opp_reg_offsets[i]);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create output pixel processor!\n");
+			goto controller_create_fail;
+		}
+	}
+
+	pool->base.audio_count = 0;
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		struct graphics_object_id obj_id;
+
+		obj_id = dal_adapter_service_enum_audio_object(as, i);
+		if (false == dal_graphics_object_id_is_valid(obj_id)) {
+			/* no more valid audio objects */
+			break;
+		}
+
+		pool->base.audios[i] = dce110_audio_create(
+				ctx, i, &audio_regs[i]);
+		if (pool->base.audios[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create DPPs!\n");
+			goto audio_create_fail;
+		}
+		pool->base.audio_count++;
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		/* TODO: rework fragile code*/
+		if (pool->base.stream_engines.u_all & 1 << i) {
+			pool->base.stream_enc[i] = dce100_stream_encoder_create(
+				i, dc->ctx,
+				dal_adapter_service_get_bios_parser(as),
+				&stream_enc_regs[i]);
+			if (pool->base.stream_enc[i] == NULL) {
+				BREAK_TO_DEBUGGER();
+				dm_error("DC: failed to create stream_encoder!\n");
+				goto stream_enc_create_fail;
+			}
+		}
+	}
+
+	for (i = 0; i < num_virtual_links; i++) {
+		pool->base.stream_enc[pool->base.stream_enc_count] =
+			virtual_stream_encoder_create(
+				dc->ctx,
+				dal_adapter_service_get_bios_parser(as));
+		if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create stream_encoder!\n");
+			goto stream_enc_create_fail;
+		}
+		pool->base.stream_enc_count++;
+	}
+
+	/* Create hardware sequencer */
+	if (!dce100_hw_sequencer_construct(dc))
+		goto stream_enc_create_fail;
+
+	return true;
 
 stream_enc_create_fail:
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
 
 audio_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.audios[i] != NULL)
-                        dce110_aud_destroy(&pool->base.audios[i]);
-        }
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.audios[i] != NULL)
+			dce110_aud_destroy(&pool->base.audios[i]);
+	}
 
 controller_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce100_opp_destroy(&pool->base.opps[i]);
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce100_opp_destroy(&pool->base.opps[i]);
 
-                if (pool->base.transforms[i] != NULL)
-                        dce100_transform_destroy(&pool->base.transforms[i]);
+		if (pool->base.transforms[i] != NULL)
+			dce100_transform_destroy(&pool->base.transforms[i]);
 
-                if (pool->base.ipps[i] != NULL)
-                        dce110_ipp_destroy(&pool->base.ipps[i]);
+		if (pool->base.ipps[i] != NULL)
+			dce110_ipp_destroy(&pool->base.ipps[i]);
 
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
 
-                if (pool->base.timing_generators[i] != NULL)    {
-                         dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
 
 filter_create_fail:
-        dal_irq_service_destroy(&pool->base.irqs);
+	dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-        dal_display_clock_destroy(&pool->base.display_clock);
+	dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL)
-                        dce100_clock_source_destroy(&pool->base.clock_sources[i]);
-        }
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL)
+			dce100_clock_source_destroy(&pool->base.clock_sources[i]);
+	}
 
-        return false;
+	return false;
 }
 
 struct resource_pool *dce100_create_resource_pool(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc)
 {
-        struct dce110_resource_pool *pool =
-                dm_alloc(sizeof(struct dce110_resource_pool));
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
 
-        if (!pool)
-                return NULL;
+	if (!pool)
+		return NULL;
 
-        if (construct(as, num_virtual_links, dc, pool))
-                return &pool->base;
+	if (construct(as, num_virtual_links, dc, pool))
+		return &pool->base;
 
-        BREAK_TO_DEBUGGER();
-        return NULL;
+	BREAK_TO_DEBUGGER();
+	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h
index c332869..24af9bf 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.h
@@ -13,12 +13,9 @@ struct core_dc;
 struct resource_pool;
 struct dc_validation_set;
 
-bool dce100_construct_resource_pool(
-	struct adapter_service *adapter_serv,
+struct resource_pool *dce100_create_resource_pool(
+	struct adapter_service *as,
 	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool);
-
-void dce100_destruct_resource_pool(struct resource_pool *pool);
+	struct core_dc *dc);
 
 #endif /* DCE100_RESOURCE_H_ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
index f60f292..6786815 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
@@ -430,8 +430,8 @@ static bool pll_adjust_pix_clk(
 	bp_adjust_pixel_clock_params.signal_type = pix_clk_params->signal_type;
 	bp_adjust_pixel_clock_params.
 		ss_enable = pix_clk_params->flags.ENABLE_SS;
-	bp_result = dc_bios_adjust_pixel_clock(clk_src->bios,
-					       &bp_adjust_pixel_clock_params);
+	bp_result = clk_src->bios->funcs->adjust_pixel_clock(
+			clk_src->bios, &bp_adjust_pixel_clock_params);
 	if (bp_result == BP_RESULT_OK) {
 		pll_settings->actual_pix_clk = actual_pix_clk_khz;
 		pll_settings->adjusted_pix_clk =
@@ -554,9 +554,10 @@ static bool disable_spread_spectrum(struct dce110_clk_src *clk_src)
 	bp_ss_params.pll_id = clk_src->base.id;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	result = dc_bios_enable_spread_spectrum_on_ppll(clk_src->bios,
-							&bp_ss_params,
-							false);
+	result = clk_src->bios->funcs->enable_spread_spectrum_on_ppll(
+			clk_src->bios,
+			&bp_ss_params,
+			false);
 
 	return result == BP_RESULT_OK;
 }
@@ -660,9 +661,11 @@ static bool enable_spread_spectrum(
 				bp_params.flags.EXTERNAL_SS = 1;
 
 			if (BP_RESULT_OK !=
-			    dc_bios_enable_spread_spectrum_on_ppll(clk_src->bios,
-								   &bp_params,
-								   true))
+				clk_src->bios->funcs->
+					enable_spread_spectrum_on_ppll(
+							clk_src->bios,
+							&bp_params,
+							true))
 				return false;
 		} else
 			return false;
@@ -765,8 +768,8 @@ static bool dce110_program_pix_clk(
 	bp_pc_params.flags.SET_EXTERNAL_REF_DIV_SRC =
 					pll_settings->use_external_clk;
 
-	if (dc_bios_set_pixel_clock(dce110_clk_src->bios,
-				    &bp_pc_params) != BP_RESULT_OK)
+	if (dce110_clk_src->bios->funcs->set_pixel_clock(
+			dce110_clk_src->bios, &bp_pc_params) != BP_RESULT_OK)
 		return false;
 
 /* Enable SS
@@ -807,7 +810,7 @@ static bool dce110_clock_source_power_down(
 	bp_pixel_clock_params.flags.FORCE_PROGRAMMING_OF_PLL = 1;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	bp_result = dc_bios_set_pixel_clock(
+	bp_result = dce110_clk_src->bios->funcs->set_pixel_clock(
 			dce110_clk_src->bios,
 			&bp_pixel_clock_params);
 
@@ -854,8 +857,9 @@ static void get_ss_info_from_atombios(
 	spread_spectrum_data[0] = NULL;
 	*ss_entries_num = 0;
 
-	*ss_entries_num = dc_bios_get_ss_entry_number(clk_src->bios,
-						      as_signal);
+	*ss_entries_num = clk_src->bios->funcs->get_ss_entry_number(
+			clk_src->bios,
+			as_signal);
 
 	if (*ss_entries_num == 0)
 		return;
@@ -873,10 +877,11 @@ static void get_ss_info_from_atombios(
 		i < (*ss_entries_num);
 		++i, ++ss_info_cur) {
 
-		bp_result = dc_bios_get_spread_spectrum_info(clk_src->bios,
-							     as_signal,
-							     i,
-							     ss_info_cur);
+		bp_result = clk_src->bios->funcs->get_spread_spectrum_info(
+				clk_src->bios,
+				as_signal,
+				i,
+				ss_info_cur);
 
 		if (bp_result != BP_RESULT_OK)
 			goto out_free_data;
@@ -979,8 +984,9 @@ static bool calc_pll_max_vco_construct(
 			init_data->bp == NULL)
 		return false;
 
-	if (dc_bios_get_firmware_info(init_data->bp,
-				      &fw_info) != BP_RESULT_OK)
+	if (init_data->bp->funcs->get_firmware_info(
+				init_data->bp,
+				&fw_info) != BP_RESULT_OK)
 		return false;
 
 	calc_pll_cs->ctx = init_data->ctx;
@@ -1099,7 +1105,8 @@ bool dce110_clk_src_construct(
 	clk_src->base.id = id;
 	clk_src->base.funcs = &dce110_clk_src_funcs;
 
-	if (dc_bios_get_firmware_info(clk_src->bios, &fw_info) != BP_RESULT_OK) {
+	if (clk_src->bios->funcs->get_firmware_info(
+			clk_src->bios, &fw_info) != BP_RESULT_OK) {
 		ASSERT_CRITICAL(false);
 		goto unexpected_failure;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 0cb1f9f..5709898 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -373,25 +373,27 @@ static bool dce110_enable_display_power_gating(
 	else
 		cntl = ASIC_PIPE_DISABLE;
 
-        if (controller_id == underlay_idx)
+	if (controller_id == underlay_idx)
 		controller_id = CONTROLLER_ID_UNDERLAY0 - 1;
 
-        if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0){
-
-		bp_result = dc_bios_enable_disp_power_gating(dcb, controller_id + 1, cntl);
-                /* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
-                 * by default when command table is called
-                 *
-                 * Bios parser accepts controller_id = 6 as indicative of
-                 * underlay pipe in dce110. But we do not support more
-                 * than 3.
-                 */
-                if (controller_id < CONTROLLER_ID_MAX - 1)
-                        dm_write_reg(ctx,
-                                HW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),
-                                0);
-        }
- 
+	if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0){
+
+		bp_result = dcb->funcs->enable_disp_power_gating(
+						dcb, controller_id + 1, cntl);
+
+		/* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
+		 * by default when command table is called
+		 *
+		 * Bios parser accepts controller_id = 6 as indicative of
+		 * underlay pipe in dce110. But we do not support more
+		 * than 3.
+		 */
+		if (controller_id < CONTROLLER_ID_MAX - 1)
+			dm_write_reg(ctx,
+				HW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),
+				0);
+	}
+
 	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
 		dce110_init_pte(ctx);
 
@@ -491,7 +493,7 @@ static enum dc_status bios_parser_crtc_source_select(
 
 	dcb = dal_adapter_service_get_bios_parser(sink->link->adapter_srv);
 
-	if (BP_RESULT_OK != dc_bios_crtc_source_select(
+	if (BP_RESULT_OK != dcb->funcs->crtc_source_select(
 		dcb,
 		&crtc_source_select)) {
 		return DC_ERROR_UNEXPECTED;
@@ -500,12 +502,13 @@ static enum dc_status bios_parser_crtc_source_select(
 	return DC_OK;
 }
 
-static void update_bios_scratch_critical_state(struct core_dc *dc,
-					       bool state)
+
+static void update_bios_scratch_critical_state(struct adapter_service *as,
+		bool state)
 {
-#ifdef CONFIG_DRM_AMD_DAL_VBIOS_PRESENT
-	dce110_set_scratch_critical_state(dc->ctx, state);
-#endif
+	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
+
+	dcb->funcs->set_scratch_critical_state(dcb, state);
 }
 
 static void update_info_frame(struct pipe_ctx *pipe_ctx)
@@ -896,9 +899,9 @@ static void power_down_controllers(struct core_dc *dc)
 {
 	int i;
 
-	for (i = 0; i < dc->res_pool.pipe_count; i++) {
-		dc->res_pool.timing_generators[i]->funcs->disable_crtc(
-				dc->res_pool.timing_generators[i]);
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		dc->res_pool->timing_generators[i]->funcs->disable_crtc(
+				dc->res_pool->timing_generators[i]);
 	}
 }
 
@@ -906,13 +909,13 @@ static void power_down_clock_sources(struct core_dc *dc)
 {
 	int i;
 
-	if (dc->res_pool.dp_clock_source->funcs->cs_power_down(
-		dc->res_pool.dp_clock_source) == false)
+	if (dc->res_pool->dp_clock_source->funcs->cs_power_down(
+		dc->res_pool->dp_clock_source) == false)
 		dm_error("Failed to power down pll! (dp clk src)\n");
 
-	for (i = 0; i < dc->res_pool.clk_src_count; i++) {
-		if (dc->res_pool.clock_sources[i]->funcs->cs_power_down(
-				dc->res_pool.clock_sources[i]) == false)
+	for (i = 0; i < dc->res_pool->clk_src_count; i++) {
+		if (dc->res_pool->clock_sources[i]->funcs->cs_power_down(
+				dc->res_pool->clock_sources[i]) == false)
 			dm_error("Failed to power down pll! (clk src index=%d)\n", i);
 	}
 }
@@ -935,10 +938,10 @@ static void disable_vga_and_power_gate_all_controllers(
 	struct dc_context *ctx;
 
 	dcb = dal_adapter_service_get_bios_parser(
-			dc->res_pool.adapter_srv);
+			dc->res_pool->adapter_srv);
 
-	for (i = 0; i < dc->res_pool.pipe_count; i++) {
-		tg = dc->res_pool.timing_generators[i];
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		tg = dc->res_pool->timing_generators[i];
 		ctx = dc->ctx;
 
 		tg->funcs->disable_vga(tg);
@@ -962,10 +965,10 @@ static void disable_vga_and_power_gate_all_controllers(
  */
 static void enable_accelerated_mode(struct core_dc *dc)
 {
-        struct dc_bios *dcb;
+	struct dc_bios *dcb;
+
+	dcb = dal_adapter_service_get_bios_parser(dc->res_pool->adapter_srv);
 
-        dcb = dal_adapter_service_get_bios_parser(dc->res_pool->adapter_srv);
-	
 	power_down_all_hw_blocks(dc);
 
 	disable_vga_and_power_gate_all_controllers(dc);
@@ -1039,14 +1042,14 @@ static bool dc_set_clocks_and_clock_state (
 {
 	struct power_to_dal_info output = {0};
 
-	struct display_clock *disp_clk = context->res_ctx.pool.display_clock;
+	struct display_clock *disp_clk = context->res_ctx.pool->display_clock;
 	struct dc_context *ctx = context->targets[0]->ctx;
 
 	if (!dc_pre_clock_change(
 			ctx,
 			&context->res_ctx.min_clocks,
 			get_required_clocks_state(
-					context->res_ctx.pool.display_clock,
+					context->res_ctx.pool->display_clock,
 					&context->res_ctx.state_clocks),
 			&output)) {
 		/* "output" was not updated by PPLib.
@@ -1094,19 +1097,19 @@ static void set_display_clock(struct validate_context *context)
 		/*TODO: set_display_clock_dfs_bypass(
 				hws,
 				path_set,
-				context->res_ctx.pool.display_clock,
+				context->res_ctx.pool->display_clock,
 				context->res_ctx.min_clocks.min_dclk_khz);*/
-        } else {
-                /*
-                 * TODO: need to either port work around from DAL2 function
-                 * getActualRequiredDisplayClock or program displayclock without
-                 * calling vbios. Currently temporily work
-                 * around by increasing the displclk by 15 percent
-                 */
-                dal_display_clock_set_clock(
-                                context->res_ctx.pool->display_clock,
-                                context->bw_results.dispclk_khz * 115 / 100);
-        }
+	} else {
+		/*
+		 * TODO: need to either port work around from DAL2 function
+		 * getActualRequiredDisplayClock or program displayclock without
+		 * calling vbios. Currently temporily work
+		 * around by increasing the displclk by 15 percent
+		 */
+		dal_display_clock_set_clock(
+				context->res_ctx.pool->display_clock,
+				context->bw_results.dispclk_khz * 115 / 100);
+	}
 
 
 	/* TODO: When changing display engine clock, DMCU WaitLoop must be
@@ -1395,7 +1398,7 @@ static enum dc_status apply_ctx_to_hw(
 		return DC_OK;
 
 	/* Apply new context */
-	update_bios_scratch_critical_state(dc, true);
+	update_bios_scratch_critical_state(context->res_ctx.pool->adapter_srv, true);
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
@@ -1414,10 +1417,10 @@ static enum dc_status apply_ctx_to_hw(
 		}
 
 		dcb = dal_adapter_service_get_bios_parser(
-				context->res_ctx.pool.adapter_srv);
+				context->res_ctx.pool->adapter_srv);
 
 		dc->hwss.enable_display_power_gating(
-                                dc, i, dcb,
+				dc, i, dcb,
 				PIPE_GATING_CONTROL_DISABLE);
 	}
 
@@ -1505,7 +1508,7 @@ static enum dc_status apply_ctx_to_hw(
 
 	dc->hwss.set_displaymarks(dc, context);
 
-	update_bios_scratch_critical_state(dc, false);
+	update_bios_scratch_critical_state(context->res_ctx.pool->adapter_srv, false);
 
 	switch_dp_clock_sources(dc, &context->res_ctx);
 
@@ -1795,15 +1798,15 @@ static void init_hw(struct core_dc *dc)
 	struct transform *xfm;
 
 	bp = dc->ctx->dc_bios;
-	for (i = 0; i < dc->res_pool.pipe_count; i++) {
-		xfm = dc->res_pool.transforms[i];
-                xfm->funcs->transform_reset(xfm);
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		xfm = dc->res_pool->transforms[i];
+		xfm->funcs->transform_reset(xfm);
 
 		dc->hwss.enable_display_power_gating(
-                                dc, i, bp,
+				dc, i, bp,
 				PIPE_GATING_CONTROL_INIT);
 		dc->hwss.enable_display_power_gating(
-                                dc, i, bp,
+				dc, i, bp,
 				PIPE_GATING_CONTROL_DISABLE);
 		xfm->funcs->transform_power_up(xfm);
 		dc->hwss.enable_display_pipe_clock_gating(
@@ -1823,8 +1826,8 @@ static void init_hw(struct core_dc *dc)
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
 
-	for (i = 0; i < dc->res_pool.pipe_count; i++) {
-		struct timing_generator *tg = dc->res_pool.timing_generators[i];
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
 		tg->funcs->disable_vga(tg);
 
@@ -1833,10 +1836,9 @@ static void init_hw(struct core_dc *dc)
 		tg->funcs->set_blank(tg, true);
 	}
 
-	for (i = 0; i < dc->res_pool.audio_count; i++) {
-		struct audio *audio = dc->res_pool.audios[i];
-
-                audio->funcs->hw_init(audio);
+	for (i = 0; i < dc->res_pool->audio_count; i++) {
+		struct audio *audio = dc->res_pool->audios[i];
+		audio->funcs->hw_init(audio);
 	}
 }
 
@@ -1853,7 +1855,7 @@ static void dce110_power_on_pipe_if_needed(
 
 	if (!old_pipe_ctx->stream && pipe_ctx->stream) {
 		dc->hwss.enable_display_power_gating(
-                                dc,
+				dc,
 				pipe_ctx->pipe_idx,
 				dcb, PIPE_GATING_CONTROL_DISABLE);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index a262d91..6e3429b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -153,7 +153,7 @@ static enum bp_result link_transmitter_control(
 	struct dc_bios *bp = dal_adapter_service_get_bios_parser(
 					enc110->base.adapter_service);
 
-	result = dc_bios_transmitter_control(bp, cntl);
+	result = bp->funcs->transmitter_control(bp, cntl);
 
 	return result;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 0713946..0258aba 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -29,6 +29,7 @@
 #include "stream_encoder.h"
 
 #include "resource.h"
+#include "dce110/dce110_resource.h"
 #include "include/irq_service_interface.h"
 #include "../virtual/virtual_stream_encoder.h"
 #include "dce110/audio_dce110.h"
@@ -488,65 +489,66 @@ void dce110_clock_source_destroy(struct clock_source **clk_src)
 
 static void destruct(struct dce110_resource_pool *pool)
 {
-        unsigned int i;
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce110_opp_destroy(&pool->base.opps[i]);
-
-                if (pool->base.transforms[i] != NULL)
-                        dce110_transform_destroy(&pool->base.transforms[i]);
-
-                if (pool->base.ipps[i] != NULL)
-                        dce110_ipp_destroy(&pool->base.ipps[i]);
-
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
-
-                if (pool->base.timing_generators[i] != NULL)    {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
-
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL) {
-                        dce110_clock_source_destroy(&pool->base.clock_sources[i]);
-                }
-        }
-
-        if (pool->base.dp_clock_source != NULL)
-                dce110_clock_source_destroy(&pool->base.dp_clock_source);
-
-        for (i = 0; i < pool->base.audio_count; i++)    {
-                if (pool->base.audios[i] != NULL) {
-                        dce110_aud_destroy(&pool->base.audios[i]);
-                }
-        }
-
-        if (pool->base.display_clock != NULL) {
-                dal_display_clock_destroy(&pool->base.display_clock);
-        }
-
-        if (pool->base.scaler_filter != NULL) {
-                dal_scaler_filter_destroy(&pool->base.scaler_filter);
-        }
-        if (pool->base.irqs != NULL) {
-                dal_irq_service_destroy(&pool->base.irqs);
-        }
-
-        if (pool->base.adapter_srv != NULL) {
-                dal_adapter_service_destroy(&pool->base.adapter_srv);
-        }
+	unsigned int i;
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce110_opp_destroy(&pool->base.opps[i]);
+
+		if (pool->base.transforms[i] != NULL)
+			dce110_transform_destroy(&pool->base.transforms[i]);
+
+		if (pool->base.ipps[i] != NULL)
+			dce110_ipp_destroy(&pool->base.ipps[i]);
+
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
+
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL) {
+			dce110_clock_source_destroy(&pool->base.clock_sources[i]);
+		}
+	}
+
+	if (pool->base.dp_clock_source != NULL)
+		dce110_clock_source_destroy(&pool->base.dp_clock_source);
+
+	for (i = 0; i < pool->base.audio_count; i++)	{
+		if (pool->base.audios[i] != NULL) {
+			dce110_aud_destroy(&pool->base.audios[i]);
+		}
+	}
+
+	if (pool->base.display_clock != NULL) {
+		dal_display_clock_destroy(&pool->base.display_clock);
+	}
+
+	if (pool->base.scaler_filter != NULL) {
+		dal_scaler_filter_destroy(&pool->base.scaler_filter);
+	}
+	if (pool->base.irqs != NULL) {
+		dal_irq_service_destroy(&pool->base.irqs);
+	}
+
+	if (pool->base.adapter_srv != NULL) {
+		dal_adapter_service_destroy(&pool->base.adapter_srv);
+	}
 }
 
+
 static void get_pixel_clock_parameters(
 	const struct pipe_ctx *pipe_ctx,
 	struct pixel_clk_params *pixel_clk_params)
@@ -905,33 +907,42 @@ enum dc_status dce110_validate_guaranteed(
 }
 
 static struct pipe_ctx *dce110_acquire_idle_pipe_for_layer(
-                struct resource_context *res_ctx,
-                struct core_stream *stream)
+		struct resource_context *res_ctx,
+		struct core_stream *stream)
 {
-        unsigned int underlay_idx = res_ctx->pool->underlay_pipe_index;
-        struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];
- 
-        if (res_ctx->pipe_ctx[underlay_idx].stream) {
-                return NULL;
-        }
-
-        pipe_ctx->tg = res_ctx->pool->timing_generators[underlay_idx];
-        pipe_ctx->mi = res_ctx->pool->mis[underlay_idx];
-        /*pipe_ctx->ipp = res_ctx->pool->ipps[underlay_idx];*/
-        pipe_ctx->xfm = res_ctx->pool->transforms[underlay_idx];
-        pipe_ctx->opp = res_ctx->pool->opps[underlay_idx]; 
-        pipe_ctx->dis_clk = res_ctx->pool->display_clock;
- 
-        pipe_ctx->pipe_idx = underlay_idx; 
- 
-        pipe_ctx->stream = stream;
- 
-        return pipe_ctx;
+	unsigned int underlay_idx = res_ctx->pool->underlay_pipe_index;
+	struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];
+
+	if (res_ctx->pipe_ctx[underlay_idx].stream) {
+		return NULL;
+	}
+
+	pipe_ctx->tg = res_ctx->pool->timing_generators[underlay_idx];
+	pipe_ctx->mi = res_ctx->pool->mis[underlay_idx];
+	/*pipe_ctx->ipp = res_ctx->pool->ipps[underlay_idx];*/
+	pipe_ctx->xfm = res_ctx->pool->transforms[underlay_idx];
+	pipe_ctx->opp = res_ctx->pool->opps[underlay_idx];
+	pipe_ctx->dis_clk = res_ctx->pool->display_clock;
+	pipe_ctx->pipe_idx = underlay_idx;
+
+	pipe_ctx->stream = stream;
+
+	return pipe_ctx;
 
 }
 
+static void dce110_destroy_resource_pool(struct resource_pool **pool)
+{
+	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
+
+	destruct(dce110_pool);
+	dm_free(dce110_pool);
+	*pool = NULL;
+}
+
+
 static const struct resource_funcs dce110_res_pool_funcs = {
-	.destruct = dce110_destruct_resource_pool,
+	.destroy = dce110_destroy_resource_pool,
 	.link_enc_create = dce110_link_encoder_create,
 	.validate_with_context = dce110_validate_with_context,
 	.validate_guaranteed = dce110_validate_guaranteed,
@@ -1023,279 +1034,282 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 }
 
 static bool construct(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc,
-        struct dce110_resource_pool *pool,
-        struct hw_asic_id asic_id)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool,
+	struct hw_asic_id asic_id)
 {
-        unsigned int i;
-        struct dc_context *ctx = dc->ctx;
-        struct firmware_info info;
-        struct dc_bios *bp;
-
-        pool->base.adapter_srv = as;
-        pool->base.funcs = &dce110_res_pool_funcs;
-
-        /*************************************************
-         *  Resource + asic cap harcoding                *
-         *************************************************/
-        pool->base.pipe_count = 3;
-        pool->base.stream_enc_count = 3;
-        pool->base.underlay_pipe_index = 3;
- 
-        if (ASIC_REV_IS_STONEY(asic_id.hw_internal_rev)) {
-                pool->base.pipe_count = 2;
-                pool->base.stream_enc_count = 2;
-                pool->base.underlay_pipe_index = 2;
-        }
- 
-        dc->public.caps.max_downscale_ratio = 150;
-        dc->public.caps.i2c_speed_in_khz = 100;
-
-        /*************************************************
-         *  Create resources                             *
-         *************************************************/
-
-
-        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-        bp = dal_adapter_service_get_bios_parser(as);
-
-        if (dal_adapter_service_get_firmware_info(as, &info) &&
-                info.external_clock_source_frequency_for_dp != 0) {
-                pool->base.dp_clock_source =
-                                dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
-
-                pool->base.clock_sources[0] =
-                                dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce110_clk_src_reg_offsets[0]);
-                pool->base.clock_sources[1] =
-                                dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce110_clk_src_reg_offsets[1]);
-
-                pool->base.clk_src_count = 2;
-
-                /* TODO: find out if CZ support 3 PLLs */
-        }
-
-        if (pool->base.dp_clock_source == NULL) {
-                dm_error("DC: failed to create dp clock source!\n");
-                BREAK_TO_DEBUGGER();
-                goto clk_src_create_fail;
-        }
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+	struct firmware_info info;
+	struct dc_bios *bp;
+
+	pool->base.adapter_srv = as;
+	pool->base.funcs = &dce110_res_pool_funcs;
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+
+	pool->base.pipe_count = 3;
+	pool->base.stream_enc_count = 3;
+	pool->base.underlay_pipe_index = 3;
+
+	if (ASIC_REV_IS_STONEY(asic_id.hw_internal_rev)) {
+		pool->base.pipe_count = 2;
+		pool->base.stream_enc_count = 2;
+		pool->base.underlay_pipe_index = 2;
+	}
+
+	dc->public.caps.max_downscale_ratio = 150;
+	dc->public.caps.i2c_speed_in_khz = 100;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+
+	pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+	bp = dal_adapter_service_get_bios_parser(as);
+
+	if (dal_adapter_service_get_firmware_info(as, &info) &&
+		info.external_clock_source_frequency_for_dp != 0) {
+		pool->base.dp_clock_source =
+				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+
+		pool->base.clock_sources[0] =
+				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce110_clk_src_reg_offsets[0]);
+		pool->base.clock_sources[1] =
+				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce110_clk_src_reg_offsets[1]);
+
+		pool->base.clk_src_count = 2;
+
+		/* TODO: find out if CZ support 3 PLLs */
+	}
+
+	if (pool->base.dp_clock_source == NULL) {
+		dm_error("DC: failed to create dp clock source!\n");
+		BREAK_TO_DEBUGGER();
+		goto clk_src_create_fail;
+	}
+
 	for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] == NULL) {
-                        dm_error("DC: failed to create clock sources!\n");
-                        BREAK_TO_DEBUGGER();
-                        goto clk_src_create_fail;
-                }
-        }
-
-        pool->base.display_clock = dal_display_clock_dce110_create(ctx, as);
-        if (pool->base.display_clock == NULL) {
-                dm_error("DC: failed to create display clock!\n");
-                BREAK_TO_DEBUGGER();
-                goto disp_clk_create_fail;
-        }
-
-        {
-                struct irq_service_init_data init_data;
-                init_data.ctx = dc->ctx;
-                pool->base.irqs = dal_irq_service_create(
-                                dal_adapter_service_get_dce_version(
-                                        pool->base.adapter_srv),
-                                &init_data);
-                if (!pool->base.irqs)
-                        goto irqs_create_fail;
-
-        }
-
-        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
-        if (pool->base.scaler_filter == NULL) {
-                BREAK_TO_DEBUGGER();
-                dm_error("DC: failed to create filter!\n");
-                goto filter_create_fail;
-        }
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                pool->base.timing_generators[i] = dce110_timing_generator_create(
-                                as, ctx, i, &dce110_tg_offsets[i]);
-                if (pool->base.timing_generators[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create tg!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.mis[i] = dce110_mem_input_create(ctx, as, i,
-                                &dce110_mi_reg_offsets[i]);
-                if (pool->base.mis[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create memory input!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.ipps[i] = dce110_ipp_create(ctx, i, &dce110_ipp_reg_offsets[i]);
-                if (pool->base.ipps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create input pixel processor!\n");
-                        goto controller_create_fail;
-   }
-
-                pool->base.transforms[i] = dce110_transform_create(
-                                        ctx, i, &dce110_xfm_offsets[i]);
-                if (pool->base.transforms[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create transform!\n");
-                        goto controller_create_fail;
-                }
-                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
-                                pool->base.transforms[i],
-                                pool->base.scaler_filter);
-
-                pool->base.opps[i] = dce110_opp_create(ctx, i, &dce110_opp_reg_offsets[i]);
-                if (pool->base.opps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create output pixel processor!\n");
-                        goto controller_create_fail;
-                }
-        }
-        pool->base.audio_count = 0;
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                struct graphics_object_id obj_id;
-
-                obj_id = dal_adapter_service_enum_audio_object(as, i);
-                if (false == dal_graphics_object_id_is_valid(obj_id)) {
-                        /* no more valid audio objects */
-                        break;
-                }
-
-                pool->base.audios[i] = dce110_audio_create(
-                                ctx, i, &audio_regs[i]);
-                if (pool->base.audios[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create audio!\n");
-                        goto audio_create_fail;
-                }
-                pool->base.audio_count++;
-        }
-       
-	 /* TODO: failure? */
-        underlay_create(ctx, &pool->base);
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                /* TODO: rework fragile code*/
-                if (pool->base.stream_engines.u_all & 1 << i) {
-                        pool->base.stream_enc[i] = dce110_stream_encoder_create(
-                                i, dc->ctx,
-                                dal_adapter_service_get_bios_parser(as),
-                                &stream_enc_regs[i]);
-                        if (pool->base.stream_enc[i] == NULL) {
-                                BREAK_TO_DEBUGGER();
-                                dm_error("DC: failed to create stream_encoder!\n");
-                                goto stream_enc_create_fail;
-                        }
-                }
-        }
-
-        for (i = 0; i < num_virtual_links; i++) {
-                pool->base.stream_enc[pool->base.stream_enc_count] =
-                        virtual_stream_encoder_create(
-                                dc->ctx,
-                                dal_adapter_service_get_bios_parser(as));
-
-                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create stream_encoder!\n");
-                        goto stream_enc_create_fail;
-                }
-                pool->base.stream_enc_count++;
-        }
-
-        /* Create hardware sequencer */
-        if (!dce110_hw_sequencer_construct(dc))
-                goto stream_enc_create_fail;
-
-        bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_CARRIZO);
-
-        bw_calcs_data_update_from_pplib(dc);
-
-        return true;
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto clk_src_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dal_display_clock_dce110_create(ctx, as);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto disp_clk_create_fail;
+	}
+
+	{
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_create(
+				dal_adapter_service_get_dce_version(
+					pool->base.adapter_srv),
+				&init_data);
+		if (!pool->base.irqs)
+			goto irqs_create_fail;
+
+	}
+
+	pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+	if (pool->base.scaler_filter == NULL) {
+		BREAK_TO_DEBUGGER();
+		dm_error("DC: failed to create filter!\n");
+		goto filter_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] = dce110_timing_generator_create(
+				as, ctx, i, &dce110_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.mis[i] = dce110_mem_input_create(ctx, as, i,
+				&dce110_mi_reg_offsets[i]);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create memory input!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.ipps[i] = dce110_ipp_create(ctx, i, &dce110_ipp_reg_offsets[i]);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create input pixel processor!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.transforms[i] = dce110_transform_create(
+					ctx, i, &dce110_xfm_offsets[i]);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create transform!\n");
+			goto controller_create_fail;
+		}
+		pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+				pool->base.transforms[i],
+				pool->base.scaler_filter);
+
+		pool->base.opps[i] = dce110_opp_create(ctx, i, &dce110_opp_reg_offsets[i]);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create output pixel processor!\n");
+			goto controller_create_fail;
+		}
+	}
+
+	pool->base.audio_count = 0;
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		struct graphics_object_id obj_id;
+
+		obj_id = dal_adapter_service_enum_audio_object(as, i);
+		if (false == dal_graphics_object_id_is_valid(obj_id)) {
+			/* no more valid audio objects */
+			break;
+		}
+
+		pool->base.audios[i] = dce110_audio_create(
+				ctx, i, &audio_regs[i]);
+
+		if (pool->base.audios[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create audio!\n");
+			goto audio_create_fail;
+		}
+		pool->base.audio_count++;
+	}
+
+	/* TODO: failure? */
+	underlay_create(ctx, &pool->base);
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		/* TODO: rework fragile code*/
+		if (pool->base.stream_engines.u_all & 1 << i) {
+			pool->base.stream_enc[i] = dce110_stream_encoder_create(
+				i, dc->ctx,
+				dal_adapter_service_get_bios_parser(as),
+				&stream_enc_regs[i]);
+			if (pool->base.stream_enc[i] == NULL) {
+				BREAK_TO_DEBUGGER();
+				dm_error("DC: failed to create stream_encoder!\n");
+				goto stream_enc_create_fail;
+			}
+		}
+	}
+
+	for (i = 0; i < num_virtual_links; i++) {
+		pool->base.stream_enc[pool->base.stream_enc_count] =
+			virtual_stream_encoder_create(
+				dc->ctx,
+				dal_adapter_service_get_bios_parser(as));
+
+		if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create stream_encoder!\n");
+			goto stream_enc_create_fail;
+		}
+		pool->base.stream_enc_count++;
+	}
+
+
+	/* Create hardware sequencer */
+	if (!dce110_hw_sequencer_construct(dc))
+		goto stream_enc_create_fail;
+
+	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_CARRIZO);
+
+	bw_calcs_data_update_from_pplib(dc);
+
+	return true;
 
 stream_enc_create_fail:
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
 
 audio_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.audios[i] != NULL)
-                        dce110_aud_destroy(&pool->base.audios[i]);
-        }
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.audios[i] != NULL)
+			dce110_aud_destroy(&pool->base.audios[i]);
+	}
 
 controller_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        pool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			pool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);
 
-                if (pool->base.transforms[i] != NULL)
-                        dce110_transform_destroy(&pool->base.transforms[i]);
+		if (pool->base.transforms[i] != NULL)
+			dce110_transform_destroy(&pool->base.transforms[i]);
 
-                if (pool->base.ipps[i] != NULL)
-                        dce110_ipp_destroy(&pool->base.ipps[i]);
+		if (pool->base.ipps[i] != NULL)
+			dce110_ipp_destroy(&pool->base.ipps[i]);
 
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
-               }
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
 
-                if (pool->base.timing_generators[i] != NULL)    {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
 
 filter_create_fail:
-        dal_irq_service_destroy(&pool->base.irqs);
+	dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-        dal_display_clock_destroy(&pool->base.display_clock);
+	dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL)
-                        dce110_clock_source_destroy(&pool->base.clock_sources[i]);
-        }
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL)
+			dce110_clock_source_destroy(&pool->base.clock_sources[i]);
+	}
 
-        return false;
+	return false;
 }
 
 struct resource_pool *dce110_create_resource_pool(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc,
-        struct hw_asic_id asic_id)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct hw_asic_id asic_id)
 {
-        struct dce110_resource_pool *pool =
-                dm_alloc(sizeof(struct dce110_resource_pool));
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
 
-        if (!pool)
-                return NULL;
+	if (!pool)
+		return NULL;
 
-        if (construct(as, num_virtual_links, dc, pool, asic_id))
-                return &pool->base;
+	if (construct(as, num_virtual_links, dc, pool, asic_id))
+		return &pool->base;
 
-        BREAK_TO_DEBUGGER();
-        return NULL;
+	BREAK_TO_DEBUGGER();
+	return NULL;
 }
-
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
index 9cdfd53..05b571e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
@@ -32,21 +32,22 @@ struct adapter_service;
 struct core_dc;
 struct resource_pool;
 
+#define TO_DCE110_RES_POOL(pool)\
+	container_of(pool, struct dce110_resource_pool, base)
+
+struct dce110_resource_pool {
+	struct resource_pool base;
+};
+
 enum dc_status dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx);
 
-bool dce110_construct_resource_pool(
-	struct adapter_service *adapter_serv,
-	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool);
 
-struct resource_pool *dce110_create_resource_pool(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc,
-        struct hw_asic_id asic_id);
 
-void dce110_destruct_resource_pool(struct resource_pool *pool);
+struct resource_pool *dce110_create_resource_pool(
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct hw_asic_id asic_id);
 
 #endif /* __DC_RESOURCE_DCE110_H__ */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index 0f918a0..a0f5c40 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -240,177 +240,105 @@ static void dce110_stream_encoder_dp_set_stream_attribute(
 
 /* setup stream encoder in hdmi mode */
 static void dce110_stream_encoder_hdmi_set_stream_attribute(
-        struct stream_encoder *enc,
-        struct dc_crtc_timing *crtc_timing,
-        int actual_pix_clk_khz,
-        bool enable_audio)
+	struct stream_encoder *enc,
+	struct dc_crtc_timing *crtc_timing,
+	int actual_pix_clk_khz,
+	bool enable_audio)
 {
-        struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
-        struct dc_context *ctx = enc110->base.ctx;
-        uint32_t value;
-        uint32_t addr;
-        struct bp_encoder_control cntl = {0};
-
-        cntl.action = ENCODER_CONTROL_SETUP;
-        cntl.engine_id = enc110->base.id;
-        cntl.signal = SIGNAL_TYPE_HDMI_TYPE_A;
-        cntl.enable_dp_audio = enable_audio;
-        cntl.pixel_clock = actual_pix_clk_khz;
-        cntl.lanes_number = LANE_COUNT_FOUR;
-
-        if (enc110->base.bp->funcs->encoder_control(
-                        enc110->base.bp, &cntl) != BP_RESULT_OK)
-                return;
-
-        addr = LINK_REG(DIG_FE_CNTL);
-        value = dm_read_reg(ctx, addr);
-
-        switch (crtc_timing->pixel_encoding) {
-        case PIXEL_ENCODING_YCBCR422:
-                set_reg_field_value(value, 1, DIG_FE_CNTL, TMDS_PIXEL_ENCODING);
-                break;
-        default:
-                set_reg_field_value(value, 0, DIG_FE_CNTL, TMDS_PIXEL_ENCODING);
-                break;
-        }
-        set_reg_field_value(value, 0, DIG_FE_CNTL, TMDS_COLOR_FORMAT);
-        dm_write_reg(ctx, addr, value);
-
-        /* setup HDMI engine */
-        addr = LINK_REG(HDMI_CONTROL);
-        value = dm_read_reg(ctx, addr);
-        set_reg_field_value(value, 1, HDMI_CONTROL, HDMI_PACKET_GEN_VERSION);
-        set_reg_field_value(value, 1, HDMI_CONTROL, HDMI_KEEPOUT_MODE);
-        set_reg_field_value(value, 0, HDMI_CONTROL, HDMI_DEEP_COLOR_ENABLE);
-        set_reg_field_value(value, 0, HDMI_CONTROL, HDMI_DATA_SCRAMBLE_EN);
-        set_reg_field_value(value, 0, HDMI_CONTROL, HDMI_CLOCK_CHANNEL_RATE);
-
-        switch (crtc_timing->display_color_depth) {
-        case COLOR_DEPTH_888:
-                set_reg_field_value(
-                        value,
-                        0,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_DEPTH);
-                break;
-        case COLOR_DEPTH_101010:
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_DEPTH);
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_ENABLE);
-                break;
-        case COLOR_DEPTH_121212:
-                set_reg_field_value(
-                        value,
-                        2,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_DEPTH);
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_ENABLE);
-                break;
-        case COLOR_DEPTH_161616:
-                set_reg_field_value(
-                        value,
-                        3,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_DEPTH);
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_DEEP_COLOR_ENABLE);
-                break;
-        default:
-                break;
-        }
-
-        if (actual_pix_clk_khz >= HDMI_CLOCK_CHANNEL_RATE_MORE_340M) {
-                /* enable HDMI data scrambler */
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_DATA_SCRAMBLE_EN);
-
-                /* HDMI_CLOCK_CHANNEL_RATE_MORE_340M
-                 * Clock channel frequency is 1/4 of character rate.*/
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_CLOCK_CHANNEL_RATE);
-        } else if (crtc_timing->flags.LTE_340MCSC_SCRAMBLE) {
-
-                /* TODO: New feature for DCE11, still need to implement */
-
-                /* enable HDMI data scrambler */
-                set_reg_field_value(
-                        value,
-                        1,
-                        HDMI_CONTROL,
-                        HDMI_DATA_SCRAMBLE_EN);
-
-                /* HDMI_CLOCK_CHANNEL_FREQ_EQUAL_TO_CHAR_RATE
-                 * Clock channel frequency is the same
-                 * as character rate */
-                set_reg_field_value(
-                        value,
-                        0,
-                        HDMI_CONTROL,
-                        HDMI_CLOCK_CHANNEL_RATE);
-        }
-
-        dm_write_reg(ctx, addr, value);
-
-        addr = LINK_REG(HDMI_VBI_PACKET_CONTROL);
-        value = dm_read_reg(ctx, addr);
-        set_reg_field_value(value, 1, HDMI_VBI_PACKET_CONTROL, HDMI_GC_CONT);
-        set_reg_field_value(value, 1, HDMI_VBI_PACKET_CONTROL, HDMI_GC_SEND);
-        set_reg_field_value(value, 1, HDMI_VBI_PACKET_CONTROL, HDMI_NULL_SEND);
-
-        dm_write_reg(ctx, addr, value);
-
-        /* following belongs to audio */
-        addr = LINK_REG(HDMI_INFOFRAME_CONTROL0);
-        value = dm_read_reg(ctx, addr);
-        set_reg_field_value(
-                value,
-                1,
-                HDMI_INFOFRAME_CONTROL0,
-                HDMI_AUDIO_INFO_SEND);
-        dm_write_reg(ctx, addr, value);
-
-        addr = LINK_REG(AFMT_INFOFRAME_CONTROL0);
-        value = dm_read_reg(ctx, addr);
-        set_reg_field_value(
-                value,
-                1,
-                AFMT_INFOFRAME_CONTROL0,
-                AFMT_AUDIO_INFO_UPDATE);
-        dm_write_reg(ctx, addr, value);
-
-        addr = LINK_REG(HDMI_INFOFRAME_CONTROL1);
-        value = dm_read_reg(ctx, addr);
-        set_reg_field_value(
-                value,
-                VBI_LINE_0 + 2,
-                HDMI_INFOFRAME_CONTROL1,
-                HDMI_AUDIO_INFO_LINE);
-        dm_write_reg(ctx, addr, value);
-
-        addr = LINK_REG(HDMI_GC);
-        value = dm_read_reg(ctx, addr);
-        set_reg_field_value(value, 0, HDMI_GC, HDMI_GC_AVMUTE);
-        dm_write_reg(ctx, addr, value);
+	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
+	struct dc_context *ctx = enc110->base.ctx;
+	struct bp_encoder_control cntl = {0};
+
+	cntl.action = ENCODER_CONTROL_SETUP;
+	cntl.engine_id = enc110->base.id;
+	cntl.signal = SIGNAL_TYPE_HDMI_TYPE_A;
+	cntl.enable_dp_audio = enable_audio;
+	cntl.pixel_clock = actual_pix_clk_khz;
+	cntl.lanes_number = LANE_COUNT_FOUR;
+
+	if (enc110->base.bp->funcs->encoder_control(
+			enc110->base.bp, &cntl) != BP_RESULT_OK)
+		return;
+
+	switch (crtc_timing->pixel_encoding) {
+	case PIXEL_ENCODING_YCBCR422:
+		REG_UPDATE(DIG_FE_CNTL, TMDS_PIXEL_ENCODING, 1);
+		break;
+	default:
+		REG_UPDATE(DIG_FE_CNTL, TMDS_PIXEL_ENCODING, 0);
+		break;
+	}
+
+	REG_UPDATE(DIG_FE_CNTL, TMDS_COLOR_FORMAT, 0);
+
+	/* setup HDMI engine */
+	REG_UPDATE_5(HDMI_CONTROL,
+		HDMI_PACKET_GEN_VERSION, 1,
+		HDMI_KEEPOUT_MODE, 1,
+		HDMI_DEEP_COLOR_ENABLE, 0,
+		HDMI_DATA_SCRAMBLE_EN, 0,
+		HDMI_CLOCK_CHANNEL_RATE, 0);
+
+	switch (crtc_timing->display_color_depth) {
+	case COLOR_DEPTH_888:
+		REG_UPDATE(HDMI_CONTROL, HDMI_DEEP_COLOR_DEPTH, 0);
+		break;
+	case COLOR_DEPTH_101010:
+		REG_UPDATE_2(HDMI_CONTROL,
+			HDMI_DEEP_COLOR_DEPTH, 1,
+			HDMI_DEEP_COLOR_ENABLE, 1);
+		break;
+	case COLOR_DEPTH_121212:
+		REG_UPDATE_2(HDMI_CONTROL,
+			HDMI_DEEP_COLOR_DEPTH, 2,
+			HDMI_DEEP_COLOR_ENABLE, 1);
+		break;
+	case COLOR_DEPTH_161616:
+		REG_UPDATE_2(HDMI_CONTROL,
+			HDMI_DEEP_COLOR_DEPTH, 3,
+			HDMI_DEEP_COLOR_ENABLE, 1);
+		break;
+	default:
+		break;
+	}
+
+	if (actual_pix_clk_khz >= HDMI_CLOCK_CHANNEL_RATE_MORE_340M) {
+		/* enable HDMI data scrambler
+		 * HDMI_CLOCK_CHANNEL_RATE_MORE_340M
+		 * Clock channel frequency is 1/4 of character rate.
+		 */
+		REG_UPDATE_2(HDMI_CONTROL,
+			HDMI_DATA_SCRAMBLE_EN, 1,
+			HDMI_CLOCK_CHANNEL_RATE, 1);
+	} else if (crtc_timing->flags.LTE_340MCSC_SCRAMBLE) {
+
+		/* TODO: New feature for DCE11, still need to implement */
+
+		/* enable HDMI data scrambler
+		 * HDMI_CLOCK_CHANNEL_FREQ_EQUAL_TO_CHAR_RATE
+		 * Clock channel frequency is the same
+		 * as character rate
+		 */
+		REG_UPDATE_2(HDMI_CONTROL,
+			HDMI_DATA_SCRAMBLE_EN, 1,
+			HDMI_CLOCK_CHANNEL_RATE, 0);
+	}
+
+	REG_UPDATE_3(HDMI_VBI_PACKET_CONTROL,
+		HDMI_GC_CONT, 1,
+		HDMI_GC_SEND, 1,
+		HDMI_NULL_SEND, 1);
+
+	/* following belongs to audio */
+	REG_UPDATE(HDMI_INFOFRAME_CONTROL0, HDMI_AUDIO_INFO_SEND, 1);
+
+	REG_UPDATE(AFMT_INFOFRAME_CONTROL0, AFMT_AUDIO_INFO_UPDATE, 1);
+
+	REG_UPDATE(HDMI_INFOFRAME_CONTROL1, HDMI_AUDIO_INFO_LINE,
+				VBI_LINE_0 + 2);
+
+	REG_UPDATE(HDMI_GC, HDMI_GC_AVMUTE, 0);
+
 }
 
 /* setup stream encoder in dvi mode */
@@ -428,12 +356,13 @@ static void dce110_stream_encoder_dvi_set_stream_attribute(
 	cntl.action = ENCODER_CONTROL_SETUP;
 	cntl.engine_id = enc110->base.id;
 	cntl.signal = is_dual_link ?
-                        SIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;
+			SIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;
 	cntl.enable_dp_audio = false;
 	cntl.pixel_clock = crtc_timing->pix_clk_khz;
-        cntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
+	cntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 
-	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (enc110->base.bp->funcs->encoder_control(
+			enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	switch (crtc_timing->pixel_encoding) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index d894eee..16ec6d9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -144,7 +144,7 @@ bool dce110_timing_generator_enable_crtc(struct timing_generator *tg)
 	value = 0;
 	dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_MASTER_UPDATE_LOCK), value);
 
-	result = dc_bios_enable_crtc(tg->bp, tg110->controller_id, true);
+	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, true);
 
 	return result == BP_RESULT_OK;
 }
@@ -236,7 +236,7 @@ bool dce110_timing_generator_disable_crtc(struct timing_generator *tg)
 
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	result = dc_bios_enable_crtc(tg->bp, tg110->controller_id, false);
+	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, false);
 
 	/* Need to make sure stereo is disabled according to the DCE5.0 spec */
 
@@ -341,7 +341,7 @@ bool dce110_timing_generator_program_timing_generator(
 	if (patched_crtc_timing.flags.HORZ_COUNT_BY_TWO == 1)
 		bp_params.flags.HORZ_COUNT_BY_TWO = 1;
 
-	result = dc_bios_program_crtc_timing(tg->bp, &bp_params);
+	result = tg->bp->funcs->program_crtc_timing(tg->bp, &bp_params);
 
 	program_horz_count_by_2(tg, &patched_crtc_timing);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
index 6fde33a..80aa6df 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
@@ -193,15 +193,15 @@ static bool dce112_program_pix_clk(
 						pll_settings->use_external_clk;
 		bp_pc_params.flags.SET_XTALIN_REF_SRC =
 						!pll_settings->use_external_clk;
- 
-                if (pix_clk_params->flags.SUPPORT_YCBCR420) {
-                        bp_pc_params.target_pixel_clock = pll_settings->actual_pix_clk / 2;
-                        bp_pc_params.flags.SUPPORT_YUV_420 = 1;
-                }
+
+		if (pix_clk_params->flags.SUPPORT_YCBCR420) {
+			bp_pc_params.target_pixel_clock = pll_settings->actual_pix_clk / 2;
+			bp_pc_params.flags.SUPPORT_YUV_420 = 1;
+		}
 
 	}
 
-	if (dc_bios_set_pixel_clock(
+	if (dce112_clk_src->bios->funcs->set_pixel_clock(
 			dce112_clk_src->bios, &bp_pc_params) != BP_RESULT_OK)
 		return false;
 
@@ -233,7 +233,7 @@ bool dce112_clock_source_power_down(
 	bp_pixel_clock_params.flags.FORCE_PROGRAMMING_OF_PLL = 1;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	bp_result = dc_bios_set_pixel_clock(
+	bp_result = dce112_clk_src->bios->funcs->set_pixel_clock(
 			dce112_clk_src->bios,
 			&bp_pixel_clock_params);
 
@@ -264,7 +264,7 @@ bool dce112_clk_src_construct(
 	clk_src->base.funcs = &dce112_clk_src_funcs;
 	clk_src->offsets = *reg_offsets;
 
-	if (dc_bios_get_firmware_info(
+	if (clk_src->bios->funcs->get_firmware_info(
 			clk_src->bios, &fw_info) != BP_RESULT_OK) {
 		ASSERT_CRITICAL(false);
 		goto unexpected_failure;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
index c06f93b..8ec1aae 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
@@ -340,18 +340,19 @@ static bool dce112_enable_display_power_gating(
 	else
 		cntl = ASIC_PIPE_DISABLE;
 
-        if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0){
+	if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0){
 
-		bp_result = dc_bios_enable_disp_power_gating(
+		bp_result = dcb->funcs->enable_disp_power_gating(
 						dcb, controller_id + 1, cntl);
-                /* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
-                 * by default when command table is called
-                 */
-                dm_write_reg(ctx,
-                        HW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),
-                        0);
-        }
- 
+
+		/* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
+		 * by default when command table is called
+		 */
+		dm_write_reg(ctx,
+			HW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),
+			0);
+	}
+
 	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
 		dce112_init_pte(ctx);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 4dad5be..13c323f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -551,63 +551,63 @@ void dce112_clock_source_destroy(struct clock_source **clk_src)
 
 static void destruct(struct dce110_resource_pool *pool)
 {
-        unsigned int i;
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce112_opp_destroy(&pool->base.opps[i]);
-
-                if (pool->base.transforms[i] != NULL)
-                        dce112_transform_destroy(&pool->base.transforms[i]);
-
-                if (pool->base.ipps[i] != NULL)
-                        dce112_ipp_destroy(&pool->base.ipps[i]);
-
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
-
-                if (pool->base.timing_generators[i] != NULL) {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
-
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL) {
-                        dce112_clock_source_destroy(&pool->base.clock_sources[i]);
-                }
-        }
-
-        if (pool->base.dp_clock_source != NULL)
-                dce112_clock_source_destroy(&pool->base.dp_clock_source);
-
-        for (i = 0; i < pool->base.audio_count; i++)    {
-                if (pool->base.audios[i] != NULL) {
-                        dce110_aud_destroy(&pool->base.audios[i]);
-                }
-        }
-
-        if (pool->base.display_clock != NULL) {
-                dal_display_clock_destroy(&pool->base.display_clock);
-        }
-
-        if (pool->base.scaler_filter != NULL) {
-                dal_scaler_filter_destroy(&pool->base.scaler_filter);
-        }
-        if (pool->base.irqs != NULL) {
-                dal_irq_service_destroy(&pool->base.irqs);
-        }
-
-        if (pool->base.adapter_srv != NULL) {
-                dal_adapter_service_destroy(&pool->base.adapter_srv);
-        }
+	unsigned int i;
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce112_opp_destroy(&pool->base.opps[i]);
+
+		if (pool->base.transforms[i] != NULL)
+			dce112_transform_destroy(&pool->base.transforms[i]);
+
+		if (pool->base.ipps[i] != NULL)
+			dce112_ipp_destroy(&pool->base.ipps[i]);
+
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
+
+		if (pool->base.timing_generators[i] != NULL) {
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL) {
+			dce112_clock_source_destroy(&pool->base.clock_sources[i]);
+		}
+	}
+
+	if (pool->base.dp_clock_source != NULL)
+		dce112_clock_source_destroy(&pool->base.dp_clock_source);
+
+	for (i = 0; i < pool->base.audio_count; i++)	{
+		if (pool->base.audios[i] != NULL) {
+			dce110_aud_destroy(&pool->base.audios[i]);
+		}
+	}
+
+	if (pool->base.display_clock != NULL) {
+		dal_display_clock_destroy(&pool->base.display_clock);
+	}
+
+	if (pool->base.scaler_filter != NULL) {
+		dal_scaler_filter_destroy(&pool->base.scaler_filter);
+	}
+	if (pool->base.irqs != NULL) {
+		dal_irq_service_destroy(&pool->base.irqs);
+	}
+
+	if (pool->base.adapter_srv != NULL) {
+		dal_adapter_service_destroy(&pool->base.adapter_srv);
+	}
 }
 
 static struct clock_source *find_matching_pll(struct resource_context *res_ctx,
@@ -615,17 +615,17 @@ static struct clock_source *find_matching_pll(struct resource_context *res_ctx,
 {
 	switch (stream->sink->link->link_enc->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
-		return res_ctx->pool.clock_sources[DCE112_CLK_SRC_PLL0];
+		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL0];
 	case TRANSMITTER_UNIPHY_B:
-		return res_ctx->pool.clock_sources[DCE112_CLK_SRC_PLL1];
+		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL1];
 	case TRANSMITTER_UNIPHY_C:
-		return res_ctx->pool.clock_sources[DCE112_CLK_SRC_PLL2];
+		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL2];
 	case TRANSMITTER_UNIPHY_D:
-		return res_ctx->pool.clock_sources[DCE112_CLK_SRC_PLL3];
+		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL3];
 	case TRANSMITTER_UNIPHY_E:
-		return res_ctx->pool.clock_sources[DCE112_CLK_SRC_PLL4];
+		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL4];
 	case TRANSMITTER_UNIPHY_F:
-		return res_ctx->pool.clock_sources[DCE112_CLK_SRC_PLL5];
+		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL5];
 	default:
 		return NULL;
 	};
@@ -804,7 +804,7 @@ static enum dc_status map_clock_resources(
 				if (dc_is_dp_signal(pipe_ctx->stream->signal)
 					|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
 					pipe_ctx->clock_source =
-						context->res_ctx.pool.dp_clock_source;
+						context->res_ctx.pool->dp_clock_source;
 				else
 					pipe_ctx->clock_source =
 							find_matching_pll(&context->res_ctx,
@@ -929,8 +929,17 @@ enum dc_status dce112_validate_guaranteed(
 	return result;
 }
 
+static void dce112_destroy_resource_pool(struct resource_pool **pool)
+{
+	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
+
+	destruct(dce110_pool);
+	dm_free(dce110_pool);
+	*pool = NULL;
+}
+
 static const struct resource_funcs dce112_res_pool_funcs = {
-	.destruct = dce112_destruct_resource_pool,
+	.destroy = dce112_destroy_resource_pool,
 	.link_enc_create = dce112_link_encoder_create,
 	.validate_with_context = dce112_validate_with_context,
 	.validate_guaranteed = dce112_validate_guaranteed,
@@ -980,282 +989,283 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 		1000);
 }
 
+
 static bool construct(
-        struct adapter_service *adapter_serv,
-        uint8_t num_virtual_links,
-        struct core_dc *dc,
-        struct dce110_resource_pool *pool)
+	struct adapter_service *adapter_serv,
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool)
 {
-        unsigned int i;
-        struct dc_context *ctx = dc->ctx;
-
-        pool->base.adapter_srv = adapter_serv;
-        pool->base.funcs = &dce112_res_pool_funcs;
-
-        /*************************************************
-         *  Resource + asic cap harcoding                *
-         *************************************************/
-        pool->base.underlay_pipe_index = -1;
-        pool->base.pipe_count =
-                dal_adapter_service_get_func_controllers_num(adapter_serv);
-        pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(adapter_serv);
-        dc->public.caps.max_downscale_ratio = 200;
-        dc->public.caps.i2c_speed_in_khz = 100;
-
-        /*************************************************
-         *  Create resources                             *
-         *************************************************/
-
-        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-        pool->base.clock_sources[DCE112_CLK_SRC_PLL0] = dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0]);
-        pool->base.clock_sources[DCE112_CLK_SRC_PLL1] = dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1]);
-        pool->base.clock_sources[DCE112_CLK_SRC_PLL2] = dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2]);
-        pool->base.clock_sources[DCE112_CLK_SRC_PLL3] = dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3]);
-        pool->base.clock_sources[DCE112_CLK_SRC_PLL4] = dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4]);
-        pool->base.clock_sources[DCE112_CLK_SRC_PLL5] = dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5]);
-        pool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;
-
-        pool->base.dp_clock_source =  dce112_clock_source_create(
-                ctx, dal_adapter_service_get_bios_parser(adapter_serv),
-                CLOCK_SOURCE_ID_DP_DTO, &dce112_clk_src_reg_offsets[0]);
-
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] == NULL) {
-                        dm_error("DC: failed to create clock sources!\n");
-                        BREAK_TO_DEBUGGER();
-                        goto clk_src_create_fail;
-                }
-        }
-
-        pool->base.display_clock = dal_display_clock_dce112_create(ctx, adapter_serv);
-        if (pool->base.display_clock == NULL) {
-                dm_error("DC: failed to create display clock!\n");
-                BREAK_TO_DEBUGGER();
-                goto disp_clk_create_fail;
-        }
-
-        {
-                struct irq_service_init_data init_data;
-                init_data.ctx = dc->ctx;
-                pool->base.irqs = dal_irq_service_create(
-                                dal_adapter_service_get_dce_version(
-                                        pool->base.adapter_srv),
-                                &init_data);
-                if (!pool->base.irqs)
-                        goto irqs_create_fail;
-
-        }
-
-        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
-        if (pool->base.scaler_filter == NULL) {
-                BREAK_TO_DEBUGGER();
-                dm_error("DC: failed to create filter!\n");
-                goto filter_create_fail;
-        }
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                pool->base.timing_generators[i] = dce112_timing_generator_create(
-                                adapter_serv,
-                                ctx,
-                                i,
-                                &dce112_tg_offsets[i]);
-                if (pool->base.timing_generators[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create tg!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.mis[i] = dce112_mem_input_create(
-                        ctx,
-                        adapter_serv,
-                        i,
-                        &dce112_mi_reg_offsets[i]);
-                if (pool->base.mis[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create memory input!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.ipps[i] = dce112_ipp_create(
-                        ctx,
-                        i,
-                        &ipp_reg_offsets[i]);
-                if (pool->base.ipps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create input pixel processor!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.transforms[i] = dce112_transform_create(
-                                ctx,
-                                i,
-                                &dce112_xfm_offsets[i]);
-                if (pool->base.transforms[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create transform!\n");
-                        goto controller_create_fail;
-                }
-                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
-                                pool->base.transforms[i],
-                                pool->base.scaler_filter);
-
-                pool->base.opps[i] = dce112_opp_create(
-                        ctx,
-                        i,
-                        &dce112_opp_reg_offsets[i]);
-                if (pool->base.opps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error(
-                                "DC: failed to create output pixel processor!\n");
-                        goto controller_create_fail;
-                }
-        }
-
-        pool->base.audio_count = 0;
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                struct graphics_object_id obj_id;
-
-                obj_id = dal_adapter_service_enum_audio_object(adapter_serv, i);
-                if (false == dal_graphics_object_id_is_valid(obj_id)) {
-                        /* no more valid audio objects */
-                        break;
-                }
-
-                pool->base.audios[i] = dce110_audio_create(
-                                ctx, i, &audio_regs[i]);
-                if (pool->base.audios[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create audio!\n");
-                        goto audio_create_fail;
-                }
-                pool->base.audio_count++;
-        }
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                /* TODO: rework fragile code*/
-                if (pool->base.stream_engines.u_all & 1 << i) {
-                        pool->base.stream_enc[i] = dce112_stream_encoder_create(
-                                i, dc->ctx,
-                                dal_adapter_service_get_bios_parser(
-                                        adapter_serv),
-                                &stream_enc_regs[i]);
-                        if (pool->base.stream_enc[i] == NULL) {
-                                BREAK_TO_DEBUGGER();
-                                dm_error("DC: failed to create stream_encoder!\n");
-                                goto stream_enc_create_fail;
-                        }
-                }
-        }
-
-        for (i = 0; i < num_virtual_links; i++) {
-                pool->base.stream_enc[pool->base.stream_enc_count] =
-                        virtual_stream_encoder_create(
-                                dc->ctx, dal_adapter_service_get_bios_parser(
-                                                                adapter_serv));
-                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create stream_encoder!\n");
-                        goto stream_enc_create_fail;
-                }
-                pool->base.stream_enc_count++;
-        }
-
-        /* Create hardware sequencer */
-        if (!dce112_hw_sequencer_construct(dc))
-                goto stream_enc_create_fail;
-
-        bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_BAFFIN);
-
-        bw_calcs_data_update_from_pplib(dc);
-
-        return true;
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+
+	pool->base.adapter_srv = adapter_serv;
+	pool->base.funcs = &dce112_res_pool_funcs;
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+	pool->base.underlay_pipe_index = -1;
+	pool->base.pipe_count =
+		dal_adapter_service_get_func_controllers_num(adapter_serv);
+	pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(adapter_serv);
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 100;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+	pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL0] = dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_COMBO_PHY_PLL0, &dce112_clk_src_reg_offsets[0]);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL1] = dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_COMBO_PHY_PLL1, &dce112_clk_src_reg_offsets[1]);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL2] = dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_COMBO_PHY_PLL2, &dce112_clk_src_reg_offsets[2]);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL3] = dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_COMBO_PHY_PLL3, &dce112_clk_src_reg_offsets[3]);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL4] = dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_COMBO_PHY_PLL4, &dce112_clk_src_reg_offsets[4]);
+	pool->base.clock_sources[DCE112_CLK_SRC_PLL5] = dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_COMBO_PHY_PLL5, &dce112_clk_src_reg_offsets[5]);
+	pool->base.clk_src_count = DCE112_CLK_SRC_TOTAL;
+
+	pool->base.dp_clock_source =  dce112_clock_source_create(
+		ctx, dal_adapter_service_get_bios_parser(adapter_serv),
+		CLOCK_SOURCE_ID_DP_DTO, &dce112_clk_src_reg_offsets[0]);
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto clk_src_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dal_display_clock_dce112_create(ctx, adapter_serv);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto disp_clk_create_fail;
+	}
+
+	{
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_create(
+				dal_adapter_service_get_dce_version(
+					pool->base.adapter_srv),
+				&init_data);
+		if (!pool->base.irqs)
+			goto irqs_create_fail;
+
+	}
+
+	pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+	if (pool->base.scaler_filter == NULL) {
+		BREAK_TO_DEBUGGER();
+		dm_error("DC: failed to create filter!\n");
+		goto filter_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] = dce112_timing_generator_create(
+				adapter_serv,
+				ctx,
+				i,
+				&dce112_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.mis[i] = dce112_mem_input_create(
+			ctx,
+			adapter_serv,
+			i,
+			&dce112_mi_reg_offsets[i]);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create memory input!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.ipps[i] = dce112_ipp_create(
+			ctx,
+			i,
+			&ipp_reg_offsets[i]);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create input pixel processor!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.transforms[i] = dce112_transform_create(
+				ctx,
+				i,
+				&dce112_xfm_offsets[i]);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create transform!\n");
+			goto controller_create_fail;
+		}
+		pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+				pool->base.transforms[i],
+				pool->base.scaler_filter);
+
+		pool->base.opps[i] = dce112_opp_create(
+			ctx,
+			i,
+			&dce112_opp_reg_offsets[i]);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create output pixel processor!\n");
+			goto controller_create_fail;
+		}
+	}
+
+	pool->base.audio_count = 0;
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		struct graphics_object_id obj_id;
+
+		obj_id = dal_adapter_service_enum_audio_object(adapter_serv, i);
+		if (false == dal_graphics_object_id_is_valid(obj_id)) {
+			/* no more valid audio objects */
+			break;
+		}
+
+		pool->base.audios[i] = dce110_audio_create(
+				ctx, i, &audio_regs[i]);
+
+		if (pool->base.audios[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create audio!\n");
+			goto audio_create_fail;
+		}
+		pool->base.audio_count++;
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		/* TODO: rework fragile code*/
+		if (pool->base.stream_engines.u_all & 1 << i) {
+			pool->base.stream_enc[i] = dce112_stream_encoder_create(
+				i, dc->ctx,
+				dal_adapter_service_get_bios_parser(
+					adapter_serv),
+				&stream_enc_regs[i]);
+			if (pool->base.stream_enc[i] == NULL) {
+				BREAK_TO_DEBUGGER();
+				dm_error("DC: failed to create stream_encoder!\n");
+				goto stream_enc_create_fail;
+			}
+		}
+	}
+
+	for (i = 0; i < num_virtual_links; i++) {
+		pool->base.stream_enc[pool->base.stream_enc_count] =
+			virtual_stream_encoder_create(
+				dc->ctx, dal_adapter_service_get_bios_parser(
+								adapter_serv));
+		if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create stream_encoder!\n");
+			goto stream_enc_create_fail;
+		}
+		pool->base.stream_enc_count++;
+	}
+
+	/* Create hardware sequencer */
+	if (!dce112_hw_sequencer_construct(dc))
+		goto stream_enc_create_fail;
+
+	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_BAFFIN);
+
+	bw_calcs_data_update_from_pplib(dc);
+
+	return true;
 
 stream_enc_create_fail:
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
 
 audio_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.audios[i] != NULL)
-                        dce110_aud_destroy(&pool->base.audios[i]);
-        }
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.audios[i] != NULL)
+			dce110_aud_destroy(&pool->base.audios[i]);
+	}
 
 controller_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce112_opp_destroy(&pool->base.opps[i]);
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce112_opp_destroy(&pool->base.opps[i]);
 
-                if (pool->base.transforms[i] != NULL)
-                        dce112_transform_destroy(&pool->base.transforms[i]);
+		if (pool->base.transforms[i] != NULL)
+			dce112_transform_destroy(&pool->base.transforms[i]);
 
-                if (pool->base.ipps[i] != NULL)
-                        dce112_ipp_destroy(&pool->base.ipps[i]);
+		if (pool->base.ipps[i] != NULL)
+			dce112_ipp_destroy(&pool->base.ipps[i]);
 
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
 
-                if (pool->base.timing_generators[i] != NULL) {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
+		if (pool->base.timing_generators[i] != NULL) {
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
 
 filter_create_fail:
-        dal_irq_service_destroy(&pool->base.irqs);
+	dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-        dal_display_clock_destroy(&pool->base.display_clock);
+	dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL)
-                        dce112_clock_source_destroy(&pool->base.clock_sources[i]);
-        }
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL)
+			dce112_clock_source_destroy(&pool->base.clock_sources[i]);
+	}
 
-        return false;
+	return false;
 }
 
 struct resource_pool *dce112_create_resource_pool(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc)
 {
-        struct dce110_resource_pool *pool =
-                dm_alloc(sizeof(struct dce110_resource_pool));
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
 
-        if (!pool)
-                return NULL;
+	if (!pool)
+		return NULL;
 
-        if (construct(as, num_virtual_links, dc, pool))
-                return &pool->base;
+	if (construct(as, num_virtual_links, dc, pool))
+		return &pool->base;
 
-        BREAK_TO_DEBUGGER();
-        return NULL;
+	BREAK_TO_DEBUGGER();
+	return NULL;
 }
-
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.h b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.h
index eed1faf..324b3d7 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.h
@@ -32,11 +32,10 @@ struct adapter_service;
 struct core_dc;
 struct resource_pool;
 
-bool dce112_construct_resource_pool(
-	struct adapter_service *adapter_serv,
+struct resource_pool *dce112_create_resource_pool(
+	struct adapter_service *as,
 	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool);
+	struct core_dc *dc);
 
 #endif /* __DC_RESOURCE_DCE112_H__ */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
index 29ac95f..2841e3b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
@@ -197,18 +197,19 @@ static bool dce80_enable_display_power_gating(
 	else
 		cntl = ASIC_PIPE_DISABLE;
 
-        if (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0)){
+	if (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0)){
 
-		bp_result = dc_bios_enable_disp_power_gating(
+		bp_result = dcb->funcs->enable_disp_power_gating(
 						dcb, controller_id + 1, cntl);
-                /* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
-                 * by default when command table is called
-                 */
-                dm_write_reg(ctx,
-                        HW_REG_CRTC(mmMASTER_UPDATE_MODE, controller_id),
-                        0);
-        }
- 
+
+		/* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
+		 * by default when command table is called
+		 */
+		dm_write_reg(ctx,
+			HW_REG_CRTC(mmMASTER_UPDATE_MODE, controller_id),
+			0);
+	}
+
 	if (bp_result == BP_RESULT_OK)
 		return true;
 	else
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
index 9667842..79e859e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
@@ -82,7 +82,7 @@ static enum bp_result link_transmitter_control(
 	struct dc_bios *bp = dal_adapter_service_get_bios_parser(
 					enc110->base.adapter_service);
 
-	result = dc_bios_transmitter_control(bp, cntl);
+	result = bp->funcs->transmitter_control(bp, cntl);
 
 	return result;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index e2819a3..483b4c4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -468,63 +468,63 @@ void dce80_clock_source_destroy(struct clock_source **clk_src)
 
 static void destruct(struct dce110_resource_pool *pool)
 {
-        unsigned int i;
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce80_opp_destroy(&pool->base.opps[i]);
-
-                if (pool->base.transforms[i] != NULL)
-                        dce80_transform_destroy(&pool->base.transforms[i]);
-
-                if (pool->base.ipps[i] != NULL)
-                        dce80_ipp_destroy(&pool->base.ipps[i]);
-
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
-
-                if (pool->base.timing_generators[i] != NULL)    {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
-
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL) {
-                        dce80_clock_source_destroy(&pool->base.clock_sources[i]);
-                }
-        }
-
-        if (pool->base.dp_clock_source != NULL)
-                dce80_clock_source_destroy(&pool->base.dp_clock_source);
-
-        for (i = 0; i < pool->base.audio_count; i++)    {
-                if (pool->base.audios[i] != NULL) {
-                        dce110_aud_destroy(&pool->base.audios[i]);
-                }
-        }
-
-        if (pool->base.display_clock != NULL) {
-                dal_display_clock_destroy(&pool->base.display_clock);
-        }
-
-        if (pool->base.scaler_filter != NULL) {
-                dal_scaler_filter_destroy(&pool->base.scaler_filter);
-        }
-        if (pool->base.irqs != NULL) {
-                dal_irq_service_destroy(&pool->base.irqs);
-        }
-
-        if (pool->base.adapter_srv != NULL) {
-                dal_adapter_service_destroy(&pool->base.adapter_srv);
-        }
+	unsigned int i;
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce80_opp_destroy(&pool->base.opps[i]);
+
+		if (pool->base.transforms[i] != NULL)
+			dce80_transform_destroy(&pool->base.transforms[i]);
+
+		if (pool->base.ipps[i] != NULL)
+			dce80_ipp_destroy(&pool->base.ipps[i]);
+
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
+
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL) {
+			dce80_clock_source_destroy(&pool->base.clock_sources[i]);
+		}
+	}
+
+	if (pool->base.dp_clock_source != NULL)
+		dce80_clock_source_destroy(&pool->base.dp_clock_source);
+
+	for (i = 0; i < pool->base.audio_count; i++)	{
+		if (pool->base.audios[i] != NULL) {
+			dce110_aud_destroy(&pool->base.audios[i]);
+		}
+	}
+
+	if (pool->base.display_clock != NULL) {
+		dal_display_clock_destroy(&pool->base.display_clock);
+	}
+
+	if (pool->base.scaler_filter != NULL) {
+		dal_scaler_filter_destroy(&pool->base.scaler_filter);
+	}
+	if (pool->base.irqs != NULL) {
+		dal_irq_service_destroy(&pool->base.irqs);
+	}
+
+	if (pool->base.adapter_srv != NULL) {
+		dal_adapter_service_destroy(&pool->base.adapter_srv);
+	}
 }
 
 static enum dc_status validate_mapped_resource(
@@ -699,8 +699,17 @@ enum dc_status dce80_validate_guaranteed(
 	return result;
 }
 
+static void dce80_destroy_resource_pool(struct resource_pool **pool)
+{
+	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
+
+	destruct(dce110_pool);
+	dm_free(dce110_pool);
+	*pool = NULL;
+}
+
 static const struct resource_funcs dce80_res_pool_funcs = {
-	.destruct = dce80_destruct_resource_pool,
+	.destroy = dce80_destroy_resource_pool,
 	.link_enc_create = dce80_link_encoder_create,
 	.validate_with_context = dce80_validate_with_context,
 	.validate_guaranteed = dce80_validate_guaranteed,
@@ -708,267 +717,268 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 };
 
 static bool construct(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc,
-        struct dce110_resource_pool *pool)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool)
 {
-        unsigned int i;
-        struct dc_context *ctx = dc->ctx;
-        struct firmware_info info;
-        struct dc_bios *bp;
-
-        pool->base.adapter_srv = as;
-        pool->base.funcs = &dce80_res_pool_funcs;
-
-
-        /*************************************************
-         *  Resource + asic cap harcoding                *
-         *************************************************/
-        pool->base.underlay_pipe_index = -1;
-        pool->base.pipe_count = dal_adapter_service_get_func_controllers_num(as);
-        pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
-        dc->public.caps.max_downscale_ratio = 200;
-        dc->public.caps.i2c_speed_in_khz = 40;
-
-        /*************************************************
-         *  Create resources                             *
-         *************************************************/
-
-        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
-        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
-
-        bp = dal_adapter_service_get_bios_parser(as);
-
-        if (dal_adapter_service_get_firmware_info(as, &info) &&
-                info.external_clock_source_frequency_for_dp != 0) {
-                pool->base.dp_clock_source =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
-
-                pool->base.clock_sources[0] =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
-                pool->base.clock_sources[1] =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
-                pool->base.clock_sources[2] =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
-                pool->base.clk_src_count = 3;
-
-        } else {
-                pool->base.dp_clock_source =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
-                pool->base.clock_sources[0] =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
-                pool->base.clock_sources[1] =
-                                dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
-                pool->base.clk_src_count = 2;
-        }
-
-        if (pool->base.dp_clock_source == NULL) {
-                dm_error("DC: failed to create dp clock source!\n");
-                BREAK_TO_DEBUGGER();
-                goto clk_src_create_fail;
-        }
-
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] == NULL) {
-                        dm_error("DC: failed to create clock sources!\n");
-                        BREAK_TO_DEBUGGER();
-                        goto clk_src_create_fail;
-                }
-        }
-
-        pool->base.display_clock = dal_display_clock_dce80_create(ctx, as);
-        if (pool->base.display_clock == NULL) {
-                dm_error("DC: failed to create display clock!\n");
-                BREAK_TO_DEBUGGER();
-                goto disp_clk_create_fail;
-        }
-
-        {
-                struct irq_service_init_data init_data;
-                init_data.ctx = dc->ctx;
-                pool->base.irqs = dal_irq_service_create(
-                                dal_adapter_service_get_dce_version(
-                                        pool->base.adapter_srv),
-                                &init_data);
-                if (!pool->base.irqs)
-                        goto irqs_create_fail;
-
-        }
-
-        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
-        if (pool->base.scaler_filter == NULL) {
-                BREAK_TO_DEBUGGER();
-                dm_error("DC: failed to create filter!\n");
-                goto filter_create_fail;
-        }
-
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                pool->base.timing_generators[i] = dce80_timing_generator_create(
-                                as, ctx, i, &dce80_tg_offsets[i]);
-                if (pool->base.timing_generators[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create tg!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.mis[i] = dce80_mem_input_create(ctx, as, i,
-                                &dce80_mi_reg_offsets[i]);
-                if (pool->base.mis[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create memory input!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.ipps[i] = dce80_ipp_create(ctx, i, &ipp_reg_offsets[i]);
-                if (pool->base.ipps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create input pixel processor!\n");
-                        goto controller_create_fail;
-                }
-
-                pool->base.transforms[i] = dce80_transform_create(
-                                                ctx, i, &dce80_xfm_offsets[i]);
-                if (pool->base.transforms[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create transform!\n");
-                        goto controller_create_fail;
-                }
-                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
-                                pool->base.transforms[i],
-                                pool->base.scaler_filter);
-
-                pool->base.opps[i] = dce80_opp_create(ctx, i);
-                if (pool->base.opps[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create output pixel processor!\n");
-                        goto controller_create_fail;
-                }
-        }
-
-        pool->base.audio_count = 0;
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                struct graphics_object_id obj_id;
-
-                obj_id = dal_adapter_service_enum_audio_object(as, i);
-                if (false == dal_graphics_object_id_is_valid(obj_id)) {
-                        /* no more valid audio objects */
-                        break;
-                }
-
-                pool->base.audios[i] = dce110_audio_create(
-                                ctx, i, &audio_regs[i]);
-                if (pool->base.audios[i] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create audio!\n");
-                        goto audio_create_fail;
-                }
-                pool->base.audio_count++;
-        }
-
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_engines.u_all & 1 << i) {
-                        pool->base.stream_enc[i] = dce80_stream_encoder_create(
-                                        i, dc->ctx,
-                                        dal_adapter_service_get_bios_parser(
-                                                as),
-                                        &stream_enc_regs[i]);
-
-                        if (pool->base.stream_enc[i] == NULL) {
-                                BREAK_TO_DEBUGGER();
-                                dm_error("DC: failed to create stream_encoder!\n");
-                                goto stream_enc_create_fail;
-                        }
-                }
-        }
-
-        for (i = 0; i < num_virtual_links; i++) {
-                pool->base.stream_enc[pool->base.stream_enc_count] =
-                        virtual_stream_encoder_create(
-                                dc->ctx, dal_adapter_service_get_bios_parser(
-                                                                as));
-                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
-                        BREAK_TO_DEBUGGER();
-                        dm_error("DC: failed to create stream_encoder!\n");
-                        goto stream_enc_create_fail;
-                }
-                pool->base.stream_enc_count++;
-        }
-
-        /* Create hardware sequencer */
-        if (!dce80_hw_sequencer_construct(dc))
-                goto stream_enc_create_fail;
-
-        return true;
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+	struct firmware_info info;
+	struct dc_bios *bp;
+
+	pool->base.adapter_srv = as;
+	pool->base.funcs = &dce80_res_pool_funcs;
+
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+	pool->base.underlay_pipe_index = -1;
+	pool->base.pipe_count = dal_adapter_service_get_func_controllers_num(as);
+	pool->base.stream_enc_count = dal_adapter_service_get_stream_engines_num(as);
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+	pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+	pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
+
+	bp = dal_adapter_service_get_bios_parser(as);
+
+	if (dal_adapter_service_get_firmware_info(as, &info) &&
+		info.external_clock_source_frequency_for_dp != 0) {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
+		pool->base.clock_sources[2] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
+		pool->base.clk_src_count = 3;
+
+	} else {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce80_clk_src_reg_offsets[0]);
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce80_clk_src_reg_offsets[1]);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &dce80_clk_src_reg_offsets[2]);
+		pool->base.clk_src_count = 2;
+	}
+
+	if (pool->base.dp_clock_source == NULL) {
+		dm_error("DC: failed to create dp clock source!\n");
+		BREAK_TO_DEBUGGER();
+		goto clk_src_create_fail;
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto clk_src_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dal_display_clock_dce80_create(ctx, as);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto disp_clk_create_fail;
+	}
+
+	{
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_create(
+				dal_adapter_service_get_dce_version(
+					pool->base.adapter_srv),
+				&init_data);
+		if (!pool->base.irqs)
+			goto irqs_create_fail;
+
+	}
+
+	pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+	if (pool->base.scaler_filter == NULL) {
+		BREAK_TO_DEBUGGER();
+		dm_error("DC: failed to create filter!\n");
+		goto filter_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] = dce80_timing_generator_create(
+				as, ctx, i, &dce80_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.mis[i] = dce80_mem_input_create(ctx, as, i,
+				&dce80_mi_reg_offsets[i]);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create memory input!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.ipps[i] = dce80_ipp_create(ctx, i, &ipp_reg_offsets[i]);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create input pixel processor!\n");
+			goto controller_create_fail;
+		}
+
+		pool->base.transforms[i] = dce80_transform_create(
+						ctx, i, &dce80_xfm_offsets[i]);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create transform!\n");
+			goto controller_create_fail;
+		}
+		pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+				pool->base.transforms[i],
+				pool->base.scaler_filter);
+
+		pool->base.opps[i] = dce80_opp_create(ctx, i);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create output pixel processor!\n");
+			goto controller_create_fail;
+		}
+	}
+
+	pool->base.audio_count = 0;
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		struct graphics_object_id obj_id;
+
+		obj_id = dal_adapter_service_enum_audio_object(as, i);
+		if (false == dal_graphics_object_id_is_valid(obj_id)) {
+			/* no more valid audio objects */
+			break;
+		}
+
+		pool->base.audios[i] = dce110_audio_create(
+				ctx, i, &audio_regs[i]);
+
+		if (pool->base.audios[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create audio!\n");
+			goto audio_create_fail;
+		}
+		pool->base.audio_count++;
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_engines.u_all & 1 << i) {
+			pool->base.stream_enc[i] = dce80_stream_encoder_create(
+					i, dc->ctx,
+					dal_adapter_service_get_bios_parser(
+						as),
+					&stream_enc_regs[i]);
+
+			if (pool->base.stream_enc[i] == NULL) {
+				BREAK_TO_DEBUGGER();
+				dm_error("DC: failed to create stream_encoder!\n");
+				goto stream_enc_create_fail;
+			}
+		}
+	}
+
+	for (i = 0; i < num_virtual_links; i++) {
+		pool->base.stream_enc[pool->base.stream_enc_count] =
+			virtual_stream_encoder_create(
+				dc->ctx, dal_adapter_service_get_bios_parser(
+								as));
+		if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create stream_encoder!\n");
+			goto stream_enc_create_fail;
+		}
+		pool->base.stream_enc_count++;
+	}
+
+	/* Create hardware sequencer */
+	if (!dce80_hw_sequencer_construct(dc))
+		goto stream_enc_create_fail;
+
+	return true;
 
 stream_enc_create_fail:
-        for (i = 0; i < pool->base.stream_enc_count; i++) {
-                if (pool->base.stream_enc[i] != NULL)
-                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
-        }
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
 
 audio_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.audios[i] != NULL)
-                        dce110_aud_destroy(&pool->base.audios[i]);
-        }
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.audios[i] != NULL)
+			dce110_aud_destroy(&pool->base.audios[i]);
+	}
 
 controller_create_fail:
-        for (i = 0; i < pool->base.pipe_count; i++) {
-                if (pool->base.opps[i] != NULL)
-                        dce80_opp_destroy(&pool->base.opps[i]);
-
-                if (pool->base.transforms[i] != NULL)
-                        dce80_transform_destroy(&pool->base.transforms[i]);
-
-                if (pool->base.ipps[i] != NULL)
-                        dce80_ipp_destroy(&pool->base.ipps[i]);
-
-                if (pool->base.mis[i] != NULL) {
-                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
-                        pool->base.mis[i] = NULL;
-                }
-                if (pool->base.timing_generators[i] != NULL)    {
-                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
-                        pool->base.timing_generators[i] = NULL;
-                }
-        }
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce80_opp_destroy(&pool->base.opps[i]);
+
+		if (pool->base.transforms[i] != NULL)
+			dce80_transform_destroy(&pool->base.transforms[i]);
+
+		if (pool->base.ipps[i] != NULL)
+			dce80_ipp_destroy(&pool->base.ipps[i]);
+
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
 
 filter_create_fail:
-        dal_irq_service_destroy(&pool->base.irqs);
+	dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-        dal_display_clock_destroy(&pool->base.display_clock);
+	dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-        for (i = 0; i < pool->base.clk_src_count; i++) {
-                if (pool->base.clock_sources[i] != NULL)
-                        dce80_clock_source_destroy(&pool->base.clock_sources[i]);
-        }
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL)
+			dce80_clock_source_destroy(&pool->base.clock_sources[i]);
+	}
 
-        return false;
+	return false;
 }
 
 struct resource_pool *dce80_create_resource_pool(
-        struct adapter_service *as,
-        uint8_t num_virtual_links,
-        struct core_dc *dc)
+	struct adapter_service *as,
+	uint8_t num_virtual_links,
+	struct core_dc *dc)
 {
-        struct dce110_resource_pool *pool =
-                dm_alloc(sizeof(struct dce110_resource_pool));
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
 
-        if (!pool)
-                return NULL;
+	if (!pool)
+		return NULL;
 
-        if (construct(as, num_virtual_links, dc, pool))
-                return &pool->base;
+	if (construct(as, num_virtual_links, dc, pool))
+		return &pool->base;
 
-        BREAK_TO_DEBUGGER();
-        return NULL;
+	BREAK_TO_DEBUGGER();
+	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.h
index ef3c819..46b0f1d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.h
@@ -32,11 +32,10 @@ struct adapter_service;
 struct core_dc;
 struct resource_pool;
 
-bool dce80_construct_resource_pool(
-	struct adapter_service *adapter_serv,
+struct resource_pool *dce80_create_resource_pool(
+	struct adapter_service *as,
 	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool);
+	struct core_dc *dc);
 
 #endif /* __DC_RESOURCE_DCE80_H__ */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
index 301c9c1..869f1ea 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
@@ -383,7 +383,8 @@ static void dce80_stream_encoder_hdmi_set_stream_attribute(
 	cntl.lanes_number = LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (enc110->base.bp->funcs->encoder_control(
+			enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	switch (crtc_timing->pixel_encoding) {
@@ -515,9 +516,10 @@ static void dce80_stream_encoder_dvi_set_stream_attribute(
 			SIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;
 	cntl.enable_dp_audio = false;
 	cntl.pixel_clock = crtc_timing->pix_clk_khz;
-        cntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
+	cntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 
-	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (enc110->base.bp->funcs->encoder_control(
+			enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	switch (crtc_timing->pixel_encoding) {
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index dfe875d..a1a00ee 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -847,7 +847,7 @@ static void set_clock(
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = base->id;
 
-	dc_bios_program_display_engine_pll(bp, &pxl_clk_params);
+	bp->funcs->program_display_engine_pll(bp, &pxl_clk_params);
 
 	if (dc->dfs_bypass_enabled) {
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
index 0072fdd..faaeac9 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
@@ -769,7 +769,7 @@ void dispclk_dce112_set_clock(
 	dce_clk_params.pll_id = dc->disp_clk_base.id;
 	dce_clk_params.clock_type = DCECLOCK_TYPE_DISPLAY_CLOCK;
 
-	dc_bios_set_dce_clock(bp, &dce_clk_params);
+	bp->funcs->set_dce_clock(bp, &dce_clk_params);
 
 	/* from power down, we need mark the clock state as ClocksStateNominal
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
@@ -781,10 +781,10 @@ void dispclk_dce112_set_clock(
 	dce_clk_params.target_clock_frequency = 0;
 	dce_clk_params.clock_type = DCECLOCK_TYPE_DPREFCLK;
 	dce_clk_params.flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK =
-                        (dce_clk_params.pll_id ==
-                                        CLOCK_SOURCE_COMBO_DISPLAY_PLL0);
+			(dce_clk_params.pll_id ==
+					CLOCK_SOURCE_COMBO_DISPLAY_PLL0);
 
-	dc_bios_set_dce_clock(bp, &dce_clk_params);
+	bp->funcs->set_dce_clock(bp, &dce_clk_params);
 }
 
 void dispclk_dce112_set_clock_state(
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
index 7ef06fd..aa367bb 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
@@ -478,7 +478,7 @@ static void set_clock(
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = dc->id;
 
-	dc_bios_program_display_engine_pll(bp, &pxl_clk_params);
+	bp->funcs->program_display_engine_pll(bp, &pxl_clk_params);
 
 	if (disp_clk->dfs_bypass_enabled) {
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
index 6fdd07e..6c4f9e1 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
@@ -1,5 +1,5 @@
 /*
- * rore_dc.h
+ * core_dc.h
  *
  *  Created on: Nov 13, 2015
  *      Author: yonsun
@@ -14,7 +14,7 @@
 #define DC_TO_CORE(dc)\
 	container_of(dc, struct core_dc, public)
 
-struct coe_dc {
+struct core_dc {
 	struct dc public;
 	struct dc_context *ctx;
 
@@ -23,8 +23,8 @@ struct coe_dc {
 
 	/* TODO: determine max number of targets*/
 	struct validate_context *current_context;
-        struct validate_context *temp_flip_context;
-	struct resource_pool res_pool;
+	struct validate_context *temp_flip_context;
+	struct resource_pool *res_pool;
 
 	/*Power State*/
 	enum dc_video_power_state previous_power_state;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 4bd5363..e82cc67 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -200,7 +200,7 @@ struct validate_context;
 struct resource_context;
 
 struct resource_funcs {
-	void (*destruct)(struct resource_pool *pool);
+	void (*destroy)(struct resource_pool **pool);
 	struct link_encoder *(*link_enc_create)(
 			const struct encoder_init_data *init);
 	enum dc_status (*validate_with_context)(
@@ -291,14 +291,14 @@ struct pipe_ctx {
 };
 
 struct resource_context {
-        const struct resource_pool *pool;
+	const struct resource_pool *pool;
 	struct pipe_ctx pipe_ctx[MAX_PIPES];
 	union supported_stream_engines used_stream_engines;
 	bool is_stream_enc_acquired[MAX_PIPES * 2];
 	bool is_audio_acquired[MAX_PIPES];
 	uint8_t clock_source_ref_count[MAX_CLOCK_SOURCES];
 	uint8_t dp_clock_source_ref_count;
-};
+ };
 
 struct validate_context {
 	struct core_target *targets[MAX_PIPES];
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index a5abaed..4254f32 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -37,10 +37,13 @@ enum dce_version resource_parse_asic_id(
 		struct hw_asic_id asic_id);
 
 struct resource_pool *dc_create_resource_pool(struct adapter_service *adapter_serv,
-                                struct core_dc *dc,
-                                int num_virtual_links,
-                                enum dce_version dc_version,
-                                struct hw_asic_id asic_id);
+				struct core_dc *dc,
+				int num_virtual_links,
+				enum dce_version dc_version,
+				struct hw_asic_id asic_id);
+
+void dc_destroy_resource_pool(struct resource_pool **pool,
+				enum dce_version dc_version);
 
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
diff --git a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
index 77e9997..c734c03 100644
--- a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
@@ -41,77 +41,74 @@
 #define FREESYNC_REGISTRY_NAME "freesync_v1"
 
 struct gradual_static_ramp {
-        bool ramp_is_active;
-        bool ramp_direction_is_up;
-        unsigned int ramp_current_frame_duration_in_ns;
+	bool ramp_is_active;
+	bool ramp_direction_is_up;
+	unsigned int ramp_current_frame_duration_in_ns;
 };
 
 struct time_cache {
-        /* video (48Hz feature) related */
-        unsigned int update_duration_in_ns;
- 
-        /* BTR/fixed refresh related */
-        unsigned int prev_time_stamp_in_us;
- 
-        unsigned int min_render_time_in_us;
-        unsigned int max_render_time_in_us;
- 
-        unsigned int render_times_index;
-        unsigned int render_times[RENDER_TIMES_MAX_COUNT];
+	/* video (48Hz feature) related */
+	unsigned int update_duration_in_ns;
+
+	/* BTR/fixed refresh related */
+	unsigned int prev_time_stamp_in_us;
+
+	unsigned int min_render_time_in_us;
+	unsigned int max_render_time_in_us;
+
+	unsigned int render_times_index;
+	unsigned int render_times[RENDER_TIMES_MAX_COUNT];
 };
 
 struct below_the_range {
-        bool btr_active;
-        bool program_btr;
- 
-        unsigned int mid_point_in_us;
- 
-        unsigned int inserted_frame_duration_in_us;
-        unsigned int frames_to_insert;
-        unsigned int frame_counter;
+	bool btr_active;
+	bool program_btr;
+
+	unsigned int mid_point_in_us;
+
+	unsigned int inserted_frame_duration_in_us;
+	unsigned int frames_to_insert;
+	unsigned int frame_counter;
 };
 
 struct fixed_refresh {
-        bool fixed_refresh_active;
-        bool program_fixed_refresh;
+	bool fixed_refresh_active;
+	bool program_fixed_refresh;
 };
 
 struct freesync_state {
-        bool fullscreen;
-        bool static_screen;
-        bool video;
- 
-        unsigned int nominal_refresh_rate_in_micro_hz;
+	bool fullscreen;
+	bool static_screen;
+	bool video;
+
+	unsigned int nominal_refresh_rate_in_micro_hz;
 
-        struct time_cache time;
+	struct time_cache time;
 
-        struct gradual_static_ramp static_ramp;
-        struct below_the_range btr;
-        struct fixed_refresh fixed_refresh;
+	struct gradual_static_ramp static_ramp;
+	struct below_the_range btr;
+	struct fixed_refresh fixed_refresh;
 };
 
 struct freesync_entity {
-        const struct dc_stream *stream;
-        const struct dc_sink *sink;
-        struct mod_freesync_caps caps;
-        struct freesync_state state;
-        struct mod_freesync_user_enable user_enable;
+	const struct dc_stream *stream;
+	const struct dc_sink *sink;
+	struct mod_freesync_caps caps;
+	struct freesync_state state;
+	struct mod_freesync_user_enable user_enable;
 };
 
 struct core_freesync {
-        struct mod_freesync public;
-        struct dc *dc;
-        struct sink_caps *caps;
-        struct freesync_state *state;
-        struct mod_freesync_user_enable *user_enable;
-        struct freesync_entity *map;
-        int num_sinks;
-        int num_streams;
-        int num_entities;
+	struct mod_freesync public;
+	struct dc *dc;
+	struct freesync_entity *map;
+	int num_sinks;
+	int num_streams;
+	int num_entities;
 };
 
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
-                container_of(mod_freesync, struct core_freesync, public)
+		container_of(mod_freesync, struct core_freesync, public)
 
 static bool check_dc_support(const struct dc *dc)
 {
@@ -161,7 +158,7 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	/* Create initial module folder in registry for freesync enable data */
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
-        dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME, NULL, NULL,
+	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME, NULL, NULL,
 					0, &flag);
 
 	return &core_freesync->public;
-- 
2.7.4

