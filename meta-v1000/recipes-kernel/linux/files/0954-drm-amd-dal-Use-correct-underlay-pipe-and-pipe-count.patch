From d9b8052b23bb66d5e782f8edc021be7640a1bae3 Mon Sep 17 00:00:00 2001
From: Jordan Lazare <Jordan.Lazare@amd.com>
Date: Wed, 31 Aug 2016 11:37:06 -0400
Subject: [PATCH 0954/1722] drm/amd/dal: Use correct underlay pipe and pipe
 count for stoney

Change-Id: Iffe716fdf20ebe6f5c88dfa22057ccfbc153a4ef
Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 640 +++++++++++----------
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  35 ++
 .../drm/amd/dal/dc/dce100/dce100_hw_sequencer.c    |   7 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  30 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    | 480 ++++++++--------
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.h    |   6 +
 .../drm/amd/dal/dc/dce112/dce112_hw_sequencer.c    |   6 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c  |   7 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   1 +
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |   4 +-
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |  11 +-
 11 files changed, 665 insertions(+), 562 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 07d5310..8e2976a 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -77,11 +77,11 @@ static bool create_links(
 {
 	int i;
 	int connectors_num;
-        struct dc_bios *bios = dc->ctx->dc_bios;
+	struct dc_bios *bios = dc->ctx->dc_bios;
 
 	dc->link_count = 0;
 
-        connectors_num = bios->funcs->get_connectors_number(bios);
+	connectors_num = bios->funcs->get_connectors_number(bios);
 
 	if (connectors_num > ENUM_ID_COUNT) {
 		dm_error(
@@ -385,9 +385,14 @@ static bool construct(struct core_dc *dc,
 
 		dc_ctx->dc_bios = dal_adapter_service_get_bios_parser(as);
 
-		if (!dc_construct_resource_pool(
-			as, dc, init_params->num_virtual_links, dc_version))
-			goto construct_resource_fail;
+		dc->res_pool = dc_create_resource_pool(
+				as,
+				dc,
+				init_params->num_virtual_links,
+				dc_version,
+				init_params->asic_id);
+		if (!dc->res_pool)
+			goto create_resource_fail;
 
 		if (!create_links(dc, as, init_params->num_virtual_links))
 			goto create_links_fail;
@@ -398,9 +403,14 @@ static bool construct(struct core_dc *dc,
 		 */
 
 		dc_ctx->dc_bios = init_params->vbios_override;
-		if (!dc_construct_resource_pool(
-			NULL, dc, init_params->num_virtual_links, dc_version))
-			goto construct_resource_fail;
+		dc->res_pool = dc_create_resource_pool(
+				NULL,
+				dc,
+				init_params->num_virtual_links,
+				dc_version,
+				init_params->asic_id);
+		if (!dc->res_pool)
+			goto create_resource_fail;
 
 		if (!create_links(dc, NULL, init_params->num_virtual_links))
 			goto create_links_fail;
@@ -411,8 +421,11 @@ static bool construct(struct core_dc *dc,
 	return true;
 
 	/**** error handling here ****/
-construct_resource_fail:
 create_links_fail:
+	dc->res_pool->funcs->destroy(&dc->res_pool);
+create_resource_fail:
+	if (as)
+		dal_adapter_service_destroy(&as);
 as_fail:
 	dal_logger_destroy(&dc_ctx->logger);
 logger_fail:
@@ -427,10 +440,10 @@ static void destruct(struct core_dc *dc)
 {
 	resource_validate_ctx_destruct(dc->current_context);
 	dm_free(dc->current_context);
-        dm_free(dc->temp_flip_context);
+	dm_free(dc->temp_flip_context);
 	dc->current_context = NULL;
 	destroy_links(dc);
-	dc->res_pool.funcs->destruct(&dc->res_pool);
+	dc->res_pool->funcs->destroy(&dc->res_pool);
 	dal_logger_destroy(&dc->ctx->logger);
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
@@ -465,7 +478,7 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
  ******************************************************************************/
 
 struct dc *dc_create(const struct dc_init_data *init_params)
-{
+ {
 	struct core_dc *core_dc = dm_alloc(sizeof(*core_dc));
 
 	if (NULL == core_dc)
@@ -478,12 +491,12 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	core_dc->hwss.init_hw(core_dc);
 
 	core_dc->public.caps.max_targets = dm_min(
-			core_dc->res_pool.pipe_count,
-			core_dc->res_pool.stream_enc_count);
+			core_dc->res_pool->pipe_count,
+			core_dc->res_pool->stream_enc_count);
 	core_dc->public.caps.max_links = core_dc->link_count;
-	core_dc->public.caps.max_audios = core_dc->res_pool.audio_count;
- 
-        core_dc->public.config.gpu_vm_support = init_params->flags.gpu_vm_support;
+	core_dc->public.caps.max_audios = core_dc->res_pool->audio_count;
+
+	core_dc->public.config.gpu_vm_support = init_params->flags.gpu_vm_support;
 
 	dal_logger_write(core_dc->ctx->logger,
 			LOG_MAJOR_INTERFACE_TRACE,
@@ -557,7 +570,7 @@ bool dc_validate_resources(
 	if(context == NULL)
 		goto context_alloc_fail;
 
-	result = core_dc->res_pool.funcs->validate_with_context(
+	result = core_dc->res_pool->funcs->validate_with_context(
 						core_dc, set, set_count, context);
 
 	resource_validate_ctx_destruct(context);
@@ -589,7 +602,7 @@ bool dc_validate_guaranteed(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	result = core_dc->res_pool.funcs->validate_guaranteed(
+	result = core_dc->res_pool->funcs->validate_guaranteed(
 					core_dc, dc_target, context);
 
 	resource_validate_ctx_destruct(context);
@@ -612,73 +625,74 @@ static void program_timing_sync(
 		struct core_dc *core_dc,
 		struct validate_context *ctx)
 {
-        int i, j;
-        int group_index = 0;
-        int pipe_count = ctx->res_ctx.pool->pipe_count;
-        struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
-        
+	int i, j;
+	int group_index = 0;
+	int pipe_count = ctx->res_ctx.pool->pipe_count;
+	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
+
+	for (i = 0; i < pipe_count; i++) {
+		if (!ctx->res_ctx.pipe_ctx[i].stream || ctx->res_ctx.pipe_ctx[i].top_pipe)
+			continue;
+
+		unsynced_pipes[i] = &ctx->res_ctx.pipe_ctx[i];
+	}
+
 	for (i = 0; i < pipe_count; i++) {
-                if (!ctx->res_ctx.pipe_ctx[i].stream || ctx->res_ctx.pipe_ctx[i].top_pipe)
+		int group_size = 1;
+		struct pipe_ctx *pipe_set[MAX_PIPES];
+
+		if (!unsynced_pipes[i])
 			continue;
-        }
- 
-        for (i = 0; i < pipe_count; i++) {
-                int group_size = 1;
-                struct pipe_ctx *pipe_set[MAX_PIPES];
- 
-                if (!unsynced_pipes[i])
-                        continue;
- 
-                pipe_set[0] = unsynced_pipes[i];
-                unsynced_pipes[i] = NULL;
+
+		pipe_set[0] = unsynced_pipes[i];
+		unsynced_pipes[i] = NULL;
 
 		/* Add tg to the set, search rest of the tg's for ones with
 		 * same timing, add all tgs with same timing to the group
 		 */
-                for (j = i + 1; j < pipe_count; j++) {
-                        if (!unsynced_pipes[j])
+		for (j = i + 1; j < pipe_count; j++) {
+			if (!unsynced_pipes[j])
 				continue;
 
 			if (resource_are_streams_timing_synchronizable(
-                                        unsynced_pipes[j]->stream,
-                                        pipe_set[0]->stream)) {
-                                pipe_set[group_size] = unsynced_pipes[j];
-                                unsynced_pipes[j] = NULL;
+					unsynced_pipes[j]->stream,
+					pipe_set[0]->stream)) {
+				pipe_set[group_size] = unsynced_pipes[j];
+				unsynced_pipes[j] = NULL;
 				group_size++;
 			}
 		}
- 
-                /* set first unblanked pipe as master */
-                for (j = 0; j < group_size; j++) {
-                        struct pipe_ctx *temp;
- 
-                        if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
-                                if (j == 0)
-                                        break;
- 
-                                temp = pipe_set[0];
-                                pipe_set[0] = pipe_set[j];
-                                pipe_set[j] = temp;
-                                break;
-                        }
-                }
- 
-                /* remove any other unblanked pipes as they have already been synced */
-                for (j = j + 1; j < group_size; j++) {
-                        if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
-                                group_size--;
-                                pipe_set[j] = pipe_set[group_size];
-                                j--;
-                        }
-                }
-
-                if (group_size > 1) {
-                        core_dc->hwss.enable_timing_synchronization(
-                                core_dc, group_index, group_size, pipe_set);
-                        group_index++;
-                }
-	}
 
+		/* set first unblanked pipe as master */
+		for (j = 0; j < group_size; j++) {
+			struct pipe_ctx *temp;
+
+			if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
+				if (j == 0)
+					break;
+
+				temp = pipe_set[0];
+				pipe_set[0] = pipe_set[j];
+				pipe_set[j] = temp;
+				break;
+			}
+		}
+
+		/* remove any other unblanked pipes as they have already been synced */
+		for (j = j + 1; j < group_size; j++) {
+			if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
+				group_size--;
+				pipe_set[j] = pipe_set[group_size];
+				j--;
+			}
+		}
+
+		if (group_size > 1) {
+			core_dc->hwss.enable_timing_synchronization(
+				core_dc, group_index, group_size, pipe_set);
+			group_index++;
+		}
+	}
 }
 
 static bool targets_changed(
@@ -728,10 +742,10 @@ static void target_disable_memory_requests(struct dc_target *dc_target,
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 
 	for (i = 0; i < target->public.stream_count; i++) {
-		for (j = 0; j < res_ctx->pool.pipe_count; j++) {
+		for (j = 0; j < res_ctx->pool->pipe_count; j++) {
 			struct timing_generator *tg = res_ctx->pipe_ctx[j].tg;
 
-                        if (res_ctx->pipe_ctx[j].top_pipe != NULL ||
+			if (res_ctx->pipe_ctx[j].top_pipe != NULL ||
 				res_ctx->pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(target->public.streams[i]))
 				continue;
@@ -939,7 +953,7 @@ bool dc_commit_targets(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	result = core_dc->res_pool.funcs->validate_with_context(core_dc, set, target_count, context);
+	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set, target_count, context);
 	if (result != DC_OK){
 		dal_logger_write(core_dc->ctx->logger,
 					LOG_MAJOR_ERROR,
@@ -954,7 +968,7 @@ bool dc_commit_targets(
 
 	pplib_apply_safe_state(core_dc);
 
-	if (!dc_bios_is_accelerated_mode(dcb)) {
+	if (!dcb->funcs->is_accelerated_mode(dcb)) {
 		core_dc->hwss.enable_accelerated_mode(core_dc);
 	}
 
@@ -1010,49 +1024,50 @@ bool dc_pre_commit_surfaces_to_target(
 	struct dc_target_status *target_status = NULL;
 	struct validate_context *context;
 	struct validate_context *temp_context;
-        bool ret = true;
+	bool ret = true;
 
 	int current_enabled_surface_count = 0;
 	int new_enabled_surface_count = 0;
 
 	if (core_dc->current_context->target_count == 0)
-                return false;
- 
-        /* Cannot commit surface to a target that is not commited */
-        for (i = 0; i < core_dc->current_context->target_count; i++)
-                if (target == core_dc->current_context->targets[i])
-                        break;
-        if (i == core_dc->current_context->target_count)
-                return false;
-  
-        target_status = &core_dc->current_context->target_status[i];
- 
-        if (new_surface_count == target_status->surface_count) {
-                bool skip_pre = true;
- 
-                for (i = 0; i < target_status->surface_count; i++) {
-                        struct dc_surface temp_surf = { 0 };
- 
-                        temp_surf = *target_status->surfaces[i];
-                        temp_surf.clip_rect = new_surfaces[i]->clip_rect;
-                        temp_surf.dst_rect.x = new_surfaces[i]->dst_rect.x;
-                        temp_surf.dst_rect.y = new_surfaces[i]->dst_rect.y;
- 
-                        if (memcmp(&temp_surf, new_surfaces[i], sizeof(temp_surf)) != 0) {
-                                skip_pre = false;
-                                break;
-                        }
-                }
- 
-                if (skip_pre)
-                        return true;
-        }
+		return false;
+
+	/* Cannot commit surface to a target that is not commited */
+	for (i = 0; i < core_dc->current_context->target_count; i++)
+		if (target == core_dc->current_context->targets[i])
+			break;
+
+	if (i == core_dc->current_context->target_count)
+		return false;
+
+	target_status = &core_dc->current_context->target_status[i];
+
+	if (new_surface_count == target_status->surface_count) {
+		bool skip_pre = true;
+
+		for (i = 0; i < target_status->surface_count; i++) {
+			struct dc_surface temp_surf = { 0 };
+
+			temp_surf = *target_status->surfaces[i];
+			temp_surf.clip_rect = new_surfaces[i]->clip_rect;
+			temp_surf.dst_rect.x = new_surfaces[i]->dst_rect.x;
+			temp_surf.dst_rect.y = new_surfaces[i]->dst_rect.y;
+
+			if (memcmp(&temp_surf, new_surfaces[i], sizeof(temp_surf)) != 0) {
+				skip_pre = false;
+				break;
+			}
+		}
+
+		if (skip_pre)
+			return true;
+	}
 
 	context = dm_alloc(sizeof(struct validate_context));
 
 	if (!context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
-                ret = false;
+		ret = false;
 		goto val_ctx_fail;
 	}
 
@@ -1090,224 +1105,227 @@ bool dc_pre_commit_surfaces_to_target(
 			resource_build_scaling_params(
 				new_surfaces[i], &context->res_ctx.pipe_ctx[j]);
 
-                        if (dc->debug.surface_visual_confirm) {
-                                context->res_ctx.pipe_ctx[j].scl_data.recout.height -= 2;
-                                context->res_ctx.pipe_ctx[j].scl_data.recout.width -= 2;
-                        }
+			if (dc->debug.surface_visual_confirm) {
+				context->res_ctx.pipe_ctx[j].scl_data.recout.height -= 2;
+				context->res_ctx.pipe_ctx[j].scl_data.recout.width -= 2;
+			}
 		}
 
-	if (core_dc->res_pool.funcs->validate_bandwidth(core_dc, context) != DC_OK) {
+	if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, context) != DC_OK) {
 		BREAK_TO_DEBUGGER();
-                ret = false;
+		ret = false;
 		goto unexpected_fail;
 	}
 
-        if (core_dc->res_pool->funcs->apply_clk_constraints) {
-                temp_context = core_dc->res_pool->funcs->apply_clk_constraints(
-                                core_dc,
-                                context);
-                if (!temp_context) {
-                        dm_error("%s:failed apply clk constraints\n", __func__);
-                        BREAK_TO_DEBUGGER();
-                        ret = false;
-                        goto unexpected_fail;
-                }
-                resource_validate_ctx_destruct(context);
-                dm_free(context);
-                context = temp_context;
-        }
-        if (prev_disp_clk < context->bw_results.dispclk_khz) {
+	if (core_dc->res_pool->funcs->apply_clk_constraints) {
+		temp_context = core_dc->res_pool->funcs->apply_clk_constraints(
+				core_dc,
+				context);
+		if (!temp_context) {
+			dm_error("%s:failed apply clk constraints\n", __func__);
+			BREAK_TO_DEBUGGER();
+			ret = false;
+			goto unexpected_fail;
+		}
+		resource_validate_ctx_destruct(context);
+		dm_free(context);
+		context = temp_context;
+	}
+
+	if (prev_disp_clk < context->bw_results.dispclk_khz) {
 		pplib_apply_display_requirements(core_dc, context,
-                                                &context->pp_display_cfg);
-                core_dc->hwss.set_display_clock(context);
-                core_dc->current_context->bw_results.dispclk_khz =
-                                context->bw_results.dispclk_khz;
+						&context->pp_display_cfg);
+		core_dc->hwss.set_display_clock(context);
+		core_dc->current_context->bw_results.dispclk_khz =
+				context->bw_results.dispclk_khz;
 	}
- 
-        for (i = 0; i < new_surface_count; i++)
-                for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-                        if (context->res_ctx.pipe_ctx[j].surface !=
-                                        DC_SURFACE_TO_CORE(new_surfaces[i]))
-                                continue;
- 
-                        core_dc->hwss.prepare_pipe_for_context(
-                                        core_dc,
-                                        &context->res_ctx.pipe_ctx[j],
-                                        context);
-                }
+
+	for (i = 0; i < new_surface_count; i++)
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			if (context->res_ctx.pipe_ctx[j].surface !=
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+			core_dc->hwss.prepare_pipe_for_context(
+					core_dc,
+					&context->res_ctx.pipe_ctx[j],
+					context);
+		}
 
 	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
 		target_disable_memory_requests(dc_target,
 				&core_dc->current_context->res_ctx);
- 
+
 unexpected_fail:
-        resource_validate_ctx_destruct(context);
-        dm_free(context);
-val_ctx_fail:	
+	resource_validate_ctx_destruct(context);
+	dm_free(context);
+val_ctx_fail:
 
-	return true;
+	return ret;
 }
 
- bool dc_isr_commit_surfaces_to_target(
-                struct dc *dc,
-                const struct dc_surface **new_surfaces,
-                int new_surface_count,
-                struct dc_target *dc_target)
+bool dc_isr_commit_surfaces_to_target(
+		struct dc *dc,
+		const struct dc_surface **new_surfaces,
+		int new_surface_count,
+		struct dc_target *dc_target)
 {
-        int i, j;
-        struct core_dc *core_dc = DC_TO_CORE(dc);
-        struct validate_context *context = core_dc->temp_flip_context;
-        struct core_target *target = DC_TARGET_TO_CORE(dc_target);
-        struct dc_target_status *target_status = NULL;
-        bool surface_needs_programming = false;
-
-        if (core_dc->current_context->target_count == 0)
-                return false;
- 
-        /* Cannot commit surface to a target that is not commited */
-        for (i = 0; i < core_dc->current_context->target_count; i++)
-                if (target == core_dc->current_context->targets[i])
-                        break;
-        if (i == core_dc->current_context->target_count)
-                return false;
-
-        target_status = &core_dc->current_context->target_status[i];
- 
-        if (new_surface_count != target_status->surface_count)
-                surface_needs_programming = true;
-        else
-                for (i = 0; i < target_status->surface_count; i++) {
-                        struct dc_surface temp_surf = { 0 };
- 
-                        temp_surf = *target_status->surfaces[i];
-                        temp_surf.address = new_surfaces[i]->address;
- 
-                        if (memcmp(&temp_surf, new_surfaces[i], sizeof(temp_surf)) != 0) {
-                                surface_needs_programming = true;
-                                break;
-                        }
-                }
- 
-        *context = *core_dc->current_context; 
-        for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
-                struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
-
-                if (cur_pipe->top_pipe)
-                        cur_pipe->top_pipe =
-                                &context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
-
-                if (cur_pipe->bottom_pipe)
-                        cur_pipe->bottom_pipe =
-                                &context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
-        }
- 
-        if (!resource_attach_surfaces_to_context(
-                        new_surfaces, new_surface_count, dc_target, context)) {
-                BREAK_TO_DEBUGGER();
-                return false;
-        }
- 
-        for (i = 0; i < new_surface_count; i++)
-                for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-                        struct pipe_ctx *old_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j]; 
-                        
+	int i, j;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *context = core_dc->temp_flip_context;
+	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
+	struct dc_target_status *target_status = NULL;
+	bool surface_needs_programming = false;
+
+	if (core_dc->current_context->target_count == 0)
+		return false;
+
+	/* Cannot commit surface to a target that is not commited */
+	for (i = 0; i < core_dc->current_context->target_count; i++)
+		if (target == core_dc->current_context->targets[i])
+			break;
+	if (i == core_dc->current_context->target_count)
+		return false;
+
+	target_status = &core_dc->current_context->target_status[i];
+
+	if (new_surface_count != target_status->surface_count)
+		surface_needs_programming = true;
+	else
+		for (i = 0; i < target_status->surface_count; i++) {
+			struct dc_surface temp_surf = { 0 };
+
+			temp_surf = *target_status->surfaces[i];
+			temp_surf.address = new_surfaces[i]->address;
+
+			if (memcmp(&temp_surf, new_surfaces[i], sizeof(temp_surf)) != 0) {
+				surface_needs_programming = true;
+				break;
+			}
+		}
+
+	*context = *core_dc->current_context;
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+
+		if (cur_pipe->top_pipe)
+			cur_pipe->top_pipe =
+				&context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+
+		if (cur_pipe->bottom_pipe)
+			cur_pipe->bottom_pipe =
+				&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+	}
+
+	if (!resource_attach_surfaces_to_context(
+			new_surfaces, new_surface_count, dc_target, context)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	for (i = 0; i < new_surface_count; i++)
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+			struct pipe_ctx *old_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
+
 			if (pipe_ctx->surface !=
-                                        DC_SURFACE_TO_CORE(new_surfaces[i]))
-                                continue;
- 
-                        resource_build_scaling_params(new_surfaces[i], pipe_ctx); 
- 
-                        if (dc->debug.surface_visual_confirm) {
-                                pipe_ctx->scl_data.recout.height -= 2;
-                                pipe_ctx->scl_data.recout.width -= 2; 
-                        }
-
-                        if (memcmp(&pipe_ctx->scl_data,
-                                        &old_pipe_ctx->scl_data,
-                                        sizeof(pipe_ctx->scl_data)))
-                                surface_needs_programming = true;
- 
-                        core_dc->hwss.pipe_control_lock(
-                                        core_dc->ctx,
-                                        pipe_ctx->pipe_idx,
-                                        PIPE_LOCK_CONTROL_SURFACE,
-                                        true);
-
-                        core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-                }
-
-        if (surface_needs_programming)
-                core_dc->hwss.apply_ctx_to_surface(core_dc, context);
-
-        /* Go in reverse order so that all pipes are unlocked simultaneously
-         * when pipe 0 is unlocked
-         * Need PIPE_LOCK_CONTROL_MODE to be 1 for this
-        */
-        for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
-                struct pipe_ctx *pipe_ctx =
-                                        &context->res_ctx.pipe_ctx[i];
- 
-                core_dc->hwss.pipe_control_lock(
-                                core_dc->ctx,
-                                pipe_ctx->pipe_idx,
-                                PIPE_LOCK_CONTROL_GRAPHICS |
-                                PIPE_LOCK_CONTROL_SCL |
-                                PIPE_LOCK_CONTROL_BLENDER |
-                                PIPE_LOCK_CONTROL_SURFACE,
-                                false);
-        }
-
-        core_dc->temp_flip_context = core_dc->current_context;
-        core_dc->current_context = context;
- 
-        return true;
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+			resource_build_scaling_params(new_surfaces[i], pipe_ctx);
+
+			if (dc->debug.surface_visual_confirm) {
+				pipe_ctx->scl_data.recout.height -= 2;
+				pipe_ctx->scl_data.recout.width -= 2;
+			}
+
+			if (memcmp(&pipe_ctx->scl_data,
+					&old_pipe_ctx->scl_data,
+					sizeof(pipe_ctx->scl_data)))
+				surface_needs_programming = true;
+
+			core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_SURFACE,
+					true);
+
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+		}
+
+	if (surface_needs_programming)
+		core_dc->hwss.apply_ctx_to_surface(core_dc, context);
+
+	/* Go in reverse order so that all pipes are unlocked simultaneously
+	 * when pipe 0 is unlocked
+	 * Need PIPE_LOCK_CONTROL_MODE to be 1 for this
+	 */
+	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
+		struct pipe_ctx *pipe_ctx =
+					&context->res_ctx.pipe_ctx[i];
+
+		core_dc->hwss.pipe_control_lock(
+				core_dc->ctx,
+				pipe_ctx->pipe_idx,
+				PIPE_LOCK_CONTROL_GRAPHICS |
+				PIPE_LOCK_CONTROL_SCL |
+				PIPE_LOCK_CONTROL_BLENDER |
+				PIPE_LOCK_CONTROL_SURFACE,
+				false);
+	}
+
+	core_dc->temp_flip_context = core_dc->current_context;
+	core_dc->current_context = context;
+
+	return true;
 }
 
 bool dc_post_commit_surfaces_to_target(struct dc *dc)
 {
-        struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
-        
-        for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count; i++) {
-                if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL) {
-                        core_dc->hwss.enable_display_power_gating(
-                                core_dc->ctx, i, core_dc->ctx->dc_bios,
-                                PIPE_GATING_CONTROL_ENABLE);
-                        if (core_dc->current_context->res_ctx.pipe_ctx[i].xfm)
-                                core_dc->current_context->res_ctx.pipe_ctx[i].xfm->funcs->transform_reset(
-                                                core_dc->current_context->res_ctx.pipe_ctx[i].xfm);
-                        memset(&core_dc->current_context->res_ctx.pipe_ctx[i].scl_data, 0, sizeof(struct scaler_data));
-                }
-        }
- 
-        core_dc->hwss.set_bandwidth(core_dc);
- 
-        pplib_apply_display_requirements(
-                        core_dc, core_dc->current_context, &core_dc->current_context->pp_display_cfg); 
- 
+
+	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count; i++) {
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL) {
+			core_dc->hwss.enable_display_power_gating(
+				core_dc, i, core_dc->ctx->dc_bios,
+				PIPE_GATING_CONTROL_ENABLE);
+			if (core_dc->current_context->res_ctx.pipe_ctx[i].xfm)
+				core_dc->current_context->res_ctx.pipe_ctx[i].xfm->funcs->transform_reset(
+						core_dc->current_context->res_ctx.pipe_ctx[i].xfm);
+			memset(&core_dc->current_context->res_ctx.pipe_ctx[i].scl_data, 0, sizeof(struct scaler_data));
+		}
+	}
+
+	core_dc->hwss.set_bandwidth(core_dc);
+
+	pplib_apply_display_requirements(
+			core_dc, core_dc->current_context, &core_dc->current_context->pp_display_cfg);
+
 	return true;
 }
 
 bool dc_commit_surfaces_to_target(
-                struct dc *dc,
-                const struct dc_surface **new_surfaces,
-                uint8_t new_surface_count,
-                struct dc_target *dc_target)
+		struct dc *dc,
+		const struct dc_surface **new_surfaces,
+		uint8_t new_surface_count,
+		struct dc_target *dc_target)
 {
-        if (!dc_pre_commit_surfaces_to_target(
-                        dc,
-                        new_surfaces,
-                        new_surface_count,
-                        dc_target))
-                return false;
- 
-        if (!dc_isr_commit_surfaces_to_target(dc, new_surfaces, new_surface_count, dc_target))
-                return false;
- 
-        if (!dc_post_commit_surfaces_to_target(dc))
-                return false;
- 
-        return true;
+	if (!dc_pre_commit_surfaces_to_target(
+			dc,
+			new_surfaces,
+			new_surface_count,
+			dc_target))
+		return false;
+
+	if (!dc_isr_commit_surfaces_to_target(dc, new_surfaces, new_surface_count, dc_target))
+		return false;
+
+	if (!dc_post_commit_surfaces_to_target(dc))
+		return false;
+
+	return true;
+
 }
 
 static struct pipe_ctx *find_pipe_ctx_by_surface(struct validate_context *context,
@@ -1490,7 +1508,7 @@ enum dc_irq_source dc_get_hpd_irq_source_at_index(
 const struct audio **dc_get_audios(struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return (const struct audio **)core_dc->res_pool.audios;
+	return (const struct audio **)core_dc->res_pool->audios;
 }
 
 void dc_flip_surface_addrs(
@@ -1499,13 +1517,13 @@ void dc_flip_surface_addrs(
 		struct dc_flip_addrs flip_addrs[],
 		uint32_t count)
 {
-        int i;
-        struct dc_surface_update updates[MAX_SURFACE_NUM] = { { 0 } };
-        for (i = 0; i < count; i++) {
-                updates[i].flip_addr = &flip_addrs[i];
-                updates[i].surface = surfaces[i];
-        }
-        dc_update_surfaces_for_target(dc, updates, count, NULL);
+	int i;
+	struct dc_surface_update updates[MAX_SURFACE_NUM] = { { 0 } };
+	for (i = 0; i < count; i++) {
+		updates[i].flip_addr = &flip_addrs[i];
+		updates[i].surface = surfaces[i];
+	}
+	dc_update_surfaces_for_target(dc, updates, count, NULL);
 }
 
 enum dc_irq_source dc_interrupt_to_irq_source(
@@ -1514,19 +1532,19 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 		uint32_t ext_id)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return dal_irq_service_to_irq_source(core_dc->res_pool.irqs, src_id, ext_id);
+	return dal_irq_service_to_irq_source(core_dc->res_pool->irqs, src_id, ext_id);
 }
 
 void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	dal_irq_service_set(core_dc->res_pool.irqs, src, enable);
+	dal_irq_service_set(core_dc->res_pool->irqs, src, enable);
 }
 
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	dal_irq_service_ack(core_dc->res_pool.irqs, src);
+	dal_irq_service_ack(core_dc->res_pool->irqs, src);
 }
 
 void dc_set_power_state(
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index b36ffcf..7671c44 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -119,6 +119,41 @@ bool dc_construct_resource_pool(struct adapter_service *adapter_serv,
 	return false;
 }
 
+struct resource_pool *dc_create_resource_pool(struct adapter_service *adapter_serv,
+                                struct core_dc *dc,
+                                int num_virtual_links,
+                                enum dce_version dc_version,
+                                struct hw_asic_id asic_id)
+{
+
+        switch (dc_version) {
+#if defined(CONFIG_DRM_AMD_DAL_DCE8_0)
+        case DCE_VERSION_8_0:
+                return dce80_create_resource_pool(
+                        adapter_serv, num_virtual_links, dc);
+#endif
+#if defined(CONFIG_DRM_AMD_DAL_DCE10_0)
+        case DCE_VERSION_10_0:
+                return dce100_create_resource_pool(
+                        adapter_serv, num_virtual_links, dc);
+#endif
+#if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
+        case DCE_VERSION_11_0:
+                return dce110_create_resource_pool(
+                        adapter_serv, num_virtual_links, dc, asic_id);
+#endif
+#if defined(CONFIG_DRM_AMD_DAL_DCE11_2)
+        case DCE_VERSION_11_2:
+                return dce112_create_resource_pool(
+                        adapter_serv, num_virtual_links, dc);
+#endif
+        default:
+                break;
+        }
+
+        return false;
+}
+
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
 		struct clock_source *clock_source)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
index 58ca223..43ebdd0 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
@@ -154,7 +154,7 @@ static bool dce100_pipe_control_lock(
 }
 
 static void dce100_set_blender_mode(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	uint32_t mode)
 {
@@ -163,6 +163,8 @@ static void dce100_set_blender_mode(
 	uint32_t blnd_mode;
 	uint32_t feedthrough = 0;
 
+	struct dc_context *ctx = dc->ctx;
+
 	switch (mode) {
 	case BLENDER_MODE_OTHER_PIPE:
 		feedthrough = 0;
@@ -197,13 +199,14 @@ static void dce100_set_blender_mode(
 }
 
 static bool dce100_enable_display_power_gating(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
 {
 	enum bp_result bp_result = BP_RESULT_OK;
 	enum bp_pipe_control_action cntl;
+	struct dc_context *ctx = dc->ctx;
 
 	if (power_gating == PIPE_GATING_CONTROL_INIT)
 		cntl = ASIC_PIPE_INIT;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 3e8bea4..f0cb5fb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -255,7 +255,7 @@ static bool dce110_pipe_control_lock(
 }
 
 static void dce110_set_blender_mode(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	uint32_t mode)
 {
@@ -266,6 +266,9 @@ static void dce110_set_blender_mode(
 	uint32_t feedthrough = 1;
 	uint32_t multiplied_mode = 0;
 
+	struct dc_context *ctx = dc->ctx;
+	unsigned int underlay_idx = dc->current_context->res_ctx.pool->underlay_pipe_index;
+
 	switch (mode) {
 	case BLENDER_MODE_OTHER_PIPE:
 		feedthrough = 0;
@@ -280,7 +283,7 @@ static void dce110_set_blender_mode(
 		break;
 	case BLENDER_MODE_CURRENT_PIPE:
 	default:
-		if (controller_id == DCE110_UNDERLAY_IDX || controller_id == 0)
+		if (controller_id == underlay_idx || controller_id == 0)
 			feedthrough = 0;
 		break;
 	}
@@ -349,13 +352,15 @@ static void enable_display_pipe_clock_gating(
 }
 
 static bool dce110_enable_display_power_gating(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
 {
 	enum bp_result bp_result = BP_RESULT_OK;
 	enum bp_pipe_control_action cntl;
+	struct dc_context *ctx = dc->ctx;
+	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
 
 	if (IS_FPGA_MAXIMUS_DC(ctx->dce_environment))
 		return true;
@@ -367,7 +372,7 @@ static bool dce110_enable_display_power_gating(
 	else
 		cntl = ASIC_PIPE_DISABLE;
 
-	if (controller_id == DCE110_UNDERLAY_IDX)
+        if (controller_id == underlay_idx)
 		controller_id = CONTROLLER_ID_UNDERLAY0 - 1;
 
         if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0){
@@ -932,7 +937,7 @@ static void disable_vga_and_power_gate_all_controllers(
 		 * powergating. */
 		enable_display_pipe_clock_gating(ctx,
 				true);
-		dc->hwss.enable_display_power_gating(ctx, i, dcb,
+		dc->hwss.enable_display_power_gating(dc, i, dcb,
 				PIPE_GATING_CONTROL_ENABLE);
 		dc->res_pool->transforms[i]->funcs->transform_reset(
 				dc->res_pool->transforms[i]);
@@ -1211,13 +1216,14 @@ static void set_displaymarks(
 	struct validate_context *context)
 {
 	uint8_t i, num_pipes;
+	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
 
 	for (i = 0, num_pipes = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		uint32_t total_dest_line_time_ns;
 
 		if (pipe_ctx->stream == NULL
-			|| pipe_ctx->pipe_idx == DCE110_UNDERLAY_IDX)
+			|| pipe_ctx->pipe_idx == underlay_idx)
 			continue;
 
 		total_dest_line_time_ns = compute_pstate_blackout_duration(
@@ -1313,7 +1319,7 @@ static void reset_single_pipe_hw_ctx(
 	pipe_ctx->xfm->funcs->transform_reset(pipe_ctx->xfm);
 	resource_unreference_clock_source(&context->res_ctx, pipe_ctx->clock_source);
 	dc->hwss.enable_display_power_gating(
-		pipe_ctx->stream->ctx, pipe_ctx->pipe_idx, dcb,
+		(struct core_dc *)dc, pipe_ctx->pipe_idx, dcb,
 			PIPE_GATING_CONTROL_ENABLE);
 
 	pipe_ctx->stream = NULL;
@@ -1393,7 +1399,7 @@ static enum dc_status apply_ctx_to_hw(
 				context->res_ctx.pool.adapter_srv);
 
 		dc->hwss.enable_display_power_gating(
-				dc->ctx, i, dcb,
+                                dc, i, dcb,
 				PIPE_GATING_CONTROL_DISABLE);
 	}
 
@@ -1529,7 +1535,7 @@ static void program_blender_if_needed(const struct core_dc *dc,
 		if (pipe_ctx->bottom_pipe)
 			blender_mode = BLENDER_MODE_BLENDING;
 		dc->hwss.set_blender_mode(
-			dc->ctx, pipe_ctx->pipe_idx, blender_mode);
+			(struct core_dc *)dc, pipe_ctx->pipe_idx, blender_mode);
 	}
 }
 
@@ -1773,10 +1779,10 @@ static void init_hw(struct core_dc *dc)
                 xfm->funcs->transform_reset(xfm);
 
 		dc->hwss.enable_display_power_gating(
-				dc->ctx, i, bp,
+                                dc, i, bp,
 				PIPE_GATING_CONTROL_INIT);
 		dc->hwss.enable_display_power_gating(
-				dc->ctx, i, bp,
+                                dc, i, bp,
 				PIPE_GATING_CONTROL_DISABLE);
 		xfm->funcs->transform_power_up(xfm);
 		dc->hwss.enable_display_pipe_clock_gating(
@@ -1827,7 +1833,7 @@ static void dce110_power_on_pipe_if_needed(
 
 	if (!old_pipe_ctx->stream && pipe_ctx->stream) {
 		dc->hwss.enable_display_power_gating(
-				dc->ctx,
+                                dc,
 				pipe_ctx->pipe_idx,
 				dcb, PIPE_GATING_CONTROL_DISABLE);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index e71c47a..8f335af 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -623,9 +623,9 @@ enum dc_status dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx)
 	return DC_OK;
 }
 
-static bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx)
+static bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigned int underlay_idx)
 {
-	if (pipe_ctx->pipe_idx != DCE110_UNDERLAY_IDX)
+	if (pipe_ctx->pipe_idx != underlay_idx)
 		return true;
 	if (!pipe_ctx->surface)
 		return false;
@@ -659,7 +659,8 @@ static enum dc_status validate_mapped_resource(
 				if (context->res_ctx.pipe_ctx[k].stream != stream)
 					continue;
 
-				if (!is_surface_pixel_format_supported(pipe_ctx))
+				if (!is_surface_pixel_format_supported(pipe_ctx,
+						context->res_ctx.pool->underlay_pipe_index))
 					return DC_SURFACE_PIXEL_FORMAT_UNSUPPORTED;
 
 				if (!pipe_ctx->tg->funcs->validate_timing(
@@ -764,7 +765,8 @@ enum dc_status dce110_validate_bandwidth(
 
 	bool all_displays_in_sync = true;
 	struct dc_crtc_timing prev_timing;
-	struct pipe_ctx *underlay_pipe_ctx = &context->res_ctx.pipe_ctx[DCE110_UNDERLAY_IDX];
+	unsigned int underlay_idx = context->res_ctx.pool->underlay_pipe_index;
+	struct pipe_ctx *underlay_pipe_ctx = &context->res_ctx.pipe_ctx[underlay_idx];
 	struct bw_calcs_input_single_display *underlay_input = &context->
 		bw_mode_data.displays_data[number_of_displays];
 
@@ -1020,19 +1022,21 @@ static struct pipe_ctx *dce110_acquire_idle_pipe_for_layer(
                 struct resource_context *res_ctx,
                 struct core_stream *stream)
 {
-        struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX];
+        unsigned int underlay_idx = res_ctx->pool->underlay_pipe_index;
+        struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];
  
-        if (res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX].stream) {
+        if (res_ctx->pipe_ctx[underlay_idx].stream) {
                 return NULL;
         }
- 
-        pipe_ctx->tg = res_ctx->pool->timing_generators[DCE110_UNDERLAY_IDX];
-        pipe_ctx->mi = res_ctx->pool->mis[DCE110_UNDERLAY_IDX];
-        /*pipe_ctx->ipp = res_ctx->pool->ipps[DCE110_UNDERLAY_IDX];*/
-        pipe_ctx->xfm = res_ctx->pool->transforms[DCE110_UNDERLAY_IDX];
-        pipe_ctx->opp = res_ctx->pool->opps[DCE110_UNDERLAY_IDX];
+
+        pipe_ctx->tg = res_ctx->pool->timing_generators[underlay_idx];
+        pipe_ctx->mi = res_ctx->pool->mis[underlay_idx];
+        /*pipe_ctx->ipp = res_ctx->pool->ipps[underlay_idx];*/
+        pipe_ctx->xfm = res_ctx->pool->transforms[underlay_idx];
+        pipe_ctx->opp = res_ctx->pool->opps[underlay_idx]; 
         pipe_ctx->dis_clk = res_ctx->pool->display_clock;
-        pipe_ctx->pipe_idx = DCE110_UNDERLAY_IDX;
+ 
+        pipe_ctx->pipe_idx = underlay_idx; 
  
         pipe_ctx->stream = stream;
  
@@ -1122,256 +1126,282 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 		1000);
 }
 
-bool dce110_construct_resource_pool(
-	struct adapter_service *as,
-	uint8_t num_virtual_links,
-	struct core_dc *dc,
-	struct resource_pool *pool)
+static bool construct(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc,
+        struct dce110_resource_pool *pool,
+        struct hw_asic_id asic_id)
 {
-	unsigned int i;
-	struct audio_init_data audio_init_data = { 0 };
-	struct dc_context *ctx = dc->ctx;
-	struct firmware_info info;
-	struct dc_bios *bp;
-
-	pool->adapter_srv = as;
-	pool->funcs = &dce110_res_pool_funcs;
-
-	/*************************************************
-	 *  Resource + asic cap harcoding                *
-	 *************************************************/
-	pool->pipe_count = 3;
-	pool->stream_enc_count = 3;
+        unsigned int i;
+        struct audio_init_data audio_init_data = { 0 };
+        struct dc_context *ctx = dc->ctx;
+        struct firmware_info info;
+        struct dc_bios *bp;
+
+        pool->base.adapter_srv = as;
+        pool->base.funcs = &dce110_res_pool_funcs;
+
+        /*************************************************
+         *  Resource + asic cap harcoding                *
+         *************************************************/
+        pool->base.pipe_count = 3;
+        pool->base.underlay_pipe_index = 3;
+ 
+        if (ASIC_REV_IS_STONEY(asic_id.hw_internal_rev)) {
+                pool->base.pipe_count = 2;
+                pool->base.underlay_pipe_index = 2;
+        }
  
+        pool->base.stream_enc_count = 3;
         dc->public.caps.max_downscale_ratio = 150;
         dc->public.caps.i2c_speed_in_khz = 100;
 
-	/*************************************************
-	 *  Create resources                             *
-	 *************************************************/
+        /*************************************************
+         *  Create resources                             *
+         *************************************************/
 
 
-	pool->stream_engines.engine.ENGINE_ID_DIGA = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGB = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGC = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGD = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGE = 1;
-	pool->stream_engines.engine.ENGINE_ID_DIGF = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGA = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGB = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGC = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGD = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGE = 1;
+        pool->base.stream_engines.engine.ENGINE_ID_DIGF = 1;
 
-	bp = dal_adapter_service_get_bios_parser(as);
+        bp = dal_adapter_service_get_bios_parser(as);
 
-	if (dal_adapter_service_get_firmware_info(as, &info) &&
-		info.external_clock_source_frequency_for_dp != 0) {
-		pool->dp_clock_source =
-				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
+        if (dal_adapter_service_get_firmware_info(as, &info) &&
+                info.external_clock_source_frequency_for_dp != 0) {
+                pool->base.dp_clock_source =
+                                dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL);
 
-		pool->clock_sources[0] =
-				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce110_clk_src_reg_offsets[0]);
-		pool->clock_sources[1] =
-				dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce110_clk_src_reg_offsets[1]);
+                pool->base.clock_sources[0] =
+                                dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &dce110_clk_src_reg_offsets[0]);
+                pool->base.clock_sources[1] =
+                                dce110_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &dce110_clk_src_reg_offsets[1]);
 
-		pool->clk_src_count = 2;
+                pool->base.clk_src_count = 2;
 
-		/* TODO: find out if CZ support 3 PLLs */
-	}
+                /* TODO: find out if CZ support 3 PLLs */
+        }
 
-	if (pool->dp_clock_source == NULL) {
-		dm_error("DC: failed to create dp clock source!\n");
-		BREAK_TO_DEBUGGER();
-		goto clk_src_create_fail;
-	}
+        if (pool->base.dp_clock_source == NULL) {
+                dm_error("DC: failed to create dp clock source!\n");
+                BREAK_TO_DEBUGGER();
+                goto clk_src_create_fail;
+        }
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] == NULL) {
+                        dm_error("DC: failed to create clock sources!\n");
+                        BREAK_TO_DEBUGGER();
+                        goto clk_src_create_fail;
+                }
+        }
 
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] == NULL) {
-			dm_error("DC: failed to create clock sources!\n");
-			BREAK_TO_DEBUGGER();
-			goto clk_src_create_fail;
-		}
-	}
+        pool->base.display_clock = dal_display_clock_dce110_create(ctx, as);
+        if (pool->base.display_clock == NULL) {
+                dm_error("DC: failed to create display clock!\n");
+                BREAK_TO_DEBUGGER();
+                goto disp_clk_create_fail;
+        }
 
-	pool->display_clock = dal_display_clock_dce110_create(ctx, as);
-	if (pool->display_clock == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto disp_clk_create_fail;
-	}
+        {
+                struct irq_service_init_data init_data;
+                init_data.ctx = dc->ctx;
+                pool->base.irqs = dal_irq_service_create(
+                                dal_adapter_service_get_dce_version(
+                                        pool->base.adapter_srv),
+                                &init_data);
+                if (!pool->base.irqs)
+                        goto irqs_create_fail;
 
-	{
-		struct irq_service_init_data init_data;
-		init_data.ctx = dc->ctx;
-		pool->irqs = dal_irq_service_create(
-				dal_adapter_service_get_dce_version(
-					dc->res_pool.adapter_srv),
-				&init_data);
-		if (!pool->irqs)
-			goto irqs_create_fail;
+        }
 
-	}
+        pool->base.scaler_filter = dal_scaler_filter_create(ctx);
+        if (pool->base.scaler_filter == NULL) {
+                BREAK_TO_DEBUGGER();
+                dm_error("DC: failed to create filter!\n");
+                goto filter_create_fail;
+        }
 
-	pool->scaler_filter = dal_scaler_filter_create(ctx);
-	if (pool->scaler_filter == NULL) {
-		BREAK_TO_DEBUGGER();
-		dm_error("DC: failed to create filter!\n");
-		goto filter_create_fail;
-	}
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		pool->timing_generators[i] = dce110_timing_generator_create(
-				as, ctx, i, &dce110_tg_offsets[i]);
-		if (pool->timing_generators[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create tg!\n");
-			goto controller_create_fail;
-		}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                pool->base.timing_generators[i] = dce110_timing_generator_create(
+                                as, ctx, i, &dce110_tg_offsets[i]);
+                if (pool->base.timing_generators[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create tg!\n");
+                        goto controller_create_fail;
+                }
 
                 pool->base.mis[i] = dce110_mem_input_create(ctx, as, i,
-				&dce110_mi_reg_offsets[i]);
-		if (pool->mis[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create memory input!\n");
-			goto controller_create_fail;
-		}
-
-		pool->ipps[i] = dce110_ipp_create(ctx, i, &dce110_ipp_reg_offsets[i]);
-		if (pool->ipps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create input pixel processor!\n");
-			goto controller_create_fail;
-		}
-
-		pool->transforms[i] = dce110_transform_create(
-					ctx, i, &dce110_xfm_offsets[i]);
-		if (pool->transforms[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create transform!\n");
-			goto controller_create_fail;
-		}
-		pool->transforms[i]->funcs->transform_set_scaler_filter(
-				pool->transforms[i],
-				pool->scaler_filter);
-
-		pool->opps[i] = dce110_opp_create(ctx, i, &dce110_opp_reg_offsets[i]);
-		if (pool->opps[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error(
-				"DC: failed to create output pixel processor!\n");
-			goto controller_create_fail;
-		}
-	}
-	/* TODO: failure? */
-	underlay_create(ctx, pool);
-
-	audio_init_data.as = as;
-	audio_init_data.ctx = ctx;
-	pool->audio_count = 0;
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct graphics_object_id obj_id;
-
-		obj_id = dal_adapter_service_enum_audio_object(as, i);
-		if (false == dal_graphics_object_id_is_valid(obj_id)) {
-			/* no more valid audio objects */
-			break;
-		}
-
-		audio_init_data.audio_stream_id = obj_id;
-		pool->audios[i] = dal_audio_create(&audio_init_data);
-		if (pool->audios[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create DPPs!\n");
-			goto audio_create_fail;
-		}
-		pool->audio_count++;
-	}
-
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		/* TODO: rework fragile code*/
-		if (pool->stream_engines.u_all & 1 << i) {
-			pool->stream_enc[i] = dce110_stream_encoder_create(
-				i, dc->ctx,
-				dal_adapter_service_get_bios_parser(as),
-				&stream_enc_regs[i]);
-			if (pool->stream_enc[i] == NULL) {
-				BREAK_TO_DEBUGGER();
-				dm_error("DC: failed to create stream_encoder!\n");
-				goto stream_enc_create_fail;
-			}
-		}
-	}
-
-	for (i = 0; i < num_virtual_links; i++) {
-		pool->stream_enc[pool->stream_enc_count] =
-			virtual_stream_encoder_create(
-				dc->ctx,
-				dal_adapter_service_get_bios_parser(as));
+                                &dce110_mi_reg_offsets[i]);
+                if (pool->base.mis[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create memory input!\n");
+                        goto controller_create_fail;
+                }
+
+                pool->base.ipps[i] = dce110_ipp_create(ctx, i, &dce110_ipp_reg_offsets[i]);
+                if (pool->base.ipps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create input pixel processor!\n");
+                        goto controller_create_fail;
+   }
+
+                pool->base.transforms[i] = dce110_transform_create(
+                                        ctx, i, &dce110_xfm_offsets[i]);
+                if (pool->base.transforms[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create transform!\n");
+                        goto controller_create_fail;
+                }
+                pool->base.transforms[i]->funcs->transform_set_scaler_filter(
+                                pool->base.transforms[i],
+                                pool->base.scaler_filter);
+
+                pool->base.opps[i] = dce110_opp_create(ctx, i, &dce110_opp_reg_offsets[i]);
+                if (pool->base.opps[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error(
+                                "DC: failed to create output pixel processor!\n");
+                        goto controller_create_fail;
+                }
+        }
+        /* TODO: failure? */
+        underlay_create(ctx, &pool->base);
+
+        audio_init_data.as = as;
+        audio_init_data.ctx = ctx;
+        pool->base.audio_count = 0;
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                struct graphics_object_id obj_id;
+
+                obj_id = dal_adapter_service_enum_audio_object(as, i);
+                if (false == dal_graphics_object_id_is_valid(obj_id)) {
+                        /* no more valid audio objects */
+                        break;
+                }
+
+                audio_init_data.audio_stream_id = obj_id;
+                pool->base.audios[i] = dal_audio_create(&audio_init_data);
+                if (pool->base.audios[i] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create DPPs!\n");
+                        goto audio_create_fail;
+                }
+                pool->base.audio_count++;
+        }
 
-		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create stream_encoder!\n");
-			goto stream_enc_create_fail;
-		}
-		pool->stream_enc_count++;
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                /* TODO: rework fragile code*/
+                if (pool->base.stream_engines.u_all & 1 << i) {
+                        pool->base.stream_enc[i] = dce110_stream_encoder_create(
+                                i, dc->ctx,
+                                dal_adapter_service_get_bios_parser(as),
+                                &stream_enc_regs[i]);
+                        if (pool->base.stream_enc[i] == NULL) {
+                                BREAK_TO_DEBUGGER();
+                                dm_error("DC: failed to create stream_encoder!\n");
+                                goto stream_enc_create_fail;
+                        }
+                }
+        }
 
+        for (i = 0; i < num_virtual_links; i++) {
+                pool->base.stream_enc[pool->base.stream_enc_count] =
+                        virtual_stream_encoder_create(
+                                dc->ctx,
+                                dal_adapter_service_get_bios_parser(as));
+
+                if (pool->base.stream_enc[pool->base.stream_enc_count] == NULL) {
+                        BREAK_TO_DEBUGGER();
+                        dm_error("DC: failed to create stream_encoder!\n");
+                        goto stream_enc_create_fail;
+                }
+                pool->base.stream_enc_count++;
+        }
 
-	/* Create hardware sequencer */
-	if (!dce110_hw_sequencer_construct(dc))
-		goto stream_enc_create_fail;
+        /* Create hardware sequencer */
+        if (!dce110_hw_sequencer_construct(dc))
+                goto stream_enc_create_fail;
 
-	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_CARRIZO);
+        bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, BW_CALCS_VERSION_CARRIZO);
 
-	bw_calcs_data_update_from_pplib(dc);
+        bw_calcs_data_update_from_pplib(dc);
 
-	return true;
+        return true;
 
 stream_enc_create_fail:
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
 audio_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->audios[i] != NULL)
-			dal_audio_destroy(&pool->audios[i]);
-	}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.audios[i] != NULL)
+                        dal_audio_destroy(&pool->base.audios[i]);
+        }
 
 controller_create_fail:
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			pool->opps[i]->funcs->opp_destroy(&pool->opps[i]);
-
-		if (pool->transforms[i] != NULL)
-			dce110_transform_destroy(&pool->transforms[i]);
-
-		if (pool->ipps[i] != NULL)
-			dce110_ipp_destroy(&pool->ipps[i]);
-
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
-
-		if (pool->timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        pool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);
+
+                if (pool->base.transforms[i] != NULL)
+                        dce110_transform_destroy(&pool->base.transforms[i]);
+
+                if (pool->base.ipps[i] != NULL)
+                        dce110_ipp_destroy(&pool->base.ipps[i]);
+
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
+               }
+
+                if (pool->base.timing_generators[i] != NULL)    {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
 filter_create_fail:
-	dal_irq_service_destroy(&pool->irqs);
+        dal_irq_service_destroy(&pool->base.irqs);
 
 irqs_create_fail:
-	dal_display_clock_destroy(&pool->display_clock);
+        dal_display_clock_destroy(&pool->base.display_clock);
 
 disp_clk_create_fail:
 clk_src_create_fail:
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL)
-			dce110_clock_source_destroy(&pool->clock_sources[i]);
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL)
+                        dce110_clock_source_destroy(&pool->base.clock_sources[i]);
+        }
 
-	return false;
+        return false;
 }
+
+struct resource_pool *dce110_create_resource_pool(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc,
+        struct hw_asic_id asic_id)
+{
+        struct dce110_resource_pool *pool =
+                dm_alloc(sizeof(struct dce110_resource_pool));
+
+        if (!pool)
+                return NULL;
+
+        if (construct(as, num_virtual_links, dc, pool, asic_id))
+                return &pool->base;
+
+        BREAK_TO_DEBUGGER();
+        return NULL;
+}
+
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
index 3a93c75..9cdfd53 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
@@ -40,6 +40,12 @@ bool dce110_construct_resource_pool(
 	struct core_dc *dc,
 	struct resource_pool *pool);
 
+struct resource_pool *dce110_create_resource_pool(
+        struct adapter_service *as,
+        uint8_t num_virtual_links,
+        struct core_dc *dc,
+        struct hw_asic_id asic_id);
+
 void dce110_destruct_resource_pool(struct resource_pool *pool);
 
 #endif /* __DC_RESOURCE_DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
index c96c335..c06f93b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
@@ -165,7 +165,7 @@ static bool dce112_pipe_control_lock(
 }
 
 static void dce112_set_blender_mode(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	uint32_t mode)
 {
@@ -175,6 +175,7 @@ static void dce112_set_blender_mode(
 	uint32_t blnd_mode = 0;
 	uint32_t feedthrough = 1;
 	uint32_t multiplied_mode = 0;
+	struct dc_context *ctx = dc->ctx;
 
 	switch (mode) {
 	case BLENDER_MODE_OTHER_PIPE:
@@ -320,13 +321,14 @@ static void dce112_init_pte(struct dc_context *ctx)
 }
 
 static bool dce112_enable_display_power_gating(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
 {
 	enum bp_result bp_result = BP_RESULT_OK;
 	enum bp_pipe_control_action cntl;
+	struct dc_context *ctx = dc->ctx;
 
 	if (IS_FPGA_MAXIMUS_DC(ctx->dce_environment))
 		return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
index 3a383f5..29ac95f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
@@ -142,7 +142,7 @@ static bool dce80_pipe_control_lock(
 }
 
 static void dce80_set_blender_mode(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	uint32_t mode)
 {
@@ -151,6 +151,8 @@ static void dce80_set_blender_mode(
 	uint32_t blnd_mode;
 	uint32_t feedthrough = 0;
 
+	struct dc_context *ctx = dc->ctx;
+
 	switch (mode) {
 	case BLENDER_MODE_OTHER_PIPE:
 		feedthrough = 0;
@@ -179,13 +181,14 @@ static void dce80_set_blender_mode(
 }
 
 static bool dce80_enable_display_power_gating(
-	struct dc_context *ctx,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
 {
 	enum bp_result bp_result = BP_RESULT_OK;
 	enum bp_pipe_control_action cntl;
+	struct dc_context *ctx = dc->ctx;
 
 	if (power_gating == PIPE_GATING_CONTROL_INIT)
 		cntl = ASIC_PIPE_INIT;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 03ca083..0a944e9 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -236,6 +236,7 @@ struct resource_pool {
 	struct stream_encoder *stream_enc[MAX_PIPES * 2];
 
 	unsigned int pipe_count;
+	unsigned int underlay_pipe_index;
 	unsigned int stream_enc_count;
 
 	union supported_stream_engines stream_engines;
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 4868b3a..9cad1b4 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -107,7 +107,7 @@ struct hw_sequencer_funcs {
 					bool clock_gating);
 
 	bool (*enable_display_power_gating)(
-					struct dc_context *ctx,
+					struct core_dc *dc,
 					uint8_t controller_id,
 					struct dc_bios *dcb,
 					enum pipe_gating_control power_gating);
@@ -128,7 +128,7 @@ struct hw_sequencer_funcs {
 				bool lock);
 
 	void (*set_blender_mode)(
-				struct dc_context *ctx,
+				struct core_dc *dc,
 				uint8_t controller_id,
 				uint32_t mode);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index b467566..a5abaed 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -32,16 +32,15 @@
 
 /* TODO unhardcode, 4 for CZ*/
 #define MEMORY_TYPE_MULTIPLIER 4
-#define DCE110_UNDERLAY_IDX 3
 
 enum dce_version resource_parse_asic_id(
 		struct hw_asic_id asic_id);
 
-bool dc_construct_resource_pool(
-		struct adapter_service *adapter_serv,
-		struct core_dc *dc,
-		int num_virtual_links,
-		enum dce_version dc_version);
+struct resource_pool *dc_create_resource_pool(struct adapter_service *adapter_serv,
+                                struct core_dc *dc,
+                                int num_virtual_links,
+                                enum dce_version dc_version,
+                                struct hw_asic_id asic_id);
 
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
-- 
2.7.4

