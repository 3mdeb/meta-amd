From 09ab9acaa81641e8edaeb0ae7de1e8a6c347fcc9 Mon Sep 17 00:00:00 2001
From: Yong Zhao <yong.zhao@amd.com>
Date: Fri, 13 May 2016 19:52:57 -0400
Subject: [PATCH 1560/1722] drm/amdkfd: Fix a potential counter overflow

When the timeout parameter used is not a multiple of 20, the loop
will never end. This commit fixes that.

Change-Id: I718bfa489e0074d7639e0f503e73c12ddbd419db
Signed-off-by: Yong Zhao <yong.zhao@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c | 14 ++++++++------
 drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c | 13 +++++++------
 2 files changed, 15 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c
index 2029a28..b3fbe78 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c
@@ -473,8 +473,10 @@ static int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,
 {
 	struct amdgpu_device *adev = get_amdgpu_device(kgd);
 	uint32_t temp;
+	int timeout_signed = timeout;
 
 	acquire_queue(kgd, pipe_id, queue_id);
+
 	WREG32(mmCP_HQD_PQ_DOORBELL_CONTROL, 0);
 
 	WREG32(mmCP_HQD_DEQUEUE_REQUEST, reset_type);
@@ -483,14 +485,13 @@ static int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,
 		temp = RREG32(mmCP_HQD_ACTIVE);
 		if (!(temp & CP_HQD_ACTIVE__ACTIVE_MASK))
 			break;
-		if (timeout == 0) {
-			pr_err("kfd: cp queue preemption time out (%dms)\n",
-				temp);
+		if (timeout_signed <= 0) {
+			pr_err("kfd: cp queue preemption time out\n");
 			release_queue(kgd);
 			return -ETIME;
 		}
 		msleep(20);
-		timeout -= 20;
+		timeout_signed -= 20;
 	}
 
 	release_queue(kgd);
@@ -504,6 +505,7 @@ static int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,
 	struct cik_sdma_rlc_registers *m;
 	uint32_t sdma_base_addr;
 	uint32_t temp;
+	int timeout_signed = timeout;
 
 	m = get_sdma_mqd(mqd);
 	sdma_base_addr = get_sdma_base_addr(m);
@@ -516,10 +518,10 @@ static int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,
 		temp = RREG32(sdma_base_addr + mmSDMA0_RLC0_CONTEXT_STATUS);
 		if (temp & SDMA0_STATUS_REG__RB_CMD_IDLE_MASK)
 			break;
-		if (timeout == 0)
+		if (timeout_signed <= 0)
 			return -ETIME;
 		msleep(20);
-		timeout -= 20;
+		timeout_signed -= 20;
 	}
 
 	WREG32(sdma_base_addr + mmSDMA0_RLC0_DOORBELL, 0);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c
index 2a2286a..cb708c1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c
@@ -482,6 +482,7 @@ static int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,
 {
 	struct amdgpu_device *adev = get_amdgpu_device(kgd);
 	uint32_t temp;
+	int timeout_signed = timeout;
 
 	acquire_queue(kgd, pipe_id, queue_id);
 
@@ -491,14 +492,13 @@ static int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,
 		temp = RREG32(mmCP_HQD_ACTIVE);
 		if (!(temp & CP_HQD_ACTIVE__ACTIVE_MASK))
 			break;
-		if (timeout == 0) {
-			pr_err("kfd: cp queue preemption time out (%dms)\n",
-				temp);
+		if (timeout_signed <= 0) {
+			pr_err("kfd: cp queue preemption time out.\n");
 			release_queue(kgd);
 			return -ETIME;
 		}
 		msleep(20);
-		timeout -= 20;
+		timeout_signed -= 20;
 	}
 
 	release_queue(kgd);
@@ -512,6 +512,7 @@ static int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,
 	struct vi_sdma_mqd *m;
 	uint32_t sdma_base_addr;
 	uint32_t temp;
+	int timeout_signed = timeout;
 
 	m = get_sdma_mqd(mqd);
 	sdma_base_addr = get_sdma_base_addr(m);
@@ -524,10 +525,10 @@ static int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,
 		temp = RREG32(sdma_base_addr + mmSDMA0_RLC0_CONTEXT_STATUS);
 		if (temp & SDMA0_RLC0_CONTEXT_STATUS__IDLE_MASK)
 			break;
-		if (timeout == 0)
+		if (timeout_signed <= 0)
 			return -ETIME;
 		msleep(20);
-		timeout -= 20;
+		timeout_signed -= 20;
 	}
 
 	WREG32(sdma_base_addr + mmSDMA0_RLC0_DOORBELL, 0);
-- 
2.7.4

