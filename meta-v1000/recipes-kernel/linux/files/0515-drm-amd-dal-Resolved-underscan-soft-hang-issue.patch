From 33bc9d78692801b3366eba6b57a6c781e778376e Mon Sep 17 00:00:00 2001
From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Fri, 27 May 2016 14:34:27 -0400
Subject: [PATCH 0515/1722] drm/amd/dal: Resolved underscan soft hang issue.

Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    | 55 +++++++++++++++++-----
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  4 --
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    | 11 ++++-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    | 11 ++++-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    | 15 ++++--
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  | 11 ++++-
 6 files changed, 82 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index 60d8ce5..d04766c 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -2457,9 +2457,13 @@ static uint32_t add_val_sets_surface(
 
 static uint32_t update_in_val_sets_target(
 	struct dc_validation_set *val_sets,
+	struct drm_crtc **crtcs,
+	struct drm_display_mode **modes,
 	uint32_t set_count,
 	const struct dc_target *old_target,
-	const struct dc_target *new_target)
+	const struct dc_target *new_target,
+	struct drm_crtc *crtc,
+	struct drm_display_mode *mode)
 {
 	uint32_t i = 0;
 
@@ -2470,6 +2474,8 @@ static uint32_t update_in_val_sets_target(
 	}
 
 	val_sets[i].target = new_target;
+	crtcs[i] = crtc;
+	modes[i] = mode;
 
 	if (i == set_count) {
 		/* nothing found. add new one to the end */
@@ -2513,11 +2519,14 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 	struct drm_plane_state *plane_state;
 	int i;
 	int j;
+	int k;
 	int ret;
 	int set_count;
 	int new_target_count;
 	struct dc_validation_set set[MAX_TARGETS] = {{ 0 }};
 	struct dc_target *new_targets[MAX_TARGETS] = { 0 };
+	struct drm_display_mode *mode_set[MAX_TARGETS] = { 0 };
+	struct drm_crtc *crtc_set[MAX_TARGETS] = { 0 };
 	struct amdgpu_device *adev = dev->dev_private;
 	struct dc *dc = adev->dm.dc;
 	bool need_to_validate = false;
@@ -2541,6 +2550,8 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 
 		if (acrtc->target) {
 			set[set_count].target = acrtc->target;
+			mode_set[set_count] = &crtc->mode;
+			crtc_set[set_count] = crtc;
 			++set_count;
 		}
 	}
@@ -2599,12 +2610,16 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 			}
 
 			new_targets[new_target_count] = new_target;
-
 			set_count = update_in_val_sets_target(
 					set,
+					crtc_set,
+					mode_set,
 					set_count,
 					acrtc->target,
-					new_target);
+					new_target,
+					crtc,
+					&mode);
+
 			new_target_count++;
 			need_to_validate = true;
 			break;
@@ -2630,15 +2645,33 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 			struct drm_plane_state *old_plane_state = plane->state;
 			struct drm_framebuffer *fb = plane_state->fb;
 			struct drm_crtc *crtc = plane_state->crtc;
-			struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+			struct drm_connector *connector;
+			struct drm_connector_state *con_state;
+			struct dm_connector_state *dm_state = NULL;
 
-			if (!fb || acrtc->target != set[i].target)
+			if (!fb)
+				continue;
+
+			if (crtc_set[i] != crtc)
 				continue;
 
 			if (!crtc->state->planes_changed)
 				continue;
 
-			if (!page_flip_needed(plane_state, old_plane_state)) {
+			for_each_connector_in_state(state, connector, con_state, k) {
+				if (con_state->crtc == crtc) {
+					dm_state = to_dm_connector_state(con_state);
+					break;
+				}
+			}
+
+			if (dm_state) {
+					calculate_stream_scaling_settings(mode_set[i],
+						set[i].target->streams[0],
+						dm_state);
+			}
+
+			if (!page_flip_needed(plane_state, old_plane_state) || dm_state) {
 				struct dc_surface *surface =
 					dc_create_surface(dc);
 
@@ -2647,14 +2680,14 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 					plane_state);
 
 				add_val_sets_surface(
-					set,
-					set_count,
-					acrtc->target,
-					surface);
+							set,
+							set_count,
+							set[i].target,
+							surface);
+
 				need_to_validate = true;
 			}
 		}
-
 	}
 
 	if (need_to_validate == false || set_count == 0 ||
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 1979170..3e60258 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -565,10 +565,6 @@ bool resource_validate_attach_surfaces(
 	int i, j;
 
 	for (i = 0; i < set_count; i++) {
-		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
-
 		for (j = 0; j < old_context->target_count; j++)
 			if (is_target_unchanged(
 					old_context->targets[j],
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index ebf30f9..7c56f92 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -656,17 +656,24 @@ enum dc_status dce100_validate_with_context(
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	for (i = 0; i < set_count; i++) {
+		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context);
+
 	if (!resource_validate_attach_surfaces(
 			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
 
-	result = resource_map_pool_resources(dc, context);
-
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index ffa0301..e1b426e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -863,17 +863,24 @@ enum dc_status dce110_validate_with_context(
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	for (i = 0; i < set_count; i++) {
+		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context);
+
 	if (!resource_validate_attach_surfaces(
 			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
 
-	result = resource_map_pool_resources(dc, context);
-
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index de4790d..1aeabdd 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -919,13 +919,14 @@ enum dc_status dce112_validate_with_context(
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
 
 	context->res_ctx.pool = dc->res_pool;
 
-	if (!resource_validate_attach_surfaces(
-			set, set_count, dc->current_context, context)) {
-		DC_ERROR("Failed to attach surface to target!\n");
-		return DC_FAIL_ATTACH_SURFACES;
+	for (i = 0; i < set_count; i++) {
+		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
 	}
 
 	result = resource_map_pool_resources(dc, context);
@@ -933,6 +934,12 @@ enum dc_status dce112_validate_with_context(
 	if (result == DC_OK)
 		result = map_clock_resources(dc, context);
 
+	if (!resource_validate_attach_surfaces(
+			set, set_count, dc->current_context, context)) {
+		DC_ERROR("Failed to attach surface to target!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
 	if (result == DC_OK)
 		result = validate_mapped_resource(dc, context);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 6849896..c1d57f3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -611,17 +611,24 @@ enum dc_status dce80_validate_with_context(
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
 
 	context->res_ctx.pool = dc->res_pool;
 
+	for (i = 0; i < set_count; i++) {
+		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context);
+
 	if (!resource_validate_attach_surfaces(
 			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
 
-	result = resource_map_pool_resources(dc, context);
-
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
-- 
2.7.4

