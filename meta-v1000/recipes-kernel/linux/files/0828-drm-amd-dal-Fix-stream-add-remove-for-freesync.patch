From 9bfbf48db470525337a2f94e606e5a042ad212fa Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 18 Aug 2016 14:01:04 -0400
Subject: [PATCH 0828/1722] drm/amd/dal: Fix stream add/remove for freesync

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    | 77 +++++++++++++++-------
 1 file changed, 54 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index f013176..23c74e8 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -2341,6 +2341,27 @@ static bool is_scaling_state_different(
 	return false;
 }
 
+static void remove_target(struct amdgpu_device *adev, struct amdgpu_crtc *acrtc)
+{
+	int i;
+
+	/*
+	 * we evade vblanks and pflips on crtc that
+	 * should be changed
+	 */
+	manage_dm_interrupts(adev, acrtc, false);
+	/* this is the update mode case */
+	if (adev->dm.freesync_module)
+		for (i = 0; i < acrtc->target->stream_count; i++)
+			mod_freesync_remove_stream(
+					adev->dm.freesync_module,
+					acrtc->target->streams[i]);
+	dc_target_release(acrtc->target);
+	acrtc->target = NULL;
+	acrtc->otg_inst = -1;
+	acrtc->enabled = false;
+}
+
 int amdgpu_dm_atomic_commit(
 	struct drm_device *dev,
 	struct drm_atomic_state *state,
@@ -2350,7 +2371,7 @@ int amdgpu_dm_atomic_commit(
 	struct amdgpu_display_manager *dm = &adev->dm;
 	struct drm_plane *plane;
 	struct drm_plane_state *old_plane_state;
-	uint32_t i;
+	uint32_t i, j;
 	int32_t ret = 0;
 	uint32_t commit_targets_count = 0;
 	uint32_t new_crtcs_count = 0;
@@ -2452,17 +2473,8 @@ int amdgpu_dm_atomic_commit(
 				break;
 			}
 
-			if (acrtc->target) {
-				/*
-				 * we evade vblanks and pflips on crtc that
-				 * should be changed
-				 */
-				manage_dm_interrupts(adev, acrtc, false);
-				/* this is the update mode case */
-				dc_target_release(acrtc->target);
-				acrtc->target = NULL;
-				acrtc->otg_inst = -1;
-			}
+			if (acrtc->target)
+				remove_target(adev, acrtc);
 
 			/*
 			 * this loop saves set mode crtcs
@@ -2477,10 +2489,10 @@ int amdgpu_dm_atomic_commit(
 			acrtc->hw_mode = crtc->state->mode;
 			crtc->hwmode = crtc->state->mode;
 			if (adev->dm.freesync_module)
-				mod_freesync_notify_mode_change(
-					adev->dm.freesync_module,
-					new_target->streams,
-					new_target->stream_count);
+				for (j = 0; j < acrtc->target->stream_count; j++)
+					mod_freesync_add_stream(
+							adev->dm.freesync_module,
+							acrtc->target->streams[j]);
 			break;
 		}
 
@@ -2501,13 +2513,8 @@ int amdgpu_dm_atomic_commit(
 		case DM_COMMIT_ACTION_RESET:
 			DRM_INFO("Atomic commit: RESET. crtc id %d:[%p]\n", acrtc->crtc_id, acrtc);
 			/* i.e. reset mode */
-			if (acrtc->target) {
-				manage_dm_interrupts(adev, acrtc, false);
-
-				dc_target_release(acrtc->target);
-				acrtc->target = NULL;
-				acrtc->enabled = false;
-			}
+			if (acrtc->target)
+				remove_target(adev, acrtc);
 			break;
 		} /* switch() */
 	} /* for_each_crtc_in_state() */
@@ -2600,6 +2607,12 @@ int amdgpu_dm_atomic_commit(
 		 */
 		struct amdgpu_crtc *acrtc = new_crtcs[i];
 
+		if (adev->dm.freesync_module)
+			mod_freesync_notify_mode_change(
+						adev->dm.freesync_module,
+						acrtc->target->streams,
+						acrtc->target->stream_count);
+
 		manage_dm_interrupts(adev, acrtc, true);
 		dm_crtc_cursor_reset(&acrtc->base);
 
@@ -2657,6 +2670,7 @@ void dm_restore_drm_connector_state(struct drm_device *dev, struct drm_connector
 	struct dc_target *commit_targets[6];
 	struct dc_target *current_target;
 	uint32_t commit_targets_count = 0;
+	int i;
 
 	if (!aconnector->dc_sink || !connector->state || !connector->encoder)
 		return;
@@ -2708,16 +2722,33 @@ void dm_restore_drm_connector_state(struct drm_device *dev, struct drm_connector
 			}
 		}
 
+		if (adev->dm.freesync_module)
+			for (i = 0; i < disconnected_acrtc->target->stream_count; i++)
+				mod_freesync_add_stream(
+						adev->dm.freesync_module,
+						disconnected_acrtc->target->streams[i]);
+
 		/* DC is optimized not to do anything if 'targets' didn't change. */
 		if (!dc_commit_targets(dc, commit_targets,
 				commit_targets_count)) {
 			DRM_INFO("Failed to restore connector state!\n");
+			if (adev->dm.freesync_module)
+				for (i = 0; i < disconnected_acrtc->target->stream_count; i++)
+					mod_freesync_remove_stream(
+							adev->dm.freesync_module,
+							disconnected_acrtc->target->streams[i]);
 			dc_target_release(disconnected_acrtc->target);
 			disconnected_acrtc->target = current_target;
 			manage_dm_interrupts(adev, disconnected_acrtc, true);
 			return;
 		}
 
+		if (adev->dm.freesync_module)
+			for (i = 0; i < current_target->stream_count; i++)
+				mod_freesync_remove_stream(
+						adev->dm.freesync_module,
+						current_target->streams[i]);
+
 		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 			struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
 
-- 
2.7.4

