From 41c338a2d5933566af3626a275889ca2d671f01e Mon Sep 17 00:00:00 2001
From: Mykola Lysenko <mykola.lysenko@amd.com>
Date: Fri, 19 Jun 2015 11:50:22 -0400
Subject: [PATCH 359/401] drm/amd/amdgpu: [DM] Single-display
 Disconnect/Re-connect workaround

The problem:
 We don't get Set Mode call if only one display is connected, and this
 display is disconnected and connected back to the same connector.

The workaround:
1. When the last display is disconnected, simulate a hot-plug for a
 fake display which hase the same EDID as the one which was just
 disconnected, but with a mode list reduced to a single mode
 (the fail-safe mode) 640x480.
 Because of the change in mode-list we do get Set Mode.
2. When the real display is connected notify the OS about the
 new mode-list, which is different from the fake one, because
 of the difference the OS calls Set Mode again, which is exactly
 what we need.

Signed-off-by: Mykola Lysenko <mykola.lysenko@amd.com>
Reviewed-by: David Rokhvarg <David.Rokhvarg@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_dal_services.c | 33 +++++----
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c           | 94 +++++++++++++++++++++++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h           | 18 +++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c     |  9 +++
 4 files changed, 138 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dal_services.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dal_services.c
index 70b7953..f1e9831 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dal_services.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dal_services.c
@@ -256,27 +256,30 @@ void dal_notify_hotplug(
 
 	/* 1. Update status of drm connectors
 	 * 2. Send a uevent and let userspace tell us what to do */
-	drm_helper_hpd_irq_event(dev);
-
 	list_for_each_entry(connector,
 		&dev->mode_config.connector_list, head) {
 		aconnector = to_amdgpu_connector(connector);
 
 		/*aconnector->connector_id means display_index*/
-		if (aconnector->connector_id == display_index) {
-			if (is_connected)
-				drm_mode_connector_update_edid_property(
-					connector,
-					(struct edid *)
-					dal_get_display_edid(
-						adev->dm.dal,
-						display_index,
-						NULL));
-			else
-				drm_mode_connector_update_edid_property(
-					connector, NULL);
-		}
+		if (aconnector->connector_id != display_index)
+			continue;
+
+		if (is_connected) {
+			drm_mode_connector_update_edid_property(
+				connector,
+				(struct edid *)
+				dal_get_display_edid(
+					adev->dm.dal,
+					display_index,
+					NULL));
+		} else
+			drm_mode_connector_update_edid_property(
+				connector, NULL);
+
+		break;
 	}
+
+	drm_helper_hpd_irq_event(dev);
 }
 
 void dal_notify_capability_change(
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
index 883f36a..20722d0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
@@ -367,9 +367,100 @@ static void amdgpu_dm_crtc_high_irq(void *interrupt_params)
 
 }
 
+static void hpd_low_irq_helper_func(
+	void *param,
+	const struct path_mode *pm)
+{
+	uint32_t *display_index = param;
+
+	*display_index = pm->display_path_index;
+}
+
 static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 {
-	/* TODO: add implementation */
+	struct amdgpu_device *adev = interrupt_params;
+	struct dal *dal = adev->dm.dal;
+	struct drm_device *dev = adev->ddev;
+	uint32_t connected_displays = dal_get_connected_targets_vector(dal);
+	struct drm_connector *connector = NULL;
+	struct amdgpu_connector *aconnector = NULL;
+
+	if (connected_displays == 0) {
+		uint32_t display_index = INVALID_DISPLAY_INDEX;
+
+		dal_pin_active_path_modes(
+			dal,
+			&display_index,
+			INVALID_DISPLAY_INDEX,
+			hpd_low_irq_helper_func);
+
+		adev->dm.fake_display_index = display_index;
+
+		list_for_each_entry(
+			connector,
+			&dev->mode_config.connector_list,
+			head) {
+			aconnector = to_amdgpu_connector(connector);
+
+			/*aconnector->connector_id means display_index*/
+			if (aconnector->connector_id == display_index)
+				break;
+		}
+
+		/*
+		 * force connected status on fake display connector
+		 */
+		aconnector->base.status = connector_status_connected;
+
+		/*
+		 * we need to force user-space notification on changed modes
+		 */
+		drm_kms_helper_hotplug_event(dev);
+	} else if (adev->dm.fake_display_index != INVALID_DISPLAY_INDEX) {
+		/* we assume only one display is connected */
+		uint32_t connected_display_index = 0;
+
+		/* identify first connected display index */
+		while (connected_displays) {
+			if (1 & connected_displays)
+				break;
+
+			++connected_display_index;
+			connected_displays >>= 1;
+		}
+
+		/*
+		 * if there is display on another connector get connected
+		 * we need to clean-up connection status on fake display
+		 */
+		if (connected_display_index != adev->dm.fake_display_index) {
+			list_for_each_entry(
+				connector,
+				&dev->mode_config.connector_list,
+				head) {
+				aconnector = to_amdgpu_connector(connector);
+
+				/*aconnector->connector_id means display_index*/
+				if (aconnector->connector_id ==
+					adev->dm.fake_display_index)
+					break;
+			}
+
+			/*
+			 * reset connected status on fake display connector
+			 */
+			aconnector->base.status = connector_status_disconnected;
+		} else {
+			dal_reset_path_mode(
+				dal,
+				1,
+				&adev->dm.fake_display_index);
+		}
+
+		adev->dm.fake_display_index = INVALID_DISPLAY_INDEX;
+
+		drm_kms_helper_hotplug_event(dev);
+	}
 }
 
 static int dm_set_clockgating_state(void *handle,
@@ -399,6 +490,7 @@ int amdgpu_dm_init(struct amdgpu_device *adev)
 	struct drm_device *ddev = adev->ddev;
 	adev->dm.ddev = adev->ddev;
 	adev->dm.adev = adev;
+	adev->dm.fake_display_index = INVALID_DISPLAY_INDEX;
 
 	/* Zero all the fields */
 	memset(&init_data, 0, sizeof(init_data));
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
index e1da5ec..d631462 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
@@ -113,6 +113,24 @@ struct amdgpu_display_manager {
 	/* Timer-related data. */
 	struct list_head timer_handler_list;
 	struct workqueue_struct *timer_workqueue;
+
+	/*
+	 * The problem:
+	 * We don't get Set Mode call if only one display is connected, and
+	 * this display is disconnected and connected back to the same
+	 * connector.
+	 *
+	 * The workaround:
+	 * 1. When the last display is disconnected, simulate a hot-plug for a
+	 * fake display which has the same EDID as the one which was just
+	 * disconnected, but with a mode list reduced to a single mode
+	 * (the fail-safe mode) 640x480.
+	 * Because of the change in mode-list we do get Set Mode.
+	 * 2. When the real display is connected notify the OS about the
+	 * new mode-list, which is different from the fake one, because
+	 * of the difference the OS calls Set Mode again, which is exactly
+	 * what we need. */
+	uint32_t fake_display_index;
 };
 
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
index a75a6bc..acdff4b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
@@ -1358,7 +1358,16 @@ int amdgpu_display_manager_fill_modes(struct drm_connector *connector,
 				stop = true;
 			else
 				++non_filtered_modes_num;
+
+			if (adev->dm.fake_display_index ==
+				aconnector->connector_id)
+				break;
+
 		} while (!stop && dal_mode_query_select_next_refresh_rate(mq));
+
+		if (adev->dm.fake_display_index == aconnector->connector_id)
+			break;
+
 	} while (!stop && dal_mode_query_select_next_render_mode(mq));
 
 	if (stop)
-- 
1.9.1

