From 88e37198f298cb17186d10db4a93beefc519623e Mon Sep 17 00:00:00 2001
From: Wenjing Liu <Wenjing.Liu@amd.com>
Date: Thu, 18 Aug 2016 19:18:44 -0400
Subject: [PATCH 0841/1722] drm/amd/dal: Validate cur RGB quantization in
 setmode

Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c   | 21 +++++++------
 drivers/gpu/drm/amd/dal/dc/dc_hw_types.h        |  8 ++---
 drivers/gpu/drm/amd/dal/modules/color/color.c   | 40 ++++++++++++++-----------
 drivers/gpu/drm/amd/dal/modules/inc/mod_color.h | 10 ++++---
 4 files changed, 44 insertions(+), 35 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index ea494df..b36ffcf 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -1341,21 +1341,24 @@ static void set_avi_info_frame(
 			cn0_cn1;
 	}
 
-	/* TODO: un-hardcode q0_q1 */
-	if (color_space == COLOR_SPACE_SRGB)
+	/* TODO : We should handle YCC quantization */
+	/* but we do not have matrix calculation */
+	if (color_space == COLOR_SPACE_SRGB) {
 		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
 						RGB_QUANTIZATION_FULL_RANGE;
-	else if (color_space == COLOR_SPACE_SRGB_LIMITED)
+		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
+						YYC_QUANTIZATION_FULL_RANGE;
+	} else if (color_space == COLOR_SPACE_SRGB_LIMITED) {
 		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
 						RGB_QUANTIZATION_LIMITED_RANGE;
-	else
+		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
+						YYC_QUANTIZATION_LIMITED_RANGE;
+	} else {
 		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
 						RGB_QUANTIZATION_DEFAULT_RANGE;
-
-	/* TODO : We should handle YCC quantization,
-	 * but we do not have matrix calculation */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
-					YYC_QUANTIZATION_LIMITED_RANGE;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
+						YYC_QUANTIZATION_LIMITED_RANGE;
+	}
 
 	info_frame.avi_info_packet.info_packet_hdmi.bits.VIC0_VIC7 =
 					stream->public.timing.vic;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
index f6b3c00..188761d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
@@ -396,10 +396,10 @@ enum dc_color_space {
 	COLOR_SPACE_YCBCR709_LIMITED
 };
 
-enum dc_rgb_range {
-	RGB_RANGE_UNKNOWN,
-	RGB_RANGE_FULL,
-	RGB_RANGE_LIMITED
+enum dc_quantization_range {
+	QUANTIZATION_RANGE_UNKNOWN,
+	QUANTIZATION_RANGE_FULL,
+	QUANTIZATION_RANGE_LIMITED
 };
 
 /* XFM */
diff --git a/drivers/gpu/drm/amd/dal/modules/color/color.c b/drivers/gpu/drm/amd/dal/modules/color/color.c
index f4196fb..cf030b1 100644
--- a/drivers/gpu/drm/amd/dal/modules/color/color.c
+++ b/drivers/gpu/drm/amd/dal/modules/color/color.c
@@ -69,7 +69,7 @@ struct color_state {
 	struct color_range saturation;
 	struct color_range brightness;
 	struct color_range hue;
-	enum dc_rgb_range rgb_range;
+	enum dc_quantization_range preferred_quantization_range;
 };
 
 struct core_color {
@@ -1260,7 +1260,7 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 	int persistent_contrast;
 	int persistent_hue;
 	int persistent_saturation;
-	enum dc_rgb_range persistent_rgb_range;
+	enum dc_quantization_range persistent_quantization_range;
 	struct persistent_data_flag flag;
 
 	if (core_color->num_sinks < MOD_COLOR_MAX_CONCURRENT_SINKS) {
@@ -1396,14 +1396,15 @@ bool mod_color_add_sink(struct mod_color *mod_color, const struct dc_sink *sink)
 
 		if (dm_read_persistent_data(core_dc->ctx, sink,
 						COLOR_REGISTRY_NAME,
-						"rgb_range",
-						&persistent_rgb_range,
+						"preferred_quantization_range",
+						&persistent_quantization_range,
 						sizeof(int), &flag))
-			core_color->state[core_color->num_sinks].rgb_range =
-					persistent_rgb_range;
+			core_color->state[core_color->num_sinks].
+			preferred_quantization_range =
+					persistent_quantization_range;
 		else
-			core_color->state[core_color->num_sinks].rgb_range =
-					RGB_RANGE_FULL;
+			core_color->state[core_color->num_sinks].
+			preferred_quantization_range = QUANTIZATION_RANGE_FULL;
 
 		core_color->num_sinks++;
 		return true;
@@ -2051,8 +2052,9 @@ bool mod_color_set_saturation(struct mod_color *mod_color,
 	return true;
 }
 
-bool mod_color_set_rgb_range(struct mod_color *mod_color,
-		const struct dc_sink *sink, enum dc_rgb_range rgb_range)
+bool mod_color_set_preferred_quantization_range(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		enum dc_quantization_range quantization_range)
 {
 	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
 	struct core_dc *core_dc = DC_TO_CORE(core_color->dc);
@@ -2061,16 +2063,16 @@ bool mod_color_set_rgb_range(struct mod_color *mod_color,
 
 	sink_index = sink_index_from_sink(core_color, sink);
 	if (core_color->state[sink_index].
-			rgb_range != rgb_range) {
-		core_color->state[sink_index].rgb_range =
-				rgb_range;
+			preferred_quantization_range != quantization_range) {
+		core_color->state[sink_index].preferred_quantization_range =
+				quantization_range;
 		flag.save_per_edid = true;
 		flag.save_per_link = false;
 		dm_write_persistent_data(core_dc->ctx,
 					sink,
 					COLOR_REGISTRY_NAME,
-					"rgb_range",
-					&rgb_range,
+					"quantization_range",
+					&quantization_range,
 					sizeof(int),
 					&flag);
 	}
@@ -2078,13 +2080,15 @@ bool mod_color_set_rgb_range(struct mod_color *mod_color,
 	return true;
 }
 
-bool mod_color_get_rgb_range(struct mod_color *mod_color,
-		const struct dc_sink *sink, enum dc_rgb_range *rgb_range)
+bool mod_color_get_preferred_quantization_range(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		enum dc_quantization_range *quantization_range)
 {
 	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
 	unsigned int sink_index;
 
 	sink_index = sink_index_from_sink(core_color, sink);
-	*rgb_range = core_color->state[sink_index].rgb_range;
+	*quantization_range = core_color->state[sink_index].
+			preferred_quantization_range;
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h b/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
index b941160..e54fe2c 100644
--- a/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
+++ b/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
@@ -168,10 +168,12 @@ bool mod_color_set_saturation(struct mod_color *mod_color,
 		const struct dc_stream **streams, int num_streams,
 		int saturation_value);
 
-bool mod_color_set_rgb_range(struct mod_color *mod_color,
-		const struct dc_sink *sink, enum dc_rgb_range rgb_range);
+bool mod_color_set_preferred_quantization_range(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		enum dc_quantization_range quantization_range);
 
-bool mod_color_get_rgb_range(struct mod_color *mod_color,
-		const struct dc_sink *sink, enum dc_rgb_range *rgb_range);
+bool mod_color_get_preferred_quantization_range(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		enum dc_quantization_range *quantization_range);
 
 #endif /* MOD_COLOR_H_ */
-- 
2.7.4

