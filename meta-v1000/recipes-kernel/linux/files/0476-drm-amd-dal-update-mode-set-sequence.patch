From e8d997d56fde4fc05d5795bf2c5718b631b2a5be Mon Sep 17 00:00:00 2001
From: Hersen Wu <hersenxs.wu@amd.com>
Date: Tue, 10 May 2016 16:16:04 -0400
Subject: [PATCH 0476/1722] drm/amd/dal: update mode set sequence

Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 41 ++++++++++++----------
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 10 +-----
 drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h      |  1 +
 3 files changed, 24 insertions(+), 28 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 98d0362..7c715e9 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -375,7 +375,10 @@ static int8_t acquire_first_free_underlay(
 			DCE110_UNDERLAY_IDX,
 			dcb, PIPE_GATING_CONTROL_DISABLE);
 
-		core_dc->hwss.enable_memory_request(pipe_ctx, false);
+		if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
+			dm_error("DC: failed to blank crtc!\n");
+			BREAK_TO_DEBUGGER();
+		}
 
 		if (!pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
 			BREAK_TO_DEBUGGER();
@@ -536,9 +539,7 @@ static bool targets_changed(
 	return false;
 }
 
-static void target_enable_memory_requests(
-		struct core_dc *core_dc,
-		struct dc_target *dc_target,
+static void target_enable_memory_requests(struct dc_target *dc_target,
 		struct resource_context *res_ctx)
 {
 	uint8_t i, j;
@@ -546,19 +547,21 @@ static void target_enable_memory_requests(
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
+			struct timing_generator *tg = res_ctx->pipe_ctx[j].tg;
+
 			if (res_ctx->pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(target->public.streams[i]))
 				continue;
 
-			core_dc->hwss.enable_memory_request(
-					&res_ctx->pipe_ctx[j], true);
+			if (!tg->funcs->set_blank(tg, false)) {
+				dm_error("DC: failed to unblank crtc!\n");
+				BREAK_TO_DEBUGGER();
+			}
 		}
 	}
 }
 
-static void target_disable_memory_requests(
-		struct core_dc *core_dc,
-		struct dc_target *dc_target,
+static void target_disable_memory_requests(struct dc_target *dc_target,
 		struct resource_context *res_ctx)
 {
 	uint8_t i, j;
@@ -566,12 +569,16 @@ static void target_disable_memory_requests(
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
+			struct timing_generator *tg = res_ctx->pipe_ctx[j].tg;
+
 			if (res_ctx->pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(target->public.streams[i]))
 				continue;
 
-			core_dc->hwss.enable_memory_request(
-					&res_ctx->pipe_ctx[j], false);
+			if (!tg->funcs->set_blank(tg, true)) {
+				dm_error("DC: failed to blank crtc!\n");
+				BREAK_TO_DEBUGGER();
+			}
 		}
 	}
 }
@@ -763,7 +770,6 @@ bool dc_commit_targets(
 	for (i = 0; i < core_dc->current_context.target_count; i++) {
 		/*TODO: optimize this to happen only when necessary*/
 		target_disable_memory_requests(
-				core_dc,
 				&core_dc->current_context.targets[i]->public,
 				&core_dc->current_context.res_ctx);
 	}
@@ -777,9 +783,7 @@ bool dc_commit_targets(
 		struct core_sink *sink = DC_SINK_TO_CORE(dc_target->streams[0]->sink);
 
 		if (context->target_status[i].surface_count > 0)
-			target_enable_memory_requests(
-					core_dc,
-					dc_target,
+			target_enable_memory_requests(dc_target,
 					&core_dc->current_context.res_ctx);
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
@@ -792,7 +796,8 @@ bool dc_commit_targets(
 
 	program_timing_sync(core_dc, context);
 
-	pplib_apply_display_requirements(core_dc, context, &context->pp_display_cfg);
+	pplib_apply_display_requirements(core_dc,
+			context, &context->pp_display_cfg);
 
 	resource_validate_ctx_destruct(&core_dc->current_context);
 
@@ -901,9 +906,7 @@ bool dc_commit_surfaces_to_target(
 	}
 
 	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
-		target_disable_memory_requests(
-				core_dc,
-				dc_target,
+		target_disable_memory_requests(dc_target,
 				&core_dc->current_context.res_ctx);
 
 	for (i = 0; i < new_surface_count; i++)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 39f3966..5f098a3f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1622,13 +1622,6 @@ static void init_hw(struct core_dc *dc)
 	}
 }
 
-static void enable_memory_request(
-	struct pipe_ctx *pipe_ctx,
-	bool enable)
-{
-	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, enable);
-}
-
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = apply_ctx_to_hw,
@@ -1650,8 +1643,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.clock_gating_power_up = dal_dc_clock_gating_dce110_power_up,/*todo*/
 	.set_display_clock = set_display_clock,
 	.set_displaymarks = set_displaymarks,
-	.set_drr = set_drr,
-	.enable_memory_request = enable_memory_request
+	.set_drr = set_drr
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
index 6d7412c..40c6cf8 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
@@ -67,6 +67,7 @@ struct mem_input_funcs {
 		enum dc_rotation_angle rotation);
 
 	void (*wait_for_no_surface_update_pending)(struct mem_input *mem_input);
+	void (*disable_request)(struct mem_input *mem_input);
 };
 
 #endif
-- 
2.7.4

