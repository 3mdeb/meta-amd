From 7faf187d881d9a761182cfb04ab4c8aba84b1bf7 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Thu, 25 Feb 2016 16:09:50 -0500
Subject: [PATCH 0844/1110] drm/amd/dal: add input csc for underlay

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    |   2 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_target.c        |   2 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |   2 +-
 drivers/gpu/drm/amd/dal/dc/dc_hw_types.h           |  11 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  56 ++----
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c   |   5 +
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h     |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c |  48 ++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c   | 212 ++++++++++++++++++---
 .../drm/amd/dal/dc/dce110/dce110_opp_formatter.c   |   4 +-
 .../amd/dal/dc/dce110/dce110_timing_generator.c    |  48 +----
 .../amd/dal/dc/dce110/dce110_timing_generator.h    |   6 +-
 .../amd/dal/dc/dce110/dce110_timing_generator_v.c  |  34 +---
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform.c   |   3 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform.h   |   1 +
 .../amd/dal/dc/dce110/dce110_transform_bit_depth.c |   7 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h       |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c   |  48 ++---
 .../gpu/drm/amd/dal/dc/dce80/dce80_opp_formatter.c |   4 +-
 drivers/gpu/drm/amd/dal/dc/inc/opp.h               |   7 +-
 drivers/gpu/drm/amd/dal/dc/inc/timing_generator.h  |   4 +-
 drivers/gpu/drm/amd/dal/dc/inc/transform.h         |   2 +
 drivers/gpu/drm/amd/dal/include/video_csc_types.h  |   5 -
 23 files changed, 302 insertions(+), 213 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index f0eaafd..9fb4e51 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -484,7 +484,7 @@ static void fill_plane_attributes_from_fb(
 	surface->scaling_quality.v_taps_c = 2;
 
 	/* TODO: unhardcode */
-	surface->color_space = COLOR_SPACE_SRGB_FULL_RANGE;
+	surface->color_space = COLOR_SPACE_SRGB;
 	surface->scaling_quality.h_taps = 2;
 	surface->scaling_quality.v_taps = 2;
 	surface->stereo_format = PLANE_STEREO_FORMAT_NONE;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
index 6a66ae9..e892a2f 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
@@ -194,7 +194,7 @@ static int8_t acquire_first_free_underlay(
 
 		pipe_ctx->tg->funcs->set_blank_color(
 				pipe_ctx->tg,
-				COLOR_SPACE_SRGB_FULL_RANGE);/* TODO unhardcode*/
+				COLOR_SPACE_YCBCR601);/* TODO unhardcode*/
 
 		pipe_ctx->stream = stream;
 		return DCE110_UNDERLAY_IDX;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 40e5883..fb0b9f6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -108,7 +108,7 @@ struct dc_surface {
 
 	union plane_size plane_size;
 	struct dc_tiling_info tiling_info;
-	enum color_space color_space;
+	enum dc_color_space color_space;
 
 	enum surface_pixel_format format;
 	enum dc_rotation_angle rotation;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
index 273c544..82e3afb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
@@ -354,17 +354,16 @@ enum dc_pixel_encoding {
 	PIXEL_ENCODING_COUNT
 };
 
-enum color_space {
+enum dc_color_space {
 	COLOR_SPACE_UNKNOWN,
-	COLOR_SPACE_SRGB_FULL_RANGE,
-	COLOR_SPACE_SRGB_LIMITED_RANGE,
+	COLOR_SPACE_SRGB,
+	COLOR_SPACE_SRGB_LIMITED,
 	COLOR_SPACE_YPBPR601,
 	COLOR_SPACE_YPBPR709,
 	COLOR_SPACE_YCBCR601,
 	COLOR_SPACE_YCBCR709,
-	COLOR_SPACE_YCBCR601_YONLY,
-	COLOR_SPACE_YCBCR709_YONLY,
-	COLOR_SPACE_N_MVPU_SUPER_AA,
+	COLOR_SPACE_YCBCR601_LIMITED,
+	COLOR_SPACE_YCBCR709_LIMITED
 };
 
 enum dc_color_depth {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 1e22e59..a93cdbb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -737,10 +737,10 @@ static void unblank_stream(struct pipe_ctx *pipe_ctx,
 	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
 }
 
-static enum color_space get_output_color_space(
+static enum dc_color_space get_output_color_space(
 				const struct dc_crtc_timing *dc_crtc_timing)
 {
-	enum color_space color_space = COLOR_SPACE_SRGB_FULL_RANGE;
+	enum dc_color_space color_space = COLOR_SPACE_SRGB;
 
 	switch (dc_crtc_timing->pixel_encoding)	{
 	case PIXEL_ENCODING_YCBCR422:
@@ -754,13 +754,13 @@ static enum color_space get_output_color_space(
 			if (dc_crtc_timing->pix_clk_khz > 27030) {
 				if (dc_crtc_timing->flags.Y_ONLY)
 					color_space =
-						COLOR_SPACE_YCBCR709_YONLY;
+						COLOR_SPACE_YCBCR709_LIMITED;
 				else
 					color_space = COLOR_SPACE_YCBCR709;
 			} else {
 				if (dc_crtc_timing->flags.Y_ONLY)
 					color_space =
-						COLOR_SPACE_YCBCR601_YONLY;
+						COLOR_SPACE_YCBCR601_LIMITED;
 				else
 					color_space = COLOR_SPACE_YCBCR601;
 			}
@@ -785,7 +785,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		&dc->current_context.res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 	bool timing_changed = context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx]
 							.flags.timing_changed;
-	enum color_space color_space;
+	enum dc_color_space color_space;
 
 	if (timing_changed) {
 		/* Must blank CRTC after disabling power gating and before any
@@ -1298,39 +1298,13 @@ static enum dc_status apply_ctx_to_hw(
 /*******************************************************************************
  * Front End programming
  ******************************************************************************/
-
-static bool setup_line_buffer_pixel_depth(
-	const struct pipe_ctx *pipe_ctx,
-	enum lb_pixel_depth depth,
-	bool blank)
-{
-	enum lb_pixel_depth current_depth;
-
-	struct timing_generator *tg = pipe_ctx->tg;
-	struct transform *xfm = pipe_ctx->xfm;
-
-	if (!xfm->funcs->transform_get_current_pixel_storage_depth(
-		xfm,
-		&current_depth))
-		return false;
-
-	if (current_depth != depth) {
-		if (blank)
-			tg->funcs->wait_for_state(tg, CRTC_STATE_VBLANK);
-
-		return xfm->funcs->transform_set_pixel_storage_depth(xfm, depth,
-				&pipe_ctx->stream->bit_depth_params);
-	}
-
-	return false;
-}
-
 static void set_default_colors(struct pipe_ctx *pipe_ctx)
 {
 	struct default_adjustment default_adjust = { 0 };
 
 	default_adjust.force_hw_default = false;
-	default_adjust.color_space = get_output_color_space(
+	default_adjust.in_color_space = pipe_ctx->surface->public.color_space;
+	default_adjust.out_color_space = get_output_color_space(
 					&pipe_ctx->stream->public.timing);
 	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
 	default_adjust.surface_pixel_format = pipe_ctx->scl_data.format;
@@ -1340,7 +1314,7 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->stream->public.timing.display_color_depth;
 
 	/* Lb color depth */
-	default_adjust.lb_color_depth = LB_PIXEL_DEPTH_24BPP;
+	default_adjust.lb_color_depth = LB_PIXEL_DEPTH_30BPP;
 	/*dal_hw_sequencer_translate_to_lb_color_depth(
 			build_params->
 			line_buffer_params[path_id][plane_id].depth);*/
@@ -1351,13 +1325,14 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 
 static void program_scaler(const struct pipe_ctx *pipe_ctx)
 {
-	setup_line_buffer_pixel_depth(
-		pipe_ctx,
-		LB_PIXEL_DEPTH_24BPP,
-		false);
+	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
+		pipe_ctx->xfm,
+		LB_PIXEL_DEPTH_30BPP,
+		&pipe_ctx->stream->bit_depth_params);
 
 	pipe_ctx->tg->funcs->set_overscan_blank_color(
-		pipe_ctx->tg, pipe_ctx->surface->public.color_space);
+		pipe_ctx->tg,
+		get_output_color_space(&pipe_ctx->stream->public.timing));
 
 	pipe_ctx->xfm->funcs->transform_set_scaler(pipe_ctx->xfm, &pipe_ctx->scl_data);
 }
@@ -1418,6 +1393,9 @@ static void set_plane_config(
 	dc->hwss.set_blender_mode(
 		ctx, pipe_ctx->pipe_idx, blender_mode);
 
+	if (blender_mode != BLENDER_MODE_CURRENT_PIPE)
+		pipe_ctx->xfm->funcs->transform_set_alpha(pipe_ctx->xfm, true);
+
 	mi->funcs->mem_input_program_surface_config(
 			mi,
 			surface->public.format,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index f640552..d9dab36 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -142,11 +142,16 @@ static void program_addr(
 {
 	switch (addr->type) {
 	case PLN_ADDR_TYPE_GRAPHICS:
+		if (addr->grph.addr.quad_part == 0)
+			break;
 		program_pri_addr(
 			mem_input110,
 			addr->grph.addr);
 		break;
 	case PLN_ADDR_TYPE_GRPH_STEREO:
+		if (addr->grph_stereo.left_addr.quad_part == 0
+			|| addr->grph_stereo.right_addr.quad_part == 0)
+			break;
 		program_pri_addr(
 			mem_input110,
 			addr->grph_stereo.left_addr);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
index cad4efa..45778e6 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
@@ -133,7 +133,7 @@ void dce110_opp_program_clamping_and_pixel_encoding(
 
 void dce110_opp_set_dyn_expansion(
 	struct output_pixel_processor *opp,
-	enum color_space color_sp,
+	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
 	enum signal_type signal);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
index b1db0cc..08df2ba 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
@@ -39,24 +39,24 @@ enum {
 };
 
 struct out_csc_color_matrix {
-	enum color_space color_space;
+	enum dc_color_space color_space;
 	uint16_t regval[OUTPUT_CSC_MATRIX_SIZE];
 };
 
 static const struct out_csc_color_matrix global_color_matrix[] = {
-{ COLOR_SPACE_SRGB_FULL_RANGE,
+{ COLOR_SPACE_SRGB,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-{ COLOR_SPACE_SRGB_LIMITED_RANGE,
+{ COLOR_SPACE_SRGB_LIMITED,
 	{ 0x1B60, 0, 0, 0x200, 0, 0x1B60, 0, 0x200, 0, 0, 0x1B60, 0x200} },
 { COLOR_SPACE_YCBCR601,
 	{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x82F, 0x1012, 0x31F, 0x200, 0xFB47,
 		0xF6B9, 0xE00, 0x1000} },
 { COLOR_SPACE_YCBCR709, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x5D2, 0x1394, 0x1FA,
 	0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
-/*  YOnly same as YCbCr709 but Y in Full range -To do. */
-{ COLOR_SPACE_YCBCR601_YONLY, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
+/* TODO: correct values below */
+{ COLOR_SPACE_YCBCR601_LIMITED, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
 	0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
-{ COLOR_SPACE_YCBCR709_YONLY, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
+{ COLOR_SPACE_YCBCR709_LIMITED, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
 	0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} }
 };
 
@@ -674,7 +674,7 @@ static void set_yuv_adjustment(
 {
 	bool b601 = (adjust->c_space == COLOR_SPACE_YPBPR601) ||
 		(adjust->c_space == COLOR_SPACE_YCBCR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601_YONLY);
+		(adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED);
 	struct out_csc_color_matrix reg_matrix;
 	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
 	struct dc_csc_adjustments adjustments;
@@ -684,8 +684,8 @@ static void set_yuv_adjustment(
 
 	setup_adjustments(adjust, &adjustments);
 
-	if ((adjust->c_space == COLOR_SPACE_YCBCR601_YONLY) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR709_YONLY))
+	if ((adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED) ||
+		(adjust->c_space == COLOR_SPACE_YCBCR709_LIMITED))
 		calculate_adjustments_y_only(
 			ideals, &adjustments, matrix);
 	else
@@ -703,7 +703,7 @@ static bool configure_graphics_mode(
 	struct dce110_opp *opp110,
 	enum csc_color_mode config,
 	enum graphics_csc_adjust_type csc_adjust_type,
-	enum color_space color_space)
+	enum dc_color_space color_space)
 {
 	struct dc_context *ctx = opp110->base.ctx;
 	uint32_t addr = DCP_REG(mmOUTPUT_CSC_CONTROL);
@@ -725,7 +725,7 @@ static bool configure_graphics_mode(
 		} else {
 
 			switch (color_space) {
-			case COLOR_SPACE_SRGB_FULL_RANGE:
+			case COLOR_SPACE_SRGB:
 				/* by pass */
 				set_reg_field_value(
 					value,
@@ -733,7 +733,7 @@ static bool configure_graphics_mode(
 					OUTPUT_CSC_CONTROL,
 					OUTPUT_CSC_GRPH_MODE);
 				break;
-			case COLOR_SPACE_SRGB_LIMITED_RANGE:
+			case COLOR_SPACE_SRGB_LIMITED:
 				/* TV RGB */
 				set_reg_field_value(
 					value,
@@ -743,7 +743,7 @@ static bool configure_graphics_mode(
 				break;
 			case COLOR_SPACE_YCBCR601:
 			case COLOR_SPACE_YPBPR601:
-			case COLOR_SPACE_YCBCR601_YONLY:
+			case COLOR_SPACE_YCBCR601_LIMITED:
 				/* YCbCr601 */
 				set_reg_field_value(
 					value,
@@ -753,7 +753,7 @@ static bool configure_graphics_mode(
 				break;
 			case COLOR_SPACE_YCBCR709:
 			case COLOR_SPACE_YPBPR709:
-			case COLOR_SPACE_YCBCR709_YONLY:
+			case COLOR_SPACE_YCBCR709_LIMITED:
 				/* YCbCr709 */
 				set_reg_field_value(
 					value,
@@ -767,7 +767,7 @@ static bool configure_graphics_mode(
 		}
 	} else if (csc_adjust_type == GRAPHICS_CSC_ADJUST_TYPE_HW) {
 		switch (color_space) {
-		case COLOR_SPACE_SRGB_FULL_RANGE:
+		case COLOR_SPACE_SRGB:
 			/* by pass */
 			set_reg_field_value(
 				value,
@@ -775,7 +775,7 @@ static bool configure_graphics_mode(
 				OUTPUT_CSC_CONTROL,
 				OUTPUT_CSC_GRPH_MODE);
 			break;
-		case COLOR_SPACE_SRGB_LIMITED_RANGE:
+		case COLOR_SPACE_SRGB_LIMITED:
 			/* TV RGB */
 			set_reg_field_value(
 				value,
@@ -785,7 +785,7 @@ static bool configure_graphics_mode(
 			break;
 		case COLOR_SPACE_YCBCR601:
 		case COLOR_SPACE_YPBPR601:
-		case COLOR_SPACE_YCBCR601_YONLY:
+		case COLOR_SPACE_YCBCR601_LIMITED:
 			/* YCbCr601 */
 			set_reg_field_value(
 				value,
@@ -795,7 +795,7 @@ static bool configure_graphics_mode(
 			break;
 		case COLOR_SPACE_YCBCR709:
 		case COLOR_SPACE_YPBPR709:
-		case COLOR_SPACE_YCBCR709_YONLY:
+		case COLOR_SPACE_YCBCR709_LIMITED:
 			 /* YCbCr709 */
 			set_reg_field_value(
 				value,
@@ -834,17 +834,17 @@ void dce110_opp_set_csc_adjustment(
 	 * the ideal values only, but keep original design to allow quick switch
 	 * to the old legacy routines */
 	switch (adjust->c_space) {
-	case COLOR_SPACE_SRGB_FULL_RANGE:
+	case COLOR_SPACE_SRGB:
 		set_rgb_adjustment_legacy(opp110, adjust);
 		break;
-	case COLOR_SPACE_SRGB_LIMITED_RANGE:
+	case COLOR_SPACE_SRGB_LIMITED:
 		set_rgb_limited_range_adjustment(
 			opp110, adjust);
 		break;
 	case COLOR_SPACE_YCBCR601:
 	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_YONLY:
-	case COLOR_SPACE_YCBCR709_YONLY:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
 	case COLOR_SPACE_YPBPR601:
 	case COLOR_SPACE_YPBPR709:
 		set_yuv_adjustment(opp110, adjust);
@@ -883,7 +883,7 @@ void dce110_opp_set_csc_default(
 
 		for (i = 0; i < ARRAY_SIZE(global_color_matrix); ++i) {
 			elm = &global_color_matrix[i];
-			if (elm->color_space != default_adjust->color_space)
+			if (elm->color_space != default_adjust->out_color_space)
 				continue;
 			/* program the matrix with default values from this
 			 * file */
@@ -900,5 +900,5 @@ void dce110_opp_set_csc_default(
 
 	configure_graphics_mode(opp110, config,
 		default_adjust->csc_adjust_type,
-		default_adjust->color_space);
+		default_adjust->out_color_space);
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c
index a786b98..2e50e5a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c
@@ -76,24 +76,24 @@ enum {
 #define  UNDERLAY_BRIGHTNESS_DIVIDER  100
 
 struct out_csc_color_matrix {
-	enum color_space color_space;
+	enum dc_color_space color_space;
 	uint16_t regval[OUTPUT_CSC_MATRIX_SIZE];
 };
 
 static const struct out_csc_color_matrix global_color_matrix[] = {
-{ COLOR_SPACE_SRGB_FULL_RANGE,
+{ COLOR_SPACE_SRGB,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-{ COLOR_SPACE_SRGB_LIMITED_RANGE,
+{ COLOR_SPACE_SRGB_LIMITED,
 	{ 0x1B60, 0, 0, 0x200, 0, 0x1B60, 0, 0x200, 0, 0, 0x1B60, 0x200} },
 { COLOR_SPACE_YCBCR601,
 	{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x82F, 0x1012, 0x31F, 0x200, 0xFB47,
 		0xF6B9, 0xE00, 0x1000} },
 { COLOR_SPACE_YCBCR709, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x5D2, 0x1394, 0x1FA,
 	0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
-/*  YOnly same as YCbCr709 but Y in Full range -To do. */
-{ COLOR_SPACE_YCBCR601_YONLY, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
+/* TODO: correct values below */
+{ COLOR_SPACE_YCBCR601_LIMITED, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
 	0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
-{ COLOR_SPACE_YCBCR709_YONLY, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
+{ COLOR_SPACE_YCBCR709_LIMITED, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
 	0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} }
 };
 
@@ -786,7 +786,7 @@ static void set_yuv_adjustment(
 {
 	bool b601 = (adjust->c_space == COLOR_SPACE_YPBPR601) ||
 		(adjust->c_space == COLOR_SPACE_YCBCR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601_YONLY);
+		(adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED);
 	struct out_csc_color_matrix reg_matrix;
 	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
 	struct dc_csc_adjustments adjustments;
@@ -796,8 +796,8 @@ static void set_yuv_adjustment(
 
 	setup_adjustments(adjust, &adjustments);
 
-	if ((adjust->c_space == COLOR_SPACE_YCBCR601_YONLY) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR709_YONLY))
+	if ((adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED) ||
+		(adjust->c_space == COLOR_SPACE_YCBCR709_LIMITED))
 		calculate_adjustments_y_only(
 			ideals, &adjustments, matrix);
 	else
@@ -815,7 +815,7 @@ static bool configure_graphics_mode_v(
 	struct dce110_opp *opp110,
 	enum csc_color_mode config,
 	enum graphics_csc_adjust_type csc_adjust_type,
-	enum color_space color_space)
+	enum dc_color_space color_space)
 {
 	struct dc_context *ctx = opp110->base.ctx;
 	uint32_t addr = mmCOL_MAN_OUTPUT_CSC_CONTROL;
@@ -832,7 +832,7 @@ static bool configure_graphics_mode_v(
 			return true;
 
 		switch (color_space) {
-		case COLOR_SPACE_SRGB_FULL_RANGE:
+		case COLOR_SPACE_SRGB:
 			/* by pass */
 			set_reg_field_value(
 				value,
@@ -840,13 +840,13 @@ static bool configure_graphics_mode_v(
 				COL_MAN_OUTPUT_CSC_CONTROL,
 				OUTPUT_CSC_MODE);
 			break;
-		case COLOR_SPACE_SRGB_LIMITED_RANGE:
+		case COLOR_SPACE_SRGB_LIMITED:
 			/* not supported for underlay on CZ */
 			return false;
 
 		case COLOR_SPACE_YCBCR601:
 		case COLOR_SPACE_YPBPR601:
-		case COLOR_SPACE_YCBCR601_YONLY:
+		case COLOR_SPACE_YCBCR601_LIMITED:
 			/* YCbCr601 */
 			set_reg_field_value(
 				value,
@@ -856,7 +856,7 @@ static bool configure_graphics_mode_v(
 			break;
 		case COLOR_SPACE_YCBCR709:
 		case COLOR_SPACE_YPBPR709:
-		case COLOR_SPACE_YCBCR709_YONLY:
+		case COLOR_SPACE_YCBCR709_LIMITED:
 			/* YCbCr709 */
 			set_reg_field_value(
 				value,
@@ -870,7 +870,7 @@ static bool configure_graphics_mode_v(
 
 	} else if (csc_adjust_type == GRAPHICS_CSC_ADJUST_TYPE_HW) {
 		switch (color_space) {
-		case COLOR_SPACE_SRGB_FULL_RANGE:
+		case COLOR_SPACE_SRGB:
 			/* by pass */
 			set_reg_field_value(
 				value,
@@ -878,12 +878,12 @@ static bool configure_graphics_mode_v(
 				COL_MAN_OUTPUT_CSC_CONTROL,
 				OUTPUT_CSC_MODE);
 			break;
-		case COLOR_SPACE_SRGB_LIMITED_RANGE:
+		case COLOR_SPACE_SRGB_LIMITED:
 			/* not supported for underlay on CZ */
 			return false;
 		case COLOR_SPACE_YCBCR601:
 		case COLOR_SPACE_YPBPR601:
-		case COLOR_SPACE_YCBCR601_YONLY:
+		case COLOR_SPACE_YCBCR601_LIMITED:
 			/* YCbCr601 */
 			set_reg_field_value(
 				value,
@@ -893,7 +893,7 @@ static bool configure_graphics_mode_v(
 			break;
 		case COLOR_SPACE_YCBCR709:
 		case COLOR_SPACE_YPBPR709:
-		case COLOR_SPACE_YCBCR709_YONLY:
+		case COLOR_SPACE_YCBCR709_LIMITED:
 			 /* YCbCr709 */
 			set_reg_field_value(
 				value,
@@ -963,6 +963,170 @@ static void set_Denormalization(struct output_pixel_processor *opp,
 	dm_write_reg(opp->ctx, mmDENORM_CLAMP_CONTROL, value);
 }
 
+struct input_csc_matrix {
+	enum dc_color_space color_space;
+	uint32_t regval[12];
+};
+
+static const struct input_csc_matrix input_csc_matrix[] = {
+	{COLOR_SPACE_SRGB,
+/*1_1   1_2   1_3   1_4   2_1   2_2   2_3   2_4   3_1   3_2   3_3   3_4 */
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_SRGB_LIMITED,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_YCBCR601,
+		{0x2cdd, 0x2000, 0x0, 0xe991, 0xe926, 0x2000, 0xf4fd, 0x10ef,
+						0x0, 0x2000, 0x38b4, 0xe3a6} },
+	{COLOR_SPACE_YCBCR601_LIMITED,
+		{0x3353, 0x2568, 0x0, 0xe400, 0xe5dc, 0x2568, 0xf367, 0x1108,
+						0x0, 0x2568, 0x40de, 0xdd3a} },
+	{COLOR_SPACE_YCBCR709,
+		{0x3265, 0x2000, 0, 0xe6ce, 0xf105, 0x2000, 0xfa01, 0xa7d, 0,
+						0x2000, 0x3b61, 0xe24f} },
+	{COLOR_SPACE_YCBCR709_LIMITED,
+		{0x39a6, 0x2568, 0, 0xe0d6, 0xeedd, 0x2568, 0xf925, 0x9a8, 0,
+						0x2568, 0x43ee, 0xdbb2} }
+};
+
+static void program_input_csc(
+	struct output_pixel_processor *opp, enum dc_color_space color_space)
+{
+	int arr_size = sizeof(input_csc_matrix)/sizeof(struct input_csc_matrix);
+	struct dc_context *ctx = opp->ctx;
+	const uint32_t *regval = NULL;
+	bool use_set_a;
+	uint32_t value;
+	int i;
+
+	for (i = 0; i < arr_size; i++)
+		if (input_csc_matrix[i].color_space == color_space) {
+			regval = input_csc_matrix[i].regval;
+			break;
+		}
+	if (regval == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	/*
+	 * 1 == set A, the logic is 'if currently we're not using set A,
+	 * then use set A, otherwise use set B'
+	 */
+	value = dm_read_reg(ctx, mmCOL_MAN_INPUT_CSC_CONTROL);
+	use_set_a = get_reg_field_value(
+		value, COL_MAN_INPUT_CSC_CONTROL, INPUT_CSC_MODE) != 1;
+
+	if (use_set_a) {
+		/* fixed S2.13 format */
+		value = 0;
+		set_reg_field_value(
+			value, regval[0], INPUT_CSC_C11_C12_A, INPUT_CSC_C11_A);
+		set_reg_field_value(
+			value, regval[1], INPUT_CSC_C11_C12_A, INPUT_CSC_C12_A);
+		dm_write_reg(ctx, mmINPUT_CSC_C11_C12_A, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[2], INPUT_CSC_C13_C14_A, INPUT_CSC_C13_A);
+		set_reg_field_value(
+			value, regval[3], INPUT_CSC_C13_C14_A, INPUT_CSC_C14_A);
+		dm_write_reg(ctx, mmINPUT_CSC_C13_C14_A, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[4], INPUT_CSC_C21_C22_A, INPUT_CSC_C21_A);
+		set_reg_field_value(
+			value, regval[5], INPUT_CSC_C21_C22_A, INPUT_CSC_C22_A);
+		dm_write_reg(ctx, mmINPUT_CSC_C21_C22_A, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[6], INPUT_CSC_C23_C24_A, INPUT_CSC_C23_A);
+		set_reg_field_value(
+			value, regval[7], INPUT_CSC_C23_C24_A, INPUT_CSC_C24_A);
+		dm_write_reg(ctx, mmINPUT_CSC_C23_C24_A, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[8], INPUT_CSC_C31_C32_A, INPUT_CSC_C31_A);
+		set_reg_field_value(
+			value, regval[9], INPUT_CSC_C31_C32_A, INPUT_CSC_C32_A);
+		dm_write_reg(ctx, mmINPUT_CSC_C31_C32_A, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[10], INPUT_CSC_C33_C34_A, INPUT_CSC_C33_A);
+		set_reg_field_value(
+			value, regval[11], INPUT_CSC_C33_C34_A, INPUT_CSC_C34_A);
+		dm_write_reg(ctx, mmINPUT_CSC_C33_C34_A, value);
+	} else {
+		/* fixed S2.13 format */
+		value = 0;
+		set_reg_field_value(
+			value, regval[0], INPUT_CSC_C11_C12_B, INPUT_CSC_C11_B);
+		set_reg_field_value(
+			value, regval[1], INPUT_CSC_C11_C12_B, INPUT_CSC_C12_B);
+		dm_write_reg(ctx, mmINPUT_CSC_C11_C12_B, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[2], INPUT_CSC_C13_C14_B, INPUT_CSC_C13_B);
+		set_reg_field_value(
+			value, regval[3], INPUT_CSC_C13_C14_B, INPUT_CSC_C14_B);
+		dm_write_reg(ctx, mmINPUT_CSC_C13_C14_B, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[4], INPUT_CSC_C21_C22_B, INPUT_CSC_C21_B);
+		set_reg_field_value(
+			value, regval[5], INPUT_CSC_C21_C22_B, INPUT_CSC_C22_B);
+		dm_write_reg(ctx, mmINPUT_CSC_C21_C22_B, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[6], INPUT_CSC_C23_C24_B, INPUT_CSC_C23_B);
+		set_reg_field_value(
+			value, regval[7], INPUT_CSC_C23_C24_B, INPUT_CSC_C24_B);
+		dm_write_reg(ctx, mmINPUT_CSC_C23_C24_B, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[8], INPUT_CSC_C31_C32_B, INPUT_CSC_C31_B);
+		set_reg_field_value(
+			value, regval[9], INPUT_CSC_C31_C32_B, INPUT_CSC_C32_B);
+		dm_write_reg(ctx, mmINPUT_CSC_C31_C32_B, value);
+
+		value = 0;
+		set_reg_field_value(
+			value, regval[10], INPUT_CSC_C33_C34_B, INPUT_CSC_C33_B);
+		set_reg_field_value(
+			value, regval[11], INPUT_CSC_C33_C34_B, INPUT_CSC_C34_B);
+		dm_write_reg(ctx, mmINPUT_CSC_C33_C34_B, value);
+	}
+
+	/* KK: leave INPUT_CSC_CONVERSION_MODE at default */
+	value = 0;
+	/*
+	 * select 8.4 input type instead of default 12.0. From the discussion
+	 * with HW team, this format depends on the UNP surface format, so for
+	 * 8-bit we should select 8.4 (4 bits truncated). For 10 it should be
+	 * 10.2. For Carrizo we only support 8-bit surfaces on underlay pipe
+	 * so we can always keep this at 8.4 (input_type=2). If the later asics
+	 * start supporting 10+ bits, we will have a problem: surface
+	 * programming including UNP_GRPH* is being done in DalISR after this,
+	 * so either we pass surface format to here, or move this logic to ISR
+	 */
+
+	set_reg_field_value(
+		value, 2, COL_MAN_INPUT_CSC_CONTROL, INPUT_CSC_INPUT_TYPE);
+	set_reg_field_value(
+		value,
+		use_set_a ? 1 : 2,
+		COL_MAN_INPUT_CSC_CONTROL,
+		INPUT_CSC_MODE);
+
+	dm_write_reg(ctx, mmCOL_MAN_INPUT_CSC_CONTROL, value);
+}
 
 void dce110_opp_v_set_csc_default(
 	struct output_pixel_processor *opp,
@@ -988,7 +1152,7 @@ void dce110_opp_v_set_csc_default(
 
 		for (i = 0; i < ARRAY_SIZE(global_color_matrix); ++i) {
 			elm = &global_color_matrix[i];
-			if (elm->color_space != default_adjust->color_space)
+			if (elm->color_space != default_adjust->out_color_space)
 				continue;
 			/* program the matrix with default values from this
 			 * file
@@ -999,6 +1163,8 @@ void dce110_opp_v_set_csc_default(
 		}
 	}
 
+	program_input_csc(opp, default_adjust->in_color_space);
+
 	/* configure the what we programmed :
 	 * 1. Default values from this file
 	 * 2. Use hardware default from ROM_A and we do not need to program
@@ -1007,7 +1173,7 @@ void dce110_opp_v_set_csc_default(
 
 	configure_graphics_mode_v(opp110, config,
 		default_adjust->csc_adjust_type,
-		default_adjust->color_space);
+		default_adjust->out_color_space);
 
 	set_Denormalization(opp, default_adjust->color_depth);
 }
@@ -1026,13 +1192,13 @@ void dce110_opp_v_set_csc_adjustment(
 	 * to the old legacy routines
 	 */
 	switch (adjust->c_space) {
-	case COLOR_SPACE_SRGB_FULL_RANGE:
+	case COLOR_SPACE_SRGB:
 		set_rgb_adjustment_legacy(opp110, adjust);
 		break;
 	case COLOR_SPACE_YCBCR601:
 	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_YONLY:
-	case COLOR_SPACE_YCBCR709_YONLY:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
 	case COLOR_SPACE_YPBPR601:
 	case COLOR_SPACE_YPBPR709:
 		set_yuv_adjustment(opp110, adjust);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c
index 235b92e..2abc01c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_formatter.c
@@ -561,7 +561,7 @@ void dce110_opp_program_clamping_and_pixel_encoding(
 
 void dce110_opp_set_dyn_expansion(
 	struct output_pixel_processor *opp,
-	enum color_space color_sp,
+	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
 	enum signal_type signal)
 {
@@ -580,7 +580,7 @@ void dce110_opp_set_dyn_expansion(
 	/* From HW programming guide:
 		FMT_DYNAMIC_EXP_EN = 0 for limited RGB or YCbCr output
 		FMT_DYNAMIC_EXP_EN = 1 for RGB full range only*/
-	if (color_sp == COLOR_SPACE_SRGB_FULL_RANGE)
+	if (color_sp == COLOR_SPACE_SRGB)
 		enable_dyn_exp = true;
 
 	/*00 - 10-bit -> 12-bit dynamic expansion*/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index 4e3276b..d4c5944 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -191,7 +191,7 @@ static void dce110_timing_generator_apply_front_porch_workaround(
 }
 
 void dce110_timing_generator_color_space_to_black_color(
-		enum color_space colorspace,
+		enum dc_color_space colorspace,
 	struct crtc_black_color *black_color)
 {
 	switch (colorspace) {
@@ -205,17 +205,7 @@ void dce110_timing_generator_color_space_to_black_color(
 		*black_color = black_color_format[BLACK_COLOR_FORMAT_YUV_CV];
 		break;
 
-	case COLOR_SPACE_N_MVPU_SUPER_AA:
-		/* In crossfire SuperAA mode, the slave overscan data is forced
-		 * to 0 in the pixel mixer on the master.  As a result, we need
-		 * to adjust the blank color so that after blending the
-		 * master+slave, it will appear black
-		 */
-		*black_color =
-			black_color_format[BLACK_COLOR_FORMAT_YUV_SUPER_AA];
-		break;
-
-	case COLOR_SPACE_SRGB_LIMITED_RANGE:
+	case COLOR_SPACE_SRGB_LIMITED:
 		*black_color =
 			black_color_format[BLACK_COLOR_FORMAT_RGB_LIMITED];
 		break;
@@ -301,7 +291,7 @@ bool dce110_timing_generator_enable_crtc(struct timing_generator *tg)
 
 void dce110_timing_generator_program_blank_color(
 		struct timing_generator *tg,
-		enum color_space color_space)
+		enum dc_color_space color_space)
 {
 	struct crtc_black_color black_color;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
@@ -1625,7 +1615,7 @@ void dce110_timing_generator_disable_vga(
 
 void dce110_timing_generator_set_overscan_color_black(
 	struct timing_generator *tg,
-	enum color_space black_color)
+	enum dc_color_space black_color)
 {
 	struct dc_context *ctx = tg->ctx;
 	uint32_t value = 0;
@@ -1659,8 +1649,8 @@ void dce110_timing_generator_set_overscan_color_black(
 	case COLOR_SPACE_YPBPR709:
 	case COLOR_SPACE_YCBCR601:
 	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_YONLY:
-	case COLOR_SPACE_YCBCR709_YONLY:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
 		set_reg_field_value(
 			value,
 			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4CV,
@@ -1680,31 +1670,7 @@ void dce110_timing_generator_set_overscan_color_black(
 			CRTC_OVERSCAN_COLOR_RED);
 		break;
 
-	case COLOR_SPACE_N_MVPU_SUPER_AA:
-		/* In crossfire SuperAA mode, the slave overscan data is forced
-		 * to 0 in the pixel mixer on the master.  As a result, we need
-		 * to adjust the blank color so that after blending the
-		 * master+slave, it will appear black */
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4SUPERAA,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_BLUE);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4SUPERAA,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_GREEN);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4SUPERAA,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_RED);
-		break;
-
-	case COLOR_SPACE_SRGB_LIMITED_RANGE:
+	case COLOR_SPACE_SRGB_LIMITED:
 		set_reg_field_value(
 			value,
 			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_RGB_LIMITED_RANGE,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
index 3579736..9c5e390 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
@@ -170,13 +170,13 @@ void dce110_timing_generator_program_blanking(
 /* Combine with below and move YUV/RGB color conversion to SW layer */
 void dce110_timing_generator_program_blank_color(
 	struct timing_generator *tg,
-	enum color_space color_space);
+	enum dc_color_space color_space);
 /* Combine with above and move YUV/RGB color conversion to SW layer */
 void dce110_timing_generator_set_overscan_color_black(
 	struct timing_generator *tg,
-	enum color_space black_color);
+	enum dc_color_space black_color);
 void dce110_timing_generator_color_space_to_black_color(
-		enum color_space colorspace,
+		enum dc_color_space colorspace,
 	struct crtc_black_color *black_color);
 /*************** End-of-move ********************/
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
index 99e8809..caf6631 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
@@ -393,7 +393,7 @@ static void dce110_timing_generator_v_program_timing(struct timing_generator *tg
 
 static void dce110_timing_generator_v_program_blank_color(
 		struct timing_generator *tg,
-		enum color_space color_space)
+		enum dc_color_space color_space)
 {
 	struct crtc_black_color black_color;
 	uint32_t addr = mmCRTCV_BLACK_COLOR;
@@ -424,7 +424,7 @@ static void dce110_timing_generator_v_program_blank_color(
 
 static void dce110_timing_generator_v_set_overscan_color_black(
 	struct timing_generator *tg,
-	enum color_space black_color)
+	enum dc_color_space black_color)
 {
 	struct dc_context *ctx = tg->ctx;
 	uint32_t value = 0;
@@ -458,8 +458,8 @@ static void dce110_timing_generator_v_set_overscan_color_black(
 	case COLOR_SPACE_YPBPR709:
 	case COLOR_SPACE_YCBCR601:
 	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_YONLY:
-	case COLOR_SPACE_YCBCR709_YONLY:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
 		set_reg_field_value(
 			value,
 			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4CV,
@@ -479,31 +479,7 @@ static void dce110_timing_generator_v_set_overscan_color_black(
 			CRTC_OVERSCAN_COLOR_RED);
 		break;
 
-	case COLOR_SPACE_N_MVPU_SUPER_AA:
-		/* In crossfire SuperAA mode, the slave overscan data is forced
-		 * to 0 in the pixel mixer on the master.  As a result, we need
-		 * to adjust the blank color so that after blending the
-		 * master+slave, it will appear black */
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4SUPERAA,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_BLUE);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4SUPERAA,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_GREEN);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4SUPERAA,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_RED);
-		break;
-
-	case COLOR_SPACE_SRGB_LIMITED_RANGE:
+	case COLOR_SPACE_SRGB_LIMITED:
 		set_reg_field_value(
 			value,
 			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_RGB_LIMITED_RANGE,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
index dba972f..032752c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
@@ -54,7 +54,8 @@ static struct transform_funcs dce110_transform_funcs = {
 	.transform_set_pixel_storage_depth =
 		dce110_transform_set_pixel_storage_depth,
 	.transform_get_current_pixel_storage_depth =
-		dce110_transform_get_current_pixel_storage_depth
+		dce110_transform_get_current_pixel_storage_depth,
+	.transform_set_alpha = dce110_transform_set_alpha
 };
 
 /*****************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h
index f7c5565..7acbabc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h
@@ -82,5 +82,6 @@ bool dce110_transform_get_current_pixel_storage_depth(
 	struct transform *xfm,
 	enum lb_pixel_depth *depth);
 
+void dce110_transform_set_alpha(struct transform *xfm, bool enable);
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
index 470453f..07f7d12 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
@@ -588,11 +588,10 @@ bool dce110_transform_get_max_num_of_supported_lines(
 	return true;
 }
 
-void dce110_transform_enable_alpha(
-	struct dce110_transform *xfm110,
-	bool enable)
+void dce110_transform_set_alpha(struct transform *xfm, bool enable)
 {
-	struct dc_context *ctx = xfm110->base.ctx;
+	struct dce110_transform *xfm110 = TO_DCE110_TRANSFORM(xfm);
+	struct dc_context *ctx = xfm->ctx;
 	uint32_t value;
 	uint32_t addr = LB_REG(mmLB_DATA_FORMAT);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
index 725f18c..e152306 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
@@ -123,7 +123,7 @@ void dce80_opp_program_clamping_and_pixel_encoding(
 
 void dce80_opp_set_dyn_expansion(
 	struct output_pixel_processor *opp,
-	enum color_space color_sp,
+	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
 	enum signal_type signal);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c
index 2ea6628..a8ad163 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c
@@ -40,24 +40,24 @@ enum {
 };
 
 struct out_csc_color_matrix {
-	enum color_space color_space;
+	enum dc_color_space color_space;
 	uint16_t regval[OUTPUT_CSC_MATRIX_SIZE];
 };
 
 static const struct out_csc_color_matrix global_color_matrix[] = {
-{ COLOR_SPACE_SRGB_FULL_RANGE,
+{ COLOR_SPACE_SRGB,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-{ COLOR_SPACE_SRGB_LIMITED_RANGE,
+{ COLOR_SPACE_SRGB_LIMITED,
 	{ 0x1B60, 0, 0, 0x200, 0, 0x1B60, 0, 0x200, 0, 0, 0x1B60, 0x200} },
 { COLOR_SPACE_YCBCR601,
 	{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x82F, 0x1012, 0x31F, 0x200, 0xFB47,
 		0xF6B9, 0xE00, 0x1000} },
 { COLOR_SPACE_YCBCR709, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x5D2, 0x1394, 0x1FA,
 	0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
-/*  YOnly same as YCbCr709 but Y in Full range -To do. */
-{ COLOR_SPACE_YCBCR601_YONLY, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
+/* TODO: correct values below */
+{ COLOR_SPACE_YCBCR601_LIMITED, { 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
 	0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
-{ COLOR_SPACE_YCBCR709_YONLY, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
+{ COLOR_SPACE_YCBCR709_LIMITED, { 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
 	0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} }
 };
 
@@ -675,7 +675,7 @@ static void set_yuv_adjustment(
 {
 	bool b601 = (adjust->c_space == COLOR_SPACE_YPBPR601) ||
 		(adjust->c_space == COLOR_SPACE_YCBCR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601_YONLY);
+		(adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED);
 	struct out_csc_color_matrix reg_matrix;
 	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
 	struct dc_csc_adjustments adjustments;
@@ -685,8 +685,8 @@ static void set_yuv_adjustment(
 
 	setup_adjustments(adjust, &adjustments);
 
-	if ((adjust->c_space == COLOR_SPACE_YCBCR601_YONLY) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR709_YONLY))
+	if ((adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED) ||
+		(adjust->c_space == COLOR_SPACE_YCBCR709_LIMITED))
 		calculate_adjustments_y_only(
 			ideals, &adjustments, matrix);
 	else
@@ -704,7 +704,7 @@ static bool configure_graphics_mode(
 	struct dce80_opp *opp80,
 	enum csc_color_mode config,
 	enum graphics_csc_adjust_type csc_adjust_type,
-	enum color_space color_space)
+	enum dc_color_space color_space)
 {
 	struct dc_context *ctx = opp80->base.ctx;
 	uint32_t addr = DCP_REG(mmOUTPUT_CSC_CONTROL);
@@ -726,7 +726,7 @@ static bool configure_graphics_mode(
 		} else {
 
 			switch (color_space) {
-			case COLOR_SPACE_SRGB_FULL_RANGE:
+			case COLOR_SPACE_SRGB:
 				/* by pass */
 				set_reg_field_value(
 					value,
@@ -734,7 +734,7 @@ static bool configure_graphics_mode(
 					OUTPUT_CSC_CONTROL,
 					OUTPUT_CSC_GRPH_MODE);
 				break;
-			case COLOR_SPACE_SRGB_LIMITED_RANGE:
+			case COLOR_SPACE_SRGB_LIMITED:
 				/* TV RGB */
 				set_reg_field_value(
 					value,
@@ -744,7 +744,7 @@ static bool configure_graphics_mode(
 				break;
 			case COLOR_SPACE_YCBCR601:
 			case COLOR_SPACE_YPBPR601:
-			case COLOR_SPACE_YCBCR601_YONLY:
+			case COLOR_SPACE_YCBCR601_LIMITED:
 				/* YCbCr601 */
 				set_reg_field_value(
 					value,
@@ -754,7 +754,7 @@ static bool configure_graphics_mode(
 				break;
 			case COLOR_SPACE_YCBCR709:
 			case COLOR_SPACE_YPBPR709:
-			case COLOR_SPACE_YCBCR709_YONLY:
+			case COLOR_SPACE_YCBCR709_LIMITED:
 				/* YCbCr709 */
 				set_reg_field_value(
 					value,
@@ -768,7 +768,7 @@ static bool configure_graphics_mode(
 		}
 	} else if (csc_adjust_type == GRAPHICS_CSC_ADJUST_TYPE_HW) {
 		switch (color_space) {
-		case COLOR_SPACE_SRGB_FULL_RANGE:
+		case COLOR_SPACE_SRGB:
 			/* by pass */
 			set_reg_field_value(
 				value,
@@ -776,7 +776,7 @@ static bool configure_graphics_mode(
 				OUTPUT_CSC_CONTROL,
 				OUTPUT_CSC_GRPH_MODE);
 			break;
-		case COLOR_SPACE_SRGB_LIMITED_RANGE:
+		case COLOR_SPACE_SRGB_LIMITED:
 			/* TV RGB */
 			set_reg_field_value(
 				value,
@@ -786,7 +786,7 @@ static bool configure_graphics_mode(
 			break;
 		case COLOR_SPACE_YCBCR601:
 		case COLOR_SPACE_YPBPR601:
-		case COLOR_SPACE_YCBCR601_YONLY:
+		case COLOR_SPACE_YCBCR601_LIMITED:
 			/* YCbCr601 */
 			set_reg_field_value(
 				value,
@@ -796,7 +796,7 @@ static bool configure_graphics_mode(
 			break;
 		case COLOR_SPACE_YCBCR709:
 		case COLOR_SPACE_YPBPR709:
-		case COLOR_SPACE_YCBCR709_YONLY:
+		case COLOR_SPACE_YCBCR709_LIMITED:
 			 /* YCbCr709 */
 			set_reg_field_value(
 				value,
@@ -835,17 +835,17 @@ void dce80_opp_set_csc_adjustment(
 	 * the ideal values only, but keep original design to allow quick switch
 	 * to the old legacy routines */
 	switch (adjust->c_space) {
-	case COLOR_SPACE_SRGB_FULL_RANGE:
+	case COLOR_SPACE_SRGB:
 		set_rgb_adjustment_legacy(opp80, adjust);
 		break;
-	case COLOR_SPACE_SRGB_LIMITED_RANGE:
+	case COLOR_SPACE_SRGB_LIMITED:
 		set_rgb_limited_range_adjustment(
 			opp80, adjust);
 		break;
 	case COLOR_SPACE_YCBCR601:
 	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_YONLY:
-	case COLOR_SPACE_YCBCR709_YONLY:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
 	case COLOR_SPACE_YPBPR601:
 	case COLOR_SPACE_YPBPR709:
 		set_yuv_adjustment(opp80, adjust);
@@ -884,7 +884,7 @@ void dce80_opp_set_csc_default(
 
 		for (i = 0; i < ARRAY_SIZE(global_color_matrix); ++i) {
 			elm = &global_color_matrix[i];
-			if (elm->color_space != default_adjust->color_space)
+			if (elm->color_space != default_adjust->out_color_space)
 				continue;
 			/* program the matrix with default values from this
 			 * file */
@@ -901,5 +901,5 @@ void dce80_opp_set_csc_default(
 
 	configure_graphics_mode(opp80, config,
 		default_adjust->csc_adjust_type,
-		default_adjust->color_space);
+		default_adjust->out_color_space);
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_formatter.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_formatter.c
index 9d0a214..5df1749 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_formatter.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_formatter.c
@@ -528,7 +528,7 @@ void dce80_opp_program_clamping_and_pixel_encoding(
 
 void dce80_opp_set_dyn_expansion(
 	struct output_pixel_processor *opp,
-	enum color_space color_sp,
+	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
 	enum signal_type signal)
 {
@@ -547,7 +547,7 @@ void dce80_opp_set_dyn_expansion(
 	/* From HW programming guide:
 		FMT_DYNAMIC_EXP_EN = 0 for limited RGB or YCbCr output
 		FMT_DYNAMIC_EXP_EN = 1 for RGB full range only*/
-	if (color_sp == COLOR_SPACE_SRGB_FULL_RANGE)
+	if (color_sp == COLOR_SPACE_SRGB)
 		enable_dyn_exp = true;
 
 	/*00 - 10-bit -> 12-bit dynamic expansion*/
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/opp.h b/drivers/gpu/drm/amd/dal/dc/inc/opp.h
index f0c852a..1c9b732 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/opp.h
@@ -230,7 +230,8 @@ enum graphics_csc_adjust_type {
 
 struct default_adjustment {
 	uint32_t lb_color_depth;
-	enum color_space color_space;
+	enum dc_color_space out_color_space;
+	enum dc_color_space in_color_space;
 	enum dc_color_depth color_depth;
 	enum pixel_format surface_pixel_format;
 	enum graphics_csc_adjust_type csc_adjust_type;
@@ -244,7 +245,7 @@ enum grph_color_adjust_option {
 
 struct opp_grph_csc_adjustment {
 	enum grph_color_adjust_option color_adjust_option;
-	enum color_space c_space;
+	enum dc_color_space c_space;
 	enum dc_color_depth color_depth; /* clean up to uint32_t */
 	enum graphics_csc_adjust_type   csc_adjust_type;
 	int32_t adjust_divider;
@@ -307,7 +308,7 @@ struct opp_funcs {
 
 	void (*opp_set_dyn_expansion)(
 		struct output_pixel_processor *opp,
-		enum color_space color_sp,
+		enum dc_color_space color_sp,
 		enum dc_color_depth color_dpth,
 		enum signal_type signal);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/timing_generator.h b/drivers/gpu/drm/amd/dal/dc/inc/timing_generator.h
index 7ef22ad..374e222 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/timing_generator.h
@@ -132,8 +132,8 @@ struct timing_generator_funcs {
 							enum crtc_state state);
 	bool (*set_blank)(struct timing_generator *tg,
 					   bool enable_blanking);
-	void (*set_overscan_blank_color) (struct timing_generator *tg, enum color_space black_color);
-	void (*set_blank_color)(struct timing_generator *tg, enum color_space black_color);
+	void (*set_overscan_blank_color) (struct timing_generator *tg, enum dc_color_space black_color);
+	void (*set_blank_color)(struct timing_generator *tg, enum dc_color_space black_color);
 	void (*set_colors)(struct timing_generator *tg,
 						const struct crtc_black_color *blank_color,
 						const struct crtc_black_color *overscan_color);
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/transform.h b/drivers/gpu/drm/amd/dal/dc/inc/transform.h
index 87dbff3..bf84f96 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/transform.h
@@ -185,6 +185,8 @@ struct transform_funcs {
 	bool (*transform_get_current_pixel_storage_depth)(
 		struct transform *xfm,
 		enum lb_pixel_depth *depth);
+
+	void (*transform_set_alpha)(struct transform *xfm, bool enable);
 };
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/include/video_csc_types.h b/drivers/gpu/drm/amd/dal/include/video_csc_types.h
index d8526d3..58dcc04 100644
--- a/drivers/gpu/drm/amd/dal/include/video_csc_types.h
+++ b/drivers/gpu/drm/amd/dal/include/video_csc_types.h
@@ -107,9 +107,4 @@ struct ovl_csc_adjustment {
 
 };
 
-struct input_csc_matrix {
-	enum color_space color_space;
-	uint16_t regval[12];
-};
-
 #endif
-- 
2.7.4

