From b35c700a2fbcc745b72be8341220730b49baf3b3 Mon Sep 17 00:00:00 2001
From: Shirish S <shirish.s@amd.com>
Date: Thu, 16 Mar 2017 15:26:56 +0530
Subject: [PATCH 2659/3082] drm/amd/display: decouple per-crtc-plane model

Current design has per-crtc-plane model.
As a result, for asic's that support underlay,
are unable to expose it to user space for modesetting.

To enable this, the drm driver intialisation now runs
for number of surfaces instead of stream/crtc.

This patch plumbs surface capabilities to drm framework
so that it can be effectively used by user space.

Tests: (On Chromium OS)
* 'modetest -p'  now shows additional plane
  with YUV capabilities in case of CZ and ST.
* 'plane_test' reaches __setplane_internal and fails there as
  update_plane function is not implemented.
* Checked multimonitor display works fine

Signed-off-by: Shirish S <shirish.s@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h           |   8 ++
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c  |  72 ++++++++---
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.c    | 142 ++++++++++-----------
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.h    |   5 +-
 drivers/gpu/drm/amd/display/dc/dc.h                |   1 +
 .../drm/amd/display/dc/dce110/dce110_resource.c    |   2 +
 6 files changed, 136 insertions(+), 94 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index 3148412..da3b125 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
@@ -59,6 +59,7 @@ struct amdgpu_hpd;
 
 #define AMDGPU_MAX_HPD_PINS 6
 #define AMDGPU_MAX_CRTCS 6
+#define AMDGPU_MAX_PLANES 6
 #define AMDGPU_MAX_AFMT_BLOCKS 9
 
 enum amdgpu_rmx_type {
@@ -338,6 +339,7 @@ struct amdgpu_mode_info {
 	struct card_info *atom_card_info;
 	bool mode_config_initialized;
 	struct amdgpu_crtc *crtcs[AMDGPU_MAX_CRTCS];
+	struct amdgpu_plane *planes[AMDGPU_MAX_PLANES];
 	struct amdgpu_afmt *afmt[AMDGPU_MAX_AFMT_BLOCKS];
 	/* DVI-I properties */
 	struct drm_property *coherent_mode_property;
@@ -371,6 +373,7 @@ struct amdgpu_mode_info {
 	int			num_dig; /* number of dig blocks */
 	int			disp_priority;
 	const struct amdgpu_display_funcs *funcs;
+	enum drm_plane_type *plane_type;
 };
 
 #define AMDGPU_MAX_BL_LEVEL 0xFF
@@ -452,6 +455,11 @@ struct amdgpu_crtc {
 	struct drm_pending_vblank_event *event;
 };
 
+struct amdgpu_plane {
+	struct drm_plane base;
+	enum drm_plane_type plane_type;
+};
+
 struct amdgpu_encoder_atom_dig {
 	bool linkb;
 	/* atom dig */
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index ed7ca67..8c2de56 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -55,6 +55,33 @@
 
 #include "modules/inc/mod_freesync.h"
 
+static enum drm_plane_type dm_surfaces_type_default[AMDGPU_MAX_PLANES] = {
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+};
+
+static enum drm_plane_type dm_surfaces_type_carizzo[AMDGPU_MAX_PLANES] = {
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_OVERLAY,/* YUV Capable Underlay */
+	DRM_PLANE_TYPE_CURSOR,
+	DRM_PLANE_TYPE_OVERLAY,
+};
+
+static enum drm_plane_type dm_surfaces_type_stoney[AMDGPU_MAX_PLANES] = {
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_PRIMARY,
+	DRM_PLANE_TYPE_OVERLAY, /* YUV Capable Underlay */
+	DRM_PLANE_TYPE_OVERLAY,
+	DRM_PLANE_TYPE_OVERLAY,
+	DRM_PLANE_TYPE_CURSOR,
+};
+
 /*
  * dm_vblank_get_counter
  *
@@ -1057,30 +1084,34 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 	uint32_t i;
 	struct amdgpu_connector *aconnector;
 	struct amdgpu_encoder *aencoder;
-	struct amdgpu_crtc *acrtc;
+	struct amdgpu_mode_info *mode_info = &adev->mode_info;
 	uint32_t link_cnt;
 
 	link_cnt = dm->dc->caps.max_links;
-
 	if (amdgpu_dm_mode_config_init(dm->adev)) {
 		DRM_ERROR("DM: Failed to initialize mode config\n");
-		return -1;
+		goto fail;
 	}
 
-	for (i = 0; i < dm->dc->caps.max_streams; i++) {
-		acrtc = kzalloc(sizeof(struct amdgpu_crtc), GFP_KERNEL);
-		if (!acrtc)
-			goto fail;
+	for (i = 0; i < dm->dc->caps.max_surfaces; i++) {
+		mode_info->planes[i] = kzalloc(sizeof(struct amdgpu_plane),
+								 GFP_KERNEL);
+		if (!mode_info->planes[i]) {
+			DRM_ERROR("KMS: Failed to allocate surface\n");
+			goto fail_free_planes;
+		}
+		mode_info->planes[i]->plane_type = mode_info->plane_type[i];
+		if (amdgpu_dm_plane_init(dm, mode_info->planes[i], 1)) {
+			DRM_ERROR("KMS: Failed to initialize plane\n");
+			goto fail_free_planes;
+		}
+	}
 
-		if (amdgpu_dm_crtc_init(
-			dm,
-			acrtc,
-			i)) {
+	for (i = 0; i < dm->dc->caps.max_streams; i++)
+		if (amdgpu_dm_crtc_init(dm, &mode_info->planes[i]->base, i)) {
 			DRM_ERROR("KMS: Failed to initialize crtc\n");
-			kfree(acrtc);
-			goto fail;
+			goto fail_free_planes;
 		}
-	}
 
 	dm->display_indexes_num = dm->dc->caps.max_streams;
 
@@ -1131,12 +1162,12 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 	case CHIP_VEGA10:
 		if (dce110_register_irq_handlers(dm->adev)) {
 			DRM_ERROR("DM: Failed to initialize IRQ\n");
-			return -1;
+			goto fail_free_encoder;
 		}
 		break;
 	default:
 		DRM_ERROR("Usupported ASIC type: 0x%X\n", adev->asic_type);
-		return -1;
+		goto fail_free_encoder;
 	}
 
 	drm_mode_config_reset(dm->ddev);
@@ -1146,6 +1177,9 @@ fail_free_encoder:
 	kfree(aencoder);
 fail_free_connector:
 	kfree(aconnector);
+fail_free_planes:
+	for (i = 0; i < dm->dc->caps.max_surfaces; i++)
+		kfree(mode_info->planes[i]);
 fail:
 	return -1;
 }
@@ -1537,6 +1571,7 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
+		adev->mode_info.plane_type = dm_surfaces_type_default;
 #ifdef CONFIG_DRM_AMDGPU_CIK
 		if (adev->mode_info.funcs == NULL)
 			adev->mode_info.funcs = &dm_dce_v8_0_display_funcs;
@@ -1547,6 +1582,7 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
+		adev->mode_info.plane_type = dm_surfaces_type_default;
 		if (adev->mode_info.funcs == NULL)
 			adev->mode_info.funcs = &dm_dce_v10_0_display_funcs;
 		break;
@@ -1554,6 +1590,7 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 3;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 9;
+		adev->mode_info.plane_type = dm_surfaces_type_carizzo;
 		if (adev->mode_info.funcs == NULL)
 			adev->mode_info.funcs = &dm_dce_v11_0_display_funcs;
 		break;
@@ -1561,6 +1598,7 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 2;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 9;
+		adev->mode_info.plane_type = dm_surfaces_type_stoney;
 		if (adev->mode_info.funcs == NULL)
 			adev->mode_info.funcs = &dm_dce_v11_0_display_funcs;
 		break;
@@ -1569,6 +1607,7 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 5;
 		adev->mode_info.num_hpd = 5;
 		adev->mode_info.num_dig = 5;
+		adev->mode_info.plane_type = dm_surfaces_type_default;
 		if (adev->mode_info.funcs == NULL)
 			adev->mode_info.funcs = &dm_dce_v11_0_display_funcs;
 		break;
@@ -1576,6 +1615,7 @@ static int dm_early_init(void *handle)
 		adev->mode_info.num_crtc = 6;
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
+		adev->mode_info.plane_type = dm_surfaces_type_default;
 		if (adev->mode_info.funcs == NULL)
 			adev->mode_info.funcs = &dm_dce_v11_0_display_funcs;
 		break;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
index 38c5624..811c009 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
@@ -1817,102 +1817,90 @@ static uint32_t rgb_formats[] = {
 	DRM_FORMAT_ABGR2101010,
 };
 
-int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
-                         struct amdgpu_crtc *acrtc,
-                         uint32_t crtc_index)
-{
-        int res = -ENOMEM;
+static uint32_t yuv_formats[] = {
+         DRM_FORMAT_YUYV,
+         DRM_FORMAT_YVYU,
+         DRM_FORMAT_UYVY,
+         DRM_FORMAT_VYUY,
+};
 
-        struct drm_plane *primary_plane =
-                kzalloc(sizeof(*primary_plane), GFP_KERNEL);
-
-        if (!primary_plane)
-                 goto fail_plane;
-        primary_plane->format_default = true;
-
-        res = drm_universal_plane_init(
-                 dm->adev->ddev,
-                 primary_plane,
-                 0,
-                 &dm_plane_funcs,
-                 rgb_formats,
-                 ARRAY_SIZE(rgb_formats),
-                 DRM_PLANE_TYPE_PRIMARY, NULL);
- 
-        primary_plane->crtc = &acrtc->base;
- 
-        drm_plane_helper_add(primary_plane, &dm_plane_helper_funcs);
- 
-        res = drm_crtc_init_with_planes(
-                         dm->ddev,
-                         &acrtc->base,
-                        primary_plane,
-                          NULL,
-                         &amdgpu_dm_crtc_funcs, NULL);
- 
- 
-        res = drm_crtc_init_with_planes(
-                         dm->ddev,
-                         &acrtc->base,
-                         primary_plane,
-                         NULL,
-                         &amdgpu_dm_crtc_funcs, NULL);
+int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
+                         struct amdgpu_plane *aplane,
+                         unsigned long possible_crtcs)
+{
+        int res = -EPERM;
+
+        switch (aplane->plane_type) {
+        case DRM_PLANE_TYPE_PRIMARY:
+                aplane->base.format_default = true;
+
+                res = drm_universal_plane_init(
+                                dm->adev->ddev,
+                                &aplane->base,
+                                possible_crtcs,
+                                &dm_plane_funcs,
+                                rgb_formats,
+                                ARRAY_SIZE(rgb_formats),
+                                aplane->plane_type, NULL);
+                break;
+        case DRM_PLANE_TYPE_OVERLAY:
+                res = drm_universal_plane_init(
+                                dm->adev->ddev,
+                                &aplane->base,
+                                possible_crtcs,
+                                &dm_plane_funcs,
+                                yuv_formats,
+                                ARRAY_SIZE(yuv_formats),
+                                aplane->plane_type, NULL);
+                break;
+        case DRM_PLANE_TYPE_CURSOR:
+                DRM_ERROR("KMS: Cursor plane not implemented.");
+                break;
+        }
+
+        drm_plane_helper_add(&aplane->base, &dm_plane_helper_funcs);
+
+        return res;
 }
 
 int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
 			struct amdgpu_crtc *acrtc,
 			uint32_t crtc_index)
 {
-	int res = -ENOMEM;
-
-	struct drm_plane *primary_plane =
-		kzalloc(sizeof(*primary_plane), GFP_KERNEL);
-
-	if (!primary_plane)
-		goto fail_plane;
-
-	primary_plane->format_default = true;
-
-	res = drm_universal_plane_init(
-		dm->adev->ddev,
-		primary_plane,
-		0,
-		&dm_plane_funcs,
-		rgb_formats,
-		ARRAY_SIZE(rgb_formats),
-		DRM_PLANE_TYPE_PRIMARY);
-
-	primary_plane->crtc = &acrtc->base;
+        struct amdgpu_crtc *acrtc;
+        int res = -ENOMEM;
 
-	drm_plane_helper_add(primary_plane, &dm_plane_helper_funcs);
+        acrtc = kzalloc(sizeof(struct amdgpu_crtc), GFP_KERNEL);
+        if (!acrtc)
+                goto fail;
 
-	res = drm_crtc_init_with_planes(
-			dm->ddev,
-			&acrtc->base,
-			primary_plane,
-			NULL,
-			&amdgpu_dm_crtc_funcs);
+        res = drm_crtc_init_with_planes(
+                        dm->ddev,
+                        &acrtc->base,
+                        plane,
+                        NULL,
+                        &amdgpu_dm_crtc_funcs, NULL);
 
-	if (res)
-		goto fail;
+        if (res)
+                goto fail;
 
-	drm_crtc_helper_add(&acrtc->base, &amdgpu_dm_crtc_helper_funcs);
+        drm_crtc_helper_add(&acrtc->base, &amdgpu_dm_crtc_helper_funcs);
 
         acrtc->max_cursor_width = dm->adev->dm.dc->caps.max_cursor_size;
         acrtc->max_cursor_height = dm->adev->dm.dc->caps.max_cursor_size;
- 
+
         acrtc->crtc_id = crtc_index;
-	acrtc->base.enabled = false;
+        acrtc->base.enabled = false;
 
         dm->adev->mode_info.crtcs[crtc_index] = acrtc;
-	drm_mode_crtc_set_gamma_size(&acrtc->base, 256);
+        drm_mode_crtc_set_gamma_size(&acrtc->base, 256);
 
-	return 0;
+        return 0;
 fail:
-        kfree(primary_plane);
-fail_plane:
-	acrtc->crtc_id = -1;
-	return res;
+        kfree(acrtc);
+        acrtc->crtc_id = -1;
+        return res;
+
 }
 
 static int to_drm_connector_type(enum signal_type st)
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
index 1bbeb87..ab6d51d 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
@@ -34,8 +34,11 @@ struct dc_validation_set;
 struct dc_surface;
 
 /*TODO Jodan Hersen use the one in amdgpu_dm*/
+int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
+			struct amdgpu_plane *aplane,
+			unsigned long possible_crtcs);
 int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
-			struct amdgpu_crtc *amdgpu_crtc,
+			struct drm_plane *plane,
 			uint32_t link_index);
 int amdgpu_dm_connector_init(struct amdgpu_display_manager *dm,
 			struct amdgpu_connector *amdgpu_connector,
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 0731045..9dd8b2a 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -45,6 +45,7 @@ struct dc_caps {
 	uint32_t max_links;
 	uint32_t max_audios;
 	uint32_t max_slave_planes;
+	uint32_t max_surfaces;
 	uint32_t max_downscale_ratio;
 	uint32_t i2c_speed_in_khz;
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 065a298..e3beb28 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -1461,6 +1461,8 @@ static bool construct(
 
 	bw_calcs_data_update_from_pplib(dc);
 
+	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+
 	return true;
 
 res_create_fail:
-- 
2.7.4

