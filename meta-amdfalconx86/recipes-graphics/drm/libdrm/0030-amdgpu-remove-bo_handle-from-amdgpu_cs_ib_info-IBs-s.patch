From b7f8a8f48423ec716504fcde60c8b8513cb373c4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 2 Jun 2015 13:05:41 +0200
Subject: [PATCH 30/67] amdgpu: remove bo_handle from amdgpu_cs_ib_info, IBs
 should be in buffer list
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
Signed-off-by: Arindam Nath <arindam.nath@amd.com>
---
 amdgpu/amdgpu.h            |  7 ++-----
 amdgpu/amdgpu_cs.c         |  5 ++---
 include/drm/amdgpu_drm.h   |  6 +-----
 tests/amdgpu/amdgpu_test.h |  9 +++++++++
 tests/amdgpu/basic_tests.c | 48 +++++++++++++++++++++++++++++++++++++---------
 tests/amdgpu/cs_tests.c    |  9 +++++++--
 tests/amdgpu/vce_tests.c   | 11 ++++++++---
 7 files changed, 68 insertions(+), 27 deletions(-)

diff --git a/amdgpu/amdgpu.h b/amdgpu/amdgpu.h
index 451437d..70b488e 100644
--- a/amdgpu/amdgpu.h
+++ b/amdgpu/amdgpu.h
@@ -283,8 +283,8 @@ struct amdgpu_cs_ib_info {
 	/** Special flags */
 	uint64_t      flags;
 
-	/** Handle of command buffer */
-	amdgpu_bo_handle bo_handle;
+	/** Virtual MC address of the command buffer */
+	uint64_t      ib_mc_address;
 
 	/**
 	 * Size of Command Buffer to be submitted.
@@ -293,9 +293,6 @@ struct amdgpu_cs_ib_info {
 	 *   - Could be 0
 	 */
 	uint32_t       size;
-
-	/** Offset in the IB buffer object (in unit of dwords) */
-	uint32_t	offset_dw;
 };
 
 /**
diff --git a/amdgpu/amdgpu_cs.c b/amdgpu/amdgpu_cs.c
index 2a039d6..a1e68f8 100644
--- a/amdgpu/amdgpu_cs.c
+++ b/amdgpu/amdgpu_cs.c
@@ -224,9 +224,8 @@ static int amdgpu_cs_submit_one(amdgpu_context_handle context,
 
 		ib = &ibs_request->ibs[i];
 
-		chunk_data[i].ib_data.handle = ib->bo_handle->handle;
-		chunk_data[i].ib_data.va_start = ib->bo_handle->virtual_mc_base_address
-						+ ib->offset_dw * 4;
+		chunk_data[i].ib_data._pad = 0;
+		chunk_data[i].ib_data.va_start = ib->ib_mc_address;
 		chunk_data[i].ib_data.ib_bytes = ib->size * 4;
 		chunk_data[i].ib_data.ip_type = ibs_request->ip_type;
 		chunk_data[i].ib_data.ip_instance = ibs_request->ip_instance;
diff --git a/include/drm/amdgpu_drm.h b/include/drm/amdgpu_drm.h
index 9a811d2..179bd78 100644
--- a/include/drm/amdgpu_drm.h
+++ b/include/drm/amdgpu_drm.h
@@ -378,11 +378,7 @@ union drm_amdgpu_cs {
 #define AMDGPU_IB_FLAG_PREAMBLE (1<<2)
 
 struct drm_amdgpu_cs_chunk_ib {
-	/**
-	 * Handle of GEM object to be used as IB or 0 if it is already in
-	 * residency list.
-	 */
-	uint32_t handle;
+	uint32_t _pad;
 	uint32_t flags;		/* IB Flags */
 	uint64_t va_start;	/* Virtual address to begin IB execution */
 	uint32_t ib_bytes;	/* Size of submission */
diff --git a/tests/amdgpu/amdgpu_test.h b/tests/amdgpu/amdgpu_test.h
index d97cb91..dd3b8bc 100644
--- a/tests/amdgpu/amdgpu_test.h
+++ b/tests/amdgpu/amdgpu_test.h
@@ -160,4 +160,13 @@ amdgpu_bo_alloc_and_map(amdgpu_device_handle dev, unsigned size,
 	return 0;
 }
 
+static inline int
+amdgpu_get_bo_list(amdgpu_device_handle dev, amdgpu_bo_handle bo1,
+		   amdgpu_bo_handle bo2, amdgpu_bo_list_handle *list)
+{
+	amdgpu_bo_handle resources[] = {bo1, bo2};
+
+	return amdgpu_bo_list_create(dev, bo2 ? 2 : 1, resources, NULL, list);
+}
+
 #endif  /* #ifdef _AMDGPU_TEST_H_ */
diff --git a/tests/amdgpu/basic_tests.c b/tests/amdgpu/basic_tests.c
index 1afcdac..9374399 100644
--- a/tests/amdgpu/basic_tests.c
+++ b/tests/amdgpu/basic_tests.c
@@ -164,6 +164,7 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 	struct amdgpu_cs_query_fence fence_status = {0};
 	uint32_t *ptr;
 	uint32_t expired;
+	amdgpu_bo_list_handle bo_list;
 	int r;
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
@@ -181,6 +182,10 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 				    &ib_result_ce_mc_address);
 	CU_ASSERT_EQUAL(r, 0);
 
+	r = amdgpu_get_bo_list(device_handle, ib_result_handle,
+			       ib_result_ce_handle, &bo_list);
+	CU_ASSERT_EQUAL(r, 0);
+
 	memset(ib_info, 0, 2 * sizeof(struct amdgpu_cs_ib_info));
 
 	/* IT_SET_CE_DE_COUNTERS */
@@ -189,7 +194,7 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 	ptr[1] = 0;
 	ptr[2] = 0xc0008400;
 	ptr[3] = 1;
-	ib_info[0].bo_handle = ib_result_ce_handle;
+	ib_info[0].ib_mc_address = ib_result_ce_mc_address;
 	ib_info[0].size = 4;
 	ib_info[0].flags = AMDGPU_IB_FLAG_CE;
 
@@ -197,12 +202,13 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 	ptr = ib_result_cpu;
 	ptr[0] = 0xc0008600;
 	ptr[1] = 0x00000001;
-	ib_info[1].bo_handle = ib_result_handle;
+	ib_info[1].ib_mc_address = ib_result_mc_address;
 	ib_info[1].size = 2;
 
 	ibs_request.ip_type = AMDGPU_HW_IP_GFX;
 	ibs_request.number_of_ibs = 2;
 	ibs_request.ibs = ib_info;
+	ibs_request.resources = bo_list;
 
 	r = amdgpu_cs_submit(context_handle, 0,
 			     &ibs_request, 1, &fence_status.fence);
@@ -221,6 +227,9 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 	r = amdgpu_bo_free(ib_result_ce_handle);
 	CU_ASSERT_EQUAL(r, 0);
 
+	r = amdgpu_bo_list_destroy(bo_list);
+	CU_ASSERT_EQUAL(r, 0);
+
 	r = amdgpu_cs_ctx_free(context_handle);
 	CU_ASSERT_EQUAL(r, 0);
 }
@@ -236,6 +245,7 @@ static void amdgpu_command_submission_gfx_shared_ib(void)
 	struct amdgpu_cs_query_fence fence_status = {0};
 	uint32_t *ptr;
 	uint32_t expired;
+	amdgpu_bo_list_handle bo_list;
 	int r;
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
@@ -247,6 +257,10 @@ static void amdgpu_command_submission_gfx_shared_ib(void)
 				    &ib_result_mc_address);
 	CU_ASSERT_EQUAL(r, 0);
 
+	r = amdgpu_get_bo_list(device_handle, ib_result_handle, NULL,
+			       &bo_list);
+	CU_ASSERT_EQUAL(r, 0);
+
 	memset(ib_info, 0, 2 * sizeof(struct amdgpu_cs_ib_info));
 
 	/* IT_SET_CE_DE_COUNTERS */
@@ -255,20 +269,20 @@ static void amdgpu_command_submission_gfx_shared_ib(void)
 	ptr[1] = 0;
 	ptr[2] = 0xc0008400;
 	ptr[3] = 1;
-	ib_info[0].bo_handle = ib_result_handle;
+	ib_info[0].ib_mc_address = ib_result_mc_address;
 	ib_info[0].size = 4;
 	ib_info[0].flags = AMDGPU_IB_FLAG_CE;
 
 	ptr = (uint32_t *)ib_result_cpu + 4;
 	ptr[0] = 0xc0008600;
 	ptr[1] = 0x00000001;
-	ib_info[1].bo_handle = ib_result_handle;
+	ib_info[1].ib_mc_address = ib_result_mc_address + 16;
 	ib_info[1].size = 2;
-	ib_info[1].offset_dw = 4;
 
 	ibs_request.ip_type = AMDGPU_HW_IP_GFX;
 	ibs_request.number_of_ibs = 2;
 	ibs_request.ibs = ib_info;
+	ibs_request.resources = bo_list;
 
 	r = amdgpu_cs_submit(context_handle, 0,
 			&ibs_request, 1, &fence_status.fence);
@@ -284,6 +298,9 @@ static void amdgpu_command_submission_gfx_shared_ib(void)
 	r = amdgpu_bo_free(ib_result_handle);
 	CU_ASSERT_EQUAL(r, 0);
 
+	r = amdgpu_bo_list_destroy(bo_list);
+	CU_ASSERT_EQUAL(r, 0);
+
 	r = amdgpu_cs_ctx_free(context_handle);
 	CU_ASSERT_EQUAL(r, 0);
 }
@@ -308,6 +325,7 @@ static void amdgpu_command_submission_compute(void)
 	uint32_t *ptr;
 	uint32_t expired;
 	int i, r, instance;
+	amdgpu_bo_list_handle bo_list;
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
 	CU_ASSERT_EQUAL(r, 0);
@@ -319,12 +337,16 @@ static void amdgpu_command_submission_compute(void)
 					    &ib_result_mc_address);
 		CU_ASSERT_EQUAL(r, 0);
 
+		r = amdgpu_get_bo_list(device_handle, ib_result_handle, NULL,
+				       &bo_list);
+		CU_ASSERT_EQUAL(r, 0);
+
 		ptr = ib_result_cpu;
 		for (i = 0; i < 16; ++i)
 			ptr[i] = 0xffff1000;
 
 		memset(&ib_info, 0, sizeof(struct amdgpu_cs_ib_info));
-		ib_info.bo_handle = ib_result_handle;
+		ib_info.ib_mc_address = ib_result_mc_address;
 		ib_info.size = 16;
 
 		memset(&ibs_request, 0, sizeof(struct amdgpu_cs_request));
@@ -332,6 +354,7 @@ static void amdgpu_command_submission_compute(void)
 		ibs_request.ring = instance;
 		ibs_request.number_of_ibs = 1;
 		ibs_request.ibs = &ib_info;
+		ibs_request.resources = bo_list;
 
 		memset(&fence_status, 0, sizeof(struct amdgpu_cs_query_fence));
 		r = amdgpu_cs_submit(context_handle, 0,
@@ -346,6 +369,9 @@ static void amdgpu_command_submission_compute(void)
 		r = amdgpu_cs_query_fence_status(&fence_status, &expired);
 		CU_ASSERT_EQUAL(r, 0);
 
+		r = amdgpu_bo_list_destroy(bo_list);
+		CU_ASSERT_EQUAL(r, 0);
+
 		r = amdgpu_bo_free(ib_result_handle);
 		CU_ASSERT_EQUAL(r, 0);
 	}
@@ -365,13 +391,14 @@ static void amdgpu_sdma_test_exec_cs(amdgpu_context_handle context_handle,
 				 struct amdgpu_cs_ib_info *ib_info,
 				 struct amdgpu_cs_request *ibs_request)
 {
-	int r, i, j;
+	int r;
 	uint32_t expired;
 	uint32_t *ring_ptr;
 	amdgpu_bo_handle ib_result_handle;
 	void *ib_result_cpu;
 	uint64_t ib_result_mc_address;
 	struct amdgpu_cs_query_fence fence_status = {0};
+	amdgpu_bo_handle *all_res = alloca(sizeof(resources[0]) * (res_cnt + 1));
 
 	/* prepare CS */
 	CU_ASSERT_NOT_EQUAL(pm4_src, NULL);
@@ -391,7 +418,7 @@ static void amdgpu_sdma_test_exec_cs(amdgpu_context_handle context_handle,
 	ring_ptr = ib_result_cpu;
 	memcpy(ring_ptr, pm4_src, pm4_dw * sizeof(*pm4_src));
 
-	ib_info->bo_handle = ib_result_handle;
+	ib_info->ib_mc_address = ib_result_mc_address;
 	ib_info->size = pm4_dw;
 
 	ibs_request->ip_type = AMDGPU_HW_IP_DMA;
@@ -399,7 +426,10 @@ static void amdgpu_sdma_test_exec_cs(amdgpu_context_handle context_handle,
 	ibs_request->number_of_ibs = 1;
 	ibs_request->ibs = ib_info;
 
-	r = amdgpu_bo_list_create(device_handle, res_cnt, resources,
+	memcpy(all_res, resources, sizeof(resources[0]) * res_cnt);
+	all_res[res_cnt] = ib_result_handle;
+
+	r = amdgpu_bo_list_create(device_handle, res_cnt+1, all_res,
 				  NULL, &ibs_request->resources);
 	CU_ASSERT_EQUAL(r, 0);
 
diff --git a/tests/amdgpu/cs_tests.c b/tests/amdgpu/cs_tests.c
index 6e76dcc..63cdbb5 100644
--- a/tests/amdgpu/cs_tests.c
+++ b/tests/amdgpu/cs_tests.c
@@ -41,7 +41,8 @@ static uint32_t family_id;
 
 static amdgpu_context_handle context_handle;
 static amdgpu_bo_handle ib_handle;
-uint32_t *ib_cpu;
+static uint64_t ib_mc_address;
+static uint32_t *ib_cpu;
 
 static amdgpu_bo_handle resources[MAX_RESOURCES];
 static unsigned num_resources;
@@ -83,6 +84,7 @@ int suite_cs_tests_init(void)
 		return CUE_SINIT_FAILED;
 
 	ib_handle = ib_result_handle;
+	ib_mc_address = ib_result_mc_address;
 	ib_cpu = ib_result_cpu;
 
 	return CUE_SUCCESS;
@@ -115,7 +117,7 @@ static int submit(unsigned ndw, unsigned ip)
 	uint32_t expired;
 	int r;
 
-	ib_info.bo_handle = ib_handle;
+	ib_info.ib_mc_address = ib_mc_address;
 	ib_info.size = ndw;
 
 	ibs_request.ip_type = ip;
@@ -183,6 +185,7 @@ static void amdgpu_cs_uvd_create(void)
 
 	num_resources = 0;
 	resources[num_resources++] = res.buf_handle;
+	resources[num_resources++] = ib_handle;
 
 	i = 0;
 	uvd_cmd(res.virtual_mc_base_address, 0x0, &i);
@@ -244,6 +247,7 @@ static void amdgpu_cs_uvd_decode(void)
 
 	num_resources = 0;
 	resources[num_resources++] = res.buf_handle;
+	resources[num_resources++] = ib_handle;
 
 	msg_addr = res.virtual_mc_base_address;
 	fb_addr = msg_addr + 4*1024;
@@ -308,6 +312,7 @@ static void amdgpu_cs_uvd_destroy(void)
 
 	num_resources = 0;
 	resources[num_resources++] = res.buf_handle;
+	resources[num_resources++] = ib_handle;
 
 	i = 0;
 	uvd_cmd(res.virtual_mc_base_address, 0x0, &i);
diff --git a/tests/amdgpu/vce_tests.c b/tests/amdgpu/vce_tests.c
index 45cfae2..70e378c 100644
--- a/tests/amdgpu/vce_tests.c
+++ b/tests/amdgpu/vce_tests.c
@@ -62,7 +62,8 @@ static uint32_t family_id;
 
 static amdgpu_context_handle context_handle;
 static amdgpu_bo_handle ib_handle;
-uint32_t *ib_cpu;
+static uint64_t ib_mc_address;
+static uint32_t *ib_cpu;
 
 static struct amdgpu_vce_encode enc;
 static amdgpu_bo_handle resources[MAX_RESOURCES];
@@ -133,7 +134,7 @@ static int submit(unsigned ndw, unsigned ip)
 	uint32_t expired;
 	int r;
 
-	ib_info.bo_handle = ib_handle;
+	ib_info.ib_mc_address = ib_mc_address;
 	ib_info.size = ndw;
 
 	ibs_request.ip_type = ip;
@@ -161,6 +162,7 @@ static int submit(unsigned ndw, unsigned ip)
 				    &ib_mc_address);
 	if (r)
 		return r;
+	resources[num_resources-1] = ib_handle;
 
 	fence_status.context = context_handle;
 	fence_status.timeout_ns = AMDGPU_TIMEOUT_INFINITE;
@@ -202,6 +204,7 @@ static void amdgpu_cs_vce_create(void)
 	num_resources  = 0;
 	alloc_resource(&enc.fb[0], 4096, AMDGPU_GEM_DOMAIN_GTT);
 	resources[num_resources++] = enc.fb[0].handle;
+	resources[num_resources++] = ib_handle;
 
 	len = 0;
 	memcpy(ib_cpu, vce_session, sizeof(vce_session));
@@ -385,6 +388,7 @@ static void amdgpu_cs_vce_encode(void)
 	resources[num_resources++] = enc.vbuf.handle;
 	alloc_resource(&enc.cpb, cpb_size, AMDGPU_GEM_DOMAIN_VRAM);
 	resources[num_resources++] = enc.cpb.handle;
+	resources[num_resources++] = ib_handle;
 
 	r = amdgpu_bo_cpu_map(enc.vbuf.handle, (void **)&enc.vbuf.ptr);
 	CU_ASSERT_EQUAL(r, 0);
@@ -423,7 +427,7 @@ static void amdgpu_cs_vce_encode(void)
 		check_result(&enc);
 	}
 
-	for (i = 0; i < num_resources; ++i) {
+	for (i = 0; i < num_resources-1; ++i) {
 		r = amdgpu_bo_free(resources[i]);
 		CU_ASSERT_EQUAL(r, 0);
 	}
@@ -436,6 +440,7 @@ static void amdgpu_cs_vce_destroy(void)
 	num_resources  = 0;
 	alloc_resource(&enc.fb[0], 4096, AMDGPU_GEM_DOMAIN_GTT);
 	resources[num_resources++] = enc.fb[0].handle;
+	resources[num_resources++] = ib_handle;
 
 	len = 0;
 	memcpy(ib_cpu, vce_session, sizeof(vce_session));
-- 
1.9.1

