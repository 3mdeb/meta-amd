From 9d6a74f24de90e0d72ea00df4e7a94e2bde9b6e3 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Thu, 19 May 2016 18:44:30 -0400
Subject: [PATCH 0501/1722] drm/amd/dal: make validate context a pointer in dc

This negates the need for tedius pointer updates when we
copy new context into current each commit surface
and target

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 88 +++++++++++++---------
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |  8 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_target.c        | 16 ++--
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  4 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 12 +--
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  6 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  8 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  4 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_dc.h           |  2 +-
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |  4 +
 10 files changed, 88 insertions(+), 64 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 00432aa..5657e66 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -211,8 +211,8 @@ static bool dc_stream_adjust_vmin_vmax(struct dc *dc, const struct dc_stream **s
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context.res_ctx.pipe_ctx[i].stream == core_stream) {
-			pipes = &core_dc->current_context.res_ctx.pipe_ctx[i];
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == core_stream) {
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
 			core_dc->hwss.set_drr(&pipes, 1, vmin, vmax);
 
 			ret = true;
@@ -241,6 +241,13 @@ static bool construct(struct core_dc *dc, const struct dc_init_data *init_params
 		goto ctx_fail;
 	}
 
+	dc->current_context = dm_alloc(sizeof(*dc->current_context));
+
+	if (!dc->current_context) {
+		dm_error("%s: failed to create validate ctx\n", __func__);
+		goto val_ctx_fail;
+	}
+
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
 	dc_ctx->dc = &dc->public;
@@ -313,6 +320,8 @@ create_links_fail:
 as_fail:
 	dal_logger_destroy(&dc_ctx->logger);
 logger_fail:
+	dm_free(dc->current_context);
+val_ctx_fail:
 	dm_free(dc_ctx);
 ctx_fail:
 	return false;
@@ -320,11 +329,14 @@ ctx_fail:
 
 static void destruct(struct core_dc *dc)
 {
-	resource_validate_ctx_destruct(&dc->current_context);
+	resource_validate_ctx_destruct(dc->current_context);
+	dm_free(dc->current_context);
+	dc->current_context = NULL;
 	destroy_links(dc);
 	dc->res_pool.funcs->destruct(&dc->res_pool);
 	dal_logger_destroy(&dc->ctx->logger);
 	dm_free(dc->ctx);
+	dc->ctx = NULL;
 }
 
 /*
@@ -559,11 +571,11 @@ static bool targets_changed(
 {
 	uint8_t i;
 
-	if (target_count != dc->current_context.target_count)
+	if (target_count != dc->current_context->target_count)
 		return true;
 
-	for (i = 0; i < dc->current_context.target_count; i++) {
-		if (&dc->current_context.targets[i]->public != targets[i])
+	for (i = 0; i < dc->current_context->target_count; i++) {
+		if (&dc->current_context->targets[i]->public != targets[i])
 			return true;
 	}
 
@@ -799,11 +811,11 @@ bool dc_commit_targets(
 		core_dc->hwss.enable_accelerated_mode(core_dc);
 	}
 
-	for (i = 0; i < core_dc->current_context.target_count; i++) {
+	for (i = 0; i < core_dc->current_context->target_count; i++) {
 		/*TODO: optimize this to happen only when necessary*/
 		target_disable_memory_requests(
-				&core_dc->current_context.targets[i]->public,
-				&core_dc->current_context.res_ctx);
+				&core_dc->current_context->targets[i]->public,
+				&core_dc->current_context->res_ctx);
 	}
 
 	if (result == DC_OK) {
@@ -816,7 +828,7 @@ bool dc_commit_targets(
 
 		if (context->target_status[i].surface_count > 0)
 			target_enable_memory_requests(dc_target,
-					&core_dc->current_context.res_ctx);
+					&core_dc->current_context->res_ctx);
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
 				dc_target->streams[0]->timing.h_addressable,
@@ -831,9 +843,12 @@ bool dc_commit_targets(
 	pplib_apply_display_requirements(core_dc,
 			context, &context->pp_display_cfg);
 
-	resource_validate_ctx_destruct(&core_dc->current_context);
+	resource_validate_ctx_destruct(core_dc->current_context);
 
-	core_dc->current_context = *context;
+	dm_free(core_dc->current_context);
+	core_dc->current_context = context;
+
+	return (result == DC_OK);
 
 fail:
 	dm_free(context);
@@ -853,7 +868,7 @@ bool dc_commit_surfaces_to_target(
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 
 	int i, j;
-	uint32_t prev_disp_clk = core_dc->current_context.bw_results.dispclk_khz;
+	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 	struct dc_target_status *target_status = NULL;
 	struct validate_context *context;
@@ -861,13 +876,18 @@ bool dc_commit_surfaces_to_target(
 	int new_enabled_surface_count = 0;
 	bool is_mpo_turning_on = false;
 
-	if (core_dc->current_context.target_count == 0)
+	if (core_dc->current_context->target_count == 0)
 		return false;
 
 
 	context = dm_alloc(sizeof(struct validate_context));
 
-	resource_validate_ctx_copy_construct(&core_dc->current_context, context);
+	if (!context) {
+		dm_error("%s: failed to create validate ctx\n", __func__);
+		goto val_ctx_fail;
+	}
+
+	resource_validate_ctx_copy_construct(core_dc->current_context, context);
 
 	/* Cannot commit surface to a target that is not commited */
 	for (i = 0; i < context->target_count; i++)
@@ -941,7 +961,7 @@ bool dc_commit_surfaces_to_target(
 
 	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
 		target_disable_memory_requests(dc_target,
-				&core_dc->current_context.res_ctx);
+				&core_dc->current_context->res_ctx);
 
 	for (i = 0; i < new_surface_count; i++)
 		for (j = 0; j < context->res_ctx.pool.pipe_count; j++) {
@@ -1035,17 +1055,17 @@ bool dc_commit_surfaces_to_target(
 						&context->pp_display_cfg);
 	}
 
+	resource_validate_ctx_destruct(core_dc->current_context);
+	dm_free(core_dc->current_context);
+	core_dc->current_context = context;
 
-	resource_validate_ctx_destruct(&(core_dc->current_context));
-	core_dc->current_context = *context;
-	dm_free(context);
 	return true;
 
 unexpected_fail:
-
 	resource_validate_ctx_destruct(context);
-
 	dm_free(context);
+val_ctx_fail:
+
 	return false;
 }
 
@@ -1064,10 +1084,10 @@ bool dc_update_surfaces_for_target(
 	struct dc_target_status *target_status = NULL;
 	struct validate_context *context;
 
-	if (core_dc->current_context.target_count == 0)
+	if (core_dc->current_context->target_count == 0)
 		return false;
 
-	context = &core_dc->current_context;
+	context = core_dc->current_context;
 
 	/* Cannot commit surface to a target that is not committed */
 	for (i = 0; i < context->target_count; i++)
@@ -1117,14 +1137,14 @@ bool dc_update_surfaces_for_target(
 uint8_t dc_get_current_target_count(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return core_dc->current_context.target_count;
+	return core_dc->current_context->target_count;
 }
 
 struct dc_target *dc_get_target_at_index(const struct dc *dc, uint8_t i)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	if (i < core_dc->current_context.target_count)
-		return &(core_dc->current_context.targets[i]->public);
+	if (i < core_dc->current_context->target_count)
+		return &(core_dc->current_context->targets[i]->public);
 	return NULL;
 }
 
@@ -1169,12 +1189,12 @@ void dc_flip_surface_addrs(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i, j;
-	int pipe_count = core_dc->current_context.res_ctx.pool.pipe_count;
+	int pipe_count = core_dc->current_context->res_ctx.pool.pipe_count;
 
 	for (i = 0; i < count; i++)
 		for (j = 0; j < pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx =
-				&core_dc->current_context.res_ctx.pipe_ctx[j];
+				&core_dc->current_context->res_ctx.pipe_ctx[j];
 			struct core_surface *ctx_surface = pipe_ctx->surface;
 
 			if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
@@ -1197,7 +1217,7 @@ void dc_flip_surface_addrs(
 	for (j = pipe_count - 1; j >= 0; j--)
 		for (i = count - 1; i >= 0; i--) {
 			struct pipe_ctx *pipe_ctx =
-				&core_dc->current_context.res_ctx.pipe_ctx[j];
+				&core_dc->current_context->res_ctx.pipe_ctx[j];
 			struct core_surface *ctx_surface = pipe_ctx->surface;
 
 			if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
@@ -1265,15 +1285,15 @@ const struct dc_target *dc_get_target_on_irq_source(
 		return NULL;
 	}
 
-	for (i = 0; i < core_dc->current_context.target_count; i++) {
-		struct core_target *target = core_dc->current_context.targets[i];
+	for (i = 0; i < core_dc->current_context->target_count; i++) {
+		struct core_target *target = core_dc->current_context->targets[i];
 		struct dc_target *dc_target = &target->public;
 
 		for (j = 0; j < target->public.stream_count; j++) {
 			const struct core_stream *stream =
 				DC_STREAM_TO_CORE(dc_target->streams[j]);
 
-			if (core_dc->current_context.res_ctx.
+			if (core_dc->current_context->res_ctx.
 					pipe_ctx[crtc_idx].stream == stream)
 				return dc_target;
 		}
@@ -1307,8 +1327,8 @@ void dc_set_power_state(
 		 * clean state, and dc hw programming optimizations will not
 		 * cause any trouble.
 		 */
-		memset(&core_dc->current_context, 0,
-				sizeof(core_dc->current_context));
+		memset(core_dc->current_context, 0,
+				sizeof(*core_dc->current_context));
 		break;
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 4dbd2f5..ded5f98 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -836,7 +836,7 @@ enum dc_status resource_map_pool_resources(
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 
-			if (!resource_is_stream_unchanged(&dc->current_context, stream))
+			if (!resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			/* mark resources used for stream that is already active */
@@ -844,7 +844,7 @@ enum dc_status resource_map_pool_resources(
 				struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[k];
 				const struct pipe_ctx *old_pipe_ctx =
-					&dc->current_context.res_ctx.pipe_ctx[k];
+					&dc->current_context->res_ctx.pipe_ctx[k];
 
 				if (!are_streams_same(old_pipe_ctx->stream, stream))
 					continue;
@@ -884,7 +884,7 @@ enum dc_status resource_map_pool_resources(
 			struct pipe_ctx *pipe_ctx = NULL;
 			int pipe_idx = -1;
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 			/* acquire new resources */
 			pipe_idx = acquire_first_free_pipe(
@@ -1497,7 +1497,7 @@ enum dc_status resource_map_clock_resources(
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			for (k = 0; k < MAX_PIPES; k++) {
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
index 4fd42a5..ff1ec0e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_target.c
@@ -94,9 +94,9 @@ const struct dc_target_status *dc_target_get_status(
 	struct core_target* target = DC_TARGET_TO_CORE(dc_target);
     struct core_dc *dc = DC_TO_CORE(target->ctx->dc);
 
-	for (i = 0; i < dc->current_context.target_count; i++)
-		if (target == dc->current_context.targets[i])
-			return &dc->current_context.target_status[i];
+	for (i = 0; i < dc->current_context->target_count; i++)
+		if (target == dc->current_context->targets[i])
+			return &dc->current_context->target_status[i];
 
 	return NULL;
 }
@@ -166,7 +166,7 @@ bool dc_target_set_cursor_attributes(
 
 	target = DC_TARGET_TO_CORE(dc_target);
 	core_dc = DC_TO_CORE(target->ctx->dc);
-	res_ctx = &core_dc->current_context.res_ctx;
+	res_ctx = &core_dc->current_context->res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -211,7 +211,7 @@ bool dc_target_set_cursor_position(
 
 	target = DC_TARGET_TO_CORE(dc_target);
 	core_dc = DC_TO_CORE(target->ctx->dc);
-	res_ctx = &core_dc->current_context.res_ctx;
+	res_ctx = &core_dc->current_context->res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -240,7 +240,7 @@ uint32_t dc_target_get_vblank_counter(const struct dc_target *dc_target)
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 	struct core_dc *core_dc = DC_TO_CORE(target->ctx->dc);
 	struct resource_context *res_ctx =
-		&core_dc->current_context.res_ctx;
+		&core_dc->current_context->res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -266,7 +266,7 @@ uint32_t dc_target_get_scanoutpos(
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 	struct core_dc *core_dc = DC_TO_CORE(target->ctx->dc);
 	struct resource_context *res_ctx =
-		&core_dc->current_context.res_ctx;
+		&core_dc->current_context->res_ctx;
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -296,7 +296,7 @@ enum dc_irq_source dc_target_get_irq_src(
 			DC_STREAM_TO_CORE(core_target->public.streams[0]);
 
 	for (i = 0; i < MAX_PIPES; i++)
-		if (core_dc->current_context.res_ctx.pipe_ctx[i].stream == stream)
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == stream)
 			return irq_type + i;
 
 	return irq_type;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 98edb91..ebf30f9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -595,7 +595,7 @@ static enum dc_status validate_mapped_resource(
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			for (k = 0; k < MAX_PIPES; k++) {
@@ -660,7 +660,7 @@ enum dc_status dce100_validate_with_context(
 	context->res_ctx.pool = dc->res_pool;
 
 	if (!resource_validate_attach_surfaces(
-			set, set_count, &dc->current_context, context)) {
+			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 1e517c3..11bcfec 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -712,7 +712,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct core_dc *dc)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct pipe_ctx *pipe_ctx_old = &dc->current_context.res_ctx.
+	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
 	if (!pipe_ctx_old->stream) {
@@ -1200,7 +1200,7 @@ static enum dc_status apply_ctx_to_hw(
 	/* look up the targets that have been removed since last commit */
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_context.res_ctx.pipe_ctx[i];
+			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		/* Note: We need to disable output if clock sources change,
@@ -1214,7 +1214,7 @@ static enum dc_status apply_ctx_to_hw(
 		if (!pipe_ctx->stream ||
 			pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			reset_single_pipe_hw_ctx(
-				dc, pipe_ctx_old, &dc->current_context);
+				dc, pipe_ctx_old, dc->current_context);
 	}
 
 	/* Skip applying if no targets */
@@ -1226,7 +1226,7 @@ static enum dc_status apply_ctx_to_hw(
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-					&dc->current_context.res_ctx.pipe_ctx[i];
+					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct dc_bios *dcb;
 
@@ -1253,12 +1253,12 @@ static enum dc_status apply_ctx_to_hw(
 	/*dc_set_clocks_and_clock_state(context);*/
 
 	if (context->bw_results.dispclk_khz
-		> dc->current_context.bw_results.dispclk_khz)
+		> dc->current_context->bw_results.dispclk_khz)
 		set_display_clock(context);
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-					&dc->current_context.res_ctx.pipe_ctx[i];
+					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index de1febd..693ec70 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -619,7 +619,7 @@ static enum dc_status validate_mapped_resource(
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			for (k = 0; k < MAX_PIPES; k++) {
@@ -785,7 +785,7 @@ enum dc_status dce110_validate_bandwidth(
 			"%s: Bandwidth validation failed!",
 			__func__);
 
-	if (memcmp(&dc->current_context.bw_results,
+	if (memcmp(&dc->current_context->bw_results,
 			&context->bw_results, sizeof(context->bw_results))) {
 		struct log_entry log_entry;
 		dal_logger_open(
@@ -851,7 +851,7 @@ enum dc_status dce110_validate_with_context(
 	context->res_ctx.pool = dc->res_pool;
 
 	if (!resource_validate_attach_surfaces(
-			set, set_count, &dc->current_context, context)) {
+			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 5b4f52b..de4790d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -645,7 +645,7 @@ static enum dc_status validate_mapped_resource(
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			for (k = 0; k < MAX_PIPES; k++) {
@@ -808,7 +808,7 @@ enum dc_status dce112_validate_bandwidth(
 			"%s: Bandwidth validation failed!",
 			__func__);
 
-	if (memcmp(&dc->current_context.bw_results,
+	if (memcmp(&dc->current_context->bw_results,
 			&context->bw_results, sizeof(context->bw_results))) {
 		struct log_entry log_entry;
 		dal_logger_open(
@@ -876,7 +876,7 @@ static enum dc_status map_clock_resources(
 			struct core_stream *stream =
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			for (k = 0; k < MAX_PIPES; k++) {
@@ -923,7 +923,7 @@ enum dc_status dce112_validate_with_context(
 	context->res_ctx.pool = dc->res_pool;
 
 	if (!resource_validate_attach_surfaces(
-			set, set_count, &dc->current_context, context)) {
+			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index e12a0e5..6849896 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -549,7 +549,7 @@ static enum dc_status validate_mapped_resource(
 				DC_STREAM_TO_CORE(target->public.streams[j]);
 			struct core_link *link = stream->sink->link;
 
-			if (resource_is_stream_unchanged(&dc->current_context, stream))
+			if (resource_is_stream_unchanged(dc->current_context, stream))
 				continue;
 
 			for (k = 0; k < MAX_PIPES; k++) {
@@ -615,7 +615,7 @@ enum dc_status dce80_validate_with_context(
 	context->res_ctx.pool = dc->res_pool;
 
 	if (!resource_validate_attach_surfaces(
-			set, set_count, &dc->current_context, context)) {
+			set, set_count, dc->current_context, context)) {
 		DC_ERROR("Failed to attach surface to target!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
index 21860e4..f0c5a54 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_dc.h
@@ -22,7 +22,7 @@ struct core_dc {
 	struct core_link *links[MAX_PIPES * 2];
 
 	/* TODO: determine max number of targets*/
-	struct validate_context current_context;
+	struct validate_context *current_context;
 	struct resource_pool res_pool;
 
 	/*Power State*/
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index c8ce3d8..1222466 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -99,6 +99,10 @@ void validate_guaranteed_copy_target(
 		struct validate_context *context,
 		int max_targets);
 
+void resource_validate_ctx_update_pointer_after_copy(
+		const struct validate_context *src_ctx,
+		struct validate_context *dst_ctx);
+
 void resource_validate_ctx_copy_construct(
 		const struct validate_context *src_ctx,
 		struct validate_context *dst_ctx);
-- 
2.7.4

