From 8636e28bd489c2e591e1535f7d648b0c23dc7172 Mon Sep 17 00:00:00 2001
From: Amy Zhang <Amy.Zhang@amd.com>
Date: Mon, 8 Aug 2016 18:14:49 -0400
Subject: [PATCH 0728/1722] drm/amd/dal: Add ability to write and read
 persistent data

- read and write call back functions for accessing registry editor
- Made sure the expandable folders are properly organized

Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c | 24 +++++++
 drivers/gpu/drm/amd/dal/dc/dm_services.h           | 76 ++++++++++++++++++++++
 .../gpu/drm/amd/dal/modules/freesync/freesync.c    | 73 +++++++++++++++++++++
 3 files changed, 173 insertions(+)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
index 85dcdf0..dc81357 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_services.c
@@ -88,6 +88,30 @@ bool dm_get_platform_info(struct dc_context *ctx,
 	return false;
 }
 
+bool dm_write_persistent_data(struct dc_context *ctx,
+		const struct dc_sink *sink,
+		const char *module_name,
+		const char *key_name,
+		void *params,
+		unsigned int size,
+		struct persistent_data_flag *flag)
+{
+	/*TODO implement*/
+	return false;
+}
+
+bool dm_read_persistent_data(struct dc_context *ctx,
+				const struct dc_sink *sink,
+				const char *module_name,
+				const char *key_name,
+				void *params,
+				unsigned int size,
+				struct persistent_data_flag *flag)
+{
+	/*TODO implement*/
+	return false;
+}
+
 /**** power component interfaces ****/
 
 bool dm_pp_pre_dce_clock_change(
diff --git a/drivers/gpu/drm/amd/dal/dc/dm_services.h b/drivers/gpu/drm/amd/dal/dc/dm_services.h
index c36a95d..526037f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dm_services.h
+++ b/drivers/gpu/drm/amd/dal/dc/dm_services.h
@@ -239,6 +239,82 @@ bool dm_get_platform_info(
 	struct dc_context *ctx,
 	struct platform_info_params *params);
 
+static const unsigned int MAX_NAME_LENGTH = 256;
+
+struct persistent_data_flag {
+	bool save_per_link;
+	bool save_per_edid;
+};
+
+/* Call to write data in registry editor for persistent data storage.
+ *
+ * \inputs      sink - identify edid/link for registry folder creation
+ *              module name - identify folders for registry
+ *              key name - identify keys within folders for registry
+ *              params - value to write in defined folder/key
+ *              size - size of the input params
+ *              flag - determine whether to save by link or edid
+ *
+ * \returns     true - call is successful
+ *              false - call failed
+ *
+ * sink         module         key
+ * -----------------------------------------------------------------------------
+ * NULL         NULL           NULL     - failure
+ * NULL         NULL           -        - create key with param value
+ *                                                      under base folder
+ * NULL         -              NULL     - create module folder under base folder
+ * -            NULL           NULL     - failure
+ * NULL         -              -        - create key under module folder
+ *                                            with no edid/link identification
+ * -            NULL           -        - create key with param value
+ *                                                       under base folder
+ * -            -              NULL     - create module folder under base folder
+ * -            -              -        - create key under module folder
+ *                                              with edid/link identification
+ */
+bool dm_write_persistent_data(struct dc_context *ctx,
+		const struct dc_sink *sink,
+		const char *module_name,
+		const char *key_name,
+		void *params,
+		unsigned int size,
+		struct persistent_data_flag *flag);
+
+
+/* Call to read data in registry editor for persistent data storage.
+ *
+ * \inputs      sink - identify edid/link for registry folder creation
+ *              module name - identify folders for registry
+ *              key name - identify keys within folders for registry
+ *              size - size of the output params
+ *              flag - determine whether it was save by link or edid
+ *
+ * \returns     params - value read from defined folder/key
+ *              true - call is successful
+ *              false - call failed
+ *
+ * sink         module         key
+ * -----------------------------------------------------------------------------
+ * NULL         NULL           NULL     - failure
+ * NULL         NULL           -        - read key under base folder
+ * NULL         -              NULL     - failure
+ * -            NULL           NULL     - failure
+ * NULL         -              -        - read key under module folder
+ *                                             with no edid/link identification
+ * -            NULL           -        - read key under base folder
+ * -            -              NULL     - failure
+ * -            -              -        - read key under module folder
+ *                                              with edid/link identification
+ */
+bool dm_read_persistent_data(struct dc_context *ctx,
+		const struct dc_sink *sink,
+		const char *module_name,
+		const char *key_name,
+		void *params,
+		unsigned int size,
+		struct persistent_data_flag *flag);
+
 /*
  *
  * print-out services
diff --git a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
index 7278a50..4106091 100644
--- a/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/dal/modules/freesync/freesync.c
@@ -27,6 +27,7 @@
 #include "dc.h"
 #include "mod_freesync.h"
 #include "core_types.h"
+#include "core_dc.h"
 
 #define MOD_FREESYNC_MAX_CONCURRENT_SINKS  32
 
@@ -79,6 +80,11 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 {
 	struct core_freesync *core_freesync =
 			dm_alloc(sizeof(struct core_freesync));
+
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct persistent_data_flag flag;
+
 	int i = 0;
 
 	if (core_freesync == NULL)
@@ -116,6 +122,12 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	if (!check_dc_support(dc))
 		goto fail_construct;
 
+	/* Create initial module folder in registry for freesync enable data */
+	flag.save_per_edid = true;
+	flag.save_per_link = false;
+	dm_write_persistent_data(core_dc->ctx, NULL, "freesync", NULL, NULL,
+					0, &flag);
+
 	return &core_freesync->public;
 
 fail_construct:
@@ -160,6 +172,12 @@ bool mod_freesync_add_sink(struct mod_freesync *mod_freesync,
 	struct core_freesync *core_freesync =
 			MOD_FREESYNC_TO_CORE(mod_freesync);
 
+	struct core_dc *core_dc = DC_TO_CORE(core_freesync->dc);
+
+	int persistent_freesync_enable = 0;
+
+	struct persistent_data_flag flag;
+
 	if (core_freesync->num_sinks < MOD_FREESYNC_MAX_CONCURRENT_SINKS) {
 		dc_sink_retain(sink);
 
@@ -177,6 +195,35 @@ bool mod_freesync_add_sink(struct mod_freesync *mod_freesync,
 		core_freesync->state[core_freesync->num_sinks].
 			static_ramp.ramp_is_active = false;
 
+		/* get persistent data from registry */
+		flag.save_per_edid = true;
+		flag.save_per_link = false;
+
+		if (dm_read_persistent_data(core_dc->ctx, sink, "freesync",
+					"userenable",
+					&persistent_freesync_enable,
+					sizeof(int), &flag)) {
+			core_freesync->user_enable[core_freesync->num_sinks].
+					enable_for_gaming =
+					(persistent_freesync_enable & 1)
+					? true : false;
+			core_freesync->user_enable[core_freesync->num_sinks].
+					enable_for_static =
+					(persistent_freesync_enable & 2)
+					? true : false;
+			core_freesync->user_enable[core_freesync->num_sinks].
+					enable_for_video =
+					(persistent_freesync_enable & 4)
+					? true : false;
+		} else {
+			core_freesync->user_enable[core_freesync->num_sinks].
+					enable_for_gaming = false;
+			core_freesync->user_enable[core_freesync->num_sinks].
+					enable_for_static = false;
+			core_freesync->user_enable[core_freesync->num_sinks].
+					enable_for_video = false;
+		}
+
 		core_freesync->num_sinks++;
 
 		return true;
@@ -667,8 +714,11 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 {
 	struct core_freesync *core_freesync =
 			MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_dc *core_dc = DC_TO_CORE(core_freesync->dc);
 
 	unsigned int stream_index, sink_index;
+	struct persistent_data_flag flag;
+	int persistent_data = 0;
 
 	for(stream_index = 0; stream_index < num_streams;
 			stream_index++){
@@ -677,6 +727,29 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 				streams[stream_index]->sink);
 
 		core_freesync->user_enable[sink_index] = *user_enable;
+
+		/* Write persistent data in registry*/
+		if (core_freesync->user_enable[sink_index].
+				enable_for_gaming)
+			persistent_data = persistent_data | 1;
+		if (core_freesync->user_enable[sink_index].
+				enable_for_static)
+			persistent_data = persistent_data | 2;
+		if (core_freesync->user_enable[sink_index].
+				enable_for_video)
+			persistent_data = persistent_data | 4;
+
+		flag.save_per_edid = true;
+		flag.save_per_link = false;
+
+		dm_write_persistent_data(core_dc->ctx,
+					streams[stream_index]->sink,
+					"freesync",
+					"userenable",
+					&persistent_data,
+					sizeof(int),
+					&flag);
+
 	}
 
 	set_freesync_on_streams(core_freesync, streams, num_streams);
-- 
2.7.4

