From 2057d8f75bcb73ff9e2cc9738af016f2e8c56537 Mon Sep 17 00:00:00 2001
From: Ayyappa Ch <ayyappa.chandolu@amd.com>
Date: Mon, 6 Feb 2017 18:49:05 +0530
Subject: [PATCH 1715/1722] drm/amd/amdgpu : Porting the code as per 4.4 POR
 kernel

modified vm interfaces function parameters as per 4.4
POR code

Signed-off-by: Ayyappa Ch <ayyappa.chandolu@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gpuvm.c |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c           |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c          |  2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c           | 65 ++++++++++++------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h           |  3 +-
 5 files changed, 38 insertions(+), 40 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gpuvm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gpuvm.c
index 9d44637..3eef2be 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gpuvm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gpuvm.c
@@ -967,7 +967,7 @@ static int unmap_bo_from_gpuvm(struct amdgpu_device *adev,
 
 	amdgpu_vm_bo_unmap(adev, bo_va, entry->va);
 
-	amdgpu_vm_clear_freed(adev, vm, &bo_va->last_pt_update);
+	amdgpu_vm_clear_freed(adev, vm);
 
 	amdgpu_sync_fence(adev, sync, bo_va->last_pt_update);
 
@@ -1003,7 +1003,7 @@ static int update_gpuvm_pte(struct amdgpu_device *adev, struct amdgpu_bo *bo,
 	amdgpu_sync_fence(adev, sync, vm->page_directory_fence);
 
 	/* Update the page tables  */
-	ret = amdgpu_vm_bo_update(adev, bo_va, &bo->tbo.mem);
+	ret = amdgpu_vm_bo_update(adev, bo_va, false);
 	if (ret != 0) {
 		pr_err("amdkfd: Failed to amdgpu_vm_bo_update\n");
 		return ret;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index c10ec65..167df00 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
@@ -808,7 +808,7 @@ static int amdgpu_bo_vm_update_pte(struct amdgpu_cs_parser *p,
 	if (r)
 		return r;
 
-	r = amdgpu_vm_clear_freed(adev, vm, NULL);
+	r = amdgpu_vm_clear_freed(adev, vm);
 	if (r)
 		return r;
 
@@ -1370,7 +1370,7 @@ amdgpu_cs_find_mapping(struct amdgpu_cs_parser *parser,
 		struct amdgpu_bo_list_entry *lobj;
 
 		lobj = &parser->bo_list->array[i];
-		if (!lobj->bo_va || amdgpu_ttm_adev(lobj->bo_va->bo) != parser->adev)
+		if (!lobj->bo_va || amdgpu_ttm_adev(lobj->bo_va->bo->tbo.bdev) != parser->adev)
 			continue;
 
 		list_for_each_entry(mapping, &lobj->bo_va->valids, list) {
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 036096c..5d5099f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
@@ -555,7 +555,7 @@ static void amdgpu_gem_va_update_vm(struct amdgpu_device *adev,
 	if (r)
 		goto error_unreserve;
 
-	r = amdgpu_vm_clear_freed(adev, bo_va->vm, NULL);
+	r = amdgpu_vm_clear_freed(adev, bo_va->vm);
 	if (r)
 		goto error_unreserve;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index c6f6d34..c5fa912 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -70,7 +70,7 @@ struct amdgpu_pte_update_params {
 	/* indicate update pt or its shadow */
 	bool shadow;
 	/* Kernel pointer of PD/PT BO that needs to be updated */
-	void *kptr;	
+	void *kptr;
 };
 
 /**
@@ -542,7 +542,7 @@ static void amdgpu_vm_do_set_ptes(struct amdgpu_pte_update_params *params,
 
 	} else {
 		amdgpu_vm_set_pte_pde(params->adev, params->ib, pe, addr,
-				      count, incr, flags);
+				count, incr, flags);
 	}
 }
 
@@ -737,7 +737,7 @@ int amdgpu_vm_update_page_directory(struct amdgpu_device *adev,
 	}
 
 	/* Submit IB if updating using SDMA */
-	if (params.ib) {	
+	if (params.ib) {
 		if (params.ib->length_dw == 0) {
 			amdgpu_job_free(job);
 			return 0;
@@ -747,11 +747,11 @@ int amdgpu_vm_update_page_directory(struct amdgpu_device *adev,
 				 AMDGPU_FENCE_OWNER_VM);
 		if (shadow)
 			amdgpu_sync_resv(adev, &job->sync, shadow->tbo.resv,
-					 AMDGPU_FENCE_OWNER_VM);
+					AMDGPU_FENCE_OWNER_VM);
 
 		WARN_ON(params.ib->length_dw > ndw);
 		r = amdgpu_job_submit(job, ring, &vm->entity,
-				      AMDGPU_FENCE_OWNER_VM, &fence);
+				AMDGPU_FENCE_OWNER_VM, &fence);
 		if (r)
 			goto error_free;
 
@@ -759,7 +759,6 @@ int amdgpu_vm_update_page_directory(struct amdgpu_device *adev,
 		fence_put(vm->page_directory_fence);
 		vm->page_directory_fence = fence_get(fence);
 		fence_put(fence);
-
 	} else if (params.kptr)
 		amdgpu_bo_kunmap(vm->page_directory);
 	return 0;
@@ -904,12 +903,12 @@ static void amdgpu_vm_frag_ptes(struct amdgpu_pte_update_params	*params,
 
 	unsigned count;
 	uint32_t incr = AMDGPU_VM_PTE_COUNT * 8;
+	
 	/* system pages are non continuously */
-	if (params->src || !(flags & AMDGPU_PTE_VALID) ||
+	if (params->src || params->pages_addr || !(flags & AMDGPU_PTE_VALID) ||
 	    (frag_start >= frag_end)) {
 
-		count = end - start;
-				
+		count = (end - start)/8;
 		if (params->kptr)
 			write_pte_using_cpu(params->adev, params, start, dst, count, incr, flags);
 		else
@@ -920,8 +919,7 @@ static void amdgpu_vm_frag_ptes(struct amdgpu_pte_update_params	*params,
 	/* handle the 4K area at the beginning */
 	if (start != frag_start) {
 	
-		count = frag_start - start;
-				
+		count = (frag_start - start)/8;
 		if (params->kptr)
 			write_pte_using_cpu(params->adev, params, start, dst, count, incr, flags);
 		else
@@ -931,8 +929,7 @@ static void amdgpu_vm_frag_ptes(struct amdgpu_pte_update_params	*params,
 	}
 
 	/* handle the area in the middle */
-	count = frag_end - frag_start;
-				
+	count = (frag_end - frag_start)/8;
 	if (params->kptr)
 		write_pte_using_cpu(params->adev, params, frag_start, dst, count, incr, flags);
 	else	
@@ -942,7 +939,7 @@ static void amdgpu_vm_frag_ptes(struct amdgpu_pte_update_params	*params,
 	/* handle the 4K area at the end */
 	if (frag_end != end) {
 		dst += (frag_end - frag_start) * AMDGPU_GPU_PAGE_SIZE;
-		count = end - frag_end;
+		count = (end - frag_end)/8;
 		if (params->kptr)
 			write_pte_using_cpu(params->adev, params, frag_end, dst, count, incr, flags);
 		else		
@@ -950,7 +947,6 @@ static void amdgpu_vm_frag_ptes(struct amdgpu_pte_update_params	*params,
 	}
 }
 
-
 /**
  * amdgpu_vm_update_ptes_cpu - make sure that page tables are valid
  *
@@ -964,8 +960,7 @@ static void amdgpu_vm_frag_ptes(struct amdgpu_pte_update_params	*params,
  *
  * Update the page tables in the range @start - @end using CPU
  */
-static int amdgpu_vm_update_ptes_cpu(struct amdgpu_device *adev,
-				     struct amdgpu_pte_update_params
+static int amdgpu_vm_update_ptes_cpu(struct amdgpu_pte_update_params
 					*vm_update_params,
 				     struct amdgpu_vm *vm,
 				     uint64_t start, uint64_t end,
@@ -975,8 +970,7 @@ static int amdgpu_vm_update_ptes_cpu(struct amdgpu_device *adev,
 	int r;
 	uint64_t addr;
 	struct amdgpu_bo *pt = NULL;
-	uint32_t incr = AMDGPU_VM_PTE_COUNT * 8;
-	
+
 	/* walk over the address space and update the page tables */
 	for (addr = start; addr < end; ) {
 		uint64_t pt_idx = addr >> amdgpu_vm_block_size;
@@ -995,7 +989,9 @@ static int amdgpu_vm_update_ptes_cpu(struct amdgpu_device *adev,
 
 		pe_start = (addr & mask) * 8;
 
-		write_pte_using_cpu(adev, vm_update_params, pe_start, dst, 1 , incr , flags);		
+		amdgpu_vm_frag_ptes(vm_update_params, vm,
+			pe_start, pe_start + 8 * nptes,
+			dst, flags);
 
 		addr += nptes;
 		dst += nptes * AMDGPU_GPU_PAGE_SIZE;
@@ -1048,7 +1044,7 @@ static int amdgpu_vm_bo_update_mapping(struct amdgpu_device *adev,
 	memset(&params, 0, sizeof(params));
 	params.adev = adev;
 	params.src = src;
-
+	params.pages_addr = pages_addr;
 	/* If update flag is set to CPU, then try to update PT entries directly
 	 * by CPU. If failed, fallback to SDMA update.
 	 */
@@ -1065,7 +1061,7 @@ static int amdgpu_vm_bo_update_mapping(struct amdgpu_device *adev,
 		amdgpu_sync_wait(&sync);
 		amdgpu_sync_free(&sync);
 
-		r = amdgpu_vm_update_ptes_cpu(adev, &params,
+		r = amdgpu_vm_update_ptes_cpu(&params,
 			vm, start, last + 1, addr, flags);
 		if (r) {
 			dev_info(adev->dev, "CPU pte update failed. Fallback to sdma\n");
@@ -1077,6 +1073,10 @@ static int amdgpu_vm_bo_update_mapping(struct amdgpu_device *adev,
 fallback_sdma_update:
 	ring = container_of(vm->entity.sched, struct amdgpu_ring, sched);
 
+	/* sync to everything on unmapping */
+	if (!(flags & AMDGPU_PTE_VALID))
+		owner = AMDGPU_FENCE_OWNER_UNDEFINED;
+
 	nptes = last - start + 1;
 
 	/*
@@ -1348,7 +1348,6 @@ int amdgpu_vm_bo_update(struct amdgpu_device *adev,
  *
  * @adev: amdgpu_device pointer
  * @vm: requested vm
- * @fence: return the last pt update fence
  *
  * Make sure all freed BOs are cleared in the PT.
  * Returns 0 for success.
@@ -1356,8 +1355,7 @@ int amdgpu_vm_bo_update(struct amdgpu_device *adev,
  * PTs have to be reserved and mutex must be locked!
  */
 int amdgpu_vm_clear_freed(struct amdgpu_device *adev,
-			  struct amdgpu_vm *vm,
-			  struct fence **fence)
+			  struct amdgpu_vm *vm)
 {
 	struct amdgpu_bo_va_mapping *mapping;
 	int r;
@@ -1368,13 +1366,12 @@ int amdgpu_vm_clear_freed(struct amdgpu_device *adev,
 		list_del(&mapping->list);
 
 		r = amdgpu_vm_bo_split_mapping(adev, NULL, 0, NULL, vm, mapping,
-					       0, 0, fence);
+					       0, 0, NULL);
 		kfree(mapping);
 		if (r)
 			return r;
 
 	}
-
 	return 0;
 
 }
@@ -1545,7 +1542,9 @@ int amdgpu_vm_bo_map(struct amdgpu_device *adev,
 		r = amdgpu_bo_create(adev, AMDGPU_VM_PTE_COUNT * 8,
 				     AMDGPU_GPU_PAGE_SIZE, true,
 				     AMDGPU_GEM_DOMAIN_VRAM,
-				     AMDGPU_GEM_CREATE_NO_CPU_ACCESS |
+				     vm->is_vm_update_mode_cpu ?
+					AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED :
+					AMDGPU_GEM_CREATE_NO_CPU_ACCESS |
 				     AMDGPU_GEM_CREATE_SHADOW |
 				     AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS |
 				     AMDGPU_GEM_CREATE_VRAM_CLEARED,
@@ -1733,18 +1732,18 @@ int amdgpu_vm_init(struct amdgpu_device *adev, struct amdgpu_vm *vm,
 				  rq, amdgpu_sched_jobs);
 	if (r)
 		goto err;
-	
+
 	vm->is_vm_update_mode_cpu = vm_update_mode;
 	DRM_DEBUG_DRIVER("VM update mode is %s\n",
-                        vm_update_mode ? "CPU" : "SDMA");
+			 vm_update_mode ? "CPU" : "SDMA");
 
 	vm->page_directory_fence = NULL;
 
 	r = amdgpu_bo_create(adev, pd_size, align, true,
 			     AMDGPU_GEM_DOMAIN_VRAM,
-			     (vm->is_vm_update_mode_cpu ?
-			     AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED :
-			     AMDGPU_GEM_CREATE_NO_CPU_ACCESS) |
+			     vm->is_vm_update_mode_cpu ?
+				AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED :
+				AMDGPU_GEM_CREATE_NO_CPU_ACCESS |
 			     AMDGPU_GEM_CREATE_SHADOW |
 			     AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS |
 			     AMDGPU_GEM_CREATE_VRAM_CLEARED,
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
index ba2c1d6..19e135d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.h
@@ -199,8 +199,7 @@ uint64_t amdgpu_vm_map_gart(const dma_addr_t *pages_addr, uint64_t addr);
 int amdgpu_vm_update_page_directory(struct amdgpu_device *adev,
 				    struct amdgpu_vm *vm);
 int amdgpu_vm_clear_freed(struct amdgpu_device *adev,
-			  struct amdgpu_vm *vm,
-			  struct fence **fence);
+			  struct amdgpu_vm *vm);
 int amdgpu_vm_clear_invalids(struct amdgpu_device *adev, struct amdgpu_vm *vm,
 			     struct amdgpu_sync *sync);
 int amdgpu_vm_bo_update(struct amdgpu_device *adev,
-- 
2.7.4

