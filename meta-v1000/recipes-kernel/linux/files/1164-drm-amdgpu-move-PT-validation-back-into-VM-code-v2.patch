From b47ff5f715cc6df88cae72b2f85fdbdbca66099f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <christian.koenig@amd.com>
Date: Wed, 28 Sep 2016 12:03:04 +0200
Subject: [PATCH 1164/1722] drm/amdgpu: move PT validation back into VM code v2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Saves a bunch of CPU cycles when swapping things back in and
allows us to split the VM headers into a separate file.

v2: rename parameters

Signed-off-by: Christian KÃ¶nig <christian.koenig@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h     |   5 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c  | 349 ++++++++++++++++++--------------
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c |  27 ++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c  |   7 +-
 4 files changed, 219 insertions(+), 169 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 6a31dc7..f307eb2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -930,8 +930,9 @@ struct amdgpu_bo_list_entry *amdgpu_vm_get_bos(struct amdgpu_device *adev,
 void amdgpu_vm_get_pd_bo(struct amdgpu_vm *vm,
 			 struct list_head *validated,
 			 struct amdgpu_bo_list_entry *entry);
-void amdgpu_vm_get_pt_bos(struct amdgpu_device *adev, struct amdgpu_vm *vm,
-			  struct list_head *duplicates);
+int amdgpu_vm_validate_pt_bos(struct amdgpu_device *adev, struct amdgpu_vm *vm,
+			      int (*callback)(void *p, struct amdgpu_bo *bo),
+			      void *param);
 void amdgpu_vm_move_pt_bos_in_lru(struct amdgpu_device *adev,
 				  struct amdgpu_vm *vm);
 int amdgpu_vm_grab_id(struct amdgpu_vm *vm, struct amdgpu_ring *ring,
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index cb3046f..5437ca0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
@@ -431,9 +431,9 @@ retry:
 
 /* Last resort, try to evict something from the current working set */
 static bool amdgpu_cs_try_evict(struct amdgpu_cs_parser *p,
-				struct amdgpu_bo_list_entry *lobj)
+				struct amdgpu_bo *validated)
 {
-	uint32_t domain = lobj->robj->allowed_domains;
+	uint32_t domain = validated->allowed_domains;
 	int r;
 
 	if (!p->evictable)
@@ -449,7 +449,7 @@ static bool amdgpu_cs_try_evict(struct amdgpu_cs_parser *p,
 		uint32_t other;
 
 		/* If we reached our current BO we can forget it */
-		if (candidate == lobj)
+		if (candidate->robj == validated)
 			break;
 
 		other = amdgpu_mem_type_to_domain(bo->tbo.mem.mem_type);
@@ -482,6 +482,23 @@ static bool amdgpu_cs_try_evict(struct amdgpu_cs_parser *p,
 	return false;
 }
 
+static int amdgpu_cs_validate(void *param, struct amdgpu_bo *bo)
+{
+	struct amdgpu_cs_parser *p = param;
+	int r;
+
+	do {
+		r = amdgpu_cs_bo_validate(p, bo);
+	} while (r == -ENOMEM && amdgpu_cs_try_evict(p, bo));
+	if (r)
+		return r;
+
+	if (bo->shadow)
+		r = amdgpu_cs_bo_validate(p, bo);
+
+	return r;
+}
+
 static int amdgpu_cs_list_validate(struct amdgpu_cs_parser *p,
 			    struct list_head *validated)
 {
@@ -509,17 +526,9 @@ static int amdgpu_cs_list_validate(struct amdgpu_cs_parser *p,
 		if (p->evictable == lobj)
                         p->evictable = NULL;
  
-                do {
-                        r = amdgpu_cs_bo_validate(p, bo);
-                } while (r == -ENOMEM && amdgpu_cs_try_evict(p, lobj));
+                r = amdgpu_cs_validate(p, bo);
                 if (r)
 			return r;
-               
-		 if (bo->shadow) {
-                        r = amdgpu_cs_bo_validate(p, bo);
-                        if (r)
-                                return r;
-		}
 
 		if (binding_userptr) {
 			drm_free_large(lobj->user_pages);
@@ -529,170 +538,206 @@ static int amdgpu_cs_list_validate(struct amdgpu_cs_parser *p,
 	return 0;
 }
 
-static int amdgpu_cs_parser_relocs(struct amdgpu_cs_parser *p)
+static int amdgpu_cs_parser_bos(struct amdgpu_cs_parser *p,
+                                union drm_amdgpu_cs *cs)
 {
-	struct amdgpu_fpriv *fpriv = p->filp->driver_priv;
-	struct amdgpu_cs_buckets buckets;
-	struct amdgpu_bo_list_entry *e;
-	struct list_head duplicates;
-	bool need_mmap_lock = false;
-	unsigned i, tries = 10;
-	int  r;
-	
-	if (p->bo_list) {
-		need_mmap_lock = p->bo_list->first_userptr !=
-			p->bo_list->num_entries;
-		amdgpu_cs_buckets_init(&buckets);
-		for (i = 0; i < p->bo_list->num_entries; i++)
-			amdgpu_cs_buckets_add(&buckets, &p->bo_list->array[i].tv.head,
-								 p->bo_list->array[i].priority);
-
-	       amdgpu_cs_buckets_get_list(&buckets, &p->validated);
-	}
+        struct amdgpu_fpriv *fpriv = p->filp->driver_priv;
+        struct amdgpu_bo_list_entry *e;
+        struct list_head duplicates;
+        bool need_mmap_lock = false;
+        unsigned i, tries = 10;
+        int r;
+
+        INIT_LIST_HEAD(&p->validated);
+
+        p->bo_list = amdgpu_bo_list_get(fpriv, cs->in.bo_list_handle);
+        if (p->bo_list) {
+                need_mmap_lock = p->bo_list->first_userptr !=
+                        p->bo_list->num_entries;
+                amdgpu_bo_list_get_list(p->bo_list, &p->validated);
+        }
+
+        INIT_LIST_HEAD(&duplicates);
+        amdgpu_vm_get_pd_bo(&fpriv->vm, &p->validated, &p->vm_pd);
+
+        if (p->uf_entry.robj)
+                list_add(&p->uf_entry.tv.head, &p->validated);
+
+        if (need_mmap_lock)
+                down_read(&current->mm->mmap_sem);
+
+        while (1) {
+                struct list_head need_pages;
+                unsigned i;
+
+                r = ttm_eu_reserve_buffers(&p->ticket, &p->validated, true,
+                                           &duplicates);
+                if (unlikely(r != 0)) {
+                        DRM_ERROR("ttm_eu_reserve_buffers failed.\n");
+                        goto error_free_pages;
+                }
 
-	INIT_LIST_HEAD(&duplicates);
-	amdgpu_vm_get_pd_bo(&fpriv->vm, &p->validated, &p->vm_pd);
+                /* Without a BO list we don't have userptr BOs */
+                if (!p->bo_list)
+                        break;
 
-	if (p->uf_entry.robj)
-		list_add(&p->uf_entry.tv.head, &p->validated);
+                INIT_LIST_HEAD(&need_pages);
+                for (i = p->bo_list->first_userptr;
+                     i < p->bo_list->num_entries; ++i) {
 
-	if (need_mmap_lock)
-		down_read(&current->mm->mmap_sem);
+                        e = &p->bo_list->array[i];
 
-	while (1) {
-		struct list_head need_pages;
-		unsigned i;
+                        if (amdgpu_ttm_tt_userptr_invalidated(e->robj->tbo.ttm,
+                                 &e->user_invalidated) && e->user_pages) {
 
-		r = ttm_eu_reserve_buffers(&p->ticket, &p->validated, true,
-					   &duplicates);
-		if (unlikely(r != 0))
-			goto error_free_pages;
- 
-		/* Without a BO list we don't have userptr BOs */
-		if (!p->bo_list)
-			break;
- 
-		INIT_LIST_HEAD(&need_pages);
-		for (i = p->bo_list->first_userptr;
-		     i < p->bo_list->num_entries; ++i) {
- 
-			e = &p->bo_list->array[i];
- 
-			if (amdgpu_ttm_tt_userptr_invalidated(e->robj->tbo.ttm,
-				 &e->user_invalidated) && e->user_pages) {
- 
-				/* We acquired a page array, but somebody
-				 * invalidated it. Free it an try again
-				 */
-				release_pages(e->user_pages,
-					      e->robj->tbo.ttm->num_pages,
-					      false);
-				drm_free_large(e->user_pages);
-				e->user_pages = NULL;
-			}
+                                /* We acquired a page array, but somebody
+                                 * invalidated it. Free it an try again
+                                 */
+                                release_pages(e->user_pages,
+                                              e->robj->tbo.ttm->num_pages,
+                                              false);
+                                drm_free_large(e->user_pages);
+                                e->user_pages = NULL;
+                        }
 
-			if (e->robj->tbo.ttm->state != tt_bound &&
-			    !e->user_pages) {
-				list_del(&e->tv.head);
-				list_add(&e->tv.head, &need_pages);
+                        if (e->robj->tbo.ttm->state != tt_bound &&
+                            !e->user_pages) {
+                                list_del(&e->tv.head);
+                                list_add(&e->tv.head, &need_pages);
 
-				amdgpu_bo_unreserve(e->robj);
-			}
-		}
+                                amdgpu_bo_unreserve(e->robj);
+                        }
+                }
 
-		if (list_empty(&need_pages))
-			break;
- 
-		/* Unreserve everything again. */
-		ttm_eu_backoff_reservation(&p->ticket, &p->validated);
+                if (list_empty(&need_pages))
+                        break;
 
-		/* We tried to often, just abort */
-		if (!--tries) {
-			r = -EDEADLK;
-			goto error_free_pages;
-		}
- 
-		/* Fill the page arrays for all useptrs. */
-		list_for_each_entry(e, &need_pages, tv.head) {
-			struct ttm_tt *ttm = e->robj->tbo.ttm;
- 
-			e->user_pages = drm_calloc_large(ttm->num_pages,
-							 sizeof(struct page*));
-			if (!e->user_pages) {
-				r = -ENOMEM;
-				goto error_free_pages;
-			}
- 
-			r = amdgpu_ttm_tt_get_user_pages(ttm, e->user_pages);
-			if (r) {
-				drm_free_large(e->user_pages);
-				e->user_pages = NULL;
-				goto error_free_pages;
-			}
-		}
- 
-		/* And try again. */
-		list_splice(&need_pages, &p->validated);
-	}
+                /* Unreserve everything again. */
+                ttm_eu_backoff_reservation(&p->ticket, &p->validated);
 
-	amdgpu_vm_get_pt_bos(&fpriv->vm, &duplicates);
+                /* We tried too many times, just abort */
+                if (!--tries) {
+                        r = -EDEADLK;
+                        DRM_ERROR("deadlock in %s\n", __func__);
+                        goto error_free_pages;
+                }
 
-	p->bytes_moved_threshold = amdgpu_cs_get_threshold_for_moves(p->adev);
-	p->bytes_moved = 0;
- 
-	r = amdgpu_cs_list_validate(p, &duplicates);
-	if (r)
-		goto error_validate;
+                /* Fill the page arrays for all useptrs. */
+                list_for_each_entry(e, &need_pages, tv.head) {
+                        struct ttm_tt *ttm = e->robj->tbo.ttm;
 
-	r = amdgpu_cs_list_validate(p, &p->validated);
-	if (r)
-		goto error_validate;
+                        e->user_pages = drm_calloc_large(ttm->num_pages,
+                                                         sizeof(struct page*));
+                        if (!e->user_pages) {
+                                r = -ENOMEM;
+                                DRM_ERROR("calloc failure in %s\n", __func__);
+                                goto error_free_pages;
+                        }
 
-	if (p->bo_list) {
-		struct amdgpu_vm *vm = &fpriv->vm;
-		unsigned i;
- 
-		for (i = 0; i < p->bo_list->num_entries; i++) {
-			struct amdgpu_bo *bo = p->bo_list->array[i].robj;
+                        r = amdgpu_ttm_tt_get_user_pages(ttm, e->user_pages);
+                        if (r) {
+                                DRM_ERROR("amdgpu_ttm_tt_get_user_pages failed.\n");
+                                drm_free_large(e->user_pages);
+                                e->user_pages = NULL;
+                                goto error_free_pages;
+                        }
+                }
+
+                /* And try again. */
+                list_splice(&need_pages, &p->validated);
+        }
+
+        p->bytes_moved_threshold = amdgpu_cs_get_threshold_for_moves(p->adev);
+        p->bytes_moved = 0;
+        p->evictable = list_last_entry(&p->validated,
+                                       struct amdgpu_bo_list_entry,
+                                       tv.head);
+        r = amdgpu_vm_validate_pt_bos(p->adev, &fpriv->vm,
+                                      amdgpu_cs_validate, p);
  
-			p->bo_list->array[i].bo_va = amdgpu_vm_bo_find(vm, bo);
-		}
-	}
+        if (r) {
+                DRM_ERROR("amdgpu_vm_validate_pt_bos() failed.\n");
+                goto error_validate;
+        }
+
+        r = amdgpu_cs_list_validate(p, &duplicates);
+        if (r) {
+                DRM_ERROR("amdgpu_cs_list_validate(duplicates) failed.\n");
+                goto error_validate;
+        }
+
+        r = amdgpu_cs_list_validate(p, &p->validated);
+        if (r) {
+                DRM_ERROR("amdgpu_cs_list_validate(validated) failed.\n");
+                goto error_validate;
+        }
+
+        amdgpu_cs_report_moved_bytes(p->adev, p->bytes_moved);
+
+        fpriv->vm.last_eviction_counter =
+                atomic64_read(&p->adev->num_evictions);
+
+        if (p->bo_list) {
+                struct amdgpu_bo *gds = p->bo_list->gds_obj;
+                struct amdgpu_bo *gws = p->bo_list->gws_obj;
+                struct amdgpu_bo *oa = p->bo_list->oa_obj;
+                struct amdgpu_vm *vm = &fpriv->vm;
+                unsigned i;
+
+                for (i = 0; i < p->bo_list->num_entries; i++) {
+                        struct amdgpu_bo *bo = p->bo_list->array[i].robj;
+
+                        p->bo_list->array[i].bo_va = amdgpu_vm_bo_find(vm, bo);
+                }
 
-	if (!r && p->uf_entry.robj) {
-		struct amdgpu_bo *uf = p->uf_entry.robj;
+                if (gds) {
+                        p->job->gds_base = amdgpu_bo_gpu_offset(gds);
+                        p->job->gds_size = amdgpu_bo_size(gds);
+                }
+                if (gws) {
+                        p->job->gws_base = amdgpu_bo_gpu_offset(gws);
+                        p->job->gws_size = amdgpu_bo_size(gws);
+                }
+                if (oa) {
+                        p->job->oa_base = amdgpu_bo_gpu_offset(oa);
+                        p->job->oa_size = amdgpu_bo_size(oa);
+                }
+        }
 
-		r = amdgpu_ttm_bind(&uf->tbo, &uf->tbo.mem);
-		p->job->uf_addr += amdgpu_bo_gpu_offset(uf);
-	}
+        if (!r && p->uf_entry.robj) {
+                struct amdgpu_bo *uf = p->uf_entry.robj;
+
+                r = amdgpu_ttm_bind(&uf->tbo, &uf->tbo.mem);
+                p->job->uf_addr += amdgpu_bo_gpu_offset(uf);
+        }
 
 error_validate:
-	if (r) {
-		amdgpu_vm_move_pt_bos_in_lru(p->adev, &fpriv->vm);
-		ttm_eu_backoff_reservation(&p->ticket, &p->validated);
-	}		
+        if (r) {
+                amdgpu_vm_move_pt_bos_in_lru(p->adev, &fpriv->vm);
+                ttm_eu_backoff_reservation(&p->ticket, &p->validated);
+        }
 
 error_free_pages:
 
-	if (need_mmap_lock)
-		up_read(&current->mm->mmap_sem);
+        if (need_mmap_lock)
+                up_read(&current->mm->mmap_sem);
 
-	if (p->bo_list) {
-		for (i = p->bo_list->first_userptr;
-		     i < p->bo_list->num_entries; ++i) {
-			e = &p->bo_list->array[i];
- 
-			if (!e->user_pages)
-				continue;
- 
-			release_pages(e->user_pages,
-				      e->robj->tbo.ttm->num_pages,
-				      false);
-			drm_free_large(e->user_pages);
-		}
-	}
+        if (p->bo_list) {
+                for (i = p->bo_list->first_userptr;
+                     i < p->bo_list->num_entries; ++i) {
+                        e = &p->bo_list->array[i];
 
-	return r;
+                        if (!e->user_pages)
+                                continue;
+
+                        release_pages(e->user_pages,
+                                      e->robj->tbo.ttm->num_pages,
+                                      false);
+                        drm_free_large(e->user_pages);
+                }
+        }
+
+        return r;
 }
 
 static int amdgpu_cs_sync_rings(struct amdgpu_cs_parser *p)
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 7c8cfdf..b058fc1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
@@ -472,6 +472,16 @@ out:
 	return r;
 }
 
+static int amdgpu_gem_va_check(void *param, struct amdgpu_bo *bo)
+{
+	unsigned domain = amdgpu_mem_type_to_domain(bo->tbo.mem.mem_type);
+
+	/* if anything is swapped out don't swap it in here,
+	   just abort and wait for the next CS */
+
+	return domain == AMDGPU_GEM_DOMAIN_CPU ? -ERESTARTSYS : 0;
+}
+
 /**
  * amdgpu_gem_va_update_vm -update the bo_va in its VM
  *
@@ -482,7 +492,8 @@ out:
  * vital here, so they are not reported back to userspace.
  */
 static void amdgpu_gem_va_update_vm(struct amdgpu_device *adev,
-				    struct amdgpu_bo_va *bo_va, uint32_t operation)
+				    struct amdgpu_bo_va *bo_va,
+				    uint32_t operation)
 {
 	struct ttm_validate_buffer tv, *entry;
 	struct amdgpu_bo_list_entry vm_pd;
@@ -505,7 +516,6 @@ static void amdgpu_gem_va_update_vm(struct amdgpu_device *adev,
 	if (r)
 		goto error_print;
  
-        amdgpu_vm_get_pt_bos(adev, bo_va->vm, &duplicates);
 	list_for_each_entry(entry, &list, head) {
 		domain = amdgpu_mem_type_to_domain(entry->bo->mem.mem_type);
 		/* if anything is swapped out don't swap it in here,
@@ -513,13 +523,10 @@ static void amdgpu_gem_va_update_vm(struct amdgpu_device *adev,
 		if (domain == AMDGPU_GEM_DOMAIN_CPU)
 			goto error_unreserve;
 	}
-	list_for_each_entry(entry, &duplicates, head) {
-		domain = amdgpu_mem_type_to_domain(entry->bo->mem.mem_type);
-		/* if anything is swapped out don't swap it in here,
-		   just abort and wait for the next CS */
-		if (domain == AMDGPU_GEM_DOMAIN_CPU)
-			goto error_unreserve;
-	}
+	r = amdgpu_vm_validate_pt_bos(adev, bo_va->vm, amdgpu_gem_va_check,
+				      NULL);
+	if (r)
+		goto error_unreserve;
 
 	r = amdgpu_vm_update_page_directory(adev, bo_va->vm);
 	if (r)
@@ -540,8 +547,6 @@ error_print:
 		DRM_ERROR("Couldn't update BO_VA (%d)\n", r);
 }
 
-
-
 int amdgpu_gem_va_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *filp)
 {
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 4b45c2c..1b02386 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -120,24 +120,23 @@ void amdgpu_vm_get_pd_bo(struct amdgpu_vm *vm,
  * @adev: amdgpu device pointer
  * @vm: vm providing the BOs
  * @duplicates: head of duplicates list
-
+ *
  * Add the page directory to the BO duplicates list
  * for command submission.
-
  */
 void amdgpu_vm_get_pt_bos(struct amdgpu_device *adev, struct amdgpu_vm *vm,
                           struct list_head *duplicates)
-
 {
         uint64_t num_evictions;
 	unsigned i;
+	int r;
  
         /* We only need to validate the page tables
          * if they aren't already valid.
          */
         num_evictions = atomic64_read(&adev->num_evictions);
         if (num_evictions == vm->last_eviction_counter)
-                return;
+                return 0;
  
 	/* add the vm page table to the list */
 	for (i = 0; i <= vm->max_pde_used; ++i) {
-- 
2.7.4

