From 7d59f70e4042dc3ffb9a88c1028c205318670742 Mon Sep 17 00:00:00 2001
From: Eric Huang <JinHuiEric.Huang@amd.com>
Date: Fri, 22 Jan 2016 14:32:41 -0500
Subject: [PATCH 0021/1722] drm/amd/powerplay: add some hwmgr functions for
 sysfs interface on Tonga

Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c | 236 ++++++++++------------
 1 file changed, 106 insertions(+), 130 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c b/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c
index d79af48..b4d65aa 100644
--- a/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/tonga_hwmgr.c
@@ -6052,147 +6052,123 @@ static int tonga_get_fan_control_mode(struct pp_hwmgr *hwmgr)
 				CG_FDO_CTRL2, FDO_PWM_MODE);
 }
 
-static int tonga_get_pp_table(struct pp_hwmgr *hwmgr, char **table)
++static int tonga_get_pp_table(struct pp_hwmgr *hwmgr, char **table)
 {
-	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
-
-	if (!data->soft_pp_table) {
-		data->soft_pp_table = kzalloc(hwmgr->soft_pp_table_size, GFP_KERNEL);
-		if (!data->soft_pp_table)
-			return -ENOMEM;
-		memcpy(data->soft_pp_table, hwmgr->soft_pp_table,
-				hwmgr->soft_pp_table_size);
-	}
-
-	*table = (char *)&data->soft_pp_table;
-
-	return hwmgr->soft_pp_table_size;
+        struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+ 
+        *table = (char *)&data->smc_state_table;
+ 
+        return sizeof(struct SMU72_Discrete_DpmTable);
 }
 
 static int tonga_set_pp_table(struct pp_hwmgr *hwmgr, const char *buf, size_t size)
 {
-	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
-
-	if (!data->soft_pp_table) {
-		data->soft_pp_table = kzalloc(hwmgr->soft_pp_table_size, GFP_KERNEL);
-		if (!data->soft_pp_table)
-			return -ENOMEM;
-	}
-
-	memcpy(data->soft_pp_table, buf, size);
-
-	hwmgr->soft_pp_table = data->soft_pp_table;
-
-	/* TODO: re-init powerplay to implement modified pptable */
-
-	return 0;
+        struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+ 
+        void *table = (void *)&data->smc_state_table;
+ 
+        memcpy(table, buf, size);
+ 
+        return 0;
 }
 
 static int tonga_force_clock_level(struct pp_hwmgr *hwmgr,
-		enum pp_clock_type type, uint32_t mask)
-{
-	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
-
-	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
-		return -EINVAL;
-
-	switch (type) {
-	case PP_SCLK:
-		if (!data->sclk_dpm_key_disabled)
-			smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
-					PPSMC_MSG_SCLKDPM_SetEnabledMask,
-					data->dpm_level_enable_mask.sclk_dpm_enable_mask & mask);
-		break;
-	case PP_MCLK:
-		if (!data->mclk_dpm_key_disabled)
-			smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
-					PPSMC_MSG_MCLKDPM_SetEnabledMask,
-					data->dpm_level_enable_mask.mclk_dpm_enable_mask & mask);
-		break;
-	case PP_PCIE:
-	{
-		uint32_t tmp = mask & data->dpm_level_enable_mask.pcie_dpm_enable_mask;
-		uint32_t level = 0;
-
-		while (tmp >>= 1)
-			level++;
-
-		if (!data->pcie_dpm_key_disabled)
-			smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
-					PPSMC_MSG_PCIeDPM_ForceLevel,
-					level);
-		break;
-	}
-	default:
-		break;
-	}
-
-	return 0;
+                enum pp_clock_type type, int level)
+{
+        struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+ 
+        if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
+                return -EINVAL;
+ 
+        switch (type) {
+        case PP_SCLK:
+                if (!data->sclk_dpm_key_disabled)
+                        smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
+                                        PPSMC_MSG_SCLKDPM_SetEnabledMask,
+                                        (1 << level));
+                break;
+        case PP_MCLK:
+                if (!data->mclk_dpm_key_disabled)
+                        smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
+                                        PPSMC_MSG_MCLKDPM_SetEnabledMask,
+                                        (1 << level));
+                break;
+        case PP_PCIE:
+                if (!data->pcie_dpm_key_disabled)
+                        smum_send_msg_to_smc_with_parameter(hwmgr->smumgr,
+                                        PPSMC_MSG_PCIeDPM_ForceLevel,
+                                        (1 << level));
+                break;
+        default:
+                break;
+        }
+ 
+        return 0;
 }
 
 static int tonga_print_clock_levels(struct pp_hwmgr *hwmgr,
-		enum pp_clock_type type, char *buf)
-{
-	struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
-	struct tonga_single_dpm_table *sclk_table = &(data->dpm_table.sclk_table);
-	struct tonga_single_dpm_table *mclk_table = &(data->dpm_table.mclk_table);
-	struct tonga_single_dpm_table *pcie_table = &(data->dpm_table.pcie_speed_table);
-	int i, now, size = 0;
-	uint32_t clock, pcie_speed;
-
-	switch (type) {
-	case PP_SCLK:
-		smum_send_msg_to_smc(hwmgr->smumgr, PPSMC_MSG_API_GetSclkFrequency);
-		clock = cgs_read_register(hwmgr->device, mmSMC_MSG_ARG_0);
-
-		for (i = 0; i < sclk_table->count; i++) {
-			if (clock > sclk_table->dpm_levels[i].value)
-				continue;
-			break;
-		}
-		now = i;
-
-		for (i = 0; i < sclk_table->count; i++)
-			size += sprintf(buf + size, "%d: %uMhz %s\n",
-					i, sclk_table->dpm_levels[i].value / 100,
-					(i == now) ? "*" : "");
-		break;
-	case PP_MCLK:
-		smum_send_msg_to_smc(hwmgr->smumgr, PPSMC_MSG_API_GetMclkFrequency);
-		clock = cgs_read_register(hwmgr->device, mmSMC_MSG_ARG_0);
-
-		for (i = 0; i < mclk_table->count; i++) {
-			if (clock > mclk_table->dpm_levels[i].value)
-				continue;
-			break;
-		}
-		now = i;
-
-		for (i = 0; i < mclk_table->count; i++)
-			size += sprintf(buf + size, "%d: %uMhz %s\n",
-					i, mclk_table->dpm_levels[i].value / 100,
-					(i == now) ? "*" : "");
-		break;
-	case PP_PCIE:
-		pcie_speed = tonga_get_current_pcie_speed(hwmgr);
-		for (i = 0; i < pcie_table->count; i++) {
-			if (pcie_speed != pcie_table->dpm_levels[i].value)
-				continue;
-			break;
-		}
-		now = i;
-
-		for (i = 0; i < pcie_table->count; i++)
-			size += sprintf(buf + size, "%d: %s %s\n", i,
-					(pcie_table->dpm_levels[i].value == 0) ? "2.5GB, x8" :
-					(pcie_table->dpm_levels[i].value == 1) ? "5.0GB, x16" :
-					(pcie_table->dpm_levels[i].value == 2) ? "8.0GB, x16" : "",
-					(i == now) ? "*" : "");
-		break;
-	default:
-		break;
-	}
-	return size;
+                enum pp_clock_type type, char *buf)
+{
+        struct tonga_hwmgr *data = (struct tonga_hwmgr *)(hwmgr->backend);
+        struct tonga_single_dpm_table *sclk_table = &(data->dpm_table.sclk_table);
+        struct tonga_single_dpm_table *mclk_table = &(data->dpm_table.mclk_table);
+        struct tonga_single_dpm_table *pcie_table = &(data->dpm_table.pcie_speed_table);
+        int i, now, size = 0;
+        uint32_t clock, pcie_speed;
+ 
+        switch (type) {
+        case PP_SCLK:
+                smum_send_msg_to_smc(hwmgr->smumgr, PPSMC_MSG_API_GetSclkFrequency);
+                clock = cgs_read_register(hwmgr->device, mmSMC_MSG_ARG_0);
+ 
+                for (i = 0; i < sclk_table->count; i++) {
+                        if (clock > sclk_table->dpm_levels[i].value)
+                                continue;
+                        break;
+                }
+                now = i;
+ 
+                for (i = 0; i < sclk_table->count; i++)
+                        size += sprintf(buf + size, "%d: %uMhz %s\n",
+                                        i, sclk_table->dpm_levels[i].value / 100,
+                                        (i == now) ? "*" : "");
+                break;
+        case PP_MCLK:
+                smum_send_msg_to_smc(hwmgr->smumgr, PPSMC_MSG_API_GetMclkFrequency);
+                clock = cgs_read_register(hwmgr->device, mmSMC_MSG_ARG_0);
+ 
+                for (i = 0; i < mclk_table->count; i++) {
+                        if (clock > mclk_table->dpm_levels[i].value)
+                                continue;
+                        break;
+                }
+                now = i;
+ 
+                for (i = 0; i < mclk_table->count; i++)
+                        size += sprintf(buf + size, "%d: %uMhz %s\n",
+                                        i, mclk_table->dpm_levels[i].value / 100,
+                                        (i == now) ? "*" : "");
+                break;
+        case PP_PCIE:
+                pcie_speed = tonga_get_current_pcie_speed(hwmgr);
+                for (i = 0; i < pcie_table->count; i++) {
+                        if (pcie_speed != pcie_table->dpm_levels[i].value)
+                                continue;
+                        break;
+                }
+                now = i;
+ 
+                for (i = 0; i < pcie_table->count; i++)
+                        size += sprintf(buf + size, "%d: %s %s\n", i,
+                                        (pcie_table->dpm_levels[i].value == 0) ? "2.5GB, x8" :
+                                        (pcie_table->dpm_levels[i].value == 1) ? "5.0GB, x16" :
+                                        (pcie_table->dpm_levels[i].value == 2) ? "8.0GB, x16" : "",
+                                        (i == now) ? "*" : "");
+                break;
+        default:
+                break;
+        }
+        return size;
 }
 
 static const struct pp_hwmgr_func tonga_hwmgr_funcs = {
-- 
2.7.4

