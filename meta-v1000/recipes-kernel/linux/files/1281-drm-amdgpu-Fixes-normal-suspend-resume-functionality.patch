From cc31107e10ea98cf7de4534e1df42d28fe6417e1 Mon Sep 17 00:00:00 2001
From: Kalyan Alle <kalyan.alle@amd.com>
Date: Mon, 21 Nov 2016 15:47:48 +0530
Subject: [PATCH 1281/1722] drm/amdgpu: Fixes normal suspend resume
 functionality.

Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c | 144 +++++++++++++++++++-------------
 1 file changed, 86 insertions(+), 58 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
index ae585e6..f4e1216 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
@@ -275,58 +275,91 @@ static int amdgpu_mm_node_addr(struct ttm_buffer_object *bo,
 }
 
 static int amdgpu_move_blit(struct ttm_buffer_object *bo,
-			    bool evict, bool no_wait_gpu,
-			    struct ttm_mem_reg *new_mem,
-			    struct ttm_mem_reg *old_mem)
+                             bool evict, bool no_wait_gpu,
+                             struct ttm_mem_reg *new_mem,
+                             struct ttm_mem_reg *old_mem)
 {
-	struct amdgpu_device *adev;
-	struct amdgpu_ring *ring;
-	uint64_t old_start, new_start;
-	struct fence *fence;
-	int r;
-
-	adev = amdgpu_ttm_adev(bo->bdev);
-	ring = adev->mman.buffer_funcs_ring;
-	old_start = old_mem->start << PAGE_SHIFT;
-	new_start = new_mem->start << PAGE_SHIFT;
-
-	switch (old_mem->mem_type) {
-	case TTM_PL_VRAM:
-		old_start += adev->mc.vram_start;
-		break;
-	case TTM_PL_TT:
-		old_start += adev->mc.gtt_start;
-		break;
-	default:
-		DRM_ERROR("Unknown placement %d\n", old_mem->mem_type);
-		return -EINVAL;
-	}
-	switch (new_mem->mem_type) {
-	case TTM_PL_VRAM:
-		new_start += adev->mc.vram_start;
-		break;
-	case TTM_PL_TT:
-		new_start += adev->mc.gtt_start;
-		break;
-	default:
-		DRM_ERROR("Unknown placement %d\n", old_mem->mem_type);
-		return -EINVAL;
-	}
-	if (!ring->ready) {
-		DRM_ERROR("Trying to move memory with ring turned off.\n");
-		return -EINVAL;
-	}
-
-	BUILD_BUG_ON((PAGE_SIZE % AMDGPU_GPU_PAGE_SIZE) != 0);
-
-	r = amdgpu_copy_buffer(ring, old_start, new_start,
-			       new_mem->num_pages * PAGE_SIZE, /* bytes */
-			       bo->resv, &fence, false);
-	/* FIXME: handle copy error */
-	r = ttm_bo_move_accel_cleanup(bo, fence,
-				      evict, no_wait_gpu, new_mem);
-	fence_put(fence);
-	return r;
+         struct amdgpu_device *adev = amdgpu_ttm_adev(bo->bdev);
+         struct amdgpu_ring *ring = adev->mman.buffer_funcs_ring;
+ 
+         struct drm_mm_node *old_mm, *new_mm;
+         uint64_t old_start, old_size, new_start, new_size;
+         unsigned long num_pages;
+         struct fence *fence = NULL;
+         int r;
+ 
+         BUILD_BUG_ON((PAGE_SIZE % AMDGPU_GPU_PAGE_SIZE) != 0);
+ 
+         if (!ring->ready) {
+                 DRM_ERROR("Trying to move memory with ring turned off.\n");
+                 return -EINVAL;
+         }
+ 
+         old_mm = old_mem->mm_node;
+         r = amdgpu_mm_node_addr(bo, old_mm, old_mem, &old_start);
+         if (r)
+                 return r;
+         old_size = old_mm->size;
+ 
+ 
+         new_mm = new_mem->mm_node;
+         r = amdgpu_mm_node_addr(bo, new_mm, new_mem, &new_start);
+         if (r)
+                 return r;
+         new_size = new_mm->size;
+ 
+         num_pages = new_mem->num_pages;
+         while (num_pages) {
+                 unsigned long cur_pages = min(old_size, new_size);
+                 struct fence *next;
+ 
+                 r = amdgpu_copy_buffer(ring, old_start, new_start,
+                                        cur_pages * PAGE_SIZE,
+                                        bo->resv, &next, false);
+                 if (r)
+                         goto error;
+ 
+                 fence_put(fence);
+                 fence = next;
+ 
+                 num_pages -= cur_pages;
+                 if (!num_pages)
+                         break;
+ 
+                 old_size -= cur_pages;
+                 if (!old_size) {
+                         r = amdgpu_mm_node_addr(bo, ++old_mm, old_mem,
+                                                 &old_start);
+                         if (r)
+                                 goto error;
+                         old_size = old_mm->size;
+                 } else {
+                         old_start += cur_pages * PAGE_SIZE;
+                 }
+ 
+                 new_size -= cur_pages;
+                 if (!new_size) {
+                         r = amdgpu_mm_node_addr(bo, ++new_mm, new_mem,
+                                                 &new_start);
+                         if (r)
+                                 goto error;
+ 
+                         new_size = new_mm->size;
+                 } else {
+                         new_start += cur_pages * PAGE_SIZE;
+                 }
+         }
+ 
+         r = ttm_bo_move_accel_cleanup(bo, fence,
+                                      evict, no_wait_gpu, new_mem);
+         fence_put(fence);
+         return r;
+
+error:
+         if (fence)
+                 fence_wait(fence, false);
+         fence_put(fence);
+         return r;
 }
 
 static int amdgpu_move_vram_ram(struct ttm_buffer_object *bo,
@@ -349,7 +382,7 @@ static int amdgpu_move_vram_ram(struct ttm_buffer_object *bo,
 	placement.num_busy_placement = 1;
 	placement.busy_placement = &placements;
 	placements.fpfn = 0;
-	placements.lpfn = 0;
+	placements.lpfn = adev->mc.gtt_size >> PAGE_SHIFT;
 	placements.flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT;
 	r = ttm_bo_mem_space(bo, &placement, &tmp_mem,
 			     interruptible, no_wait_gpu);
@@ -396,7 +429,7 @@ static int amdgpu_move_ram_vram(struct ttm_buffer_object *bo,
 	placement.num_busy_placement = 1;
 	placement.busy_placement = &placements;
 	placements.fpfn = 0;
-	placements.lpfn = 0;
+	placements.lpfn = adev->mc.gtt_size >> PAGE_SHIFT;
 	placements.flags = TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT;
 	r = ttm_bo_mem_space(bo, &placement, &tmp_mem,
 			     interruptible, no_wait_gpu);
@@ -1091,11 +1124,6 @@ int amdgpu_ttm_init(struct amdgpu_device *adev)
 	unsigned i, j;
 	int r;
 	
-	r = amdgpu_ttm_global_init(adev);
-	if (r) {
-		return r;
-	}
-	
 	/* No others user of address space so set it to 0 */
 	r = ttm_bo_device_init(&adev->mman.bdev,
 			       adev->mman.bo_global_ref.ref.object,
-- 
2.7.4

