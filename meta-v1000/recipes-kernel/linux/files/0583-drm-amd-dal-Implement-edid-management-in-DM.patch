From a9cf5595c0bfc911729ee619f0d7e8feb2ae1b7e Mon Sep 17 00:00:00 2001
From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Tue, 7 Jun 2016 12:09:13 -0400
Subject: [PATCH 0583/1722] drm/amd/dal: Implement edid management in DM.

Change-Id: I47754988892be3ab948710a0710dcb089ba7866f
Signed-off-by: Yongqiang Sun <Yongqiang.Sun@amd.com>
Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c      | 31 +++++++++-
 .../gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c    | 68 +++++++++++++++++++++-
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  6 ++
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  7 ++-
 4 files changed, 103 insertions(+), 9 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
index 1b3a35b..3d2d0a3 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm.c
@@ -744,8 +744,31 @@ void amdgpu_dm_update_connector_after_detect(
 	if (aconnector->mst_mgr.mst_state == true)
 		return;
 
+
 	sink = aconnector->dc_link->local_sink;
 
+	/* Edid mgmt connector gets first update only in mode_valid hook and then
+	 * the connector sink is set to either fake or physical sink depends on link status.
+	 * don't do it here if u are during boot
+	 */
+	if (aconnector->base.force != DRM_FORCE_UNSPECIFIED
+			&& aconnector->dc_em_sink) {
+
+		/* For S3 resume with headless use eml_sink to fake target
+		 * because on resume connecotr->sink is set ti NULL
+		 */
+		if (sink) {
+			aconnector->dc_sink = sink;
+			amdgpu_dm_add_sink_to_freesync_module(
+								connector, aconnector->edid);
+		} else {
+			amdgpu_dm_remove_sink_from_freesync_module(connector);
+			if (!aconnector->dc_sink)
+				aconnector->dc_sink = aconnector->dc_em_sink;
+		}
+		return;
+	}
+
 	/*
 	 * TODO: temporary guard to look for proper fix
 	 * if this sink is MST sink, we should not do anything
@@ -807,11 +830,13 @@ static void handle_hpd_irq(void *param)
 	if (dc_link_detect(aconnector->dc_link, false)) {
 		amdgpu_dm_update_connector_after_detect(aconnector);
 
+
 		drm_modeset_lock_all(dev);
 		dm_restore_drm_connector_state(dev, connector);
 		drm_modeset_unlock_all(dev);
 
-		drm_kms_helper_hotplug_event(dev);
+		if (aconnector->base.force == DRM_FORCE_UNSPECIFIED)
+			drm_kms_helper_hotplug_event(dev);
 	}
 
 }
@@ -829,6 +854,7 @@ static void handle_hpd_rx_irq(void *param)
 		if (dc_link_detect(aconnector->dc_link, false)) {
 			amdgpu_dm_update_connector_after_detect(aconnector);
 
+
 			drm_modeset_lock_all(dev);
 			dm_restore_drm_connector_state(dev, connector);
 			drm_modeset_unlock_all(dev);
@@ -1105,8 +1131,7 @@ int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)
 		}
 
 		if (dc_link_detect(dc_get_link_at_index(dm->dc, i), true))
-			amdgpu_dm_update_connector_after_detect(
-				aconnector);
+			amdgpu_dm_update_connector_after_detect(aconnector);
 	}
 
 	/* Software is initialized. Now we can register interrupt handlers. */
diff --git a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
index f359fa3..21c02bd 100644
--- a/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/dal/amdgpu_dm/amdgpu_dm_types.c
@@ -1062,7 +1062,10 @@ amdgpu_dm_connector_detect(struct drm_connector *connector, bool force)
 	 * 2. This interface *is called* in context of user-mode ioctl. Which
 	 * makes it a bad place for *any* MST-related activit. */
 
-	connected = (NULL != aconnector->dc_sink);
+	if (aconnector->base.force == DRM_FORCE_UNSPECIFIED)
+		connected = (aconnector->dc_sink != NULL);
+	else
+		connected = (aconnector->base.force == DRM_FORCE_ON);
 
 	return (connected ? connector_status_connected :
 			connector_status_disconnected);
@@ -1263,23 +1266,82 @@ static int get_modes(struct drm_connector *connector)
 	return amdgpu_dm_connector_get_modes(connector);
 }
 
+static void create_eml_sink(struct amdgpu_connector *aconnector)
+{
+	struct dc_sink_init_data init_params = {
+			.link = aconnector->dc_link,
+			.sink_signal = SIGNAL_TYPE_VIRTUAL
+	};
+	struct edid *edid = (struct edid *) aconnector->base.edid_blob_ptr->data;
+
+	if (!aconnector->base.edid_blob_ptr ||
+		!aconnector->base.edid_blob_ptr->data) {
+		DRM_ERROR("No EDID firmware found on connector: %s ,forcing to OFF!\n",
+				aconnector->base.name);
+
+		aconnector->base.force = DRM_FORCE_OFF;
+		aconnector->base.override_edid = false;
+		return;
+	}
+
+	aconnector->edid = edid;
+
+	aconnector->dc_em_sink = dc_link_add_remote_sink(
+		aconnector->dc_link,
+		(uint8_t *)edid,
+		(edid->extensions + 1) * EDID_LENGTH,
+		&init_params);
+
+	if (aconnector->base.force
+					== DRM_FORCE_ON)
+		aconnector->dc_sink = aconnector->dc_link->local_sink ?
+		aconnector->dc_link->local_sink :
+		aconnector->dc_em_sink;
+}
+
+static void handle_edid_mgmt(struct amdgpu_connector *aconnector)
+{
+	struct dc_link *link = (struct dc_link *)aconnector->dc_link;
+
+	/* In case of headless boot with force on for DP managed connector
+	 * Those settings have to be != 0 to get initial modeset
+	 */
+	if (link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT) {
+		link->verified_link_cap.lane_count = LANE_COUNT_FOUR;
+		link->verified_link_cap.link_rate = LINK_RATE_HIGH2;
+	}
+
+
+	aconnector->base.override_edid = true;
+	create_eml_sink(aconnector);
+}
+
 int amdgpu_dm_connector_mode_valid(
 		struct drm_connector *connector,
 		struct drm_display_mode *mode)
 {
 	int result = MODE_ERROR;
-	const struct dc_sink *dc_sink =
-			to_amdgpu_connector(connector)->dc_sink;
+	const struct dc_sink *dc_sink;
 	struct amdgpu_device *adev = connector->dev->dev_private;
 	struct dc_validation_set val_set = { 0 };
 	/* TODO: Unhardcode stream count */
 	struct dc_stream *streams[1];
 	struct dc_target *target;
+	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
 
 	if ((mode->flags & DRM_MODE_FLAG_INTERLACE) ||
 			(mode->flags & DRM_MODE_FLAG_DBLSCAN))
 		return result;
 
+	/* Only run this the first time mode_valid is called to initilialize
+	 * EDID mgmt
+	 */
+	if (aconnector->base.force != DRM_FORCE_UNSPECIFIED &&
+		!aconnector->dc_em_sink)
+		handle_edid_mgmt(aconnector);
+
+	dc_sink = to_amdgpu_connector(connector)->dc_sink;
+
 	if (NULL == dc_sink) {
 		DRM_ERROR("dc_sink is NULL!\n");
 		goto stream_create_fail;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 432fe7d..32b3d23 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -1341,6 +1341,12 @@ enum dc_status dc_link_validate_mode_timing(
 {
 	uint32_t max_pix_clk = stream->sink->dongle_max_pix_clk;
 
+	/* A hack to avoid failing any modes for EDID override feature on
+	 * topology change such as lower quality cable for DP or different dongle
+	 */
+	if (link->public.remote_sinks[0])
+		return DC_OK;
+
 	if (0 != max_pix_clk && timing->pix_clk_khz > max_pix_clk)
 		return DC_EXCEED_DONGLE_MAX_CLK;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index b63d594..d24cfdc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -770,9 +770,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			&stream->bit_depth_params,
 			&stream->clamping);
 
-	stream->sink->link->link_enc->funcs->setup(
-		stream->sink->link->link_enc,
-		pipe_ctx->stream->signal);
+	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
+		stream->sink->link->link_enc->funcs->setup(
+			stream->sink->link->link_enc,
+			pipe_ctx->stream->signal);
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->dp_set_stream_attribute(
-- 
2.7.4

