From addae1f0a0bc62461eb5efa32f164febe7dfd5dd Mon Sep 17 00:00:00 2001
From: David Rokhvarg <David.Rokhvarg@amd.com>
Date: Mon, 13 Jul 2015 15:25:48 -0400
Subject: [PATCH 360/401] drm/amd/amdgpu: [DM] Protect DAL from re-entry from
 Mode Set/Reset and HPD.

Signed-off-by: David Rokhvarg <David.Rokhvarg@amd.com>
Reviewed-by: Mykola Lysenko <mykola.lysenko@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c       | 31 +++++++++++++++++++++-------
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h       |  6 ++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c | 16 +++++++++++---
 3 files changed, 42 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
index 20722d0..830ab6f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
@@ -384,6 +384,15 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 	uint32_t connected_displays = dal_get_connected_targets_vector(dal);
 	struct drm_connector *connector = NULL;
 	struct amdgpu_connector *aconnector = NULL;
+	bool trigger_drm_hpd_event = false;
+
+	/* This function runs after dal_notify_hotplug().
+	 * That means the user-mode may already called DAL with a Set/Reset
+	 * mode, that means this function must acquire the dal_mutex
+	 * *before* calling into DAL.
+	 * The vice-versa sequence may also happen - this function is
+	 * calling into DAL and preempted by a call from user-mode. */
+	mutex_lock(&adev->dm.dal_mutex);
 
 	if (connected_displays == 0) {
 		uint32_t display_index = INVALID_DISPLAY_INDEX;
@@ -412,10 +421,9 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 		 */
 		aconnector->base.status = connector_status_connected;
 
-		/*
-		 * we need to force user-space notification on changed modes
-		 */
-		drm_kms_helper_hotplug_event(dev);
+		/* we need to force user-space notification on changed modes */
+		trigger_drm_hpd_event = true;
+
 	} else if (adev->dm.fake_display_index != INVALID_DISPLAY_INDEX) {
 		/* we assume only one display is connected */
 		uint32_t connected_display_index = 0;
@@ -446,9 +454,7 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 					break;
 			}
 
-			/*
-			 * reset connected status on fake display connector
-			 */
+			/* reset connected status on fake display connector */
 			aconnector->base.status = connector_status_disconnected;
 		} else {
 			dal_reset_path_mode(
@@ -459,8 +465,13 @@ static void amdgpu_dm_hpd_low_irq(void *interrupt_params)
 
 		adev->dm.fake_display_index = INVALID_DISPLAY_INDEX;
 
-		drm_kms_helper_hotplug_event(dev);
+		trigger_drm_hpd_event = true;
 	}
+
+	mutex_unlock(&adev->dm.dal_mutex);
+
+	if (true == trigger_drm_hpd_event)
+		drm_kms_helper_hotplug_event(dev);
 }
 
 static int dm_set_clockgating_state(void *handle,
@@ -501,6 +512,8 @@ int amdgpu_dm_init(struct amdgpu_device *adev)
 	/* initialize DAL's lock (for SYNC context use) */
 	spin_lock_init(&adev->dm.dal_lock);
 
+	mutex_init(&adev->dm.dal_mutex);
+
 	if(amdgpu_dm_irq_init(adev)) {
 		DRM_ERROR("amdgpu: failed to initialize DM IRQ support.\n");
 		goto error;
@@ -726,7 +739,9 @@ static int dm_resume(void *handle)
 		}
 	}
 
+	mutex_lock(&adev->dm.dal_mutex);
 	dal_reset_path_mode(dm->dal, displays_number, displays_vector);
+	mutex_unlock(&adev->dm.dal_mutex);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
index d631462..31e2ae2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
@@ -131,6 +131,12 @@ struct amdgpu_display_manager {
 	 * of the difference the OS calls Set Mode again, which is exactly
 	 * what we need. */
 	uint32_t fake_display_index;
+	/* Use dal_mutex for any activity which is NOT syncronized by
+	 * DRM mode setting locks.
+	 * For example: amdgpu_dm_hpd_low_irq() calls into DAL *without*
+	 * DRM mode setting locks being acquired. This is where dal_mutex
+	 * is acquired before calling into DAL. */
+	struct mutex dal_mutex;
 };
 
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
index acdff4b..c8400be 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm_types.c
@@ -604,7 +604,9 @@ bool amdgpu_dm_mode_reset(struct drm_crtc *crtc)
 			"Skip reset mode for disp_index %d\n",
 			display_index);
 	} else {
+		mutex_lock(&adev->dm.dal_mutex);
 		ret = dal_reset_path_mode(adev->dm.dal, 1, &display_index);
+		mutex_unlock(&adev->dm.dal_mutex);
 		DRM_DEBUG_KMS(
 			"Do reset mode for disp_index %d\n",
 			display_index);
@@ -699,7 +701,6 @@ int amdgpu_dm_set_config(struct drm_mode_set *set)
 	if (!set->mode)
 		set->fb = NULL;
 
-
 	/* Allocate space for the backup of all (non-pointer) crtc, encoder and
 	 * connector data. */
 	save_crtcs = kzalloc(dev->mode_config.num_crtc *
@@ -884,11 +885,17 @@ int amdgpu_dm_set_config(struct drm_mode_set *set)
 	}
 
 	if (mode_changed) {
-		DRM_DEBUG_KMS(
-				"Attempting to set mode from userspace\n");
+		struct amdgpu_device *adev;
+
+		DRM_DEBUG_KMS("Attempting to set mode from userspace. Mode:\n");
+
 		drm_mode_debug_printmodeline(set->mode);
 
 		set->crtc->primary->fb = set->fb;
+
+		adev = set->crtc->dev->dev_private;
+
+		mutex_lock(&adev->dm.dal_mutex);
 		if (!amdgpu_dm_mode_set(
 				set->crtc,
 				set->mode,
@@ -901,9 +908,12 @@ int amdgpu_dm_set_config(struct drm_mode_set *set)
 					acrtc->crtc_id);
 			set->crtc->primary->fb = save_set.fb;
 			ret = -EINVAL;
+			mutex_unlock(&adev->dm.dal_mutex);
 			goto fail;
 		}
 
+		mutex_unlock(&adev->dm.dal_mutex);
+
 		DRM_DEBUG_KMS("Setting connector DPMS state to on\n");
 		for (i = 0; i < set->num_connectors; i++) {
 			DRM_DEBUG_KMS(
-- 
1.9.1

