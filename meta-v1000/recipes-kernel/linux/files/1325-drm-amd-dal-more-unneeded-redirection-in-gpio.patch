From 9bedc8415a0fa76ee888a842874f29738597ccdc Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Wed, 12 Oct 2016 21:56:41 -0400
Subject: [PATCH 1325/1722] drm/amd/dal: more unneeded redirection in gpio

Change-Id: Ice87cb3b97025c9c71e18a49fc1bc243ee4953bf
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  6 +--
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |  2 +-
 drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c     | 48 ----------------------
 .../drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c   |  2 +-
 .../gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c |  2 +-
 drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c  | 13 +++---
 .../drm/amd/dal/include/gpio_service_interface.h   | 25 -----------
 7 files changed, 12 insertions(+), 86 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index de2855a..62a83f0 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -206,7 +206,7 @@ static bool detect_sink(struct core_link *link, enum dc_connection_type *type)
 	dal_gpio_open(hpd_pin, GPIO_MODE_INTERRUPT);
 	dal_gpio_get_value(hpd_pin, &is_hpd_high);
 	dal_gpio_close(hpd_pin);
-	dal_gpio_service_destroy_irq(&hpd_pin);
+	dal_gpio_destroy_irq(&hpd_pin);
 
 	if (is_hpd_high) {
 		*type = dc_connection_single;
@@ -355,13 +355,13 @@ static bool is_dp_sink_present(struct core_link *link)
 	/* Read GPIO: DP sink is present if both clock and data pins are zero */
 	/* [anaumov] in DAL2, there was no check for GPIO failure */
 
-	gpio_result = dal_ddc_get_clock(ddc, &clock_pin);
+	gpio_result = dal_gpio_get_value(ddc->pin_clock, &clock_pin);
 	ASSERT(gpio_result == GPIO_RESULT_OK);
 
 	if (gpio_result == GPIO_RESULT_OK)
 		if (link->link_enc->features.flags.bits.
 						DP_SINK_DETECT_POLL_DATA_PIN)
-			gpio_result = dal_ddc_get_data(ddc, &data_pin);
+			gpio_result = dal_gpio_get_value(ddc->pin_data, &data_pin);
 
 	present = (gpio_result == GPIO_RESULT_OK) && !(clock_pin || data_pin);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 29c485d..3fc3fac 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -635,7 +635,7 @@ static void link_encoder_edp_wait_for_hpd_ready(
 
 	dal_gpio_close(hpd);
 
-	dal_gpio_service_destroy_irq(&hpd);
+	dal_gpio_destroy_irq(&hpd);
 
 	if (false == edp_hpd_high) {
 		dal_logger_write(ctx->logger,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
index fbd788d..7320a6b 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
@@ -155,12 +155,6 @@ struct gpio *dal_gpio_service_create_irq(
 	return dal_gpio_create_irq(service, id, en);
 }
 
-void dal_gpio_service_destroy_irq(
-	struct gpio **irq)
-{
-	dal_gpio_destroy_irq(irq);
-}
-
 void dal_gpio_service_destroy(
 	struct gpio_service **ptr)
 {
@@ -532,34 +526,6 @@ failure:
 	return result;
 }
 
-enum gpio_result dal_ddc_get_clock(
-	const struct ddc *ddc,
-	uint32_t *value)
-{
-	return dal_gpio_get_value(ddc->pin_clock, value);
-}
-
-enum gpio_result dal_ddc_set_clock(
-	const struct ddc *ddc,
-	uint32_t value)
-{
-	return dal_gpio_set_value(ddc->pin_clock, value);
-}
-
-enum gpio_result dal_ddc_get_data(
-	const struct ddc *ddc,
-	uint32_t *value)
-{
-	return dal_gpio_get_value(ddc->pin_data, value);
-}
-
-enum gpio_result dal_ddc_set_data(
-	const struct ddc *ddc,
-	uint32_t value)
-{
-	return dal_gpio_set_value(ddc->pin_data, value);
-}
-
 enum gpio_result dal_ddc_change_mode(
 	struct ddc *ddc,
 	enum gpio_mode mode)
@@ -592,26 +558,12 @@ failure:
 	return result;
 }
 
-bool dal_ddc_is_hw_supported(
-	const struct ddc *ddc)
-{
-	return ddc->hw_info.hw_supported;
-}
-
 enum gpio_ddc_line dal_ddc_get_line(
 	const struct ddc *ddc)
 {
 	return (enum gpio_ddc_line)dal_gpio_get_enum(ddc->pin_data);
 }
 
-bool dal_ddc_check_line_aborted(
-	const struct ddc *self)
-{
-	/* No arbitration with VBIOS is performed since DCE 6.0 */
-
-	return false;
-}
-
 enum gpio_result dal_ddc_set_config(
 	struct ddc *ddc,
 	enum gpio_ddc_config_type config_type)
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
index 864c09c..650474bb 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
@@ -89,7 +89,7 @@ static struct i2c_engine *acquire_i2c_hw_engine(
 	if (!ddc)
 		return NULL;
 
-	if (dal_ddc_is_hw_supported(ddc)) {
+	if (ddc->hw_info.hw_supported) {
 		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
 
 		if (line < GPIO_DDC_LINE_COUNT)
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
index df16cae..be1d264 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce80/i2caux_dce80.c
@@ -118,7 +118,7 @@ static struct i2c_engine *acquire_i2c_hw_engine(
 	if (!ddc)
 		return NULL;
 
-	if (dal_ddc_is_hw_supported(ddc)) {
+	if (ddc->hw_info.hw_supported) {
 		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
 
 		if (line < GPIO_DDC_LINE_COUNT) {
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
index 5a9455c..95bc445 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2c_sw_engine.c
@@ -56,9 +56,9 @@ static inline bool read_bit_from_ddc(
 	uint32_t value = 0;
 
 	if (data_nor_clock)
-		dal_ddc_get_data(ddc, &value);
+		dal_gpio_get_value(ddc->pin_data, &value);
 	else
-		dal_ddc_get_clock(ddc, &value);
+		dal_gpio_get_value(ddc->pin_clock, &value);
 
 	return (value != 0);
 }
@@ -71,9 +71,9 @@ static inline void write_bit_to_ddc(
 	uint32_t value = bit ? 1 : 0;
 
 	if (data_nor_clock)
-		dal_ddc_set_data(ddc, value);
+		dal_gpio_set_value(ddc->pin_data, value);
 	else
-		dal_ddc_set_clock(ddc, value);
+		dal_gpio_set_value(ddc->pin_clock, value);
 }
 
 static bool wait_for_scl_high(
@@ -526,9 +526,8 @@ enum i2c_channel_operation_result dal_i2c_sw_engine_get_channel_status(
 	struct i2c_engine *engine,
 	uint8_t *returned_bytes)
 {
-	return dal_ddc_check_line_aborted(engine->base.ddc) ?
-		I2C_CHANNEL_OPERATION_FAILED :
-		I2C_CHANNEL_OPERATION_SUCCEEDED;
+	/* No arbitration with VBIOS is performed since DCE 6.0 */
+	return I2C_CHANNEL_OPERATION_SUCCEEDED;
 }
 
 void dal_i2c_sw_engine_destruct(
diff --git a/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h b/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h
index 7e99a04..f40259b 100644
--- a/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h
@@ -51,9 +51,6 @@ struct gpio *dal_gpio_service_create_irq(
 	uint32_t offset,
 	uint32_t mask);
 
-void dal_gpio_service_destroy_irq(
-	struct gpio **ptr);
-
 struct ddc *dal_gpio_create_ddc(
 	struct gpio_service *service,
 	uint32_t offset,
@@ -91,35 +88,13 @@ enum gpio_result dal_ddc_open(
 	enum gpio_mode mode,
 	enum gpio_ddc_config_type config_type);
 
-enum gpio_result dal_ddc_get_clock(
-	const struct ddc *ddc,
-	uint32_t *value);
-
-enum gpio_result dal_ddc_set_clock(
-	const struct ddc *ddc,
-	uint32_t value);
-
-enum gpio_result dal_ddc_get_data(
-	const struct ddc *ddc,
-	uint32_t *value);
-
-enum gpio_result dal_ddc_set_data(
-	const struct ddc *ddc,
-	uint32_t value);
-
 enum gpio_result dal_ddc_change_mode(
 	struct ddc *ddc,
 	enum gpio_mode mode);
 
-bool dal_ddc_is_hw_supported(
-	const struct ddc *ddc);
-
 enum gpio_ddc_line dal_ddc_get_line(
 	const struct ddc *ddc);
 
-bool dal_ddc_check_line_aborted(
-	const struct ddc *ddc);
-
 enum gpio_result dal_ddc_set_config(
 	struct ddc *ddc,
 	enum gpio_ddc_config_type config_type);
-- 
2.7.4

