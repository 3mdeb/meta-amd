From 7221c0972121659413300bc16f414e889d710981 Mon Sep 17 00:00:00 2001
From: "Leo (Sunpeng) Li" <sunpeng.li@amd.com>
Date: Tue, 25 Jul 2017 20:51:26 -0400
Subject: [PATCH 2754/2831] drm/amd/display: Roll core_stream into dc_stream

Change-Id: I4ba9615a927027e3321fb232fd0e5cbdd4e567f2
Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c  |   2 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.c    |  10 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.h    |   2 +-
 drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c   |  16 +-
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |  92 ++++----
 drivers/gpu/drm/amd/display/dc/core/dc.c           | 107 ++++-----
 drivers/gpu/drm/amd/display/dc/core/dc_debug.c     |   4 +-
 drivers/gpu/drm/amd/display/dc/core/dc_link.c      |  41 ++--
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c   |   7 +-
 drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c |   2 +-
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  | 259 ++++++++++-----------
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    | 118 +++++-----
 drivers/gpu/drm/amd/display/dc/dc.h                |  71 +++---
 .../gpu/drm/amd/display/dc/dce/dce_link_encoder.c  |  10 +-
 .../gpu/drm/amd/display/dc/dce/dce_link_encoder.h  |   2 +-
 .../drm/amd/display/dc/dce100/dce100_resource.c    |  12 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    | 176 +++++++-------
 .../drm/amd/display/dc/dce110/dce110_resource.c    |  46 ++--
 .../drm/amd/display/dc/dce112/dce112_resource.c    |  16 +-
 .../drm/amd/display/dc/dce112/dce112_resource.h    |   2 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |  12 +-
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  |  72 +++---
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |  36 +--
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |  33 +--
 drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h    |   4 +-
 .../gpu/drm/amd/display/dc/inc/hw/link_encoder.h   |   3 +-
 drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h  |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h      |  14 +-
 .../amd/display/dc/virtual/virtual_link_encoder.c  |   2 +-
 .../drm/amd/display/modules/freesync/freesync.c    |  60 +++--
 .../gpu/drm/amd/display/modules/inc/mod_freesync.h |  28 +--
 31 files changed, 612 insertions(+), 649 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 14f96c7..9f76c00 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -1535,7 +1535,7 @@ static int amdgpu_notify_freesync(struct drm_device *dev, void *data,
 	num_streams = dc_get_current_stream_count(adev->dm.dc);
 
 	for (i = 0; i < num_streams; i++) {
-		const struct dc_stream *stream;
+		struct dc_stream *stream;
 		stream = dc_get_stream_at_index(adev->dm.dc, i);
 
 		mod_freesync_update_state(adev->dm.freesync_module,
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
index e254e53..f8c4497 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
@@ -2345,7 +2345,7 @@ static bool is_scaling_state_different(
 static void remove_stream(
 		struct amdgpu_device *adev,
 		struct amdgpu_crtc *acrtc,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	/* this is the update mode case */
 	if (adev->dm.freesync_module)
@@ -2500,7 +2500,7 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 	uint32_t i;
 	struct drm_plane *plane;
 	struct drm_plane_state *old_plane_state;
-	const struct dc_stream *dc_stream_attach;
+	struct dc_stream *dc_stream_attach;
 	struct dc_surface *dc_surfaces_constructed[MAX_SURFACES];
 	struct amdgpu_crtc *acrtc_attach = to_amdgpu_crtc(pcrtc);
 	struct dm_crtc_state *acrtc_state = to_dm_crtc_state(pcrtc->state);
@@ -2637,7 +2637,7 @@ void amdgpu_dm_atomic_commit_tail(
 	struct drm_crtc *crtc, *pcrtc;
 	struct drm_crtc_state *old_crtc_state;
 	struct amdgpu_crtc *new_crtcs[MAX_STREAMS];
-	const struct dc_stream *new_stream = NULL;
+	struct dc_stream *new_stream = NULL;
 	unsigned long flags;
 	bool wait_for_vblank = true;
 	struct drm_connector *connector;
@@ -2973,8 +2973,8 @@ static uint32_t add_val_sets_surface(
 static uint32_t update_in_val_sets_stream(
 	struct dc_validation_set *val_sets,
 	uint32_t set_count,
-	const struct dc_stream *old_stream,
-	const struct dc_stream *new_stream,
+	struct dc_stream *old_stream,
+	struct dc_stream *new_stream,
 	struct drm_crtc *crtc)
 {
 	uint32_t i = 0;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
index c565787..94de6a3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
@@ -45,7 +45,7 @@ struct dm_plane_state {
 
 struct dm_crtc_state {
 	struct drm_crtc_state base;
-	const struct dc_stream *stream;
+	struct dc_stream *stream;
 };
 
 #define to_dm_crtc_state(x)    container_of(x, struct dm_crtc_state, base)
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
index 5ef44ff..9a85022 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
@@ -2610,9 +2610,9 @@ static void populate_initial_data(
 
 		data->fbc_en[num_displays + 4] = false;
 		data->lpt_en[num_displays + 4] = false;
-		data->h_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->public.timing.h_total);
-		data->v_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->public.timing.v_total);
-		data->pixel_rate[num_displays + 4] = bw_frc_to_fixed(pipe[i].stream->public.timing.pix_clk_khz, 1000);
+		data->h_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.h_total);
+		data->v_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.v_total);
+		data->pixel_rate[num_displays + 4] = bw_frc_to_fixed(pipe[i].stream->timing.pix_clk_khz, 1000);
 		data->src_width[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.width);
 		data->pitch_in_pixels[num_displays + 4] = data->src_width[num_displays + 4];
 		data->src_height[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.height);
@@ -2707,9 +2707,9 @@ static void populate_initial_data(
 
 		data->fbc_en[num_displays + 4] = false;
 		data->lpt_en[num_displays + 4] = false;
-		data->h_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->public.timing.h_total);
-		data->v_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->public.timing.v_total);
-		data->pixel_rate[num_displays + 4] = bw_frc_to_fixed(pipe[i].stream->public.timing.pix_clk_khz, 1000);
+		data->h_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.h_total);
+		data->v_total[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.v_total);
+		data->pixel_rate[num_displays + 4] = bw_frc_to_fixed(pipe[i].stream->timing.pix_clk_khz, 1000);
 		if (pipe[i].surface) {
 			data->src_width[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.viewport.width);
 			data->pitch_in_pixels[num_displays + 4] = data->src_width[num_displays + 4];
@@ -2759,9 +2759,9 @@ static void populate_initial_data(
 				break;
 			}
 		} else {
-			data->src_width[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->public.timing.h_addressable);
+			data->src_width[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.h_addressable);
 			data->pitch_in_pixels[num_displays + 4] = data->src_width[num_displays + 4];
-			data->src_height[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->public.timing.v_addressable);
+			data->src_height[num_displays + 4] = bw_int_to_fixed(pipe[i].stream->timing.v_addressable);
 			data->h_taps[num_displays + 4] = bw_int_to_fixed(1);
 			data->v_taps[num_displays + 4] = bw_int_to_fixed(1);
 			data->h_scale_ratio[num_displays + 4] = bw_int_to_fixed(1);
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index 1651b75..ef10a8b 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -365,7 +365,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	}
 
 
-	input->dest.vactive        = pipe->stream->public.timing.v_addressable;
+	input->dest.vactive        = pipe->stream->timing.v_addressable;
 
 	input->dest.recout_width   = pipe->scl_data.recout.width;
 	input->dest.recout_height  = pipe->scl_data.recout.height;
@@ -373,24 +373,24 @@ static void pipe_ctx_to_e2e_pipe_params (
 	input->dest.full_recout_width   = pipe->scl_data.recout.width;
 	input->dest.full_recout_height  = pipe->scl_data.recout.height;
 
-	input->dest.htotal         = pipe->stream->public.timing.h_total;
-	input->dest.hblank_start   = input->dest.htotal - pipe->stream->public.timing.h_front_porch;
+	input->dest.htotal         = pipe->stream->timing.h_total;
+	input->dest.hblank_start   = input->dest.htotal - pipe->stream->timing.h_front_porch;
 	input->dest.hblank_end     = input->dest.hblank_start
-			- pipe->stream->public.timing.h_addressable
-			- pipe->stream->public.timing.h_border_left
-			- pipe->stream->public.timing.h_border_right;
+			- pipe->stream->timing.h_addressable
+			- pipe->stream->timing.h_border_left
+			- pipe->stream->timing.h_border_right;
 
-	input->dest.vtotal         = pipe->stream->public.timing.v_total;
-	input->dest.vblank_start   = input->dest.vtotal - pipe->stream->public.timing.v_front_porch;
+	input->dest.vtotal         = pipe->stream->timing.v_total;
+	input->dest.vblank_start   = input->dest.vtotal - pipe->stream->timing.v_front_porch;
 	input->dest.vblank_end     = input->dest.vblank_start
-			- pipe->stream->public.timing.v_addressable
-			- pipe->stream->public.timing.v_border_bottom
-			- pipe->stream->public.timing.v_border_top;
-
-	input->dest.vsync_plus_back_porch = pipe->stream->public.timing.v_total
-			- pipe->stream->public.timing.v_addressable
-			- pipe->stream->public.timing.v_front_porch;
-	input->dest.pixel_rate_mhz = pipe->stream->public.timing.pix_clk_khz/1000.0;
+			- pipe->stream->timing.v_addressable
+			- pipe->stream->timing.v_border_bottom
+			- pipe->stream->timing.v_border_top;
+
+	input->dest.vsync_plus_back_porch = pipe->stream->timing.v_total
+			- pipe->stream->timing.v_addressable
+			- pipe->stream->timing.v_front_porch;
+	input->dest.pixel_rate_mhz = pipe->stream->timing.pix_clk_khz/1000.0;
 	input->dest.vstartup_start = pipe->pipe_dlg_param.vstartup_start;
 	input->dest.vupdate_offset = pipe->pipe_dlg_param.vupdate_offset;
 	input->dest.vupdate_offset = pipe->pipe_dlg_param.vupdate_offset;
@@ -851,14 +851,14 @@ bool dcn_validate_bandwidth(
 		v->underscan_output[input_idx] = false; /* taken care of in recout already*/
 		v->interlace_output[input_idx] = false;
 
-		v->htotal[input_idx] = pipe->stream->public.timing.h_total;
-		v->vtotal[input_idx] = pipe->stream->public.timing.v_total;
-		v->v_sync_plus_back_porch[input_idx] = pipe->stream->public.timing.v_total
-				- pipe->stream->public.timing.v_addressable
-				- pipe->stream->public.timing.v_front_porch;
-		v->vactive[input_idx] = pipe->stream->public.timing.v_addressable;
-		v->pixel_clock[input_idx] = pipe->stream->public.timing.pix_clk_khz / 1000.0f;
-		if (pipe->stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		v->htotal[input_idx] = pipe->stream->timing.h_total;
+		v->vtotal[input_idx] = pipe->stream->timing.v_total;
+		v->v_sync_plus_back_porch[input_idx] = pipe->stream->timing.v_total
+				- pipe->stream->timing.v_addressable
+				- pipe->stream->timing.v_front_porch;
+		v->vactive[input_idx] = pipe->stream->timing.v_addressable;
+		v->pixel_clock[input_idx] = pipe->stream->timing.pix_clk_khz / 1000.0f;
+		if (pipe->stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
 			v->pixel_clock[input_idx] /= 2;
 
 
@@ -867,10 +867,10 @@ bool dcn_validate_bandwidth(
 			v->source_pixel_format[input_idx] = dcn_bw_rgb_sub_32;
 			v->source_surface_mode[input_idx] = dcn_bw_sw_4_kb_s;
 			v->lb_bit_per_pixel[input_idx] = 30;
-			v->viewport_width[input_idx] = pipe->stream->public.timing.h_addressable;
-			v->viewport_height[input_idx] = pipe->stream->public.timing.v_addressable;
-			v->scaler_rec_out_width[input_idx] = pipe->stream->public.timing.h_addressable;
-			v->scaler_recout_height[input_idx] = pipe->stream->public.timing.v_addressable;
+			v->viewport_width[input_idx] = pipe->stream->timing.h_addressable;
+			v->viewport_height[input_idx] = pipe->stream->timing.v_addressable;
+			v->scaler_rec_out_width[input_idx] = pipe->stream->timing.h_addressable;
+			v->scaler_recout_height[input_idx] = pipe->stream->timing.v_addressable;
 			v->override_hta_ps[input_idx] = 1;
 			v->override_vta_ps[input_idx] = 1;
 			v->override_hta_pschroma[input_idx] = 1;
@@ -995,22 +995,22 @@ bool dcn_validate_bandwidth(
 			pipe->pipe_dlg_param.vready_offset = v->v_ready_offset[input_idx];
 			pipe->pipe_dlg_param.vstartup_start = v->v_startup[input_idx];
 
-			pipe->pipe_dlg_param.htotal = pipe->stream->public.timing.h_total;
-			pipe->pipe_dlg_param.vtotal = pipe->stream->public.timing.v_total;
-			vesa_sync_start = pipe->stream->public.timing.v_addressable +
-						pipe->stream->public.timing.v_border_bottom +
-						pipe->stream->public.timing.v_front_porch;
+			pipe->pipe_dlg_param.htotal = pipe->stream->timing.h_total;
+			pipe->pipe_dlg_param.vtotal = pipe->stream->timing.v_total;
+			vesa_sync_start = pipe->stream->timing.v_addressable +
+						pipe->stream->timing.v_border_bottom +
+						pipe->stream->timing.v_front_porch;
 
-			asic_blank_end = (pipe->stream->public.timing.v_total -
+			asic_blank_end = (pipe->stream->timing.v_total -
 						vesa_sync_start -
-						pipe->stream->public.timing.v_border_top)
-			* (pipe->stream->public.timing.flags.INTERLACE ? 1 : 0);
+						pipe->stream->timing.v_border_top)
+			* (pipe->stream->timing.flags.INTERLACE ? 1 : 0);
 
 			asic_blank_start = asic_blank_end +
-						(pipe->stream->public.timing.v_border_top +
-						pipe->stream->public.timing.v_addressable +
-						pipe->stream->public.timing.v_border_bottom)
-			* (pipe->stream->public.timing.flags.INTERLACE ? 1 : 0);
+						(pipe->stream->timing.v_border_top +
+						pipe->stream->timing.v_addressable +
+						pipe->stream->timing.v_border_bottom)
+			* (pipe->stream->timing.flags.INTERLACE ? 1 : 0);
 
 			pipe->pipe_dlg_param.vblank_start = asic_blank_start;
 			pipe->pipe_dlg_param.vblank_end = asic_blank_end;
@@ -1019,13 +1019,13 @@ bool dcn_validate_bandwidth(
 				struct pipe_ctx *hsplit_pipe = pipe->bottom_pipe;
 
 				if (v->dpp_per_plane[input_idx] == 2 ||
-					((pipe->stream->public.view_format ==
+					((pipe->stream->view_format ==
 					  VIEW_3D_FORMAT_SIDE_BY_SIDE ||
-					  pipe->stream->public.view_format ==
+					  pipe->stream->view_format ==
 					  VIEW_3D_FORMAT_TOP_AND_BOTTOM) &&
-					(pipe->stream->public.timing.timing_3d_format ==
+					(pipe->stream->timing.timing_3d_format ==
 					 TIMING_3D_FORMAT_TOP_AND_BOTTOM ||
-					 pipe->stream->public.timing.timing_3d_format ==
+					 pipe->stream->timing.timing_3d_format ==
 					 TIMING_3D_FORMAT_SIDE_BY_SIDE))) {
 					if (hsplit_pipe && hsplit_pipe->surface == pipe->surface) {
 						/* update previously split pipe */
@@ -1034,8 +1034,8 @@ bool dcn_validate_bandwidth(
 						hsplit_pipe->pipe_dlg_param.vready_offset = v->v_ready_offset[input_idx];
 						hsplit_pipe->pipe_dlg_param.vstartup_start = v->v_startup[input_idx];
 
-						hsplit_pipe->pipe_dlg_param.htotal = pipe->stream->public.timing.h_total;
-						hsplit_pipe->pipe_dlg_param.vtotal = pipe->stream->public.timing.v_total;
+						hsplit_pipe->pipe_dlg_param.htotal = pipe->stream->timing.h_total;
+						hsplit_pipe->pipe_dlg_param.vtotal = pipe->stream->timing.v_total;
 						hsplit_pipe->pipe_dlg_param.vblank_start = pipe->pipe_dlg_param.vblank_start;
 						hsplit_pipe->pipe_dlg_param.vblank_end = pipe->pipe_dlg_param.vblank_end;
 					} else {
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e4c5560..c513bbe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -149,19 +149,19 @@ static bool create_links(
 }
 
 static bool stream_adjust_vmin_vmax(struct dc *dc,
-		const struct dc_stream **stream, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	struct dc_stream *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == core_stream && pipe->stream_enc) {
+		if (pipe->stream == stream && pipe->stream_enc) {
 			core_dc->hwss.set_drr(&pipe, 1, vmin, vmax);
 
 			/* build and update the info frame */
@@ -175,12 +175,12 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 }
 
 static bool stream_get_crtc_position(struct dc *dc,
-		const struct dc_stream **stream, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	struct dc_stream *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 	struct crtc_position position;
@@ -189,7 +189,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 		struct pipe_ctx *pipe =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == core_stream && pipe->stream_enc) {
+		if (pipe->stream == stream && pipe->stream_enc) {
 			core_dc->hwss.get_position(&pipe, 1, &position);
 
 			*v_pos = position.vertical_count;
@@ -203,15 +203,12 @@ static bool stream_get_crtc_position(struct dc *dc,
 static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
-				== core_stream) {
-
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == stream) {
 			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
 			core_dc->hwss.program_gamut_remap(pipes);
 			ret = true;
@@ -221,22 +218,21 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 	return ret;
 }
 
-static bool program_csc_matrix(struct dc *dc, const struct dc_stream *stream)
+static bool program_csc_matrix(struct dc *dc, struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
-				== core_stream) {
+				== stream) {
 
 			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
 			core_dc->hwss.program_csc_matrix(pipes,
-			core_stream->public.output_color_space,
-			core_stream->public.csc_color_matrix.matrix);
+			stream->output_color_space,
+			stream->csc_color_matrix.matrix);
 			ret = true;
 		}
 	}
@@ -245,7 +241,7 @@ static bool program_csc_matrix(struct dc *dc, const struct dc_stream *stream)
 }
 
 static void set_static_screen_events(struct dc *dc,
-		const struct dc_stream **stream,
+		struct dc_stream **streams,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
@@ -256,11 +252,11 @@ static void set_static_screen_events(struct dc *dc,
 	int num_pipes_affected = 0;
 
 	for (i = 0; i < num_streams; i++) {
-		struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[i]);
+		struct dc_stream *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
 			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
-					== core_stream) {
+					== stream) {
 				pipes_affected[num_pipes_affected++] =
 						&core_dc->current_context->res_ctx.pipe_ctx[j];
 			}
@@ -337,10 +333,9 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
-void set_dither_option(const struct dc_stream *dc_stream,
+void set_dither_option(struct dc_stream *stream,
 		enum dc_dither_option option)
 {
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct bit_depth_reduction_params params;
 	struct dc_link *link = stream->status.link;
 	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
@@ -351,21 +346,21 @@ void set_dither_option(const struct dc_stream *dc_stream,
 	if (option > DITHER_OPTION_MAX)
 		return;
 	if (option == DITHER_OPTION_DEFAULT) {
-		switch (stream->public.timing.display_color_depth) {
+		switch (stream->timing.display_color_depth) {
 		case COLOR_DEPTH_666:
-			stream->public.dither_option = DITHER_OPTION_SPATIAL6;
+			stream->dither_option = DITHER_OPTION_SPATIAL6;
 			break;
 		case COLOR_DEPTH_888:
-			stream->public.dither_option = DITHER_OPTION_SPATIAL8;
+			stream->dither_option = DITHER_OPTION_SPATIAL8;
 			break;
 		case COLOR_DEPTH_101010:
-			stream->public.dither_option = DITHER_OPTION_SPATIAL10;
+			stream->dither_option = DITHER_OPTION_SPATIAL10;
 			break;
 		default:
 			option = DITHER_OPTION_DISABLE;
 		}
 	} else {
-		stream->public.dither_option = option;
+		stream->dither_option = option;
 	}
 	resource_build_bit_depth_reduction_params(stream,
 				&params);
@@ -644,7 +639,7 @@ static bool is_validation_required(
 
 		if (set[i].surface_count != context->stream_status[i].surface_count)
 			return true;
-		if (!is_stream_unchanged(DC_STREAM_TO_CORE(set[i].stream), context->streams[i]))
+		if (!is_stream_unchanged(set[i].stream, context->streams[i]))
 			return true;
 
 		for (j = 0; j < set[i].surface_count; j++) {
@@ -754,7 +749,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -869,7 +864,7 @@ static bool context_changed(
 		return true;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (&dc->current_context->streams[i]->public != &context->streams[i]->public)
+		if (dc->current_context->streams[i] != context->streams[i])
 			return true;
 	}
 
@@ -878,7 +873,7 @@ static bool context_changed(
 
 static bool streams_changed(
 		struct core_dc *dc,
-		const struct dc_stream *streams[],
+		struct dc_stream *streams[],
 		uint8_t stream_count)
 {
 	uint8_t i;
@@ -887,7 +882,7 @@ static bool streams_changed(
 		return true;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (&dc->current_context->streams[i]->public != streams[i])
+		if (dc->current_context->streams[i] != streams[i])
 			return true;
 	}
 
@@ -897,7 +892,7 @@ static bool streams_changed(
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
-	const struct dc_stream *streams[],
+	struct dc_stream *streams[],
 	uint8_t stream_count)
 {
 	bool ret = true;
@@ -915,7 +910,7 @@ bool dc_enable_stereo(
 		else
 			pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 		for (j = 0 ; pipe && j < stream_count; j++)  {
-			if (streams[j] && streams[j] == &pipe->stream->public &&
+			if (streams[j] && streams[j] == pipe->stream &&
 				core_dc->hwss.setup_stereo)
 				core_dc->hwss.setup_stereo(pipe, core_dc);
 		}
@@ -943,10 +938,10 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
-	const struct dc_stream *dc_streams[MAX_STREAMS] = {0};
+	struct dc_stream *dc_streams[MAX_STREAMS] = {0};
 
 	for (i = 0; i < context->stream_count; i++)
-		dc_streams[i] =  &context->streams[i]->public;
+		dc_streams[i] =  context->streams[i];
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		core_dc->hwss.enable_accelerated_mode(core_dc);
@@ -985,11 +980,11 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		}
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
-				context->streams[i]->public.timing.h_addressable,
-				context->streams[i]->public.timing.v_addressable,
-				context->streams[i]->public.timing.h_total,
-				context->streams[i]->public.timing.v_total,
-				context->streams[i]->public.timing.pix_clk_khz);
+				context->streams[i]->timing.h_addressable,
+				context->streams[i]->timing.v_addressable,
+				context->streams[i]->timing.h_total,
+				context->streams[i]->timing.v_total,
+				context->streams[i]->timing.pix_clk_khz);
 	}
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
@@ -1016,7 +1011,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
-		const struct dc_stream *stream = &context->streams[i]->public;
+		struct dc_stream *stream = context->streams[i];
 
 		dc_stream_log(stream,
 				core_dc->ctx->logger,
@@ -1031,7 +1026,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 
 bool dc_commit_streams(
 	struct dc *dc,
-	const struct dc_stream *streams[],
+	struct dc_stream *streams[],
 	uint8_t stream_count)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1047,8 +1042,8 @@ bool dc_commit_streams(
 				__func__, stream_count);
 
 	for (i = 0; i < stream_count; i++) {
-		const struct dc_stream *stream = streams[i];
-		const struct dc_stream_status *status = dc_stream_get_status(stream);
+		struct dc_stream *stream = streams[i];
+		struct dc_stream_status *status = dc_stream_get_status(stream);
 		int j;
 
 		dc_stream_log(stream,
@@ -1120,7 +1115,7 @@ bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
 		struct dc_surface **new_surfaces,
 		uint8_t new_surface_count,
-		const struct dc_stream *dc_stream)
+		struct dc_stream *dc_stream)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
 	struct dc_flip_addrs flip_addr[MAX_SURFACES];
@@ -1377,7 +1372,7 @@ enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_surfaces_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *stream,
 		struct dc_stream_update *stream_update)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1385,7 +1380,6 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	int i, j;
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct dc_context *dc_ctx = core_dc->ctx;
 
 	/* Currently this function do not result in any HW programming
@@ -1398,7 +1392,8 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (surface_count == 0)
 		return;
 
-	stream_status = dc_stream_get_status(dc_stream);
+	stream_status = dc_stream_get_status(stream);
+
 	ASSERT(stream_status);
 	if (!stream_status)
 		return; /* Cannot commit surface to stream that is not committed */
@@ -1415,19 +1410,19 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (stream_update) {
 		if ((stream_update->src.height != 0) &&
 				(stream_update->src.width != 0))
-			stream->public.src = stream_update->src;
+			stream->src = stream_update->src;
 
 		if ((stream_update->dst.height != 0) &&
 				(stream_update->dst.width != 0))
-			stream->public.dst = stream_update->dst;
+			stream->dst = stream_update->dst;
 
 		if (stream_update->out_transfer_func &&
 				stream_update->out_transfer_func !=
-						dc_stream->out_transfer_func) {
-			if (dc_stream->out_transfer_func != NULL)
-				dc_transfer_func_release(dc_stream->out_transfer_func);
+						stream->out_transfer_func) {
+			if (stream->out_transfer_func != NULL)
+				dc_transfer_func_release(stream->out_transfer_func);
 			dc_transfer_func_retain(stream_update->out_transfer_func);
-			stream->public.out_transfer_func =
+			stream->out_transfer_func =
 				stream_update->out_transfer_func;
 		}
 	}
@@ -1469,7 +1464,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, dc_stream,
+				new_surfaces, surface_count, stream,
 				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
@@ -1617,7 +1612,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 					core_dc, pipe_ctx->surface, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		dc_stream_set_cursor_position(&pipe_ctx->stream->public, &position);
+		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
 
 		if (is_new_pipe_surface) {
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
@@ -1712,7 +1707,7 @@ struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	if (i < core_dc->current_context->stream_count)
-		return &(core_dc->current_context->streams[i]->public);
+		return core_dc->current_context->streams[i];
 	return NULL;
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
index 9a5df3a..bf127a8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
@@ -321,8 +321,8 @@ void context_timing_trace(
 
 		TIMING_TRACE("OTG_%d   H_tot:%d  V_tot:%d   H_pos:%d  V_pos:%d\n",
 				pipe_ctx->tg->inst,
-				pipe_ctx->stream->public.timing.h_total,
-				pipe_ctx->stream->public.timing.v_total,
+				pipe_ctx->stream->timing.h_total,
+				pipe_ctx->stream->timing.v_total,
 				h_pos[i], v_pos[i]);
 	}
 }
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index fd2ae18..2487046 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -1143,7 +1143,7 @@ static void dpcd_configure_panel_mode(
 
 static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	union down_spread_ctrl downspread;
 
@@ -1151,7 +1151,7 @@ static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 			&downspread.raw, sizeof(downspread));
 
 	downspread.bits.IGNORE_MSA_TIMING_PARAM =
-			(stream->public.ignore_msa_timing_param) ? 1 : 0;
+			(stream->ignore_msa_timing_param) ? 1 : 0;
 
 	core_link_write_dpcd(link, DP_DOWNSPREAD_CTRL,
 			&downspread.raw, sizeof(downspread));
@@ -1159,7 +1159,7 @@ static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 
 static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	enum dc_status status;
 	bool skip_video_pattern;
 	struct dc_link *link = stream->sink->link;
@@ -1250,7 +1250,7 @@ static enum dc_status enable_link_dp_mst(struct pipe_ctx *pipe_ctx)
 
 static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	enum dc_color_depth display_color_depth;
 
@@ -1258,13 +1258,13 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 		dal_ddc_service_write_scdc_data(
 			stream->sink->link->ddc,
 			stream->phy_pix_clk,
-			stream->public.timing.flags.LTE_340MCSC_SCRAMBLE);
+			stream->timing.flags.LTE_340MCSC_SCRAMBLE);
 
 	memset(&stream->sink->link->cur_link_settings, 0,
 			sizeof(struct dc_link_settings));
 
-	display_color_depth = stream->public.timing.display_color_depth;
-	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)
+	display_color_depth = stream->timing.display_color_depth;
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)
 		display_color_depth = COLOR_DEPTH_888;
 
 	link->link_enc->funcs->enable_tmds_output(
@@ -1341,7 +1341,7 @@ static void disable_link(struct dc_link *link, enum signal_type signal)
 }
 
 enum dc_status dc_link_validate_mode_timing(
-		const struct core_stream *stream,
+		const struct dc_stream *stream,
 		struct dc_link *link,
 		const struct dc_crtc_timing *timing)
 {
@@ -1377,7 +1377,6 @@ bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
 		uint32_t frame_ramp, const struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
-	struct core_stream *core_stream = NULL;
 	struct abm *abm = core_dc->res_pool->abm;
 	unsigned int controller_id = 0;
 	int i;
@@ -1390,11 +1389,10 @@ bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
 
 	if (dc_is_embedded_signal(link->connector_signal)) {
 		if (stream != NULL) {
-			core_stream = DC_STREAM_TO_CORE(stream);
 			for (i = 0; i < MAX_PIPES; i++) {
 				if (core_dc->current_context->res_ctx.
 						pipe_ctx[i].stream
-						== core_stream)
+						== stream)
 					/* DMCU -1 for all controller id values,
 					 * therefore +1 here
 					 */
@@ -1457,7 +1455,6 @@ bool dc_link_setup_psr(struct dc_link *link,
 {
 	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i;
 
 	psr_context->controllerId = CONTROLLER_ID_UNDEFINED;
@@ -1501,7 +1498,7 @@ bool dc_link_setup_psr(struct dc_link *link,
 
 		for (i = 0; i < MAX_PIPES; i++) {
 			if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
-					== core_stream) {
+					== stream) {
 				/* dmcu -1 for all controller id values,
 				 * therefore +1 here
 				 */
@@ -1590,7 +1587,7 @@ void core_link_resume(struct dc_link *link)
 		program_hpd_filter(link);
 }
 
-static struct fixed31_32 get_pbn_per_slot(struct core_stream *stream)
+static struct fixed31_32 get_pbn_per_slot(struct dc_stream *stream)
 {
 	struct dc_link_settings *link_settings =
 			&stream->sink->link->cur_link_settings;
@@ -1699,7 +1696,7 @@ static void update_mst_stream_alloc_table(
  */
 static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	struct link_encoder *link_encoder = link->link_enc;
 	struct stream_encoder *stream_encoder = pipe_ctx->stream_enc;
@@ -1717,7 +1714,7 @@ static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 	/* get calculate VC payload for stream: stream_alloc */
 	if (dm_helpers_dp_mst_write_payload_allocation_table(
 		stream->ctx,
-		&stream->public,
+		stream,
 		&proposed_table,
 		true)) {
 		update_mst_stream_alloc_table(
@@ -1759,11 +1756,11 @@ static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 	/* send down message */
 	dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 			stream->ctx,
-			&stream->public);
+			stream);
 
 	dm_helpers_dp_mst_send_payload_allocation(
 			stream->ctx,
-			&stream->public,
+			stream,
 			true);
 
 	/* slot X.Y for only current stream */
@@ -1781,7 +1778,7 @@ static enum dc_status allocate_mst_payload(struct pipe_ctx *pipe_ctx)
 
 static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	struct link_encoder *link_encoder = link->link_enc;
 	struct stream_encoder *stream_encoder = pipe_ctx->stream_enc;
@@ -1806,7 +1803,7 @@ static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 	if (mst_mode) {
 		if (dm_helpers_dp_mst_write_payload_allocation_table(
 				stream->ctx,
-				&stream->public,
+				stream,
 				&proposed_table,
 				false)) {
 
@@ -1848,11 +1845,11 @@ static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 	if (mst_mode) {
 		dm_helpers_dp_mst_poll_for_allocation_change_trigger(
 			stream->ctx,
-			&stream->public);
+			stream);
 
 		dm_helpers_dp_mst_send_payload_allocation(
 			stream->ctx,
-			&stream->public,
+			stream,
 			false);
 	}
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index c7b4007..d9754b5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -1434,7 +1434,7 @@ bool dp_validate_mode_timing(
 		return false;
 }
 
-void decide_link_settings(struct core_stream *stream,
+void decide_link_settings(struct dc_stream *stream,
 	struct dc_link_settings *link_setting)
 {
 
@@ -1446,8 +1446,7 @@ void decide_link_settings(struct core_stream *stream,
 	uint32_t req_bw;
 	uint32_t link_bw;
 
-	req_bw = bandwidth_in_kbps_from_timing(
-			&stream->public.timing);
+	req_bw = bandwidth_in_kbps_from_timing(&stream->timing);
 
 	link = stream->sink->link;
 
@@ -2327,7 +2326,7 @@ static void set_crtc_test_pattern(struct dc_link *link,
 {
 	enum controller_dp_test_pattern controller_test_pattern;
 	enum dc_color_depth color_depth = pipe_ctx->
-		stream->public.timing.display_color_depth;
+		stream->timing.display_color_depth;
 	struct bit_depth_reduction_params params;
 
 	memset(&params, 0, sizeof(params));
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 5bdcd50..76dc169 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -78,7 +78,7 @@ void dp_enable_link_phy(
 					pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
 				pipes[i].clock_source = dp_cs;
 				pipes[i].pix_clk_params.requested_pix_clk =
-						pipes[i].stream->public.timing.pix_clk_khz;
+						pipes[i].stream->timing.pix_clk_khz;
 				pipes[i].clock_source->funcs->program_pix_clk(
 							pipes[i].clock_source,
 							&pipes[i].pix_clk_params,
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7240a70..7e4c387 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -294,25 +294,25 @@ void resource_reference_clock_source(
 }
 
 bool resource_are_streams_timing_synchronizable(
-	const struct core_stream *stream1,
-	const struct core_stream *stream2)
+	struct dc_stream *stream1,
+	struct dc_stream *stream2)
 {
-	if (stream1->public.timing.h_total != stream2->public.timing.h_total)
+	if (stream1->timing.h_total != stream2->timing.h_total)
 		return false;
 
-	if (stream1->public.timing.v_total != stream2->public.timing.v_total)
+	if (stream1->timing.v_total != stream2->timing.v_total)
 		return false;
 
-	if (stream1->public.timing.h_addressable
-				!= stream2->public.timing.h_addressable)
+	if (stream1->timing.h_addressable
+				!= stream2->timing.h_addressable)
 		return false;
 
-	if (stream1->public.timing.v_addressable
-				!= stream2->public.timing.v_addressable)
+	if (stream1->timing.v_addressable
+				!= stream2->timing.v_addressable)
 		return false;
 
-	if (stream1->public.timing.pix_clk_khz
-				!= stream2->public.timing.pix_clk_khz)
+	if (stream1->timing.pix_clk_khz
+				!= stream2->timing.pix_clk_khz)
 		return false;
 
 	if (stream1->phy_pix_clk != stream2->phy_pix_clk
@@ -431,7 +431,7 @@ static void rect_swap_helper(struct rect *rect)
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = &pipe_ctx->stream->public;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
 	struct rect clip = { 0 };
@@ -530,7 +530,7 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	struct rect surf_clip = surface->clip_rect;
 	int recout_full_x, recout_full_y;
@@ -539,38 +539,38 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
-	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
-	if (stream->public.src.x < surf_clip.x)
+	pipe_ctx->scl_data.recout.x = stream->dst.x;
+	if (stream->src.x < surf_clip.x)
 		pipe_ctx->scl_data.recout.x += (surf_clip.x
-			- stream->public.src.x) * stream->public.dst.width
-						/ stream->public.src.width;
+			- stream->src.x) * stream->dst.width
+						/ stream->src.width;
 
 	pipe_ctx->scl_data.recout.width = surf_clip.width *
-			stream->public.dst.width / stream->public.src.width;
+			stream->dst.width / stream->src.width;
 	if (pipe_ctx->scl_data.recout.width + pipe_ctx->scl_data.recout.x >
-			stream->public.dst.x + stream->public.dst.width)
+			stream->dst.x + stream->dst.width)
 		pipe_ctx->scl_data.recout.width =
-			stream->public.dst.x + stream->public.dst.width
+			stream->dst.x + stream->dst.width
 						- pipe_ctx->scl_data.recout.x;
 
-	pipe_ctx->scl_data.recout.y = stream->public.dst.y;
-	if (stream->public.src.y < surf_clip.y)
+	pipe_ctx->scl_data.recout.y = stream->dst.y;
+	if (stream->src.y < surf_clip.y)
 		pipe_ctx->scl_data.recout.y += (surf_clip.y
-			- stream->public.src.y) * stream->public.dst.height
-						/ stream->public.src.height;
+			- stream->src.y) * stream->dst.height
+						/ stream->src.height;
 
 	pipe_ctx->scl_data.recout.height = surf_clip.height *
-			stream->public.dst.height / stream->public.src.height;
+			stream->dst.height / stream->src.height;
 	if (pipe_ctx->scl_data.recout.height + pipe_ctx->scl_data.recout.y >
-			stream->public.dst.y + stream->public.dst.height)
+			stream->dst.y + stream->dst.height)
 		pipe_ctx->scl_data.recout.height =
-			stream->public.dst.y + stream->public.dst.height
+			stream->dst.y + stream->dst.height
 						- pipe_ctx->scl_data.recout.y;
 
 	/* Handle h & vsplit */
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
 		pipe_ctx->surface) {
-		if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
+		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 			pipe_ctx->scl_data.recout.height /= 2;
 			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
 			/* Floor primary pipe, ceil 2ndary pipe */
@@ -582,7 +582,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 		}
 	} else if (pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
-		if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
+		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
 		else
 			pipe_ctx->scl_data.recout.width /= 2;
@@ -592,14 +592,14 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
-	recout_full_x = stream->public.dst.x + (surface->dst_rect.x -  stream->public.src.x)
-					* stream->public.dst.width / stream->public.src.width -
+	recout_full_x = stream->dst.x + (surface->dst_rect.x -  stream->src.x)
+					* stream->dst.width / stream->src.width -
 			surf_src.x * surface->dst_rect.width / surf_src.width
-					* stream->public.dst.width / stream->public.src.width;
-	recout_full_y = stream->public.dst.y + (surface->dst_rect.y -  stream->public.src.y)
-					* stream->public.dst.height / stream->public.src.height -
+					* stream->dst.width / stream->src.width;
+	recout_full_y = stream->dst.y + (surface->dst_rect.y -  stream->src.y)
+					* stream->dst.height / stream->src.height -
 			surf_src.y * surface->dst_rect.height / surf_src.height
-					* stream->public.dst.height / stream->public.src.height;
+					* stream->dst.height / stream->src.height;
 
 	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
 	recout_skip->height = pipe_ctx->scl_data.recout.y - recout_full_y;
@@ -608,12 +608,12 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
-	const int in_w = stream->public.src.width;
-	const int in_h = stream->public.src.height;
-	const int out_w = stream->public.dst.width;
-	const int out_h = stream->public.dst.height;
+	const int in_w = stream->src.width;
+	const int in_h = stream->src.height;
+	const int out_w = stream->dst.width;
+	const int out_h = stream->dst.height;
 
 	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
@@ -626,9 +626,9 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 					surf_src.height,
 					surface->dst_rect.height);
 
-	if (stream->public.view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
+	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
-	else if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
+	else if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 		pipe_ctx->scl_data.ratios.vert.value *= 2;
 
 	pipe_ctx->scl_data.ratios.vert.value = div64_s64(
@@ -815,7 +815,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
 
@@ -920,7 +920,7 @@ struct pipe_ctx *find_idle_secondary_pipe(
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
-		const struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -940,11 +940,10 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		const struct dc_stream *dc_stream)
+		struct dc_stream *stream)
 {
 	int i;
 	struct resource_context *res_ctx = &context->res_ctx;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	struct pipe_ctx *head_pipe = NULL;
 
@@ -980,10 +979,9 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 static void release_free_pipes_for_stream(
 		struct resource_context *res_ctx,
-		const struct dc_stream *dc_stream)
+		struct dc_stream *stream)
 {
 	int i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	for (i = MAX_PIPES - 1; i >= 0; i--) {
 		/* never release the topmost pipe*/
@@ -999,7 +997,7 @@ static void release_free_pipes_for_stream(
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 
@@ -1033,14 +1031,13 @@ static int acquire_first_split_pipe(
 bool resource_attach_surfaces_to_context(
 		struct dc_surface * const *surfaces,
 		int surface_count,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *stream,
 		struct validate_context *context,
 		const struct resource_pool *pool)
 {
 	int i;
 	struct pipe_ctx *tail_pipe;
 	struct dc_stream_status *stream_status = NULL;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 
 	if (surface_count > MAX_SURFACE_NUM) {
@@ -1050,7 +1047,7 @@ bool resource_attach_surfaces_to_context(
 	}
 
 	for (i = 0; i < context->stream_count; i++)
-		if (&context->streams[i]->public == dc_stream) {
+		if (context->streams[i] == stream) {
 			stream_status = &context->stream_status[i];
 			break;
 		}
@@ -1081,7 +1078,7 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++) {
 		struct dc_surface *surface = surfaces[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
-				context, pool, dc_stream);
+				context, pool, stream);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 		if (!free_pipe) {
@@ -1109,7 +1106,7 @@ bool resource_attach_surfaces_to_context(
 		tail_pipe = free_pipe;
 	}
 
-	release_free_pipes_for_stream(&context->res_ctx, dc_stream);
+	release_free_pipes_for_stream(&context->res_ctx, stream);
 
 	/* assign new surfaces*/
 	for (i = 0; i < surface_count; i++)
@@ -1121,8 +1118,8 @@ bool resource_attach_surfaces_to_context(
 }
 
 
-static bool is_timing_changed(const struct core_stream *cur_stream,
-		const struct core_stream *new_stream)
+static bool is_timing_changed(struct dc_stream *cur_stream,
+		struct dc_stream *new_stream)
 {
 	if (cur_stream == NULL)
 		return true;
@@ -1134,18 +1131,17 @@ static bool is_timing_changed(const struct core_stream *cur_stream,
 		return true;
 
 	/* If output color space is changed, need to reprogram info frames */
-	if (cur_stream->public.output_color_space !=
-			new_stream->public.output_color_space)
+	if (cur_stream->output_color_space != new_stream->output_color_space)
 		return true;
 
 	return memcmp(
-		&cur_stream->public.timing,
-		&new_stream->public.timing,
+		&cur_stream->timing,
+		&new_stream->timing,
 		sizeof(struct dc_crtc_timing)) != 0;
 }
 
 static bool are_stream_backends_same(
-	const struct core_stream *stream_a, const struct core_stream *stream_b)
+	struct dc_stream *stream_a, struct dc_stream *stream_b)
 {
 	if (stream_a == stream_b)
 		return true;
@@ -1160,7 +1156,7 @@ static bool are_stream_backends_same(
 }
 
 bool is_stream_unchanged(
-	const struct core_stream *old_stream, const struct core_stream *stream)
+	struct dc_stream *old_stream, struct dc_stream *stream)
 {
 
 	if (!are_stream_backends_same(old_stream, stream))
@@ -1186,7 +1182,7 @@ bool resource_validate_attach_surfaces(
 				if (!resource_attach_surfaces_to_context(
 						old_context->stream_status[j].surfaces,
 						old_context->stream_status[j].surface_count,
-						&context->streams[i]->public,
+						context->streams[i],
 						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
@@ -1195,7 +1191,7 @@ bool resource_validate_attach_surfaces(
 			if (!resource_attach_surfaces_to_context(
 					set[i].surfaces,
 					set[i].surface_count,
-					&context->streams[i]->public,
+					context->streams[i],
 					context, pool))
 				return false;
 
@@ -1237,7 +1233,7 @@ static void set_audio_in_use(
 static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 
@@ -1267,7 +1263,7 @@ static int acquire_first_free_pipe(
 static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 	int j = -1;
@@ -1318,22 +1314,22 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-static void update_stream_signal(struct core_stream *stream)
+static void update_stream_signal(struct dc_stream *stream)
 {
-	if (stream->public.output_signal == SIGNAL_TYPE_NONE) {
-		struct dc_sink *dc_sink = stream->public.sink;
+	if (stream->output_signal == SIGNAL_TYPE_NONE) {
+		struct dc_sink *dc_sink = stream->sink;
 
 		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
 			stream->signal = stream->sink->link->connector_signal;
 		else
 			stream->signal = dc_sink->sink_signal;
 	} else {
-		stream->signal = stream->public.output_signal;
+		stream->signal = stream->output_signal;
 	}
 
 	if (dc_is_dvi_signal(stream->signal)) {
-		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
-			stream->public.sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
@@ -1341,12 +1337,12 @@ static void update_stream_signal(struct core_stream *stream)
 }
 
 bool resource_is_stream_unchanged(
-	const struct validate_context *old_context, const struct core_stream *stream)
+	struct validate_context *old_context, struct dc_stream *stream)
 {
 	int i;
 
 	for (i = 0; i < old_context->stream_count; i++) {
-		const struct core_stream *old_stream = old_context->streams[i];
+		struct dc_stream *old_stream = old_context->streams[i];
 
 		if (are_stream_backends_same(old_stream, stream))
 				return true;
@@ -1359,7 +1355,7 @@ static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
 	struct dc_surface *surface = to_pipe_ctx->surface;
-	struct core_stream *stream = to_pipe_ctx->stream;
+	struct dc_stream *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
 	to_pipe_ctx->stream = stream;
@@ -1367,14 +1363,14 @@ static void copy_pipe_ctx(
 		to_pipe_ctx->surface = surface;
 }
 
-static struct core_stream *find_pll_sharable_stream(
-		const struct core_stream *stream_needs_pll,
+static struct dc_stream *find_pll_sharable_stream(
+		struct dc_stream *stream_needs_pll,
 		struct validate_context *context)
 {
 	int i;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream_has_pll = context->streams[i];
+		struct dc_stream *stream_has_pll = context->streams[i];
 
 		/* We are looking for non dp, non virtual stream */
 		if (resource_are_streams_timing_synchronizable(
@@ -1418,17 +1414,17 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-static void calculate_phy_pix_clks(struct core_stream *stream)
+static void calculate_phy_pix_clks(struct dc_stream *stream)
 {
 	update_stream_signal(stream);
 
 	/* update actual pixel clock on all streams */
 	if (dc_is_hdmi_signal(stream->signal))
 		stream->phy_pix_clk = get_norm_pix_clk(
-			&stream->public.timing);
+			&stream->timing);
 	else
 		stream->phy_pix_clk =
-			stream->public.timing.pix_clk_khz;
+			stream->timing.pix_clk_khz;
 }
 
 enum dc_status resource_map_pool_resources(
@@ -1440,7 +1436,7 @@ enum dc_status resource_map_pool_resources(
 	int i, j;
 
 	for (i = 0; old_context && i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (!resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
@@ -1493,7 +1489,7 @@ enum dc_status resource_map_pool_resources(
 	}
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 		struct pipe_ctx *pipe_ctx = NULL;
 		int pipe_idx = -1;
 
@@ -1524,7 +1520,7 @@ enum dc_status resource_map_pool_resources(
 		/* TODO: Add check if ASIC support and EDID audio */
 		if (!stream->sink->converter_disable_audio &&
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
-			stream->public.audio_info.mode_count) {
+			stream->audio_info.mode_count) {
 			pipe_ctx->audio = find_first_free_audio(
 				&context->res_ctx, pool);
 
@@ -1560,7 +1556,7 @@ void validate_guaranteed_copy_streams(
 		context->res_ctx.pipe_ctx[i].stream =
 				context->res_ctx.pipe_ctx[0].stream;
 
-		dc_stream_retain(&context->streams[i]->public);
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 }
@@ -1588,7 +1584,7 @@ static void set_avi_info_frame(
 		struct encoder_info_packet *info_packet,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
 	struct info_frame info_frame = { {0} };
 	uint32_t pixel_encoding = 0;
@@ -1602,12 +1598,12 @@ static void set_avi_info_frame(
 	uint8_t byte_index = 0;
 	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
 	union display_content_support support = {0};
-	unsigned int vic = pipe_ctx->stream->public.timing.vic;
+	unsigned int vic = pipe_ctx->stream->timing.vic;
 	enum dc_timing_3d_format format;
 
-	color_space = pipe_ctx->stream->public.output_color_space;
+	color_space = pipe_ctx->stream->output_color_space;
 	if (color_space == COLOR_SPACE_UNKNOWN)
-		color_space = (stream->public.timing.pixel_encoding == PIXEL_ENCODING_RGB)?
+		color_space = (stream->timing.pixel_encoding == PIXEL_ENCODING_RGB) ?
 			COLOR_SPACE_SRGB:COLOR_SPACE_YCBCR709;
 
 	/* Initialize header */
@@ -1622,7 +1618,7 @@ static void set_avi_info_frame(
 	 * according to HDMI 2.0 spec (Section 10.1)
 	 */
 
-	switch (stream->public.timing.pixel_encoding) {
+	switch (stream->timing.pixel_encoding) {
 	case PIXEL_ENCODING_YCBCR422:
 		pixel_encoding = 1;
 		break;
@@ -1664,7 +1660,7 @@ static void set_avi_info_frame(
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)
 		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU601;
 	else {
-		if (stream->public.timing.pixel_encoding != PIXEL_ENCODING_RGB)
+		if (stream->timing.pixel_encoding != PIXEL_ENCODING_RGB)
 			BREAK_TO_DEBUGGER();
 		hdmi_info->bits.C0_C1 = COLORIMETRY_NO_DATA;
 	}
@@ -1679,7 +1675,7 @@ static void set_avi_info_frame(
 	}
 
 	/* TODO: un-hardcode aspect ratio */
-	aspect = stream->public.timing.aspect_ratio;
+	aspect = stream->timing.aspect_ratio;
 
 	switch (aspect) {
 	case ASPECT_RATIO_4_3:
@@ -1705,7 +1701,7 @@ static void set_avi_info_frame(
 	itc = true;
 	itc_value = 1;
 
-	support = stream->public.sink->edid_caps.content_support;
+	support = stream->sink->edid_caps.content_support;
 
 	if (itc) {
 		if (!support.bits.valid_content_type) {
@@ -1744,8 +1740,8 @@ static void set_avi_info_frame(
 
 	/* TODO : We should handle YCC quantization */
 	/* but we do not have matrix calculation */
-	if (stream->public.sink->edid_caps.qs_bit == 1 &&
-			stream->public.sink->edid_caps.qy_bit == 1) {
+	if (stream->sink->edid_caps.qs_bit == 1 &&
+			stream->sink->edid_caps.qy_bit == 1) {
 		if (color_space == COLOR_SPACE_SRGB ||
 			color_space == COLOR_SPACE_2020_RGB_FULLRANGE) {
 			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
@@ -1764,11 +1760,11 @@ static void set_avi_info_frame(
 	}
 
 	///VIC
-	format = stream->public.timing.timing_3d_format;
+	format = stream->timing.timing_3d_format;
 	/*todo, add 3DStereo support*/
 	if (format != TIMING_3D_FORMAT_NONE) {
 		// Based on HDMI specs hdmi vic needs to be converted to cea vic when 3D is enabled
-		switch (pipe_ctx->stream->public.timing.hdmi_vic) {
+		switch (pipe_ctx->stream->timing.hdmi_vic) {
 		case 1:
 			vic = 95;
 			break;
@@ -1797,12 +1793,12 @@ static void set_avi_info_frame(
 	 * barBottom: Line Number of Start of Bottom Bar.
 	 * barLeft:   Pixel Number of End of Left Bar.
 	 * barRight:  Pixel Number of Start of Right Bar. */
-	hdmi_info->bits.bar_top = stream->public.timing.v_border_top;
-	hdmi_info->bits.bar_bottom = (stream->public.timing.v_total
-			- stream->public.timing.v_border_bottom + 1);
-	hdmi_info->bits.bar_left  = stream->public.timing.h_border_left;
-	hdmi_info->bits.bar_right = (stream->public.timing.h_total
-			- stream->public.timing.h_border_right + 1);
+	hdmi_info->bits.bar_top = stream->timing.v_border_top;
+	hdmi_info->bits.bar_bottom = (stream->timing.v_total
+			- stream->timing.v_border_bottom + 1);
+	hdmi_info->bits.bar_left  = stream->timing.h_border_left;
+	hdmi_info->bits.bar_right = (stream->timing.h_total
+			- stream->timing.h_border_right + 1);
 
 	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
 	check_sum = &info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
@@ -1830,7 +1826,7 @@ static void set_avi_info_frame(
 
 static void set_vendor_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	uint32_t length = 0;
 	bool hdmi_vic_mode = false;
@@ -1842,16 +1838,16 @@ static void set_vendor_info_packet(
 
 	info_packet->valid = false;
 
-	format = stream->public.timing.timing_3d_format;
-	if (stream->public.view_format == VIEW_3D_FORMAT_NONE)
+	format = stream->timing.timing_3d_format;
+	if (stream->view_format == VIEW_3D_FORMAT_NONE)
 		format = TIMING_3D_FORMAT_NONE;
 
 	/* Can be different depending on packet content */
 	length = 5;
 
-	if (stream->public.timing.hdmi_vic != 0
-			&& stream->public.timing.h_total >= 3840
-			&& stream->public.timing.v_total >= 2160)
+	if (stream->timing.hdmi_vic != 0
+			&& stream->timing.h_total >= 3840
+			&& stream->timing.v_total >= 2160)
 		hdmi_vic_mode = true;
 
 	/* According to HDMI 1.4a CTS, VSIF should be sent
@@ -1918,7 +1914,7 @@ static void set_vendor_info_packet(
 	/*PB5: If PB4 is set to 0x1 (extended resolution format)
 	 * fill PB5 with the correct HDMI VIC code */
 	if (hdmi_vic_mode)
-		info_packet->sb[5] = stream->public.timing.hdmi_vic;
+		info_packet->sb[5] = stream->timing.hdmi_vic;
 
 	/* Header */
 	info_packet->hb0 = HDMI_INFOFRAME_TYPE_VENDOR; /* VSIF packet type. */
@@ -1943,7 +1939,7 @@ static void set_vendor_info_packet(
 
 static void set_spd_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	/* SPD info packet for FreeSync */
 
@@ -1953,7 +1949,7 @@ static void set_spd_info_packet(
 	/* Check if Freesync is supported. Return if false. If true,
 	 * set the corresponding bit in the info packet
 	 */
-	if (stream->public.freesync_ctx.supported == false)
+	if (stream->freesync_ctx.supported == false)
 		return;
 
 	if (dc_is_hdmi_signal(stream->signal)) {
@@ -2018,20 +2014,20 @@ static void set_spd_info_packet(
 	/* PB6 = [Bits 7:3 = Reserved] */
 	info_packet->sb[6] = 0x00;
 
-	if (stream->public.freesync_ctx.supported == true)
+	if (stream->freesync_ctx.supported == true)
 		/* PB6 = [Bit 0 = FreeSync Supported] */
 		info_packet->sb[6] |= 0x01;
 
-	if (stream->public.freesync_ctx.enabled == true)
+	if (stream->freesync_ctx.enabled == true)
 		/* PB6 = [Bit 1 = FreeSync Enabled] */
 		info_packet->sb[6] |= 0x02;
 
-	if (stream->public.freesync_ctx.active == true)
+	if (stream->freesync_ctx.active == true)
 		/* PB6 = [Bit 2 = FreeSync Active] */
 		info_packet->sb[6] |= 0x04;
 
 	/* PB7 = FreeSync Minimum refresh rate (Hz) */
-	info_packet->sb[7] = (unsigned char) (stream->public.freesync_ctx.
+	info_packet->sb[7] = (unsigned char) (stream->freesync_ctx.
 			min_refresh_in_micro_hz / 1000000);
 
 	/* PB8 = FreeSync Maximum refresh rate (Hz)
@@ -2040,7 +2036,7 @@ static void set_spd_info_packet(
 	 * of the panel, because we should never go above the field
 	 * rate of the mode timing set.
 	 */
-	info_packet->sb[8] = (unsigned char) (stream->public.freesync_ctx.
+	info_packet->sb[8] = (unsigned char) (stream->freesync_ctx.
 			nominal_refresh_in_micro_hz / 1000000);
 
 	/* PB9 - PB27  = Reserved */
@@ -2065,7 +2061,7 @@ static void set_spd_info_packet(
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
 		struct dc_surface *surface,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
@@ -2168,7 +2164,7 @@ static void set_hdr_static_info_packet(
 
 static void set_vsc_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
@@ -2218,7 +2214,7 @@ void dc_resource_validate_ctx_destruct(struct validate_context *context)
 				context->stream_status[i].surfaces[j]);
 
 		context->stream_status[i].surface_count = 0;
-		dc_stream_release(&context->streams[i]->public);
+		dc_stream_release(context->streams[i]);
 		context->streams[i] = NULL;
 	}
 }
@@ -2248,7 +2244,7 @@ void dc_resource_validate_ctx_copy_construct(
 	}
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {
-		dc_stream_retain(&dst_ctx->streams[i]->public);
+		dc_stream_retain(dst_ctx->streams[i]);
 		for (j = 0; j < dst_ctx->stream_status[i].surface_count; j++)
 			dc_surface_retain(
 				dst_ctx->stream_status[i].surfaces[j]);
@@ -2321,7 +2317,7 @@ enum dc_status resource_map_clock_resources(
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
-		const struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -2401,12 +2397,12 @@ bool pipe_need_reprogram(
 	return false;
 }
 
-void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
+void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth)
 {
-	enum dc_dither_option option = stream->public.dither_option;
+	enum dc_dither_option option = stream->dither_option;
 	enum dc_pixel_encoding pixel_encoding =
-			stream->public.timing.pixel_encoding;
+			stream->timing.pixel_encoding;
 
 	memset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));
 
@@ -2511,31 +2507,30 @@ void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(const struct dc *dc, const struct dc_stream *stream)
+bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_context *dc_ctx = core_dc->ctx;
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
-	struct dc_link *link = core_stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
 
-	calculate_phy_pix_clks(core_stream);
+	calculate_phy_pix_clks(stream);
 
-	if (!tg->funcs->validate_timing(tg, &core_stream->public.timing))
+	if (!tg->funcs->validate_timing(tg, &stream->timing))
 		res = DC_FAIL_CONTROLLER_VALIDATE;
 
 	if (res == DC_OK)
 		if (!link->link_enc->funcs->validate_output_with_stream(
-						link->link_enc, core_stream))
+						link->link_enc, stream))
 			res = DC_FAIL_ENC_VALIDATE;
 
 	/* TODO: validate audio ASIC caps, encoder */
 
 	if (res == DC_OK)
-		res = dc_link_validate_mode_timing(core_stream,
+		res = dc_link_validate_mode_timing(stream,
 		      link,
-		      &core_stream->public.timing);
+		      &stream->timing);
 
 	if (res != DC_OK)
 		DC_ERROR("Failed validation for stream %p, err:%d, !\n",
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 5b356dd..46ad1bc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -35,24 +35,24 @@
  ******************************************************************************/
 
 struct stream {
-	struct core_stream protected;
+	struct dc_stream protected;
 	int ref_count;
 };
 
-#define DC_STREAM_TO_STREAM(dc_stream) container_of(dc_stream, struct stream, protected.public)
+#define DC_STREAM_TO_STREAM(dc_stream) container_of(dc_stream, struct stream, protected)
 
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
 
-static bool construct(struct core_stream *stream,
+static bool construct(struct dc_stream *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
 
 	stream->sink = dc_sink_data;
 	stream->ctx = stream->sink->ctx;
-	stream->public.sink = dc_sink_data;
+	stream->sink = dc_sink_data;
 
 	dc_sink_retain(dc_sink_data);
 
@@ -60,52 +60,52 @@ static bool construct(struct core_stream *stream,
 	/* TODO - Remove this translation */
 	for (i = 0; i < (dc_sink_data->edid_caps.audio_mode_count); i++)
 	{
-		stream->public.audio_info.modes[i].channel_count = dc_sink_data->edid_caps.audio_modes[i].channel_count;
-		stream->public.audio_info.modes[i].format_code = dc_sink_data->edid_caps.audio_modes[i].format_code;
-		stream->public.audio_info.modes[i].sample_rates.all = dc_sink_data->edid_caps.audio_modes[i].sample_rate;
-		stream->public.audio_info.modes[i].sample_size = dc_sink_data->edid_caps.audio_modes[i].sample_size;
+		stream->audio_info.modes[i].channel_count = dc_sink_data->edid_caps.audio_modes[i].channel_count;
+		stream->audio_info.modes[i].format_code = dc_sink_data->edid_caps.audio_modes[i].format_code;
+		stream->audio_info.modes[i].sample_rates.all = dc_sink_data->edid_caps.audio_modes[i].sample_rate;
+		stream->audio_info.modes[i].sample_size = dc_sink_data->edid_caps.audio_modes[i].sample_size;
 	}
-	stream->public.audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;
-	stream->public.audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;
-	stream->public.audio_info.video_latency = dc_sink_data->edid_caps.video_latency;
+	stream->audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;
+	stream->audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;
+	stream->audio_info.video_latency = dc_sink_data->edid_caps.video_latency;
 	memmove(
-		stream->public.audio_info.display_name,
+		stream->audio_info.display_name,
 		dc_sink_data->edid_caps.display_name,
 		AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);
-	stream->public.audio_info.manufacture_id = dc_sink_data->edid_caps.manufacturer_id;
-	stream->public.audio_info.product_id = dc_sink_data->edid_caps.product_id;
-	stream->public.audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;
+	stream->audio_info.manufacture_id = dc_sink_data->edid_caps.manufacturer_id;
+	stream->audio_info.product_id = dc_sink_data->edid_caps.product_id;
+	stream->audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;
 
 	if (dc_sink_data->dc_container_id != NULL) {
 		struct dc_container_id *dc_container_id = dc_sink_data->dc_container_id;
 
-		stream->public.audio_info.port_id[0] = dc_container_id->portId[0];
-		stream->public.audio_info.port_id[1] = dc_container_id->portId[1];
+		stream->audio_info.port_id[0] = dc_container_id->portId[0];
+		stream->audio_info.port_id[1] = dc_container_id->portId[1];
 	} else {
 		/* TODO - WindowDM has implemented,
 		other DMs need Unhardcode port_id */
-		stream->public.audio_info.port_id[0] = 0x5558859e;
-		stream->public.audio_info.port_id[1] = 0xd989449;
+		stream->audio_info.port_id[0] = 0x5558859e;
+		stream->audio_info.port_id[1] = 0xd989449;
 	}
 
 	/* EDID CAP translation for HDMI 2.0 */
-	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
+	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
 	stream->status.link = stream->sink->link;
 	return true;
 }
 
-static void destruct(struct core_stream *stream)
+static void destruct(struct dc_stream *stream)
 {
 	dc_sink_release(stream->sink);
-	if (stream->public.out_transfer_func != NULL) {
+	if (stream->out_transfer_func != NULL) {
 		dc_transfer_func_release(
-				stream->public.out_transfer_func);
-		stream->public.out_transfer_func = NULL;
+				stream->out_transfer_func);
+		stream->out_transfer_func = NULL;
 	}
 }
 
-void dc_stream_retain(const struct dc_stream *dc_stream)
+void dc_stream_retain(struct dc_stream *dc_stream)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(dc_stream);
 
@@ -113,17 +113,16 @@ void dc_stream_retain(const struct dc_stream *dc_stream)
 	stream->ref_count++;
 }
 
-void dc_stream_release(const struct dc_stream *public)
+void dc_stream_release(struct dc_stream *public)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(public);
-	struct core_stream *protected = DC_STREAM_TO_CORE(public);
 
 	if (public != NULL) {
 		ASSERT(stream->ref_count > 0);
 		stream->ref_count--;
 
 		if (stream->ref_count == 0) {
-			destruct(protected);
+			destruct(public);
 			dm_free(stream);
 		}
 	}
@@ -147,7 +146,7 @@ struct dc_stream *dc_create_stream_for_sink(
 
 	stream->ref_count++;
 
-	return &stream->protected.public;
+	return &stream->protected;
 
 construct_fail:
 	dm_free(stream);
@@ -157,10 +156,9 @@ struct dc_stream *dc_create_stream_for_sink(
 }
 
 struct dc_stream_status *dc_stream_get_status(
-	const struct dc_stream *dc_stream)
+	struct dc_stream *stream)
 {
 	uint8_t i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
@@ -176,15 +174,14 @@ struct dc_stream_status *dc_stream_get_status(
  * Update the cursor attributes and set cursor surface address
  */
 bool dc_stream_set_cursor_attributes(
-	const struct dc_stream *dc_stream,
+	const struct dc_stream *stream,
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
-	struct core_stream *stream;
 	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
-	if (NULL == dc_stream) {
+	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
 			return false;
 	}
@@ -193,7 +190,6 @@ bool dc_stream_set_cursor_attributes(
 			return false;
 	}
 
-	stream = DC_STREAM_TO_CORE(dc_stream);
 	core_dc = DC_TO_CORE(stream->ctx->dc);
 	res_ctx = &core_dc->current_context->res_ctx;
 
@@ -213,15 +209,14 @@ bool dc_stream_set_cursor_attributes(
 }
 
 bool dc_stream_set_cursor_position(
-	const struct dc_stream *dc_stream,
+	struct dc_stream *stream,
 	const struct dc_cursor_position *position)
 {
 	int i;
-	struct core_stream *stream;
 	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
-	if (NULL == dc_stream) {
+	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
 		return false;
 	}
@@ -231,7 +226,6 @@ bool dc_stream_set_cursor_position(
 		return false;
 	}
 
-	stream = DC_STREAM_TO_CORE(dc_stream);
 	core_dc = DC_TO_CORE(stream->ctx->dc);
 	res_ctx = &core_dc->current_context->res_ctx;
 
@@ -240,7 +234,7 @@ bool dc_stream_set_cursor_position(
 		struct input_pixel_processor *ipp = pipe_ctx->ipp;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
-			.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
+			.pixel_clk_khz = stream->timing.pix_clk_khz,
 			.ref_clk_khz = core_dc->res_pool->ref_clock_inKhz,
 			.viewport_x_start = pipe_ctx->scl_data.viewport.x,
 			.viewport_width = pipe_ctx->scl_data.viewport.width,
@@ -264,10 +258,9 @@ bool dc_stream_set_cursor_position(
 	return true;
 }
 
-uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)
+uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream)
 {
 	uint8_t i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
 		&core_dc->current_context->res_ctx;
@@ -284,7 +277,7 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)
 	return 0;
 }
 
-bool dc_stream_get_scanoutpos(const struct dc_stream *dc_stream,
+bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
 				  uint32_t *v_blank_start,
 				  uint32_t *v_blank_end,
 				  uint32_t *h_position,
@@ -292,7 +285,6 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *dc_stream,
 {
 	uint8_t i;
 	bool ret = false;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
 		&core_dc->current_context->res_ctx;
@@ -322,37 +314,35 @@ void dc_stream_log(
 	struct dal_logger *dm_logger,
 	enum dc_log_type log_type)
 {
-	const struct core_stream *core_stream =
-		DC_STREAM_TO_CORE(stream);
 
 	dm_logger_write(dm_logger,
 			log_type,
 			"core_stream 0x%x: src: %d, %d, %d, %d; dst: %d, %d, %d, %d, colorSpace:%d\n",
-			core_stream,
-			core_stream->public.src.x,
-			core_stream->public.src.y,
-			core_stream->public.src.width,
-			core_stream->public.src.height,
-			core_stream->public.dst.x,
-			core_stream->public.dst.y,
-			core_stream->public.dst.width,
-			core_stream->public.dst.height,
-			core_stream->public.output_color_space);
+			stream,
+			stream->src.x,
+			stream->src.y,
+			stream->src.width,
+			stream->src.height,
+			stream->dst.x,
+			stream->dst.y,
+			stream->dst.width,
+			stream->dst.height,
+			stream->output_color_space);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tpix_clk_khz: %d, h_total: %d, v_total: %d, pixelencoder:%d, displaycolorDepth:%d\n",
-			core_stream->public.timing.pix_clk_khz,
-			core_stream->public.timing.h_total,
-			core_stream->public.timing.v_total,
-			core_stream->public.timing.pixel_encoding,
-			core_stream->public.timing.display_color_depth);
+			stream->timing.pix_clk_khz,
+			stream->timing.h_total,
+			stream->timing.v_total,
+			stream->timing.pixel_encoding,
+			stream->timing.display_color_depth);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tsink name: %s, serial: %d\n",
-			core_stream->sink->edid_caps.display_name,
-			core_stream->sink->edid_caps.serial_number);
+			stream->sink->edid_caps.display_name,
+			stream->sink->edid_caps.serial_number);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tlink: %d\n",
-			core_stream->sink->link->link_index);
+			stream->sink->link->link_index);
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index d26c966..bd4a45e 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -32,6 +32,7 @@
 #include "gpio_types.h"
 #include "link_service_types.h"
 #include "grph_object_ctrl_defs.h"
+#include <inc/hw/opp.h>
 
 #define MAX_SURFACES 3
 #define MAX_STREAMS 6
@@ -106,12 +107,12 @@ struct dc_cap_funcs {
 
 struct dc_stream_funcs {
 	bool (*adjust_vmin_vmax)(struct dc *dc,
-			const struct dc_stream **stream,
+			struct dc_stream **stream,
 			int num_streams,
 			int vmin,
 			int vmax);
 	bool (*get_crtc_position)(struct dc *dc,
-			const struct dc_stream **stream,
+			struct dc_stream **stream,
 			int num_streams,
 			unsigned int *v_pos,
 			unsigned int *nom_v_pos);
@@ -120,14 +121,14 @@ struct dc_stream_funcs {
 			const struct dc_stream *stream);
 
 	bool (*program_csc_matrix)(struct dc *dc,
-			const struct dc_stream *stream);
+			struct dc_stream *stream);
 
 	void (*set_static_screen_events)(struct dc *dc,
-			const struct dc_stream **stream,
+			struct dc_stream **stream,
 			int num_streams,
 			const struct dc_static_screen_events *events);
 
-	void (*set_dither_option)(const struct dc_stream *stream,
+	void (*set_dither_option)(struct dc_stream *stream,
 			enum dc_dither_option option);
 };
 
@@ -440,7 +441,7 @@ bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
 		struct dc_surface **dc_surfaces,
 		uint8_t surface_count,
-		const struct dc_stream *stream);
+		struct dc_stream *stream);
 
 bool dc_post_update_surfaces_to_stream(
 		struct dc *dc);
@@ -480,6 +481,18 @@ enum surface_update_type {
 /*******************************************************************************
  * Stream Interfaces
  ******************************************************************************/
+
+struct dc_stream_status {
+	int primary_otg_inst;
+	int surface_count;
+	struct dc_surface *surfaces[MAX_SURFACE_NUM];
+
+	/*
+	 * link this stream passes through
+	 */
+	struct dc_link *link;
+};
+
 struct dc_stream {
 	struct dc_sink *sink;
 	struct dc_crtc_timing timing;
@@ -507,6 +520,21 @@ struct dc_stream {
 	/* TODO: ABM info (DMCU) */
 	/* TODO: PSR info */
 	/* TODO: CEA VIC */
+
+	/* from core_stream struct */
+	struct dc_context *ctx;
+
+	/* used by DCP and FMT */
+	struct bit_depth_reduction_params bit_depth_params;
+	struct clamping_and_pixel_encoding_params clamping;
+
+	int phy_pix_clk;
+	enum signal_type signal;
+
+	struct dc_stream_status status;
+
+	/* from stream struct */
+	int ref_count;
 };
 
 struct dc_stream_update {
@@ -533,7 +561,7 @@ struct dc_stream_update {
 
 void dc_update_surfaces_and_stream(struct dc *dc,
 		struct dc_surface_update *surface_updates, int surface_count,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct dc_stream_update *stream_update);
 
 /*
@@ -566,12 +594,12 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
  * Structure to store surface/stream associations for validation
  */
 struct dc_validation_set {
-	const struct dc_stream *stream;
+	struct dc_stream *stream;
 	struct dc_surface *surfaces[MAX_SURFACES];
 	uint8_t surface_count;
 };
 
-bool dc_validate_stream(const struct dc *dc, const struct dc_stream *stream);
+bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream);
 
 /*
  * This function takes a set of resources and checks that they are cofunctional.
@@ -599,7 +627,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		const struct dc_stream *stream);
+		struct dc_stream *stream);
 
 void dc_resource_validate_ctx_copy_construct(
 		const struct validate_context *src_ctx,
@@ -628,7 +656,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context);
  */
 bool dc_commit_streams(
 		struct dc *dc,
-		const struct dc_stream *streams[],
+		struct dc_stream *streams[],
 		uint8_t stream_count);
 /*
  * Enable stereo when commit_streams is not required,
@@ -637,7 +665,7 @@ bool dc_commit_streams(
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
-	const struct dc_stream *streams[],
+	struct dc_stream *streams[],
 	uint8_t stream_count);
 
 /**
@@ -645,22 +673,11 @@ bool dc_enable_stereo(
  */
 struct dc_stream *dc_create_stream_for_sink(struct dc_sink *dc_sink);
 
-void dc_stream_retain(const struct dc_stream *dc_stream);
-void dc_stream_release(const struct dc_stream *dc_stream);
-
-struct dc_stream_status {
-	int primary_otg_inst;
-	int surface_count;
-	struct dc_surface *surfaces[MAX_SURFACE_NUM];
-
-	/*
-	 * link this stream passes through
-	 */
-	struct dc_link *link;
-};
+void dc_stream_retain(struct dc_stream *dc_stream);
+void dc_stream_release(struct dc_stream *dc_stream);
 
 struct dc_stream_status *dc_stream_get_status(
-	const struct dc_stream *dc_stream);
+	struct dc_stream *dc_stream);
 
 enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc *dc,
@@ -927,7 +944,7 @@ bool dc_stream_set_cursor_attributes(
 	const struct dc_cursor_attributes *attributes);
 
 bool dc_stream_set_cursor_position(
-	const struct dc_stream *stream,
+	struct dc_stream *stream,
 	const struct dc_cursor_position *position);
 
 /* Newer interfaces  */
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
index aff0a44..24d0c48 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
@@ -1009,7 +1009,7 @@ bool dce110_link_encoder_construct(
 
 bool dce110_link_encoder_validate_output_with_stream(
 	struct link_encoder *enc,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
 	bool is_valid;
@@ -1021,22 +1021,22 @@ bool dce110_link_encoder_validate_output_with_stream(
 			enc110,
 			stream->sink->link->connector_signal,
 			stream->signal,
-			&stream->public.timing);
+			&stream->timing);
 	break;
 	case SIGNAL_TYPE_HDMI_TYPE_A:
 		is_valid = dce110_link_encoder_validate_hdmi_output(
 				enc110,
-				&stream->public.timing,
+				&stream->timing,
 				stream->phy_pix_clk);
 	break;
 	case SIGNAL_TYPE_DISPLAY_PORT:
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
 		is_valid = dce110_link_encoder_validate_dp_output(
-					enc110, &stream->public.timing);
+					enc110, &stream->timing);
 	break;
 	case SIGNAL_TYPE_EDP:
 		is_valid =
-			(stream->public.timing.
+			(stream->timing.
 				pixel_encoding == PIXEL_ENCODING_RGB) ? true : false;
 	break;
 	case SIGNAL_TYPE_VIRTUAL:
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h
index ded6c61..a47b075 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.h
@@ -199,7 +199,7 @@ bool dce110_link_encoder_validate_wireless_output(
 
 bool dce110_link_encoder_validate_output_with_stream(
 	struct link_encoder *enc,
-	const struct core_stream *stream);
+	const struct dc_stream *stream);
 
 /****************** HW programming ************************/
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index 3d25a90..cf98f247 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -660,7 +660,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -734,8 +734,8 @@ enum dc_status dce100_validate_with_context(
 		return DC_FAIL_SURFACE_VALIDATE;
 
 	for (i = 0; i < set_count; i++) {
-		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
-		dc_stream_retain(&context->streams[i]->public);
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 
@@ -765,13 +765,13 @@ enum dc_status dce100_validate_with_context(
 
 enum dc_status dce100_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
-	dc_stream_retain(&context->streams[0]->public);
+	context->streams[0] = dc_stream;
+	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context, NULL);
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1193659..15f6eee 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -623,21 +623,21 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
-	if (stream->public.out_transfer_func &&
-		stream->public.out_transfer_func->type ==
+	if (stream->out_transfer_func &&
+		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
-		stream->public.out_transfer_func->tf ==
+		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
 	} else if (dce110_translate_regamma_to_hw_format(
-				stream->public.out_transfer_func, &opp->regamma_params)) {
+				stream->out_transfer_func, &opp->regamma_params)) {
 			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
 			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {
@@ -702,7 +702,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	enum dc_lane_count lane_count =
 		pipe_ctx->stream->sink->link->cur_link_settings.lane_count;
 
-	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* 1. update AVI info frame (HDMI, DP)
@@ -745,7 +745,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 
 	if (pipe_ctx->audio) {
@@ -797,7 +797,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
-		pipe_ctx->stream->public.timing.pix_clk_khz;
+		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
 }
@@ -833,7 +833,7 @@ static void build_audio_output(
 	const struct pipe_ctx *pipe_ctx,
 	struct audio_output *audio_output)
 {
-	const struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	audio_output->engine_id = pipe_ctx->stream_enc->id;
 
 	audio_output->signal = pipe_ctx->stream->signal;
@@ -841,33 +841,33 @@ static void build_audio_output(
 	/* audio_crtc_info  */
 
 	audio_output->crtc_info.h_total =
-		stream->public.timing.h_total;
+		stream->timing.h_total;
 
 	/*
 	 * Audio packets are sent during actual CRTC blank physical signal, we
 	 * need to specify actual active signal portion
 	 */
 	audio_output->crtc_info.h_active =
-			stream->public.timing.h_addressable
-			+ stream->public.timing.h_border_left
-			+ stream->public.timing.h_border_right;
+			stream->timing.h_addressable
+			+ stream->timing.h_border_left
+			+ stream->timing.h_border_right;
 
 	audio_output->crtc_info.v_active =
-			stream->public.timing.v_addressable
-			+ stream->public.timing.v_border_top
-			+ stream->public.timing.v_border_bottom;
+			stream->timing.v_addressable
+			+ stream->timing.v_border_top
+			+ stream->timing.v_border_bottom;
 
 	audio_output->crtc_info.pixel_repetition = 1;
 
 	audio_output->crtc_info.interlaced =
-			stream->public.timing.flags.INTERLACE;
+			stream->timing.flags.INTERLACE;
 
 	audio_output->crtc_info.refresh_rate =
-		(stream->public.timing.pix_clk_khz*1000)/
-		(stream->public.timing.h_total*stream->public.timing.v_total);
+		(stream->timing.pix_clk_khz*1000)/
+		(stream->timing.h_total*stream->timing.v_total);
 
 	audio_output->crtc_info.color_depth =
-		stream->public.timing.display_color_depth;
+		stream->timing.display_color_depth;
 
 	audio_output->crtc_info.requested_pixel_clock =
 			pipe_ctx->pix_clk_params.requested_pix_clk;
@@ -878,7 +878,7 @@ static void build_audio_output(
 /*for HDMI, audio ACR is with deep color ratio factor*/
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal) &&
 		audio_output->crtc_info.requested_pixel_clock ==
-				stream->public.timing.pix_clk_khz) {
+				stream->timing.pix_clk_khz) {
 		if (pipe_ctx->pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
 			audio_output->crtc_info.requested_pixel_clock =
 					audio_output->crtc_info.requested_pixel_clock/2;
@@ -959,7 +959,7 @@ static void program_scaler(const struct core_dc *dc,
 		get_surface_visual_confirm_color(pipe_ctx, &color);
 	else
 		color_space_to_black_color(dc,
-				pipe_ctx->stream->public.output_color_space,
+				pipe_ctx->stream->output_color_space,
 				&color);
 
 	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
@@ -981,7 +981,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
@@ -990,7 +990,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 		/* program blank color */
 		color_space_to_black_color(dc,
-				stream->public.output_color_space, &black_color);
+				stream->output_color_space, &black_color);
 		pipe_ctx->tg->funcs->set_blank_color(
 				pipe_ctx->tg,
 				&black_color);
@@ -1011,7 +1011,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 		pipe_ctx->tg->funcs->program_timing(
 				pipe_ctx->tg,
-				&stream->public.timing,
+				&stream->timing,
 				true);
 
 		pipe_ctx->tg->funcs->set_static_screen_control(
@@ -1037,7 +1037,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
@@ -1047,7 +1047,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	pipe_ctx->opp->funcs->opp_set_dyn_expansion(
 			pipe_ctx->opp,
 			COLOR_SPACE_YCBCR601,
-			stream->public.timing.display_color_depth,
+			stream->timing.display_color_depth,
 			pipe_ctx->stream->signal);
 
 	/* FPGA does not program backend */
@@ -1074,7 +1074,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_enc->funcs->setup_stereo_sync(
 		pipe_ctx->stream_enc,
 		pipe_ctx->tg->inst,
-		stream->public.timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
+		stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
 
 
 /*vbios crtc_source_selection and encoder_setup will override fmt_C*/
@@ -1086,20 +1086,20 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->dp_set_stream_attribute(
 			pipe_ctx->stream_enc,
-			&stream->public.timing,
-			stream->public.output_color_space);
+			&stream->timing,
+			stream->output_color_space);
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->hdmi_set_stream_attribute(
 			pipe_ctx->stream_enc,
-			&stream->public.timing,
+			&stream->timing,
 			stream->phy_pix_clk,
 			pipe_ctx->audio != NULL);
 
 	if (dc_is_dvi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->dvi_set_stream_attribute(
 			pipe_ctx->stream_enc,
-			&stream->public.timing,
+			&stream->timing,
 			(pipe_ctx->stream->signal == SIGNAL_TYPE_DVI_DUAL_LINK) ?
 			true : false);
 
@@ -1129,9 +1129,9 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 #endif
 		pipe_ctx->mi->funcs->allocate_mem_input(
 					pipe_ctx->mi,
-					stream->public.timing.h_total,
-					stream->public.timing.v_total,
-					stream->public.timing.pix_clk_khz,
+					stream->timing.h_total,
+					stream->timing.v_total,
+					stream->timing.pix_clk_khz,
 					context->stream_count);
 
 	pipe_ctx->stream->sink->link->psr_enabled = false;
@@ -1228,7 +1228,7 @@ void dce110_enable_accelerated_mode(struct core_dc *dc)
 
 static uint32_t compute_pstate_blackout_duration(
 	struct bw_fixed blackout_duration,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	uint32_t total_dest_line_time_ns;
 	uint32_t pstate_blackout_duration_ns;
@@ -1236,8 +1236,8 @@ static uint32_t compute_pstate_blackout_duration(
 	pstate_blackout_duration_ns = 1000 * blackout_duration.value >> 24;
 
 	total_dest_line_time_ns = 1000000UL *
-		stream->public.timing.h_total /
-		stream->public.timing.pix_clk_khz +
+		stream->timing.h_total /
+		stream->timing.pix_clk_khz +
 		pstate_blackout_duration_ns;
 
 	return total_dest_line_time_ns;
@@ -1805,19 +1805,19 @@ enum dc_status dce110_apply_ctx_to_hw(
 				pipe_ctx->stream_enc->funcs->dp_audio_setup(
 						pipe_ctx->stream_enc,
 						pipe_ctx->audio->inst,
-						&pipe_ctx->stream->public.audio_info);
+						&pipe_ctx->stream->audio_info);
 			else
 				pipe_ctx->stream_enc->funcs->hdmi_audio_setup(
 						pipe_ctx->stream_enc,
 						pipe_ctx->audio->inst,
-						&pipe_ctx->stream->public.audio_info,
+						&pipe_ctx->stream->audio_info,
 						&audio_output.crtc_info);
 
 			pipe_ctx->audio->funcs->az_configure(
 					pipe_ctx->audio,
 					pipe_ctx->stream->signal,
 					&audio_output.crtc_info,
-					&pipe_ctx->stream->public.audio_info);
+					&pipe_ctx->stream->audio_info);
 		}
 
 		status = apply_single_controller_ctx_to_hw(
@@ -1862,13 +1862,13 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.out_color_space =
-				pipe_ctx->stream->public.output_color_space;
+				pipe_ctx->stream->output_color_space;
 	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
 	default_adjust.surface_pixel_format = pipe_ctx->scl_data.format;
 
 	/* display color depth */
 	default_adjust.color_depth =
-		pipe_ctx->stream->public.timing.display_color_depth;
+		pipe_ctx->stream->timing.display_color_depth;
 
 	/* Lb color depth */
 	default_adjust.lb_color_depth = pipe_ctx->scl_data.lb_params.depth;
@@ -1932,35 +1932,35 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
@@ -1987,48 +1987,48 @@ static void set_plane_config(
 	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
 
 	set_default_colors(pipe_ctx);
-	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
 			== true) {
 		tbl_entry.color_space =
-			pipe_ctx->stream->public.output_color_space;
+			pipe_ctx->stream->output_color_space;
 
 		for (i = 0; i < 12; i++)
 			tbl_entry.regval[i] =
-			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
 		pipe_ctx->opp->funcs->opp_set_csc_adjustment
 				(pipe_ctx->opp, &tbl_entry);
 	}
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
@@ -2260,7 +2260,7 @@ void dce110_fill_display_configs(
 	for (j = 0; j < context->stream_count; j++) {
 		int k;
 
-		const struct core_stream *stream = context->streams[j];
+		const struct dc_stream *stream = context->streams[j];
 		struct dm_pp_single_disp_config *cfg =
 			&pp_display_cfg->disp_configs[num_cfgs];
 		const struct pipe_ctx *pipe_ctx = NULL;
@@ -2276,8 +2276,8 @@ void dce110_fill_display_configs(
 		num_cfgs++;
 		cfg->signal = pipe_ctx->stream->signal;
 		cfg->pipe_idx = pipe_ctx->pipe_idx;
-		cfg->src_height = stream->public.src.height;
-		cfg->src_width = stream->public.src.width;
+		cfg->src_height = stream->src.height;
+		cfg->src_width = stream->src.width;
 		cfg->ddi_channel_mapping =
 			stream->sink->link->ddi_channel_mapping.raw;
 		cfg->transmitter =
@@ -2290,10 +2290,10 @@ void dce110_fill_display_configs(
 			stream->sink->link->cur_link_settings.link_spread;
 		cfg->sym_clock = stream->phy_pix_clk;
 		/* Round v_refresh*/
-		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
-		cfg->v_refresh /= stream->public.timing.h_total;
-		cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
-							/ stream->public.timing.v_total;
+		cfg->v_refresh = stream->timing.pix_clk_khz * 1000;
+		cfg->v_refresh /= stream->timing.h_total;
+		cfg->v_refresh = (cfg->v_refresh + stream->timing.v_total / 2)
+							/ stream->timing.v_total;
 	}
 
 	pp_display_cfg->display_count = num_cfgs;
@@ -2305,7 +2305,7 @@ uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 	uint32_t min_vertical_blank_time = -1;
 
 		for (j = 0; j < context->stream_count; j++) {
-			const struct dc_stream *stream = &context->streams[j]->public;
+			struct dc_stream *stream = context->streams[j];
 			uint32_t vertical_blank_in_pixels = 0;
 			uint32_t vertical_blank_time = 0;
 
@@ -2388,7 +2388,7 @@ static void pplib_apply_display_requirements(
 	/* TODO: is this still applicable?*/
 	if (pp_display_cfg->display_count == 1) {
 		const struct dc_crtc_timing *timing =
-			&context->streams[0]->public.timing;
+			&context->streams[0]->timing;
 
 		pp_display_cfg->crtc_index =
 			pp_display_cfg->disp_configs[0].pipe_idx;
@@ -2441,48 +2441,48 @@ static void dce110_program_front_end_for_pipe(
 	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
 
 	set_default_colors(pipe_ctx);
-	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
 			== true) {
 		tbl_entry.color_space =
-			pipe_ctx->stream->public.output_color_space;
+			pipe_ctx->stream->output_color_space;
 
 		for (i = 0; i < 12; i++)
 			tbl_entry.regval[i] =
-			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
 		pipe_ctx->opp->funcs->opp_set_csc_adjustment
 				(pipe_ctx->opp, &tbl_entry);
 	}
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index c773351..cc25c4b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -718,13 +718,13 @@ static void get_pixel_clock_parameters(
 	const struct pipe_ctx *pipe_ctx,
 	struct pixel_clk_params *pixel_clk_params)
 {
-	const struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 
 	/*TODO: is this halved for YCbCr 420? in that case we might want to move
 	 * the pixel clock normalization for hdmi up to here instead of doing it
 	 * in pll_adjust_pix_clk
 	 */
-	pixel_clk_params->requested_pix_clk = stream->public.timing.pix_clk_khz;
+	pixel_clk_params->requested_pix_clk = stream->timing.pix_clk_khz;
 	pixel_clk_params->encoder_object_id = stream->sink->link->link_enc->id;
 	pixel_clk_params->signal_type = pipe_ctx->stream->signal;
 	pixel_clk_params->controller_id = pipe_ctx->pipe_idx + 1;
@@ -733,15 +733,15 @@ static void get_pixel_clock_parameters(
 						LINK_RATE_REF_FREQ_IN_KHZ;
 	pixel_clk_params->flags.ENABLE_SS = 0;
 	pixel_clk_params->color_depth =
-		stream->public.timing.display_color_depth;
+		stream->timing.display_color_depth;
 	pixel_clk_params->flags.DISPLAY_BLANKED = 1;
-	pixel_clk_params->flags.SUPPORT_YCBCR420 = (stream->public.timing.pixel_encoding ==
+	pixel_clk_params->flags.SUPPORT_YCBCR420 = (stream->timing.pixel_encoding ==
 			PIXEL_ENCODING_YCBCR420);
-	pixel_clk_params->pixel_encoding = stream->public.timing.pixel_encoding;
-	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR422) {
+	pixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422) {
 		pixel_clk_params->color_depth = COLOR_DEPTH_888;
 	}
-	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
 		pixel_clk_params->requested_pix_clk  = pixel_clk_params->requested_pix_clk / 2;
 	}
 }
@@ -755,7 +755,7 @@ enum dc_status dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx)
 		&pipe_ctx->pll_settings);
 	resource_build_bit_depth_reduction_params(pipe_ctx->stream,
 			&pipe_ctx->stream->bit_depth_params);
-	pipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->public.timing.pixel_encoding;
+	pipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;
 
 	return DC_OK;
 }
@@ -780,7 +780,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -837,9 +837,9 @@ bool dce110_validate_bandwidth(
 		dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_VALIDATION,
 			"%s: %dx%d@%d Bandwidth validation failed!\n",
 			__func__,
-			context->streams[0]->public.timing.h_addressable,
-			context->streams[0]->public.timing.v_addressable,
-			context->streams[0]->public.timing.pix_clk_khz);
+			context->streams[0]->timing.h_addressable,
+			context->streams[0]->timing.v_addressable,
+			context->streams[0]->timing.pix_clk_khz);
 
 	if (memcmp(&dc->current_context->bw.dce,
 			&context->bw.dce, sizeof(context->bw.dce))) {
@@ -942,8 +942,8 @@ enum dc_status dce110_validate_with_context(
 		return DC_FAIL_SURFACE_VALIDATE;
 
 	for (i = 0; i < set_count; i++) {
-		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
-		dc_stream_retain(&context->streams[i]->public);
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 
@@ -973,13 +973,13 @@ enum dc_status dce110_validate_with_context(
 
 enum dc_status dce110_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
-	dc_stream_retain(&context->streams[0]->public);
+	context->streams[0] = dc_stream;
+	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context, NULL);
@@ -1006,7 +1006,7 @@ enum dc_status dce110_validate_guaranteed(
 static struct pipe_ctx *dce110_acquire_underlay(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx = &context->res_ctx;
@@ -1041,18 +1041,18 @@ static struct pipe_ctx *dce110_acquire_underlay(
 		 */
 
 		pipe_ctx->tg->funcs->program_timing(pipe_ctx->tg,
-				&stream->public.timing,
+				&stream->timing,
 				false);
 
 		pipe_ctx->tg->funcs->enable_advanced_request(
 				pipe_ctx->tg,
 				true,
-				&stream->public.timing);
+				&stream->timing);
 
 		pipe_ctx->mi->funcs->allocate_mem_input(pipe_ctx->mi,
-				stream->public.timing.h_total,
-				stream->public.timing.v_total,
-				stream->public.timing.pix_clk_khz,
+				stream->timing.h_total,
+				stream->timing.v_total,
+				stream->timing.pix_clk_khz,
 				context->stream_count);
 
 		color_space_to_black_color(dc,
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index 19cd999..9589208 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -698,7 +698,7 @@ static void destruct(struct dce110_resource_pool *pool)
 static struct clock_source *find_matching_pll(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		const struct core_stream *const stream)
+		const struct dc_stream *const stream)
 {
 	switch (stream->sink->link->link_enc->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -729,7 +729,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -843,7 +843,7 @@ enum dc_status resource_map_phy_clock_resources(
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -916,8 +916,8 @@ enum dc_status dce112_validate_with_context(
 		return DC_FAIL_SURFACE_VALIDATE;
 
 	for (i = 0; i < set_count; i++) {
-		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
-		dc_stream_retain(&context->streams[i]->public);
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 
@@ -947,13 +947,13 @@ enum dc_status dce112_validate_with_context(
 
 enum dc_status dce112_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
-	dc_stream_retain(&context->streams[0]->public);
+	context->streams[0] = stream;
+	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context, NULL);
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
index c6c0bba..cb2c69f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
@@ -44,7 +44,7 @@ enum dc_status dce112_validate_with_context(
 
 enum dc_status dce112_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context);
 
 bool dce112_validate_bandwidth(
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 0123006..2fde43c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -676,7 +676,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -750,8 +750,8 @@ enum dc_status dce80_validate_with_context(
 		return DC_FAIL_SURFACE_VALIDATE;
 
 	for (i = 0; i < set_count; i++) {
-		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
-		dc_stream_retain(&context->streams[i]->public);
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 
@@ -780,13 +780,13 @@ enum dc_status dce80_validate_with_context(
 
 enum dc_status dce80_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
-	dc_stream_retain(&context->streams[0]->public);
+	context->streams[0] = dc_stream;
+	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context, NULL);
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e738387..1531b52 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -684,12 +684,12 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
-	bool enableStereo    = stream->public.timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
+	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
 			false:true;
-	bool rightEyePolarity = stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+	bool rightEyePolarity = stream->timing.flags.RIGHT_EYE_3D_POLARITY;
 
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
@@ -722,7 +722,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 
 	pipe_ctx->tg->funcs->program_timing(
 			pipe_ctx->tg,
-			&stream->public.timing,
+			&stream->timing,
 			true);
 
 	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
@@ -742,7 +742,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 				&stream->clamping);
 #endif
 	/* program otg blank color */
-	color_space = stream->public.output_color_space;
+	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
 	pipe_ctx->tg->funcs->set_blank_color(
 			pipe_ctx->tg,
@@ -1053,16 +1053,16 @@ static bool patch_address_for_sbs_tb_stereo(
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
 	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
-		(pipe_ctx->stream->public.timing.timing_3d_format ==
+		(pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
-		 pipe_ctx->stream->public.timing.timing_3d_format ==
+		 pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
 		*addr = surface->address.grph_stereo.left_addr;
 		surface->address.grph_stereo.left_addr =
 		surface->address.grph_stereo.right_addr;
 		return true;
 	} else {
-		if (pipe_ctx->stream->public.view_format != VIEW_3D_FORMAT_NONE &&
+		if (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&
 			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
 			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
 			surface->address.grph_stereo.right_addr =
@@ -1456,7 +1456,7 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	struct transform *xfm = pipe_ctx->xfm;
 
@@ -1465,14 +1465,14 @@ static bool dcn10_set_output_transfer_func(
 
 	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
-	if (stream->public.out_transfer_func &&
-		stream->public.out_transfer_func->type ==
+	if (stream->out_transfer_func &&
+		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
-		stream->public.out_transfer_func->tf ==
+		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
 		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
-				stream->public.out_transfer_func, &xfm->regamma_params)) {
+				stream->out_transfer_func, &xfm->regamma_params)) {
 			xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
 			xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
 	} else {
@@ -1756,35 +1756,35 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
@@ -1798,14 +1798,14 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	int i;
 	struct out_csc_color_matrix tbl_entry;
 
-	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
 				== true) {
 			enum dc_color_space color_space =
-				pipe_ctx->stream->public.output_color_space;
+				pipe_ctx->stream->output_color_space;
 
 			//uint16_t matrix[12];
 			for (i = 0; i < 12; i++)
-				tbl_entry.regval[i] = pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+				tbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
@@ -1967,7 +1967,7 @@ static void update_dchubp_dpp(
 	 * pre-multiplied alpha.
 	 */
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
-			pipe_ctx->stream->public.output_color_space)
+			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
 	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
 
@@ -1975,7 +1975,7 @@ static void update_dchubp_dpp(
 		dcn10_get_surface_visual_confirm_color(pipe_ctx, &black_color);
 	} else {
 		color_space_to_black_color(
-			dc, pipe_ctx->stream->public.output_color_space,
+			dc, pipe_ctx->stream->output_color_space,
 			&black_color);
 	}
 	pipe_ctx->mpcc->funcs->set_bg_color(pipe_ctx->mpcc, &black_color);
@@ -1991,7 +1991,7 @@ static void update_dchubp_dpp(
 	program_gamut_remap(pipe_ctx);
 
 	/*TODO add adjustments parameters*/
-	ocsc.out_color_space = pipe_ctx->stream->public.output_color_space;
+	ocsc.out_color_space = pipe_ctx->stream->output_color_space;
 	pipe_ctx->xfm->funcs->opp_set_csc_default(pipe_ctx->xfm, &ocsc);
 
 	mi->funcs->mem_input_program_surface_config(
@@ -2346,11 +2346,11 @@ static void set_plane_config(
 }
 
 static void dcn10_config_stereo_parameters(
-		struct core_stream *stream, struct crtc_stereo_flags *flags)
+		struct dc_stream *stream, struct crtc_stereo_flags *flags)
 {
-	enum view_3d_format view_format = stream->public.view_format;
+	enum view_3d_format view_format = stream->view_format;
 	enum dc_timing_3d_format timing_3d_format =\
-			stream->public.timing.timing_3d_format;
+			stream->timing.timing_3d_format;
 	bool non_stereo_timing = false;
 
 	if (timing_3d_format == TIMING_3D_FORMAT_NONE ||
@@ -2374,7 +2374,7 @@ static void dcn10_config_stereo_parameters(
 				flags->DISABLE_STEREO_DP_SYNC = 1;
 		}
 		flags->RIGHT_EYE_POLARITY =\
-				stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+				stream->timing.flags.RIGHT_EYE_3D_POLARITY;
 		if (timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)
 			flags->FRAME_PACKED = 1;
 	}
@@ -2385,18 +2385,18 @@ static void dcn10_config_stereo_parameters(
 static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 
 	dcn10_config_stereo_parameters(stream, &flags);
 
 	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
 		pipe_ctx->opp,
 		flags.PROGRAM_STEREO == 1 ? true:false,
-		stream->public.timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
+		stream->timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
 
 	pipe_ctx->tg->funcs->program_stereo(
 		pipe_ctx->tg,
-		&stream->public.timing,
+		&stream->timing,
 		&flags);
 
 	return;
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index b901ef9..33beb0b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -787,8 +787,8 @@ static void get_pixel_clock_parameters(
 	const struct pipe_ctx *pipe_ctx,
 	struct pixel_clk_params *pixel_clk_params)
 {
-	const struct core_stream *stream = pipe_ctx->stream;
-	pixel_clk_params->requested_pix_clk = stream->public.timing.pix_clk_khz;
+	const struct dc_stream *stream = pipe_ctx->stream;
+	pixel_clk_params->requested_pix_clk = stream->timing.pix_clk_khz;
 	pixel_clk_params->encoder_object_id = stream->sink->link->link_enc->id;
 	pixel_clk_params->signal_type = pipe_ctx->stream->signal;
 	pixel_clk_params->controller_id = pipe_ctx->pipe_idx + 1;
@@ -797,23 +797,23 @@ static void get_pixel_clock_parameters(
 		LINK_RATE_REF_FREQ_IN_KHZ;
 	pixel_clk_params->flags.ENABLE_SS = 0;
 	pixel_clk_params->color_depth =
-		stream->public.timing.display_color_depth;
+		stream->timing.display_color_depth;
 	pixel_clk_params->flags.DISPLAY_BLANKED = 1;
-	pixel_clk_params->pixel_encoding = stream->public.timing.pixel_encoding;
+	pixel_clk_params->pixel_encoding = stream->timing.pixel_encoding;
 
-	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)
 		pixel_clk_params->color_depth = COLOR_DEPTH_888;
 
-	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
 		pixel_clk_params->requested_pix_clk  /= 2;
 
 }
 
-static void build_clamping_params(struct core_stream *stream)
+static void build_clamping_params(struct dc_stream *stream)
 {
 	stream->clamping.clamping_level = CLAMPING_FULL_RANGE;
-	stream->clamping.c_depth = stream->public.timing.display_color_depth;
-	stream->clamping.pixel_encoding = stream->public.timing.pixel_encoding;
+	stream->clamping.c_depth = stream->timing.display_color_depth;
+	stream->clamping.pixel_encoding = stream->timing.pixel_encoding;
 }
 
 static enum dc_status build_pipe_hw_param(struct pipe_ctx *pipe_ctx)
@@ -826,7 +826,7 @@ static enum dc_status build_pipe_hw_param(struct pipe_ctx *pipe_ctx)
 		&pipe_ctx->pix_clk_params,
 		&pipe_ctx->pll_settings);
 
-	pipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->public.timing.pixel_encoding;
+	pipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;
 
 	resource_build_bit_depth_reduction_params(pipe_ctx->stream,
 					&pipe_ctx->stream->bit_depth_params);
@@ -844,7 +844,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
@@ -852,7 +852,7 @@ static enum dc_status build_mapped_resource(
 				resource_build_bit_depth_reduction_params(stream,
 						&stream->bit_depth_params);
 				stream->clamping.pixel_encoding =
-						stream->public.timing.pixel_encoding;
+						stream->timing.pixel_encoding;
 
 				resource_build_bit_depth_reduction_params(stream,
 								&stream->bit_depth_params);
@@ -896,8 +896,8 @@ enum dc_status dcn10_validate_with_context(
 		return result;
 
 	for (i = 0; i < set_count; i++) {
-		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
-		dc_stream_retain(&context->streams[i]->public);
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 
@@ -929,13 +929,13 @@ enum dc_status dcn10_validate_with_context(
 
 enum dc_status dcn10_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
-	dc_stream_retain(&context->streams[0]->public);
+	context->streams[0] = dc_stream;
+	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context, NULL);
@@ -960,7 +960,7 @@ enum dc_status dcn10_validate_guaranteed(
 static struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	struct resource_context *res_ctx = &context->res_ctx;
 	struct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 5a47d4c..2ae5a60 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -36,41 +36,18 @@
 #include "mpc.h"
 #endif
 
-struct core_stream;
-
 #define MAX_CLOCK_SOURCES 7
 
 void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 		uint32_t controller_id);
 
-/********* core_stream ************/
 #include "grph_object_id.h"
 #include "link_encoder.h"
 #include "stream_encoder.h"
 #include "clock_source.h"
 #include "audio.h"
 #include "hw_sequencer_types.h"
-#include "opp.h"
-
-#define DC_STREAM_TO_CORE(dc_stream) container_of( \
-	dc_stream, struct core_stream, public)
-
-struct core_stream {
-	struct dc_stream public;
-
-	/* field internal to DC */
-	struct dc_context *ctx;
-	struct dc_sink *sink;
 
-	/* used by DCP and FMT */
-	struct bit_depth_reduction_params bit_depth_params;
-	struct clamping_and_pixel_encoding_params clamping;
-
-	int phy_pix_clk;
-	enum signal_type signal;
-
-	struct dc_stream_status status;
-};
 
 /************ link *****************/
 struct link_init_data {
@@ -85,7 +62,7 @@ struct dc_link *link_create(const struct link_init_data *init_params);
 void link_destroy(struct dc_link **link);
 
 enum dc_status dc_link_validate_mode_timing(
-		const struct core_stream *stream,
+		const struct dc_stream *stream,
 		struct dc_link *link,
 		const struct dc_crtc_timing *timing);
 
@@ -117,7 +94,7 @@ struct resource_funcs {
 
 	enum dc_status (*validate_guaranteed)(
 					const struct core_dc *dc,
-					const struct dc_stream *stream,
+					struct dc_stream *stream,
 					struct validate_context *context);
 
 	bool (*validate_bandwidth)(
@@ -127,7 +104,7 @@ struct resource_funcs {
 	struct pipe_ctx *(*acquire_idle_pipe_for_layer)(
 			struct validate_context *context,
 			const struct resource_pool *pool,
-			struct core_stream *stream);
+			struct dc_stream *stream);
 };
 
 struct audio_support{
@@ -178,7 +155,7 @@ struct resource_pool {
 
 struct pipe_ctx {
 	struct dc_surface *surface;
-	struct core_stream *stream;
+	struct dc_stream *stream;
 
 	struct mem_input *mi;
 	struct input_pixel_processor *ipp;
@@ -264,7 +241,7 @@ union bw_context {
 };
 
 struct validate_context {
-	struct core_stream *streams[MAX_PIPES];
+	struct dc_stream *streams[MAX_PIPES];
 	struct dc_stream_status stream_status[MAX_PIPES];
 	uint8_t stream_count;
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
index d9af028..5b41850 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dc_link_dp.h
@@ -30,7 +30,7 @@
 #define LINK_TRAINING_RETRY_DELAY 50 /* ms */
 
 struct dc_link;
-struct core_stream;
+struct dc_stream;
 struct dc_link_settings;
 
 bool dp_hbr_verify_link_cap(
@@ -50,7 +50,7 @@ bool dp_validate_mode_timing(
 	const struct dc_crtc_timing *timing);
 
 void decide_link_settings(
-	struct core_stream *stream,
+	struct dc_stream *stream,
 	struct dc_link_settings *link_setting);
 
 bool perform_link_training_with_retries(
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
index 0ee7387..28fb02f 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
@@ -17,7 +17,6 @@ struct encoder_set_dp_phy_pattern_param;
 struct link_mst_stream_allocation_table;
 struct dc_link_settings;
 struct link_training_settings;
-struct core_stream;
 struct pipe_ctx;
 
 struct encoder_init_data {
@@ -94,7 +93,7 @@ struct link_encoder {
 
 struct link_encoder_funcs {
 	bool (*validate_output_with_stream)(
-		struct link_encoder *enc, const struct core_stream *stream);
+		struct link_encoder *enc, const struct dc_stream *stream);
 	void (*hw_init)(struct link_encoder *enc);
 	void (*setup)(struct link_encoder *enc,
 		enum signal_type signal);
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
index a3eec07..b2f7ba2 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
@@ -92,7 +92,7 @@ struct hw_sequencer_funcs {
 
 	bool (*set_output_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
-				const struct core_stream *stream);
+				const struct dc_stream *stream);
 
 	void (*power_down)(struct core_dc *dc);
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index ed94df1..571bfae 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -103,8 +103,8 @@ void resource_reference_clock_source(
 		struct clock_source *clock_source);
 
 bool resource_are_streams_timing_synchronizable(
-		const struct core_stream *stream1,
-		const struct core_stream *stream2);
+		struct dc_stream *stream1,
+		struct dc_stream *stream2);
 
 struct clock_source *resource_find_used_clk_src_for_sharing(
 		struct resource_context *res_ctx,
@@ -116,12 +116,12 @@ struct clock_source *dc_resource_find_first_free_pll(
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
-		const struct core_stream *stream);
+		struct dc_stream *stream);
 
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *const *surfaces,
 		int surface_count,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context,
 		const struct resource_pool *pool);
 
@@ -130,10 +130,10 @@ struct pipe_ctx *find_idle_secondary_pipe(
 		const struct resource_pool *pool);
 
 bool resource_is_stream_unchanged(
-	const struct validate_context *old_context, const struct core_stream *stream);
+	struct validate_context *old_context, struct dc_stream *stream);
 
 bool is_stream_unchanged(
-	const struct core_stream *old_stream, const struct core_stream *stream);
+	struct dc_stream *old_stream, struct dc_stream *stream);
 
 bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
@@ -164,7 +164,7 @@ bool pipe_need_reprogram(
 		struct pipe_ctx *pipe_ctx_old,
 		struct pipe_ctx *pipe_ctx);
 
-void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
+void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth);
 
 #endif /* DRIVERS_GPU_DRM_AMD_DC_DEV_DC_INC_RESOURCE_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c b/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c
index d312874..dd024c9 100644
--- a/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/virtual/virtual_link_encoder.c
@@ -30,7 +30,7 @@
 
 static bool virtual_link_encoder_validate_output_with_stream(
 	struct link_encoder *enc,
-	const struct core_stream *stream) { return true; }
+	const struct dc_stream *stream) { return true; }
 
 static void virtual_link_encoder_hw_init(struct link_encoder *enc) {}
 
diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index a989d5d..358f8a8 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -111,7 +111,7 @@ struct freesync_state {
 };
 
 struct freesync_entity {
-	const struct dc_stream *stream;
+	struct dc_stream *stream;
 	struct mod_freesync_caps *caps;
 	struct freesync_state state;
 	struct mod_freesync_user_enable user_enable;
@@ -229,7 +229,7 @@ void mod_freesync_destroy(struct mod_freesync *mod_freesync)
  * on the core_freesync->map and returns the corresponding index
  */
 static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	unsigned int index = 0;
 
@@ -244,9 +244,8 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 }
 
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream, struct mod_freesync_caps *caps)
+		struct dc_stream *stream, struct mod_freesync_caps *caps)
 {
-	struct core_stream *core_stream = NULL;
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
@@ -258,7 +257,6 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	core_stream = DC_STREAM_TO_CORE(stream);
 	core_dc = DC_TO_CORE(core_freesync->dc);
 
 	flag.save_per_edid = true;
@@ -315,7 +313,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		if (caps->supported &&
 			nom_refresh_rate_uhz >= caps->min_refresh_in_micro_hz &&
 			nom_refresh_rate_uhz <= caps->max_refresh_in_micro_hz)
-			core_stream->public.ignore_msa_timing_param = 1;
+			stream->ignore_msa_timing_param = 1;
 
 		core_freesync->num_entities++;
 		return true;
@@ -324,7 +322,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	int i = 0;
 	struct core_freesync *core_freesync = NULL;
@@ -346,14 +344,12 @@ bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
 }
 
 static void update_stream_freesync_context(struct core_freesync *core_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	unsigned int index;
 	struct freesync_context *ctx;
-	struct core_stream *core_stream;
 
-	core_stream = DC_STREAM_TO_CORE(stream);
-	ctx = &core_stream->public.freesync_ctx;
+	ctx = &stream->freesync_ctx;
 
 	index = map_index_from_stream(core_freesync, stream);
 
@@ -372,19 +368,17 @@ static void update_stream_freesync_context(struct core_freesync *core_freesync,
 }
 
 static void update_stream(struct core_freesync *core_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
-
 	unsigned int index = map_index_from_stream(core_freesync, stream);
 	if (core_freesync->map[index].caps->supported) {
-		core_stream->public.ignore_msa_timing_param = 1;
+		stream->ignore_msa_timing_param = 1;
 		update_stream_freesync_context(core_freesync, stream);
 	}
 }
 
 static void calc_freesync_range(struct core_freesync *core_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct freesync_state *state,
 		unsigned int min_refresh_in_uhz,
 		unsigned int max_refresh_in_uhz)
@@ -458,7 +452,7 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 		min_frame_duration_in_ns) / 2000;
 }
 
-static void calc_v_total_from_duration(const struct dc_stream *stream,
+static void calc_v_total_from_duration(struct dc_stream *stream,
 		unsigned int duration_in_ns, int *v_total_nominal)
 {
 	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
@@ -467,7 +461,7 @@ static void calc_v_total_from_duration(const struct dc_stream *stream,
 }
 
 static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int index, int *v_total)
 {
 	unsigned int frame_duration = 0;
@@ -563,7 +557,7 @@ static void reset_freesync_state_variables(struct freesync_state* state)
  * Sets freesync mode on a stream depending on current freesync state.
  */
 static bool set_freesync_on_streams(struct core_freesync *core_freesync,
-		const struct dc_stream **streams, int num_streams)
+		struct dc_stream **streams, int num_streams)
 {
 	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
 	unsigned int stream_idx, map_index = 0;
@@ -735,7 +729,7 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams)
+		struct dc_stream **streams, int num_streams)
 {
 	unsigned int index, v_total, inserted_frame_v_total = 0;
 	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
@@ -845,7 +839,7 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		struct mod_freesync_params *freesync_params)
 {
 	bool freesync_program_required = false;
@@ -935,7 +929,7 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 
 
 bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct mod_freesync_params *freesync_params)
 {
 	unsigned int index = 0;
@@ -971,7 +965,7 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int stream_index, map_index;
@@ -1023,7 +1017,7 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int index = 0;
@@ -1041,7 +1035,7 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		bool *is_ramp_active)
 {
 	unsigned int index = 0;
@@ -1060,7 +1054,7 @@ bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		const struct dc_stream *streams,
+		struct dc_stream *streams,
 		unsigned int min_refresh,
 		unsigned int max_refresh,
 		struct mod_freesync_caps *caps)
@@ -1113,7 +1107,7 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *min_refresh,
 		unsigned int *max_refresh)
 {
@@ -1135,7 +1129,7 @@ bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *vmin,
 		unsigned int *vmax)
 {
@@ -1157,7 +1151,7 @@ bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos)
 {
@@ -1185,7 +1179,7 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams)
+		struct dc_stream **streams, int num_streams)
 {
 	unsigned int stream_index, map_index;
 	struct freesync_state *state;
@@ -1310,7 +1304,7 @@ static void update_timestamps(struct core_freesync *core_freesync,
 }
 
 static void apply_below_the_range(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, unsigned int map_index,
+		struct dc_stream *stream, unsigned int map_index,
 		unsigned int last_render_time_in_us)
 {
 	unsigned int inserted_frame_duration_in_us = 0;
@@ -1409,7 +1403,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 }
 
 static void apply_fixed_refresh(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, unsigned int map_index)
+		struct dc_stream *stream, unsigned int map_index)
 {
 	unsigned int vmin = 0, vmax = 0;
 	struct freesync_state *state = &core_freesync->map[map_index].state;
@@ -1440,7 +1434,7 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		unsigned int curr_time_stamp_in_us)
 {
 	unsigned int stream_index, map_index, last_render_time_in_us = 0;
diff --git a/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h b/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h
index 53c428b..2b9d451 100644
--- a/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h
+++ b/drivers/gpu/drm/amd/display/modules/inc/mod_freesync.h
@@ -101,67 +101,67 @@ struct mod_freesync_params {
  * Add stream to be tracked by module
  */
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream, struct mod_freesync_caps *caps);
+		struct dc_stream *stream, struct mod_freesync_caps *caps);
 
 /*
  * Remove stream to be tracked by module
  */
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream);
+		struct dc_stream *stream);
 
 /*
  * Update the freesync state flags for each display and program
  * freesync accordingly
  */
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		struct mod_freesync_params *freesync_params);
 
 bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct mod_freesync_params *freesync_params);
 
 bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable);
 
 bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct mod_freesync_user_enable *user_enable);
 
 bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		bool *is_ramp_active);
 
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		const struct dc_stream *streams,
+		struct dc_stream *streams,
 		unsigned int min_refresh,
 		unsigned int max_refresh,
 		struct mod_freesync_caps *caps);
 
 bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *min_refresh,
 		unsigned int *max_refresh);
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *vmin,
 		unsigned int *vmax);
 
 bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos);
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams);
+		struct dc_stream **streams, int num_streams);
 
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams);
+		struct dc_stream **streams, int num_streams);
 
 void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		unsigned int curr_time_stamp);
 
 #endif
-- 
2.7.4

