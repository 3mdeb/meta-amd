From c30f7bc2f070acd40c792a839331b22c9dd615f7 Mon Sep 17 00:00:00 2001
From: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date: Tue, 12 Jul 2016 10:59:16 -0400
Subject: [PATCH 0650/1722] drm/amd/dal: Scale taps policy implementation

Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 65 +++++++++------
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  4 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  2 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  4 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform.c   | 29 ++++++-
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform.h   |  8 ++
 .../amd/dal/dc/dce110/dce110_transform_bit_depth.c | 76 ++++-------------
 .../amd/dal/dc/dce110/dce110_transform_bit_depth.h | 11 +--
 .../drm/amd/dal/dc/dce110/dce110_transform_scl.c   | 36 ++++++++
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c |  5 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  4 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  4 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.c | 22 ++++-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h |  3 +
 .../amd/dal/dc/dce80/dce80_transform_bit_depth.c   | 95 ----------------------
 .../amd/dal/dc/dce80/dce80_transform_bit_depth.h   | 12 ---
 .../gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c |  1 -
 drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h      | 16 ++++
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |  4 +-
 19 files changed, 181 insertions(+), 220 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index d32fa85..565dabf 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -435,25 +435,27 @@ static void calculate_scaling_ratios(
 	}
 }
 
-void get_optimal_number_of_taps(
-	struct scaling_taps *taps)
+void decide_lb_format(struct pipe_ctx *pipe_ctx)
 {
-	/*
-	 * TODO fix hard-coding.
-	 * 4 taps preferred but fall
-	 * back to 2 taps if line buffer
-	 * isn't sufficient
-	 */
-	taps->h_taps = 2;
-	taps->v_taps = 2;
-	taps->h_taps_c = 2;
-	taps->v_taps_c = 2;
+	switch (pipe_ctx->pix_clk_params.color_depth) {
+	case COLOR_DEPTH_666:
+	case COLOR_DEPTH_888:
+		pipe_ctx->scl_data.lb_bpp = LB_PIXEL_DEPTH_24BPP;
+		break;
+	case COLOR_DEPTH_101010:
+		pipe_ctx->scl_data.lb_bpp = LB_PIXEL_DEPTH_30BPP;
+		break;
+	default:
+		pipe_ctx->scl_data.lb_bpp = LB_PIXEL_DEPTH_30BPP;
+		break;
+	}
 }
 
-void resource_build_scaling_params(
+bool resource_build_scaling_params(
 	const struct dc_surface *surface,
 	struct pipe_ctx *pipe_ctx)
 {
+	bool res;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
@@ -466,33 +468,39 @@ void resource_build_scaling_params(
 
 	calculate_recout(surface, pipe_ctx);
 
+	decide_lb_format(pipe_ctx);
+
 	pipe_ctx->scl_data.h_active = timing->h_addressable
 			+ timing->h_border_left + timing->h_border_right;
 	pipe_ctx->scl_data.v_active = timing->v_addressable
 			+ timing->v_border_top + timing->v_border_bottom;
 
-	get_optimal_number_of_taps(&pipe_ctx->scl_data.taps);
+	/* Taps calculations */
+	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
+		pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
 
-	/* Check if scaling is required update taps if not */
+	/* Check if scaling is required, if so  fail in case optimal taps calc
+	 * failed. Otherwise just update taps here
+	 */
 	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.horz) == (1 << 19))
 		pipe_ctx->scl_data.taps.h_taps = 1;
-	else if (surface->scaling_quality.h_taps != 0)
-		pipe_ctx->scl_data.taps.h_taps = surface->scaling_quality.h_taps;
+	else if (!res)
+		return false;
 
 	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.horz_c) == (1 << 19))
 		pipe_ctx->scl_data.taps.h_taps_c = 1;
-	else if (surface->scaling_quality.h_taps_c != 0)
-		pipe_ctx->scl_data.taps.h_taps_c = surface->scaling_quality.h_taps_c;
+	else if (!res)
+		return false;
 
 	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.vert) == (1 << 19))
 		pipe_ctx->scl_data.taps.v_taps = 1;
-	else if (surface->scaling_quality.v_taps != 0)
-		pipe_ctx->scl_data.taps.v_taps = surface->scaling_quality.v_taps;
+	else if (!res)
+		return false;
 
 	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.vert_c) == (1 << 19))
 		pipe_ctx->scl_data.taps.v_taps_c = 1;
-	else if (surface->scaling_quality.v_taps_c != 0)
-		pipe_ctx->scl_data.taps.v_taps_c = surface->scaling_quality.v_taps_c;
+	else if (!res)
+		return false;
 
 	dal_logger_write(pipe_ctx->stream->ctx->logger,
 				LOG_MAJOR_DCP,
@@ -509,10 +517,12 @@ void resource_build_scaling_params(
 				surface->dst_rect.width,
 				surface->dst_rect.x,
 				surface->dst_rect.y);
+
+	return true;
 }
 
 
-void resource_build_scaling_params_for_context(
+enum dc_status resource_build_scaling_params_for_context(
 	const struct core_dc *dc,
 	struct validate_context *context)
 {
@@ -521,10 +531,13 @@ void resource_build_scaling_params_for_context(
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
 				context->res_ctx.pipe_ctx[i].stream != NULL)
-			resource_build_scaling_params(
+			if (!resource_build_scaling_params(
 				&context->res_ctx.pipe_ctx[i].surface->public,
-				&context->res_ctx.pipe_ctx[i]);
+				&context->res_ctx.pipe_ctx[i]))
+				return DC_FAIL_BANDWIDTH_VALIDATE;
 	}
+
+	return DC_OK;
 }
 
 static void detach_surfaces_for_target(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 8ddf452..a96b262 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -683,7 +683,7 @@ enum dc_status dce100_validate_with_context(
 		result = validate_mapped_resource(dc, context);
 
 	if (result == DC_OK)
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
 		result = dce100_validate_bandwidth(dc, context);
@@ -715,7 +715,7 @@ enum dc_status dce100_validate_guaranteed(
 	if (result == DC_OK) {
 		validate_guaranteed_copy_target(
 				context, dc->public.caps.max_targets);
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index bdee9f1..9939944 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1487,7 +1487,7 @@ static void program_scaler(const struct core_dc *dc,
 
 	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
 		pipe_ctx->xfm,
-		LB_PIXEL_DEPTH_30BPP,
+		pipe_ctx->scl_data.lb_bpp,
 		&pipe_ctx->stream->bit_depth_params);
 
 	pipe_ctx->tg->funcs->set_overscan_blank_color(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index e1c204a..8aa529b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -922,7 +922,7 @@ enum dc_status dce110_validate_with_context(
 		result = validate_mapped_resource(dc, context);
 
 	if (result == DC_OK)
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
 		result = dce110_validate_bandwidth(dc, context);
@@ -954,7 +954,7 @@ enum dc_status dce110_validate_guaranteed(
 	if (result == DC_OK) {
 		validate_guaranteed_copy_target(
 				context, dc->public.caps.max_targets);
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
index 59b2448..24d159e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.c
@@ -40,6 +40,27 @@
 
 #include "dce110_transform_bit_depth.h"
 
+bool dce110_transform_get_optimal_number_of_taps(
+	struct transform *xfm,
+	struct scaler_data *scl_data,
+	const struct scaling_taps *in_taps)
+{
+	uint32_t pixel_width;
+
+
+	if (scl_data->viewport.width > scl_data->recout.width)
+		pixel_width = scl_data->recout.width;
+	else
+		pixel_width = scl_data->viewport.width;
+
+	return transform_get_optimal_number_of_taps_helper(
+			xfm,
+			scl_data,
+			pixel_width,
+			in_taps);
+
+}
+
 static const struct transform_funcs dce110_transform_funcs = {
 	.transform_power_up =
 		dce110_transform_power_up,
@@ -55,7 +76,9 @@ static const struct transform_funcs dce110_transform_funcs = {
 		dce110_transform_set_pixel_storage_depth,
 	.transform_get_current_pixel_storage_depth =
 		dce110_transform_get_current_pixel_storage_depth,
-	.transform_set_alpha = dce110_transform_set_alpha
+	.transform_set_alpha = dce110_transform_set_alpha,
+	.transform_get_optimal_number_of_taps =
+		dce110_transform_get_optimal_number_of_taps
 };
 
 /*****************************************/
@@ -80,6 +103,9 @@ bool dce110_transform_construct(
 			LB_PIXEL_DEPTH_24BPP |
 			LB_PIXEL_DEPTH_30BPP;
 
+	xfm110->base.lb_bits_per_entry = LB_BITS_PER_ENTRY;
+	xfm110->base.lb_total_entries_num = LB_TOTAL_NUMBER_OF_ENTRIES;
+
 	return true;
 }
 
@@ -87,4 +113,3 @@ bool dce110_transform_power_up(struct transform *xfm)
 {
 	return dce110_transform_power_up_line_buffer(xfm);
 }
-
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h
index c9740f5..3fa99fb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform.h
@@ -30,6 +30,9 @@
 #define TO_DCE110_TRANSFORM(transform)\
 	container_of(transform, struct dce110_transform, base)
 
+#define LB_TOTAL_NUMBER_OF_ENTRIES 1712
+#define LB_BITS_PER_ENTRY 144
+
 struct dce110_transform_reg_offsets {
 	uint32_t scl_offset;
 	uint32_t dcfe_offset;
@@ -81,4 +84,9 @@ bool dce110_transform_get_current_pixel_storage_depth(
 
 void dce110_transform_set_alpha(struct transform *xfm, bool enable);
 
+bool dce110_transform_get_optimal_number_of_taps(
+	struct transform *xfm,
+	struct scaler_data *scl_data,
+	const struct scaling_taps *in_taps);
+
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
index 07f7d12..20d680a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.c
@@ -41,9 +41,6 @@
 #define LB_REG(reg)\
 	(reg + xfm110->offsets.lb_offset)
 
-#define LB_TOTAL_NUMBER_OF_ENTRIES 1712
-#define LB_BITS_PER_ENTRY 144
-
 enum dcp_out_trunc_round_mode {
 	DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE,
 	DCP_OUT_TRUNC_ROUND_MODE_ROUND
@@ -538,54 +535,53 @@ static bool set_dither(
 	return true;
 }
 
-bool dce110_transform_get_max_num_of_supported_lines(
-	struct dce110_transform *xfm110,
+int32_t dce110_transform_get_max_num_of_supported_lines(
+	struct transform *xfm,
 	enum lb_pixel_depth depth,
-	uint32_t pixel_width,
-	uint32_t *lines)
+	uint32_t pixel_width)
 {
 	uint32_t pixels_per_entries = 0;
 	uint32_t max_pixels_supports = 0;
 
-	if (pixel_width == 0)
-		return false;
+	ASSERT_CRITICAL(pixel_width);
 
 	/* Find number of pixels that can fit into a single LB entry and
 	 * take floor of the value since we cannot store a single pixel
 	 * across multiple entries. */
 	switch (depth) {
 	case LB_PIXEL_DEPTH_18BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 18;
+		pixels_per_entries = xfm->lb_bits_per_entry / 18;
 		break;
 
 	case LB_PIXEL_DEPTH_24BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 24;
+		pixels_per_entries = xfm->lb_bits_per_entry / 24;
 		break;
 
 	case LB_PIXEL_DEPTH_30BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 30;
+		pixels_per_entries = xfm->lb_bits_per_entry / 30;
 		break;
 
 	case LB_PIXEL_DEPTH_36BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 36;
+		pixels_per_entries = xfm->lb_bits_per_entry / 36;
 		break;
 
 	default:
-		dal_logger_write(xfm110->base.ctx->logger,
+		dal_logger_write(xfm->ctx->logger,
 			LOG_MAJOR_WARNING,
 			LOG_MINOR_COMPONENT_GPU,
 			"%s: Invalid LB pixel depth",
 			__func__);
+		ASSERT_CRITICAL(false);
 		break;
 	}
 
-	if (pixels_per_entries == 0)
-		return false;
+	ASSERT_CRITICAL(pixels_per_entries);
 
-	max_pixels_supports = pixels_per_entries * LB_TOTAL_NUMBER_OF_ENTRIES;
+	max_pixels_supports =
+			pixels_per_entries *
+			xfm->lb_total_entries_num;
 
-	*lines = max_pixels_supports / pixel_width;
-	return true;
+	return (max_pixels_supports / pixel_width);
 }
 
 void dce110_transform_set_alpha(struct transform *xfm, bool enable)
@@ -613,48 +609,6 @@ void dce110_transform_set_alpha(struct transform *xfm, bool enable)
 	dm_write_reg(ctx, addr, value);
 }
 
-static enum lb_pixel_depth translate_display_bpp_to_lb_depth(
-	uint32_t display_bpp)
-{
-	switch (display_bpp) {
-	case 18:
-		return LB_PIXEL_DEPTH_18BPP;
-	case 24:
-		return LB_PIXEL_DEPTH_24BPP;
-	case 36:
-	case 42:
-	case 48:
-		return LB_PIXEL_DEPTH_36BPP;
-	case 30:
-	default:
-		return LB_PIXEL_DEPTH_30BPP;
-	}
-}
-
-bool dce110_transform_get_next_lower_pixel_storage_depth(
-	struct dce110_transform *xfm110,
-	uint32_t display_bpp,
-	enum lb_pixel_depth depth,
-	enum lb_pixel_depth *lower_depth)
-{
-	enum lb_pixel_depth depth_req_by_display =
-		translate_display_bpp_to_lb_depth(display_bpp);
-	uint32_t current_required_depth = depth_req_by_display;
-	uint32_t current_depth = depth;
-
-	/* if required display depth < current we could go down, for example
-	 * from LB_PIXEL_DEPTH_30BPP to LB_PIXEL_DEPTH_24BPP
-	 */
-	if (current_required_depth < current_depth) {
-		current_depth = current_depth >> 1;
-		if (xfm110->lb_pixel_depth_supported & current_depth) {
-			*lower_depth = current_depth;
-			return true;
-		}
-	}
-	return false;
-}
-
 bool dce110_transform_is_prefetch_enabled(
 	struct dce110_transform *xfm110)
 {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.h
index 71f1c3a..a28efb0 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_bit_depth.h
@@ -30,16 +30,9 @@
 bool dce110_transform_power_up_line_buffer(struct transform *xfm);
 
 bool dce110_transform_get_max_num_of_supported_lines(
-	struct dce110_transform *xfm110,
+	struct transform *xfm,
 	enum lb_pixel_depth depth,
-	uint32_t pixel_width,
-	uint32_t *lines);
-
-bool dce110_transform_get_next_lower_pixel_storage_depth(
-	struct dce110_transform *xfm110,
-	uint32_t display_bpp,
-	enum lb_pixel_depth depth,
-	enum lb_pixel_depth *lower_depth);
+	uint32_t pixel_width);
 
 bool dce110_transform_is_prefetch_enabled(
 	struct dce110_transform *xfm110);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
index 080ca04..889ab2f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
@@ -30,6 +30,7 @@
 #include "dce/dce_11_0_sh_mask.h"
 
 #include "dce110_transform.h"
+#include "dce110_transform_bit_depth.h"
 
 #define UP_SCALER_RATIO_MAX 16000
 #define DOWN_SCALER_RATIO_MAX 250
@@ -720,3 +721,38 @@ void dce110_transform_set_scaler_filter(
 	xfm->filter = filter;
 }
 
+bool transform_get_optimal_number_of_taps_helper(
+	struct transform *xfm,
+	struct scaler_data *scl_data,
+	uint32_t pixel_width,
+	const struct scaling_taps *in_taps) {
+
+	int max_num_of_lines;
+
+	max_num_of_lines = dce110_transform_get_max_num_of_supported_lines(
+		xfm,
+		scl_data->lb_bpp,
+		pixel_width);
+
+	/* If num of taps is given as input fail if we cannot
+	 * maintain that much taps
+	 */
+	if (in_taps->v_taps) {
+		scl_data->taps = *in_taps;
+		return max_num_of_lines > scl_data->taps.v_taps;
+	}
+
+	/*If no taps given as input set to max and reduce
+	 * as needed to get along, also
+	 * set horizontal taps to 4 regardless
+	 */
+	scl_data->taps.h_taps = 4;
+	scl_data->taps.v_taps = 4;
+
+	if (max_num_of_lines > scl_data->taps.v_taps)
+		return true;
+
+	scl_data->taps.v_taps = max_num_of_lines - 1;
+	return scl_data->taps.v_taps > 1;
+
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
index e852ffc..dd57a81 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
@@ -35,7 +35,6 @@
 
 #define NOT_IMPLEMENTED()  DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_CONTROLLER,\
 			"TRANSFORM SCALER:%s()\n", __func__)
-#define LB_TOTAL_NUMBER_OF_ENTRIES 1712
 
 struct sclv_ratios_inits {
 	uint32_t h_int_scale_ratio_luma;
@@ -591,7 +590,9 @@ static const struct transform_funcs dce110_transform_v_funcs = {
 	.transform_set_pixel_storage_depth =
 		dce110_transform_v_set_pixel_storage_depth,
 	.transform_get_current_pixel_storage_depth =
-		dce110_transform_v_get_current_pixel_storage_depth
+		dce110_transform_v_get_current_pixel_storage_depth,
+	.transform_get_optimal_number_of_taps =
+			dce110_transform_get_optimal_number_of_taps
 };
 /*****************************************/
 /* Constructor, Destructor               */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 4ff6dc1..381312e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -946,7 +946,7 @@ enum dc_status dce112_validate_with_context(
 		result = validate_mapped_resource(dc, context);
 
 	if (result == DC_OK)
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
 		result = dce112_validate_bandwidth(dc, context);
@@ -978,7 +978,7 @@ enum dc_status dce112_validate_guaranteed(
 	if (result == DC_OK) {
 		validate_guaranteed_copy_target(
 				context, dc->public.caps.max_targets);
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 6aadbe3..626549e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -637,7 +637,7 @@ enum dc_status dce80_validate_with_context(
 		result = validate_mapped_resource(dc, context);
 
 	if (result == DC_OK)
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
 		result = dce80_validate_bandwidth(dc, context);
@@ -669,7 +669,7 @@ enum dc_status dce80_validate_guaranteed(
 	if (result == DC_OK) {
 		validate_guaranteed_copy_target(
 				context, dc->public.caps.max_targets);
-		resource_build_scaling_params_for_context(dc, context);
+		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
 	if (result == DC_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.c
index b3a9b72..9f5336d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.c
@@ -40,6 +40,21 @@
 
 #include "dce80_transform_bit_depth.h"
 
+bool dce80_transform_get_optimal_number_of_taps(
+	struct transform *xfm,
+	struct scaler_data *scl_data,
+	const struct scaling_taps *in_taps)
+{
+
+	return transform_get_optimal_number_of_taps_helper(
+			xfm,
+			scl_data,
+			scl_data->viewport.width,
+			in_taps);
+
+	return true;
+}
+
 static const struct transform_funcs dce80_transform_funcs = {
 	.transform_power_up =
 		dce80_transform_power_up,
@@ -54,7 +69,9 @@ static const struct transform_funcs dce80_transform_funcs = {
 	.transform_set_pixel_storage_depth =
 		dce80_transform_set_pixel_storage_depth,
 	.transform_get_current_pixel_storage_depth =
-		dce80_transform_get_current_pixel_storage_depth
+		dce80_transform_get_current_pixel_storage_depth,
+	.transform_get_optimal_number_of_taps =
+		dce80_transform_get_optimal_number_of_taps
 };
 
 /*****************************************/
@@ -79,6 +96,9 @@ bool dce80_transform_construct(
 			LB_PIXEL_DEPTH_24BPP |
 			LB_PIXEL_DEPTH_30BPP;
 
+	xfm80->base.lb_bits_per_entry = LB_BITS_PER_ENTRY;
+	xfm80->base.lb_total_entries_num = LB_TOTAL_NUMBER_OF_ENTRIES;
+
 	return true;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h
index f7b7cc5..3d14e04 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform.h
@@ -30,6 +30,9 @@
 #define TO_DCE80_TRANSFORM(transform)\
 	container_of(transform, struct dce80_transform, base)
 
+#define LB_TOTAL_NUMBER_OF_ENTRIES 1712
+#define LB_BITS_PER_ENTRY 144
+
 struct dce80_transform_reg_offsets {
 	uint32_t scl_offset;
 	uint32_t crtc_offset;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.c
index 1dc0dbc..fd29892 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.c
@@ -40,9 +40,6 @@
 #define LB_REG(reg)\
 	(reg + xfm80->offsets.lb_offset)
 
-#define LB_TOTAL_NUMBER_OF_ENTRIES 1712
-#define LB_BITS_PER_ENTRY 144
-
 enum dcp_out_trunc_round_mode {
 	DCP_OUT_TRUNC_ROUND_MODE_TRUNCATE,
 	DCP_OUT_TRUNC_ROUND_MODE_ROUND
@@ -528,56 +525,6 @@ static bool set_dither(
 	return true;
 }
 
-bool dce80_transform_get_max_num_of_supported_lines(
-	struct dce80_transform *xfm80,
-	enum lb_pixel_depth depth,
-	uint32_t pixel_width,
-	uint32_t *lines)
-{
-	uint32_t pixels_per_entries = 0;
-	uint32_t max_pixels_supports = 0;
-
-	if (pixel_width == 0)
-		return false;
-
-	/* Find number of pixels that can fit into a single LB entry and
-	 * take floor of the value since we cannot store a single pixel
-	 * across multiple entries. */
-	switch (depth) {
-	case LB_PIXEL_DEPTH_18BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 18;
-		break;
-
-	case LB_PIXEL_DEPTH_24BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 24;
-		break;
-
-	case LB_PIXEL_DEPTH_30BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 30;
-		break;
-
-	case LB_PIXEL_DEPTH_36BPP:
-		pixels_per_entries = LB_BITS_PER_ENTRY / 36;
-		break;
-
-	default:
-		dal_logger_write(xfm80->base.ctx->logger,
-			LOG_MAJOR_WARNING,
-			LOG_MINOR_COMPONENT_GPU,
-			"%s: Invalid LB pixel depth",
-			__func__);
-		break;
-	}
-
-	if (pixels_per_entries == 0)
-		return false;
-
-	max_pixels_supports = pixels_per_entries * LB_TOTAL_NUMBER_OF_ENTRIES;
-
-	*lines = max_pixels_supports / pixel_width;
-	return true;
-}
-
 void dce80_transform_enable_alpha(
 	struct dce80_transform *xfm80,
 	bool enable)
@@ -604,48 +551,6 @@ void dce80_transform_enable_alpha(
 	dm_write_reg(ctx, addr, value);
 }
 
-static enum lb_pixel_depth translate_display_bpp_to_lb_depth(
-	uint32_t display_bpp)
-{
-	switch (display_bpp) {
-	case 18:
-		return LB_PIXEL_DEPTH_18BPP;
-	case 24:
-		return LB_PIXEL_DEPTH_24BPP;
-	case 36:
-	case 42:
-	case 48:
-		return LB_PIXEL_DEPTH_36BPP;
-	case 30:
-	default:
-		return LB_PIXEL_DEPTH_30BPP;
-	}
-}
-
-bool dce80_transform_get_next_lower_pixel_storage_depth(
-	struct dce80_transform *xfm80,
-	uint32_t display_bpp,
-	enum lb_pixel_depth depth,
-	enum lb_pixel_depth *lower_depth)
-{
-	enum lb_pixel_depth depth_req_by_display =
-		translate_display_bpp_to_lb_depth(display_bpp);
-	uint32_t current_required_depth = depth_req_by_display;
-	uint32_t current_depth = depth;
-
-	/* if required display depth < current we could go down, for example
-	 * from LB_PIXEL_DEPTH_30BPP to LB_PIXEL_DEPTH_24BPP
-	 */
-	if (current_required_depth < current_depth) {
-		current_depth = current_depth >> 1;
-		if (xfm80->lb_pixel_depth_supported & current_depth) {
-			*lower_depth = current_depth;
-			return true;
-		}
-	}
-	return false;
-}
-
 bool dce80_transform_is_prefetch_enabled(
 	struct dce80_transform *xfm80)
 {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.h
index af831f8..a8d9008 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_bit_depth.h
@@ -29,22 +29,10 @@
 
 bool dce80_transform_power_up_line_buffer(struct transform *xfm);
 
-bool dce80_transform_get_max_num_of_supported_lines(
-	struct dce80_transform *xfm80,
-	enum lb_pixel_depth depth,
-	uint32_t pixel_width,
-	uint32_t *lines);
-
 void dce80_transform_enable_alpha(
 	struct dce80_transform *xfm80,
 	bool enable);
 
-bool dce80_transform_get_next_lower_pixel_storage_depth(
-	struct dce80_transform *xfm80,
-	uint32_t display_bpp,
-	enum lb_pixel_depth depth,
-	enum lb_pixel_depth *lower_depth);
-
 bool dce80_transform_is_prefetch_enabled(
 	struct dce80_transform *xfm80);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c
index 5d674f2..53930b9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c
@@ -717,4 +717,3 @@ void dce80_transform_set_scaler_filter(
 {
 	xfm->filter = filter;
 }
-
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
index c6e5d17..b0fa06a 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
@@ -28,6 +28,7 @@
 
 #include "include/scaler_types.h"
 #include "calcs/scaler_filter.h"
+#include "dc_hw_types.h"
 
 struct bit_depth_reduction_params;
 
@@ -36,6 +37,9 @@ struct transform {
 	struct dc_context *ctx;
 	uint32_t inst;
 	struct scaler_filter *filter;
+
+	int lb_total_entries_num;
+	int lb_bits_per_entry;
 };
 
 enum lb_pixel_depth {
@@ -148,6 +152,7 @@ struct scaler_data {
 	struct scaling_ratios ratios;
 	struct sharpness_adj sharpness;
 	enum pixel_format format;
+	enum lb_pixel_depth lb_bpp;
 };
 
 struct line_buffer_params {
@@ -187,6 +192,17 @@ struct transform_funcs {
 		enum lb_pixel_depth *depth);
 
 	void (*transform_set_alpha)(struct transform *xfm, bool enable);
+
+	bool (*transform_get_optimal_number_of_taps)(
+		struct transform *xfm,
+		struct scaler_data *scl_data,
+		const struct scaling_taps *in_taps);
 };
 
+bool transform_get_optimal_number_of_taps_helper(
+	struct transform *xfm,
+	struct scaler_data *scl_data,
+	uint32_t pixel_width,
+	const struct scaling_taps *in_taps);
+
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index 505e718..4014a74 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -47,11 +47,11 @@ enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context);
 
-void resource_build_scaling_params(
+bool resource_build_scaling_params(
 		const struct dc_surface *surface,
 		struct pipe_ctx *pipe_ctx);
 
-void resource_build_scaling_params_for_context(
+enum dc_status resource_build_scaling_params_for_context(
 		const struct core_dc *dc,
 		struct validate_context *context);
 
-- 
2.7.4

