From e5edef8b16381c9bfe99282ecac3cdd37c39c174 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 25 Jun 2015 13:36:14 -0400
Subject: [PATCH 307/401] amd/dal: Remove DMCU until it's needed

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 .../gpu/drm/amd/dal/display_path/display_path.c    |  20 ---
 .../gpu/drm/amd/dal/display_path/display_path.h    |   4 -
 .../dal/hw_sequencer/dce110/hw_sequencer_dce110.c  |  17 --
 .../gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c    |  96 ----------
 .../drm/amd/dal/include/display_path_interface.h   |   8 -
 drivers/gpu/drm/amd/dal/include/dmcu_interface.h   |  87 ---------
 drivers/gpu/drm/amd/dal/include/dmcu_types.h       | 199 ---------------------
 .../gpu/drm/amd/dal/topology/tm_detection_mgr.c    |   1 -
 .../gpu/drm/amd/dal/topology/tm_resource_builder.c |  42 -----
 .../gpu/drm/amd/dal/topology/tm_resource_builder.h |   3 -
 drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c |  25 +--
 drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h |   6 -
 drivers/gpu/drm/amd/dal/topology/topology.c        |  16 +-
 13 files changed, 2 insertions(+), 522 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/include/dmcu_interface.h
 delete mode 100644 drivers/gpu/drm/amd/dal/include/dmcu_types.h

diff --git a/drivers/gpu/drm/amd/dal/display_path/display_path.c b/drivers/gpu/drm/amd/dal/display_path/display_path.c
index 79f9301..b9b8788 100644
--- a/drivers/gpu/drm/amd/dal/display_path/display_path.c
+++ b/drivers/gpu/drm/amd/dal/display_path/display_path.c
@@ -509,15 +509,6 @@ struct clock_source *dal_display_path_get_alt_clock_source(
 	return path->alt_clock_source;
 }
 
-void dal_display_path_set_dmcu(struct display_path *path, struct dmcu *dmcu)
-{
-	path->dmcu = dmcu;
-}
-struct dmcu *dal_display_path_get_dmcu(const struct display_path *path)
-{
-	return path->dmcu;
-}
-
 void dal_display_path_set_fbc_info(
 	struct display_path *path,
 	struct fbc_info *fbc_info)
@@ -792,17 +783,6 @@ void dal_display_path_get_static_screen_triggers(
 
 bool dal_display_path_is_psr_supported(const struct display_path *path)
 {
-	struct link_service *ls =
-		dal_display_path_get_link_query_interface(
-				path, ASIC_LINK_INDEX);
-
-	/* Condition 1: PSR supported through registry key (FEATURE_PSR_ENABLE)
-	 *              and Panel reports PSR support through DPCD
-	 * Condition 2: DMCU object is attached to this display path
-	 */
-	if (dal_ls_is_link_psr_supported(ls) && (path->dmcu != NULL))
-		return true;
-
 	return false;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/display_path/display_path.h b/drivers/gpu/drm/amd/dal/display_path/display_path.h
index 317a97a..6a689b5 100644
--- a/drivers/gpu/drm/amd/dal/display_path/display_path.h
+++ b/drivers/gpu/drm/amd/dal/display_path/display_path.h
@@ -55,10 +55,6 @@ struct display_path {
 	uint32_t number_of_links;
 	struct connector *connector;
 
-	/* optional components that are always attached
-	 * to a particular display path*/
-	struct dmcu *dmcu; /* dmcu is for embedded display paths*/
-
 	/* dcp components that attached only on acquired display path*/
 	struct clock_source *clock_source;
 
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c b/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c
index 366f64b..4fa0bd1 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c
@@ -27,7 +27,6 @@
 
 #include "include/logger_interface.h"
 #include "include/bandwidth_manager_interface.h"
-#include "include/dmcu_interface.h"
 #include "include/connector_interface.h"
 #include "include/controller_interface.h"
 #include "include/display_path_interface.h"
@@ -523,22 +522,6 @@ static void set_display_clock(
 		dal_display_clock_set_clock(objs.dc,
 				min_clocks->min_dclk_khz);
 
-	/* When changing display engine clock, DMCU WaitLoop must be
-	 * reconfigured in order to maintain the same delays within DMCU
-	 * programming sequences. */
-	paths_number = dal_hw_path_mode_set_get_paths_number(path_set);
-	for (i = 0; i < paths_number; i++) {
-		const struct hw_path_mode *path_mode =
-			dal_hw_path_mode_set_get_path_by_index(path_set, i);
-
-		if (path_mode == NULL || path_mode->display_path == NULL)
-			continue;
-
-		/* There is only only DMCU on the ASIC. We can break from this
-		 * loop once DMCU has been found. */
-		break;
-	}
-
 	/* Start GTC counter */
 	hws->funcs->start_gtc_counter(hws, path_set);
 }
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
index 20e04e8..f4bcd20 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
@@ -34,7 +34,6 @@
 #include "include/dc_clock_generator_interface.h"
 #include "include/dcs_interface.h"
 #include "include/ddc_service_types.h"
-#include "include/dmcu_interface.h"
 #include "include/encoder_interface.h"
 #include "include/logger_interface.h"
 #include "include/signal_types.h"
@@ -1246,101 +1245,6 @@ static void build_upstream_encoder_output(
 					LINK_SPREAD_DISABLED);
 }
 
-static void build_dmcu_context(
-		struct hw_sequencer *hws,
-		const struct hw_path_mode *hw_path_mode,
-		const struct psr_caps *psr_caps,
-		struct dmcu_context *dmcu_context)
-{
-	uint32_t link_idx = ASIC_LINK_INDEX;
-	struct display_path *display_path = hw_path_mode->display_path;
-	struct dcs *dcs;
-	struct controller *controller;
-
-	struct display_sink_capability sink_capability = {
-			DISPLAY_DONGLE_NONE };
-
-	struct connector_feature_support cfs;
-	struct encoder *upstream_enc;
-
-	if (hw_path_mode == NULL || dmcu_context == NULL)
-			return;
-	upstream_enc = dal_display_path_get_upstream_encoder(
-				hw_path_mode->display_path,
-				link_idx);
-	dcs = dal_display_path_get_dcs(hw_path_mode->display_path);
-
-	if (upstream_enc == NULL || dcs == NULL) {
-		BREAK_TO_DEBUGGER();
-		dal_logger_write(hws->dal_context->logger,
-			LOG_MAJOR_WARNING,
-			LOG_MINOR_COMPONENT_HWSS,
-			"%s: Failed to obtain encoder or dcs", __func__);
-		return;
-	}
-
-	dal_dcs_get_sink_capability(dcs, &sink_capability);
-
-	controller = dal_display_path_get_controller(
-			hw_path_mode->display_path);
-
-	dal_connector_get_features(
-			dal_display_path_get_connector(
-					hw_path_mode->display_path),
-					&cfs);
-
-	dmcu_context->channel = cfs.ddc_line;
-
-	dmcu_context->engine_id = ENGINE_ID_UNKNOWN;
-	if (dal_display_path_is_link_active(display_path, ASIC_LINK_INDEX))
-		dmcu_context->engine_id = dal_display_path_get_stream_engine(
-				display_path,
-				ASIC_LINK_INDEX);
-
-	dmcu_context->smu_physical_phy_id = dal_encoder_get_phy(upstream_enc);
-
-	dmcu_context->transmitter_id = dal_encoder_get_transmitter(
-			upstream_enc);
-
-	dmcu_context->controller_id = dal_controller_get_id(controller);
-
-	dmcu_context->phy_type = PHY_TYPE_UNIPHY;
-
-	dmcu_context->psr_supported_display_config =
-			(psr_caps->psr_version > 0);
-
-	/* Check if PSR CRC workaround should be applied for this ASIC */
-	if (dal_adapter_service_get_asic_bugs(
-			hws->as).PSR_WA_OVERSCAN_CRC_ERROR)
-		/* Workaround for CRC mismatch when overscan enabled
-		 * since FMT CRCs generated do not include overscan borders.*/
-		if (hw_path_mode->mode.overscan.top != 0
-				|| hw_path_mode->mode.overscan.bottom != 0
-				|| hw_path_mode->mode.overscan.left != 0
-				|| hw_path_mode->mode.overscan.right != 0)
-			/* Keep PSR disabled if overscan is enabled. */
-			dmcu_context->psr_supported_display_config = false;
-
-	/* Whether fast link training is supported by the panel */
-	dmcu_context->psr_exit_link_training_required =
-			psr_caps->psr_exit_link_training_req;
-
-	/* Vertical total pixels from crtc timing. This is used for static
-	 * screen detection. For example, if we want to enter PSR state after
-	 * idle for half a frame, we use this do determine how many lines. */
-	dmcu_context->crtc_timing_vertical_total =
-			hw_path_mode->mode.timing.v_total;
-
-	/* The following two parameters are calculated based on Display Timing
-	 * (Specifically VBLANK size) and RFB Setup Time. It is used to
-	 *  determine whether the Sink is able to capture static video frame
-	 *  on the same frame as the frame GPU transmits SDP. */
-	dmcu_context->sdp_transmit_line_num_deadline =
-			psr_caps->psr_sdp_transmit_line_num_deadline;
-	dmcu_context->psr_frame_capture_indication_required =
-			psr_caps->psr_frame_capture_indication_req;
-}
-
 /**
  * Validate video memory bandwidth with the default (i.e. highest) display
  * engine clock value.
diff --git a/drivers/gpu/drm/amd/dal/include/display_path_interface.h b/drivers/gpu/drm/amd/dal/include/display_path_interface.h
index 27cbd8b..2468aec 100644
--- a/drivers/gpu/drm/amd/dal/include/display_path_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/display_path_interface.h
@@ -36,7 +36,6 @@ struct encoder;
 struct controller;
 struct connector;
 struct audio;
-struct dmcu;
 struct clock_source;
 struct link_service;
 struct goc_link_service_data;
@@ -188,13 +187,6 @@ void dal_display_path_set_alt_clock_source(
 struct clock_source *dal_display_path_get_alt_clock_source(
 	const struct display_path *path);
 
-void dal_display_path_set_dmcu(
-	struct display_path *path,
-	struct dmcu *clock);
-
-struct dmcu *dal_display_path_get_dmcu(
-	const struct display_path *path);
-
 void dal_display_path_set_fbc_info(
 	struct display_path *path,
 	struct fbc_info *clock);
diff --git a/drivers/gpu/drm/amd/dal/include/dmcu_interface.h b/drivers/gpu/drm/amd/dal/include/dmcu_interface.h
deleted file mode 100644
index cce61bb..0000000
--- a/drivers/gpu/drm/amd/dal/include/dmcu_interface.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright 2012-14 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_DMCU_INTERFACE_H__
-#define __DAL_DMCU_INTERFACE_H__
-
-#include "grph_object_defs.h"
-#include "dmcu_types.h"
-
-/* Interface functions */
-
-/* DMCU setup related interface functions */
-struct dmcu *dal_dmcu_create(
-	struct dmcu_init_data *init_data);
-void dal_dmcu_destroy(struct dmcu **dmcu);
-void dal_dmcu_release_hw(struct dmcu *dmcu);
-
-void dal_dmcu_power_up(struct dmcu *dmcu);
-void dal_dmcu_power_down(struct dmcu *dmcu);
-
-void dal_dmcu_configure_wait_loop(
-		struct dmcu *dmcu,
-		uint32_t display_clock);
-
-/* PSR feature related interface functions */
-void dal_dmcu_psr_setup(
-		struct dmcu *dmcu,
-		struct dmcu_context *dmcu_context);
-void dal_dmcu_psr_enable(struct dmcu *dmcu);
-void dal_dmcu_psr_disable(struct dmcu *dmcu);
-void dal_dmcu_psr_block(struct dmcu *dmcu, bool block_psr);
-bool dal_dmcu_psr_is_blocked(struct dmcu *dmcu);
-void dal_dmcu_psr_set_level(
-		struct dmcu *dmcu,
-		union dmcu_psr_level psr_level);
-void dal_dmcu_psr_allow_power_down_crtc(
-		struct dmcu *dmcu,
-		bool should_allow_crtc_power_down);
-bool dal_dmcu_psr_submit_command(
-		struct dmcu *dmcu,
-		struct dmcu_context *dmcu_context,
-		struct dmcu_config_data *config_data);
-void dal_dmcu_psr_get_config_data(
-		struct dmcu *dmcu,
-		uint32_t v_total,
-		struct dmcu_config_data *config_data);
-
-/* ABM feature related interface functions */
-void dal_dmcu_abm_enable(
-		struct dmcu *dmcu,
-		enum controller_id controller_id,
-		uint32_t vsync_rate_hz);
-void dal_dmcu_abm_disable(struct dmcu *dmcu);
-bool dal_dmcu_abm_enable_smooth_brightness(struct dmcu *dmcu);
-bool dal_dmcu_abm_disable_smooth_brightness(struct dmcu *dmcu);
-void dal_dmcu_abm_varibright_control(
-		struct dmcu *dmcu,
-		const struct varibright_control *varibright_control);
-bool dal_dmcu_abm_set_backlight_level(
-		struct dmcu *dmcu,
-		uint8_t backlight_8_bit);
-uint8_t dal_dmcu_abm_get_user_backlight_level(struct dmcu *dmcu);
-uint8_t dal_dmcu_abm_get_current_backlight_level(struct dmcu *dmcu);
-
-#endif /* __DAL_DMCU_INTERFACE_H__ */
diff --git a/drivers/gpu/drm/amd/dal/include/dmcu_types.h b/drivers/gpu/drm/amd/dal/include/dmcu_types.h
deleted file mode 100644
index b818a22..0000000
--- a/drivers/gpu/drm/amd/dal/include/dmcu_types.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright 2012-14 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_DMCU_TYPES_H__
-#define __DAL_DMCU_TYPES_H__
-
-/* Forward declaration */
-struct dmcu;
-
-/* Required information for creation and initialization of a controller */
-struct dmcu_init_data {
-	struct dal_context *dal_context;
-	struct adapter_service *as;
-	uint32_t max_engine_clock_in_khz;
-};
-
-/* Interface structure defines */
-
-enum dmcu_action {
-	DMCU_ACTION_PSR_ENABLE,
-	DMCU_ACTION_PSR_EXIT,
-	DMCU_ACTION_PSR_RFB_UPDATE,
-	DMCU_ACTION_PSR_SET,
-	DMCU_ACTION_PSR_CLEAR_COUNT,
-	DMCU_ACTION_PSR_COUNT_REQUEST,
-	DMCU_ACTION_PSR_STATE_REQUEST,
-	DMCU_ACTION_PSR_SET_LEVEL,
-	DMCU_ACTION_PSR_ADVANCE_STATE,
-	DMCU_ACTION_PSR_SET_WAITLOOP
-};
-
-enum dmcu_output {
-	DMCU_OUTPUT_PSR_ACK,
-	DMCU_OUTPUT_PSR_NACK,
-	DMCU_OUTPUT_PSR_AUX_ERR,
-	DMCU_OUTPUT_PSR_COUNT_STATUS,
-	DMCU_OUTPUT_PSR_STATE_STATUS,
-	DMCU_OUTPUT_PSR_RFB_UPDATE_ERR,
-	DMCU_OUTPUT_PSR_ERR,
-	DMCU_OUTPUT_PSR_GET_REPLY,
-	DMCU_OUTPUT_PSR_ENTRY_ERROR,
-	DMCU_OUTPUT_PSR_LT_ERROR,
-	DMCU_OUTPUT_PSR_FORCE_SR_ERROR,
-	DMCU_OUTPUT_PSR_SDP_SEND_TIMEOUT
-};
-
-/* PSR states, based similarly on states defined in eDP specification. */
-enum psr_state {
-	STATE0,		/* PSR is disabled */
-	STATE1,		/* PSR is enabled, but inactive */
-	STATE1A,
-	STATE2,		/* PSR is transitioning to active state */
-	STATE2A,
-	STATE3,		/* PSR is active; Display is in self refresh */
-	STATE3INIT,
-	STATE4,		/* RFB single frame update */
-	STATE4A,
-	STATE4B,
-	STATE4C,
-	STATE4D,
-	STATE5,		/* Exiting from PSR active state */
-	STATE5A,
-	STATE5B,
-	STATE5C
-};
-
-enum phy_type {
-	PHY_TYPE_UNKNOWN = 1,
-	PHY_TYPE_PCIE_PHY = 2,
-	PHY_TYPE_UNIPHY = 3,
-};
-
-struct dmcu_context {
-	enum channel_id channel;
-	enum transmitter transmitter_id;
-	enum engine_id engine_id;
-	enum controller_id controller_id;
-	enum phy_type phy_type;
-	enum physical_phy_id smu_physical_phy_id;
-
-	/* Vertical total pixels from crtc timing.
-	 * This is used for static screen detection.
-	 * ie. If we want to detect half a frame,
-	 * we use this to determine the hyst lines.*/
-	uint32_t crtc_timing_vertical_total;
-
-	/* PSR supported from panel capabilities
-	 * and current display configuration */
-	bool psr_supported_display_config;
-
-	/* Whether fast link training is supported by the panel */
-	bool psr_exit_link_training_required;
-
-	/* If RFB setup time is greater than the total VBLANK time, it is not
-	 * possible for the sink to capture the video frame in the same frame
-	 * the SDP is sent. In this case, the frame capture indication bit
-	 * should be set and an extra static frame should be transmitted to
-	 * the sink */
-	bool psr_frame_capture_indication_required;
-
-	/* Set the last possible line SDP may be transmitted without violating
-	 * the RFB setup time */
-	bool sdp_transmit_line_num_deadline;
-
-	/* The VSync rate in Hz used to calculate the step size
-	 * for smooth brightness feature */
-	uint32_t vsync_rate_hz;
-};
-
-union dmcu_psr_level {
-	struct {
-		bool SKIP_CRC:1;
-		bool SKIP_DP_VID_STREAM_DISABLE:1;
-		bool SKIP_PHY_POWER_DOWN:1;
-		bool SKIP_AUX_ACK_CHECK:1;
-		bool SKIP_CRTC_DISABLE:1;
-		bool SKIP_AUX_RFB_CAPTURE_CHECK:1;
-		bool SKIP_SMU_NOTIFICATION:1;
-		bool SKIP_AUTO_STATE_ADVANCE:1;
-		bool DISABLE_PSR_ENTRY_ABORT:1;
-	} bits;
-	uint32_t u32all;
-};
-
-struct dmcu_config_data {
-	/* Command sent to DMCU. */
-	enum dmcu_action action;
-	/* PSR Level controls which HW blocks to power down during PSR active,
-	 * and also other sequence modifications. */
-	union dmcu_psr_level psr_level;
-	/* To indicate that first changed frame from active state should not
-	 * result in exit to inactive state, but instead perform an automatic
-	 * single frame RFB update. */
-	bool rfb_update_auto_en;
-	/* Number of consecutive static frames to detect before entering PSR
-	 * active state. */
-	uint32_t hyst_frames;
-	/* Partial frames before entering PSR active. Note this parameter is in
-	 * units of 100 lines. i.e. Wait a value of 5 means wait 500 additional
-	 * lines. */
-	uint32_t hyst_lines;
-	/* Number of repeated AUX retries before indicating failure to driver.
-	 * In a working case, first attempt to write/read AUX should pass. */
-	uint32_t aux_repeat;
-	/* Additional delay after remote frame capture before continuing to
-	 * power down. This is mainly for debug purposes to identify timing
-	 * issues. */
-	uint32_t frame_delay;
-	/* Controls how long the delay of a wait loop is. It should be tuned
-	 * to 1 us, and needs to be reconfigured every time DISPCLK changes. */
-	uint32_t wait_loop_num;
-};
-
-struct dmcu_output_data {
-	/* DMCU reply */
-	enum dmcu_output output;
-	/* The current PSR state. */
-	uint32_t psr_state;
-	/* The number of frames during PSR active state. */
-	uint32_t psr_count;
-};
-
-enum varibright_command {
-	VARIBRIGHT_CMD_SET_VB_LEVEL = 0,
-	VARIBRIGHT_CMD_USER_ENABLE,
-	VARIBRIGHT_CMD_POST_DISPLAY_CONFIG,
-	VARIBRIGHT_CMD_UNKNOWN
-};
-
-struct varibright_control {
-	enum varibright_command command;
-	uint8_t level;
-	bool enable;
-	bool activate;
-};
-
-#endif /* __DAL_DMCU_TYPES_H__ */
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
index e0b25cb..5ff9b2f 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
@@ -32,7 +32,6 @@
 #include "include/connector_interface.h"
 #include "include/dcs_interface.h"
 #include "include/encoder_interface.h"
-#include "include/dmcu_interface.h"
 #include "include/flat_set.h"
 
 
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c b/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c
index 1df76af..fb9a912 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c
@@ -36,7 +36,6 @@
 #include "include/link_service_interface.h"
 #include "include/ddc_service_interface.h"
 #include "include/controller_interface.h"
-#include "include/dmcu_interface.h"
 #include "include/audio_interface.h"
 
 /* Internal includes */
@@ -198,14 +197,6 @@ static struct gpu *tm_resource_builder_create_gpu(
 	return gpu;
 }
 
-static struct dmcu *tm_resource_builder_create_dmcu(
-		struct tm_resource_builder *tm_rb,
-		struct gpu *gpu)
-{
-	/* TODO Create DMCU object */
-	return NULL;
-}
-
 static enum tm_result tm_resource_builder_add_engines(
 		struct tm_resource_builder *tm_rb)
 {
@@ -322,7 +313,6 @@ enum tm_result tm_resource_builder_create_gpu_resources(
 {
 	enum tm_result rc = TM_RESULT_SUCCESS;
 	struct gpu *gpu;
-	struct dmcu *dmcu;
 	struct dal_context *dal_context = tm_rb->dal_context;
 
 	do {
@@ -333,16 +323,6 @@ enum tm_result tm_resource_builder_create_gpu_resources(
 		}
 
 		/********************************************************
-		Add DMCU
-		*********************************************************/
-		dmcu = tm_resource_builder_create_dmcu(tm_rb, gpu);
-		if (!dmcu) {
-			/* not necessarily an error because
-			 * DMCU doesn't exist on discrete. */
-			TM_RESOURCES("DMCU doesn't exist.\n");
-		}
-
-		/********************************************************
 		Add Engines
 		*********************************************************/
 		rc = tm_resource_builder_add_engines(tm_rb);
@@ -1885,28 +1865,6 @@ void tm_resource_builder_sort_display_paths(struct tm_resource_builder *tm_rb)
 	tmrb_put_default_display_on_top_of_the_list(tm_rb);
 }
 
-void tm_resource_builder_assign_dmcu_resource(
-		struct tm_resource_builder *tm_rb)
-{
-	/* If embedded display is available on the system, it will be located
-	 * at diplay path index 0. */
-	struct display_path *display_path =
-			tm_resource_builder_get_path_at(tm_rb, 0);
-
-	if (display_path != NULL) {
-		struct connector_device_tag_info *tag =
-				dal_display_path_get_device_tag(display_path);
-
-		/* For LCD displays, attach DMCU object for ABM/PSR and other
-		 * embedded display related features. */
-		if (tag->dev_id.device_type == DEVICE_TYPE_LCD) {
-			struct dmcu *dmcu = tm_resource_mgr_get_dmcu(
-					tm_rb->tm_rm);
-			dal_display_path_set_dmcu(display_path, dmcu);
-		}
-	}
-}
-
 uint32_t tm_resource_builder_get_num_of_paths(
 		struct tm_resource_builder *tm_rb)
 {
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.h b/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.h
index af195c6..2175e8b 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.h
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.h
@@ -75,9 +75,6 @@ enum tm_result tm_resource_builder_add_feature_resources(
 void tm_resource_builder_sort_display_paths(
 		struct tm_resource_builder *tm_rb);
 
-void tm_resource_builder_assign_dmcu_resource(
-		struct tm_resource_builder *tm_rb);
-
 uint32_t tm_resource_builder_get_num_of_paths(
 		struct tm_resource_builder *tm_rb);
 
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
index c3afbff..443742a 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
@@ -32,7 +32,6 @@
 #include "include/controller_interface.h"
 #include "include/dcs_interface.h"
 #include "include/ddc_service_interface.h"
-#include "include/dmcu_interface.h"
 #include "include/vector.h"
 #include "include/flat_set.h"
 
@@ -54,7 +53,6 @@ struct tm_resource_mgr {
 	uint32_t link_services_number_of_paths;
 
 	struct gpu *gpu_interface;
-	struct dmcu *dmcu;
 
 	bool prioritize_controllers;
 	uint32_t active_audio_resources_num;
@@ -395,8 +393,6 @@ static void tm_resource_mgr_destruct(struct tm_resource_mgr *tm_rm)
 	/* Only the original RM should delete these objects. */
 	if (false == tm_rm->is_cloned) {
 		tm_resource_mgr_release_all_link_services(tm_rm);
-
-		/* TODO Destroy DMCU */
 	}
 
 	/* Go over all entries in tm_rm->resource_vector
@@ -466,13 +462,7 @@ void tm_resource_mgr_release_hw(struct tm_resource_mgr *tm_rm)
 	if (tm_rm->gpu_interface != NULL)
 		dal_gpu_release_hw(tm_rm->gpu_interface);
 
-	/* TODO 3. Call DMCU to release HW access */
-/*
-	if (tm_rm->dmcu != NULL)
-		dal_dmcu_release_hw(tm_rm->dmcu);
-*/
-
-	/* 4. Release HW access on all graphics objects */
+	/* 3. Release HW access on all graphics objects */
 	for (i = 0; i < tm_resource_mgr_get_total_resources_num(tm_rm); i++) {
 		tm_resource = tm_resource_mgr_enum_resource(tm_rm, i);
 		tmrm_resource_release_hw(tm_rm, tm_resource);
@@ -2518,19 +2508,6 @@ struct gpu *tm_resource_mgr_get_gpu_interface(
 }
 
 
-void tm_resource_mgr_set_dmcu(
-		struct tm_resource_mgr *tm_rm,
-		struct dmcu *dmcu)
-{
-	tm_rm->dmcu = dmcu;
-}
-
-struct dmcu *tm_resource_mgr_get_dmcu(
-		struct tm_resource_mgr *tm_rm)
-{
-	return tm_rm->dmcu;
-}
-
 /**
  * Attaches an audio to display path if available for the specified
  * signal type, and increments the reference count.
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h
index 22db64e..e5c40ad 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.h
@@ -181,12 +181,6 @@ void tm_resource_mgr_set_gpu_interface(
 struct gpu *tm_resource_mgr_get_gpu_interface(
 		struct tm_resource_mgr *tm_rm);
 
-void tm_resource_mgr_set_dmcu(
-		struct tm_resource_mgr *tm_rm,
-		struct dmcu *dmcu);
-struct dmcu *tm_resource_mgr_get_dmcu(
-		struct tm_resource_mgr *tm_rm);
-
 enum tm_result tm_resource_mgr_attach_audio_to_display_path(
 		struct tm_resource_mgr *tm_rm,
 		struct display_path *display_path,
diff --git a/drivers/gpu/drm/amd/dal/topology/topology.c b/drivers/gpu/drm/amd/dal/topology/topology.c
index 2857037..46d60e8 100644
--- a/drivers/gpu/drm/amd/dal/topology/topology.c
+++ b/drivers/gpu/drm/amd/dal/topology/topology.c
@@ -32,7 +32,6 @@
 #include "include/encoder_interface.h"
 #include "include/controller_interface.h"
 #include "include/display_path_interface.h"
-#include "include/dmcu_interface.h"
 #include "include/audio_interface.h"
 #include "include/dcs_interface.h"
 #include "include/vector.h"
@@ -267,8 +266,6 @@ static bool construct(struct topology_mgr_init_data *init_data,
 		if (tm->display_paths)
 			dal_vector_destroy(&tm->display_paths);
 
-		/* TODO: remove dmcu if was created*/
-
 		if (tm->tm_rm)
 			tm_resource_mgr_destroy(&tm->tm_rm);
 
@@ -2016,12 +2013,7 @@ enum tm_result dal_tm_init_hw(struct topology_mgr *tm)
 	 * number of pipes and wireless etc. */
 	tm_update_audio_connectivity(tm);
 
-	/* TODO 4. PowerUp DMCU - This should be done before Encoder */
-/*
-	dmcu = tm_resource_mgr_get_dmcu(tm->tm_rm);
-	if (dmcu != NULL)
-		dal_dmcu_power_up(dmcu);
-*/
+	/* 4. TODO PowerUp DMCU - This should be done before Encoder */
 
 	/* 5. PowerUp controllers :move to step0 to make sure init front pipe*/
 
@@ -2082,11 +2074,6 @@ enum tm_result dal_tm_power_down_hw(struct topology_mgr *tm)
 	TM_NOT_IMPLEMENTED();
 
 	/* TODO 2. PowerDown DMCU*/
-/*
-	dmcu = tm_resource_mgr_get_dmcu(tm->tm_rm);
-	if (dmcu != NULL)
-		dal_dmcu_power_down(dmcu);
-*/
 
 	/* 3.0 If we are going to S4 or BACO,
 	 * then we only need to invalidate states
@@ -4161,7 +4148,6 @@ static enum tm_result miscellaneous_init(struct topology_mgr *tm)
 	tm_resource_builder_sort_display_paths(tm->tm_rb);
 
 	/* Step 6. Assign display path specific resources */
-	tm_resource_builder_assign_dmcu_resource(tm->tm_rb);
 
 	/* Step 7. Check number of paths */
 	if (!tm_resource_builder_get_num_of_paths(tm->tm_rb)) {
-- 
1.9.1

