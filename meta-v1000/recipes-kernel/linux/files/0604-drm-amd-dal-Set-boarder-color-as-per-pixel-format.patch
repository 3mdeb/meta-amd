From 12527fc4007894daaa658a22ff17b9ad72f2b1f4 Mon Sep 17 00:00:00 2001
From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Wed, 6 Jul 2016 10:35:41 -0400
Subject: [PATCH 0604/1722] drm/amd/dal: Set boarder color as per pixel format

Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>

Change-Id: Icaf8544f264744b5d30e85333ff65cff827bdcb7
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  81 ++++++++++++-
 .../amd/dal/dc/dce110/dce110_timing_generator.c    | 125 +++++----------------
 .../amd/dal/dc/dce110/dce110_timing_generator.h    |  32 +-----
 .../amd/dal/dc/dce110/dce110_timing_generator_v.c  | 113 +++++--------------
 .../gpu/drm/amd/dal/dc/inc/hw/timing_generator.h   |  17 +--
 5 files changed, 147 insertions(+), 221 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 7db254f..84fe29e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -31,6 +31,7 @@
 #include "hw_sequencer.h"
 #include "dm_helpers.h"
 #include "dce110_hw_sequencer.h"
+#include "dce110_timing_generator.h"
 
 #include "gpu/dce110/dc_clock_gating_dce110.h"
 
@@ -1421,8 +1422,82 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 					pipe_ctx->opp, &default_adjust);
 }
 
-static void program_scaler(const struct pipe_ctx *pipe_ctx)
+static void get_overscan_black_color(enum dc_color_space color_space, struct tg_color *color)
 {
+	/* Overscan Color for YUV display modes:
+	 * to achieve a black color for both the explicit and implicit overscan,
+	 * the overscan color registers should be programmed to: */
+
+	switch (color_space) {
+	case COLOR_SPACE_YPBPR601:
+		color->color_b_cb = 0x200; 	/* BLACK_COLOR_B_CB_YUV_4TV */
+		color->color_g_y = 0x40; 	/* BLACK_COLOR_G_Y_YUV_4TV  */
+		color->color_r_cr = 0x200; 	/* BLACK_COLOR_R_CR_YUV_4TV */
+		break;
+
+	case COLOR_SPACE_YPBPR709:
+	case COLOR_SPACE_YCBCR601:
+	case COLOR_SPACE_YCBCR709:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
+		color->color_b_cb = 0x1f4;	/* BLACK_COLOR_B_CB_YUV_4CV */
+		color->color_g_y = 0x40; 	/* BLACK_COLOR_G_Y_YUV_4TV  */
+		color->color_r_cr = 0x1f4;	/* BLACK_COLOR_R_CR_YUV_4CV */
+		break;
+
+	case COLOR_SPACE_SRGB_LIMITED:
+		/* OVERSCAN COLOR FOR RGB LIMITED RANGE
+		 * (16~253) 16*4 (Multiple over 256 code leve) =64 (0x40) */
+		color->color_b_cb = 0x40;
+		color->color_g_y = 0x40;
+		color->color_r_cr = 0x40;
+		break;
+
+	default:
+		/* default is sRGB black 0. */
+		break;
+	}
+}
+
+static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
+		struct tg_color *color)
+{
+	uint32_t color_value = MAX_TG_COLOR_VALUE * (4 - pipe_ctx->pipe_idx) / 4;
+
+	switch (pipe_ctx->scl_data.format) {
+	case PIXEL_FORMAT_ARGB8888:
+		/* set boarder color to red */
+		color->color_r_cr = color_value;
+		break;
+
+	case PIXEL_FORMAT_ARGB2101010:
+		/* set boarder color to blue */
+		color->color_b_cb = color_value;
+		break;
+	case PIXEL_FORMAT_420BPP12:
+		/* set boarder color to green */
+		color->color_g_y = color_value;
+		break;
+	case PIXEL_FORMAT_FP16:
+		/* set boarder color to white */
+		color->color_r_cr = color_value;
+		color->color_b_cb = color_value;
+		color->color_g_y = color_value;
+		break;
+	default:
+		break;
+	}
+}
+
+static void program_scaler(const struct core_dc *dc, const struct pipe_ctx *pipe_ctx)
+{
+	struct tg_color color = {0};
+
+	if (dc->public.debug.surface_visual_confirm)
+		get_surface_visual_confirm_color(pipe_ctx, &color);
+	else
+		get_overscan_black_color(pipe_ctx->stream->public.output_color_space, &color);
+
 	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
 		pipe_ctx->xfm,
 		LB_PIXEL_DEPTH_30BPP,
@@ -1430,7 +1505,7 @@ static void program_scaler(const struct pipe_ctx *pipe_ctx)
 
 	pipe_ctx->tg->funcs->set_overscan_blank_color(
 		pipe_ctx->tg,
-		pipe_ctx->stream->public.output_color_space);
+		&color);
 
 	pipe_ctx->xfm->funcs->transform_set_scaler(pipe_ctx->xfm, &pipe_ctx->scl_data);
 }
@@ -1454,7 +1529,7 @@ static void set_plane_config(
 
 	set_default_colors(pipe_ctx);
 
-	program_scaler(pipe_ctx);
+	program_scaler(dc, pipe_ctx);
 
 	for (i = pipe_ctx->pipe_idx + 1; i < MAX_PIPES; i++)
 		if (res_ctx->pipe_ctx[i].stream == pipe_ctx->stream) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index 9bab93e..1beed55 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -155,25 +155,17 @@ static const struct timing_generator_funcs dce110_tg_funcs = {
 
 };
 
-static const struct crtc_black_color black_color_format[] = {
+static const struct tg_color black_color_format[] = {
 	/* BlackColorFormat_RGB_FullRange */
 	{0, 0, 0},
 	/* BlackColorFormat_RGB_Limited */
-	{CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_RGB_LIMITED_RANGE,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_RGB_LIMITED_RANGE,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_RGB_LIMITED_RANGE},
+	{0x40, 0x40, 0x40},
 	/* BlackColorFormat_YUV_TV */
-	{CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4TV,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4TV,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4TV},
+	{0x200, 0x40, 0x200},
 	/* BlackColorFormat_YUV_CV */
-	{CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4CV,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4CV,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4CV},
+	{0x1f4, 0x40, 0x1f4},
 	/* BlackColorFormat_YUV_SuperAA */
-	{CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4SUPERAA,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4SUPERAA,
-		CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4SUPERAA}
+	{0x1a2, 0x20, 0x1a2},
 };
 
 /**
@@ -197,7 +189,7 @@ static void dce110_timing_generator_apply_front_porch_workaround(
 
 void dce110_timing_generator_color_space_to_black_color(
 		enum dc_color_space colorspace,
-	struct crtc_black_color *black_color)
+	struct tg_color *black_color)
 {
 	switch (colorspace) {
 	case COLOR_SPACE_YPBPR601:
@@ -301,7 +293,7 @@ void dce110_timing_generator_program_blank_color(
 		struct timing_generator *tg,
 		enum dc_color_space color_space)
 {
-	struct crtc_black_color black_color;
+	struct tg_color black_color;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_BLACK_COLOR);
 	uint32_t value = dm_read_reg(tg->ctx, addr);
@@ -312,17 +304,17 @@ void dce110_timing_generator_program_blank_color(
 
 	set_reg_field_value(
 		value,
-		black_color.black_color_b_cb,
+		black_color.color_b_cb,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_B_CB);
 	set_reg_field_value(
 		value,
-		black_color.black_color_g_y,
+		black_color.color_g_y,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_G_Y);
 	set_reg_field_value(
 		value,
-		black_color.black_color_r_cr,
+		black_color.color_r_cr,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_R_CR);
 
@@ -1558,92 +1550,31 @@ void dce110_timing_generator_disable_vga(
 
 void dce110_timing_generator_set_overscan_color_black(
 	struct timing_generator *tg,
-	enum dc_color_space black_color)
+	const struct tg_color *color)
 {
 	struct dc_context *ctx = tg->ctx;
-	uint32_t value = 0;
 	uint32_t addr;
+	uint32_t value = 0;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
-	/* Overscan Color for YUV display modes:
-	 * to achieve a black color for both the explicit and implicit overscan,
-	 * the overscan color registers should be programmed to: */
-
-	switch (black_color) {
-	case COLOR_SPACE_YPBPR601:
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4TV,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_BLUE);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4TV,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_GREEN);
 
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4TV,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_RED);
-		break;
-
-	case COLOR_SPACE_YPBPR709:
-	case COLOR_SPACE_YCBCR601:
-	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_LIMITED:
-	case COLOR_SPACE_YCBCR709_LIMITED:
-		set_reg_field_value(
+	set_reg_field_value(
 			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4CV,
+			color->color_b_cb,
 			CRTC_OVERSCAN_COLOR,
 			CRTC_OVERSCAN_COLOR_BLUE);
 
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4TV,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_GREEN);
-
-		set_reg_field_value(
+	set_reg_field_value(
 			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4CV,
+			color->color_r_cr,
 			CRTC_OVERSCAN_COLOR,
 			CRTC_OVERSCAN_COLOR_RED);
-		break;
 
-	case COLOR_SPACE_SRGB_LIMITED:
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_RGB_LIMITED_RANGE,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_BLUE);
-
-		set_reg_field_value(
+	set_reg_field_value(
 			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_RGB_LIMITED_RANGE,
+			color->color_g_y,
 			CRTC_OVERSCAN_COLOR,
 			CRTC_OVERSCAN_COLOR_GREEN);
 
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_RGB_LIMITED_RANGE,
-			CRTC_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_RED);
-		break;
-
-	default:
-		/* default is sRGB black 0. */
-		if (tg->ctx->dc->debug.surface_visual_confirm) {
-			set_reg_field_value(
-				value,
-				0x3ff,
-				CRTC_OVERSCAN_COLOR,
-				CRTC_OVERSCAN_COLOR_RED);
-		}
-		break;
-	}
 	addr = CRTC_REG(mmCRTC_OVERSCAN_COLOR);
 	dm_write_reg(ctx, addr, value);
 	addr = CRTC_REG(mmCRTC_BLACK_COLOR);
@@ -1666,7 +1597,7 @@ void dce110_timing_generator_set_overscan_color_black(
 }
 
 void dce110_tg_program_blank_color(struct timing_generator *tg,
-		const struct crtc_black_color *black_color)
+		const struct tg_color *black_color)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = CRTC_REG(mmCRTC_BLACK_COLOR);
@@ -1674,17 +1605,17 @@ void dce110_tg_program_blank_color(struct timing_generator *tg,
 
 	set_reg_field_value(
 		value,
-		black_color->black_color_b_cb,
+		black_color->color_b_cb,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_B_CB);
 	set_reg_field_value(
 		value,
-		black_color->black_color_g_y,
+		black_color->color_g_y,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_G_Y);
 	set_reg_field_value(
 		value,
-		black_color->black_color_r_cr,
+		black_color->color_r_cr,
 		CRTC_BLACK_COLOR,
 		CRTC_BLACK_COLOR_R_CR);
 
@@ -1695,7 +1626,7 @@ void dce110_tg_program_blank_color(struct timing_generator *tg,
 }
 
 void dce110_tg_set_overscan_color(struct timing_generator *tg,
-	const struct crtc_black_color *overscan_color)
+	const struct tg_color *overscan_color)
 {
 	struct dc_context *ctx = tg->ctx;
 	uint32_t value = 0;
@@ -1704,19 +1635,19 @@ void dce110_tg_set_overscan_color(struct timing_generator *tg,
 
 	set_reg_field_value(
 		value,
-		overscan_color->black_color_b_cb,
+		overscan_color->color_b_cb,
 		CRTC_OVERSCAN_COLOR,
 		CRTC_OVERSCAN_COLOR_BLUE);
 
 	set_reg_field_value(
 		value,
-		overscan_color->black_color_g_y,
+		overscan_color->color_g_y,
 		CRTC_OVERSCAN_COLOR,
 		CRTC_OVERSCAN_COLOR_GREEN);
 
 	set_reg_field_value(
 		value,
-		overscan_color->black_color_r_cr,
+		overscan_color->color_r_cr,
 		CRTC_OVERSCAN_COLOR,
 		CRTC_OVERSCAN_COLOR_RED);
 
@@ -1779,8 +1710,8 @@ void dce110_tg_wait_for_state(struct timing_generator *tg,
 }
 
 void dce110_tg_set_colors(struct timing_generator *tg,
-	const struct crtc_black_color *blank_color,
-	const struct crtc_black_color *overscan_color)
+	const struct tg_color *blank_color,
+	const struct tg_color *overscan_color)
 {
 	if (blank_color != NULL)
 		dce110_tg_program_blank_color(tg, blank_color);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
index a3079ce..c1cb75d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.h
@@ -30,26 +30,6 @@
 #include "../include/grph_object_id.h"
 #include "../include/hw_sequencer_types.h"
 
-/* overscan in blank for YUV color space. For RGB, it is zero for black. */
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4CV 0x1f4
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4CV 0x40
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4CV 0x1f4
-
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4TV 0x200
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4TV 0x40
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4TV 0x200
-
-/* overscan in blank for YUV color space when in SuperAA crossfire mode */
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4SUPERAA 0x1a2
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4SUPERAA 0x20
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4SUPERAA 0x1a2
-
-/* OVERSCAN COLOR FOR RGB LIMITED RANGE
- * (16~253) 16*4 (Multiple over 256 code leve) =64 (0x40) */
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_RGB_LIMITED_RANGE 0x40
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_RGB_LIMITED_RANGE 0x40
-#define CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_RGB_LIMITED_RANGE 0X40
-
 struct dce110_timing_generator_offsets {
 	int32_t crtc;
 	int32_t dcp;
@@ -169,10 +149,10 @@ void dce110_timing_generator_program_blank_color(
 /* Combine with above and move YUV/RGB color conversion to SW layer */
 void dce110_timing_generator_set_overscan_color_black(
 	struct timing_generator *tg,
-	enum dc_color_space black_color);
+	const struct tg_color *color);
 void dce110_timing_generator_color_space_to_black_color(
 		enum dc_color_space colorspace,
-	struct crtc_black_color *black_color);
+	struct tg_color *black_color);
 /*************** End-of-move ********************/
 
 /* Not called yet */
@@ -202,10 +182,10 @@ void dce110_timing_generator_set_lock_master(struct timing_generator *tg,
 		bool lock);
 
 void dce110_tg_program_blank_color(struct timing_generator *tg,
-	const struct crtc_black_color *black_color);
+	const struct tg_color *black_color);
 
 void dce110_tg_set_overscan_color(struct timing_generator *tg,
-	const struct crtc_black_color *overscan_color);
+	const struct tg_color *overscan_color);
 
 void dce110_tg_get_position(struct timing_generator *tg,
 	struct crtc_position *position);
@@ -224,7 +204,7 @@ void dce110_tg_wait_for_state(struct timing_generator *tg,
 	enum crtc_state state);
 
 void dce110_tg_set_colors(struct timing_generator *tg,
-	const struct crtc_black_color *blank_color,
-	const struct crtc_black_color *overscan_color);
+	const struct tg_color *blank_color,
+	const struct tg_color *overscan_color);
 
 #endif /* __DC_TIMING_GENERATOR_DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
index e6a9288..21ec085 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
@@ -454,7 +454,7 @@ static void dce110_timing_generator_v_program_blank_color(
 		struct timing_generator *tg,
 		enum dc_color_space color_space)
 {
-	struct crtc_black_color black_color;
+	struct tg_color black_color;
 	uint32_t addr = mmCRTCV_BLACK_COLOR;
 	uint32_t value = dm_read_reg(tg->ctx, addr);
 
@@ -464,17 +464,17 @@ static void dce110_timing_generator_v_program_blank_color(
 
 	set_reg_field_value(
 		value,
-		black_color.black_color_b_cb,
+		black_color.color_b_cb,
 		CRTCV_BLACK_COLOR,
 		CRTC_BLACK_COLOR_B_CB);
 	set_reg_field_value(
 		value,
-		black_color.black_color_g_y,
+		black_color.color_g_y,
 		CRTCV_BLACK_COLOR,
 		CRTC_BLACK_COLOR_G_Y);
 	set_reg_field_value(
 		value,
-		black_color.black_color_r_cr,
+		black_color.color_r_cr,
 		CRTCV_BLACK_COLOR,
 		CRTC_BLACK_COLOR_R_CR);
 
@@ -483,92 +483,30 @@ static void dce110_timing_generator_v_program_blank_color(
 
 static void dce110_timing_generator_v_set_overscan_color_black(
 	struct timing_generator *tg,
-	enum dc_color_space black_color)
+	const struct tg_color *color)
 {
 	struct dc_context *ctx = tg->ctx;
-	uint32_t value = 0;
 	uint32_t addr;
+	uint32_t value = 0;
 
-	/* Overscan Color for YUV display modes:
-	 * to achieve a black color for both the explicit and implicit overscan,
-	 * the overscan color registers should be programmed to: */
-
-	switch (black_color) {
-	case COLOR_SPACE_YPBPR601:
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4TV,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_BLUE);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4TV,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_GREEN);
-
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4TV,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_RED);
-		break;
-
-	case COLOR_SPACE_YPBPR709:
-	case COLOR_SPACE_YCBCR601:
-	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_LIMITED:
-	case COLOR_SPACE_YCBCR709_LIMITED:
-		set_reg_field_value(
+	set_reg_field_value(
 			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_CB_YUV_4CV,
-			CRTCV_OVERSCAN_COLOR,
+			color->color_b_cb,
+			CRTC_OVERSCAN_COLOR,
 			CRTC_OVERSCAN_COLOR_BLUE);
 
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_Y_YUV_4TV,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_GREEN);
-
-		set_reg_field_value(
+	set_reg_field_value(
 			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_CR_YUV_4CV,
-			CRTCV_OVERSCAN_COLOR,
+			color->color_r_cr,
+			CRTC_OVERSCAN_COLOR,
 			CRTC_OVERSCAN_COLOR_RED);
-		break;
 
-	case COLOR_SPACE_SRGB_LIMITED:
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_B_RGB_LIMITED_RANGE,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_BLUE);
-
-		set_reg_field_value(
+	set_reg_field_value(
 			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_G_RGB_LIMITED_RANGE,
-			CRTCV_OVERSCAN_COLOR,
+			color->color_g_y,
+			CRTC_OVERSCAN_COLOR,
 			CRTC_OVERSCAN_COLOR_GREEN);
 
-		set_reg_field_value(
-			value,
-			CRTC_OVERSCAN_COLOR_BLACK_COLOR_R_RGB_LIMITED_RANGE,
-			CRTCV_OVERSCAN_COLOR,
-			CRTC_OVERSCAN_COLOR_RED);
-		break;
-
-	default:
-		/* default is sRGB black 0. */
-		if (tg->ctx->dc->debug.surface_visual_confirm) {
-			set_reg_field_value(
-				value,
-				0x3ff,
-				CRTCV_OVERSCAN_COLOR,
-				CRTC_OVERSCAN_COLOR_GREEN);
-		}
-		break;
-	}
 	addr = mmCRTCV_OVERSCAN_COLOR;
 	dm_write_reg(ctx, addr, value);
 	addr = mmCRTCV_BLACK_COLOR;
@@ -587,28 +525,27 @@ static void dce110_timing_generator_v_set_overscan_color_black(
 	 * m_mmDxCRTC_BLACK_COLOR_EXT
 	 * m_mmDxCRTC_BLANK_DATA_COLOR_EXT
 	 */
-
 }
 
 static void dce110_tg_v_program_blank_color(struct timing_generator *tg,
-		const struct crtc_black_color *black_color)
+		const struct tg_color *black_color)
 {
 	uint32_t addr = mmCRTCV_BLACK_COLOR;
 	uint32_t value = dm_read_reg(tg->ctx, addr);
 
 	set_reg_field_value(
 		value,
-		black_color->black_color_b_cb,
+		black_color->color_b_cb,
 		CRTCV_BLACK_COLOR,
 		CRTC_BLACK_COLOR_B_CB);
 	set_reg_field_value(
 		value,
-		black_color->black_color_g_y,
+		black_color->color_g_y,
 		CRTCV_BLACK_COLOR,
 		CRTC_BLACK_COLOR_G_Y);
 	set_reg_field_value(
 		value,
-		black_color->black_color_r_cr,
+		black_color->color_r_cr,
 		CRTCV_BLACK_COLOR,
 		CRTC_BLACK_COLOR_R_CR);
 
@@ -619,7 +556,7 @@ static void dce110_tg_v_program_blank_color(struct timing_generator *tg,
 }
 
 static void dce110_timing_generator_v_set_overscan_color(struct timing_generator *tg,
-	const struct crtc_black_color *overscan_color)
+	const struct tg_color *overscan_color)
 {
 	struct dc_context *ctx = tg->ctx;
 	uint32_t value = 0;
@@ -627,19 +564,19 @@ static void dce110_timing_generator_v_set_overscan_color(struct timing_generator
 
 	set_reg_field_value(
 		value,
-		overscan_color->black_color_b_cb,
+		overscan_color->color_b_cb,
 		CRTCV_OVERSCAN_COLOR,
 		CRTC_OVERSCAN_COLOR_BLUE);
 
 	set_reg_field_value(
 		value,
-		overscan_color->black_color_g_y,
+		overscan_color->color_g_y,
 		CRTCV_OVERSCAN_COLOR,
 		CRTC_OVERSCAN_COLOR_GREEN);
 
 	set_reg_field_value(
 		value,
-		overscan_color->black_color_r_cr,
+		overscan_color->color_r_cr,
 		CRTCV_OVERSCAN_COLOR,
 		CRTC_OVERSCAN_COLOR_RED);
 
@@ -648,8 +585,8 @@ static void dce110_timing_generator_v_set_overscan_color(struct timing_generator
 }
 
 static void dce110_timing_generator_v_set_colors(struct timing_generator *tg,
-	const struct crtc_black_color *blank_color,
-	const struct crtc_black_color *overscan_color)
+	const struct tg_color *blank_color,
+	const struct tg_color *overscan_color)
 {
 	if (blank_color != NULL)
 		dce110_tg_v_program_blank_color(tg, blank_color);
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
index 1c6d43b..f5f654a 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
@@ -31,10 +31,13 @@ struct dc_bios;
 /**
  *  These parameters are required as input when doing blanking/Unblanking
 */
-struct crtc_black_color {
-	uint32_t black_color_r_cr;
-	uint32_t black_color_g_y;
-	uint32_t black_color_b_cb;
+#define MAX_TG_COLOR_VALUE 0x3FF
+
+struct tg_color {
+	/* Maximum 10 bits color value */
+	uint16_t color_r_cr;
+	uint16_t color_g_y;
+	uint16_t color_b_cb;
 };
 
 /* Contains CRTC vertical/horizontal pixel counters */
@@ -128,11 +131,11 @@ struct timing_generator_funcs {
 							enum crtc_state state);
 	bool (*set_blank)(struct timing_generator *tg,
 					   bool enable_blanking);
-	void (*set_overscan_blank_color) (struct timing_generator *tg, enum dc_color_space black_color);
+	void (*set_overscan_blank_color) (struct timing_generator *tg, const struct tg_color *color);
 	void (*set_blank_color)(struct timing_generator *tg, enum dc_color_space black_color);
 	void (*set_colors)(struct timing_generator *tg,
-						const struct crtc_black_color *blank_color,
-						const struct crtc_black_color *overscan_color);
+						const struct tg_color *blank_color,
+						const struct tg_color *overscan_color);
 
 	void (*disable_vga)(struct timing_generator *tg);
 	bool (*did_triggered_reset_occur)(struct timing_generator *tg);
-- 
2.7.4

