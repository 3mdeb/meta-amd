From 3d92b63e83a220c4b0ba5b501ec578cd23f8e4a7 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Fri, 20 May 2016 17:21:06 -0400
Subject: [PATCH 0502/1722] drm/amd/dal: don't split plane for older asics

Was spliting plane for any display with pixel clock above
500000 on any asic.

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c          |   4 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c | 103 --------------------------
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h   |   4 +
 3 files changed, 7 insertions(+), 104 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 5657e66..77a93f5 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -949,7 +949,9 @@ bool dc_commit_surfaces_to_target(
 		goto unexpected_fail;
 	}
 
-	resource_map_vmin_resources(core_dc, context);
+	if (core_dc->res_pool.funcs->map_vmin_resources) {
+		core_dc->res_pool.funcs->map_vmin_resources(core_dc, context);
+	}
 
 	if (prev_disp_clk < context->bw_results.dispclk_khz ||
 		(is_mpo_turning_on &&
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index ded5f98..d7e2ba4 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -949,109 +949,6 @@ void validate_guaranteed_copy_target(
 	}
 }
 
-static void split_stream_across_pipes(
-		struct validate_context *context,
-		struct pipe_ctx *primary_pipe,
-		struct pipe_ctx *secondary_pipe)
-{
-	int secondary_pipe_idx = secondary_pipe->pipe_idx;
-	/* Use same back-end as original pipe */
-	*secondary_pipe = *primary_pipe;
-	secondary_pipe->primary_pipe = primary_pipe;
-	secondary_pipe->secondary_pipe = NULL;
-	primary_pipe->secondary_pipe = secondary_pipe;
-	primary_pipe->primary_pipe = NULL;
-	secondary_pipe->pipe_idx = secondary_pipe_idx;
-
-	/* Only acquire different front end objects */
-	secondary_pipe->mi = context->res_ctx.pool.mis[secondary_pipe->pipe_idx];
-	secondary_pipe->ipp = context->res_ctx.pool.ipps[secondary_pipe->pipe_idx];
-	secondary_pipe->xfm = context->res_ctx.pool.transforms[secondary_pipe->pipe_idx];
-	secondary_pipe->opp = context->res_ctx.pool.opps[secondary_pipe->pipe_idx];
-
-	if (primary_pipe->surface) {
-		/* Todo: account for truncation error */
-		primary_pipe->scl_data.viewport.width /= 2;
-		primary_pipe->scl_data.recout.width /= 2;
-
-		secondary_pipe->scl_data = primary_pipe->scl_data;
-		secondary_pipe->scl_data.viewport.x =
-				primary_pipe->scl_data.viewport.width
-				+ primary_pipe->scl_data.viewport.x;
-		secondary_pipe->scl_data.recout.x =
-				primary_pipe->scl_data.recout.width
-				+ primary_pipe->scl_data.recout.x;
-	}
-}
-
-enum dc_status resource_map_vmin_resources(
-		const struct core_dc *dc,
-		struct validate_context *context) {
-	/* TODO: Temporary hack. Forcing vmin here, one stream two pipes */
-	/* TODO: Lower  clock, change timing, etc? */
-
-	/* This function is called dc_validate_resources, dc_commit_targets,
-	 * by dc_commit_surfaces_to_target, each of them will
-	 * re-allocation buffer using
-	 * context = dm_alloc(sizeof(struct validate_context));
-	 * so pointer to buffer may be changed. In case save pointer to buffer
-	 * , handle will be needed
-	 */
-	if (context->target_count == 1 && context->targets[0]->public.stream_count == 1) {
-
-		int i;
-		struct pipe_ctx *primary_pipe = NULL;
-		struct pipe_ctx *secondary_pipe = NULL;
-
-		/* Only enable for 4k@60 displays */
-		struct core_stream *stream = DC_STREAM_TO_CORE(context->targets[0]->public.streams[0]);
-
-		if (stream->phy_pix_clk < 500000)
-			return DC_OK;
-
-		/* Find first pipe, assume it already has viewport calculated */
-		for (i = 0; i < context->res_ctx.pool.pipe_count; i++) {
-			if (context->res_ctx.pipe_ctx[i].stream) {
-				primary_pipe = &context->res_ctx.pipe_ctx[i];
-				break;
-			}
-		}
-
-		if (primary_pipe == NULL) {
-			BREAK_TO_DEBUGGER();
-			return DC_NO_CONTROLLER_RESOURCE;
-		}
-
-		/* Determine if we've already acquired a vmin pipe previously */
-		if (primary_pipe->secondary_pipe)
-			secondary_pipe = primary_pipe->secondary_pipe;
-		else {
-			for (i = 0; i < context->res_ctx.pool.pipe_count; i++) {
-				if (context->res_ctx.pipe_ctx[i].stream == NULL) {
-					secondary_pipe = &context->res_ctx.pipe_ctx[i];
-					secondary_pipe->pipe_idx = i;
-					break;
-				}
-			}
-
-		}
-
-		if (secondary_pipe == NULL) {
-			dal_logger_write(dc->ctx->logger,
-						LOG_MAJOR_TM,
-						LOG_MINOR_TM_RESOURCES,
-						"%s: Failed to find additional pipe resource, driving one pipe\n",
-						__func__);
-			return DC_OK;
-		}
-
-		split_stream_across_pipes(context, primary_pipe,
-				secondary_pipe);
-
-	}
-	return DC_OK;
-}
-
 static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 	struct encoder_info_frame *encoder_info_frame)
 {
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 5d9af4e..ef0bb23 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -233,6 +233,10 @@ struct resource_funcs {
 	enum dc_status (*validate_bandwidth)(
 					const struct core_dc *dc,
 					struct validate_context *context);
+
+	enum dc_status (*map_vmin_resources)(
+					const struct core_dc *dc,
+					struct validate_context *context);
 };
 
 struct resource_pool {
-- 
2.7.4

