From ba110bcfaf4343839f7c3d45fc002f1d6c7f443c Mon Sep 17 00:00:00 2001
From: Tony Cheng <tony.cheng@amd.com>
Date: Mon, 19 Sep 2016 23:06:21 -0400
Subject: [PATCH 1303/1722] drm/amd/dal: audio instanciation refactor

- enable us to keep all register offset, shift and mask initialization in 1 place, dce*_resource.c
- compiler will check and throw an error if a register offset/shift/mask does not exist on that particular asic
- maximize code reuse between different DCE, while take care of delta between regsiter offset and fields

*note this is probably a good practice for most HW block, as HW often goes through evualtion rather than re-architecture.
hw often add new register fields to be programmed in new generation to enable new feature or power saving, however
usually the base programming sequence remains the same.  a 0 offset/shift/mask can easily identify that a register/field
does not exist on an asic and the corresponding programming can be skipped.

*note this is probably not necessary for audio, as the shift/mask is the same between different version.

Change-Id: If9ee51171b3c80b3c080b5442a2053ec6491aa56
Signed-off-by: Tony Cheng <tony.cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/dc_helper.c             |  18 ++--
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  13 ++-
 drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h   |  63 +++++++++++-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c   |  14 ++-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  14 ++-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  12 ++-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  11 ++-
 drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h        | 107 +++++++++++----------
 8 files changed, 182 insertions(+), 70 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/dc_helper.c b/drivers/gpu/drm/amd/dal/dc/dc_helper.c
index 9a50ddf..841d58b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_helper.c
+++ b/drivers/gpu/drm/amd/dal/dc/dc_helper.c
@@ -16,19 +16,19 @@ uint32_t generic_reg_update_ex(const struct dc_context *ctx,
 	va_list ap;
 	va_start(ap, n);
 
-	 while (i < n) {
+	while (i < n) {
 		shift = va_arg(ap, uint32_t);
 		mask = va_arg(ap, uint32_t);
 		field_value = va_arg(ap, uint32_t);
 
 		reg_val = set_reg_field_value_ex(reg_val, field_value, mask, shift);
 		i++;
-	  }
+	}
 
-	 dm_write_reg(ctx, addr, reg_val);
-	 va_end(ap);
+	dm_write_reg(ctx, addr, reg_val);
+	va_end(ap);
 
-	 return reg_val;
+	return reg_val;
 }
 
 uint32_t generic_reg_get(const struct dc_context *ctx, uint32_t addr,
@@ -65,18 +65,18 @@ uint32_t generic_reg_get(const struct dc_context *ctx,
 	va_list ap;
 	va_start(ap, n);
 
-	 while (i < n) {
+	while (i < n) {
 		shift = va_arg(ap, uint32_t);
 		mask = va_arg(ap, uint32_t);
 		field_value = va_arg(ap, uint32_t *);
 
 		*field_value = get_reg_field_value_ex(reg_val, mask, shift);
 		i++;
-	  }
+	}
 
-	 va_end(ap);
+	va_end(ap);
 
-	 return reg_val;
+	return reg_val;
 }
 */
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index ba8eb49..6cb7465 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -45,6 +45,8 @@
 #include "dce110/audio_dce110.h"
 #include "dce100/dce100_hw_sequencer.h"
 #include "dce/dce_10_0_d.h"
+#include "dce/dce_10_0_sh_mask.h"
+
 
 #ifndef mmDP_DPHY_INTERNAL_CTRL
 	#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7
@@ -298,6 +300,15 @@ static const struct dce110_audio_registers audio_regs[] = {
 	audio_regs(6),
 };
 
+static const struct dce110_audio_shift audio_shift = {
+		AUD_COMMON_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce110_aduio_mask audio_mask = {
+		AUD_COMMON_MASK_SH_LIST(_MASK)
+};
+
+
 #define DCFE_MEM_PWR_CTRL_REG_BASE 0x1b03
 
 static const struct dce110_opp_reg_offsets dce100_opp_reg_offsets[] = {
@@ -933,7 +944,7 @@ static bool construct(
 		}
 
 		pool->base.audios[i] = dce110_audio_create(
-				ctx, i, &audio_regs[i]);
+				ctx, i, &audio_regs[i], &audio_shift, &audio_mask);
 		if (pool->base.audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error("DC: failed to create DPPs!\n");
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h b/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h
index b950d43..cbba99e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h
@@ -43,6 +43,28 @@
 	AUD_COMMON_REG_LIST_BASE(id)
 
 
+ /* set field name */
+#define SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+
+#define AUD_COMMON_MASK_SH_LIST_BASE(mask_sh)\
+		SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO0_SOURCE_SEL, mask_sh),\
+		SF(DCCG_AUDIO_DTO_SOURCE, DCCG_AUDIO_DTO_SEL, mask_sh),\
+		SF(DCCG_AUDIO_DTO0_MODULE, DCCG_AUDIO_DTO0_MODULE, mask_sh),\
+		SF(DCCG_AUDIO_DTO0_PHASE, DCCG_AUDIO_DTO0_PHASE, mask_sh),\
+		SF(DCCG_AUDIO_DTO0_MODULE, DCCG_AUDIO_DTO0_MODULE, mask_sh),\
+		SF(DCCG_AUDIO_DTO0_PHASE, DCCG_AUDIO_DTO0_PHASE, mask_sh),\
+		SF(AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES, AUDIO_RATE_CAPABILITIES, mask_sh),\
+		SF(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES, CLKSTOP, mask_sh),\
+		SF(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES, EPSS, mask_sh)
+
+#define AUD_COMMON_MASK_SH_LIST(mask_sh)\
+		AUD_COMMON_MASK_SH_LIST_BASE(mask_sh),\
+		SF(AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\
+		SF(AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh)
+
+
 struct dce110_audio_registers {
 	uint32_t AZALIA_F0_CODEC_ENDPOINT_INDEX;
 	uint32_t AZALIA_F0_CODEC_ENDPOINT_DATA;
@@ -56,11 +78,48 @@ struct dce110_audio_registers {
 	uint32_t DCCG_AUDIO_DTO0_PHASE;
 	uint32_t DCCG_AUDIO_DTO1_MODULE;
 	uint32_t DCCG_AUDIO_DTO1_PHASE;
+
+	uint32_t AUDIO_RATE_CAPABILITIES;
+};
+
+struct dce110_audio_shift {
+	uint8_t AZALIA_ENDPOINT_REG_INDEX;
+	uint8_t AZALIA_ENDPOINT_REG_DATA;
+
+	uint8_t AUDIO_RATE_CAPABILITIES;
+	uint8_t CLKSTOP;
+	uint8_t EPSS;
+
+	uint8_t DCCG_AUDIO_DTO0_SOURCE_SEL;
+	uint8_t DCCG_AUDIO_DTO_SEL;
+	uint8_t DCCG_AUDIO_DTO0_MODULE;
+	uint8_t DCCG_AUDIO_DTO0_PHASE;
+	uint8_t DCCG_AUDIO_DTO1_MODULE;
+	uint8_t DCCG_AUDIO_DTO1_PHASE;
+};
+
+struct dce110_aduio_mask {
+	uint32_t AZALIA_ENDPOINT_REG_INDEX;
+	uint32_t AZALIA_ENDPOINT_REG_DATA;
+
+	uint32_t AUDIO_RATE_CAPABILITIES;
+	uint32_t CLKSTOP;
+	uint32_t EPSS;
+
+	uint32_t DCCG_AUDIO_DTO0_SOURCE_SEL;
+	uint32_t DCCG_AUDIO_DTO_SEL;
+	uint32_t DCCG_AUDIO_DTO0_MODULE;
+	uint32_t DCCG_AUDIO_DTO0_PHASE;
+	uint32_t DCCG_AUDIO_DTO1_MODULE;
+	uint32_t DCCG_AUDIO_DTO1_PHASE;
 };
 
 struct audio_dce110 {
 	struct audio base;
 	const struct dce110_audio_registers *regs;
+	const struct dce110_audio_shift *shifts;
+	const struct dce110_aduio_mask *masks;
+
 	/* dce-specific members are following */
 	/* none */
 };
@@ -68,7 +127,9 @@ struct audio_dce110 {
 struct audio *dce110_audio_create(
 		struct dc_context *ctx,
 		unsigned int inst,
-		const struct dce110_audio_registers *reg);
+		const struct dce110_audio_registers *reg,
+		const struct dce110_audio_shift *shifts,
+		const struct dce110_aduio_mask *masks);
 
 void dce110_aud_destroy(struct audio **audio);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
index ad0108f..c6964c3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
@@ -28,17 +28,20 @@
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 
-
 #define DCE110_AUD(audio)\
 	container_of(audio, struct audio_dce110, base)
 
 
+#include "reg_helper.h"
+
 #define CTX \
 	aud110->base.ctx
 #define REG(reg)\
 	(aud110->regs->reg)
-#include "reg_helper.h"
 
+#undef FN
+#define FN(reg_name, field_name) \
+	aud110->shifts->field_name, aud110->masks->field_name
 
 #define IX_REG(reg)\
 	ix ## reg
@@ -886,7 +889,10 @@ void dce110_aud_destroy(struct audio **audio)
 struct audio *dce110_audio_create(
 		struct dc_context *ctx,
 		unsigned int inst,
-		const struct dce110_audio_registers *reg)
+		const struct dce110_audio_registers *reg,
+		const struct dce110_audio_shift *shifts,
+		const struct dce110_aduio_mask *masks
+		)
 {
 	struct audio_dce110 *audio = dm_alloc(sizeof(*audio));
 
@@ -900,6 +906,8 @@ struct audio *dce110_audio_create(
 	audio->base.funcs = &funcs;
 
 	audio->regs = reg;
+	audio->shifts = shifts;
+	audio->masks = masks;
 
 	return &audio->base;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 90d1553..ae71f1b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -46,9 +46,11 @@
 #include "dce110/dce110_opp_v.h"
 #include "dce110/dce110_clock_source.h"
 #include "dce110/dce110_hw_sequencer.h"
-#include "dce/dce_11_0_d.h"
 #include "adapter_service_interface.h"
 
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_10_0_sh_mask.h"
+
 #ifndef mmDP_DPHY_INTERNAL_CTRL
 	#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7
 	#define mmDP0_DP_DPHY_INTERNAL_CTRL 0x4aa7
@@ -255,6 +257,14 @@ static const struct dce110_audio_registers audio_regs[] = {
 	audio_regs(6),
 };
 
+static const struct dce110_audio_shift audio_shift = {
+		AUD_COMMON_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce110_aduio_mask audio_mask = {
+		AUD_COMMON_MASK_SH_LIST(_MASK)
+};
+
 /* AG TBD Needs to be reduced back to 3 pipes once dce10 hw sequencer implemented. */
 static const struct dce110_opp_reg_offsets dce110_opp_reg_offsets[] = {
 {
@@ -1194,7 +1204,7 @@ static bool construct(
 		}
 
 		pool->base.audios[i] = dce110_audio_create(
-				ctx, i, &audio_regs[i]);
+				ctx, i, &audio_regs[i], &audio_shift, &audio_mask);
 
 		if (pool->base.audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 4b95be6a..e256803 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -47,6 +47,7 @@
 #include "dce112/dce112_hw_sequencer.h"
 
 #include "dce/dce_11_2_d.h"
+#include "dce/dce_11_2_sh_mask.h"
 
 #ifndef mmDP_DPHY_INTERNAL_CTRL
 	#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7
@@ -293,6 +294,15 @@ static const struct dce110_audio_registers audio_regs[] = {
 	audio_regs(6),
 };
 
+static const struct dce110_audio_shift audio_shift = {
+		AUD_COMMON_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce110_aduio_mask audio_mask = {
+		AUD_COMMON_MASK_SH_LIST(_MASK)
+};
+
+
 static const struct dce110_opp_reg_offsets dce112_opp_reg_offsets[] = {
 {
 	.fmt_offset = (mmFMT0_FMT_CONTROL - mmFMT0_FMT_CONTROL),
@@ -1156,7 +1166,7 @@ static bool construct(
 		}
 
 		pool->base.audios[i] = dce110_audio_create(
-				ctx, i, &audio_regs[i]);
+				ctx, i, &audio_regs[i], &audio_shift, &audio_mask);
 
 		if (pool->base.audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index ab1078a..5b62906 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -50,6 +50,7 @@
 #include "dce80/dce80_hw_sequencer.h"
 
 #include "dce/dce_8_0_d.h"
+#include "dce/dce_8_0_sh_mask.h"
 
 /* TODO remove this include */
 
@@ -300,6 +301,14 @@ static const struct dce110_audio_registers audio_regs[] = {
 	audio_regs(6),
 };
 
+static const struct dce110_audio_shift audio_shift = {
+		AUD_COMMON_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce110_aduio_mask audio_mask = {
+		AUD_COMMON_MASK_SH_LIST(_MASK)
+};
+
 static const struct dce110_clk_src_reg_offsets dce80_clk_src_reg_offsets[] = {
 	{
 		.pll_cntl = mmDCCG_PLL0_PLL_CNTL,
@@ -874,7 +883,7 @@ static bool construct(
 		}
 
 		pool->base.audios[i] = dce110_audio_create(
-				ctx, i, &audio_regs[i]);
+				ctx, i, &audio_regs[i], &audio_shift, &audio_mask);
 
 		if (pool->base.audios[i] == NULL) {
 			BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h b/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h
index de13faa..1e3308d 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h
@@ -55,14 +55,17 @@
 				initial_val, \
 				n, __VA_ARGS__)
 
+#define FN(reg_name, field) \
+	FD(reg_name##__##field)
+
 #define REG_SET(reg_name, initial_val, field, val)	\
 		REG_SET_N(reg_name, 1, initial_val, \
-				FD(reg_name##__##field), val)
+				FN(reg_name, field), val)
 
 #define REG_SET_2(reg, init_value, f1, v1, f2, v2)	\
 		REG_SET_N(reg, 2, init_value, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2)
 
 #define REG_SET_3(reg, init_value, f1, v1, f2, v2, f3, v3)	\
 		REG_SET_N(reg, 3, init_value, \
@@ -103,18 +106,18 @@
  * read given register and fill in field value in output parameter */
 #define REG_GET(reg_name, field, val)	\
 		generic_reg_get(CTX, REG(reg_name), \
-				FD(reg_name##__##field), val)
+				FN(reg_name, field), val)
 
 #define REG_GET_2(reg_name, f1, v1, f2, v2)	\
 		generic_reg_get2(CTX, REG(reg_name), \
-				FD(reg_name##__##f1), v1, \
-				FD(reg_name##__##f2), v2)
+				FN(reg_name, f1), v1, \
+				FN(reg_name, f2), v2)
 
 /* macro to poll and wait for a register field to read back given value */
 
 #define REG_WAIT(reg_name, field, val, delay, max_try)	\
 		generic_reg_wait(CTX, \
-				REG(reg_name), FD(reg_name##__##field), val,\
+				REG(reg_name), FN(reg_name, field), val,\
 				delay, max_try)
 
 /* macro to update (read, modify, write) register fields
@@ -127,75 +130,75 @@
 
 #define REG_UPDATE(reg_name, field, val)	\
 		REG_UPDATE_N(reg_name, 1, \
-				FD(reg_name##__##field), val)
+				FN(reg_name, field), val)
 
 #define REG_UPDATE_2(reg, f1, v1, f2, v2)	\
 		REG_UPDATE_N(reg, 2,\
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2)
 
 #define REG_UPDATE_3(reg, f1, v1, f2, v2, f3, v3)	\
 		REG_UPDATE_N(reg, 3, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2, \
-				FD(reg##__##f3), v3)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2, \
+				FN(reg, f3), v3)
 
 #define REG_UPDATE_4(reg, f1, v1, f2, v2, f3, v3, f4, v4)	\
 		REG_UPDATE_N(reg, 4, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2, \
-				FD(reg##__##f3), v3, \
-				FD(reg##__##f4), v4)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2, \
+				FN(reg, f3), v3, \
+				FN(reg, f4), v4)
 
 #define REG_UPDATE_5(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5)	\
 		REG_UPDATE_N(reg, 5, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2, \
-				FD(reg##__##f3), v3, \
-				FD(reg##__##f4), v4, \
-				FD(reg##__##f5), v5)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2, \
+				FN(reg, f3), v3, \
+				FN(reg, f4), v4, \
+				FN(reg, f5), v5)
 
 #define REG_UPDATE_6(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6)	\
 		REG_UPDATE_N(reg, 6, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2, \
-				FD(reg##__##f3), v3, \
-				FD(reg##__##f4), v4, \
-				FD(reg##__##f5), v5, \
-				FD(reg##__##f6), v6)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2, \
+				FN(reg, f3), v3, \
+				FN(reg, f4), v4, \
+				FN(reg, f5), v5, \
+				FN(reg, f6), v6)
 
 #define REG_UPDATE_7(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7)	\
 		REG_UPDATE_N(reg, 7, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2, \
-				FD(reg##__##f3), v3, \
-				FD(reg##__##f4), v4, \
-				FD(reg##__##f5), v5, \
-				FD(reg##__##f6), v6, \
-				FD(reg##__##f7), v7)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2, \
+				FN(reg, f3), v3, \
+				FN(reg, f4), v4, \
+				FN(reg, f5), v5, \
+				FN(reg, f6), v6, \
+				FN(reg, f7), v7)
 
 #define REG_UPDATE_8(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8)	\
 		REG_UPDATE_N(reg, 8, \
-				FD(reg##__##f1), v1,\
-				FD(reg##__##f2), v2, \
-				FD(reg##__##f3), v3, \
-				FD(reg##__##f4), v4, \
-				FD(reg##__##f5), v5, \
-				FD(reg##__##f6), v6, \
-				FD(reg##__##f7), v7, \
-				FD(reg##__##f8), v8)
+				FN(reg, f1), v1,\
+				FN(reg, f2), v2, \
+				FN(reg, f3), v3, \
+				FN(reg, f4), v4, \
+				FN(reg, f5), v5, \
+				FN(reg, f6), v6, \
+				FN(reg, f7), v7, \
+				FN(reg, f8), v8)
 
 #define REG_UPDATE_9(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8, f9, v9)	\
 		REG_UPDATE_N(reg, 9, \
-				FD(reg##__##f1), val1,\
-				FD(reg##__##f2), val2, \
-				FD(reg##__##f3), val3, \
-				FD(reg##__##f4), val4, \
-				FD(reg##__##f5), val5, \
-				FD(reg##__##f6), val6, \
-				FD(reg##__##f7), val7, \
-				FD(reg##__##f8), val8, \
-				FD(reg##__##f9), val9)
+				FN(reg, f1), val1,\
+				FN(reg, f2), val2, \
+				FN(reg, f3), val3, \
+				FN(reg, f4), val4, \
+				FN(reg, f5), val5, \
+				FN(reg, f6), val6, \
+				FN(reg, f7), val7, \
+				FN(reg, f8), val8, \
+				FN(reg, f9), val9)
 
 /* macro to update a register field to specified values in given sequences.
  * useful when toggling bits
-- 
2.7.4

