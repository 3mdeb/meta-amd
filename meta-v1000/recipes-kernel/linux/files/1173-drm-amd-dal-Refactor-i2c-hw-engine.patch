From 2bb30e354ee9990240063140751daca56fc7a83b Mon Sep 17 00:00:00 2001
From: Yongqiang Sun <yongqiang.sun@amd.com>
Date: Thu, 22 Sep 2016 13:22:41 -0400
Subject: [PATCH 1173/1722] drm/amd/dal: Refactor i2c hw engine.

Change-Id: I7d70e2a2f921f8f1b9341876594f0e1beac77438
Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/i2caux/Makefile         |   2 +-
 .../dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c    | 231 +++----
 .../dal/dc/i2caux/dce110/i2c_hw_engine_dce110.h    |  30 +
 .../drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c   |  15 +
 .../dal/dc/i2caux/dce112/i2c_hw_engine_dce112.c    | 715 ---------------------
 .../dal/dc/i2caux/dce112/i2c_hw_engine_dce112.h    |  34 -
 .../drm/amd/dal/dc/i2caux/dce112/i2caux_dce112.c   |  19 +-
 7 files changed, 186 insertions(+), 860 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.h

diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/Makefile b/drivers/gpu/drm/amd/dal/dc/i2caux/Makefile
index cac2c70..6b23387 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/Makefile
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/Makefile
@@ -48,7 +48,7 @@ endif
 # DCE 112 family
 ###############################################################################
 ifdef CONFIG_DRM_AMD_DAL_DCE11_2
-I2CAUX_DCE112 = i2caux_dce112.o i2c_hw_engine_dce112.o
+I2CAUX_DCE112 = i2caux_dce112.o
 
 AMD_DAL_I2CAUX_DCE112 = $(addprefix $(AMDDALPATH)/dc/i2caux/dce112/,$(I2CAUX_DCE112))
 
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
index dbffe9c..5f01bd2 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.c
@@ -45,6 +45,7 @@
  */
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
+#include "reg_helper.h"
 
 /*
  * This unit
@@ -91,17 +92,20 @@ enum {
 #define FROM_ENGINE(ptr) \
 	FROM_I2C_ENGINE(container_of((ptr), struct i2c_engine, base))
 
+#define CTX \
+		hw_engine->base.base.base.ctx
+#define REG(reg_name)\
+	(hw_engine->regs->reg_name)
+#include "reg_helper.h"
+
+
 static void disable_i2c_hw_engine(
-	struct i2c_hw_engine_dce110 *engine)
+	struct i2c_hw_engine_dce110 *hw_engine)
 {
-	const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
 	uint32_t value = 0;
-
 	struct dc_context *ctx = NULL;
 
-	ctx = engine->base.base.base.ctx;
-
-	value = dm_read_reg(ctx, addr);
+	value = REG_READ(SETUP);
 
 	set_reg_field_value(
 		value,
@@ -109,7 +113,7 @@ static void disable_i2c_hw_engine(
 		DC_I2C_DDC1_SETUP,
 		DC_I2C_DDC1_ENABLE);
 
-	dm_write_reg(ctx, addr, value);
+	REG_WRITE(SETUP, value);
 }
 
 static void release_engine(
@@ -129,7 +133,7 @@ static void release_engine(
 
 	/* Release I2C */
 	{
-		value = dm_read_reg(engine->ctx, mmDC_I2C_ARBITRATION);
+		value = REG_READ(DC_I2C_ARBITRATION);
 
 		set_reg_field_value(
 				value,
@@ -137,14 +141,14 @@ static void release_engine(
 				DC_I2C_ARBITRATION,
 				DC_I2C_SW_DONE_USING_I2C_REG);
 
-		dm_write_reg(engine->ctx, mmDC_I2C_ARBITRATION, value);
+		REG_WRITE(DC_I2C_ARBITRATION, value);
 	}
 
 	/* Reset HW engine */
 	{
 		uint32_t i2c_sw_status = 0;
 
-		value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
+		value = REG_READ(DC_I2C_SW_STATUS);
 
 		i2c_sw_status = get_reg_field_value(
 				value,
@@ -154,7 +158,7 @@ static void release_engine(
 		safe_to_reset = (i2c_sw_status == 1);
 	}
 	{
-		value = dm_read_reg(engine->ctx, mmDC_I2C_CONTROL);
+		value = REG_READ(DC_I2C_CONTROL);
 
 		if (safe_to_reset)
 			set_reg_field_value(
@@ -169,7 +173,7 @@ static void release_engine(
 			DC_I2C_CONTROL,
 			DC_I2C_SW_STATUS_RESET);
 
-		dm_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
+		REG_WRITE(DC_I2C_CONTROL, value);
 	}
 
 	/* HW I2c engine - clock gating feature */
@@ -181,13 +185,11 @@ static bool setup_engine(
 	struct i2c_engine *i2c_engine)
 {
 	uint32_t value = 0;
-	struct i2c_hw_engine_dce110 *engine = FROM_I2C_ENGINE(i2c_engine);
+	struct i2c_hw_engine_dce110 *hw_engine = FROM_I2C_ENGINE(i2c_engine);
 
 	/* Program pin select */
 	{
-		const uint32_t addr = mmDC_I2C_CONTROL;
-
-		value = dm_read_reg(i2c_engine->base.ctx, addr);
+		value = REG_READ(DC_I2C_CONTROL);
 
 		set_reg_field_value(
 			value,
@@ -221,18 +223,16 @@ static bool setup_engine(
 
 		set_reg_field_value(
 			value,
-			engine->engine_id,
+			hw_engine->engine_id,
 			DC_I2C_CONTROL,
 			DC_I2C_DDC_SELECT);
 
-		dm_write_reg(i2c_engine->base.ctx, addr, value);
+		REG_WRITE(DC_I2C_CONTROL, value);
 	}
 
 	/* Program time limit */
 	{
-		const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
-
-		value = dm_read_reg(i2c_engine->base.ctx, addr);
+		value = REG_READ(SETUP);
 
 		set_reg_field_value(
 			value,
@@ -246,7 +246,7 @@ static bool setup_engine(
 			DC_I2C_DDC1_SETUP,
 			DC_I2C_DDC1_ENABLE);
 
-		dm_write_reg(i2c_engine->base.ctx, addr, value);
+		REG_WRITE(SETUP, value);
 	}
 
 	/* Program HW priority
@@ -254,8 +254,7 @@ static bool setup_engine(
 	 * Enable restart of SW I2C that was interrupted by HW
 	 * disable queuing of software while I2C is in use by HW */
 	{
-		value = dm_read_reg(i2c_engine->base.ctx,
-				mmDC_I2C_ARBITRATION);
+		value = REG_READ(DC_I2C_ARBITRATION);
 
 		set_reg_field_value(
 			value,
@@ -269,8 +268,7 @@ static bool setup_engine(
 			DC_I2C_ARBITRATION,
 			DC_I2C_SW_PRIORITY);
 
-		dm_write_reg(i2c_engine->base.ctx,
-				mmDC_I2C_ARBITRATION, value);
+		REG_WRITE(DC_I2C_ARBITRATION, value);
 	}
 
 	return true;
@@ -279,13 +277,9 @@ static bool setup_engine(
 static uint32_t get_speed(
 	const struct i2c_engine *i2c_engine)
 {
-	const struct i2c_hw_engine_dce110 *engine = FROM_I2C_ENGINE(i2c_engine);
-
-	const uint32_t addr = engine->addr.DC_I2C_DDCX_SPEED;
-
+	const struct i2c_hw_engine_dce110 *hw_engine = FROM_I2C_ENGINE(i2c_engine);
 	uint32_t pre_scale = 0;
-
-	uint32_t value = dm_read_reg(i2c_engine->base.ctx, addr);
+	uint32_t value = REG_READ(SPEED);
 
 	pre_scale = get_reg_field_value(
 			value,
@@ -296,24 +290,22 @@ static uint32_t get_speed(
 	/*ASSERT(value.bits.DC_I2C_DDC1_PRESCALE);*/
 
 	return pre_scale ?
-		engine->reference_frequency / pre_scale :
-		engine->base.default_speed;
+		hw_engine->reference_frequency / pre_scale :
+		hw_engine->base.default_speed;
 }
 
 static void set_speed(
 	struct i2c_engine *i2c_engine,
 	uint32_t speed)
 {
-	struct i2c_hw_engine_dce110 *engine = FROM_I2C_ENGINE(i2c_engine);
+	struct i2c_hw_engine_dce110 *hw_engine = FROM_I2C_ENGINE(i2c_engine);
 
 	if (speed) {
-		const uint32_t addr = engine->addr.DC_I2C_DDCX_SPEED;
-
-		uint32_t value = dm_read_reg(i2c_engine->base.ctx, addr);
+		uint32_t value = REG_READ(SPEED);
 
 		set_reg_field_value(
 			value,
-			engine->reference_frequency / speed,
+			hw_engine->reference_frequency / speed,
 			DC_I2C_DDC1_SPEED,
 			DC_I2C_DDC1_PRESCALE);
 
@@ -338,13 +330,14 @@ static void set_speed(
 				DC_I2C_DDC1_START_STOP_TIMING_CNTL);
 		}
 
-		dm_write_reg(i2c_engine->base.ctx, addr, value);
+		REG_WRITE(SPEED, value);
 	}
 }
 
 static inline void reset_hw_engine(struct engine *engine)
 {
-	uint32_t value = dm_read_reg(engine->ctx, mmDC_I2C_CONTROL);
+	struct i2c_hw_engine_dce110 *hw_engine = FROM_ENGINE(engine);
+	uint32_t value = REG_READ(DC_I2C_CONTROL);
 
 	set_reg_field_value(
 		value,
@@ -358,14 +351,15 @@ static inline void reset_hw_engine(struct engine *engine)
 		DC_I2C_CONTROL,
 		DC_I2C_SW_STATUS_RESET);
 
-	dm_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
+	REG_WRITE(DC_I2C_CONTROL, value);
 }
 
 static bool is_hw_busy(struct engine *engine)
 {
+	struct i2c_hw_engine_dce110 *hw_engine = FROM_ENGINE(engine);
 	uint32_t i2c_sw_status = 0;
 
-	uint32_t value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
+	uint32_t value = REG_READ(DC_I2C_SW_STATUS);
 
 	i2c_sw_status = get_reg_field_value(
 			value,
@@ -377,7 +371,7 @@ static bool is_hw_busy(struct engine *engine)
 
 	reset_hw_engine(engine);
 
-	value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
+	value = REG_READ(DC_I2C_SW_STATUS);
 
 	i2c_sw_status = get_reg_field_value(
 			value,
@@ -391,15 +385,47 @@ static bool is_hw_busy(struct engine *engine)
  * @brief
  * DC_GPIO_DDC MM register offsets
  */
-static const uint32_t transaction_addr[] = {
-	mmDC_I2C_TRANSACTION0,
-	mmDC_I2C_TRANSACTION1,
-	mmDC_I2C_TRANSACTION2,
-	mmDC_I2C_TRANSACTION3
-};
+static uint32_t transaction_reg_read(struct i2c_hw_engine_dce110 *hw_engine,
+		uint32_t transaction_count)
+{
+	switch (transaction_count) {
+	case 0:
+		return REG_READ(DC_I2C_TRANSACTION0);
+	case 1:
+		return REG_READ(DC_I2C_TRANSACTION1);
+	case 2:
+		return REG_READ(DC_I2C_TRANSACTION2);
+	case 3:
+		return REG_READ(DC_I2C_TRANSACTION3);
+	default:
+		return 0;
+	}
+}
+
+static void transcation_reg_write(struct i2c_hw_engine_dce110 *hw_engine,
+		uint32_t transaction_count, uint32_t value)
+{
+	switch (transaction_count) {
+	case 0:
+		REG_WRITE(DC_I2C_TRANSACTION0, value);
+		break;
+	case 1:
+		REG_WRITE(DC_I2C_TRANSACTION1, value);
+		break;
+	case 2:
+		REG_WRITE(DC_I2C_TRANSACTION2, value);
+		break;
+	case 3:
+		REG_WRITE(DC_I2C_TRANSACTION3, value);
+		break;
+
+	default:
+		break;
+	}
+}
 
 static bool process_transaction(
-	struct i2c_hw_engine_dce110 *engine,
+	struct i2c_hw_engine_dce110 *hw_engine,
 	struct i2c_request_transaction_data *request)
 {
 	uint32_t length = request->length;
@@ -410,13 +436,10 @@ static bool process_transaction(
 
 	struct dc_context *ctx = NULL;
 
-	ctx = engine->base.base.base.ctx;
+	ctx = hw_engine->base.base.base.ctx;
 
 	{
-		const uint32_t addr =
-			transaction_addr[engine->transaction_count];
-
-		value = dm_read_reg(ctx, addr);
+		value = transaction_reg_read(hw_engine, hw_engine->transaction_count);
 
 		set_reg_field_value(
 			value,
@@ -430,7 +453,7 @@ static bool process_transaction(
 			DC_I2C_TRANSACTION0,
 			DC_I2C_START0);
 
-		if ((engine->transaction_count == 3) ||
+		if ((hw_engine->transaction_count == 3) ||
 		(request->action == I2CAUX_TRANSACTION_ACTION_I2C_WRITE) ||
 		(request->action & I2CAUX_TRANSACTION_ACTION_I2C_READ)) {
 
@@ -461,7 +484,7 @@ static bool process_transaction(
 			DC_I2C_TRANSACTION0,
 			DC_I2C_COUNT0);
 
-		dm_write_reg(ctx, addr, value);
+		transcation_reg_write(hw_engine, hw_engine->transaction_count, value);
 	}
 
 	/* Write the I2C address and I2C data
@@ -486,7 +509,7 @@ static bool process_transaction(
 			DC_I2C_DATA,
 			DC_I2C_DATA);
 
-		if (engine->transaction_count == 0) {
+		if (hw_engine->transaction_count == 0) {
 			set_reg_field_value(
 				value,
 				0,
@@ -500,12 +523,12 @@ static bool process_transaction(
 				DC_I2C_DATA,
 				DC_I2C_INDEX_WRITE);
 
-			engine->buffer_used_write = 0;
+			hw_engine->buffer_used_write = 0;
 		}
 
-		dm_write_reg(ctx, mmDC_I2C_DATA, value);
+		REG_WRITE(DC_I2C_DATA, value);
 
-		engine->buffer_used_write++;
+		hw_engine->buffer_used_write++;
 
 		if (!(request->action & I2CAUX_TRANSACTION_ACTION_I2C_READ)) {
 
@@ -523,32 +546,27 @@ static bool process_transaction(
 					DC_I2C_DATA,
 					DC_I2C_DATA);
 
-				dm_write_reg(ctx, mmDC_I2C_DATA, value);
+				REG_WRITE(DC_I2C_DATA, value);
 
-				engine->buffer_used_write++;
+				hw_engine->buffer_used_write++;
 				--length;
 			}
 		}
 	}
 
-	++engine->transaction_count;
-	engine->buffer_used_bytes += length + 1;
+	++hw_engine->transaction_count;
+	hw_engine->buffer_used_bytes += length + 1;
 
 	return last_transaction;
 }
 
 static void execute_transaction(
-	struct i2c_hw_engine_dce110 *engine)
+	struct i2c_hw_engine_dce110 *hw_engine)
 {
 	uint32_t value = 0;
-	struct dc_context *ctx = NULL;
-
-	ctx = engine->base.base.base.ctx;
 
 	{
-		const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
-
-		value = dm_read_reg(ctx, addr);
+		value = REG_READ(SETUP);
 
 		set_reg_field_value(
 			value,
@@ -580,13 +598,11 @@ static void execute_transaction(
 			DC_I2C_DDC1_SETUP,
 			DC_I2C_DDC1_INTRA_BYTE_DELAY);
 
-		dm_write_reg(ctx, addr, value);
+		REG_WRITE(SETUP, value);
 	}
 
 	{
-		const uint32_t addr = mmDC_I2C_CONTROL;
-
-		value = dm_read_reg(ctx, addr);
+		value = REG_READ(DC_I2C_CONTROL);
 
 		set_reg_field_value(
 			value,
@@ -614,18 +630,16 @@ static void execute_transaction(
 
 		set_reg_field_value(
 			value,
-			engine->transaction_count - 1,
+			hw_engine->transaction_count - 1,
 			DC_I2C_CONTROL,
 			DC_I2C_TRANSACTION_COUNT);
 
-		dm_write_reg(ctx, addr, value);
+		REG_WRITE(DC_I2C_CONTROL, value);
 	}
 
 	/* start I2C transfer */
 	{
-		const uint32_t addr = mmDC_I2C_CONTROL;
-
-		value	= dm_read_reg(ctx, addr);
+		value	= REG_READ(DC_I2C_CONTROL);
 
 		set_reg_field_value(
 			value,
@@ -633,13 +647,13 @@ static void execute_transaction(
 			DC_I2C_CONTROL,
 			DC_I2C_GO);
 
-		dm_write_reg(ctx, addr, value);
+		REG_WRITE(DC_I2C_CONTROL, value);
 	}
 
 	/* all transactions were executed and HW buffer became empty
 	 * (even though it actually happens when status becomes DONE) */
-	engine->transaction_count = 0;
-	engine->buffer_used_bytes = 0;
+	hw_engine->transaction_count = 0;
+	hw_engine->buffer_used_bytes = 0;
 }
 
 static void submit_channel_request(
@@ -666,7 +680,7 @@ static void process_channel_reply(
 	uint32_t length = reply->length;
 	uint8_t *buffer = reply->data;
 
-	struct i2c_hw_engine_dce110 *i2c_hw_engine_dce110 =
+	struct i2c_hw_engine_dce110 *hw_engine =
 		FROM_I2C_ENGINE(engine);
 
 	uint32_t value = 0;
@@ -674,7 +688,7 @@ static void process_channel_reply(
 	/*set index*/
 	set_reg_field_value(
 		value,
-		i2c_hw_engine_dce110->buffer_used_write,
+		hw_engine->buffer_used_write,
 		DC_I2C_DATA,
 		DC_I2C_INDEX);
 
@@ -690,7 +704,7 @@ static void process_channel_reply(
 		DC_I2C_DATA,
 		DC_I2C_INDEX_WRITE);
 
-	dm_write_reg(engine->base.ctx, mmDC_I2C_DATA, value);
+	REG_WRITE(DC_I2C_DATA, value);
 
 	while (length) {
 		/* after reading the status,
@@ -698,7 +712,7 @@ static void process_channel_reply(
 		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
 		 * should read data bytes from I2C circular data buffer */
 
-		value = dm_read_reg(engine->base.ctx, mmDC_I2C_DATA);
+		value = REG_READ(DC_I2C_DATA);
 
 		*buffer++ = get_reg_field_value(
 				value,
@@ -710,11 +724,12 @@ static void process_channel_reply(
 }
 
 static enum i2c_channel_operation_result get_channel_status(
-	struct i2c_engine *engine,
+	struct i2c_engine *i2c_engine,
 	uint8_t *returned_bytes)
 {
 	uint32_t i2c_sw_status = 0;
-	uint32_t value = dm_read_reg(engine->base.ctx, mmDC_I2C_SW_STATUS);
+	struct i2c_hw_engine_dce110 *hw_engine = FROM_I2C_ENGINE(i2c_engine);
+	uint32_t value = REG_READ(DC_I2C_SW_STATUS);
 
 	i2c_sw_status = get_reg_field_value(
 			value,
@@ -840,7 +855,7 @@ static const struct i2c_hw_engine_funcs i2c_hw_engine_funcs = {
 };
 
 bool i2c_hw_engine_dce110_construct(
-	struct i2c_hw_engine_dce110 *engine_dce110,
+	struct i2c_hw_engine_dce110 *hw_engine,
 	const struct i2c_hw_engine_dce110_create_arg *arg)
 {
 	uint32_t xtal_ref_div = 0;
@@ -855,29 +870,29 @@ bool i2c_hw_engine_dce110_construct(
 	if (!arg->reference_frequency)
 		return false;
 
-	if (!dal_i2c_hw_engine_construct(&engine_dce110->base, arg->ctx))
+	if (!dal_i2c_hw_engine_construct(&hw_engine->base, arg->ctx))
 		return false;
 
-	engine_dce110->base.base.base.funcs = &engine_funcs;
-	engine_dce110->base.base.funcs = &i2c_engine_funcs;
-	engine_dce110->base.funcs = &i2c_hw_engine_funcs;
-	engine_dce110->base.default_speed = arg->default_speed;
+	hw_engine->base.base.base.funcs = &engine_funcs;
+	hw_engine->base.base.funcs = &i2c_engine_funcs;
+	hw_engine->base.funcs = &i2c_hw_engine_funcs;
+	hw_engine->base.default_speed = arg->default_speed;
+
+	hw_engine->regs = arg->regs;
 
-	engine_dce110->engine_id = arg->engine_id;
+	hw_engine->engine_id = arg->engine_id;
 
-	engine_dce110->buffer_used_bytes = 0;
-	engine_dce110->transaction_count = 0;
-	engine_dce110->engine_keep_power_up_count = 1;
+	hw_engine->buffer_used_bytes = 0;
+	hw_engine->transaction_count = 0;
+	hw_engine->engine_keep_power_up_count = 1;
 
 	/*values which are not included by arg*/
-	engine_dce110->addr.DC_I2C_DDCX_SETUP =
+	hw_engine->addr.DC_I2C_DDCX_SETUP =
 		mmDC_I2C_DDC1_SETUP + ddc_setup_offset[arg->engine_id];
-	engine_dce110->addr.DC_I2C_DDCX_SPEED =
+	hw_engine->addr.DC_I2C_DDCX_SPEED =
 		mmDC_I2C_DDC1_SPEED + ddc_speed_offset[arg->engine_id];
 
-	value = dm_read_reg(
-		engine_dce110->base.base.base.ctx,
-		mmMICROSECOND_TIME_BASE_DIV);
+	value = REG_READ(MICROSECOND_TIME_BASE_DIV);
 
 	xtal_ref_div = get_reg_field_value(
 			value,
@@ -886,7 +901,7 @@ bool i2c_hw_engine_dce110_construct(
 
 	if (xtal_ref_div == 0) {
 		dal_logger_write(
-				engine_dce110->base.base.base.ctx->logger,
+				hw_engine->base.base.base.ctx->logger,
 				LOG_MAJOR_WARNING,
 				LOG_MINOR_COMPONENT_I2C_AUX,
 				"Invalid base timer divider\n",
@@ -901,7 +916,7 @@ bool i2c_hw_engine_dce110_construct(
 	 *  which already divided by 2. So we need x2 to get original
 	 *  reference clock from ppll_info
 	 */
-	engine_dce110->reference_frequency =
+	hw_engine->reference_frequency =
 		(arg->reference_frequency * 2) / xtal_ref_div;
 
 	return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.h b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.h
index 5ae6c9c..ee40e7c 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2c_hw_engine_dce110.h
@@ -26,8 +26,37 @@
 #ifndef __DAL_I2C_HW_ENGINE_DCE110_H__
 #define __DAL_I2C_HW_ENGINE_DCE110_H__
 
+#define I2C_HW_ENGINE_COMMON_REG_LIST(id)\
+	SRI(SETUP, DC_I2C_DDC, id),\
+	SRI(SPEED, DC_I2C_DDC, id),\
+	SR(DC_I2C_ARBITRATION),\
+	SR(DC_I2C_CONTROL),\
+	SR(DC_I2C_SW_STATUS),\
+	SR(DC_I2C_TRANSACTION0),\
+	SR(DC_I2C_TRANSACTION1),\
+	SR(DC_I2C_TRANSACTION2),\
+	SR(DC_I2C_TRANSACTION3),\
+	SR(DC_I2C_DATA),\
+	SR(MICROSECOND_TIME_BASE_DIV)
+
+struct dce110_i2c_hw_engine_registers {
+	uint32_t SETUP;
+	uint32_t SPEED;
+	uint32_t DC_I2C_ARBITRATION;
+	uint32_t DC_I2C_CONTROL;
+	uint32_t DC_I2C_SW_STATUS;
+	uint32_t DC_I2C_TRANSACTION0;
+	uint32_t DC_I2C_TRANSACTION1;
+	uint32_t DC_I2C_TRANSACTION2;
+	uint32_t DC_I2C_TRANSACTION3;
+	uint32_t DC_I2C_DATA;
+	uint32_t MICROSECOND_TIME_BASE_DIV;
+};
+
+
 struct i2c_hw_engine_dce110 {
 	struct i2c_hw_engine base;
+	const struct dce110_i2c_hw_engine_registers *regs;
 	struct {
 		uint32_t DC_I2C_DDCX_SETUP;
 		uint32_t DC_I2C_DDCX_SPEED;
@@ -50,6 +79,7 @@ struct i2c_hw_engine_dce110_create_arg {
 	uint32_t reference_frequency;
 	uint32_t default_speed;
 	struct dc_context *ctx;
+	const struct dce110_i2c_hw_engine_registers *regs;
 };
 
 struct i2c_engine *dal_i2c_hw_engine_dce110_create(
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
index 065354a..864c09c 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce110/i2caux_dce110.c
@@ -165,6 +165,11 @@ static const struct i2caux_funcs i2caux_funcs = {
 	.AUX_RESET_MASK = AUX_CONTROL__AUX_RESET_MASK \
 }
 
+#define hw_engine_regs(id)\
+[id] = {\
+		I2C_HW_ENGINE_COMMON_REG_LIST(id) \
+}
+
 static const struct dce110_aux_registers dce110_aux_regs[] = {
 		aux_regs(0),
 		aux_regs(1),
@@ -174,6 +179,15 @@ static const struct dce110_aux_registers dce110_aux_regs[] = {
 		aux_regs(5)
 };
 
+static const struct dce110_i2c_hw_engine_registers i2c_hw_engine_regs[] = {
+		hw_engine_regs(1),
+		hw_engine_regs(2),
+		hw_engine_regs(3),
+		hw_engine_regs(4),
+		hw_engine_regs(5),
+		hw_engine_regs(6)
+};
+
 bool dal_i2caux_dce110_construct(
 	struct i2caux_dce110 *i2caux_dce110,
 	struct adapter_service *as,
@@ -225,6 +239,7 @@ bool dal_i2caux_dce110_construct(
 		hw_arg_dce110.reference_frequency = reference_frequency;
 		hw_arg_dce110.default_speed = base->default_i2c_hw_speed;
 		hw_arg_dce110.ctx = ctx;
+		hw_arg_dce110.regs = &i2c_hw_engine_regs[i + 1];
 
 		base->i2c_hw_engines[line_id] =
 			dal_i2c_hw_engine_dce110_create(&hw_arg_dce110);
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.c
deleted file mode 100644
index 05de98b..0000000
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.c
+++ /dev/null
@@ -1,715 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "include/logger_interface.h"
-/*
- * Pre-requisites: headers required by header of this unit
- */
-
-#include "include/i2caux_interface.h"
-#include "../engine.h"
-#include "../i2c_engine.h"
-#include "../i2c_hw_engine.h"
-#include "../i2c_generic_hw_engine.h"
-/*
- * Header of this unit
- */
-
-#include "i2c_hw_engine_dce112.h"
-
-#include "dce/dce_11_2_d.h"
-#include "dce/dce_11_2_sh_mask.h"
-
-/*
- * This unit
- */
-
-enum dc_i2c_status {
-	DC_I2C_STATUS__DC_I2C_STATUS_IDLE,
-	DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_SW,
-	DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_HW
-};
-
-enum dc_i2c_arbitration {
-	DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL,
-	DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_HIGH
-};
-
-enum {
-	/* No timeout in HW
-	 * (timeout implemented in SW by querying status) */
-	I2C_SETUP_TIME_LIMIT = 255,
-	I2C_HW_BUFFER_SIZE = 538
-};
-
-/*
- * @brief
- * Cast pointer to 'struct i2c_hw_engine *'
- * to pointer 'struct i2c_hw_engine_dce110 *'
- */
-#define FROM_I2C_HW_ENGINE(ptr) \
-	container_of((ptr), struct i2c_hw_engine_dce110, base)
-/*
- * @brief
- * Cast pointer to 'struct i2c_engine *'
- * to pointer to 'struct i2c_hw_engine_dce110 *'
- */
-#define FROM_I2C_ENGINE(ptr) \
-	FROM_I2C_HW_ENGINE(container_of((ptr), struct i2c_hw_engine, base))
-
-/*
- * @brief
- * Cast pointer to 'struct engine *'
- * to 'pointer to struct i2c_hw_engine_dce110 *'
- */
-#define FROM_ENGINE(ptr) \
-	FROM_I2C_ENGINE(container_of((ptr), struct i2c_engine, base))
-
-static bool setup_engine(
-	struct i2c_engine *i2c_engine)
-{
-	uint32_t value = 0;
-	struct i2c_hw_engine_dce110 *engine = FROM_I2C_ENGINE(i2c_engine);
-
-	/* Program pin select */
-	{
-		const uint32_t addr = mmDC_I2C_CONTROL;
-
-		value = dm_read_reg(i2c_engine->base.ctx, addr);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_GO);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_SOFT_RESET);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_SEND_RESET);
-
-		set_reg_field_value(
-			value,
-			1,
-			DC_I2C_CONTROL,
-			DC_I2C_SW_STATUS_RESET);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_TRANSACTION_COUNT);
-
-		set_reg_field_value(
-			value,
-			engine->engine_id,
-			DC_I2C_CONTROL,
-			DC_I2C_DDC_SELECT);
-
-		dm_write_reg(i2c_engine->base.ctx, addr, value);
-	}
-
-	/* Program time limit */
-	{
-		const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
-
-		value = dm_read_reg(i2c_engine->base.ctx, addr);
-
-		set_reg_field_value(
-			value,
-			I2C_SETUP_TIME_LIMIT,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_TIME_LIMIT);
-
-		set_reg_field_value(
-			value,
-			1,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_ENABLE);
-
-		dm_write_reg(i2c_engine->base.ctx, addr, value);
-	}
-
-	/* Program HW priority
-	 * set to High - interrupt software I2C at any time
-	 * Enable restart of SW I2C that was interrupted by HW
-	 * disable queuing of software while I2C is in use by HW */
-	{
-		value = dm_read_reg(i2c_engine->base.ctx,
-				mmDC_I2C_ARBITRATION);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_ARBITRATION,
-			DC_I2C_NO_QUEUED_SW_GO);
-
-		set_reg_field_value(
-			value,
-			DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL,
-			DC_I2C_ARBITRATION,
-			DC_I2C_SW_PRIORITY);
-
-		dm_write_reg(i2c_engine->base.ctx,
-				mmDC_I2C_ARBITRATION, value);
-	}
-
-	return true;
-}
-
-static uint32_t get_speed(
-	const struct i2c_engine *i2c_engine)
-{
-	const struct i2c_hw_engine_dce110 *engine = FROM_I2C_ENGINE(i2c_engine);
-
-	const uint32_t addr = engine->addr.DC_I2C_DDCX_SPEED;
-
-	uint32_t pre_scale = 0;
-
-	uint32_t value = dm_read_reg(i2c_engine->base.ctx, addr);
-
-	pre_scale = get_reg_field_value(
-			value,
-			DC_I2C_DDC1_SPEED,
-			DC_I2C_DDC1_PRESCALE);
-
-	/* [anaumov] it seems following is unnecessary */
-	/*ASSERT(value.bits.DC_I2C_DDC1_PRESCALE);*/
-
-	return pre_scale ?
-		engine->reference_frequency / pre_scale :
-		engine->base.default_speed;
-}
-
-static void set_speed(
-	struct i2c_engine *i2c_engine,
-	uint32_t speed)
-{
-	struct i2c_hw_engine_dce110 *engine = FROM_I2C_ENGINE(i2c_engine);
-
-	if (speed) {
-		const uint32_t addr = engine->addr.DC_I2C_DDCX_SPEED;
-
-		uint32_t value = dm_read_reg(i2c_engine->base.ctx, addr);
-
-		set_reg_field_value(
-			value,
-			engine->reference_frequency / speed,
-			DC_I2C_DDC1_SPEED,
-			DC_I2C_DDC1_PRESCALE);
-
-		set_reg_field_value(
-			value,
-			2,
-			DC_I2C_DDC1_SPEED,
-			DC_I2C_DDC1_THRESHOLD);
-
-		/*DCE11, HW add 100Khz support for I2c*/
-		if (speed > 50) {
-			set_reg_field_value(
-				value,
-				2,
-				DC_I2C_DDC1_SPEED,
-				DC_I2C_DDC1_START_STOP_TIMING_CNTL);
-		} else {
-			set_reg_field_value(
-				value,
-				1,
-				DC_I2C_DDC1_SPEED,
-				DC_I2C_DDC1_START_STOP_TIMING_CNTL);
-		}
-
-		dm_write_reg(i2c_engine->base.ctx, addr, value);
-	}
-}
-
-static inline void reset_hw_engine(struct engine *engine)
-{
-	uint32_t value = dm_read_reg(engine->ctx, mmDC_I2C_CONTROL);
-
-	set_reg_field_value(
-		value,
-		1,
-		DC_I2C_CONTROL,
-		DC_I2C_SOFT_RESET);
-
-	set_reg_field_value(
-		value,
-		1,
-		DC_I2C_CONTROL,
-		DC_I2C_SW_STATUS_RESET);
-
-	dm_write_reg(engine->ctx, mmDC_I2C_CONTROL, value);
-}
-
-static bool is_hw_busy(struct engine *engine)
-{
-	uint32_t i2c_sw_status = 0;
-
-	uint32_t value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
-
-	i2c_sw_status = get_reg_field_value(
-			value,
-			DC_I2C_SW_STATUS,
-			DC_I2C_SW_STATUS);
-
-	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)
-		return false;
-
-	reset_hw_engine(engine);
-
-	value = dm_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
-
-	i2c_sw_status = get_reg_field_value(
-			value,
-			DC_I2C_SW_STATUS,
-			DC_I2C_SW_STATUS);
-
-	return i2c_sw_status != DC_I2C_STATUS__DC_I2C_STATUS_IDLE;
-}
-
-/*
- * @brief
- * DC_GPIO_DDC MM register offsets
- */
-static const uint32_t transaction_addr[] = {
-	mmDC_I2C_TRANSACTION0,
-	mmDC_I2C_TRANSACTION1,
-	mmDC_I2C_TRANSACTION2,
-	mmDC_I2C_TRANSACTION3
-};
-
-static bool process_transaction(
-	struct i2c_hw_engine_dce110 *engine,
-	struct i2c_request_transaction_data *request)
-{
-	uint32_t length = request->length;
-	uint8_t *buffer = request->data;
-
-	bool last_transaction = false;
-	uint32_t value = 0;
-
-	struct dc_context *ctx = NULL;
-
-	ctx = engine->base.base.base.ctx;
-
-	{
-		const uint32_t addr =
-			transaction_addr[engine->transaction_count];
-
-		value = dm_read_reg(ctx, addr);
-
-		set_reg_field_value(
-			value,
-			1,
-			DC_I2C_TRANSACTION0,
-			DC_I2C_STOP_ON_NACK0);
-
-		set_reg_field_value(
-			value,
-			1,
-			DC_I2C_TRANSACTION0,
-			DC_I2C_START0);
-
-		if ((engine->transaction_count == 3) ||
-		(request->action == I2CAUX_TRANSACTION_ACTION_I2C_WRITE) ||
-		(request->action & I2CAUX_TRANSACTION_ACTION_I2C_READ)) {
-
-			set_reg_field_value(
-				value,
-				1,
-				DC_I2C_TRANSACTION0,
-				DC_I2C_STOP0);
-
-			last_transaction = true;
-		} else
-			set_reg_field_value(
-				value,
-				0,
-				DC_I2C_TRANSACTION0,
-				DC_I2C_STOP0);
-
-		set_reg_field_value(
-			value,
-			(0 != (request->action &
-					I2CAUX_TRANSACTION_ACTION_I2C_READ)),
-			DC_I2C_TRANSACTION0,
-			DC_I2C_RW0);
-
-		set_reg_field_value(
-			value,
-			length,
-			DC_I2C_TRANSACTION0,
-			DC_I2C_COUNT0);
-
-		dm_write_reg(ctx, addr, value);
-	}
-
-	/* Write the I2C address and I2C data
-	 * into the hardware circular buffer, one byte per entry.
-	 * As an example, the 7-bit I2C slave address for CRT monitor
-	 * for reading DDC/EDID information is 0b1010001.
-	 * For an I2C send operation, the LSB must be programmed to 0;
-	 * for I2C receive operation, the LSB must be programmed to 1. */
-
-	{
-		value = 0;
-
-		set_reg_field_value(
-			value,
-			false,
-			DC_I2C_DATA,
-			DC_I2C_DATA_RW);
-
-		set_reg_field_value(
-			value,
-			request->address,
-			DC_I2C_DATA,
-			DC_I2C_DATA);
-
-		if (engine->transaction_count == 0) {
-			set_reg_field_value(
-				value,
-				0,
-				DC_I2C_DATA,
-				DC_I2C_INDEX);
-
-			/*enable index write*/
-			set_reg_field_value(
-				value,
-				1,
-				DC_I2C_DATA,
-				DC_I2C_INDEX_WRITE);
-
-			engine->buffer_used_write = 0;
-		}
-
-		dm_write_reg(ctx, mmDC_I2C_DATA, value);
-
-		engine->buffer_used_write++;
-
-		if (!(request->action & I2CAUX_TRANSACTION_ACTION_I2C_READ)) {
-
-			set_reg_field_value(
-				value,
-				0,
-				DC_I2C_DATA,
-				DC_I2C_INDEX_WRITE);
-
-			while (length) {
-
-				set_reg_field_value(
-					value,
-					*buffer++,
-					DC_I2C_DATA,
-					DC_I2C_DATA);
-
-				dm_write_reg(ctx, mmDC_I2C_DATA, value);
-
-				engine->buffer_used_write++;
-				--length;
-			}
-		}
-	}
-
-	++engine->transaction_count;
-	engine->buffer_used_bytes += length + 1;
-
-	return last_transaction;
-}
-
-static void execute_transaction(
-	struct i2c_hw_engine_dce110 *engine)
-{
-	uint32_t value = 0;
-	struct dc_context *ctx = NULL;
-
-	ctx = engine->base.base.base.ctx;
-
-	{
-		const uint32_t addr = engine->addr.DC_I2C_DDCX_SETUP;
-
-		value = dm_read_reg(ctx, addr);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_DATA_DRIVE_EN);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_CLK_DRIVE_EN);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_DATA_DRIVE_SEL);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_INTRA_TRANSACTION_DELAY);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_DDC1_SETUP,
-			DC_I2C_DDC1_INTRA_BYTE_DELAY);
-
-		dm_write_reg(ctx, addr, value);
-	}
-
-	{
-		const uint32_t addr = mmDC_I2C_CONTROL;
-
-		value = dm_read_reg(ctx, addr);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_SOFT_RESET);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_SW_STATUS_RESET);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_SEND_RESET);
-
-		set_reg_field_value(
-			value,
-			0,
-			DC_I2C_CONTROL,
-			DC_I2C_GO);
-
-		set_reg_field_value(
-			value,
-			engine->transaction_count - 1,
-			DC_I2C_CONTROL,
-			DC_I2C_TRANSACTION_COUNT);
-
-		dm_write_reg(ctx, addr, value);
-	}
-
-	/* start I2C transfer */
-	{
-		const uint32_t addr = mmDC_I2C_CONTROL;
-
-		value	= dm_read_reg(ctx, addr);
-
-		set_reg_field_value(
-			value,
-			1,
-			DC_I2C_CONTROL,
-			DC_I2C_GO);
-
-		dm_write_reg(ctx, addr, value);
-	}
-
-	/* all transactions were executed and HW buffer became empty
-	 * (even though it actually happens when status becomes DONE) */
-	engine->transaction_count = 0;
-	engine->buffer_used_bytes = 0;
-}
-
-static void submit_channel_request(
-	struct i2c_engine *engine,
-	struct i2c_request_transaction_data *request)
-{
-	request->status = I2C_CHANNEL_OPERATION_SUCCEEDED;
-
-	if (!process_transaction(FROM_I2C_ENGINE(engine), request))
-		return;
-
-	if (is_hw_busy(&engine->base)) {
-		request->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;
-		return;
-	}
-
-	execute_transaction(FROM_I2C_ENGINE(engine));
-}
-
-static void process_channel_reply(
-	struct i2c_engine *engine,
-	struct i2c_reply_transaction_data *reply)
-{
-	uint32_t length = reply->length;
-	uint8_t *buffer = reply->data;
-
-	struct i2c_hw_engine_dce110 *i2c_hw_engine_dce110 =
-		FROM_I2C_ENGINE(engine);
-
-	uint32_t value = 0;
-
-	/*set index*/
-	set_reg_field_value(
-		value,
-		i2c_hw_engine_dce110->buffer_used_write,
-		DC_I2C_DATA,
-		DC_I2C_INDEX);
-
-	set_reg_field_value(
-		value,
-		1,
-		DC_I2C_DATA,
-		DC_I2C_DATA_RW);
-
-	set_reg_field_value(
-		value,
-		1,
-		DC_I2C_DATA,
-		DC_I2C_INDEX_WRITE);
-
-	dm_write_reg(engine->base.ctx, mmDC_I2C_DATA, value);
-
-	while (length) {
-		/* after reading the status,
-		 * if the I2C operation executed successfully
-		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
-		 * should read data bytes from I2C circular data buffer */
-
-		value = dm_read_reg(engine->base.ctx, mmDC_I2C_DATA);
-
-		*buffer++ = get_reg_field_value(
-				value,
-				DC_I2C_DATA,
-				DC_I2C_DATA);
-
-		--length;
-	}
-}
-
-static enum i2c_channel_operation_result get_channel_status(
-	struct i2c_engine *engine,
-	uint8_t *returned_bytes)
-{
-	uint32_t i2c_sw_status = 0;
-	uint32_t value = dm_read_reg(engine->base.ctx, mmDC_I2C_SW_STATUS);
-
-	i2c_sw_status = get_reg_field_value(
-			value,
-			DC_I2C_SW_STATUS,
-			DC_I2C_SW_STATUS);
-
-	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_SW)
-		return I2C_CHANNEL_OPERATION_ENGINE_BUSY;
-	else if (value & DC_I2C_SW_STATUS__DC_I2C_SW_STOPPED_ON_NACK_MASK)
-		return I2C_CHANNEL_OPERATION_NO_RESPONSE;
-	else if (value & DC_I2C_SW_STATUS__DC_I2C_SW_TIMEOUT_MASK)
-		return I2C_CHANNEL_OPERATION_TIMEOUT;
-	else if (value & DC_I2C_SW_STATUS__DC_I2C_SW_ABORTED_MASK)
-		return I2C_CHANNEL_OPERATION_FAILED;
-	else if (value & DC_I2C_SW_STATUS__DC_I2C_SW_DONE_MASK)
-		return I2C_CHANNEL_OPERATION_SUCCEEDED;
-
-	/*
-	 * this is the case when HW used for communication, I2C_SW_STATUS
-	 * could be zero
-	 */
-	return I2C_CHANNEL_OPERATION_SUCCEEDED;
-}
-
-static void destroy(
-	struct i2c_engine **i2c_engine)
-{
-	struct i2c_hw_engine_dce110 *engine_dce110 =
-			FROM_I2C_ENGINE(*i2c_engine);
-
-	dal_i2c_hw_engine_destruct(&engine_dce110->base);
-
-	dm_free(engine_dce110);
-
-	*i2c_engine = NULL;
-}
-
-static const struct i2c_engine_funcs i2c_engine_funcs = {
-	.destroy = destroy,
-	.get_speed = get_speed,
-	.set_speed = set_speed,
-	.setup_engine = setup_engine,
-	.submit_channel_request = submit_channel_request,
-	.process_channel_reply = process_channel_reply,
-	.get_channel_status = get_channel_status,
-	.acquire_engine = dal_i2c_hw_engine_acquire_engine,
-};
-
-static bool construct(
-	struct i2c_hw_engine_dce110 *engine_dce110,
-	const struct i2c_hw_engine_dce110_create_arg *arg)
-{
-	if (!i2c_hw_engine_dce110_construct(engine_dce110, arg))
-		return false;
-
-	engine_dce110->base.base.funcs = &i2c_engine_funcs;
-
-	return true;
-}
-
-struct i2c_engine *dal_i2c_hw_engine_dce112_create(
-	const struct i2c_hw_engine_dce110_create_arg *arg)
-{
-	struct i2c_hw_engine_dce110 *engine_dce10;
-
-	if (!arg) {
-		ASSERT_CRITICAL(false);
-		return NULL;
-	}
-
-	engine_dce10 = dm_alloc(sizeof(struct i2c_hw_engine_dce110));
-
-	if (!engine_dce10) {
-		ASSERT_CRITICAL(false);
-		return NULL;
-	}
-
-	if (construct(engine_dce10, arg))
-		return &engine_dce10->base.base;
-
-	ASSERT_CRITICAL(false);
-
-	dm_free(engine_dce10);
-
-	return NULL;
-}
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.h b/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.h
deleted file mode 100644
index 9202aba..0000000
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2c_hw_engine_dce112.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_I2C_HW_ENGINE_DCE112_H__
-#define __DAL_I2C_HW_ENGINE_DCE112_H__
-
-#include "../dce110/i2c_hw_engine_dce110.h"
-
-struct i2c_engine *dal_i2c_hw_engine_dce112_create(
-	const struct i2c_hw_engine_dce110_create_arg *arg);
-
-#endif
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2caux_dce112.c b/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2caux_dce112.c
index 5311335..a3478f0 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2caux_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/dce112/i2caux_dce112.c
@@ -37,7 +37,7 @@
 
 #include "../dce110/aux_engine_dce110.h"
 
-#include "i2c_hw_engine_dce112.h"
+#include "../dce110/i2c_hw_engine_dce110.h"
 
 static const enum gpio_ddc_line hw_ddc_lines[] = {
 	GPIO_DDC_LINE_DDC1,
@@ -65,6 +65,11 @@ static const enum gpio_ddc_line hw_ddc_lines[] = {
 	.AUX_RESET_MASK = AUX_CONTROL__AUX_RESET_MASK \
 }
 
+#define hw_engine_regs(id)\
+{\
+		I2C_HW_ENGINE_COMMON_REG_LIST(id) \
+}
+
 static const struct dce110_aux_registers dce112_aux_regs[] = {
 		aux_regs(0),
 		aux_regs(1),
@@ -74,6 +79,15 @@ static const struct dce110_aux_registers dce112_aux_regs[] = {
 		aux_regs(5),
 };
 
+static const struct dce110_i2c_hw_engine_registers dce112_hw_engine_regs[] = {
+		hw_engine_regs(1),
+		hw_engine_regs(2),
+		hw_engine_regs(3),
+		hw_engine_regs(4),
+		hw_engine_regs(5),
+		hw_engine_regs(6)
+};
+
 static bool construct(
 	struct i2caux_dce110 *i2caux_dce110,
 	struct adapter_service *as,
@@ -109,12 +123,13 @@ static bool construct(
 		hw_arg_dce110.reference_frequency = reference_frequency;
 		hw_arg_dce110.default_speed = base->default_i2c_hw_speed;
 		hw_arg_dce110.ctx = ctx;
+		hw_arg_dce110.regs = &dce112_hw_engine_regs[i];
 
 		if (base->i2c_hw_engines[line_id])
 			base->i2c_hw_engines[line_id]->funcs->destroy(&base->i2c_hw_engines[line_id]);
 
 		base->i2c_hw_engines[line_id] =
-			dal_i2c_hw_engine_dce112_create(&hw_arg_dce110);
+			dal_i2c_hw_engine_dce110_create(&hw_arg_dce110);
 
 		++i;
 	} while (i < ARRAY_SIZE(hw_ddc_lines));
-- 
2.7.4

