From d914203d0f070851dc6ce11e8153b51a62474bf4 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Mon, 6 Jun 2016 13:25:43 -0400
Subject: [PATCH 0565/1722] drm/amd/dal: Refactor MPO for and surface

Refactor MPO and attach surface code to be more generic.
Temporarily breaks MPO for DCE11 until the hw sequence is fixed

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  53 --------
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 141 ++++++++++++++++++---
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  52 +++++++-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   4 +
 drivers/gpu/drm/amd/dal/dc/inc/resource.h          |   6 +
 5 files changed, 182 insertions(+), 74 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 4699f26..11b749e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -362,49 +362,6 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
 	WriteReg (mmDPGV1_REPEATER_PROGRAM, 0x11);
 }
 */
-static int8_t acquire_first_free_underlay(
-		struct resource_context *res_ctx,
-		struct core_stream *stream,
-		struct core_dc* core_dc)
-{
-	if (!res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX].stream) {
-		struct dc_bios *dcb;
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX];
-
-		pipe_ctx->tg = res_ctx->pool.timing_generators[DCE110_UNDERLAY_IDX];
-		pipe_ctx->mi = res_ctx->pool.mis[DCE110_UNDERLAY_IDX];
-		/*pipe_ctx->ipp = res_ctx->pool.ipps[DCE110_UNDERLAY_IDX];*/
-		pipe_ctx->xfm = res_ctx->pool.transforms[DCE110_UNDERLAY_IDX];
-		pipe_ctx->opp = res_ctx->pool.opps[DCE110_UNDERLAY_IDX];
-		pipe_ctx->dis_clk = res_ctx->pool.display_clock;
-		pipe_ctx->pipe_idx = DCE110_UNDERLAY_IDX;
-
-		dcb = dal_adapter_service_get_bios_parser(
-						res_ctx->pool.adapter_srv);
-
-		core_dc->hwss.enable_display_power_gating(
-			core_dc->ctx,
-			DCE110_UNDERLAY_IDX,
-			dcb, PIPE_GATING_CONTROL_DISABLE);
-
-		if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
-			dm_error("DC: failed to blank crtc!\n");
-			BREAK_TO_DEBUGGER();
-		}
-
-		if (!pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
-			BREAK_TO_DEBUGGER();
-		}
-
-		pipe_ctx->tg->funcs->set_blank_color(
-				pipe_ctx->tg,
-				COLOR_SPACE_YCBCR601);/* TODO unhardcode*/
-
-		pipe_ctx->stream = stream;
-		return DCE110_UNDERLAY_IDX;
-	}
-	return -1;
-}
 
 /*******************************************************************************
  * Public functions
@@ -912,16 +869,6 @@ bool dc_commit_surfaces_to_target(
 		if (new_surfaces[i]->visible)
 			new_enabled_surface_count++;
 
-	/* TODO unhack mpo */
-	if (new_surface_count == 2 && target_status->surface_count < 2) {
-		acquire_first_free_underlay(&context->res_ctx,
-				DC_STREAM_TO_CORE(dc_target->streams[0]), core_dc);
-		is_mpo_turning_on = true;
-	} else if (new_surface_count < 2 && target_status->surface_count == 2) {
-		context->res_ctx.pipe_ctx[DCE110_UNDERLAY_IDX].stream = NULL;
-		context->res_ctx.pipe_ctx[DCE110_UNDERLAY_IDX].surface = NULL;
-	}
-
 	dal_logger_write(core_dc->ctx->logger,
 				LOG_MAJOR_INTERFACE_TRACE,
 				LOG_MINOR_COMPONENT_DC,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index a305ace..67f9d16 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -479,15 +479,110 @@ void resource_build_scaling_params_for_context(
 	}
 }
 
+static void detach_surfaces_for_target(
+		struct validate_context *context,
+		const struct dc_target *dc_target)
+{
+	int i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+		if (cur_pipe->stream == stream) {
+			cur_pipe->surface = NULL;
+			cur_pipe->top_pipe = NULL;
+			cur_pipe->bottom_pipe = NULL;
+		}
+	}
+}
+
+struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx)
+{
+	int i;
+	struct pipe_ctx *secondary_pipe = NULL;
+
+	/*
+	 * search backwards for the second pipe to keep pipe
+	 * assignment more consistent
+	 */
+
+	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+		if (res_ctx->pipe_ctx[i].stream == NULL) {
+			secondary_pipe = &res_ctx->pipe_ctx[i];
+			secondary_pipe->pipe_idx = i;
+			break;
+		}
+	}
+
+
+	return secondary_pipe;
+}
+
+struct pipe_ctx *resource_get_head_pipe_for_stream(
+		struct resource_context *res_ctx,
+		const struct core_stream *stream)
+{
+	int i;
+	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+		if (res_ctx->pipe_ctx[i].stream == stream &&
+				!res_ctx->pipe_ctx[i].top_pipe) {
+			return &res_ctx->pipe_ctx[i];
+			break;
+		}
+	}
+	return NULL;
+}
+
+static struct pipe_ctx *acquire_free_pipe_for_target(
+		struct resource_context *res_ctx,
+		const struct dc_target *dc_target)
+{
+	int i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+
+	struct pipe_ctx *head_pipe = NULL;
+
+	/* Find head pipe, which has the back end set up*/
+
+	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
+
+	if (!head_pipe)
+		ASSERT(0);
+
+	if (!head_pipe->surface)
+		return head_pipe;
+
+	/* Re-use pipe already acquired for this stream if available*/
+	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+		if (res_ctx->pipe_ctx[i].stream == stream &&
+				!res_ctx->pipe_ctx[i].surface) {
+			return &res_ctx->pipe_ctx[i];
+		}
+	}
+
+	/*
+	 * At this point we have no re-useable pipe for this stream and we need
+	 * to acquire an idle one to satisfy the request
+	 */
+
+	if(!res_ctx->pool->funcs->acquire_idle_pipe_for_layer)
+		return NULL;
+
+	return res_ctx->pool->funcs->acquire_idle_pipe_for_layer(res_ctx, stream);
+
+}
+
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *surfaces[],
 		int surface_count,
 		const struct dc_target *dc_target,
 		struct validate_context *context)
 {
-	int i, j, k;
+	int i;
+	struct pipe_ctx *tail_pipe;
 	struct dc_target_status *target_status = NULL;
 
+
 	if (surface_count > MAX_SURFACE_NUM) {
 		dm_error("Surface: can not attach %d surfaces! Maximum is: %d\n",
 			surface_count, MAX_SURFACE_NUM);
@@ -508,39 +603,45 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++)
 		dc_surface_retain(surfaces[i]);
 
+	detach_surfaces_for_target(context, dc_target);
+
 	/* release existing surfaces*/
 	for (i = 0; i < target_status->surface_count; i++) {
 		dc_surface_release(target_status->surfaces[i]);
 		target_status->surfaces[i] = NULL;
 	}
 
-	/* assign new surfaces*/
-	for (i = 0; i < surface_count; i++)
-		target_status->surfaces[i] = surfaces[i];
-
-	target_status->surface_count = surface_count;
+	target_status->surface_count = 0;
 
-	for (i = 0; i < dc_target->stream_count; i++) {
-		k = 0;
-		for (j = 0; j < MAX_PIPES; j++) {
-			struct core_surface *surface = NULL;
+	if (surface_count == 0)
+		return true;
 
-			/* Skip surface assignment for child pipes */
-			if (context->res_ctx.pipe_ctx[j].top_pipe != NULL)
-				continue;
+	tail_pipe = NULL;
+	for (i = 0; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_target(
+				&context->res_ctx, dc_target);
 
-			if (k < surface_count)
-				surface = DC_SURFACE_TO_CORE(surfaces[k]);
+		if (!free_pipe)
+			return false;
 
-			if (context->res_ctx.pipe_ctx[j].stream !=
-				DC_STREAM_TO_CORE(dc_target->streams[i]))
-				continue;
+		free_pipe->surface = surface;
 
-			context->res_ctx.pipe_ctx[j].surface = surface;
-			k++;
+		if (tail_pipe) {
+			free_pipe->top_pipe = tail_pipe;
+			tail_pipe->bottom_pipe = free_pipe;
 		}
+
+		tail_pipe = free_pipe;
 	}
 
+
+	/* assign new surfaces*/
+	for (i = 0; i < surface_count; i++)
+		target_status->surfaces[i] = surfaces[i];
+
+	target_status->surface_count = surface_count;
+
 	return true;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index 63ec98a..40bd013 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -931,12 +931,62 @@ enum dc_status dce110_validate_guaranteed(
 	return result;
 }
 
+static struct pipe_ctx *dce110_acquire_idle_pipe_for_layer(
+                struct resource_context *res_ctx,
+                struct core_stream *stream)
+{
+        struct dc_bios *dcb;
+        struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX];
+ 
+        if (res_ctx->pipe_ctx[DCE110_UNDERLAY_IDX].stream) {
+                return NULL;
+        }
+ 
+        pipe_ctx->tg = res_ctx->pool->timing_generators[DCE110_UNDERLAY_IDX];
+        pipe_ctx->mi = res_ctx->pool->mis[DCE110_UNDERLAY_IDX];
+        /*pipe_ctx->ipp = res_ctx->pool->ipps[DCE110_UNDERLAY_IDX];*/
+        pipe_ctx->xfm = res_ctx->pool->transforms[DCE110_UNDERLAY_IDX];
+        pipe_ctx->opp = res_ctx->pool->opps[DCE110_UNDERLAY_IDX];
+        pipe_ctx->dis_clk = res_ctx->pool->display_clock;
+        pipe_ctx->pipe_idx = DCE110_UNDERLAY_IDX;
+ 
+        dcb = dal_adapter_service_get_bios_parser(
+                                        res_ctx->pool->adapter_srv);
+ 
+        /* TODO move underlay pipe enable to apply_ctx_to_surface for dce11*/
+#if 0
+       dc->hwss.enable_display_power_gating(
+                dc->ctx,
+                DCE110_UNDERLAY_IDX,
+                dcb, PIPE_GATING_CONTROL_DISABLE);
+ 
+        if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
+                dm_error("DC: failed to blank crtc!\n");
+                BREAK_TO_DEBUGGER();
+        }
+ 
+        if (!pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
+                BREAK_TO_DEBUGGER();
+        }
+ 
+        pipe_ctx->tg->funcs->set_blank_color(
+                        pipe_ctx->tg,
+                        COLOR_SPACE_YCBCR601);/* TODO unhardcode*/
+#endif
+ 
+        pipe_ctx->stream = stream;
+ 
+        return pipe_ctx;
+
+}
+
 static const struct resource_funcs dce110_res_pool_funcs = {
 	.destruct = dce110_destruct_resource_pool,
 	.link_enc_create = dce110_link_encoder_create,
 	.validate_with_context = dce110_validate_with_context,
 	.validate_guaranteed = dce110_validate_guaranteed,
-	.validate_bandwidth = dce110_validate_bandwidth
+	.validate_bandwidth = dce110_validate_bandwidth,
+	.acquire_idle_pipe_for_layer = dce110_acquire_idle_pipe_for_layer
 };
 
 static void underlay_create(struct dc_context *ctx, struct resource_pool *pool)
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index db93d14..47c0bfa 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -214,6 +214,7 @@ void core_link_disable_stream(struct pipe_ctx *pipe_ctx);
 
 struct resource_pool;
 struct validate_context;
+struct resource_context;
 
 struct resource_funcs {
 	void (*destruct)(struct resource_pool *pool);
@@ -237,6 +238,9 @@ struct resource_funcs {
 	struct validate_context *(*apply_clk_constraints)(
 					const struct core_dc *dc,
 					struct validate_context *context);
+	struct pipe_ctx *(*acquire_idle_pipe_for_layer)(
+			struct resource_context *res_ctx,
+			struct core_stream *stream);
 };
 
 struct resource_pool {
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/resource.h b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
index 0147f41..505e718 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/resource.h
@@ -76,12 +76,18 @@ struct clock_source *resource_find_used_clk_src_for_sharing(
 struct clock_source *dc_resource_find_first_free_pll(
 		struct resource_context *res_ctx);
 
+struct pipe_ctx *resource_get_head_pipe_for_stream(
+		struct resource_context *res_ctx,
+		const struct core_stream *stream);
+
 bool resource_attach_surfaces_to_context(
 		struct dc_surface *surfaces[],
 		int surface_count,
 		const struct dc_target *dc_target,
 		struct validate_context *context);
 
+struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx);
+
 bool resource_is_stream_unchanged(
 	const struct validate_context *old_context, struct core_stream *stream);
 
-- 
2.7.4

