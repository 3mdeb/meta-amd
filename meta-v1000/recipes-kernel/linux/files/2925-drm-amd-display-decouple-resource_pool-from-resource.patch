From f38abf76327c81982d0010ceceed9a4eee898153 Mon Sep 17 00:00:00 2001
From: Tony Cheng <tony.cheng@amd.com>
Date: Sat, 22 Apr 2017 14:17:51 -0400
Subject: [PATCH 2925/3082] drm/amd/display: decouple resource_pool from
 resource_context

to avoid null access in case res_ctx is used to access res_pool before it's fully constructed

also make it clear which function has dependency on resource_pool

Signed-off-by: Tony Cheng <tony.cheng@amd.com>
Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc.c           |  19 ++-
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c   |   2 +-
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  | 143 ++++++++++++---------
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |   2 +-
 drivers/gpu/drm/amd/display/dc/core/dc_surface.c   |   3 +-
 .../amd/display/dc/dce100/dce100_hw_sequencer.c    |   4 +-
 .../drm/amd/display/dc/dce100/dce100_resource.c    |   8 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    |  42 +++---
 .../drm/amd/display/dc/dce110/dce110_resource.c    |  25 ++--
 .../drm/amd/display/dc/dce112/dce112_resource.c    |  35 +++--
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |   8 +-
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |   2 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h      |  15 ++-
 13 files changed, 161 insertions(+), 147 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2e74fae..3798663 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -736,7 +736,7 @@ static void program_timing_sync(
 {
 	int i, j;
 	int group_index = 0;
-	int pipe_count = ctx->res_ctx.pool->pipe_count;
+	int pipe_count = core_dc->res_pool->pipe_count;
 	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
 
 	for (i = 0; i < pipe_count; i++) {
@@ -939,7 +939,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	post_surface_trace(dc);
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
 			context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
@@ -1015,7 +1015,7 @@ static bool is_surface_in_context(
 {
 	int j;
 
-	for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 		if (surface == &pipe_ctx->surface->public) {
@@ -1245,7 +1245,8 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, dc_stream, context)) {
+				new_surfaces, surface_count, dc_stream,
+				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
 		}
@@ -1304,7 +1305,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* not sure if we still need this */
 		if (update_type == UPDATE_TYPE_FULL) {
-			for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 				if (pipe_ctx->surface != surface)
@@ -1365,7 +1366,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (pipe_ctx->surface != surface)
@@ -1389,7 +1390,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 				context_timing_trace(dc, &context->res_ctx);
 		}
 
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 			struct pipe_ctx *cur_pipe_ctx;
 			bool is_new_pipe_surface = true;
@@ -1427,7 +1428,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	}
 
 	/* Unlock pipes */
-	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
+	for (i = core_dc->res_pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		for (j = 0; j < surface_count; j++) {
@@ -1571,8 +1572,6 @@ void dc_set_power_state(
 		memset(core_dc->current_context, 0,
 				sizeof(*core_dc->current_context));
 
-		core_dc->current_context->res_ctx.pool = core_dc->res_pool;
-
 		break;
 	}
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index f883fdb..4b9d3f1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -2245,7 +2245,7 @@ static void set_crtc_test_pattern(struct core_link *link,
 	case DP_TEST_PATTERN_VIDEO_MODE:
 	{
 		/* restore bitdepth reduction */
-		link->dc->current_context->res_ctx.pool->funcs->
+		link->dc->res_pool->funcs->
 			build_bit_depth_reduction_params(pipe_ctx->stream,
 					&params);
 		pipe_ctx->stream->bit_depth_params = params;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index cdb98d5..43e5758 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -233,11 +233,12 @@ bool resource_construct(
 
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct clock_source **clock_source)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
-		if (res_ctx->pool->clock_sources[i] != *clock_source)
+	for (i = 0; i < pool->clk_src_count; i++) {
+		if (pool->clock_sources[i] != *clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]--;
@@ -248,7 +249,7 @@ void resource_unreference_clock_source(
 		break;
 	}
 
-	if (res_ctx->pool->dp_clock_source == *clock_source) {
+	if (pool->dp_clock_source == *clock_source) {
 		res_ctx->dp_clock_source_ref_count--;
 
 		if (res_ctx->dp_clock_source_ref_count == 0)
@@ -259,18 +260,19 @@ void resource_unreference_clock_source(
 
 void resource_reference_clock_source(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct clock_source *clock_source)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
-		if (res_ctx->pool->clock_sources[i] != clock_source)
+	for (i = 0; i < pool->clk_src_count; i++) {
+		if (pool->clock_sources[i] != clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]++;
 		break;
 	}
 
-	if (res_ctx->pool->dp_clock_source == clock_source)
+	if (pool->dp_clock_source == clock_source)
 		res_ctx->dp_clock_source_ref_count++;
 }
 
@@ -861,12 +863,13 @@ enum dc_status resource_build_scaling_params_for_context(
 
 static void detach_surfaces_for_stream(
 		struct validate_context *context,
+		const struct resource_pool *pool,
 		const struct dc_stream *dc_stream)
 {
 	int i;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
 		if (cur_pipe->stream == stream) {
 			cur_pipe->surface = NULL;
@@ -876,7 +879,9 @@ static void detach_surfaces_for_stream(
 	}
 }
 
-struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx)
+struct pipe_ctx *find_idle_secondary_pipe(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
 	struct pipe_ctx *secondary_pipe = NULL;
@@ -886,7 +891,7 @@ struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx)
 	 * assignment more consistent
 	 */
 
-	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == NULL) {
 			secondary_pipe = &res_ctx->pipe_ctx[i];
 			secondary_pipe->pipe_idx = i;
@@ -903,7 +908,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 		const struct core_stream *stream)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				res_ctx->pipe_ctx[i].stream_enc) {
 			return &res_ctx->pipe_ctx[i];
@@ -919,6 +924,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
  */
 static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct validate_context *context,
+		const struct resource_pool *pool,
 		const struct dc_stream *dc_stream)
 {
 	int i;
@@ -938,7 +944,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 		return head_pipe;
 
 	/* Re-use pipe already acquired for this stream if available*/
-	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				!res_ctx->pipe_ctx[i].surface) {
 			return &res_ctx->pipe_ctx[i];
@@ -950,10 +956,10 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	 * to acquire an idle one to satisfy the request
 	 */
 
-	if(!res_ctx->pool->funcs->acquire_idle_pipe_for_layer)
+	if (!pool->funcs->acquire_idle_pipe_for_layer)
 		return NULL;
 
-	return res_ctx->pool->funcs->acquire_idle_pipe_for_layer(context, stream);
+	return pool->funcs->acquire_idle_pipe_for_layer(context, pool, stream);
 
 }
 
@@ -964,7 +970,7 @@ static void release_free_pipes_for_stream(
 	int i;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
-	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+	for (i = MAX_PIPES - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				!res_ctx->pipe_ctx[i].surface) {
 			res_ctx->pipe_ctx[i].stream = NULL;
@@ -976,7 +982,8 @@ bool resource_attach_surfaces_to_context(
 		const struct dc_surface * const *surfaces,
 		int surface_count,
 		const struct dc_stream *dc_stream,
-		struct validate_context *context)
+		struct validate_context *context,
+		const struct resource_pool *pool)
 {
 	int i;
 	struct pipe_ctx *tail_pipe;
@@ -1003,7 +1010,7 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++)
 		dc_surface_retain(surfaces[i]);
 
-	detach_surfaces_for_stream(context, dc_stream);
+	detach_surfaces_for_stream(context, pool, dc_stream);
 
 	/* release existing surfaces*/
 	for (i = 0; i < stream_status->surface_count; i++)
@@ -1020,7 +1027,8 @@ bool resource_attach_surfaces_to_context(
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
-		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(context, dc_stream);
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
+				context, pool, dc_stream);
 
 		if (!free_pipe) {
 			stream_status->surfaces[i] = NULL;
@@ -1101,7 +1109,8 @@ bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
 		int set_count,
 		const struct validate_context *old_context,
-		struct validate_context *context)
+		struct validate_context *context,
+		const struct resource_pool *pool)
 {
 	int i, j;
 
@@ -1114,7 +1123,7 @@ bool resource_validate_attach_surfaces(
 						old_context->stream_status[j].surfaces,
 						old_context->stream_status[j].surface_count,
 						&context->streams[i]->public,
-						context))
+						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
 			}
@@ -1123,7 +1132,7 @@ bool resource_validate_attach_surfaces(
 					set[i].surfaces,
 					set[i].surface_count,
 					&context->streams[i]->public,
-					context))
+					context, pool))
 				return false;
 
 	}
@@ -1136,12 +1145,13 @@ bool resource_validate_attach_surfaces(
 
 static void set_stream_engine_in_use(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct stream_encoder *stream_enc)
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
-		if (res_ctx->pool->stream_enc[i] == stream_enc)
+	for (i = 0; i < pool->stream_enc_count; i++) {
+		if (pool->stream_enc[i] == stream_enc)
 			res_ctx->is_stream_enc_acquired[i] = true;
 	}
 }
@@ -1149,32 +1159,33 @@ static void set_stream_engine_in_use(
 /* TODO: release audio object */
 static void set_audio_in_use(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct audio *audio)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->audio_count; i++) {
-		if (res_ctx->pool->audios[i] == audio) {
+	for (i = 0; i < pool->audio_count; i++) {
+		if (pool->audios[i] == audio)
 			res_ctx->is_audio_acquired[i] = true;
-		}
 	}
 }
 
 static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct core_stream *stream)
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+	for (i = 0; i < pool->pipe_count; i++) {
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-			pipe_ctx->tg = res_ctx->pool->timing_generators[i];
-			pipe_ctx->mi = res_ctx->pool->mis[i];
-			pipe_ctx->ipp = res_ctx->pool->ipps[i];
-			pipe_ctx->xfm = res_ctx->pool->transforms[i];
-			pipe_ctx->opp = res_ctx->pool->opps[i];
-			pipe_ctx->dis_clk = res_ctx->pool->display_clock;
+			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->mi = pool->mis[i];
+			pipe_ctx->ipp = pool->ipps[i];
+			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -1186,21 +1197,22 @@ static int acquire_first_free_pipe(
 
 static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct core_stream *stream)
 {
 	int i;
 	int j = -1;
 	struct core_link *link = stream->sink->link;
 
-	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
+	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (!res_ctx->is_stream_enc_acquired[i] &&
-					res_ctx->pool->stream_enc[i]) {
+				pool->stream_enc[i]) {
 			/* Store first available for MST second display
 			 * in daisy chain use case */
 			j = i;
-			if (res_ctx->pool->stream_enc[i]->id ==
+			if (pool->stream_enc[i]->id ==
 					link->link_enc->preferred_engine)
-				return res_ctx->pool->stream_enc[i];
+				return pool->stream_enc[i];
 		}
 	}
 
@@ -1218,17 +1230,19 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 	 */
 
 	if (j >= 0 && dc_is_dp_signal(stream->signal))
-		return res_ctx->pool->stream_enc[j];
+		return pool->stream_enc[j];
 
 	return NULL;
 }
 
-static struct audio *find_first_free_audio(struct resource_context *res_ctx)
+static struct audio *find_first_free_audio(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->audio_count; i++) {
+	for (i = 0; i < pool->audio_count; i++) {
 		if (res_ctx->is_audio_acquired[i] == false) {
-			return res_ctx->pool->audios[i];
+			return pool->audios[i];
 		}
 	}
 
@@ -1358,6 +1372,7 @@ enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
+	const struct resource_pool *pool = dc->res_pool;
 	int i, j;
 
 	calculate_phy_pix_clks(dc, context);
@@ -1370,12 +1385,12 @@ enum dc_status resource_map_pool_resources(
 				stream->bit_depth_params =
 						dc->current_context->streams[i]->bit_depth_params;
 				stream->clamping = dc->current_context->streams[i]->clamping;
-			continue;
+				continue;
+			}
 		}
-	}
 
 		/* mark resources used for stream that is already active */
-		for (j = 0; j < MAX_PIPES; j++) {
+		for (j = 0; j < pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx =
 				&context->res_ctx.pipe_ctx[j];
 			const struct pipe_ctx *old_pipe_ctx =
@@ -1395,7 +1410,7 @@ enum dc_status resource_map_pool_resources(
 				continue;
 
 			set_stream_engine_in_use(
-				&context->res_ctx,
+				&context->res_ctx, pool,
 				pipe_ctx->stream_enc);
 
 			/* Switch to dp clock source only if there is
@@ -1404,15 +1419,14 @@ enum dc_status resource_map_pool_resources(
 			 */
 			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
 				!find_pll_sharable_stream(stream, context))
-				pipe_ctx->clock_source =
-					context->res_ctx.pool->dp_clock_source;
+				pipe_ctx->clock_source = pool->dp_clock_source;
 
 			resource_reference_clock_source(
-				&context->res_ctx,
+				&context->res_ctx, pool,
 				pipe_ctx->clock_source);
 
-			set_audio_in_use(&context->res_ctx,
-					 pipe_ctx->audio);
+			set_audio_in_use(&context->res_ctx, pool,
+					pipe_ctx->audio);
 		}
 	}
 
@@ -1424,22 +1438,22 @@ enum dc_status resource_map_pool_resources(
 		if (resource_is_stream_unchanged(dc->current_context, stream))
 			continue;
 		/* acquire new resources */
-		pipe_idx = acquire_first_free_pipe(&context->res_ctx, stream);
+		pipe_idx = acquire_first_free_pipe(
+				&context->res_ctx, pool, stream);
 		if (pipe_idx < 0)
 			return DC_NO_CONTROLLER_RESOURCE;
 
-
 		pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
 
 		pipe_ctx->stream_enc =
 			find_first_free_match_stream_enc_for_link(
-				&context->res_ctx, stream);
+				&context->res_ctx, pool, stream);
 
 		if (!pipe_ctx->stream_enc)
 			return DC_NO_STREAM_ENG_RESOURCE;
 
 		set_stream_engine_in_use(
-			&context->res_ctx,
+			&context->res_ctx, pool,
 			pipe_ctx->stream_enc);
 
 		/* TODO: Add check if ASIC support and EDID audio */
@@ -1447,7 +1461,7 @@ enum dc_status resource_map_pool_resources(
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 			stream->public.audio_info.mode_count) {
 			pipe_ctx->audio = find_first_free_audio(
-				&context->res_ctx);
+				&context->res_ctx, pool);
 
 			/*
 			 * Audio assigned in order first come first get.
@@ -1456,7 +1470,7 @@ enum dc_status resource_map_pool_resources(
 			 */
 			if (pipe_ctx->audio)
 				set_audio_in_use(
-					&context->res_ctx,
+					&context->res_ctx, pool,
 					pipe_ctx->audio);
 		}
 
@@ -2077,7 +2091,7 @@ void dc_resource_validate_ctx_copy_construct(
 
 	*dst_ctx = *src_ctx;
 
-	for (i = 0; i < dst_ctx->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *cur_pipe = &dst_ctx->res_ctx.pipe_ctx[i];
 
 		if (cur_pipe->top_pipe)
@@ -2097,13 +2111,14 @@ void dc_resource_validate_ctx_copy_construct(
 }
 
 struct clock_source *dc_resource_find_first_free_pll(
-		struct resource_context *res_ctx)
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool->clk_src_count; ++i) {
+	for (i = 0; i < pool->clk_src_count; ++i) {
 		if (res_ctx->clock_source_ref_count[i] == 0)
-			return res_ctx->pool->clock_sources[i];
+			return pool->clock_sources[i];
 	}
 
 	return NULL;
@@ -2151,6 +2166,7 @@ enum dc_status resource_map_clock_resources(
 		struct validate_context *context)
 {
 	int i, j;
+	const struct resource_pool *pool = dc->res_pool;
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
@@ -2168,8 +2184,7 @@ enum dc_status resource_map_clock_resources(
 
 			if (dc_is_dp_signal(pipe_ctx->stream->signal)
 				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
-				pipe_ctx->clock_source =
-					context->res_ctx.pool->dp_clock_source;
+				pipe_ctx->clock_source = pool->dp_clock_source;
 			else {
 				pipe_ctx->clock_source = NULL;
 
@@ -2180,14 +2195,16 @@ enum dc_status resource_map_clock_resources(
 
 				if (pipe_ctx->clock_source == NULL)
 					pipe_ctx->clock_source =
-						dc_resource_find_first_free_pll(&context->res_ctx);
+						dc_resource_find_first_free_pll(
+							&context->res_ctx,
+							pool);
 			}
 
 			if (pipe_ctx->clock_source == NULL)
 				return DC_NO_CLOCK_SOURCE_RESOURCE;
 
 			resource_reference_clock_source(
-				&context->res_ctx,
+				&context->res_ctx, pool,
 				pipe_ctx->clock_source);
 
 			/* only one cs per stream regardless of mpo */
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 23627b1..99b6a16 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -240,7 +240,7 @@ bool dc_stream_set_cursor_position(
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
-			.ref_clk_khz = res_ctx->pool->ref_clock_inKhz,
+			.ref_clk_khz = core_dc->res_pool->ref_clock_inKhz,
 			.viewport_x_start = pipe_ctx->scl_data.viewport.x,
 			.viewport_width = pipe_ctx->scl_data.viewport.width,
 			.h_scale_ratio = pipe_ctx->scl_data.ratios.horz
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 943895f..aa6ac95 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -138,8 +138,7 @@ const struct dc_surface_status *dc_surface_get_status(
 	if (core_dc->current_context == NULL)
 		return NULL;
 
-	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count;
-			i++) {
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
index dd6f0b1..30c197f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
@@ -132,8 +132,8 @@ void dce100_set_bandwidth(
 		bool decrease_allowed)
 {
 	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
-		context->res_ctx.pool->display_clock->funcs->set_clock(
-				context->res_ctx.pool->display_clock,
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
 				context->dispclk_khz * 115 / 100);
 		dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
 		dc->current_context->dispclk_khz = context->dispclk_khz;
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index f65b785..f070070 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -804,8 +804,6 @@ enum dc_status dce100_validate_with_context(
 	if (!dce100_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	for (i = 0; i < set_count; i++) {
 		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
 		dc_stream_retain(&context->streams[i]->public);
@@ -817,8 +815,8 @@ enum dc_status dce100_validate_with_context(
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
-	if (!resource_validate_attach_surfaces(
-			set, set_count, dc->current_context, context)) {
+	if (!resource_validate_attach_surfaces(set, set_count,
+			dc->current_context, context, dc->res_pool)) {
 		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
@@ -843,8 +841,6 @@ enum dc_status dce100_validate_guaranteed(
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
 	dc_stream_retain(&context->streams[0]->public);
 	context->stream_count++;
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0e69ace..dc4c164 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1260,10 +1260,12 @@ void dce110_set_displaymarks(
 	}
 }
 
-static void set_safe_displaymarks(struct resource_context *res_ctx)
+static void set_safe_displaymarks(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
-	int underlay_idx = res_ctx->pool->underlay_pipe_index;
+	int underlay_idx = pool->underlay_pipe_index;
 	struct bw_watermarks max_marks = {
 		MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK };
 	struct bw_watermarks nbp_marks = {
@@ -1308,9 +1310,11 @@ static void switch_dp_clock_sources(
 			if (clk_src &&
 				clk_src != pipe_ctx->clock_source) {
 				resource_unreference_clock_source(
-					res_ctx, &pipe_ctx->clock_source);
+					res_ctx, dc->res_pool,
+					&pipe_ctx->clock_source);
 				pipe_ctx->clock_source = clk_src;
-				resource_reference_clock_source(res_ctx, clk_src);
+				resource_reference_clock_source(
+						res_ctx, dc->res_pool, clk_src);
 
 				dce_crtc_switch_to_clk_src(dc->hwseq, clk_src, i);
 			}
@@ -1336,8 +1340,8 @@ static void reset_single_pipe_hw_ctx(
 	pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
 	pipe_ctx->mi->funcs->free_mem_input(
 				pipe_ctx->mi, context->stream_count);
-	resource_unreference_clock_source(
-			&context->res_ctx, &pipe_ctx->clock_source);
+	resource_unreference_clock_source(&context->res_ctx, dc->res_pool,
+			 &pipe_ctx->clock_source);
 
 	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
 
@@ -1530,7 +1534,7 @@ static enum dc_status apply_ctx_to_hw_fpga(
 	enum dc_status status = DC_ERROR_UNEXPECTED;
 	int i;
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 				&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1561,7 +1565,7 @@ static void reset_hw_ctx_wrap(
 
 	/* Reset old context */
 	/* look up the targets that have been removed since last commit */
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1609,7 +1613,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	dcb->funcs->set_scratch_critical_state(dcb, true);
 
 	/* below is for real asic only */
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1629,14 +1633,14 @@ enum dc_status dce110_apply_ctx_to_hw(
 				PIPE_GATING_CONTROL_DISABLE);
 	}
 
-	set_safe_displaymarks(&context->res_ctx);
+	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 	if (context->dispclk_khz
 			> dc->current_context->dispclk_khz) {
-		context->res_ctx.pool->display_clock->funcs->set_clock(
-				context->res_ctx.pool->display_clock,
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
 				context->dispclk_khz * 115 / 100);
 	}
 	/* program audio wall clock. use HDMI as clock source if HDMI
@@ -1658,7 +1662,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	* find first available pipe with audio, setup audio wall DTO per topology
 	* instead of per pipe.
 	*/
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
@@ -1685,8 +1689,8 @@ enum dc_status dce110_apply_ctx_to_hw(
 	}
 
 	/* no HDMI audio is found, try DP audio */
-	if (i == context->res_ctx.pool->pipe_count) {
-		for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	if (i == dc->res_pool->pipe_count) {
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 			if (pipe_ctx->stream == NULL)
@@ -1713,7 +1717,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		}
 	}
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -2297,8 +2301,8 @@ static void dce110_set_bandwidth(
 	dce110_set_displaymarks(dc, context);
 
 	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
-		context->res_ctx.pool->display_clock->funcs->set_clock(
-				context->res_ctx.pool->display_clock,
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
 				context->dispclk_khz * 115 / 100);
 		dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
 		dc->current_context->dispclk_khz = context->dispclk_khz;
@@ -2446,7 +2450,7 @@ static void dce110_apply_ctx_for_surface(
 	if (!surface)
 		return;
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->surface != surface)
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index f51b11d..f572439 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -866,7 +866,7 @@ static enum dc_status validate_mapped_resource(
 				continue;
 
 			if (!is_surface_pixel_format_supported(pipe_ctx,
-							       context->res_ctx.pool->underlay_pipe_index))
+					dc->res_pool->underlay_pipe_index))
 				return DC_SURFACE_PIXEL_FORMAT_UNSUPPORTED;
 
 			if (!pipe_ctx->tg->funcs->validate_timing(
@@ -918,7 +918,7 @@ bool dce110_validate_bandwidth(
 			&dc->bw_dceip,
 			&dc->bw_vbios,
 			context->res_ctx.pipe_ctx,
-			context->res_ctx.pool->pipe_count,
+			dc->res_pool->pipe_count,
 			&context->bw_results))
 		result =  true;
 	context->dispclk_khz = context->bw_results.dispclk_khz;
@@ -1030,8 +1030,6 @@ enum dc_status dce110_validate_with_context(
 	if (!dce110_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	for (i = 0; i < set_count; i++) {
 		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
 		dc_stream_retain(&context->streams[i]->public);
@@ -1043,8 +1041,8 @@ enum dc_status dce110_validate_with_context(
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
-	if (!resource_validate_attach_surfaces(
-			set, set_count, dc->current_context, context)) {
+	if (!resource_validate_attach_surfaces(set, set_count,
+			dc->current_context, context, dc->res_pool)) {
 		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
@@ -1069,8 +1067,6 @@ enum dc_status dce110_validate_guaranteed(
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
 	dc_stream_retain(&context->streams[0]->public);
 	context->stream_count++;
@@ -1098,22 +1094,23 @@ enum dc_status dce110_validate_guaranteed(
 
 static struct pipe_ctx *dce110_acquire_underlay(
 		struct validate_context *context,
+		const struct resource_pool *pool,
 		struct core_stream *stream)
 {
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx = &context->res_ctx;
-	unsigned int underlay_idx = res_ctx->pool->underlay_pipe_index;
+	unsigned int underlay_idx = pool->underlay_pipe_index;
 	struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];
 
 	if (res_ctx->pipe_ctx[underlay_idx].stream)
 		return NULL;
 
-	pipe_ctx->tg = res_ctx->pool->timing_generators[underlay_idx];
-	pipe_ctx->mi = res_ctx->pool->mis[underlay_idx];
+	pipe_ctx->tg = pool->timing_generators[underlay_idx];
+	pipe_ctx->mi = pool->mis[underlay_idx];
 	/*pipe_ctx->ipp = res_ctx->pool->ipps[underlay_idx];*/
-	pipe_ctx->xfm = res_ctx->pool->transforms[underlay_idx];
-	pipe_ctx->opp = res_ctx->pool->opps[underlay_idx];
-	pipe_ctx->dis_clk = res_ctx->pool->display_clock;
+	pipe_ctx->xfm = pool->transforms[underlay_idx];
+	pipe_ctx->opp = pool->opps[underlay_idx];
+	pipe_ctx->dis_clk = pool->display_clock;
 	pipe_ctx->pipe_idx = underlay_idx;
 
 	pipe_ctx->stream = stream;
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index 4bf75af..4de51a8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -749,22 +749,24 @@ static void destruct(struct dce110_resource_pool *pool)
 	}
 }
 
-static struct clock_source *find_matching_pll(struct resource_context *res_ctx,
+static struct clock_source *find_matching_pll(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		const struct core_stream *const stream)
 {
 	switch (stream->sink->link->link_enc->transmitter) {
 	case TRANSMITTER_UNIPHY_A:
-		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL0];
+		return pool->clock_sources[DCE112_CLK_SRC_PLL0];
 	case TRANSMITTER_UNIPHY_B:
-		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL1];
+		return pool->clock_sources[DCE112_CLK_SRC_PLL1];
 	case TRANSMITTER_UNIPHY_C:
-		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL2];
+		return pool->clock_sources[DCE112_CLK_SRC_PLL2];
 	case TRANSMITTER_UNIPHY_D:
-		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL3];
+		return pool->clock_sources[DCE112_CLK_SRC_PLL3];
 	case TRANSMITTER_UNIPHY_E:
-		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL4];
+		return pool->clock_sources[DCE112_CLK_SRC_PLL4];
 	case TRANSMITTER_UNIPHY_F:
-		return res_ctx->pool->clock_sources[DCE112_CLK_SRC_PLL5];
+		return pool->clock_sources[DCE112_CLK_SRC_PLL5];
 	default:
 		return NULL;
 	};
@@ -842,7 +844,7 @@ bool dce112_validate_bandwidth(
 			&dc->bw_dceip,
 			&dc->bw_vbios,
 			context->res_ctx.pipe_ctx,
-			context->res_ctx.pool->pipe_count,
+			dc->res_pool->pipe_count,
 			&context->bw_results))
 		result = true;
 	context->dispclk_khz = context->bw_results.dispclk_khz;
@@ -928,17 +930,18 @@ enum dc_status resource_map_phy_clock_resources(
 			if (dc_is_dp_signal(pipe_ctx->stream->signal)
 				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
 				pipe_ctx->clock_source =
-					context->res_ctx.pool->dp_clock_source;
+						dc->res_pool->dp_clock_source;
 			else
-				pipe_ctx->clock_source =
-					find_matching_pll(&context->res_ctx,
-							  stream);
+				pipe_ctx->clock_source = find_matching_pll(
+					&context->res_ctx, dc->res_pool,
+					stream);
 
 			if (pipe_ctx->clock_source == NULL)
 				return DC_NO_CLOCK_SOURCE_RESOURCE;
 
 			resource_reference_clock_source(
 				&context->res_ctx,
+				dc->res_pool,
 				pipe_ctx->clock_source);
 
 			/* only one cs per stream regardless of mpo */
@@ -983,8 +986,6 @@ enum dc_status dce112_validate_with_context(
 	if (!dce112_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	for (i = 0; i < set_count; i++) {
 		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
 		dc_stream_retain(&context->streams[i]->public);
@@ -996,8 +997,8 @@ enum dc_status dce112_validate_with_context(
 	if (result == DC_OK)
 		result = resource_map_phy_clock_resources(dc, context);
 
-	if (!resource_validate_attach_surfaces(
-			set, set_count, dc->current_context, context)) {
+	if (!resource_validate_attach_surfaces(set, set_count,
+			dc->current_context, context, dc->res_pool)) {
 		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
@@ -1022,8 +1023,6 @@ enum dc_status dce112_validate_guaranteed(
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
 	dc_stream_retain(&context->streams[0]->public);
 	context->stream_count++;
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index d490929..0aa128e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -821,8 +821,6 @@ enum dc_status dce80_validate_with_context(
 	if (!dce80_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	for (i = 0; i < set_count; i++) {
 		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
 		dc_stream_retain(&context->streams[i]->public);
@@ -834,8 +832,8 @@ enum dc_status dce80_validate_with_context(
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
-	if (!resource_validate_attach_surfaces(
-			set, set_count, dc->current_context, context)) {
+	if (!resource_validate_attach_surfaces(set, set_count,
+			dc->current_context, context, dc->res_pool)) {
 		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
@@ -859,8 +857,6 @@ enum dc_status dce80_validate_guaranteed(
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
 	dc_stream_retain(&context->streams[0]->public);
 	context->stream_count++;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 2b43e18..f3fe850 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -212,6 +212,7 @@ struct resource_funcs {
 
 	struct pipe_ctx *(*acquire_idle_pipe_for_layer)(
 			struct validate_context *context,
+			const struct resource_pool *pool,
 			struct core_stream *stream);
 
 	void (*build_bit_depth_reduction_params)(
@@ -293,7 +294,6 @@ struct pipe_ctx {
 };
 
 struct resource_context {
-	const struct resource_pool *pool;
 	struct pipe_ctx pipe_ctx[MAX_PIPES];
 	bool is_stream_enc_acquired[MAX_PIPES * 2];
 	bool is_audio_acquired[MAX_PIPES];
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index b1987ca..89d34be 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -92,10 +92,12 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx);
 
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct clock_source **clock_source);
 
 void resource_reference_clock_source(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct clock_source *clock_source);
 
 bool resource_are_streams_timing_synchronizable(
@@ -107,7 +109,8 @@ struct clock_source *resource_find_used_clk_src_for_sharing(
 		struct pipe_ctx *pipe_ctx);
 
 struct clock_source *dc_resource_find_first_free_pll(
-		struct resource_context *res_ctx);
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool);
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
@@ -117,9 +120,12 @@ bool resource_attach_surfaces_to_context(
 		const struct dc_surface *const *surfaces,
 		int surface_count,
 		const struct dc_stream *dc_stream,
-		struct validate_context *context);
+		struct validate_context *context,
+		const struct resource_pool *pool);
 
-struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx);
+struct pipe_ctx *find_idle_secondary_pipe(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool);
 
 bool resource_is_stream_unchanged(
 	const struct validate_context *old_context, const struct core_stream *stream);
@@ -131,7 +137,8 @@ bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
 		int set_count,
 		const struct validate_context *old_context,
-		struct validate_context *context);
+		struct validate_context *context,
+		const struct resource_pool *pool);
 
 void validate_guaranteed_copy_streams(
 		struct validate_context *context,
-- 
2.7.4

