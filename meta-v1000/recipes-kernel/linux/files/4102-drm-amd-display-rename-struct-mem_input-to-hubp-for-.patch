From 2da4d154c9f86ad0f40a038c8db78246a6633cd1 Mon Sep 17 00:00:00 2001
From: Yue Hin Lau <Yuehin.Lau@amd.com>
Date: Mon, 2 Oct 2017 14:39:42 -0400
Subject: [PATCH 4102/5855] drm/amd/display: rename struct mem_input to hubp
 for dcn

Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
Signed-off-by: Pavan Kumar Ramayanam <pavan.ramayanam@amd.com>
---
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |   1 +
 drivers/gpu/drm/amd/display/dc/core/dc.c           |   1 +
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  |   3 +-
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |  22 +--
 drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c |   3 -
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    |  19 +--
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  |  88 ++++++------
 .../gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c | 158 ++++++++++-----------
 .../gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h |  49 +++----
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |  26 ++--
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |   4 +-
 drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h       | 105 ++++++++++++++
 drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h  |   3 -
 13 files changed, 286 insertions(+), 196 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h

diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index fd1db8d..c37f130 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -485,6 +485,7 @@ static void split_stream_across_pipes(
 
 	secondary_pipe->pipe_idx = pipe_idx;
 	secondary_pipe->plane_res.mi = pool->mis[secondary_pipe->pipe_idx];
+	secondary_pipe->plane_res.hubp = pool->hubps[secondary_pipe->pipe_idx];
 	secondary_pipe->plane_res.ipp = pool->ipps[secondary_pipe->pipe_idx];
 	secondary_pipe->plane_res.xfm = pool->transforms[secondary_pipe->pipe_idx];
 	if (primary_pipe->bottom_pipe) {
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2e1245c..d55914c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -47,6 +47,7 @@
 #include "dc_link_ddc.h"
 #include "dm_helpers.h"
 #include "mem_input.h"
+#include "hubp.h"
 
 
 /*******************************************************************************
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7d75036..4fb4f00 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1024,7 +1024,7 @@ static int acquire_first_split_pipe(
 
 			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
 			pipe_ctx->stream_res.tg = pool->timing_generators[i];
-			pipe_ctx->plane_res.mi = pool->mis[i];
+			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
@@ -1359,6 +1359,7 @@ static int acquire_first_free_pipe(
 
 			pipe_ctx->stream_res.tg = pool->timing_generators[i];
 			pipe_ctx->plane_res.mi = pool->mis[i];
+			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3dd44be..4116787 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -200,7 +200,7 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.mi || !pipe_ctx->plane_res.xfm)
+		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.xfm)
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
@@ -210,10 +210,15 @@ bool dc_stream_set_cursor_attributes(
 			pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
 						pipe_ctx->plane_res.ipp, attributes);
 
-		if (pipe_ctx->plane_res.mi->funcs->set_cursor_attributes != NULL)
+		if (pipe_ctx->plane_res.hubp != NULL)
+			pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(
+					pipe_ctx->plane_res.hubp, attributes);
+
+		if (pipe_ctx->plane_res.mi != NULL)
 			pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
 					pipe_ctx->plane_res.mi, attributes);
 
+
 		if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
 				pipe_ctx->plane_res.xfm, attributes);
@@ -248,7 +253,7 @@ bool dc_stream_set_cursor_position(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
-		struct mem_input *mi = pipe_ctx->plane_res.mi;
+		struct hubp *hubp = pipe_ctx->plane_res.hubp;
 		struct transform *xfm = pipe_ctx->plane_res.xfm;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
@@ -260,7 +265,7 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->plane_res.mi ||
+				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
 				!pipe_ctx->plane_state ||
 				!pipe_ctx->plane_res.xfm)
 			continue;
@@ -276,11 +281,12 @@ bool dc_stream_set_cursor_position(
 		if (ipp->funcs->ipp_cursor_set_position != NULL)
 			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
 
-		if (mi->funcs->set_cursor_attributes != NULL)
-			mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
+		if (hubp != NULL)
+			hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
+
+		if (xfm != NULL)
+			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, hubp->curs_attr.width);
 
-		if (xfm->funcs->set_cursor_attributes != NULL)
-			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, mi->curs_attr.width);
 	}
 
 	return true;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 83d9caa..ed301c3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -685,9 +685,6 @@ void dce_mem_input_construct(
 	dce_mi->regs = regs;
 	dce_mi->shifts = mi_shift;
 	dce_mi->masks = mi_mask;
-
-	dce_mi->base.mpcc_id = 0xf;
-	dce_mi->base.opp_id = 0xf;
 }
 
 void dce112_mem_input_construct(
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index edf0219..5b47daf 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1373,15 +1373,14 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	}
 
 	/* mst support - use total stream count */
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (pipe_ctx->plane_res.mi->funcs->allocate_mem_input != NULL)
-#endif
+	if (pipe_ctx->plane_res.mi != NULL) {
 		pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
-					pipe_ctx->plane_res.mi,
-					stream->timing.h_total,
-					stream->timing.v_total,
-					stream->timing.pix_clk_khz,
-					context->stream_count);
+				pipe_ctx->plane_res.mi,
+				stream->timing.h_total,
+				stream->timing.v_total,
+				stream->timing.pix_clk_khz,
+				context->stream_count);
+	}
 
 	pipe_ctx->stream->sink->link->psr_enabled = false;
 
@@ -1551,7 +1550,7 @@ static void set_safe_displaymarks(
 		SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK };
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (res_ctx->pipe_ctx[i].stream == NULL)
+		if (res_ctx->pipe_ctx[i].stream == NULL || res_ctx->pipe_ctx[i].plane_res.mi == NULL)
 			continue;
 
 		res_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_display_marks(
@@ -1560,6 +1559,7 @@ static void set_safe_displaymarks(
 				max_marks,
 				max_marks,
 				MAX_WATERMARK);
+
 		if (i == underlay_idx)
 			res_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_chroma_display_marks(
 				res_ctx->pipe_ctx[i].plane_res.mi,
@@ -1567,6 +1567,7 @@ static void set_safe_displaymarks(
 				max_marks,
 				max_marks,
 				MAX_WATERMARK);
+
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 479dc16..df22329 100755
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -175,10 +175,10 @@ static void dcn10_log_hw_state(struct dc *dc)
 			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
 
 	for (i = 0; i < pool->pipe_count; i++) {
-		struct mem_input *mi = pool->mis[i];
+		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state s;
 
-		dcn10_mem_input_read_state(TO_DCN10_MEM_INPUT(mi), &s);
+		hubp1_read_state(TO_DCN10_HUBP(hubp), &s);
 
 		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t "
 				"%xh \t %xh \t %xh \t "
@@ -806,7 +806,7 @@ static void power_on_plane(
 static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[0];
+	struct hubp *hubp = dc->res_pool->hubps[0];
 	int pwr_status = 0;
 
 	REG_GET(DOMAIN0_PG_STATUS, DOMAIN0_PGFSM_PWR_STATUS, &pwr_status);
@@ -814,7 +814,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 	if (pwr_status == 2)
 		return;
 
-	mi->funcs->set_blank(mi, true);
+	hubp->funcs->set_blank(hubp, true);
 
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
@@ -827,7 +827,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[0];
+	struct hubp *hubp = dc->res_pool->hubps[0];
 
 	if (dc->debug.disable_stutter)
 		return;
@@ -889,7 +889,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 
-	mi->funcs->set_hubp_blank_en(mi, false);
+	hubp->funcs->set_hubp_blank_en(hubp, false);
 }
 
 static void bios_golden_init(struct dc *dc)
@@ -1123,7 +1123,7 @@ static void reset_back_end_for_pipe(
 static void plane_atomic_disconnect(struct dc *dc,
 		int fe_idx)
 {
-	struct mem_input *mi = dc->res_pool->mis[fe_idx];
+	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id, z_idx;
 	int mpcc_id = -1;
@@ -1147,7 +1147,7 @@ static void plane_atomic_disconnect(struct dc *dc,
 
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
-	mi->funcs->dcc_control(mi, false, false);
+	hubp->funcs->dcc_control(hubp, false, false);
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
@@ -1161,20 +1161,20 @@ static void plane_atomic_disable(struct dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[fe_idx];
+	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
-	int opp_id = mi->opp_id;
+	int opp_id = hubp->opp_id;
 
 	if (opp_id == 0xf)
 		return;
 
-	mpc->funcs->wait_for_idle(mpc, mi->mpcc_id);
-	dc->res_pool->opps[mi->opp_id]->mpcc_disconnect_pending[mi->mpcc_id] = false;
+	mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
+	dc->res_pool->opps[hubp->opp_id]->mpcc_disconnect_pending[hubp->mpcc_id] = false;
 	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 			"[debug_mpo: atomic disable finished on mpcc %d]\n",
 			fe_idx);*/
 
-	mi->funcs->set_blank(mi, true);
+	hubp->funcs->set_blank(hubp, true);
 
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
@@ -1224,7 +1224,7 @@ static void reset_front_end(
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct timing_generator *tg;
-	int opp_id = dc->res_pool->mis[fe_idx]->opp_id;
+	int opp_id = dc->res_pool->hubps[fe_idx]->opp_id;
 
 	/*Already reset*/
 	if (opp_id == 0xf)
@@ -1408,8 +1408,8 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 	if (plane_state == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
-	pipe_ctx->plane_res.mi->funcs->mem_input_program_surface_flip_and_addr(
-			pipe_ctx->plane_res.mi,
+	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
+			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
 			plane_state->flip_immediate);
 	plane_state->status.requested_address = plane_state->address;
@@ -1814,8 +1814,8 @@ static void dcn10_pipe_control_lock(
 	struct pipe_ctx *pipe,
 	bool lock)
 {
-	struct mem_input *mi = NULL;
-	mi = dc->res_pool->mis[pipe->pipe_idx];
+	struct hubp *hubp = NULL;
+	hubp = dc->res_pool->hubps[pipe->pipe_idx];
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */
@@ -2236,7 +2236,7 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
-static void mmhub_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
+static void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,
 		struct vm_system_aperture_param *apt,
 		struct dce_hwseq *hws)
 {
@@ -2261,7 +2261,7 @@ static void mmhub_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
 }
 
 /* Temporary read settings, future will get values from kmd directly */
-static void mmhub_read_vm_context0_settings(struct dcn10_mem_input *mi,
+static void mmhub_read_vm_context0_settings(struct dcn10_hubp *hubp1,
 		struct vm_context0_param *vm0,
 		struct dce_hwseq *hws)
 {
@@ -2305,22 +2305,22 @@ static void mmhub_read_vm_context0_settings(struct dcn10_mem_input *mi,
 	vm0->pte_base.quad_part -= fb_offset.quad_part;
 }
 
-static void dcn10_program_pte_vm(struct mem_input *mem_input,
+static void dcn10_program_pte_vm(struct hubp *hubp,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation,
 		struct dce_hwseq *hws)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	struct vm_system_aperture_param apt = { {{ 0 } } };
 	struct vm_context0_param vm0 = { { { 0 } } };
 
 
-	mmhub_read_vm_system_aperture_settings(mi, &apt, hws);
-	mmhub_read_vm_context0_settings(mi, &vm0, hws);
+	mmhub_read_vm_system_aperture_settings(hubp1, &apt, hws);
+	mmhub_read_vm_context0_settings(hubp1, &vm0, hws);
 
-	mem_input->funcs->mem_input_set_vm_system_aperture_settings(mem_input, &apt);
-	mem_input->funcs->mem_input_set_vm_context0_settings(mem_input, &vm0);
+	hubp->funcs->hubp_set_vm_system_aperture_settings(hubp, &apt);
+	hubp->funcs->hubp_set_vm_context0_settings(hubp, &vm0);
 }
 
 static void update_dchubp_dpp(
@@ -2329,7 +2329,7 @@ static void update_dchubp_dpp(
 	struct dc_state *context)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = pipe_ctx->plane_res.mi;
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct transform *xfm = pipe_ctx->plane_res.xfm;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
@@ -2354,8 +2354,8 @@ static void update_dchubp_dpp(
 	 */
 	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
 
-	mi->funcs->mem_input_setup(
-		mi,
+	hubp->funcs->hubp_setup(
+		hubp,
 		&pipe_ctx->dlg_regs,
 		&pipe_ctx->ttu_regs,
 		&pipe_ctx->rq_regs,
@@ -2365,7 +2365,7 @@ static void update_dchubp_dpp(
 
 	if (dc->config.gpu_vm_support)
 		dcn10_program_pte_vm(
-				pipe_ctx->plane_res.mi,
+				pipe_ctx->plane_res.hubp,
 				plane_state->format,
 				&plane_state->tiling_info,
 				plane_state->rotation,
@@ -2376,7 +2376,7 @@ static void update_dchubp_dpp(
 			plane_state->format,
 			EXPANSION_MODE_ZERO);
 
-	mpcc_cfg.dpp_id = mi->inst;
+	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
 	mpcc_cfg.tree_cfg = &(pipe_ctx->stream_res.opp->mpc_tree);
 	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
@@ -2395,15 +2395,15 @@ static void update_dchubp_dpp(
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
 			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
-	mi->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
-	mi->opp_id = mpcc_cfg.opp_id;
+	hubp->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
+	hubp->opp_id = mpcc_cfg.opp_id;
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
 	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(
 			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data);
-	mi->funcs->mem_program_viewport(mi,
+	hubp->funcs->mem_program_viewport(hubp,
 			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
 
 	/*gamut remap*/
@@ -2413,8 +2413,8 @@ static void update_dchubp_dpp(
 			pipe_ctx->stream->output_color_space,
 			pipe_ctx->stream->csc_color_matrix.matrix);
 
-	mi->funcs->mem_input_program_surface_config(
-		mi,
+	hubp->funcs->hubp_program_surface_config(
+		hubp,
 		plane_state->format,
 		&plane_state->tiling_info,
 		&size,
@@ -2425,7 +2425,7 @@ static void update_dchubp_dpp(
 	dc->hwss.update_plane_addr(dc, pipe_ctx);
 
 	if (is_pipe_tree_visible(pipe_ctx))
-		mi->funcs->set_blank(mi, false);
+		hubp->funcs->set_blank(hubp, false);
 }
 
 
@@ -2605,7 +2605,7 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
-			if (pipe_ctx->plane_res.mi->opp_id != 0xf && pipe_ctx->stream_res.tg->inst == be_idx) {
+			if (pipe_ctx->plane_res.hubp->opp_id != 0xf && pipe_ctx->stream_res.tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
 				 * power down fe will unlock when calling reset, need
@@ -2632,7 +2632,7 @@ static void dcn10_apply_ctx_for_surface(
 					&(old_pipe_ctx->stream_res.opp->mpc_tree),
 					old_pipe_ctx->stream_res.opp->inst,
 					old_pipe_ctx->pipe_idx);
-			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.mi->mpcc_id] = true;
+			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.hubp->mpcc_id] = true;
 
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
@@ -2916,7 +2916,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 		if (pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i]) {
 			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, i);
 			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i] = false;
-			res_pool->mis[i]->funcs->set_blank(res_pool->mis[i], true);
+			res_pool->hubps[i]->funcs->set_blank(res_pool->hubps[i], true);
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",
 					i);*/
@@ -2947,11 +2947,11 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 		return;
 
 	plane_state->status.is_flip_pending =
-			pipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(
-					pipe_ctx->plane_res.mi);
+			pipe_ctx->plane_res.hubp->funcs->hubp_is_flip_pending(
+					pipe_ctx->plane_res.hubp);
 
-	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
-	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	plane_state->status.current_address = pipe_ctx->plane_res.hubp->current_address;
+	if (pipe_ctx->plane_res.hubp->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
index 2336da5..d942586 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
@@ -29,18 +29,18 @@
 #include "basics/conversion.h"
 
 #define REG(reg)\
-	mi->mi_regs->reg
+	hubp1->mi_regs->reg
 
 #define CTX \
-	mi->base.ctx
+	hubp1->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	mi->mi_shift->field_name, mi->mi_mask->field_name
+	hubp1->mi_shift->field_name, hubp1->mi_mask->field_name
 
-void hubp1_set_blank(struct mem_input *mem_input, bool blank)
+void hubp1_set_blank(struct hubp *hubp, bool blank)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	uint32_t blank_en = blank ? 1 : 0;
 
 	REG_UPDATE_2(DCHUBP_CNTL,
@@ -51,24 +51,24 @@ void hubp1_set_blank(struct mem_input *mem_input, bool blank)
 		REG_WAIT(DCHUBP_CNTL,
 				HUBP_NO_OUTSTANDING_REQ, 1,
 				1, 200);
-		mem_input->mpcc_id = 0xf;
-		mem_input->opp_id = 0xf;
+		hubp->mpcc_id = 0xf;
+		hubp->opp_id = 0xf;
 	}
 }
 
-static void hubp1_set_hubp_blank_en(struct mem_input *mem_input, bool blank)
+static void hubp1_set_hubp_blank_en(struct hubp *hubp, bool blank)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	uint32_t blank_en = blank ? 1 : 0;
 
 	REG_UPDATE(DCHUBP_CNTL, HUBP_BLANK_EN, blank_en);
 }
 
-static void hubp1_vready_workaround(struct mem_input *mem_input,
+static void hubp1_vready_workaround(struct hubp *hubp,
 		struct _vcs_dpi_display_pipe_dest_params_st *pipe_dest)
 {
 	uint32_t value = 0;
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
 	/* set HBUBREQ_DEBUG_DB[12] = 1 */
 	value = REG_READ(HUBPREQ_DEBUG_DB);
@@ -88,7 +88,7 @@ static void hubp1_vready_workaround(struct mem_input *mem_input,
 }
 
 void hubp1_program_tiling(
-	struct dcn10_mem_input *mi,
+	struct dcn10_hubp *hubp1,
 	const union dc_tiling_info *info,
 	const enum surface_pixel_format pixel_format)
 {
@@ -108,7 +108,7 @@ void hubp1_program_tiling(
 }
 
 void hubp1_program_size_and_rotation(
-	struct dcn10_mem_input *mi,
+	struct dcn10_hubp *hubp1,
 	enum dc_rotation_angle rotation,
 	enum surface_pixel_format format,
 	const union plane_size *plane_size,
@@ -170,7 +170,7 @@ void hubp1_program_size_and_rotation(
 }
 
 void hubp1_program_pixel_format(
-	struct dcn10_mem_input *mi,
+	struct dcn10_hubp *hubp1,
 	enum surface_pixel_format format)
 {
 	uint32_t red_bar = 3;
@@ -246,11 +246,11 @@ void hubp1_program_pixel_format(
 }
 
 bool hubp1_program_surface_flip_and_addr(
-	struct mem_input *mem_input,
+	struct hubp *hubp,
 	const struct dc_plane_address *address,
 	bool flip_immediate)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
 	/* program flip type */
 	REG_SET(DCSURF_FLIP_CONTROL, 0,
@@ -387,20 +387,20 @@ bool hubp1_program_surface_flip_and_addr(
 		break;
 	}
 
-	mem_input->request_address = *address;
+	hubp->request_address = *address;
 
 	if (flip_immediate)
-		mem_input->current_address = *address;
+		hubp->current_address = *address;
 
 	return true;
 }
 
-void hubp1_dcc_control(struct mem_input *mem_input, bool enable,
+void hubp1_dcc_control(struct hubp *hubp, bool enable,
 		bool independent_64b_blks)
 {
 	uint32_t dcc_en = enable ? 1 : 0;
 	uint32_t dcc_ind_64b_blk = independent_64b_blks ? 1 : 0;
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
 	REG_UPDATE_2(DCSURF_SURFACE_CONTROL,
 			PRIMARY_SURFACE_DCC_EN, dcc_en,
@@ -408,7 +408,7 @@ void hubp1_dcc_control(struct mem_input *mem_input, bool enable,
 }
 
 void hubp1_program_surface_config(
-	struct mem_input *mem_input,
+	struct hubp *hubp,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
 	union plane_size *plane_size,
@@ -416,20 +416,20 @@ void hubp1_program_surface_config(
 	struct dc_plane_dcc_param *dcc,
 	bool horizontal_mirror)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
-	hubp1_dcc_control(mem_input, dcc->enable, dcc->grph.independent_64b_blks);
-	hubp1_program_tiling(mi, tiling_info, format);
+	hubp1_dcc_control(hubp, dcc->enable, dcc->grph.independent_64b_blks);
+	hubp1_program_tiling(hubp1, tiling_info, format);
 	hubp1_program_size_and_rotation(
-		mi, rotation, format, plane_size, dcc, horizontal_mirror);
-	hubp1_program_pixel_format(mi, format);
+			hubp1, rotation, format, plane_size, dcc, horizontal_mirror);
+	hubp1_program_pixel_format(hubp1, format);
 }
 
 void hubp1_program_requestor(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		struct _vcs_dpi_display_rq_regs_st *rq_regs)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
 	REG_UPDATE(HUBPRET_CONTROL,
 			DET_BUF_PLANE1_BASE_ADDRESS, rq_regs->plane1_base_address);
@@ -460,11 +460,11 @@ void hubp1_program_requestor(
 
 
 void hubp1_program_deadline(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		struct _vcs_dpi_display_dlg_regs_st *dlg_attr,
 		struct _vcs_dpi_display_ttu_regs_st *ttu_attr)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
 	/* DLG - Per hubp */
 	REG_SET_2(BLANK_OFFSET_0, 0,
@@ -581,7 +581,7 @@ void hubp1_program_deadline(
 }
 
 static void hubp1_setup(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		struct _vcs_dpi_display_dlg_regs_st *dlg_attr,
 		struct _vcs_dpi_display_ttu_regs_st *ttu_attr,
 		struct _vcs_dpi_display_rq_regs_st *rq_regs,
@@ -590,27 +590,15 @@ static void hubp1_setup(
 	/* otg is locked when this func is called. Register are double buffered.
 	 * disable the requestors is not needed
 	 */
-	hubp1_program_requestor(mem_input, rq_regs);
-	hubp1_program_deadline(mem_input, dlg_attr, ttu_attr);
-	hubp1_vready_workaround(mem_input, pipe_dest);
+	hubp1_program_requestor(hubp, rq_regs);
+	hubp1_program_deadline(hubp, dlg_attr, ttu_attr);
+	hubp1_vready_workaround(hubp, pipe_dest);
 }
 
-void hubp1_program_display_marks(
-	struct mem_input *mem_input,
-	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
-	struct dce_watermarks urgent,
-	uint32_t total_dest_line_time_ns)
-{
-	/* only for dce
-	 * dcn use only program_watermarks
-	 */
-}
-
-bool hubp1_is_flip_pending(struct mem_input *mem_input)
+bool hubp1_is_flip_pending(struct hubp *hubp)
 {
 	uint32_t flip_pending = 0;
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	struct dc_plane_address earliest_inuse_address;
 
 	REG_GET(DCSURF_FLIP_CONTROL,
@@ -625,20 +613,20 @@ bool hubp1_is_flip_pending(struct mem_input *mem_input)
 	if (flip_pending)
 		return true;
 
-	if (earliest_inuse_address.grph.addr.quad_part != mem_input->request_address.grph.addr.quad_part)
+	if (earliest_inuse_address.grph.addr.quad_part != hubp->request_address.grph.addr.quad_part)
 		return true;
 
-	mem_input->current_address = mem_input->request_address;
+	hubp->current_address = hubp->request_address;
 	return false;
 }
 
 uint32_t aperture_default_system = 1;
 uint32_t context0_default_system; /* = 0;*/
 
-static void hubp1_set_vm_system_aperture_settings(struct mem_input *mem_input,
+static void hubp1_set_vm_system_aperture_settings(struct hubp *hubp,
 		struct vm_system_aperture_param *apt)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	PHYSICAL_ADDRESS_LOC mc_vm_apt_default;
 	PHYSICAL_ADDRESS_LOC mc_vm_apt_low;
 	PHYSICAL_ADDRESS_LOC mc_vm_apt_high;
@@ -664,10 +652,10 @@ static void hubp1_set_vm_system_aperture_settings(struct mem_input *mem_input,
 			MC_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, mc_vm_apt_high.low_part);
 }
 
-static void hubp1_set_vm_context0_settings(struct mem_input *mem_input,
+static void hubp1_set_vm_context0_settings(struct hubp *hubp,
 		const struct vm_context0_param *vm0)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	/* pte base */
 	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, 0,
 			VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, vm0->pte_base.high_part);
@@ -700,11 +688,11 @@ static void hubp1_set_vm_context0_settings(struct mem_input *mem_input,
 }
 
 void min_set_viewport(
-	struct mem_input *mem_input,
+	struct hubp *hubp,
 	const struct rect *viewport,
 	const struct rect *viewport_c)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 
 	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION, 0,
 		  PRI_VIEWPORT_WIDTH, viewport->width,
@@ -733,7 +721,7 @@ void min_set_viewport(
 		  PRI_VIEWPORT_Y_START_C, viewport_c->y);
 }
 
-void dcn10_mem_input_read_state(struct dcn10_mem_input *mi,
+void hubp1_read_state(struct dcn10_hubp *hubp1,
 		struct dcn_hubp_state *s)
 {
 	REG_GET(DCSURF_SURFACE_CONFIG,
@@ -783,7 +771,7 @@ enum cursor_lines_per_chunk {
 };
 
 static bool ippn10_cursor_program_control(
-		struct dcn10_mem_input *mi,
+		struct dcn10_hubp *hubp1,
 		bool pixel_data_invert,
 		enum dc_cursor_color_format color_format)
 {
@@ -849,15 +837,15 @@ static enum cursor_lines_per_chunk ippn10_get_lines_per_chunk(
 }
 
 void hubp1_cursor_set_attributes(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		const struct dc_cursor_attributes *attr)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	enum cursor_pitch hw_pitch = ippn10_get_cursor_pitch(attr->pitch);
 	enum cursor_lines_per_chunk lpc = ippn10_get_lines_per_chunk(
 			attr->width, attr->color_format);
 
-	mem_input->curs_attr = *attr;
+	hubp->curs_attr = *attr;
 
 	REG_UPDATE(CURSOR_SURFACE_ADDRESS_HIGH,
 			CURSOR_SURFACE_ADDRESS_HIGH, attr->address.high_part);
@@ -871,17 +859,17 @@ void hubp1_cursor_set_attributes(
 			CURSOR_MODE, attr->color_format,
 			CURSOR_PITCH, hw_pitch,
 			CURSOR_LINES_PER_CHUNK, lpc);
-	ippn10_cursor_program_control(mi,
+	ippn10_cursor_program_control(hubp1,
 			attr->attribute_flags.bits.INVERT_PIXEL_DATA,
 			attr->color_format);
 }
 
 void hubp1_cursor_set_position(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		const struct dc_cursor_position *pos,
 		const struct dc_cursor_mi_param *param)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	int src_x_offset = pos->x - pos->x_hotspot - param->viewport_x_start;
 	uint32_t cur_en = pos->enable ? 1 : 0;
 	uint32_t dst_x_offset = (src_x_offset >= 0) ? src_x_offset : 0;
@@ -893,7 +881,7 @@ void hubp1_cursor_set_position(
 	 * TODO: Look at combining cursor_set_position() and
 	 * cursor_set_attributes() into cursor_update()
 	 */
-	if (mem_input->curs_attr.address.quad_part == 0)
+	if (hubp->curs_attr.address.quad_part == 0)
 		return;
 
 	dst_x_offset *= param->ref_clk_khz;
@@ -909,11 +897,11 @@ void hubp1_cursor_set_position(
 	if (src_x_offset >= (int)param->viewport_width)
 		cur_en = 0;  /* not visible beyond right edge*/
 
-	if (src_x_offset + (int)mem_input->curs_attr.width < 0)
+	if (src_x_offset + (int)hubp->curs_attr.width < 0)
 		cur_en = 0;  /* not visible beyond left edge*/
 
 	if (cur_en && REG_READ(CURSOR_SURFACE_ADDRESS) == 0)
-		hubp1_cursor_set_attributes(mem_input, &mem_input->curs_attr);
+		hubp1_cursor_set_attributes(hubp, &hubp->curs_attr);
 	REG_UPDATE(CURSOR_CONTROL,
 			CURSOR_ENABLE, cur_en);
 
@@ -930,16 +918,15 @@ void hubp1_cursor_set_position(
 	/* TODO Handle surface pixel formats other than 4:4:4 */
 }
 
-static struct mem_input_funcs dcn10_mem_input_funcs = {
-	.mem_input_program_display_marks = hubp1_program_display_marks,
-	.mem_input_program_surface_flip_and_addr =
+static struct hubp_funcs dcn10_hubp_funcs = {
+	.hubp_program_surface_flip_and_addr =
 			hubp1_program_surface_flip_and_addr,
-	.mem_input_program_surface_config =
+	.hubp_program_surface_config =
 			hubp1_program_surface_config,
-	.mem_input_is_flip_pending = hubp1_is_flip_pending,
-	.mem_input_setup = hubp1_setup,
-	.mem_input_set_vm_system_aperture_settings = hubp1_set_vm_system_aperture_settings,
-	.mem_input_set_vm_context0_settings = hubp1_set_vm_context0_settings,
+	.hubp_is_flip_pending = hubp1_is_flip_pending,
+	.hubp_setup = hubp1_setup,
+	.hubp_set_vm_system_aperture_settings = hubp1_set_vm_system_aperture_settings,
+	.hubp_set_vm_context0_settings = hubp1_set_vm_context0_settings,
 	.set_blank = hubp1_set_blank,
 	.dcc_control = hubp1_dcc_control,
 	.mem_program_viewport = min_set_viewport,
@@ -951,23 +938,22 @@ static struct mem_input_funcs dcn10_mem_input_funcs = {
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
-
-void dcn10_mem_input_construct(
-	struct dcn10_mem_input *mi,
+void dcn10_hubp_construct(
+	struct dcn10_hubp *hubp1,
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dcn_mi_registers *mi_regs,
 	const struct dcn_mi_shift *mi_shift,
 	const struct dcn_mi_mask *mi_mask)
 {
-	mi->base.funcs = &dcn10_mem_input_funcs;
-	mi->base.ctx = ctx;
-	mi->mi_regs = mi_regs;
-	mi->mi_shift = mi_shift;
-	mi->mi_mask = mi_mask;
-	mi->base.inst = inst;
-	mi->base.opp_id = 0xf;
-	mi->base.mpcc_id = 0xf;
+	hubp1->base.funcs = &dcn10_hubp_funcs;
+	hubp1->base.ctx = ctx;
+	hubp1->mi_regs = mi_regs;
+	hubp1->mi_shift = mi_shift;
+	hubp1->mi_mask = mi_mask;
+	hubp1->base.inst = inst;
+	hubp1->base.opp_id = 0xf;
+	hubp1->base.mpcc_id = 0xf;
 }
 
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
index 514c082..3fb632c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
@@ -25,10 +25,10 @@
 #ifndef __DC_MEM_INPUT_DCN10_H__
 #define __DC_MEM_INPUT_DCN10_H__
 
-#include "mem_input.h"
+#include "hubp.h"
 
-#define TO_DCN10_MEM_INPUT(mi)\
-	container_of(mi, struct dcn10_mem_input, base)
+#define TO_DCN10_HUBP(hubp)\
+	container_of(hubp, struct dcn10_hubp, base)
 
 #define MI_REG_LIST_DCN(id)\
 	SRI(DCHUBP_CNTL, HUBP, id),\
@@ -584,15 +584,15 @@ struct dcn_mi_mask {
 	DCN_MI_REG_FIELD_LIST(uint32_t);
 };
 
-struct dcn10_mem_input {
-	struct mem_input base;
+struct dcn10_hubp {
+	struct hubp base;
 	const struct dcn_mi_registers *mi_regs;
 	const struct dcn_mi_shift *mi_shift;
 	const struct dcn_mi_mask *mi_mask;
 };
 
 void hubp1_program_surface_config(
-	struct mem_input *mem_input,
+	struct hubp *hubp,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
 	union plane_size *plane_size,
@@ -601,20 +601,20 @@ void hubp1_program_surface_config(
 	bool horizontal_mirror);
 
 void hubp1_program_deadline(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		struct _vcs_dpi_display_dlg_regs_st *dlg_attr,
 		struct _vcs_dpi_display_ttu_regs_st *ttu_attr);
 
 void hubp1_program_requestor(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		struct _vcs_dpi_display_rq_regs_st *rq_regs);
 
 void hubp1_program_pixel_format(
-		struct dcn10_mem_input *mi,
+		struct dcn10_hubp *hubp,
 		enum surface_pixel_format format);
 
 void hubp1_program_size_and_rotation(
-		struct dcn10_mem_input *mi,
+		struct dcn10_hubp *hubp,
 		enum dc_rotation_angle rotation,
 		enum surface_pixel_format format,
 		const union plane_size *plane_size,
@@ -622,45 +622,38 @@ void hubp1_program_size_and_rotation(
 		bool horizontal_mirror);
 
 void hubp1_program_tiling(
-		struct dcn10_mem_input *mi,
+		struct dcn10_hubp *hubp,
 		const union dc_tiling_info *info,
 		const enum surface_pixel_format pixel_format);
 
-void hubp1_dcc_control(struct mem_input *mem_input,
+void hubp1_dcc_control(struct hubp *hubp,
 		bool enable,
 		bool independent_64b_blks);
 
-void hubp1_program_display_marks(
-		struct mem_input *mem_input,
-		struct dce_watermarks nbp,
-		struct dce_watermarks stutter,
-		struct dce_watermarks urgent,
-		uint32_t total_dest_line_time_ns);
-
 bool hubp1_program_surface_flip_and_addr(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		const struct dc_plane_address *address,
 		bool flip_immediate);
 
-bool hubp1_is_flip_pending(struct mem_input *mem_input);
+bool hubp1_is_flip_pending(struct hubp *hubp);
 
 void hubp1_cursor_set_attributes(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		const struct dc_cursor_attributes *attr);
 
 void hubp1_cursor_set_position(
-		struct mem_input *mem_input,
+		struct hubp *hubp,
 		const struct dc_cursor_position *pos,
 		const struct dc_cursor_mi_param *param);
 
-void hubp1_set_blank(struct mem_input *mem_input, bool blank);
+void hubp1_set_blank(struct hubp *hubp, bool blank);
 
-void min_set_viewport(struct mem_input *mem_input,
+void min_set_viewport(struct hubp *hubp,
 		const struct rect *viewport,
 		const struct rect *viewport_c);
 
-void dcn10_mem_input_construct(
-	struct dcn10_mem_input *mi,
+void dcn10_hubp_construct(
+	struct dcn10_hubp *hubp1,
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dcn_mi_registers *mi_regs,
@@ -684,7 +677,7 @@ struct dcn_hubp_state {
 	uint32_t qos_level_low_wm;
 	uint32_t qos_level_high_wm;
 };
-void dcn10_mem_input_read_state(struct dcn10_mem_input *mi,
+void hubp1_read_state(struct dcn10_hubp *hubp1,
 		struct dcn_hubp_state *s);
 
 #endif
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index 315d250..64ef3b9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -704,9 +704,9 @@ static void destruct(struct dcn10_resource_pool *pool)
 		if (pool->base.ipps[i] != NULL)
 			pool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->base.mis[i] != NULL) {
-			kfree(TO_DCN10_MEM_INPUT(pool->base.mis[i]));
-			pool->base.mis[i] = NULL;
+		if (pool->base.hubps[i] != NULL) {
+			dm_free(TO_DCN10_MEM_INPUT(pool->base.hubps[i]));
+			pool->base.hubps[i] = NULL;
 		}
 
 		if (pool->base.irqs != NULL) {
@@ -753,19 +753,19 @@ static void destruct(struct dcn10_resource_pool *pool)
 	kfree(pool->base.pp_smu);
 }
 
-static struct mem_input *dcn10_mem_input_create(
+static struct hubp *dcn10_hubp_create(
 	struct dc_context *ctx,
 	uint32_t inst)
 {
-	struct dcn10_mem_input *mem_inputn10 =
-		kzalloc(sizeof(struct dcn10_mem_input), GFP_KERNEL);
+	struct dcn10_hubp *hubp1 =
+               dm_alloc(sizeof(struct dcn10_hubp));
 
-	if (!mem_inputn10)
+	if (!hubp1)
 		return NULL;
 
-	dcn10_mem_input_construct(mem_inputn10, ctx, inst,
-				  &mi_regs[inst], &mi_shift, &mi_mask);
-	return &mem_inputn10->base;
+	if(dcn10_hubp_construct(hubp1, ctx, inst,
+				&mi_regs[inst], &mi_shift, &mi_mask))
+		return &hubp1->base;
 }
 
 static void get_pixel_clock_parameters(
@@ -918,7 +918,7 @@ static struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(
 	idle_pipe->stream_res.tg = head_pipe->stream_res.tg;
 	idle_pipe->stream_res.opp = head_pipe->stream_res.opp;
 
-	idle_pipe->plane_res.mi = pool->mis[idle_pipe->pipe_idx];
+	idle_pipe->plane_res.hubp = pool->hubps[idle_pipe->pipe_idx];
 	idle_pipe->plane_res.ipp = pool->ipps[idle_pipe->pipe_idx];
 	idle_pipe->plane_res.xfm = pool->transforms[idle_pipe->pipe_idx];
 
@@ -1357,8 +1357,8 @@ static bool construct(
 		if ((pipe_fuses & (1 << i)) != 0)
 			continue;
 
-		pool->base.mis[j] = dcn10_mem_input_create(ctx, i);
-		if (pool->base.mis[j] == NULL) {
+		pool->base.hubps[j] = dcn10_hubp_create(ctx, i);
+		if (pool->base.hubps[j] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error(
 				"DC: failed to create memory input!\n");
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 9bb2d06..a20114c 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -32,6 +32,7 @@
 #include "ddc_service_types.h"
 #include "dc_bios_types.h"
 #include "mem_input.h"
+#include "hubp.h"
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "mpc.h"
 #endif
@@ -129,6 +130,7 @@ struct audio_support{
 
 struct resource_pool {
 	struct mem_input *mis[MAX_PIPES];
+	struct hubp *hubps[MAX_PIPES];
 	struct input_pixel_processor *ipps[MAX_PIPES];
 	struct transform *transforms[MAX_PIPES];
 	struct output_pixel_processor *opps[MAX_PIPES];
@@ -178,7 +180,7 @@ struct stream_resource {
 
 struct plane_resource {
 	struct scaler_data scl_data;
-
+	struct hubp *hubp;
 	struct mem_input *mi;
 	struct input_pixel_processor *ipp;
 	struct transform *xfm;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
new file mode 100644
index 0000000..0d186be
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/hubp.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DAL_HUBP_H__
+#define __DAL_HUBP_H__
+
+#include "mem_input.h"
+
+struct hubp {
+	struct hubp_funcs *funcs;
+	struct dc_context *ctx;
+	struct dc_plane_address request_address;
+	struct dc_plane_address current_address;
+	int inst;
+	int opp_id;
+	int mpcc_id;
+	struct dc_cursor_attributes curs_attr;
+};
+
+
+struct hubp_funcs {
+	void (*hubp_setup)(
+			struct hubp *hubp,
+			struct _vcs_dpi_display_dlg_regs_st *dlg_regs,
+			struct _vcs_dpi_display_ttu_regs_st *ttu_regs,
+			struct _vcs_dpi_display_rq_regs_st *rq_regs,
+			struct _vcs_dpi_display_pipe_dest_params_st *pipe_dest);
+
+	void (*dcc_control)(struct hubp *hubp, bool enable,
+			bool independent_64b_blks);
+	void (*mem_program_viewport)(
+			struct hubp *hubp,
+			const struct rect *viewport,
+			const struct rect *viewport_c);
+
+	bool (*hubp_program_surface_flip_and_addr)(
+		struct hubp *hubp,
+		const struct dc_plane_address *address,
+		bool flip_immediate);
+
+	void (*hubp_program_pte_vm)(
+		struct hubp *hubp,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation);
+
+	void (*hubp_set_vm_system_aperture_settings)(
+			struct hubp *hubp,
+			struct vm_system_aperture_param *apt);
+
+	void (*hubp_set_vm_context0_settings)(
+			struct hubp *hubp,
+			const struct vm_context0_param *vm0);
+
+	void (*hubp_program_surface_config)(
+		struct hubp *hubp,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		union plane_size *plane_size,
+		enum dc_rotation_angle rotation,
+		struct dc_plane_dcc_param *dcc,
+		bool horizontal_mirror);
+
+	bool (*hubp_is_flip_pending)(struct hubp *hubp);
+
+	void (*hubp_update_dchub)(struct hubp *hubp,
+				struct dchub_init_data *dh_data);
+
+	void (*set_blank)(struct hubp *hubp, bool blank);
+	void (*set_hubp_blank_en)(struct hubp *hubp, bool blank);
+
+	void (*set_cursor_attributes)(
+			struct hubp *hubp,
+			const struct dc_cursor_attributes *attr);
+
+	void (*set_cursor_position)(
+			struct hubp *hubp,
+			const struct dc_cursor_position *pos,
+			const struct dc_cursor_mi_param *param);
+
+};
+
+#endif
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h b/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
index 5c8e45b..3e1e7e6 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
@@ -69,10 +69,7 @@ struct mem_input {
 	struct dc_plane_address request_address;
 	struct dc_plane_address current_address;
 	int inst;
-	int opp_id;
-	int mpcc_id;
 	struct stutter_modes stutter_mode;
-	struct dc_cursor_attributes curs_attr;
 };
 
 struct vm_system_aperture_param {
-- 
2.7.4

