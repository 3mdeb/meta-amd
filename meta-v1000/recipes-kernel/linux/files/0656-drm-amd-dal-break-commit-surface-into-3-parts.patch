From 6e87eb8294419885759c303c5d12d5bc7912c8d2 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Mon, 18 Jul 2016 14:01:01 -0400
Subject: [PATCH 0656/1722] drm/amd/dal: break commit surface into 3 parts

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  79 +++++++++++----
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 106 +++++++++++++++++++--
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |   5 +-
 3 files changed, 161 insertions(+), 29 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index ef41878..d98844c 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -899,17 +899,15 @@ context_alloc_fail:
 	return (result == DC_OK);
 }
 
-bool dc_commit_surfaces_to_target(
+struct validate_context *dc_pre_commit_surfaces_to_target(
 		struct dc *dc,
 		struct dc_surface *new_surfaces[],
 		uint8_t new_surface_count,
 		struct dc_target *dc_target)
-
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 
 	int i, j;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
 	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 	struct dc_target_status *target_status = NULL;
@@ -920,7 +918,7 @@ bool dc_commit_surfaces_to_target(
 	int new_enabled_surface_count = 0;
 
 	if (core_dc->current_context->target_count == 0)
-		return false;
+		return NULL;
 
 
 	context = dm_alloc(sizeof(struct validate_context));
@@ -939,12 +937,6 @@ bool dc_commit_surfaces_to_target(
 
 	target_status = &context->target_status[i];
 
-	if (!dc_bios_is_accelerated_mode(dcb)
-			|| i == context->target_count) {
-		BREAK_TO_DEBUGGER();
-		goto unexpected_fail;
-	}
-
 	for (i = 0; i < target_status->surface_count; i++)
 		if (target_status->surfaces[i]->visible)
 			current_enabled_surface_count++;
@@ -1016,22 +1008,69 @@ bool dc_commit_surfaces_to_target(
 		target_disable_memory_requests(dc_target,
 				&core_dc->current_context->res_ctx);
 
-        core_dc->hwss.apply_ctx_to_surface(core_dc, context);
+        core_dc->hwss.apply_ctx_to_surface_locked(core_dc, context);
+
+        return context;
  
-        /* TODO: Implement lowering display clock */
+unexpected_fail:
+        resource_validate_ctx_destruct(context);
+        dm_free(context);
+val_ctx_fail:
+        return NULL;
+}
+
+bool dc_isr_commit_surfaces_to_target(
+                struct dc *dc,
+                struct validate_context *context)
+{
+        struct core_dc *core_dc = DC_TO_CORE(dc);
+        enum dc_status status;
+ 
+        /*
+         * Currently refactor is not complete, in some environment this is
+         * not implemented so we need to check the pointer.
+         * TODO: remove the check when implementation is done
+         */
+        if (!core_dc->hwss.apply_ctx_to_surface_unlock)
+                return true;
+        status = core_dc->hwss.apply_ctx_to_surface_unlock(core_dc, context);
+        return status == DC_OK;
+}
+
+bool dc_post_commit_surfaces_to_target(
+                struct dc *dc,
+                struct validate_context *context)
+{
+        struct core_dc *core_dc = DC_TO_CORE(dc);
+        /* TODO: lower display clock if needed*/
 
 	resource_validate_ctx_destruct(core_dc->current_context);
 	dm_free(core_dc->current_context);
 	core_dc->current_context = context;
-
 	return true;
+}
 
-unexpected_fail:
-	resource_validate_ctx_destruct(context);
-	dm_free(context);
-val_ctx_fail:
-
-	return false;
+bool dc_commit_surfaces_to_target(
+               struct dc *dc,
+                struct dc_surface *new_surfaces[],
+                uint8_t new_surface_count,
+                struct dc_target *dc_target)
+{
+        struct validate_context *context = dc_pre_commit_surfaces_to_target(
+                        dc,
+                        new_surfaces,
+                        new_surface_count,
+                        dc_target);
+        if (!context)
+                return false;
+ 
+        if (!dc_isr_commit_surfaces_to_target(dc, context))
+                return false;
+ 
+        if (!dc_post_commit_surfaces_to_target(dc, context))
+                return false;
+ 
+        return true;
 }
 
 bool dc_update_surfaces_for_target(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index a10c050..85fda4e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1873,11 +1873,24 @@ static void set_display_mark_for_pipe_if_needed(struct core_dc *dc,
 		program_wm_for_pipe(dc, pipe_ctx, context);
 }
 
+static void dce110_program_blending(struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	program_blender_if_needed(dc, pipe_ctx);
+}
+
 static void dce110_program_front_end_for_pipe(struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context)
 {
 	struct core_gamma *gamma = NULL;
+	struct mem_input *mi = pipe_ctx->mi;
+	struct pipe_ctx *old_pipe = NULL;
+	struct dc_context *ctx = pipe_ctx->stream->ctx;
+	struct core_surface *surface = pipe_ctx->surface;
+	struct xfm_grph_csc_adjustment adjust;
+
 	int lock_mask =
 		PIPE_LOCK_CONTROL_GRAPHICS |
 		PIPE_LOCK_CONTROL_SCL |
@@ -1898,9 +1911,70 @@ static void dce110_program_front_end_for_pipe(struct core_dc *dc,
 			lock_mask,
 			true);
 
+	if (dc->current_context)
+		old_pipe = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+
+	memset(&adjust, 0, sizeof(adjust));
+	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
+
+	dc->hwss.enable_fe_clock(ctx, pipe_ctx->pipe_idx, true);
 
-	dc->hwss.set_plane_config(
-			dc, pipe_ctx, &context->res_ctx);
+	set_default_colors(pipe_ctx);
+
+	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		adjust.temperature_matrix[0] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[0];
+		adjust.temperature_matrix[1] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[1];
+		adjust.temperature_matrix[2] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[2];
+		adjust.temperature_matrix[3] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[4];
+		adjust.temperature_matrix[4] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[5];
+		adjust.temperature_matrix[5] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[6];
+		adjust.temperature_matrix[6] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[8];
+		adjust.temperature_matrix[7] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[9];
+		adjust.temperature_matrix[8] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[10];
+	}
+
+	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+
+	if (old_pipe && memcmp(&old_pipe->scl_data,
+				&pipe_ctx->scl_data,
+				sizeof(struct scaler_data)) != 0)
+		program_scaler(dc, pipe_ctx);
+
+	if (pipe_ctx->bottom_pipe)
+		pipe_ctx->xfm->funcs->transform_set_alpha(pipe_ctx->xfm, true);
+
+	mi->funcs->mem_input_program_surface_config(
+			mi,
+			surface->public.format,
+			&surface->public.tiling_info,
+			&surface->public.plane_size,
+			surface->public.rotation);
+
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
+				pipe_ctx->mi,
+				surface->public.format,
+				&surface->public.tiling_info,
+				surface->public.rotation);
 
 	dc->hwss.update_plane_addr(dc, pipe_ctx);
 
@@ -1938,7 +2012,6 @@ static void dce110_program_front_end_for_pipe(struct core_dc *dc,
 			pipe_ctx->surface->public.clip_rect.width,
 			pipe_ctx->surface->public.clip_rect.height);
 
-
 	dal_logger_write(dc->ctx->logger,
 			LOG_MAJOR_INTERFACE_TRACE,
 			LOG_MINOR_COMPONENT_SURFACE,
@@ -1956,7 +2029,7 @@ static void dce110_program_front_end_for_pipe(struct core_dc *dc,
 			pipe_ctx->scl_data.recout.y);
 }
 
-static enum dc_status apply_ctx_to_surface(
+static enum dc_status apply_ctx_to_surface_locked(
 		struct core_dc *dc,
 		struct validate_context *context)
 {
@@ -1974,7 +2047,26 @@ static enum dc_status apply_ctx_to_surface(
 		hw_sequencer_program_pipe_tree(dc, context, head_pipe,
 				dce110_program_front_end_for_pipe);
 
+	}
+
 
+	return DC_OK;
+}
+
+static enum dc_status apply_ctx_to_surface_unlock(
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	int i;
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *head_pipe = &context->res_ctx.pipe_ctx[i];
+
+		if (!head_pipe->surface || head_pipe->top_pipe != NULL)
+			continue;
+
+		hw_sequencer_program_pipe_tree(dc, context, head_pipe,
+				dce110_program_blending);
 	}
 
 	/* Go in reverse order so that all pipes are unlocked simultaneously
@@ -1995,9 +2087,6 @@ static enum dc_status apply_ctx_to_surface(
 				false);
 	}
 
-#ifdef DIAGS_BUILD
-	print_context_timing_status(dc, &context->res_ctx);
-#endif
 	return DC_OK;
 }
 
@@ -2026,7 +2115,8 @@ static void update_plane_surface(
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = apply_ctx_to_hw,
-	.apply_ctx_to_surface = apply_ctx_to_surface,
+	.apply_ctx_to_surface_locked = apply_ctx_to_surface_locked,
+	.apply_ctx_to_surface_unlock = apply_ctx_to_surface_unlock,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = update_pending_status,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index caf3664..6a47452 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -51,7 +51,10 @@ struct hw_sequencer_funcs {
 	enum dc_status (*apply_ctx_to_hw)(
 			struct core_dc *dc, struct validate_context *context);
 
-	enum dc_status (*apply_ctx_to_surface)(
+	enum dc_status (*apply_ctx_to_surface_locked)(
+			struct core_dc *dc, struct validate_context *context);
+
+	enum dc_status (*apply_ctx_to_surface_unlock)(
 			struct core_dc *dc, struct validate_context *context);
 
 	void (*set_plane_config)(
-- 
2.7.4

