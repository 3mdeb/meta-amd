From bb9790b0b4c3971f4f298908b2a3a99c281e7b9b Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Tue, 9 Jun 2015 11:12:22 -0400
Subject: [PATCH 269/401] drm/amdgpu: Add AMDDSAT

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Tim Writer <Tim.Writer@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/Makefile            |   7 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c         |  13 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h         |   5 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c        |   8 +
 drivers/gpu/drm/amd/dsat/Makefile              |  17 +
 drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.c   | 709 +++++++++++++++++++++
 drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.h   |  32 +
 drivers/gpu/drm/amd/dsat/amdgpu_dsat_structs.h | 575 +++++++++++++++++
 drivers/gpu/drm/amd/dsat/dsat.c                | 846 +++++++++++++++++++++++++
 drivers/gpu/drm/amd/dsat/dsat.h                | 195 ++++++
 10 files changed, 2406 insertions(+), 1 deletion(-)
 create mode 100644 drivers/gpu/drm/amd/dsat/Makefile
 create mode 100644 drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.c
 create mode 100644 drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.h
 create mode 100644 drivers/gpu/drm/amd/dsat/amdgpu_dsat_structs.h
 create mode 100644 drivers/gpu/drm/amd/dsat/dsat.c
 create mode 100644 drivers/gpu/drm/amd/dsat/dsat.h

diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index 075e4ce..f0c80e8 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -8,7 +8,9 @@ ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/amd/include/asic_reg \
 		-Idrivers/gpu/drm/amd/acp/include \
 		-Idrivers/gpu/drm/amd/amdgpu \
 		-Idrivers/gpu/drm/amd/dal \
-		-Idrivers/gpu/drm/amd/dal/include
+		-Idrivers/gpu/drm/amd/dal/include \
+		-Idrivers/gpu/drm/amd/dsat
+		
 amdgpu-y := amdgpu_drv.o
 
 # add KMS driver
@@ -100,6 +102,9 @@ amdgpu-y += amdgpu_dal_services.o amdgpu_dm_types.o amdgpu_dm.o \
 include drivers/gpu/drm/amd/dal/Makefile
 
 amdgpu-y += $(AMD_DAL_FILES)
+
+include drivers/gpu/drm/amd/dsat/Makefile
+
 endif
 
 obj-$(CONFIG_DRM_AMDGPU)+= amdgpu.o
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
index 6fa8564..020b393 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.c
@@ -1089,3 +1089,16 @@ static int dm_early_init(void *handle)
 
 	return 0;
 }
+
+
+bool amdgpu_dm_acquire_dal_lock(struct amdgpu_display_manager *dm)
+{
+	/* TODO */
+	return true;
+}
+
+bool amdgpu_dm_release_dal_lock(struct amdgpu_display_manager *dm)
+{
+	/* TODO */
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
index b93224f..fdbf196 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dm.h
@@ -119,6 +119,11 @@ int amdgpu_dm_initialize_drm_device(
 void amdgpu_dm_destroy_drm_device(
 	struct amdgpu_display_manager *dm);
 
+/* Locking/Mutex */
+bool amdgpu_dm_acquire_dal_lock(struct amdgpu_display_manager *dm);
+
+bool amdgpu_dm_release_dal_lock(struct amdgpu_display_manager *dm);
+
 extern const struct amd_ip_funcs amdgpu_dm_funcs;
 
 #endif /* __AMDGPU_DM_H__ */
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
index bb94bda..36ed690 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
@@ -31,6 +31,8 @@
 #include "amdgpu_uvd.h"
 #include "amdgpu_vce.h"
 
+#include "amdgpu_dsat_ioctl.h"
+
 #include <linux/vga_switcheroo.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
@@ -699,5 +701,11 @@ const struct drm_ioctl_desc amdgpu_ioctls_kms[] = {
 	DRM_IOCTL_DEF_DRV(AMDGPU_GEM_VA, amdgpu_gem_va_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(AMDGPU_GEM_OP, amdgpu_gem_op_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(AMDGPU_GEM_USERPTR, amdgpu_gem_userptr_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
+
+#ifdef CONFIG_DRM_AMD_DAL
+	/* DSAT */
+	DRM_IOCTL_DEF_DRV(AMDGPU_DSAT_COMMAND, amdgpu_dsat_cmd_ioctl, DRM_AUTH|DRM_ROOT_ONLY),
+#endif
+
 };
 int amdgpu_max_kms_ioctl = ARRAY_SIZE(amdgpu_ioctls_kms);
diff --git a/drivers/gpu/drm/amd/dsat/Makefile b/drivers/gpu/drm/amd/dsat/Makefile
new file mode 100644
index 0000000..d1ea67a
--- /dev/null
+++ b/drivers/gpu/drm/amd/dsat/Makefile
@@ -0,0 +1,17 @@
+#
+# Makefile for DSAT, which is a  sub-component
+# of AMDGPU drm driver.
+# It provides additional controls for debugging.
+
+#AMDDALDSATPATH = ../amd/dsat
+AMDDALDSATPATH = ../dsat
+
+subdir-ccflags-y += -I$(AMDDALDSATPATH)
+
+DSAT = amdgpu_dsat_ioctl.o dsat.o
+
+AMDGPU_DSAT = $(addprefix $(AMDDALDSATPATH)/,$(DSAT))
+
+amdgpu-y += $(AMDGPU_DSAT)
+
+
diff --git a/drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.c b/drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.c
new file mode 100644
index 0000000..d52f91c
--- /dev/null
+++ b/drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.c
@@ -0,0 +1,709 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/firmware.h>
+#include <linux/module.h>
+
+#include <drm/drmP.h>
+#include <drm/amdgpu_drm.h>
+#include "amdgpu.h"
+#include "amdgpu_dsat_structs.h"
+
+#include "dal_services_types.h"
+#include "include/dal_interface.h"
+#include "dsat.h"
+#include "amdgpu_dsat_ioctl.h"
+
+int amdgpu_dsat_cmd_ioctl(struct drm_device *dev, void *data,
+		struct drm_file *filp)
+{
+	struct amdgpu_device *rdev;
+	struct amdgpu_display_manager *dm;
+	struct dal *dal;
+	struct drm_amdgpu_dsat_cmd_context *dsat_ctx = data;
+
+	int i;
+	uint32_t ret = 0;
+
+	uint64_t user_input_ptr = dsat_ctx->in_ptr;
+	uint64_t user_output_ptr = dsat_ctx->out_ptr;
+	uint32_t out_data_buffer_size = 0;
+
+	struct amdgpu_dsat_input_context *kernel_in_data = NULL;
+	struct amdgpu_dsat_output_context *kernel_out_data = NULL;
+
+	rdev = (struct amdgpu_device *) dev->dev_private;
+	dm = &rdev->dm;
+	dal = dm->dal;
+	dsat_ctx->ret = DSAT_CMD_OK;
+
+	/* Allocate kernel space for struct + blob */
+	if (dsat_ctx->in_size > 0)
+		kernel_in_data = kmalloc(dsat_ctx->in_size, GFP_KERNEL);
+
+	if (dsat_ctx->out_size > 0)
+		kernel_out_data = kmalloc(dsat_ctx->out_size, GFP_KERNEL);
+
+	if (kernel_in_data == NULL) {
+		DRM_ERROR("DSAT- Failed to malloc input struct size=%d\n", dsat_ctx->in_size);
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	if (kernel_out_data == NULL) {
+		DRM_ERROR("DSAT- Failed to malloc output struct\n");
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	if (dsat_ctx->out_size < sizeof(struct amdgpu_dsat_output_context)) {
+		DRM_ERROR("DSAT- wrong output buffer size\n");
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	/* Initialize some variables in case of default case or error */
+	out_data_buffer_size =
+		dsat_ctx->out_size - sizeof(struct amdgpu_dsat_output_context);
+	dsat_ctx->out_size = sizeof(struct amdgpu_dsat_output_context);
+	kernel_out_data->data_size = 0;
+
+	ret = copy_from_user(kernel_in_data, (void __user *) user_input_ptr,
+			dsat_ctx->in_size);
+
+	if (ret) {
+		DRM_ERROR("DSAT - Failed copying %ud bytes FROM user mode\n",
+				ret);
+		dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+		goto cleanup;
+	}
+
+	switch (kernel_in_data->cmd) {
+	case DSAT_CMD_LOGGER_ENUM_MAJOR_INFO: {
+		uint32_t *major_index;
+		if (out_data_buffer_size <
+				sizeof(struct dsat_logger_major_info)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+		if (kernel_in_data->in_data_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+		major_index = (uint32_t *) kernel_in_data->data;
+		kernel_out_data->data_size = dsat_logger_enum_major_info(
+				dm,
+				kernel_out_data->data,
+				*major_index);
+
+		break;
+	}
+	case DSAT_CMD_LOGGER_ENUM_MINOR_INFO: {
+		struct dsat_logger_request *minor_request;
+
+		if (out_data_buffer_size < sizeof(struct log_minor_info)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		if (kernel_in_data->in_data_size <
+			sizeof(struct dsat_logger_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		minor_request =
+		(struct dsat_logger_request *) kernel_in_data->data;
+
+		kernel_out_data->data_size = dsat_logger_enum_minor_info(
+				dm,
+				kernel_out_data->data,
+				minor_request->major_index,
+				minor_request->minor_index);
+
+		break;
+	}
+	case DSAT_CMD_LOGGER_GET_BUFFER_SIZE: {
+		uint32_t *buffer_size = (uint32_t *)kernel_out_data->data;
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		*buffer_size = dsat_logger_get_buffer_size(dm);
+
+		break;
+	}
+	case DSAT_CMD_LOGGER_SET_BUFFER_SIZE: {
+		uint32_t *buffer_size = (uint32_t *) kernel_in_data->data;
+		uint32_t *new_buffer_size = (uint32_t *)kernel_out_data->data;
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+		if (kernel_in_data->in_data_size <
+			sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		*new_buffer_size = dsat_logger_set_buffer_size(dm,
+				*buffer_size);
+
+		break;
+	}
+	case DSAT_CMD_LOGGER_GET_FLAGS: {
+		uint32_t *flags = (uint32_t *)kernel_out_data->data;
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		*flags = dsat_logger_get_flags(dm);
+		break;
+	}
+	case DSAT_CMD_LOGGER_SET_FLAGS: {
+		uint32_t *flags = (uint32_t *) kernel_in_data->data;
+
+		if (kernel_in_data->in_data_size <
+			sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		dsat_logger_set_flags(dm, *flags);
+		break;
+	}
+	case DSAT_CMD_LOGGER_GET_MASK: {
+		struct dsat_logger_request *request =
+			(struct dsat_logger_request *) kernel_in_data->data;
+		uint32_t *mask = (uint32_t *)kernel_out_data->data;
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		if (kernel_in_data->in_data_size <
+			sizeof(struct dsat_logger_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		*mask = dsat_logger_get_mask(dm, request->major_index,
+				request->minor_index);
+
+		break;
+	}
+	case DSAT_CMD_LOGGER_SET_MASK: {
+		struct dsat_logger_request *request =
+			(struct dsat_logger_request *) kernel_in_data->data;
+		if (kernel_in_data->in_data_size <
+			sizeof(struct dsat_logger_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		dsat_logger_set_mask(dm, request->major_index,
+				request->major_index);
+		break;
+	}
+	case DSAT_CMD_LOGGER_GET_MASKS: {
+		struct dsat_logger_request *request =
+			(struct dsat_logger_request *) kernel_in_data->data;
+		uint32_t *mask = (uint32_t *)kernel_out_data->data;
+
+		if (kernel_in_data->in_data_size <
+			sizeof(struct dsat_logger_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		*mask = dsat_logger_get_masks(dm, request->major_index);
+		break;
+	}
+	case DSAT_CMD_LOGGER_SET_MASKS: {
+		struct dsat_logger_request *request =
+			(struct dsat_logger_request *) kernel_in_data->data;
+
+		if (kernel_in_data->in_data_size <
+			sizeof(struct dsat_logger_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+		dsat_logger_set_masks(dm, request->major_index, request->mask);
+		break;
+	}
+	case DSAT_CMD_LOGGER_UNSET_MASK: {
+		struct dsat_logger_request *request =
+			(struct dsat_logger_request *) kernel_in_data->data;
+
+		if (kernel_in_data->in_data_size <
+			sizeof(struct dsat_logger_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		dsat_logger_unset_mask(dm, request->major_index,
+				request->minor_index);
+
+		break;
+	}
+	case DSAT_CMD_LOGGER_READ: {
+
+		if (kernel_in_data->in_data_size <
+			sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+
+		}
+
+		dsat_logger_read(dm, out_data_buffer_size,
+				(char *) kernel_out_data->data,
+				&kernel_out_data->data_size, false);
+
+		break;
+	}
+	case DSAT_CMD_READ_HW_REG: {
+		if (kernel_in_data->in_data_size <
+				sizeof(struct dsat_hw_rw_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+		}
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+
+		struct dsat_hw_rw_request *request =
+			(struct dsat_hw_rw_request *) kernel_in_data->data;
+		uint32_t *reg_value = (uint32_t *) kernel_out_data->data;
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+		*reg_value = dsat_read_hw_reg(dm, request->address);
+
+		break;
+	}
+	case DSAT_CMD_WRITE_HW_REG: {
+		if (kernel_in_data->in_data_size <
+				sizeof(struct dsat_hw_rw_request)) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+		}
+
+		struct dsat_hw_rw_request *request =
+			(struct dsat_hw_rw_request *) kernel_in_data->data;
+
+		dsat_write_hw_reg(dm, request->address, request->value);
+
+		break;
+	}
+	case DSAT_CMD_ADAPTERS_GET_COUNT: {
+		uint32_t *number_of_adapters =
+				(uint32_t *) kernel_out_data->data;
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		*number_of_adapters = dsat_get_adapters_count(dm);
+
+		break;
+	}
+	case DSAT_CMD_ADAPTERS_GET_INFO: {
+		uint32_t adapter_count = dsat_get_adapters_count(dm);
+		uint32_t adapter_index = 0;
+		struct dsat_adapter_info *adapter_info_array = NULL;
+
+		kernel_out_data->data_size = sizeof(struct dsat_adapter_info)
+				* adapter_count;
+
+		if (out_data_buffer_size < kernel_out_data->data_size) {
+			kernel_out_data->data_size = 0;
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+
+		adapter_info_array =
+			(struct dsat_adapter_info *) kernel_out_data->data;
+
+		memset((void *) adapter_info_array, 0,
+				kernel_out_data->data_size);
+
+		for (adapter_index = 0; adapter_index < adapter_count;
+				adapter_index++) {
+			dsat_get_adapters_info(dm, adapter_index,
+					&adapter_info_array[adapter_index]);
+
+		}
+		break;
+	}
+	case DSAT_CMD_ADAPTER_GET_CAPS: {
+		break;
+
+	}
+	case DSAT_CMD_DISPLAYS_GET_COUNT: {
+		uint32_t *number_of_displays =
+				(uint32_t *) kernel_out_data->data;
+
+
+		if (out_data_buffer_size < sizeof(uint32_t)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		kernel_out_data->data_size = sizeof(uint32_t);
+
+		*number_of_displays = dsat_get_displays_count(dm,
+				kernel_in_data->adapter_index);
+
+		break;
+	}
+	case DSAT_CMD_DISPLAYS_GET_INFO: {
+		uint32_t adapter_index = kernel_in_data->adapter_index;
+
+		uint32_t display_count = dsat_get_displays_count(dm,
+				adapter_index);
+		struct dsat_display_info *display_info_array = NULL;
+
+		kernel_out_data->data_size = sizeof(struct dsat_display_info)
+				* display_count;
+
+		if (out_data_buffer_size < kernel_out_data->data_size) {
+			kernel_out_data->data_size = 0;
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		display_info_array =
+			(struct dsat_display_info *) kernel_out_data->data;
+
+		memset((void *) display_info_array, 0,
+			kernel_out_data->data_size);
+
+		if (dsat_get_displays_info(dm,
+			kernel_in_data->adapter_index,
+			out_data_buffer_size,
+			display_info_array)) {
+			dsat_ctx->ret = DSAT_CMD_ERROR;
+		}
+
+		break;
+	}
+	case DSAT_CMD_DISPLAY_GET_CAPS: {
+		dsat_ctx->ret = DSAT_CMD_NOT_IMPLEMENTED;
+		break;
+
+	}
+	case DSAT_CMD_DISPLAY_GET_DEVICE_CONFIG: {
+		dsat_ctx->ret = DSAT_CMD_NOT_IMPLEMENTED;
+		break;
+
+	}
+	case DSAT_CMD_DISPLAY_GET_DDC_INFO: {
+		dsat_ctx->ret = DSAT_CMD_NOT_IMPLEMENTED;
+		break;
+
+	}
+
+	case DSAT_CMD_TEST: {
+		struct dsat_test_in *test_in;
+		struct dsat_test_out test_out;
+
+		/* Cast from 'kernel_in_data' to actual struct */
+		test_in = (struct dsat_test_in *) kernel_in_data->data;
+
+
+		if (kernel_in_data->in_data_size <
+				(sizeof(struct dsat_test_in))) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+		}
+
+		if (out_data_buffer_size < sizeof(struct dsat_test_in)) {
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+
+		dsat_test_fill_data(dm, test_in, &test_out);
+
+		/* Set sizes and return values properly */
+		kernel_out_data->data_size = sizeof(struct dsat_test_out);
+		if (out_data_buffer_size < sizeof(struct dsat_test_out)) {
+			kernel_out_data->data_size = 0;
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		/* TODO: Stop doing a memcpy,
+		 * just write directly into malloced area */
+
+		/* Pack interior struct into output struct */
+		memcpy(kernel_out_data->data, &test_out,
+				kernel_out_data->data_size);
+
+		break;
+	}
+	case DSAT_CMD_GET_EDID: {
+
+		if (dsat_display_get_edid(dm,
+				kernel_in_data->adapter_index,
+				kernel_in_data->display_index,
+				&out_data_buffer_size,
+				kernel_out_data->data)) {
+			dsat_ctx->ret = DSAT_CMD_ERROR;
+			break;
+		}
+
+		kernel_out_data->data_size = out_data_buffer_size;
+		break;
+
+	}
+
+	case DSAT_CMD_OVERRIDE_EDID: {
+		struct dsat_display_edid_data *edid_in_data;
+
+		if (kernel_in_data->in_data_size <
+				(sizeof(struct dsat_display_edid_data))) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+		}
+
+		edid_in_data =
+			(struct dsat_display_edid_data *) kernel_in_data->data;
+
+		dsat_override_edid(dm, kernel_in_data->adapter_index,
+			kernel_in_data->display_index, edid_in_data);
+		break;
+	}
+	case DSAT_CMD_GET_ADJUSTMENT_INFO: {
+		uint32_t *adjust_id = (uint32_t *) kernel_in_data->data;
+		struct adjustment_info *adjust_info =
+			(struct adjustment_info *) kernel_out_data->data;
+
+		if (kernel_in_data->in_data_size < (sizeof(uint32_t))) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+		}
+
+		kernel_out_data->data_size = sizeof(struct adjustment_info);
+		if (out_data_buffer_size < kernel_out_data->data_size) {
+			kernel_out_data->data_size = 0;
+			dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			break;
+		}
+
+		dsat_get_adjustment_info(dm, kernel_in_data->adapter_index,
+				kernel_in_data->display_index,
+				*adjust_id,
+				adjust_info);
+
+		break;
+	}
+	case DSAT_CMD_DAL_ADJUSTMENT: {
+		struct dsat_adjustment_data *adj_value;
+
+		if (kernel_in_data->in_data_size <
+				(sizeof(struct dsat_adjustment_data))) {
+			dsat_ctx->ret = DSAT_CMD_DATA_ERROR;
+			break;
+		}
+
+		adj_value =
+			(struct dsat_adjustment_data *) kernel_in_data->data;
+
+		switch (adj_value->id) {
+		case DSAT_DAL_ADJ_ID_SATURATION:
+			if (adj_value->cmd == DSAT_DAL_ADJ_SET) {
+				dsat_set_saturation(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value->value);
+
+			} else {
+				dsat_get_saturation(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value);
+			}
+			break;
+
+		case DSAT_DAL_ADJ_ID_BACKLIGHT:
+			if (adj_value->cmd == DSAT_DAL_ADJ_SET) {
+				dsat_set_backlight(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value->value);
+
+			} else {
+				dsat_get_backlight(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value);
+			}
+			break;
+
+		case DSAT_DAL_ADJ_ID_BIT_DEPTH_REDUCTION:
+			if (adj_value->cmd == DSAT_DAL_ADJ_SET) {
+				dsat_set_bit_depth_reduction(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value->value);
+
+			} else {
+				dsat_get_bit_depth_reduction(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value);
+			}
+			break;
+
+		case DSAT_DAL_ADJ_ID_UNDERSCAN:
+			if (adj_value->cmd == DSAT_DAL_ADJ_SET) {
+				dsat_set_underscan(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value->value);
+
+			} else {
+				dsat_get_underscan(dm,
+						kernel_in_data->adapter_index,
+						kernel_in_data->display_index,
+						adj_value);
+			}
+			break;
+		}
+
+		if (adj_value->cmd != DSAT_DAL_ADJ_SET) {
+			kernel_out_data->data_size =
+					sizeof(struct dsat_adjustment_data);
+
+			if (out_data_buffer_size <
+					sizeof(struct dsat_adjustment_data)) {
+				kernel_out_data->data_size = 0;
+				dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+			} else {
+				memcpy(kernel_out_data->data, adj_value,
+						kernel_out_data->data_size);
+			}
+		}
+
+		break;
+		case DSAT_CMD_DISPLAY_MODE_TIMING_GET_COUNT: {
+			uint32_t *display_path_nums =
+					(uint32_t *) kernel_out_data->data;
+
+			if (out_data_buffer_size < sizeof(uint32_t)) {
+				dsat_ctx->ret = DSAT_CMD_WRONG_BUFFER_SIZE;
+				break;
+			}
+
+			kernel_out_data->data_size = sizeof(uint32_t);
+
+			*display_path_nums =
+				dsat_display_mode_timing_get_count(
+					dm,
+					kernel_in_data->adapter_index,
+					kernel_in_data->display_index);
+			break;
+		}
+
+		/*user mode must get count of mode timing first, allocate
+		 * correct size of buffer, and then call get list*/
+		case DSAT_CMD_DISPLAY_MODE_TIMINF_GET_LIST: {
+			if (!dsat_display_mode_timing_get_list(
+					dm,
+					kernel_in_data->adapter_index,
+					kernel_in_data->display_index,
+					out_data_buffer_size,
+					(struct dsat_mode_timing *)kernel_out_data->data)) {
+				dsat_ctx->ret = DSAT_CMD_ERROR;
+				break;
+			}
+
+			kernel_out_data->data_size = out_data_buffer_size;
+			break;
+		}
+	}
+	default: {
+		break;
+	}
+	}
+
+	dsat_ctx->out_size = sizeof(struct amdgpu_dsat_output_context)
+			+ kernel_out_data->data_size;
+
+	ret = copy_to_user((void __user *) user_output_ptr, kernel_out_data,
+			dsat_ctx->out_size);
+
+	if (ret)
+		DRM_ERROR("DSAT - Failed copying %ud bytes TO user mode", ret);
+
+cleanup:
+
+	if (kernel_in_data)
+		kfree(kernel_in_data);
+
+	if (kernel_out_data)
+		kfree(kernel_out_data);
+
+	if (ret)
+	{
+		DRM_ERROR("DSAT - Failed, error: %d", ret);
+		return -EFAULT;
+	}
+	return 0;
+}
diff --git a/drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.h b/drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.h
new file mode 100644
index 0000000..7ad9a84
--- /dev/null
+++ b/drivers/gpu/drm/amd/dsat/amdgpu_dsat_ioctl.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __AMDGPU_DSAT_IOCTL__H
+#define __AMDGPU_DSAT_IOCTL__H
+
+#include <linux/types.h>
+
+int amdgpu_dsat_cmd_ioctl(struct drm_device *dev,
+		void *data,
+		struct drm_file *filp);
+
+#endif /* __AMDGPU_DSAT_IOCTL__H */
diff --git a/drivers/gpu/drm/amd/dsat/amdgpu_dsat_structs.h b/drivers/gpu/drm/amd/dsat/amdgpu_dsat_structs.h
new file mode 100644
index 0000000..b9bc910
--- /dev/null
+++ b/drivers/gpu/drm/amd/dsat/amdgpu_dsat_structs.h
@@ -0,0 +1,575 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ * Copyright
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *
+ * Description:
+ *  Public header file for AMDGPU DSAT library, struct defns
+ *
+ */
+
+#ifndef __AMDGPU_DSAT_STRUCTS__H
+#define __AMDGPU_DSAT_STRUCTS__H
+
+#define DSAT_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED		0x00000001
+#define DSAT_DISPLAY_DISPLAYINFO_DISPLAYMAPPED			0x00000002
+#define DSAT_DISPLAY_DISPLAYINFO_NONLOCAL			0x00000004
+#define DSAT_DISPLAY_DISPLAYINFO_FORCIBLESUPPORTED		0x00000008
+#define DSAT_DISPLAY_DISPLAYINFO_GENLOCKSUPPORTED		0x00000010
+#define DSAT_DISPLAY_DISPLAYINFO_MULTIVPU_SUPPORTED		0x00000020
+#define DSAT_DISPLAY_DISPLAYINFO_LDA_DISPLAY			0x00000040
+#define DSAT_DISPLAY_DISPLAYINFO_MODETIMING_OVERRIDESSUPPORTED	0x00000080
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_SINGLE	0x00000100
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_CLONE		0x00000200
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2VSTRETCH	0x00000400
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2HSTRETCH	0x00000800
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_EXTENDED	0x00001000
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCH1GPU	0x00010000
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCHNGPU	0x00020000
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED2	0x00040000
+#define DSAT_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED3	0x00080000
+#define DSAT_DISPLAY_DISPLAYINFO_SHOWTYPE_PROJECTOR		0x00100000
+
+#define DSAT_MAX_REGISTRY_PATH 256
+enum dsat_cmd_errors {
+	DSAT_CMD_OK,
+	DSAT_CMD_NOT_IMPLEMENTED,
+	DSAT_CMD_ERROR,
+	DSAT_CMD_DATA_ERROR,
+	DSAT_CMD_WRONG_BUFFER_SIZE,
+	DSAT_CMD_DISABLED
+};
+
+enum dsat_ioctl_commands {
+	/* @brief: Used to test DSAT bridge functionality
+	 * @param[in]:dsat_test_in
+	 * @param[out]:dsat_test_out
+	 */
+	DSAT_CMD_TEST,
+	/* @brief: Get logger buffer size
+	 * @param[in]:
+	 * @param[out]:uint32_t buffer_size
+	 */
+	DSAT_CMD_LOGGER_GET_BUFFER_SIZE,
+	/* @brief: Set logger buffer size
+	 * @param[in]:uint32_t buffer_size
+	 * @param[out]:uint32_t new_buffer_size
+	 */
+	DSAT_CMD_LOGGER_SET_BUFFER_SIZE,
+	/* @brief: Get logger flags
+	 * @param[in]:
+	 * @param[out]:uint32_t flags
+	 */
+	DSAT_CMD_LOGGER_GET_FLAGS,
+	/* @brief: Set logger flags
+	 * @param[in]:uint32_t flags
+	 * @param[out]:
+	 */
+	DSAT_CMD_LOGGER_SET_FLAGS,
+	/* @brief: Get logger mask
+	 * @param[in]:uint32_t mask_index
+	 * @param[out]:uint32_t mask
+	 */
+	DSAT_CMD_LOGGER_GET_MASK,
+	/* @brief: Set logger mask
+	 * @param[in]:struct dsat_logger_request
+	 * @param[out]:uint32_t mask
+	 */
+	DSAT_CMD_LOGGER_SET_MASK,
+	/* @brief: Unset logger mask
+	 * @param[in]:struct dsat_logger_request
+	 * @param[out]:
+	 */
+	DSAT_CMD_LOGGER_UNSET_MASK,
+	/* @brief: get logger masks
+	 * @param[in]:struct dsat_logger_request
+	 * @param[out]:uint32_t mask
+	 */
+	DSAT_CMD_LOGGER_GET_MASKS,
+	/* @brief: Set logger masks
+	 * @param[in]:struct dsat_logger_request
+	 * @param[out]:
+	 */
+	DSAT_CMD_LOGGER_SET_MASKS,
+	/* @brief: Get logger majors info
+	 * @param[in]:uint32_t major_index
+	 * @param[out]:void *
+	 */
+	DSAT_CMD_LOGGER_ENUM_MAJOR_INFO,
+	/* @brief: Get logger minors info
+	 * @param[in]:struct dsat_logger_request
+	 * @param[out]:void *
+	 */
+	DSAT_CMD_LOGGER_ENUM_MINOR_INFO,
+	/* @brief: Read driver log
+	 * @param[in]:
+	 * @param[out]:char *
+	 */
+	DSAT_CMD_LOGGER_READ,
+	/* @brief: Read HW Reg
+	 * @comment: set DDSAT_ALLOW_REG_ACCESS in makefile
+	 * to enable this functionality in developers build
+	 * @param[in]:dsat_hw_rw_request
+	 * @param[out]:uint32_t reg_value
+	 */
+	DSAT_CMD_READ_HW_REG,
+	/* @brief: Write HW Reg
+	 * @comment: set DDSAT_ALLOW_REG_ACCESS in makefile
+	 * to enable this functionality in developers build
+	 * @param[in]:dsat_hw_rw_request
+	 * @param[out]:
+	 */
+	DSAT_CMD_WRITE_HW_REG,
+	/* @brief: Get adapters count
+	 * @param[in]:
+	 * @param[out]:uint32_t count
+	 */
+	DSAT_CMD_ADAPTERS_GET_COUNT,
+	/* @brief: Get adapters info
+	 * @param[in]:
+	 * @param[out]:struct dsat_adapter_info[adapter_count]
+	 */
+	DSAT_CMD_ADAPTERS_GET_INFO,
+	/* @brief: get adapter caps
+	 * @comment: not implemented
+	 * @param[in]:
+	 * @param[out]:
+	 */
+	DSAT_CMD_ADAPTER_GET_CAPS,
+	/* @brief: Get display EDID
+	 * @param[in]:
+	 * @param[out]:uint8_t *edid_data
+	 */
+	DSAT_CMD_GET_EDID,
+	/* @brief: Override display EDID
+	 * @param[in]:struct dsat_display_edid_data
+	 * @param[out]:
+	 */
+	DSAT_CMD_OVERRIDE_EDID,
+	/* @brief: Get display mode
+	 * @comment: not implemented
+	 * @param[in]:
+	 * @param[out]:
+	 */
+	DSAT_CMD_GET_DISPLAY_MODE,
+	/* @brief: Set display mode
+	 * @comment: not implemented
+	 * @param[in]:
+	 * @param[out]:
+	 */
+	DSAT_CMD_SET_DISPLAY_MODE,
+	/* @brief: Get display adjustment
+	 * @comment: not implemented
+	 * @param[in]:struct dsat_adjustment_data
+	 * @param[out]:
+	 */
+	DSAT_CMD_DAL_ADJUSTMENT,
+	/* @brief: Get display adjustment info
+	 * @param[in]:struct dsat_adjustment_data
+	 * @param[out]:struct adjustment_info adjust_info
+	 */
+	DSAT_CMD_GET_ADJUSTMENT_INFO,
+	/* @brief: Get displays count
+	 * @param[in]:
+	 * @param[out]:uint32_t count
+	 */
+	DSAT_CMD_DISPLAYS_GET_COUNT,
+	/* @brief: get displays info
+	 * @param[in]:
+	 * @param[out]:struct dsat_display_info[display_count]
+	 */
+	DSAT_CMD_DISPLAYS_GET_INFO,
+	/* @brief: get display caps
+	 * @comment: not implemented
+	 * @param[in]:
+	 * @param[out]:
+	 */
+	DSAT_CMD_DISPLAY_GET_CAPS,
+	/* @brief: Get display config
+	 * @comment: not implemented
+	 * @param[in]:
+	 * @param[out]:
+	 */
+	DSAT_CMD_DISPLAY_GET_DEVICE_CONFIG,
+	/* @brief: get display DDC info
+	 * @comment: not implemented
+	 * @param[in]:
+	 * @param[out]:
+	 */
+	DSAT_CMD_DISPLAY_GET_DDC_INFO,
+	/* @brief: get display monitor mode timing count
+	 * @param[in]:
+	 * @param[out]:uint32_t count
+	 */
+	DSAT_CMD_DISPLAY_MODE_TIMING_GET_COUNT,
+	/* @brief: get display monitor mode timing list
+	 * @param[in]:
+	 * @param[out]:mode timing list
+	 */
+	DSAT_CMD_DISPLAY_MODE_TIMINF_GET_LIST,
+};
+
+/* Ensure total struct is 8-byte aligned. */
+#pragma pack(8)
+
+struct amdgpu_dsat_input_context {
+	enum dsat_ioctl_commands cmd;
+	uint32_t adapter_index;
+	uint32_t display_index;
+	uint32_t in_data_size;
+	uint8_t data[1];
+	/*
+	 * ------------------------
+	 * | Additional data here |
+	 * ------------------------
+	 */
+};
+
+struct amdgpu_dsat_output_context {
+	uint32_t data_size;
+	uint32_t cmd_error;
+	uint8_t data[1];
+	/*
+	 * ------------------------
+	 * | Additional data here |
+	 * ------------------------
+	 */
+};
+
+/* structs for DSAT_CMD_TEST */
+struct dsat_test_in {
+	uint32_t value1;
+	uint32_t value2;
+	uint32_t value3;
+};
+
+struct dsat_test_out {
+	uint64_t value4;
+	uint32_t value1;
+	uint32_t value2;
+	uint32_t value3;
+};
+
+struct dsat_hw_rw_request {
+	uint32_t address;
+	uint32_t value;
+};
+
+/* structs for DSAT_CMD_GET_EDID_DATA and DSAT_CMD_OVERRIDE_EDID */
+struct dsat_display_edid_data {
+	uint32_t data_size;
+	uint8_t data[DSAT_MAX_REGISTRY_PATH];
+};
+
+enum dsat_dal_adjustment_id {
+	DSAT_DAL_ADJ_ID_SATURATION,
+	DSAT_DAL_ADJ_ID_BACKLIGHT,
+	DSAT_DAL_ADJ_ID_BIT_DEPTH_REDUCTION,
+	DSAT_DAL_ADJ_ID_UNDERSCAN
+};
+
+enum dsat_dal_adjustment_cmd {
+	DSAT_DAL_ADJ_SET, DSAT_DAL_ADJ_GET
+};
+
+struct dsat_adjustment_data {
+	enum dsat_dal_adjustment_cmd cmd;
+	enum dsat_dal_adjustment_id id;
+	int32_t value;
+};
+
+/* structs for DSAT general use */
+struct dsat_logger_request {
+	uint32_t major_index;
+	uint32_t minor_index;
+	uint32_t mask;
+};
+
+union dsat_logger_flags {
+	struct {
+		uint32_t ENABLE_CONSOLE:1; /* Print to console */
+		uint32_t ENABLE_BUFFER:1; /* Print to buffer */
+		uint32_t RESERVED:30;
+	} bits;
+	uint32_t value;
+};
+#define DSAT_MAX_MAJOR_NAME_LEN 32
+#define DSAT_MAX_MINOR_NAME_LEN 32
+
+struct dsat_logger_major_info {
+	uint32_t major;
+	char major_name[DSAT_MAX_MAJOR_NAME_LEN];
+};
+
+struct dsat_logger_minor_info {
+	uint32_t minor;
+	char minor_name[DSAT_MAX_MINOR_NAME_LEN];
+};
+
+struct dsat_adapter_info {
+	uint32_t bus_number;
+	uint32_t device_number;
+	uint32_t function_number;
+	uint32_t chip_family;
+	uint32_t chip_id;
+	uint32_t pci_revision_id;
+	uint32_t hw_internal_rev;
+	uint32_t vram_type;
+	uint32_t vram_width;
+	uint32_t vendor_id;
+	uint32_t adapter_index;
+	uint32_t present;
+	uint32_t num_of_funct_controllers;
+	uint32_t num_of_controllers;
+	uint32_t num_of_connectors;
+	uint32_t num_of_underlays;
+};
+
+struct dsat_display_info {
+	uint32_t display_adapterIndex;
+	uint32_t display_index;
+	uint8_t display_name[DSAT_MAX_REGISTRY_PATH];
+	uint8_t display_manufacturer_name[DSAT_MAX_REGISTRY_PATH];
+	uint32_t display_active_signal;
+	uint32_t display_type;
+	uint32_t display_output_type;
+	uint32_t display_connector;
+	uint32_t display_infoMask;
+	uint32_t display_info_value;
+};
+
+
+/**
+ * DSAT Timing standard used to calculate a timing for a mode
+ */
+enum dsat_timing_standard {
+	DSAT_TIMING_STANDARD_UNDEFINED,
+	DSAT_TIMING_STANDARD_DMT,
+	DSAT_TIMING_STANDARD_GTF,
+	DSAT_TIMING_STANDARD_CVT,
+	DSAT_TIMING_STANDARD_CVT_RB,
+	DSAT_TIMING_STANDARD_CEA770,
+	DSAT_TIMING_STANDARD_CEA861,
+	DSAT_TIMING_STANDARD_HDMI,
+	DSAT_TIMING_STANDARD_TV_NTSC,
+	DSAT_TIMING_STANDARD_TV_NTSC_J,
+	DSAT_TIMING_STANDARD_TV_PAL,
+	DSAT_TIMING_STANDARD_TV_PAL_M,
+	DSAT_TIMING_STANDARD_TV_PAL_CN,
+	DSAT_TIMING_STANDARD_TV_SECAM,
+	DSAT_TIMING_STANDARD_EXPLICIT,
+	/*!< For explicit timings from EDID, VBIOS, etc.*/
+	DSAT_TIMING_STANDARD_USER_OVERRIDE,
+	/*!< For mode timing override by user*/
+	DSAT_TIMING_STANDARD_MAX
+};
+
+enum dsat_aspect_ratio {
+	DSAT_ASPECT_RATIO_NO_DATA,
+	DSAT_ASPECT_RATIO_4_3,
+	DSAT_ASPECT_RATIO_16_9,
+	DSAT_ASPECT_RATIO_FUTURE
+};
+
+enum dsat_display_color_depth {
+	DSAT_DISPLAY_COLOR_DEPTH_UNDEFINED,
+	DSAT_DISPLAY_COLOR_DEPTH_666,
+	DSAT_DISPLAY_COLOR_DEPTH_888,
+	DSAT_DISPLAY_COLOR_DEPTH_101010,
+	DSAT_DISPLAY_COLOR_DEPTH_121212,
+	DSAT_DISPLAY_COLOR_DEPTH_141414,
+	DSAT_DISPLAY_COLOR_DEPTH_161616
+};
+
+enum dsat_pixel_encoding {
+	DSAT_PIXEL_ENCODING_UNDEFINED,
+	DSAT_PIXEL_ENCODING_RGB,
+	DSAT_PIXEL_ENCODING_YCBCR422,
+	DSAT_PIXEL_ENCODING_YCBCR444
+};
+
+enum dsat_timing_3d_format {
+	DSAT_TIMING_3D_FORMAT_NONE,
+	DSAT_TIMING_3D_FORMAT_FRAME_ALTERNATE, /* No stereosync at all*/
+	DSAT_, /* Inband Frame Alternate (DVI/DP)*/
+	DSAT_TIMING_3D_FORMAT_DP_HDMI_INBAND_FA, /* Inband FA to HDMI Frame Pack*/
+	/* for active DP-HDMI dongle*/
+	DSAT_TIMING_3D_FORMAT_SIDEBAND_FA, /* Sideband Frame Alternate (eDP)*/
+	DSAT_TIMING_3D_FORMAT_HW_FRAME_PACKING,
+	DSAT_TIMING_3D_FORMAT_SW_FRAME_PACKING,
+	DSAT_TIMING_3D_FORMAT_ROW_INTERLEAVE,
+	DSAT_TIMING_3D_FORMAT_COLUMN_INTERLEAVE,
+	DSAT_TIMING_3D_FORMAT_PIXEL_INTERLEAVE,
+	DSAT_TIMING_3D_FORMAT_SIDE_BY_SIDE,
+	DSAT_TIMING_3D_FORMAT_TOP_AND_BOTTOM,
+	DSAT_TIMING_3D_FORMAT_SBS_SW_PACKED,
+	/* Side-by-side, packed by application/driver into 2D frame*/
+	DSAT_TIMING_3D_FORMAT_TB_SW_PACKED,
+	/* Top-and-bottom, packed by application/driver into 2D frame*/
+
+	DSAT_TIMING_3D_FORMAT_MAX,
+};
+
+enum dsat_timing_source {
+	DSAT_TIMING_SOURCE_UNDEFINED,
+
+/* explicitly specifed by user, most important*/
+	DSAT_TIMING_SOURCE_USER_FORCED,
+	DSAT_TIMING_SOURCE_USER_OVERRIDE,
+	DSAT_TIMING_SOURCE_CUSTOM,
+	DSAT_TIMING_SOURCE_DALINTERFACE_EXPLICIT,
+
+/* explicitly specified by the display device, more important*/
+	DSAT_TIMING_SOURCE_EDID_CEA_SVD_3D,
+	DSAT_TIMING_SOURCE_EDID_DETAILED,
+	DSAT_TIMING_SOURCE_EDID_ESTABLISHED,
+	DSAT_TIMING_SOURCE_EDID_STANDARD,
+	DSAT_TIMING_SOURCE_EDID_CEA_SVD,
+	DSAT_TIMING_SOURCE_EDID_CVT_3BYTE,
+	DSAT_TIMING_SOURCE_EDID_4BYTE,
+	DSAT_TIMING_SOURCE_VBIOS,
+	DSAT_TIMING_SOURCE_CV,
+	DSAT_TIMING_SOURCE_TV,
+	DSAT_TIMING_SOURCE_HDMI_VIC,
+
+/* implicitly specified by display device, still safe but less important*/
+	DSAT_TIMING_SOURCE_DEFAULT,
+
+/* only used for custom base modes */
+	DSAT_TIMING_SOURCE_CUSTOM_BASE,
+
+/* these timing might not work, least important*/
+	DSAT_TIMING_SOURCE_RANGELIMIT,
+	DSAT_TIMING_SOURCE_OS_FORCED,
+	DSAT_TIMING_SOURCE_DALINTERFACE_IMPLICIT,
+
+/* only used by default mode list*/
+	DSAT_TIMING_SOURCE_BASICMODE,
+};
+
+enum dsat_timing_support_method {
+	DSAT_TIMING_SUPPORT_METHOD_UNDEFINED,
+	DSAT_TIMING_SUPPORT_METHOD_EXPLICIT,
+	DSAT_TIMING_SUPPORT_METHOD_IMPLICIT,
+	DSAT_TIMING_SUPPORT_METHOD_NATIVE
+};
+
+struct dsat_mode_flags {
+	/* note: part of refresh rate flag*/
+	uint32_t INTERLACE:1;
+	/* native display timing*/
+	uint32_t NATIVE:1;
+	/* preferred is the recommended mode, one per display */
+	uint32_t PREFERRED:1;
+	/* true if this mode should use reduced blanking timings
+	 *_not_ related to the Reduced Blanking adjustment*/
+	uint32_t REDUCED_BLANKING:1;
+	/* note: part of refreshrate flag*/
+	uint32_t VIDEO_OPTIMIZED_RATE:1;
+	/* should be reported to upper layers as mode_flags*/
+	uint32_t PACKED_PIXEL_FORMAT:1;
+	/*< preferred view*/
+	uint32_t PREFERRED_VIEW:1;
+	/* this timing should be used only in tiled mode*/
+	uint32_t TILED_MODE:1;
+};
+
+struct dsat_mode_info {
+	uint32_t pixel_width;
+	uint32_t pixel_height;
+	uint32_t field_rate;
+	/* Vertical refresh rate for progressive modes.
+	 * Field rate for interlaced modes.*/
+
+	enum dsat_timing_standard timing_standard;
+	enum dsat_timing_source timing_source;
+	struct dsat_mode_flags flags;
+};
+
+struct dsat_ts_timing_flags {
+	uint32_t INTERLACE:1;
+	uint32_t DOUBLESCAN:1;
+	uint32_t PIXEL_REPETITION:4; /* values 1 to 10 supported*/
+	uint32_t HSYNC_POSITIVE_POLARITY:1; /* when set to 1,
+	it is positive polarity --reversed with dal1 or video bios define*/
+	uint32_t VSYNC_POSITIVE_POLARITY:1; /* when set to 1,
+	it is positive polarity --reversed with dal1 or video bios define*/
+	uint32_t EXCLUSIVE_3D:1; /* if this bit set,
+	timing can be driven in 3D format only
+	and there is no corresponding 2D timing*/
+	uint32_t RIGHT_EYE_3D_POLARITY:1; /* 1 - means right eye polarity
+					(right eye = '1', left eye = '0') */
+	uint32_t SUB_SAMPLE_3D:1; /* 1 - means left/right  images subsampled
+	when mixed into 3D image. 0 - means summation (3D timing is doubled)*/
+	uint32_t USE_IN_3D_VIEW_ONLY:1; /* Do not use this timing in 2D View,
+	because corresponding 2D timing also present in the list*/
+	uint32_t STEREO_3D_PREFERENCE:1; /* Means this is 2D timing
+	and we want to match priority of corresponding 3D timing*/
+	uint32_t YONLY:1;
+
+};
+
+/* TODO to be reworked: similar structures in timing generator
+ *	and hw sequence service*/
+struct dsat_crtc_timing {
+	uint32_t h_total;
+	uint32_t h_border_left;
+	uint32_t h_addressable;
+	uint32_t h_border_right;
+	uint32_t h_front_porch;
+	uint32_t h_sync_width;
+
+	uint32_t v_total;
+	uint32_t v_border_top;
+	uint32_t v_addressable;
+	uint32_t v_border_bottom;
+	uint32_t v_front_porch;
+	uint32_t v_sync_width;
+
+	uint32_t pix_clk_khz;
+
+	uint32_t vic;
+	uint32_t hdmi_vic;
+	enum dsat_timing_standard timing_standard;
+	enum dsat_timing_3d_format timing_3d_format;
+	enum dsat_display_color_depth display_color_depth;
+	enum dsat_pixel_encoding pixel_encoding;
+
+	struct dsat_ts_timing_flags flags;
+};
+
+/**
+ * Combination structure to link a mode with a timing
+ */
+
+struct dsat_mode_timing {
+	struct dsat_mode_info mode_info;
+	struct dsat_crtc_timing crtc_timing;
+};
+
+#define DSAT_PIXEL_CLOCK_MULTIPLIER 1000
+
+
+/* restore default packing  */
+#pragma pack()
+
+#endif /* __AMDGPU_DSAT_STRUCTS__H */
diff --git a/drivers/gpu/drm/amd/dsat/dsat.c b/drivers/gpu/drm/amd/dsat/dsat.c
new file mode 100644
index 0000000..5d8cd2c
--- /dev/null
+++ b/drivers/gpu/drm/amd/dsat/dsat.c
@@ -0,0 +1,846 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* Do implementation of DSAT test harness functions here
+ * Call through amdgpu_dm_dsat (which acquires dm lock) to
+ * dal/interface/dsat_services which implements calls on dal end for any
+ * missing DSAT specific code*/
+
+/* Declarations for dal interface accessors */
+
+#include <linux/firmware.h>
+#include <linux/module.h>
+
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/amdgpu_drm.h>
+#include "amdgpu_dsat_structs.h"
+
+#include "dal_services_types.h"
+#include "dal_services.h"
+
+#include "include/dal_interface.h"
+#include "include/adapter_service_interface.h"
+#include "include/timing_service_interface.h"
+#include "include/topology_mgr_interface.h"
+#include "include/timing_list_query_interface.h"
+#include "include/display_service_interface.h"
+#include "include/set_mode_interface.h"
+#include "include/display_path_interface.h"
+#include "include/controller_interface.h"
+#include "include/hw_sequencer_interface.h"
+#include "include/logger_interface.h"
+#include "include/adjustment_interface.h"
+
+#include "dsat.h"
+
+struct topology_mgr *dal_get_tm(struct dal *dal);
+
+struct adapter_service *dal_get_as(struct dal *dal);
+
+struct timing_service *dal_get_ts(struct dal *dal);
+
+struct hw_sequencer *dal_get_hws(struct dal *dal);
+
+struct display_service *dal_get_ds(struct dal *dal);
+
+struct mode_manager *dal_get_mm(struct dal *dal);
+
+struct dal_context *dal_get_dal_ctx(struct dal *dal);
+
+struct dal_init_data *dal_get_init_data(struct dal *dal);
+
+/*****************************
+ ** FEATURE IMPLEMENTATIONS **
+ *****************************/
+
+void dsat_test_fill_data(struct amdgpu_display_manager *dm,
+		struct dsat_test_in *test_in, struct dsat_test_out *test_out)
+{
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	test_out->value1 = test_in->value1;
+	test_out->value2 = test_in->value2;
+	test_out->value3 = test_in->value3;
+	test_out->value4 = 9977;
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+/***************** Calls used to get device configuration *******/
+uint32_t dsat_get_adapters_count(struct amdgpu_display_manager *dm)
+{
+	return 1;
+}
+
+void dsat_get_adapters_info(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		struct dsat_adapter_info *adapter_info_data)
+{
+	struct adapter_service *as = dal_get_as(dm->dal);
+	struct dal_init_data *init = dal_get_init_data(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	memset(adapter_info_data, 0, sizeof(struct dsat_adapter_info));
+	adapter_info_data->bus_number = init->bdf_info.BUS_NUMBER;
+	adapter_info_data->device_number = init->bdf_info.DEVICE_NUMBER;
+	adapter_info_data->function_number = init->bdf_info.FUNCTION_NUMBER;
+	adapter_info_data->chip_family = init->asic_id.chip_family;
+	adapter_info_data->chip_id = init->asic_id.chip_id;
+	adapter_info_data->pci_revision_id = init->asic_id.pci_revision_id;
+	adapter_info_data->hw_internal_rev = init->asic_id.hw_internal_rev;
+	adapter_info_data->vram_type = init->asic_id.vram_type;
+	adapter_info_data->vram_width = init->asic_id.vram_width;
+	adapter_info_data->vendor_id = 1002;
+	adapter_info_data->adapter_index = 0;
+	adapter_info_data->present = 1;
+	adapter_info_data->num_of_funct_controllers =
+			dal_get_controllers_number(dm->dal);
+	adapter_info_data->num_of_controllers =
+			dal_adapter_service_get_controllers_num(as);
+	adapter_info_data->num_of_connectors =
+			dal_adapter_service_get_connectors_num(as);
+	adapter_info_data->num_of_underlays =
+			dal_adapter_service_get_num_of_underlays(as);
+
+	amdgpu_dm_release_dal_lock(dm);
+
+}
+
+uint32_t dsat_get_displays_count(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index)
+{
+	struct topology_mgr *tm;
+	uint32_t number_of_displays;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	tm = dal_get_tm(dm->dal);
+	number_of_displays = dal_tm_get_num_display_paths(tm, true);
+
+	amdgpu_dm_release_dal_lock(dm);
+	return number_of_displays;
+}
+
+uint32_t dsat_get_displays_info(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t buffer_size,
+		struct dsat_display_info *display_info_data)
+{
+	struct topology_mgr *tm;
+	uint32_t ind;
+	struct display_path *display_path;
+	uint32_t display_paths_num;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	tm = dal_get_tm(dm->dal);
+	display_paths_num = dal_tm_get_num_display_paths(tm, true);
+	if (buffer_size <
+		sizeof(struct dsat_display_info) * display_paths_num) {
+
+		amdgpu_dm_release_dal_lock(dm);
+		return 1;
+	}
+	memset(display_info_data, 0,
+			sizeof(struct dsat_display_info) * display_paths_num);
+
+	for (ind = 0; ind < display_paths_num; ind++) {
+		display_path = dal_tm_display_index_to_display_path(tm, ind);
+		display_info_data[ind].display_index =
+				dal_display_path_get_display_index(
+						display_path);
+		display_info_data[ind].display_adapterIndex = adapter_index;
+		display_info_data[ind].display_active_signal =
+				dal_display_path_get_active_signal(display_path,
+					display_info_data[ind].display_index);
+		if (dal_display_path_is_target_connected(display_path)) {
+			display_info_data[ind].display_info_value |=
+			DSAT_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED;
+			display_info_data[ind].display_output_type =
+				(int32_t) dal_display_path_get_query_signal(
+							display_path,
+							SINK_LINK_INDEX);
+			if (dal_display_path_is_target_unblanked(
+					display_path)) {
+				display_info_data[ind].display_info_value |=
+				DSAT_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
+			}
+		}
+
+	}
+	amdgpu_dm_release_dal_lock(dm);
+	return 0;
+
+}
+/***************** Calls used to test for test and validation  *******/
+
+/***************** Calls used to get driver log **********************/
+uint32_t dsat_logger_get_buffer_size(struct amdgpu_display_manager *dm)
+{
+	struct dal_context *dal_ctx;
+	uint32_t log_buffer_size;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	log_buffer_size = dal_logger_get_buffer_size(dal_ctx->logger);
+	amdgpu_dm_release_dal_lock(dm);
+	return log_buffer_size;
+}
+
+uint32_t dsat_logger_set_buffer_size(struct amdgpu_display_manager *dm,
+		uint32_t buffer_size)
+{
+	struct dal_context *dal_ctx;
+	uint32_t new_log_buffer_size;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	new_log_buffer_size = dal_logger_set_buffer_size(dal_ctx->logger,
+			buffer_size);
+	amdgpu_dm_release_dal_lock(dm);
+
+	return new_log_buffer_size;
+}
+
+uint32_t dsat_logger_get_flags(struct amdgpu_display_manager *dm)
+{
+	struct dal_context *dal_ctx;
+	union logger_flags flags_data;
+	union dsat_logger_flags dsat_flags_data;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	flags_data.value = dal_logger_get_flags(dal_ctx->logger);
+	dsat_flags_data.bits.ENABLE_CONSOLE = flags_data.bits.ENABLE_CONSOLE;
+	dsat_flags_data.bits.ENABLE_BUFFER = flags_data.bits.ENABLE_BUFFER;
+
+	amdgpu_dm_release_dal_lock(dm);
+	return dsat_flags_data.value;
+
+}
+
+void dsat_logger_set_flags(struct amdgpu_display_manager *dm, uint32_t flags)
+{
+	struct dal_context *dal_ctx;
+	union logger_flags flags_data;
+	union dsat_logger_flags dsat_flags_data;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+	dsat_flags_data.value = flags;
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	flags_data.bits.ENABLE_CONSOLE = dsat_flags_data.bits.ENABLE_CONSOLE;
+	flags_data.bits.ENABLE_BUFFER = dsat_flags_data.bits.ENABLE_BUFFER;
+	dal_logger_set_flags(dal_ctx->logger, flags_data);
+
+	amdgpu_dm_release_dal_lock(dm);
+
+}
+
+uint32_t dsat_logger_get_mask(struct amdgpu_display_manager *dm,
+		uint32_t lvl_major, uint32_t lvl_minor)
+{
+	struct dal_context *dal_ctx;
+	uint32_t result = 0;
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	result = dal_logger_get_mask(dal_ctx->logger, lvl_major, lvl_minor);
+	amdgpu_dm_release_dal_lock(dm);
+	return result;
+}
+
+uint32_t dsat_logger_set_mask(struct amdgpu_display_manager *dm,
+		uint32_t lvl_major, uint32_t lvl_minor)
+{
+	struct dal_context *dal_ctx;
+	uint32_t result = 0;
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	result = dal_logger_set_mask(dal_ctx->logger, lvl_major, lvl_minor);
+	amdgpu_dm_release_dal_lock(dm);
+	return result;
+}
+
+uint32_t dsat_logger_get_masks(struct amdgpu_display_manager *dm,
+		uint32_t lvl_major)
+{
+	struct dal_context *dal_ctx;
+	uint32_t result = 0;
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	result = dal_logger_get_masks(dal_ctx->logger, lvl_major);
+
+	amdgpu_dm_release_dal_lock(dm);
+	return result;
+}
+
+void dsat_logger_set_masks(struct amdgpu_display_manager *dm,
+		uint32_t lvl_major, uint32_t mask)
+{
+	struct dal_context *dal_ctx;
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_logger_set_masks(dal_ctx->logger, lvl_major, mask);
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+uint32_t dsat_logger_unset_mask(struct amdgpu_display_manager *dm,
+		uint32_t lvl_major, uint32_t lvl_minor)
+{
+	struct dal_context *dal_ctx;
+	uint32_t result = 0;
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	result = dal_logger_unset_mask(dal_ctx->logger, lvl_major, lvl_minor);
+
+	amdgpu_dm_release_dal_lock(dm);
+	return result;
+}
+
+uint32_t dsat_logger_read(struct amdgpu_display_manager *dm,
+		uint32_t output_buffer_size, /* <[in] */
+		char *output_buffer, /* >[out] */
+		uint32_t *bytes_read, /* >[out] */
+		bool single_line)
+{
+	struct dal_context *dal_ctx;
+	uint32_t bytes_remaining = 0;
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	bytes_remaining = dal_logger_read(dal_ctx->logger, output_buffer_size,
+			output_buffer, bytes_read, single_line);
+
+	amdgpu_dm_release_dal_lock(dm);
+	return bytes_remaining;
+
+}
+
+uint32_t dsat_logger_enum_major_info(struct amdgpu_display_manager *dm,
+		void *info, uint32_t enum_index)
+{
+	struct dal_context *dal_ctx;
+	const struct log_major_info* major_info = NULL;
+	struct dsat_logger_major_info *major_info_out =
+		(struct dsat_logger_major_info *)info;
+	uint32_t result = 0;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	major_info =
+		dal_logger_enum_log_major_info(dal_ctx->logger, enum_index);
+	if (major_info != NULL) {
+		major_info_out->major = (uint32_t)major_info->major;
+		memcpy(major_info_out->major_name,
+			major_info->major_name, DSAT_MAX_MAJOR_NAME_LEN);
+		result = sizeof(struct dsat_logger_major_info);
+	}
+	amdgpu_dm_release_dal_lock(dm);
+	return result;
+}
+
+uint32_t dsat_logger_enum_minor_info(struct amdgpu_display_manager *dm,
+		void *info, uint32_t major, uint32_t enum_index)
+{
+	struct dal_context *dal_ctx;
+	uint32_t result = 0;
+	enum log_major enum_major;
+	const struct log_minor_info* minor_info = NULL;
+	struct dsat_logger_minor_info *minor_info_out =
+		(struct dsat_logger_minor_info *)info;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	enum_major = (enum log_major) major;
+	minor_info =
+		dal_logger_enum_log_minor_info(dal_ctx->logger, major,
+				enum_index);
+
+	if (minor_info != NULL) {
+		minor_info_out->minor = (uint32_t)minor_info->minor;
+		memcpy(minor_info_out->minor_name,
+				minor_info->minor_name,
+				DSAT_MAX_MINOR_NAME_LEN);
+		result = sizeof(struct dsat_logger_minor_info);
+	}
+
+	amdgpu_dm_release_dal_lock(dm);
+	return result;
+
+}
+
+/***************** Calls used to read/write HW reg. *******/
+
+uint32_t dsat_read_hw_reg(struct amdgpu_display_manager *dm, uint32_t address)
+{
+	struct dal_context *dal_ctx;
+	uint32_t value = 0;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	value = dal_read_reg(dal_ctx, address);
+	amdgpu_dm_release_dal_lock(dm);
+	return value;
+}
+
+void dsat_write_hw_reg(struct amdgpu_display_manager *dm, uint32_t address,
+		uint32_t value)
+{
+	struct dal_context *dal_ctx;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	dal_ctx = dal_get_dal_ctx(dm->dal);
+	dal_write_reg(dal_ctx, address, value);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+uint32_t dsat_display_get_edid(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		uint32_t *buffer_size, uint8_t *edid_data)
+{
+	struct topology_mgr *tm;
+	uint32_t error = 0;
+	uint32_t buff_size_temp = 0;
+	const uint8_t *edid = NULL;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	tm = dal_get_tm(dm->dal);
+
+	edid = dal_get_display_edid(dm->dal, display_index,
+			&buff_size_temp);
+
+	if ((edid != NULL) && (*buffer_size >= buff_size_temp)) {
+		memcpy(edid_data, edid, buff_size_temp);
+		*buffer_size = buff_size_temp;
+		error = 0;
+
+	} else {
+		*buffer_size = 0;
+		error = 1;
+	}
+	amdgpu_dm_release_dal_lock(dm);
+	return error;
+}
+
+void dsat_override_edid(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		struct dsat_display_edid_data *edid_data)
+{
+	struct topology_mgr *tm;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	tm = dal_get_tm(dm->dal);
+
+	dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+			LOG_MINOR_DSAT_EDID_OVERRIDE,
+			"%s(): adapter_index: %d, display_index: %d\n",
+			__func__, adapter_index, display_index);
+
+	if (dal_tm_update_display_edid(tm, display_index, edid_data->data,
+			edid_data->data_size)) {
+
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_EDID_OVERRIDE,
+				"%s(): TM successfully  updated EDID.\n",
+				__func__);
+
+	} else {
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_EDID_OVERRIDE,
+				"%s(): TM failed to update EDID!\n", __func__);
+	}
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_get_adjustment_info(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		enum adjustment_id adjust_id,
+		struct adjustment_info *adjust_info)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+	if (!dal_ds_dispatch_get_adjustment_info(ds_dispatch, display_index,
+			adjust_id, adjust_info)) {
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set saturation is successfully.\n",
+				__func__);
+	} else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set saturation is failed.\n", __func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_set_saturation(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index, uint32_t value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+
+	if (!dal_ds_dispatch_set_adjustment(ds_dispatch, display_index,
+			ADJ_ID_SATURATION, (int32_t) value))
+
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set saturation is successfully.\n",
+				__func__);
+	else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set saturation is failed.\n", __func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_set_backlight(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index, uint32_t value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+
+	if (!dal_ds_dispatch_set_adjustment(ds_dispatch, display_index,
+			ADJ_ID_BACKLIGHT, (int32_t) value))
+
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set backlight is successfully.\n",
+				__func__);
+	else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set backlight is failed.\n", __func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_set_bit_depth_reduction(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index, uint32_t value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+
+	if (!dal_ds_dispatch_set_adjustment(ds_dispatch, display_index,
+			ADJ_ID_BIT_DEPTH_REDUCTION, (int32_t) value))
+
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set bit depth reduction is successfully.\n",
+				__func__);
+	else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set bit depth reduction is failed.\n",
+				__func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_set_underscan(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index, uint32_t value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+
+	if (!dal_ds_dispatch_set_adjustment(ds_dispatch, display_index,
+			ADJ_ID_UNDERSCAN, (int32_t) value))
+
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set underscan is successfully.\n",
+				__func__);
+	else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_SET_ADJUSTMENTS,
+				"%s(): Set underscan is failed.\n", __func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_get_saturation(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		struct dsat_adjustment_data *adj_value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct display_path *disp_path;
+	struct topology_mgr *tm;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+	int32_t value;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	tm = dal_get_tm(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+	disp_path = dal_tm_display_index_to_display_path(tm, display_index);
+
+	if (!dal_ds_dispatch_get_adjustment_value(ds_dispatch, disp_path,
+			ADJ_ID_SATURATION, true, &value)) {
+
+		adj_value->value = value;
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get saturation value is successfully.\n",
+				__func__);
+	} else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get saturation value is failed.\n",
+				__func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_get_backlight(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		struct dsat_adjustment_data *adj_value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct display_path *disp_path;
+	struct topology_mgr *tm;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+	int32_t value;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	tm = dal_get_tm(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+	disp_path = dal_tm_display_index_to_display_path(tm, display_index);
+
+	if (!dal_ds_dispatch_get_adjustment_value(ds_dispatch, disp_path,
+			ADJ_ID_BACKLIGHT, true, &value)) {
+
+		adj_value->value = value;
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get backlight value is successfully.\n",
+				__func__);
+	} else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get backlight value is failed.\n",
+				__func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_get_bit_depth_reduction(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		struct dsat_adjustment_data *adj_value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct display_path *disp_path;
+	struct topology_mgr *tm;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+	int32_t value;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	tm = dal_get_tm(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+	disp_path = dal_tm_display_index_to_display_path(tm, display_index);
+
+	if (!dal_ds_dispatch_get_adjustment_value(ds_dispatch, disp_path,
+			ADJ_ID_BIT_DEPTH_REDUCTION, true, &value)) {
+
+		adj_value->value = value;
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get bit depth reduction value is successfully.\n",
+				__func__);
+	} else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get bit depth reduction value is failed.\n",
+				__func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+void dsat_get_underscan(struct amdgpu_display_manager *dm,
+		uint32_t adapter_index, uint32_t display_index,
+		struct dsat_adjustment_data *adj_value)
+{
+	struct display_service *ds;
+	struct ds_dispatch *ds_dispatch;
+	struct display_path *disp_path;
+	struct topology_mgr *tm;
+	struct dal_context *dal_ctx = dal_get_dal_ctx(dm->dal);
+	int32_t value;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	ds = dal_get_ds(dm->dal);
+	tm = dal_get_tm(dm->dal);
+	ds_dispatch = dal_display_service_get_set_mode_interface(ds);
+	disp_path = dal_tm_display_index_to_display_path(tm, display_index);
+
+	if (!dal_ds_dispatch_get_adjustment_value(ds_dispatch, disp_path,
+			ADJ_ID_UNDERSCAN, true, &value)) {
+
+		adj_value->value = value;
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get underscan value is successfully.\n",
+				__func__);
+	} else
+		dal_logger_write(dal_ctx->logger, LOG_MAJOR_DSAT,
+				LOG_MINOR_DSAT_GET_ADJUSTMENTS,
+				"%s(): Get underscan value is failed.\n",
+				__func__);
+
+	amdgpu_dm_release_dal_lock(dm);
+}
+
+
+uint32_t dsat_display_mode_timing_get_count(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index)
+{
+	uint32_t mode_timing_nums = 0;
+	struct dal_timing_list_query *tlsq;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+	tlsq = dal_create_timing_list_query(dm->dal, display_index);
+	if (tlsq) {
+		mode_timing_nums=
+			dal_timing_list_query_get_mode_timing_count(tlsq);
+
+		dal_timing_list_query_destroy(&tlsq);
+	}
+
+	amdgpu_dm_release_dal_lock(dm);
+	return mode_timing_nums;
+}
+static void translate_mode_timing_to_dsat(const struct mode_timing *mt_src,
+		struct dsat_mode_timing *mode_timing)
+{
+	/* ToDo: change to real translation. */
+	memcpy(mode_timing, mt_src, sizeof(struct dsat_mode_timing));
+}
+
+bool dsat_display_mode_timing_get_list(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index,
+		uint32_t buffer_size,
+		struct dsat_mode_timing *mode_timing)
+{
+	uint32_t mt_nums = 0;
+	uint32_t idx = 0;
+	struct dal_timing_list_query *tlsq;
+	struct mode_timing *mt_dst = mode_timing;
+	bool ret_val = false;
+
+	amdgpu_dm_acquire_dal_lock(dm);
+
+
+	tlsq = dal_create_timing_list_query(dm->dal, display_index);
+	if (tlsq) {
+		mt_nums = dal_timing_list_query_get_mode_timing_count(tlsq);
+
+		if (buffer_size < mt_nums * sizeof(struct dsat_mode_timing)) {
+			amdgpu_dm_release_dal_lock(dm);
+			return false;
+		}
+
+		memset(mode_timing, 0, mt_nums * sizeof(struct dsat_mode_timing));
+
+		/*make sure user mode buffer size is not less than kernel mode*/
+		for (idx = 0; idx < mt_nums; idx++) {
+			const struct mode_timing *mt_temp =
+				dal_timing_list_query_get_mode_timing_at_index(
+					tlsq, idx);
+
+			translate_mode_timing_to_dsat(mt_temp, &mode_timing[idx]);
+		}
+
+		dal_timing_list_query_destroy(&tlsq);
+		ret_val = true;
+	}
+
+	amdgpu_dm_release_dal_lock(dm);
+	return ret_val;
+}
diff --git a/drivers/gpu/drm/amd/dsat/dsat.h b/drivers/gpu/drm/amd/dsat/dsat.h
new file mode 100644
index 0000000..8846f4f
--- /dev/null
+++ b/drivers/gpu/drm/amd/dsat/dsat.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __DSAT__H
+#define __DSAT__H
+
+#include <linux/types.h>
+
+#include "amdgpu_dm.h"
+#include "logger_interface.h"
+
+void dsat_test_fill_data(struct amdgpu_display_manager *dm,
+		struct dsat_test_in *test_in,
+		struct dsat_test_out *test_out);
+
+uint32_t dsat_logger_get_buffer_size(
+		struct amdgpu_display_manager *dm);
+
+uint32_t dsat_logger_set_buffer_size(
+		struct amdgpu_display_manager *dm,
+		uint32_t buffer_size);
+
+uint32_t dsat_logger_get_flags(struct amdgpu_display_manager *dm);
+
+void dsat_logger_set_flags(
+		struct amdgpu_display_manager *dm,
+		uint32_t flags);
+
+uint32_t dsat_logger_get_mask(
+		struct amdgpu_display_manager *dm,
+		uint32_t lvl_major,
+		uint32_t lvl_minor);
+
+uint32_t dsat_logger_set_mask(
+		struct amdgpu_display_manager *dm,
+		uint32_t lvl_major,
+		uint32_t lvl_minor);
+
+uint32_t dsat_logger_get_masks(
+		struct amdgpu_display_manager *dm,
+		uint32_t lvl_major);
+
+void dsat_logger_set_masks(
+		struct amdgpu_display_manager *dm,
+		uint32_t lvl_major,
+		uint32_t mask);
+
+uint32_t dsat_logger_unset_mask(
+		struct amdgpu_display_manager *dm,
+		uint32_t lvl_major,
+		uint32_t lvl_minor);
+
+uint32_t dsat_logger_read(struct amdgpu_display_manager *dm,
+		uint32_t output_buffer_size, /* <[in] */
+		char *output_buffer, /* >[out] */
+		uint32_t *bytes_read, /* >[out] */
+		bool single_line);
+
+uint32_t dsat_logger_enum_major_info(
+		struct amdgpu_display_manager *dm,
+		void *info,
+		uint32_t enum_index);
+
+uint32_t dsat_logger_enum_minor_info(
+		struct amdgpu_display_manager *dm,
+		void *info,
+		uint32_t major,
+		uint32_t enum_index);
+
+uint32_t dsat_read_hw_reg(
+		struct amdgpu_display_manager *dm,
+		uint32_t address);
+
+void dsat_write_hw_reg(
+		struct amdgpu_display_manager *dm,
+		uint32_t address,
+		uint32_t value);
+
+uint32_t dsat_get_adapters_count(struct amdgpu_display_manager *dm);
+
+void dsat_get_adapters_info(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		struct dsat_adapter_info *adapter_info_data);
+
+uint32_t dsat_get_displays_count(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index);
+
+uint32_t dsat_get_displays_info(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t buffer_size,
+		struct dsat_display_info *display_info_data);
+
+uint32_t dsat_display_get_edid(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index,
+		uint32_t *buffer_size,
+		uint8_t *edid_data);
+
+void dsat_override_edid(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index,
+		struct dsat_display_edid_data *edid_data);
+
+void dsat_get_adjustment_info(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index,
+		enum adjustment_id adjust_id,
+		struct adjustment_info *adjust_info);
+
+void dsat_set_saturation(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	uint32_t value);
+
+void dsat_set_backlight(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	uint32_t value);
+
+void dsat_set_bit_depth_reduction(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	uint32_t value);
+
+void dsat_set_underscan(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	uint32_t value);
+
+void dsat_get_saturation(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	struct dsat_adjustment_data *adj_value);
+
+void dsat_get_backlight(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	struct dsat_adjustment_data *adj_value);
+
+void dsat_get_bit_depth_reduction(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	struct dsat_adjustment_data *adj_value);
+
+void dsat_get_underscan(
+	struct amdgpu_display_manager *dm,
+	uint32_t adapter_index,
+	uint32_t display_index,
+	struct dsat_adjustment_data *adj_value);
+
+uint32_t dsat_display_mode_timing_get_count(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index);
+
+bool dsat_display_mode_timing_get_list(
+		struct amdgpu_display_manager *dm,
+		uint32_t adapter_index,
+		uint32_t display_index,
+		uint32_t buffer_size,
+		struct dsat_mode_timing *mode_timing);
+
+#endif /* __DSAT__H */
-- 
1.9.1

