From 2958cca3c21976e6165e44f3ddd6f14926b08432 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Thu, 1 Sep 2016 15:46:57 -0400
Subject: [PATCH 0956/1722] drm/amd/dal: refined surface update routine

Change-Id: Ice30e75335252edf036bab647d62afec589546ab
Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c | 78 +++++++++++++++++-------------------
 1 file changed, 36 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index b0ff7b1..fc002c5 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -1347,9 +1347,23 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 		int surface_count, struct dc_target *dc_target)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct validate_context *context = core_dc->current_context;
+	struct validate_context *context = core_dc->temp_flip_context;
 	int i;
 
+	*context = *core_dc->current_context;
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+
+		if (cur_pipe->top_pipe)
+			cur_pipe->top_pipe =
+				&context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+
+		if (cur_pipe->bottom_pipe)
+			cur_pipe->bottom_pipe =
+				&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+	}
+
 	if (dc_target) {
 		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
 		struct core_target *target = DC_TARGET_TO_CORE(dc_target);
@@ -1367,37 +1381,12 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 		for (i = 0 ; i < surface_count; i++) {
 			new_surfaces[i] = updates[i].surface;
 		}
-		context = core_dc->temp_flip_context;
-		*context = *core_dc->current_context;
-
-		for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
-			struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
-
-			if (cur_pipe->top_pipe)
-				cur_pipe->top_pipe =
-					&context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
-
-			if (cur_pipe->bottom_pipe)
-				cur_pipe->bottom_pipe =
-					&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
-		}
 
 		if (!resource_attach_surfaces_to_context(
 				new_surfaces, surface_count, dc_target, context)) {
 			BREAK_TO_DEBUGGER();
 			return;
 		}
-
-		for (i = 0; i < surface_count; i++) {
-			struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
-			struct pipe_ctx *pipe_ctx = find_pipe_ctx_by_surface(context, surface);
-
-			core_dc->hwss.pipe_control_lock(
-						core_dc->ctx,
-						pipe_ctx->pipe_idx,
-						PIPE_LOCK_CONTROL_SURFACE,
-						true);
-		}
 	}
 
 	for (i = 0; i < surface_count; i++) {
@@ -1409,6 +1398,13 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			return;
 		}
 
+		if (updates[i].flip_addr)
+			core_dc->hwss.pipe_control_lock(
+						core_dc->ctx,
+						pipe_ctx->pipe_idx,
+						PIPE_LOCK_CONTROL_SURFACE,
+						true);
+
 		if (updates[i].plane_info || updates[i].scaling_info) {
 
 			if (updates[i].flip_addr) {
@@ -1440,7 +1436,6 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			}
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 
-			core_dc->hwss.apply_ctx_to_surface(core_dc, context);
 
 		} else if (updates[i].flip_addr) {
 			surface->public.address = updates[i].flip_addr->address;
@@ -1453,24 +1448,23 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			core_dc->hwss.prepare_pipe_for_context(core_dc, pipe_ctx, context);
 	}
 
-	if (dc_target) {
-
-		for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+	core_dc->hwss.apply_ctx_to_surface(core_dc, context);
 
-			core_dc->hwss.pipe_control_lock(
-								core_dc->ctx,
-								pipe_ctx->pipe_idx,
-								PIPE_LOCK_CONTROL_GRAPHICS |
-								PIPE_LOCK_CONTROL_SCL |
-								PIPE_LOCK_CONTROL_BLENDER |
-								PIPE_LOCK_CONTROL_SURFACE,
-								false);
-		}
+	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		core_dc->temp_flip_context = core_dc->current_context;
-		core_dc->current_context = context;
+		core_dc->hwss.pipe_control_lock(
+					core_dc->ctx,
+					pipe_ctx->pipe_idx,
+					PIPE_LOCK_CONTROL_GRAPHICS |
+					PIPE_LOCK_CONTROL_SCL |
+					PIPE_LOCK_CONTROL_BLENDER |
+					PIPE_LOCK_CONTROL_SURFACE,
+					false);
 	}
+
+	core_dc->temp_flip_context = core_dc->current_context;
+	core_dc->current_context = context;
 }
 
 uint8_t dc_get_current_target_count(const struct dc *dc)
-- 
2.7.4

