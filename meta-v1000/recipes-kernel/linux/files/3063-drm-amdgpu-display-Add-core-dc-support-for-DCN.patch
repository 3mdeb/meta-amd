From b69c6b23e2108bf34e470584ea181216d09ae82a Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Mon, 8 May 2017 15:19:06 -0400
Subject: [PATCH 3063/3082] drm/amdgpu/display: Add core dc support for DCN

Core display support for DCN.

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/display/dc/dcn10/Makefile      |   10 +
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  | 1866 ++++++++++++++++++++
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h  |   38 +
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c   |  883 +++++++++
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h   |  549 ++++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c | 1102 ++++++++++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h |  553 ++++++
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c   |  376 ++++
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.h   |  135 ++
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c   |  801 +++++++++
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.h   |  622 +++++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  | 1475 ++++++++++++++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.h  |   47 +
 .../amd/display/dc/dcn10/dcn10_timing_generator.c  | 1202 +++++++++++++
 .../amd/display/dc/dcn10/dcn10_timing_generator.h  |  335 ++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_transform.c | 1057 +++++++++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_transform.h |  416 +++++
 17 files changed, 11467 insertions(+)
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/Makefile
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.c
 create mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.h

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/Makefile b/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
new file mode 100644
index 0000000..2c43ad7
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for DCN.
+
+DCN10 = dcn10_resource.o dcn10_ipp.o dcn10_hw_sequencer.o \
+		dcn10_transform.o dcn10_opp.o dcn10_timing_generator.o \
+		dcn10_mem_input.o dcn10_mpc.o
+
+AMD_DAL_DCN10 = $(addprefix $(AMDDALPATH)/dc/dcn10/,$(DCN10))
+
+AMD_DISPLAY_FILES += $(AMD_DAL_DCN10)
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
new file mode 100644
index 0000000..fb4eb43
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -0,0 +1,1866 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dc.h"
+#include "core_dc.h"
+#include "core_types.h"
+#include "core_status.h"
+#include "resource.h"
+#include "hw_sequencer.h"
+#include "dcn10_hw_sequencer.h"
+#include "dce110/dce110_hw_sequencer.h"
+#include "abm.h"
+
+#include "dcn10/dcn10_transform.h"
+#include "dcn10/dcn10_mpc.h"
+#include "dcn10/dcn10_timing_generator.h"
+
+#include "mem_input.h"
+#include "timing_generator.h"
+#include "opp.h"
+#include "ipp.h"
+
+#include "dc_bios_types.h"
+
+#include "raven1/DCN/dcn_1_0_offset.h"
+#include "raven1/DCN/dcn_1_0_sh_mask.h"
+#include "vega10/soc15ip.h"
+
+#include "custom_float.h"
+
+
+struct dcn10_hwseq_reg_offsets {
+	uint32_t dchubp;
+	uint32_t dpp;
+	uint32_t otg;
+	uint32_t vtg;
+	uint32_t fmt;
+};
+
+/* TODO: move to resource */
+static const struct dcn10_hwseq_reg_offsets reg_offsets[] = {
+	{
+		.dchubp = (mmHUBP0_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM0_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG0_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG0_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT0_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	},
+	{
+		.dchubp = (mmHUBP1_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM1_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG1_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG1_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT1_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	},
+	{
+		.dchubp = (mmHUBP2_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM2_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG2_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG2_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT2_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	},
+	{
+		.dchubp = (mmHUBP3_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM3_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG3_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG3_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT3_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	}
+};
+
+#define HWSEQ_REG_UPDATE_N(reg_name, n, ...)	\
+		generic_reg_update_soc15(ctx, inst_offset, reg_name, n, __VA_ARGS__)
+
+#define HWSEQ_REG_SET_N(reg_name, n, ...)	\
+		generic_reg_set_soc15(ctx, inst_offset, reg_name, n, __VA_ARGS__)
+
+#define HWSEQ_REG_UPDATE(reg, field, val)	\
+		HWSEQ_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
+
+#define HWSEQ_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
+		HWSEQ_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
+
+#define HWSEQ_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
+		HWSEQ_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
+
+
+#define HWSEQ_REG_SET(reg, field, val)	\
+		HWSEQ_REG_SET_N(reg, 1, FD(reg##__##field), val)
+
+/* TODO should be moved to OTG */
+static void lock_otg_master_update(
+	struct dc_context *ctx,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[inst].otg;
+
+	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_CONTROL0,
+			OTG_MASTER_UPDATE_LOCK_SEL, inst);
+
+	/* unlock master locker */
+	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
+			OTG_MASTER_UPDATE_LOCK, 1);
+
+	/* wait for unlock happens */
+	if (!wait_reg(ctx, inst_offset, OTG0_OTG_MASTER_UPDATE_LOCK, UPDATE_LOCK_STATUS, 1))
+			BREAK_TO_DEBUGGER();
+
+}
+
+static bool unlock_master_tg_and_wait(
+	struct dc_context *ctx,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[inst].otg;
+
+	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_SYNC_STATUS,
+			VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
+	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK, OTG_MASTER_UPDATE_LOCK, 0);
+
+	if (!wait_reg(ctx, inst_offset, OTG0_OTG_GLOBAL_SYNC_STATUS, VUPDATE_NO_LOCK_EVENT_OCCURRED, 1)) {
+		dm_logger_write(ctx->logger, LOG_ERROR,
+				"wait for VUPDATE_NO_LOCK_EVENT_OCCURRED failed\n");
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+	return true;
+}
+
+/* TODO: should be  moved to OTG ? */
+static void unlock_otg_master(
+	struct dc_context *ctx,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[inst].otg;
+
+	/* unlock master locker */
+	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
+			OTG_MASTER_UPDATE_LOCK, 0);
+}
+
+
+static void wait_no_outstanding_request(
+	struct dc_context *ctx,
+	uint8_t plane_id)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	if (!wait_reg(ctx, inst_offset, HUBP0_DCHUBP_CNTL, HUBP_NO_OUTSTANDING_REQ, 1))
+				BREAK_TO_DEBUGGER();
+}
+
+static void disable_clocks(
+	struct dc_context *ctx,
+	uint8_t plane_id)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	generic_reg_update_soc15(ctx, inst_offset, HUBP0_HUBP_CLK_CNTL, 1,
+			FD(HUBP0_HUBP_CLK_CNTL__HUBP_CLOCK_ENABLE), 0);
+
+	inst_offset = reg_offsets[plane_id].dpp;
+	generic_reg_update_soc15(ctx, inst_offset, DPP_TOP0_DPP_CONTROL, 1,
+				FD(DPP_TOP0_DPP_CONTROL__DPP_CLOCK_ENABLE), 0);
+}
+
+/* TODO: This is one time program during system boot up,
+ * this should be done within BIOS or CAIL
+ */
+static void dchubp_map_fb_to_mc(struct dc_context *ctx)
+{
+	/* TODO: do not know where to program
+	 * DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB
+	 */
+	/*
+	 * TODO: For real ASIC, FB_OFFSET may be need change to the same value
+	 * as FB_BASE. Need re-visit this for real ASIC.
+	 */
+	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_BASE, 0, 0x80);
+	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_OFFSET, 0, 0);
+	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_TOP, 0, 0xFF);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_CFG0, 7,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_DATA_RESPONSE_STATUS_CLEAR), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_REQ_CREDIT_ERROR_CLEAR), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_FLUSH_REQ_CREDIT_EN), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_REQ_CREDIT_EN), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_PORT_CONTROL), 1,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_UNIT_ID_BITMASK), 0xd3,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_CREDIT_DISCONNECT_DELAY), 0xc);
+
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_CFG1, 4,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_INSIDE_FB_IO), 0,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_INSIDE_FB_VC), 6,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_OUTSIDE_FB_IO), 1,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_OUTSIDE_FB_VC), 6);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_FB_BASE, 1,
+			FD(DCHUBBUB_SDPIF_FB_BASE__SDPIF_FB_BASE), 0x000080);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_FB_TOP, 1,
+			FD(DCHUBBUB_SDPIF_FB_TOP__SDPIF_FB_TOP), 0x0000ff);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_BOT, 1,
+			FD(DCHUBBUB_SDPIF_AGP_BOT__SDPIF_AGP_BOT), 0x0000040);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_TOP, 1,
+			FD(DCHUBBUB_SDPIF_AGP_TOP__SDPIF_AGP_TOP), 0x00001ff);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_BASE, 1,
+			FD(DCHUBBUB_SDPIF_AGP_BASE__SDPIF_AGP_BASE), 0x0000080);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_APER_TOP, 1,
+			FD(DCHUBBUB_SDPIF_APER_TOP__SDPIF_APER_TOP), 0x00007ff);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_APER_DEF_0, 1,
+			FD(DCHUBBUB_SDPIF_APER_DEF_0__SDPIF_APER_DEF_0), 0xdeadbeef);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_0, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_0__SDPIF_MARC_EN_0), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_0__SDPIF_MARC_RELOC_LO_0), 0x90000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_0, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_0__SDPIF_MARC_LENGTH_LO_0), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_1, 1,
+			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_1__SDPIF_MARC_BASE_LO_1), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_1, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_1__SDPIF_MARC_EN_1), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_1__SDPIF_MARC_RELOC_LO_1), 0xa0000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_1, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_1__SDPIF_MARC_LENGTH_LO_1), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_2, 1,
+			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_2__SDPIF_MARC_BASE_LO_2), 0x20000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_2, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_2__SDPIF_MARC_EN_2), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_2__SDPIF_MARC_RELOC_LO_2), 0xb0000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_2, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_2__SDPIF_MARC_LENGTH_LO_2), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_3, 1,
+			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_3__SDPIF_MARC_BASE_LO_3), 0x30000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_3, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_3__SDPIF_MARC_EN_3), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_3__SDPIF_MARC_RELOC_LO_3), 0xc0000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_3, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_3__SDPIF_MARC_LENGTH_LO_3), 0x10000);
+
+	/* TODO: Is DCN_VM_SYSTEM_APERTURE address one time programming?
+	 * Are all 4 hubp programmed with the same address?
+	 */
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+}
+
+/* TODO: This is one time program during system boot up,
+ * this should be done within BIOS
+ */
+static void dchubup_setup_timer(struct dc_context *ctx)
+{
+	dm_write_reg_soc15(ctx, mmREFCLK_CNTL, 0, 0);
+
+	generic_reg_update_soc15(ctx, 0, DCHUBBUB_GLOBAL_TIMER_CNTL, 1,
+			FD(DCHUBBUB_GLOBAL_TIMER_CNTL__DCHUBBUB_GLOBAL_TIMER_ENABLE), 1);
+}
+
+/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
+ * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
+ * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
+ */
+static void select_vtg(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	HWSEQ_REG_UPDATE(HUBP0_DCHUBP_CNTL, HUBP_VTG_SEL, inst);
+}
+
+static void enable_dcfclk(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint32_t requested_pix_clk,
+	bool dppclk_div)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	HWSEQ_REG_UPDATE(HUBP0_HUBP_CLK_CNTL, HUBP_CLOCK_ENABLE, 1);
+}
+
+static void enable_dppclk(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint32_t requested_pix_clk,
+	bool dppclk_div)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dpp;
+
+	dm_logger_write(ctx->logger, LOG_SURFACE,
+			"dppclk_rate_control for pipe %d programed to %d\n",
+			plane_id,
+			dppclk_div);
+
+	/* TODO: find condition for DPP clock to DISPCLK or 1/2 DISPCLK */
+	if (dppclk_div) {
+		/* 1/2 DISPCLK*/
+		HWSEQ_REG_UPDATE_2(DPP_TOP0_DPP_CONTROL,
+			DPPCLK_RATE_CONTROL, 1,
+			DPP_CLOCK_ENABLE, 1);
+	} else {
+		/* DISPCLK */
+		HWSEQ_REG_UPDATE_2(DPP_TOP0_DPP_CONTROL,
+			DPPCLK_RATE_CONTROL, 0,
+			DPP_CLOCK_ENABLE, 1);
+	}
+}
+
+static void enable_power_gating_plane(
+	struct dc_context *ctx,
+	bool enable)
+{
+	uint32_t inst_offset = 0; /* each register only has one instance */
+	bool force_on = 1; /* disable power gating */
+
+	if (enable)
+		force_on = 0;
+
+	/* DCHUBP0/1/2/3 */
+	HWSEQ_REG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN2_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN4_PG_CONFIG, DOMAIN4_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN6_PG_CONFIG, DOMAIN6_POWER_FORCEON, force_on);
+
+	/* DPP0/1/2/3 */
+	HWSEQ_REG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN1_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
+
+	if (ctx->dc->debug.disable_clock_gate) {
+		/* probably better to just write entire register to 0xffff to
+		 * ensure all clock gating is disabled
+		 */
+		HWSEQ_REG_UPDATE_3(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_R_DCCG_GATE_DISABLE, 1,
+				DPREFCLK_R_DCCG_GATE_DISABLE, 1,
+				REFCLK_R_DIG_GATE_DISABLE, 1);
+		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+				DCFCLK_GATE_DIS, 1);
+	}
+
+}
+
+static void dpp_pg_control(
+		struct dc_context *ctx,
+		unsigned int dpp_inst,
+		bool power_on)
+{
+	uint32_t inst_offset = 0;
+	uint32_t power_gate = power_on ? 0 : 1;
+	uint32_t pwr_status = power_on ? 0 : 2;
+
+	if (ctx->dc->debug.disable_dpp_power_gate)
+		return;
+
+	switch (dpp_inst) {
+	case 0: /* DPP0 */
+		HWSEQ_REG_UPDATE(DOMAIN1_PG_CONFIG,
+				DOMAIN1_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN1_PG_STATUS,
+				DOMAIN1_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 1: /* DPP1 */
+		HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG,
+				DOMAIN3_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN3_PG_STATUS,
+				DOMAIN3_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 2: /* DPP2 */
+		HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG,
+				DOMAIN5_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN5_PG_STATUS,
+				DOMAIN5_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 3: /* DPP3 */
+		HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG,
+				DOMAIN7_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN7_PG_STATUS,
+				DOMAIN7_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
+static void hubp_pg_control(
+		struct dc_context *ctx,
+		unsigned int hubp_inst,
+		bool power_on)
+{
+	uint32_t inst_offset = 0;
+	uint32_t power_gate = power_on ? 0 : 1;
+	uint32_t pwr_status = power_on ? 0 : 2;
+
+	if (ctx->dc->debug.disable_hubp_power_gate)
+		return;
+
+	switch (hubp_inst) {
+	case 0: /* DCHUBP0 */
+		HWSEQ_REG_UPDATE(DOMAIN0_PG_CONFIG,
+				DOMAIN0_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN0_PG_STATUS,
+				DOMAIN0_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 1: /* DCHUBP1 */
+		HWSEQ_REG_UPDATE(DOMAIN2_PG_CONFIG,
+				DOMAIN2_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN2_PG_STATUS,
+				DOMAIN2_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 2: /* DCHUBP2 */
+		HWSEQ_REG_UPDATE(DOMAIN4_PG_CONFIG,
+				DOMAIN4_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN4_PG_STATUS,
+				DOMAIN4_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 3: /* DCHUBP3 */
+		HWSEQ_REG_UPDATE(DOMAIN6_PG_CONFIG,
+				DOMAIN6_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN6_PG_STATUS,
+				DOMAIN6_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
+static void power_on_plane(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint8_t inst)
+{
+	uint32_t inst_offset = 0;
+
+	/* disable clock power gating */
+
+	/* DCCG_GATE_DISABLE_CNTL only has one instance */
+	HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
+			DISPCLK_DCCG_GATE_DISABLE, 1,
+			DPPCLK_GATE_DISABLE, 1);
+	/* DCFCLK_CNTL only has one instance */
+	HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+			DCFCLK_GATE_DIS, 1);
+
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 1);
+	dpp_pg_control(ctx, plane_id, true);
+	hubp_pg_control(ctx, plane_id, true);
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 0);
+
+	if (ctx->dc->debug.disable_clock_gate) {
+		HWSEQ_REG_UPDATE(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_DCCG_GATE_DISABLE, 0);
+	} else {
+		/* DCCG_GATE_DISABLE_CNTL only has one instance. inst_offset = 0 */
+		HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_DCCG_GATE_DISABLE, 0,
+				DPPCLK_GATE_DISABLE, 0);
+		/* DCFCLK_CNTL only has one instance. inst_offset = 0 */
+		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+				DCFCLK_GATE_DIS, 0);
+	}
+}
+
+/* fully check bios enabledisplaypowergating table. dal only need dce init
+ * other power, clock gate register will be handle by dal itself.
+ * further may be put within init_hw
+ */
+static bool dcn10_enable_display_power_gating(
+	struct core_dc *dc,
+	uint8_t controller_id,
+	struct dc_bios *dcb,
+	enum pipe_gating_control power_gating)
+{
+	/* TODOFPGA */
+#if 0
+	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
+		dce110_init_pte(ctx);
+#endif
+
+	return true;
+}
+
+static void bios_golden_init(struct core_dc *dc)
+{
+	struct dc_bios *bp = dc->ctx->dc_bios;
+	int i;
+
+	/* initialize dcn global */
+	bp->funcs->enable_disp_power_gating(bp,
+			CONTROLLER_ID_D0, ASIC_PIPE_INIT);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		/* initialize dcn per pipe */
+		bp->funcs->enable_disp_power_gating(bp,
+				CONTROLLER_ID_D0 + i, ASIC_PIPE_DISABLE);
+	}
+}
+
+static void init_hw(struct core_dc *dc)
+{
+	int i;
+	struct dc_bios *bp;
+	struct transform *xfm;
+	struct abm *abm;
+
+	bp = dc->ctx->dc_bios;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		/* TODO: this will be moved to Diag or BIOS */
+		dchubup_setup_timer(dc->ctx);
+
+		/* TODO: dchubp_map_fb_to_mc will be moved to dchub interface
+		 * between dc and kmd
+		 */
+		dchubp_map_fb_to_mc(dc->ctx);
+
+		enable_power_gating_plane(dc->ctx, true);
+		return;
+	}
+	/* end of FPGA. Below if real ASIC */
+
+	bios_golden_init(dc);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		xfm = dc->res_pool->transforms[i];
+		xfm->funcs->transform_reset(xfm);
+
+		/* TODOFPGA: may need later */
+#if 0
+		xfm->funcs->transform_power_up(xfm);
+		dc->hwss.enable_display_pipe_clock_gating(
+			dc->ctx,
+			true);
+#endif
+	}
+	/* TODOFPGA: light sleep */
+#if 0
+	dc->hwss.clock_gating_power_up(dc->ctx, false);
+#endif
+
+	for (i = 0; i < dc->link_count; i++) {
+		/* Power up AND update implementation according to the
+		 * required signal (which may be different from the
+		 * default signal on connector).
+		 */
+		struct core_link *link = dc->links[i];
+
+		link->link_enc->funcs->hw_init(link->link_enc);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg =
+				dc->res_pool->timing_generators[i];
+
+		tg->funcs->disable_vga(tg);
+
+		/* Blank controller using driver code instead of
+		 * command table.
+		 */
+		tg->funcs->set_blank(tg, true);
+		hwss_wait_for_blank_complete(tg);
+	}
+
+	for (i = 0; i < dc->res_pool->audio_count; i++) {
+		struct audio *audio = dc->res_pool->audios[i];
+
+		audio->funcs->hw_init(audio);
+	}
+
+	abm = dc->res_pool->abm;
+	if (abm != NULL) {
+		abm->funcs->init_backlight(abm);
+		abm->funcs->abm_init(abm);
+	}
+
+	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
+	generic_reg_set_soc15(dc->ctx, 0, DIO_MEM_PWR_CTRL, 7,
+			FD(DIO_MEM_PWR_CTRL__HDMI0_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI1_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI2_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI3_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI4_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI5_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI6_MEM_PWR_FORCE), 0);
+
+	/* This power gating should be one-time program for DAL.
+	 * It can only change by registry key
+	 * TODO: new task will for this.
+	 * if power gating is disable, power_on_plane and power_off_plane
+	 * should be skip. Otherwise, hand will be met in power_off_plane
+	 */
+
+	enable_power_gating_plane(dc->ctx, true);
+}
+
+static enum dc_status dcn10_prog_pixclk_crtc_otg(
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context,
+		struct core_dc *dc)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	enum dc_color_space color_space;
+	struct tg_color black_color = {0};
+	bool enableStereo    = stream->public.timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
+			false:true;
+	bool rightEyePolarity = stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+
+
+	/* by upper caller loop, pipe0 is parent pipe and be called first.
+	 * back end is set up by for pipe0. Other children pipe share back end
+	 * with pipe 0. No program is needed.
+	 */
+	if (pipe_ctx->top_pipe != NULL)
+		return DC_OK;
+
+	/* TODO check if timing_changed, disable stream if timing changed */
+
+	/* HW program guide assume display already disable
+	 * by unplug sequence. OTG assume stop.
+	 */
+	pipe_ctx->tg->funcs->enable_optc_clock(pipe_ctx->tg, true);
+
+	if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
+			pipe_ctx->clock_source,
+			&pipe_ctx->pix_clk_params,
+			&pipe_ctx->pll_settings)) {
+		BREAK_TO_DEBUGGER();
+		return DC_ERROR_UNEXPECTED;
+	}
+	pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
+	pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
+	pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
+	pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
+
+	pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+
+	pipe_ctx->tg->funcs->program_timing(
+			pipe_ctx->tg,
+			&stream->public.timing,
+			true);
+
+	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
+				pipe_ctx->opp,
+				enableStereo,
+				rightEyePolarity);
+
+#if 0 /* move to after enable_crtc */
+	/* TODO: OPP FMT, ABM. etc. should be done here. */
+	/* or FPGA now. instance 0 only. TODO: move to opp.c */
+
+	inst_offset = reg_offsets[pipe_ctx->tg->inst].fmt;
+
+	pipe_ctx->opp->funcs->opp_program_fmt(
+				pipe_ctx->opp,
+				&stream->bit_depth_params,
+				&stream->clamping);
+#endif
+	/* program otg blank color */
+	color_space = stream->public.output_color_space;
+	color_space_to_black_color(dc, color_space, &black_color);
+	pipe_ctx->tg->funcs->set_blank_color(
+			pipe_ctx->tg,
+			&black_color);
+
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
+	hwss_wait_for_blank_complete(pipe_ctx->tg);
+
+	/* VTG is  within DCHUB command block. DCFCLK is always on */
+	if (false == pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
+		BREAK_TO_DEBUGGER();
+		return DC_ERROR_UNEXPECTED;
+	}
+
+	/* TODO program crtc source select for non-virtual signal*/
+	/* TODO program FMT */
+	/* TODO setup link_enc */
+	/* TODO set stream attributes */
+	/* TODO program audio */
+	/* TODO enable stream if timing changed */
+	/* TODO unblank stream if DP */
+
+	return DC_OK;
+}
+
+static void reset_back_end_for_pipe(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	int i;
+	struct dc_bios *bp;
+
+	bp = dc->ctx->dc_bios;
+
+	if (pipe_ctx->stream_enc == NULL) {
+		pipe_ctx->stream = NULL;
+		return;
+	}
+
+	/* TODOFPGA break core_link_disable_stream into 2 functions:
+	 * disable_stream and disable_link. disable_link will disable PHYPLL
+	 * which is used by otg. Move disable_link after disable_crtc
+	 */
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		core_link_disable_stream(pipe_ctx);
+
+	/* by upper caller loop, parent pipe: pipe0, will be reset last.
+	 * back end share by all pipes and will be disable only when disable
+	 * parent pipe.
+	 */
+	if (pipe_ctx->top_pipe == NULL) {
+		pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
+
+		pipe_ctx->tg->funcs->enable_optc_clock(pipe_ctx->tg, false);
+	}
+
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		resource_unreference_clock_source(
+			&context->res_ctx, dc->res_pool,
+			&pipe_ctx->clock_source);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++)
+		if (&dc->current_context->res_ctx.pipe_ctx[i] == pipe_ctx)
+			break;
+
+	if (i == dc->res_pool->pipe_count)
+		return;
+
+	pipe_ctx->stream = NULL;
+}
+
+static void reset_front_end_for_pipe(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
+	struct mpc_tree_cfg *tree_cfg = NULL;
+
+	if (!pipe_ctx->surface)
+		return;
+
+	lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
+
+	/* TODO: build stream pipes group id. For now, use stream otg
+	 * id as pipe group id
+	 */
+	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+
+	if (pipe_ctx->top_pipe == NULL)
+		dcn10_delete_mpc_tree(mpc, tree_cfg);
+	else {
+		if (dcn10_remove_dpp(mpc, tree_cfg, pipe_ctx->pipe_idx))
+			pipe_ctx->top_pipe->bottom_pipe = NULL;
+		else {
+			dm_logger_write(dc->ctx->logger, LOG_RESOURCE,
+				"%s: failed to find dpp to be removed!\n",
+				__func__);
+		}
+	}
+
+	pipe_ctx->top_pipe = NULL;
+	pipe_ctx->bottom_pipe = NULL;
+	pipe_ctx->mpc_idx = -1;
+
+	unlock_master_tg_and_wait(dc->ctx, pipe_ctx->tg->inst);
+
+	pipe_ctx->mi->funcs->disable_request(pipe_ctx->mi);
+
+	wait_no_outstanding_request(dc->ctx, pipe_ctx->pipe_idx);
+
+	wait_mpcc_idle(mpc, pipe_ctx->pipe_idx);
+
+	disable_clocks(dc->ctx, pipe_ctx->pipe_idx);
+
+	pipe_ctx->xfm->funcs->transform_reset(pipe_ctx->xfm);
+
+	dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Reset front end for pipe %d\n",
+					pipe_ctx->pipe_idx);
+
+	pipe_ctx->surface = NULL;
+}
+
+static void reset_hw_ctx(struct core_dc *dc,
+		struct validate_context *context,
+		void (*reset)(struct core_dc *dc,
+				struct pipe_ctx *pipe_ctx,
+				struct validate_context *context))
+{
+	int i;
+
+	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
+		struct pipe_ctx *pipe_ctx_old =
+			&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx_old->stream)
+			continue;
+
+		if (!pipe_ctx->stream ||
+				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+			reset(dc, pipe_ctx_old, dc->current_context);
+	}
+}
+
+static void reset_hw_ctx_wrap(
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	/* Reset Front End*/
+	reset_hw_ctx(dc, context, reset_front_end_for_pipe);
+	/* Reset Back End*/
+	reset_hw_ctx(dc, context, reset_back_end_for_pipe);
+
+	memcpy(context->res_ctx.mpc_tree,
+			dc->current_context->res_ctx.mpc_tree,
+			sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
+}
+
+static bool patch_address_for_sbs_tb_stereo(struct pipe_ctx *pipe_ctx,
+											PHYSICAL_ADDRESS_LOC *addr)
+{
+	struct core_surface *surface = pipe_ctx->surface;
+	bool sec_split = pipe_ctx->top_pipe &&
+			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
+	if (sec_split && surface->public.address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+		(pipe_ctx->stream->public.timing.timing_3d_format ==
+		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
+		 pipe_ctx->stream->public.timing.timing_3d_format ==
+		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
+		*addr = surface->public.address.grph_stereo.left_addr;
+		surface->public.address.grph_stereo.left_addr =\
+		surface->public.address.grph_stereo.right_addr;
+		return true;
+	}
+	return false;
+}
+
+static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	bool addr_patched = false;
+	PHYSICAL_ADDRESS_LOC addr;
+	struct core_surface *surface = pipe_ctx->surface;
+
+	if (surface == NULL)
+		return;
+	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
+	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
+			pipe_ctx->mi,
+			&surface->public.address,
+			surface->public.flip_immediate);
+	surface->status.requested_address = surface->public.address;
+	if (addr_patched)
+		pipe_ctx->surface->public.address.grph_stereo.left_addr = addr;
+}
+
+static bool dcn10_set_input_transfer_func(
+	struct pipe_ctx *pipe_ctx,
+	const struct core_surface *surface)
+{
+	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	const struct core_transfer_func *tf = NULL;
+	bool result = true;
+
+	if (ipp == NULL)
+		return false;
+
+	if (surface->public.in_transfer_func)
+		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
+
+	if (tf == NULL)
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+	else if (tf->public.type == TF_TYPE_PREDEFINED) {
+		switch (tf->public.tf) {
+		case TRANSFER_FUNCTION_SRGB:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_HW_sRGB);
+			break;
+		case TRANSFER_FUNCTION_BT709:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_HW_xvYCC);
+			break;
+		case TRANSFER_FUNCTION_LINEAR:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_BYPASS);
+			break;
+		case TRANSFER_FUNCTION_PQ:
+			result = false;
+			break;
+		default:
+			result = false;
+			break;
+		}
+	} else if (tf->public.type == TF_TYPE_BYPASS) {
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+	} else {
+		/*TF_TYPE_DISTRIBUTED_POINTS*/
+		result = false;
+	}
+
+	return result;
+}
+/*modify the method to handle rgb for arr_points*/
+static bool convert_to_custom_float(
+		struct pwl_result_data *rgb_resulted,
+		struct curve_points *arr_points,
+		uint32_t hw_points_num)
+{
+	struct custom_float_format fmt;
+
+	struct pwl_result_data *rgb = rgb_resulted;
+
+	uint32_t i = 0;
+
+	fmt.exponenta_bits = 6;
+	fmt.mantissa_bits = 12;
+	fmt.sign = false;
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].x,
+		&fmt,
+		&arr_points[0].custom_float_x)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].offset,
+		&fmt,
+		&arr_points[0].custom_float_offset)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].slope,
+		&fmt,
+		&arr_points[0].custom_float_slope)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	fmt.mantissa_bits = 10;
+	fmt.sign = false;
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].x,
+		&fmt,
+		&arr_points[1].custom_float_x)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].y,
+		&fmt,
+		&arr_points[1].custom_float_y)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].slope,
+		&fmt,
+		&arr_points[1].custom_float_slope)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	fmt.mantissa_bits = 12;
+	fmt.sign = true;
+
+	while (i != hw_points_num) {
+		if (!convert_to_custom_float_format(
+			rgb->red,
+			&fmt,
+			&rgb->red_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->green,
+			&fmt,
+			&rgb->green_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->blue,
+			&fmt,
+			&rgb->blue_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_red,
+			&fmt,
+			&rgb->delta_red_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_green,
+			&fmt,
+			&rgb->delta_green_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_blue,
+			&fmt,
+			&rgb->delta_blue_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		++rgb;
+		++i;
+	}
+
+	return true;
+}
+#define MAX_REGIONS_NUMBER 34
+#define MAX_LOW_POINT      25
+#define NUMBER_SEGMENTS    32
+
+static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
+		*output_tf, struct pwl_params *regamma_params)
+{
+	struct curve_points *arr_points;
+	struct pwl_result_data *rgb_resulted;
+	struct pwl_result_data *rgb;
+	struct pwl_result_data *rgb_plus_1;
+	struct fixed31_32 y_r;
+	struct fixed31_32 y_g;
+	struct fixed31_32 y_b;
+	struct fixed31_32 y1_min;
+	struct fixed31_32 y3_max;
+
+	int32_t segment_start, segment_end;
+	int32_t i;
+	uint32_t j, k, seg_distr[MAX_REGIONS_NUMBER], increment, start_index, hw_points;
+
+	if (output_tf == NULL || regamma_params == NULL ||
+			output_tf->type == TF_TYPE_BYPASS)
+		return false;
+
+	arr_points = regamma_params->arr_points;
+	rgb_resulted = regamma_params->rgb_resulted;
+	hw_points = 0;
+
+	memset(regamma_params, 0, sizeof(struct pwl_params));
+	memset(seg_distr, 0, sizeof(seg_distr));
+
+	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
+		/* 32 segments
+		 * segments are from 2^-25 to 2^7
+		 */
+		for (i = 0; i < 32 ; i++)
+			seg_distr[i] = 3;
+
+		segment_start = -25;
+		segment_end   = 7;
+	} else {
+		/* 10 segments
+		 * segment is from 2^-10 to 2^0
+		 * There are less than 256 points, for optimization
+		 */
+		seg_distr[0] = 3;
+		seg_distr[1] = 4;
+		seg_distr[2] = 4;
+		seg_distr[3] = 4;
+		seg_distr[4] = 4;
+		seg_distr[5] = 4;
+		seg_distr[6] = 4;
+		seg_distr[7] = 4;
+		seg_distr[8] = 5;
+		seg_distr[9] = 5;
+
+		segment_start = -10;
+		segment_end = 0;
+	}
+
+	for (i = segment_end - segment_start; i < MAX_REGIONS_NUMBER ; i++)
+		seg_distr[i] = -1;
+
+	for (k = 0; k < MAX_REGIONS_NUMBER; k++) {
+		if (seg_distr[k] != -1)
+			hw_points += (1 << seg_distr[k]);
+	}
+
+	j = 0;
+	for (k = 0; k < (segment_end - segment_start); k++) {
+		increment = NUMBER_SEGMENTS / (1 << seg_distr[k]);
+		start_index = (segment_start + k + MAX_LOW_POINT) * NUMBER_SEGMENTS;
+		for (i = start_index; i < start_index + NUMBER_SEGMENTS; i += increment) {
+			if (j == hw_points - 1)
+				break;
+			rgb_resulted[j].red = output_tf->tf_pts.red[i];
+			rgb_resulted[j].green = output_tf->tf_pts.green[i];
+			rgb_resulted[j].blue = output_tf->tf_pts.blue[i];
+			j++;
+		}
+	}
+
+	/* last point */
+	start_index = (segment_end + MAX_LOW_POINT) * NUMBER_SEGMENTS;
+	rgb_resulted[hw_points - 1].red =
+			output_tf->tf_pts.red[start_index];
+	rgb_resulted[hw_points - 1].green =
+			output_tf->tf_pts.green[start_index];
+	rgb_resulted[hw_points - 1].blue =
+			output_tf->tf_pts.blue[start_index];
+
+	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_start));
+	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_end));
+	arr_points[2].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_end));
+
+	y_r = rgb_resulted[0].red;
+	y_g = rgb_resulted[0].green;
+	y_b = rgb_resulted[0].blue;
+
+	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
+
+	arr_points[0].y = y1_min;
+	arr_points[0].slope = dal_fixed31_32_div(
+					arr_points[0].y,
+					arr_points[0].x);
+	y_r = rgb_resulted[hw_points - 1].red;
+	y_g = rgb_resulted[hw_points - 1].green;
+	y_b = rgb_resulted[hw_points - 1].blue;
+
+	/* see comment above, m_arrPoints[1].y should be the Y value for the
+	 * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints - 1)
+	 */
+	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
+
+	arr_points[1].y = y3_max;
+	arr_points[2].y = y3_max;
+
+	arr_points[1].slope = dal_fixed31_32_zero;
+	arr_points[2].slope = dal_fixed31_32_zero;
+
+	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
+		/* for PQ, we want to have a straight line from last HW X point,
+		 * and the slope to be such that we hit 1.0 at 10000 nits.
+		 */
+		const struct fixed31_32 end_value =
+				dal_fixed31_32_from_int(125);
+
+		arr_points[1].slope = dal_fixed31_32_div(
+			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+			dal_fixed31_32_sub(end_value, arr_points[1].x));
+		arr_points[2].slope = dal_fixed31_32_div(
+			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+			dal_fixed31_32_sub(end_value, arr_points[1].x));
+	}
+
+	regamma_params->hw_points_num = hw_points;
+
+	i = 1;
+	for (k = 0; k < MAX_REGIONS_NUMBER && i < MAX_REGIONS_NUMBER; k++) {
+		if (seg_distr[k] != -1) {
+			regamma_params->arr_curve_points[k].segments_num =
+					seg_distr[k];
+			regamma_params->arr_curve_points[i].offset =
+					regamma_params->arr_curve_points[k].
+					offset + (1 << seg_distr[k]);
+		}
+		i++;
+	}
+
+	if (seg_distr[k] != -1)
+		regamma_params->arr_curve_points[k].segments_num =
+				seg_distr[k];
+
+	rgb = rgb_resulted;
+	rgb_plus_1 = rgb_resulted + 1;
+
+	i = 1;
+
+	while (i != hw_points + 1) {
+		if (dal_fixed31_32_lt(rgb_plus_1->red, rgb->red))
+			rgb_plus_1->red = rgb->red;
+		if (dal_fixed31_32_lt(rgb_plus_1->green, rgb->green))
+			rgb_plus_1->green = rgb->green;
+		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
+			rgb_plus_1->blue = rgb->blue;
+
+		rgb->delta_red = dal_fixed31_32_sub(
+			rgb_plus_1->red,
+			rgb->red);
+		rgb->delta_green = dal_fixed31_32_sub(
+			rgb_plus_1->green,
+			rgb->green);
+		rgb->delta_blue = dal_fixed31_32_sub(
+			rgb_plus_1->blue,
+			rgb->blue);
+
+		++rgb_plus_1;
+		++rgb;
+		++i;
+	}
+
+	convert_to_custom_float(rgb_resulted, arr_points, hw_points);
+
+	return true;
+}
+
+static bool dcn10_set_output_transfer_func(
+	struct pipe_ctx *pipe_ctx,
+	const struct core_surface *surface,
+	const struct core_stream *stream)
+{
+	struct output_pixel_processor *opp = pipe_ctx->opp;
+
+	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
+
+	if (stream->public.out_transfer_func &&
+		stream->public.out_transfer_func->type ==
+			TF_TYPE_PREDEFINED &&
+		stream->public.out_transfer_func->tf ==
+			TRANSFER_FUNCTION_SRGB) {
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
+	} else if (dcn10_translate_regamma_to_hw_format(
+				stream->public.out_transfer_func, &opp->regamma_params)) {
+			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
+			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
+	} else {
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
+	}
+
+	return true;
+}
+
+static void dcn10_pipe_control_lock(
+	struct core_dc *dc,
+	struct pipe_ctx *pipe,
+	bool lock)
+{
+	struct dce_hwseq *hws = hws = dc->hwseq;
+
+	/* use TG master update lock to lock everything on the TG
+	 * therefore only top pipe need to lock
+	 */
+	if (pipe->top_pipe)
+		return;
+
+	if (lock)
+		dcn10_lock(pipe->tg);
+	else
+		dcn10_unlock(pipe->tg);
+}
+
+static bool wait_for_reset_trigger_to_occur(
+	struct dc_context *dc_ctx,
+	struct timing_generator *tg)
+{
+	bool rc = false;
+
+	/* To avoid endless loop we wait at most
+	 * frames_to_wait_on_triggered_reset frames for the reset to occur. */
+	const uint32_t frames_to_wait_on_triggered_reset = 10;
+	int i;
+
+	for (i = 0; i < frames_to_wait_on_triggered_reset; i++) {
+
+		if (!tg->funcs->is_counter_moving(tg)) {
+			DC_ERROR("TG counter is not moving!\n");
+			break;
+		}
+
+		if (tg->funcs->did_triggered_reset_occur(tg)) {
+			rc = true;
+			/* usually occurs at i=1 */
+			DC_SYNC_INFO("GSL: reset occurred at wait count: %d\n",
+					i);
+			break;
+		}
+
+		/* Wait for one frame. */
+		tg->funcs->wait_for_state(tg, CRTC_STATE_VACTIVE);
+		tg->funcs->wait_for_state(tg, CRTC_STATE_VBLANK);
+	}
+
+	if (false == rc)
+		DC_ERROR("GSL: Timeout on reset trigger!\n");
+
+	return rc;
+}
+
+static void dcn10_enable_timing_synchronization(
+	struct core_dc *dc,
+	int group_index,
+	int group_size,
+	struct pipe_ctx *grouped_pipes[])
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	int i;
+
+	DC_SYNC_INFO("Setting up OTG reset trigger\n");
+
+	for (i = 1; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->enable_reset_trigger(
+				grouped_pipes[i]->tg, grouped_pipes[0]->tg->inst);
+
+
+	DC_SYNC_INFO("Waiting for trigger\n");
+
+	/* Need to get only check 1 pipe for having reset as all the others are
+	 * synchronized. Look at last pipe programmed to reset.
+	 */
+	wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[1]->tg);
+	for (i = 1; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->disable_reset_trigger(
+				grouped_pipes[i]->tg);
+
+	DC_SYNC_INFO("Sync complete\n");
+}
+
+static void dcn10_power_on_fe(
+	struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct validate_context *context)
+{
+	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
+
+	/* power up DCHUP and DPP from pseudo code pipe_move.c */
+	 /*TODO: function: power_on_plane. If already power up, skip
+	 */
+	{
+		power_on_plane(dc->ctx,
+			pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+
+		/* enable DCFCLK current DCHUB */
+		enable_dcfclk(dc->ctx,
+				pipe_ctx->pipe_idx,
+				pipe_ctx->pix_clk_params.requested_pix_clk,
+				context->dppclk_div);
+
+		if (dc_surface) {
+			dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Pipe:%d 0x%x: addr hi:0x%x, "
+					"addr low:0x%x, "
+					"src: %d, %d, %d,"
+					" %d; dst: %d, %d, %d, %d;\n",
+					pipe_ctx->pipe_idx,
+					dc_surface,
+					dc_surface->address.grph.addr.high_part,
+					dc_surface->address.grph.addr.low_part,
+					dc_surface->src_rect.x,
+					dc_surface->src_rect.y,
+					dc_surface->src_rect.width,
+					dc_surface->src_rect.height,
+					dc_surface->dst_rect.x,
+					dc_surface->dst_rect.y,
+					dc_surface->dst_rect.width,
+					dc_surface->dst_rect.height);
+
+			dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
+					"Pipe %d: width, height, x, y\n"
+					"viewport:%d, %d, %d, %d\n"
+					"recout:  %d, %d, %d, %d\n",
+					pipe_ctx->pipe_idx,
+					pipe_ctx->scl_data.viewport.width,
+					pipe_ctx->scl_data.viewport.height,
+					pipe_ctx->scl_data.viewport.x,
+					pipe_ctx->scl_data.viewport.y,
+					pipe_ctx->scl_data.recout.width,
+					pipe_ctx->scl_data.recout.height,
+					pipe_ctx->scl_data.recout.x,
+					pipe_ctx->scl_data.recout.y);
+		}
+	}
+
+}
+
+static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
+{
+	struct xfm_grph_csc_adjustment adjust;
+	memset(&adjust, 0, sizeof(adjust));
+	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
+
+
+	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		adjust.temperature_matrix[0] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[0];
+		adjust.temperature_matrix[1] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[1];
+		adjust.temperature_matrix[2] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[2];
+		adjust.temperature_matrix[3] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[4];
+		adjust.temperature_matrix[4] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[5];
+		adjust.temperature_matrix[5] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[6];
+		adjust.temperature_matrix[6] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[8];
+		adjust.temperature_matrix[7] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[9];
+		adjust.temperature_matrix[8] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[10];
+	}
+
+	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+}
+
+static void update_dchubp_dpp(
+	struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct validate_context *context)
+{
+	struct mem_input *mi = pipe_ctx->mi;
+	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	struct core_surface *surface = pipe_ctx->surface;
+	union plane_size size = surface->public.plane_size;
+	struct mpc_tree_cfg *tree_cfg = NULL;
+	struct default_adjustment ocsc = {0};
+	enum dc_color_space color_space;
+	struct tg_color black_color = {0};
+	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
+
+	/* depends on DML calculation, DPP clock value may change dynamically */
+	enable_dppclk(
+		dc->ctx,
+		pipe_ctx->pipe_idx,
+		pipe_ctx->pix_clk_params.requested_pix_clk,
+		context->dppclk_div);
+
+	select_vtg(dc->ctx, pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+
+	update_plane_addr(dc, pipe_ctx);
+
+	mi->funcs->mem_input_setup(
+		mi,
+		&pipe_ctx->dlg_regs,
+		&pipe_ctx->ttu_regs,
+		&pipe_ctx->rq_regs,
+		&pipe_ctx->pipe_dlg_param);
+
+	size.grph.surface_size = pipe_ctx->scl_data.viewport;
+
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
+				pipe_ctx->mi,
+				surface->public.format,
+				&surface->public.tiling_info,
+				surface->public.rotation);
+
+	ipp->funcs->ipp_setup(ipp,
+			surface->public.format,
+			1,
+			IPP_OUTPUT_FORMAT_12_BIT_FIX);
+
+	/* mpc TODO un-hardcode object ids
+	 * for pseudo code pipe_move.c :
+	 * add_plane_mpcc(added_plane_inst, mpcc_inst, ...);
+	 * Do we want to cache the tree_cfg?
+	 */
+
+	/* TODO: build stream pipes group id. For now, use stream otg
+	 * id as pipe group id
+	 */
+	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
+	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+	/* enable when bottom pipe is present and
+	 * it does not share a surface with current pipe
+	 */
+	if (pipe_ctx->bottom_pipe && surface != pipe_ctx->bottom_pipe->surface) {
+		pipe_ctx->scl_data.lb_params.alpha_en = 1;
+		tree_cfg->mode = TOP_BLND;
+	} else {
+		pipe_ctx->scl_data.lb_params.alpha_en = 0;
+		tree_cfg->mode = TOP_PASSTHRU;
+	}
+	if (!pipe_ctx->top_pipe) {
+		/* primary pipe, set mpc tree index 0 only */
+		tree_cfg->num_pipes = 1;
+		tree_cfg->opp_id = pipe_ctx->tg->inst;
+		tree_cfg->dpp[0] = pipe_ctx->pipe_idx;
+		tree_cfg->mpcc[0] = pipe_ctx->pipe_idx;
+		dcn10_set_mpc_tree(mpc, tree_cfg);
+	} else {
+		/* TODO: add position is hard code to 1 for now
+		 * If more than 2 pipes are supported, calculate position
+		 */
+		dcn10_add_dpp(mpc, tree_cfg,
+			pipe_ctx->pipe_idx, pipe_ctx->pipe_idx, 1);
+	}
+
+	color_space = pipe_ctx->stream->public.output_color_space;
+	color_space_to_black_color(dc, color_space, &black_color);
+	dcn10_set_mpc_background_color(mpc, pipe_ctx->pipe_idx, &black_color);
+
+	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
+	/* scaler configuration */
+	pipe_ctx->xfm->funcs->transform_set_scaler(
+			pipe_ctx->xfm, &pipe_ctx->scl_data);
+
+	/*gamut remap*/
+	program_gamut_remap(pipe_ctx);
+
+	/*TODO add adjustments parameters*/
+	ocsc.out_color_space = pipe_ctx->stream->public.output_color_space;
+	pipe_ctx->opp->funcs->opp_set_csc_default(pipe_ctx->opp, &ocsc);
+
+	mi->funcs->mem_input_program_surface_config(
+		mi,
+		surface->public.format,
+		&surface->public.tiling_info,
+		&size,
+		surface->public.rotation,
+		&surface->public.dcc,
+		surface->public.horizontal_mirror,
+		surface->public.visible);
+
+	/* Only support one plane for now. */
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !surface->public.visible);
+
+}
+
+static void program_all_pipe_in_tree(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
+
+	if (pipe_ctx->surface->public.visible || pipe_ctx->top_pipe == NULL) {
+		dcn10_power_on_fe(dc, pipe_ctx, context);
+
+		/* lock otg_master_update to process all pipes associated with
+		 * this OTG. this is done only one time.
+		 */
+		if (pipe_ctx->top_pipe == NULL) {
+			/* watermark is for all pipes */
+			pipe_ctx->mi->funcs->program_watermarks(
+					pipe_ctx->mi, &context->watermarks, ref_clk_mhz);
+			lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
+		}
+		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
+		pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
+		pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
+		pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
+		pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+		pipe_ctx->tg->funcs->program_global_sync(
+				pipe_ctx->tg);
+		update_dchubp_dpp(dc, pipe_ctx, context);
+	}
+
+	if (pipe_ctx->bottom_pipe != NULL)
+		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
+}
+
+static void dcn10_pplib_apply_display_requirements(
+	struct core_dc *dc,
+	struct validate_context *context)
+{
+	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
+
+	pp_display_cfg->all_displays_in_sync = false;/*todo*/
+	pp_display_cfg->nb_pstate_switch_disable = false;
+	pp_display_cfg->min_engine_clock_khz = context->dcfclk_khz;
+	pp_display_cfg->min_memory_clock_khz = context->fclk_khz;
+	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->dcfclk_deep_sleep_khz;
+	pp_display_cfg->avail_mclk_switch_time_us =
+			context->dram_ccm_us > 0 ? context->dram_ccm_us : 0;
+	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us =
+			context->min_active_dram_ccm_us > 0 ? context->min_active_dram_ccm_us : 0;
+	pp_display_cfg->min_dcfclock_khz = context->dcfclk_khz;
+	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
+	dce110_fill_display_configs(context, pp_display_cfg);
+
+	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
+			struct dm_pp_display_configuration)) !=  0)
+		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
+
+	dc->prev_display_config = *pp_display_cfg;
+}
+
+static void dcn10_apply_ctx_for_surface(
+		struct core_dc *dc,
+		struct core_surface *surface,
+		struct validate_context *context)
+{
+	int i;
+
+	memcpy(context->res_ctx.mpc_tree,
+			dc->current_context->res_ctx.mpc_tree,
+			sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->surface)
+			continue;
+
+		/* looking for top pipe to program */
+		if (!pipe_ctx->top_pipe)
+			program_all_pipe_in_tree(dc, pipe_ctx, context);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			continue;
+
+		/* unlock master update lock */
+		unlock_otg_master(dc->ctx, pipe_ctx->tg->inst);
+	}
+
+	/* reset unused pipe */
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx =
+				&dc->current_context->res_ctx.pipe_ctx[i];
+
+		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
+				|| (!pipe_ctx->stream && old_pipe_ctx->stream))
+			reset_front_end_for_pipe(dc,
+					old_pipe_ctx, dc->current_context);
+	}
+}
+
+static void dcn10_set_bandwidth(
+		struct core_dc *dc,
+		struct validate_context *context,
+		bool decrease_allowed)
+{
+	struct dm_pp_clock_for_voltage_req clock;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		return;
+
+	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
+				context->dispclk_khz);
+		dc->current_context->dispclk_khz = context->dispclk_khz;
+	}
+	if (decrease_allowed || context->dcfclk_khz > dc->current_context->dcfclk_khz) {
+		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
+		clock.clocks_in_khz = context->dcfclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+	}
+	if (decrease_allowed || context->fclk_khz > dc->current_context->fclk_khz) {
+		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
+		clock.clocks_in_khz = context->fclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->fclk_khz = clock.clocks_in_khz ;
+	}
+	dcn10_pplib_apply_display_requirements(dc, context);
+}
+
+static void dcn10_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
+{
+	struct dc_context *ctx = dc->ctx;
+	uint32_t inst_offset = 0;
+
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 1);
+	dpp_pg_control(ctx, pipe->pipe_idx, false);
+	hubp_pg_control(ctx, pipe->pipe_idx, false);
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 0);
+
+	if (pipe->xfm)
+		pipe->xfm->funcs->transform_reset(pipe->xfm);
+	memset(&pipe->scl_data, 0, sizeof(pipe->scl_data));
+}
+
+static void set_drr(struct pipe_ctx **pipe_ctx,
+		int num_pipes, int vmin, int vmax)
+{
+	int i = 0;
+	struct drr_params params = {0};
+
+	params.vertical_total_max = vmax;
+	params.vertical_total_min = vmin;
+
+	/* TODO: If multiple pipes are to be supported, you need
+	 * some GSL stuff
+	 */
+	for (i = 0; i < num_pipes; i++) {
+		pipe_ctx[i]->tg->funcs->set_drr(pipe_ctx[i]->tg, &params);
+	}
+}
+
+static void get_position(struct pipe_ctx **pipe_ctx,
+		int num_pipes,
+		struct crtc_position *position)
+{
+	int i = 0;
+
+	/* TODO: handle pipes > 1
+	 */
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->get_position(pipe_ctx[i]->tg, position);
+}
+
+static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
+		int num_pipes, const struct dc_static_screen_events *events)
+{
+	unsigned int i;
+	unsigned int value = 0;
+
+	if (events->surface_update)
+		value |= 0x80;
+	if (events->cursor_update)
+		value |= 0x2;
+
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->
+			set_static_screen_control(pipe_ctx[i]->tg, value);
+}
+
+static void set_plane_config(
+	const struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct resource_context *res_ctx)
+{
+	/* TODO */
+	program_gamut_remap(pipe_ctx);
+}
+
+static const struct hw_sequencer_funcs dcn10_funcs = {
+	.init_hw = init_hw,
+	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
+	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
+	.set_plane_config = set_plane_config,
+	.update_plane_addr = update_plane_addr,
+	.update_pending_status = dce110_update_pending_status,
+	.set_input_transfer_func = dcn10_set_input_transfer_func,
+	.set_output_transfer_func = dcn10_set_output_transfer_func,
+	.power_down = dce110_power_down,
+	.enable_accelerated_mode = dce110_enable_accelerated_mode,
+	.enable_timing_synchronization = dcn10_enable_timing_synchronization,
+	.update_info_frame = dce110_update_info_frame,
+	.enable_stream = dce110_enable_stream,
+	.disable_stream = dce110_disable_stream,
+	.unblank_stream = dce110_unblank_stream,
+	.enable_display_pipe_clock_gating = NULL, /* TODOFPGA */
+	.enable_display_power_gating = dcn10_enable_display_power_gating,
+	.power_down_front_end = dcn10_power_down_fe,
+	.power_on_front_end = dcn10_power_on_fe,
+	.pipe_control_lock = dcn10_pipe_control_lock,
+	.set_bandwidth = dcn10_set_bandwidth,
+	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
+	.prog_pixclk_crtc_otg = dcn10_prog_pixclk_crtc_otg,
+	.set_drr = set_drr,
+	.get_position = get_position,
+	.set_static_screen_control = set_static_screen_control
+};
+
+
+bool dcn10_hw_sequencer_construct(struct core_dc *dc)
+{
+	dc->hwss = dcn10_funcs;
+	return true;
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
new file mode 100644
index 0000000..c3aff2e
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
@@ -0,0 +1,38 @@
+/*
+* Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_HWSS_DCN10_H__
+#define __DC_HWSS_DCN10_H__
+
+#include "core_types.h"
+
+struct core_dc;
+
+bool dcn10_hw_sequencer_construct(struct core_dc *dc);
+extern void fill_display_configs(
+	const struct validate_context *context,
+	struct dm_pp_display_configuration *pp_display_cfg);
+
+#endif /* __DC_HWSS_DCN10_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c
new file mode 100644
index 0000000..3062b7d
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c
@@ -0,0 +1,883 @@
+/*
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dcn10_ipp.h"
+#include "reg_helper.h"
+
+#define REG(reg) \
+	(ippn10->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	ippn10->ipp_shift->field_name, ippn10->ipp_mask->field_name
+
+#define CTX \
+	ippn10->base.ctx
+
+
+struct dcn10_input_csc_matrix {
+	enum dc_color_space color_space;
+	uint32_t regval[12];
+};
+
+static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
+	{COLOR_SPACE_SRGB,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_SRGB_LIMITED,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_YCBCR601,
+		{0x2cdd, 0x2000, 0, 0xe991, 0xe926, 0x2000, 0xf4fd, 0x10ef,
+						0, 0x2000, 0x38b4, 0xe3a6} },
+	{COLOR_SPACE_YCBCR601_LIMITED,
+		{0x3353, 0x2568, 0, 0xe400, 0xe5dc, 0x2568, 0xf367, 0x1108,
+						0, 0x2568, 0x40de, 0xdd3a} },
+	{COLOR_SPACE_YCBCR709,
+		{0x3265, 0x2000, 0, 0xe6ce, 0xf105, 0x2000, 0xfa01, 0xa7d, 0,
+						0x2000, 0x3b61, 0xe24f} },
+
+	{COLOR_SPACE_YCBCR709_LIMITED,
+		{0x39a6, 0x2568, 0, 0xe0d6, 0xeedd, 0x2568, 0xf925, 0x9a8, 0,
+						0x2568, 0x43ee, 0xdbb2} }
+};
+
+enum dcn10_input_csc_select {
+	INPUT_CSC_SELECT_BYPASS = 0,
+	INPUT_CSC_SELECT_ICSC,
+	INPUT_CSC_SELECT_COMA
+};
+
+static void dcn10_program_input_csc(
+		struct input_pixel_processor *ipp,
+		enum dc_color_space color_space,
+		enum dcn10_input_csc_select select)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	int i;
+	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
+	const uint32_t *regval = NULL;
+	uint32_t selection = 1;
+
+	if (select == INPUT_CSC_SELECT_BYPASS) {
+		REG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);
+		return;
+	}
+
+	for (i = 0; i < arr_size; i++)
+		if (dcn10_input_csc_matrix[i].color_space == color_space) {
+			regval = dcn10_input_csc_matrix[i].regval;
+			break;
+		}
+
+	if (regval == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (select == INPUT_CSC_SELECT_COMA)
+		selection = 2;
+	REG_SET(CM_ICSC_CONTROL, 0,
+			CM_ICSC_MODE, selection);
+
+	if (select == INPUT_CSC_SELECT_ICSC) {
+		/*R*/
+		REG_SET_2(CM_ICSC_C11_C12, 0,
+			CM_ICSC_C11, regval[0],
+			CM_ICSC_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C13_C14, 0,
+			CM_ICSC_C13, regval[0],
+			CM_ICSC_C14, regval[1]);
+		/*G*/
+		regval += 2;
+		REG_SET_2(CM_ICSC_C21_C22, 0,
+			CM_ICSC_C21, regval[0],
+			CM_ICSC_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C23_C24, 0,
+			CM_ICSC_C23, regval[0],
+			CM_ICSC_C24, regval[1]);
+		/*B*/
+		regval += 2;
+		REG_SET_2(CM_ICSC_C31_C32, 0,
+			CM_ICSC_C31, regval[0],
+			CM_ICSC_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C33_C34, 0,
+			CM_ICSC_C33, regval[0],
+			CM_ICSC_C34, regval[1]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMA_C11_C12, 0,
+			CM_COMA_C11, regval[0],
+			CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+			CM_COMA_C13, regval[0],
+			CM_COMA_C14, regval[1]);
+		/*G*/
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+			CM_COMA_C21, regval[0],
+			CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+			CM_COMA_C23, regval[0],
+			CM_COMA_C24, regval[1]);
+		/*B*/
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+			CM_COMA_C31, regval[0],
+			CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+			CM_COMA_C33, regval[0],
+			CM_COMA_C34, regval[1]);
+	}
+}
+
+/*program de gamma RAM B*/
+static void dcn10_ipp_program_degamma_lutb_settings(
+		struct input_pixel_processor *ipp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_DGAM_RAMB_REGION_0_1, 0,
+		CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, 	curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_2_3, 0,
+		CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_4_5, 0,
+		CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_6_7, 0,
+		CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_8_9, 0,
+		CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_10_11, 0,
+		CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_12_13, 0,
+		CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_14_15, 0,
+		CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+/*program de gamma RAM A*/
+static void dcn10_ipp_program_degamma_luta_settings(
+		struct input_pixel_processor *ipp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_DGAM_RAMA_REGION_0_1, 0,
+		CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_2_3, 0,
+		CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_4_5, 0,
+		CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_6_7, 0,
+		CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_8_9, 0,
+		CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_10_11, 0,
+		CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_12_13, 0,
+		CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_14_15, 0,
+		CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+static void ipp_power_on_degamma_lut(
+	struct input_pixel_processor *ipp,
+	bool power_on)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			SHARED_MEM_PWR_DIS, power_on == true ? 0:1);
+
+}
+
+static void ipp_program_degamma_lut(
+		struct input_pixel_processor *ipp,
+		const struct pwl_result_data *rgb,
+		uint32_t num,
+		bool is_ram_a)
+{
+	uint32_t i;
+
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);
+	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,
+				   CM_DGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL,
+					is_ram_a == true ? 0:1);
+
+	REG_SET(CM_DGAM_LUT_INDEX, 0, CM_DGAM_LUT_INDEX, 0);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_blue_reg);
+
+	}
+
+}
+
+static void dcn10_ipp_enable_cm_block(
+		struct input_pixel_processor *ipp)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 1);
+	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
+}
+
+
+static void dcn10_ipp_full_bypass(struct input_pixel_processor *ipp)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	/* Input pixel format: ARGB8888 */
+	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
+			CNVC_SURFACE_PIXEL_FORMAT, 0x8);
+
+	/* Zero expansion */
+	REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			ALPHA_EN, 0,
+			FORMAT_EXPANSION_MODE, 0);
+
+	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
+	REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
+
+	/* Setting degamma bypass for now */
+	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
+	REG_SET(CM_IGAM_CONTROL, 0, CM_IGAM_LUT_MODE, 0);
+}
+
+static void dcn10_ipp_set_degamma(
+		struct input_pixel_processor *ipp,
+		enum ipp_degamma_mode mode)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	dcn10_ipp_enable_cm_block(ipp);
+
+	switch (mode) {
+	case IPP_DEGAMMA_MODE_BYPASS:
+		/* Setting de gamma bypass for now */
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 0);
+		break;
+	case IPP_DEGAMMA_MODE_HW_sRGB:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 1);
+		break;
+	case IPP_DEGAMMA_MODE_HW_xvYCC:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);
+			break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
+static bool dcn10_cursor_program_control(
+		struct dcn10_ipp *ippn10,
+		bool pixel_data_invert,
+		enum dc_cursor_color_format color_format)
+{
+	REG_SET_2(CURSOR_SETTINS, 0,
+			/* no shift of the cursor HDL schedule */
+			CURSOR0_DST_Y_OFFSET, 0,
+			 /* used to shift the cursor chunk request deadline */
+			CURSOR0_CHUNK_HDL_ADJUST, 3);
+
+	REG_UPDATE_2(CURSOR0_CONTROL,
+			CUR0_MODE, color_format,
+			CUR0_INVERT_MODE, 0);
+
+	if (color_format == CURSOR_MODE_MONO) {
+		/* todo: clarify what to program these to */
+		REG_UPDATE(CURSOR0_COLOR0,
+				CUR0_COLOR0, 0x00000000);
+		REG_UPDATE(CURSOR0_COLOR1,
+				CUR0_COLOR1, 0xFFFFFFFF);
+	}
+
+	/* TODO: Fixed vs float */
+
+	REG_UPDATE_3(FORMAT_CONTROL,
+				CNVC_BYPASS, 0,
+				ALPHA_EN, 1,
+				FORMAT_EXPANSION_MODE, 0);
+
+	REG_UPDATE(CURSOR0_CONTROL,
+			CUR0_EXPANSION_MODE, 0);
+
+	if (0 /*attributes->attribute_flags.bits.MIN_MAX_INVERT*/) {
+		REG_UPDATE(CURSOR0_CONTROL,
+				CUR0_MAX,
+				0 /* TODO */);
+		REG_UPDATE(CURSOR0_CONTROL,
+				CUR0_MIN,
+				0 /* TODO */);
+	}
+
+	return true;
+}
+
+enum cursor_pitch {
+	CURSOR_PITCH_64_PIXELS = 0,
+	CURSOR_PITCH_128_PIXELS,
+	CURSOR_PITCH_256_PIXELS
+};
+
+enum cursor_lines_per_chunk {
+	CURSOR_LINE_PER_CHUNK_2 = 1,
+	CURSOR_LINE_PER_CHUNK_4,
+	CURSOR_LINE_PER_CHUNK_8,
+	CURSOR_LINE_PER_CHUNK_16
+};
+
+static enum cursor_pitch dcn10_get_cursor_pitch(
+		unsigned int pitch)
+{
+	enum cursor_pitch hw_pitch;
+
+	switch (pitch) {
+	case 64:
+		hw_pitch = CURSOR_PITCH_64_PIXELS;
+		break;
+	case 128:
+		hw_pitch = CURSOR_PITCH_128_PIXELS;
+		break;
+	case 256:
+		hw_pitch = CURSOR_PITCH_256_PIXELS;
+		break;
+	default:
+		DC_ERR("Invalid cursor pitch of %d. "
+				"Only 64/128/256 is supported on DCN.\n", pitch);
+		hw_pitch = CURSOR_PITCH_64_PIXELS;
+		break;
+	}
+	return hw_pitch;
+}
+
+static enum cursor_lines_per_chunk dcn10_get_lines_per_chunk(
+		unsigned int cur_width,
+		enum dc_cursor_color_format format)
+{
+	enum cursor_lines_per_chunk line_per_chunk;
+
+	if (format == CURSOR_MODE_MONO)
+		/* impl B. expansion in CUR Buffer reader */
+		line_per_chunk = CURSOR_LINE_PER_CHUNK_16;
+	else if (cur_width <= 32)
+		line_per_chunk = CURSOR_LINE_PER_CHUNK_16;
+	else if (cur_width <= 64)
+		line_per_chunk = CURSOR_LINE_PER_CHUNK_8;
+	else if (cur_width <= 128)
+		line_per_chunk = CURSOR_LINE_PER_CHUNK_4;
+	else
+		line_per_chunk = CURSOR_LINE_PER_CHUNK_2;
+
+	return line_per_chunk;
+}
+
+static void dcn10_cursor_set_attributes(
+		struct input_pixel_processor *ipp,
+		const struct dc_cursor_attributes *attr)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	enum cursor_pitch hw_pitch = dcn10_get_cursor_pitch(attr->pitch);
+	enum cursor_lines_per_chunk lpc = dcn10_get_lines_per_chunk(
+			attr->width, attr->color_format);
+
+	ippn10->curs_attr = *attr;
+
+	REG_UPDATE(CURSOR_SURFACE_ADDRESS_HIGH,
+			CURSOR_SURFACE_ADDRESS_HIGH, attr->address.high_part);
+	REG_UPDATE(CURSOR_SURFACE_ADDRESS,
+			CURSOR_SURFACE_ADDRESS, attr->address.low_part);
+
+	REG_UPDATE_2(CURSOR_SIZE,
+			CURSOR_WIDTH, attr->width,
+			CURSOR_HEIGHT, attr->height);
+
+	REG_UPDATE_3(CURSOR_CONTROL,
+			CURSOR_MODE, attr->color_format,
+			CURSOR_PITCH, hw_pitch,
+			CURSOR_LINES_PER_CHUNK, lpc);
+
+	dcn10_cursor_program_control(ippn10,
+			attr->attribute_flags.bits.INVERT_PIXEL_DATA,
+			attr->color_format);
+}
+
+static void dcn10_cursor_set_position(
+		struct input_pixel_processor *ipp,
+		const struct dc_cursor_position *pos,
+		const struct dc_cursor_mi_param *param)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	int src_x_offset = pos->x - pos->x_hotspot - param->viewport_x_start;
+	uint32_t cur_en = pos->enable ? 1 : 0;
+	uint32_t dst_x_offset = (src_x_offset >= 0) ? src_x_offset : 0;
+
+	dst_x_offset *= param->ref_clk_khz;
+	dst_x_offset /= param->pixel_clk_khz;
+
+	ASSERT(param->h_scale_ratio.value);
+
+	if (param->h_scale_ratio.value)
+		dst_x_offset = dal_fixed31_32_floor(dal_fixed31_32_div(
+				dal_fixed31_32_from_int(dst_x_offset),
+				param->h_scale_ratio));
+
+	if (src_x_offset >= (int)param->viewport_width)
+		cur_en = 0;  /* not visible beyond right edge*/
+
+	if (src_x_offset + (int)ippn10->curs_attr.width < 0)
+		cur_en = 0;  /* not visible beyond left edge*/
+
+	if (cur_en && REG_READ(CURSOR_SURFACE_ADDRESS) == 0)
+		dcn10_cursor_set_attributes(ipp, &ippn10->curs_attr);
+	REG_UPDATE(CURSOR_CONTROL,
+			CURSOR_ENABLE, cur_en);
+	REG_UPDATE(CURSOR0_CONTROL,
+			CUR0_ENABLE, cur_en);
+
+	REG_SET_2(CURSOR_POSITION, 0,
+			CURSOR_X_POSITION, pos->x,
+			CURSOR_Y_POSITION, pos->y);
+
+	REG_SET_2(CURSOR_HOT_SPOT, 0,
+			CURSOR_HOT_SPOT_X, pos->x_hotspot,
+			CURSOR_HOT_SPOT_Y, pos->y_hotspot);
+
+	REG_SET(CURSOR_DST_OFFSET, 0,
+			CURSOR_DST_X_OFFSET, dst_x_offset);
+	/* TODO Handle surface pixel formats other than 4:4:4 */
+}
+
+enum pixel_format_description {
+	PIXEL_FORMAT_FIXED = 0,
+	PIXEL_FORMAT_FIXED16,
+	PIXEL_FORMAT_FLOAT
+
+};
+
+static void dcn10_setup_format_flags(enum surface_pixel_format input_format,\
+						enum pixel_format_description *fmt)
+{
+
+	if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F ||
+		input_format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F)
+		*fmt = PIXEL_FORMAT_FLOAT;
+	else if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)
+		*fmt = PIXEL_FORMAT_FIXED16;
+	else
+		*fmt = PIXEL_FORMAT_FIXED;
+}
+
+static void dcn10_ipp_set_degamma_format_float(struct input_pixel_processor *ipp,
+		bool is_float)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	if (is_float) {
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 1);
+	} else {
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 2);
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 0);
+	}
+}
+
+
+static void dcn10_ipp_cnv_setup (
+		struct input_pixel_processor *ipp,
+		enum surface_pixel_format input_format,
+		enum expansion_mode mode,
+		enum ipp_output_format cnv_out_format)
+{
+	uint32_t pixel_format;
+	uint32_t alpha_en;
+	enum pixel_format_description fmt ;
+	enum dc_color_space color_space;
+	enum dcn10_input_csc_select select;
+	bool is_float;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	bool force_disable_cursor = false;
+
+	dcn10_setup_format_flags(input_format, &fmt);
+	alpha_en = 1;
+	pixel_format = 0;
+	color_space = COLOR_SPACE_SRGB;
+	select = INPUT_CSC_SELECT_BYPASS;
+	is_float = false;
+
+	switch (fmt) {
+	case PIXEL_FORMAT_FIXED:
+	case PIXEL_FORMAT_FIXED16:
+	/*when output is float then FORMAT_CONTROL__OUTPUT_FP=1*/
+		REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_EXPANSION_MODE, mode,
+			OUTPUT_FP, 0);
+		break;
+	case PIXEL_FORMAT_FLOAT:
+		REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_EXPANSION_MODE, mode,
+			OUTPUT_FP, 1);
+		is_float = true;
+		break;
+	default:
+
+		break;
+	}
+
+	dcn10_ipp_set_degamma_format_float(ipp, is_float);
+
+	switch (input_format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+		pixel_format = 1;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		pixel_format = 3;
+		alpha_en = 0;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+		pixel_format = 8;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		pixel_format = 10;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+		force_disable_cursor = false;
+		pixel_format = 65;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		force_disable_cursor = true;
+		pixel_format = 64;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+		force_disable_cursor = true;
+		pixel_format = 67;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		force_disable_cursor = true;
+		pixel_format = 66;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+		pixel_format = 22;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+		pixel_format = 24;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		pixel_format = 25;
+		break;
+	default:
+		break;
+	}
+	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
+			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
+	REG_UPDATE(FORMAT_CONTROL, ALPHA_EN, alpha_en);
+
+	dcn10_program_input_csc(ipp, color_space, select);
+
+	if (force_disable_cursor) {
+		REG_UPDATE(CURSOR_CONTROL,
+				CURSOR_ENABLE, 0);
+		REG_UPDATE(CURSOR0_CONTROL,
+				CUR0_ENABLE, 0);
+	}
+}
+
+
+static bool dcn10_degamma_ram_inuse(struct input_pixel_processor *ipp,
+							bool *ram_a_inuse)
+{
+	bool ret = false;
+	uint32_t status_reg = 0;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	status_reg = (REG_READ(CM_IGAM_LUT_RW_CONTROL) & 0x0F00) >>16;
+	if (status_reg == 9) {
+		*ram_a_inuse = true;
+		ret = true;
+	} else if (status_reg == 10) {
+		*ram_a_inuse = false;
+		ret = true;
+	}
+	return ret;
+}
+
+static void dcn10_degamma_ram_select(struct input_pixel_processor *ipp,
+							bool use_ram_a)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	if (use_ram_a)
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
+	else
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 4);
+
+}
+
+static void dcn10_ipp_set_degamma_pwl(struct input_pixel_processor *ipp,
+								 const struct pwl_params *params)
+{
+	bool is_ram_a = true;
+
+	ipp_power_on_degamma_lut(ipp, true);
+	dcn10_ipp_enable_cm_block(ipp);
+	dcn10_degamma_ram_inuse(ipp, &is_ram_a);
+	if (is_ram_a == true)
+		dcn10_ipp_program_degamma_lutb_settings(ipp, params);
+	else
+		dcn10_ipp_program_degamma_luta_settings(ipp, params);
+
+	ipp_program_degamma_lut(ipp, params->rgb_resulted,
+							params->hw_points_num, !is_ram_a);
+	dcn10_degamma_ram_select(ipp, !is_ram_a);
+}
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+static void dcn10_ipp_destroy(struct input_pixel_processor **ipp)
+{
+	dm_free(TO_DCN10_IPP(*ipp));
+	*ipp = NULL;
+}
+
+static const struct ipp_funcs dcn10_ipp_funcs = {
+	.ipp_cursor_set_attributes	= dcn10_cursor_set_attributes,
+	.ipp_cursor_set_position	= dcn10_cursor_set_position,
+	.ipp_set_degamma		= dcn10_ipp_set_degamma,
+	.ipp_full_bypass		= dcn10_ipp_full_bypass,
+	.ipp_setup			= dcn10_ipp_cnv_setup,
+	.ipp_program_degamma_pwl	= dcn10_ipp_set_degamma_pwl,
+	.ipp_destroy			= dcn10_ipp_destroy
+};
+
+void dcn10_ipp_construct(
+	struct dcn10_ipp *ippn10,
+	struct dc_context *ctx,
+	int inst,
+	const struct dcn10_ipp_registers *regs,
+	const struct dcn10_ipp_shift *ipp_shift,
+	const struct dcn10_ipp_mask *ipp_mask)
+{
+	ippn10->base.ctx = ctx;
+	ippn10->base.inst = inst;
+	ippn10->base.funcs = &dcn10_ipp_funcs;
+
+	ippn10->regs = regs;
+	ippn10->ipp_shift = ipp_shift;
+	ippn10->ipp_mask = ipp_mask;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h
new file mode 100644
index 0000000..a4ea4e7
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h
@@ -0,0 +1,549 @@
+/*
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef _DCN10_IPP_H_
+#define _DCN10_IPP_H_
+
+#include "ipp.h"
+
+#define TO_DCN10_IPP(ipp)\
+	container_of(ipp, struct dcn10_ipp, base)
+
+#define IPP_DCN10_REG_LIST(id) \
+	SRI(CM_ICSC_CONTROL, CM, id), \
+	SRI(CM_ICSC_C11_C12, CM, id), \
+	SRI(CM_ICSC_C13_C14, CM, id), \
+	SRI(CM_ICSC_C21_C22, CM, id), \
+	SRI(CM_ICSC_C23_C24, CM, id), \
+	SRI(CM_ICSC_C31_C32, CM, id), \
+	SRI(CM_ICSC_C33_C34, CM, id), \
+	SRI(CM_COMA_C11_C12, CM, id), \
+	SRI(CM_COMA_C13_C14, CM, id), \
+	SRI(CM_COMA_C21_C22, CM, id), \
+	SRI(CM_COMA_C23_C24, CM, id), \
+	SRI(CM_COMA_C31_C32, CM, id), \
+	SRI(CM_COMA_C33_C34, CM, id), \
+	SRI(CM_DGAM_RAMB_START_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMB_START_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMB_START_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMB_SLOPE_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMB_SLOPE_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMB_SLOPE_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL1_B, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL2_B, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL1_G, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL2_G, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL1_R, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL2_R, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_0_1, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_2_3, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_4_5, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_6_7, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_8_9, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_10_11, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_12_13, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_14_15, CM, id), \
+	SRI(CM_DGAM_RAMA_START_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMA_START_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMA_START_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMA_SLOPE_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMA_SLOPE_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMA_SLOPE_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL1_B, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL2_B, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL1_G, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL2_G, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL1_R, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL2_R, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_0_1, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_2_3, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_4_5, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_6_7, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_8_9, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_10_11, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_12_13, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_14_15, CM, id), \
+	SRI(CM_MEM_PWR_CTRL, CM, id), \
+	SRI(CM_IGAM_LUT_RW_CONTROL, CM, id), \
+	SRI(CM_DGAM_LUT_WRITE_EN_MASK, CM, id), \
+	SRI(CM_DGAM_LUT_INDEX, CM, id), \
+	SRI(CM_DGAM_LUT_DATA, CM, id), \
+	SRI(CM_CONTROL, CM, id), \
+	SRI(CM_DGAM_CONTROL, CM, id), \
+	SRI(CM_IGAM_CONTROL, CM, id), \
+	SRI(DPP_CONTROL, DPP_TOP, id), \
+	SRI(CURSOR_SETTINS, HUBPREQ, id), \
+	SRI(CNVC_SURFACE_PIXEL_FORMAT, CNVC_CFG, id), \
+	SRI(CURSOR0_CONTROL, CNVC_CUR, id), \
+	SRI(CURSOR0_COLOR0, CNVC_CUR, id), \
+	SRI(CURSOR0_COLOR1, CNVC_CUR, id), \
+	SRI(FORMAT_CONTROL, CNVC_CFG, id), \
+	SRI(CURSOR_SURFACE_ADDRESS_HIGH, CURSOR, id), \
+	SRI(CURSOR_SURFACE_ADDRESS, CURSOR, id), \
+	SRI(CURSOR_SIZE, CURSOR, id), \
+	SRI(CURSOR_CONTROL, CURSOR, id), \
+	SRI(CURSOR_POSITION, CURSOR, id), \
+	SRI(CURSOR_HOT_SPOT, CURSOR, id), \
+	SRI(CURSOR_DST_OFFSET, CURSOR, id)
+
+#define IPP_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define IPP_DCN10_MASK_SH_LIST(mask_sh) \
+	IPP_SF(CM0_CM_ICSC_CONTROL, CM_ICSC_MODE, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C11, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C12, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C13_C14, CM_ICSC_C13, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C13_C14, CM_ICSC_C14, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C21_C22, CM_ICSC_C21, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C21_C22, CM_ICSC_C22, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C23_C24, CM_ICSC_C23, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C23_C24, CM_ICSC_C24, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C31_C32, CM_ICSC_C31, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C31_C32, CM_ICSC_C32, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C33, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C34, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C11_C12, CM_COMA_C11, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C11_C12, CM_COMA_C12, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C13_C14, CM_COMA_C13, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C13_C14, CM_COMA_C14, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C21_C22, CM_COMA_C21, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C21_C22, CM_COMA_C22, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C23_C24, CM_COMA_C23, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C23_C24, CM_COMA_C24, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C31_C32, CM_COMA_C31, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C31_C32, CM_COMA_C32, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C33_C34, CM_COMA_C33, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C33_C34, CM_COMA_C34, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_R, CM_DGAM_RAMB_EXP_REGION_START_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_R, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_B, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_G, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_R, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL1_B, CM_DGAM_RAMB_EXP_REGION_END_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_B, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_B, CM_DGAM_RAMB_EXP_REGION_END_BASE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL1_G, CM_DGAM_RAMB_EXP_REGION_END_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_G, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_G, CM_DGAM_RAMB_EXP_REGION_END_BASE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL1_R, CM_DGAM_RAMB_EXP_REGION_END_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_R, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_R, CM_DGAM_RAMB_EXP_REGION_END_BASE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_B, CM_DGAM_RAMA_EXP_REGION_START_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_B, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_G, CM_DGAM_RAMA_EXP_REGION_START_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_G, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_R, CM_DGAM_RAMA_EXP_REGION_START_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_R, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_B, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_G, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_R, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL1_B, CM_DGAM_RAMA_EXP_REGION_END_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_B, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_B, CM_DGAM_RAMA_EXP_REGION_END_BASE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL1_G, CM_DGAM_RAMA_EXP_REGION_END_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_G, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_G, CM_DGAM_RAMA_EXP_REGION_END_BASE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL1_R, CM_DGAM_RAMA_EXP_REGION_END_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_R, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_R, CM_DGAM_RAMA_EXP_REGION_END_BASE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_MEM_PWR_CTRL, SHARED_MEM_PWR_DIS, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_EN_MASK, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_INDEX, CM_DGAM_LUT_INDEX, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_DATA, CM_DGAM_LUT_DATA, mask_sh), \
+	IPP_SF(DPP_TOP0_DPP_CONTROL, DPP_CLOCK_ENABLE, mask_sh), \
+	IPP_SF(CM0_CM_CONTROL, CM_BYPASS_EN, mask_sh), \
+	IPP_SF(CNVC_CFG0_CNVC_SURFACE_PIXEL_FORMAT, CNVC_SURFACE_PIXEL_FORMAT, mask_sh), \
+	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, CNVC_BYPASS, mask_sh), \
+	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, ALPHA_EN, mask_sh), \
+	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, FORMAT_EXPANSION_MODE, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, mask_sh), \
+	IPP_SF(HUBPREQ0_CURSOR_SETTINS, CURSOR0_DST_Y_OFFSET, mask_sh), \
+	IPP_SF(HUBPREQ0_CURSOR_SETTINS, CURSOR0_CHUNK_HDL_ADJUST, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_MODE, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_INVERT_MODE, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_COLOR0, CUR0_COLOR0, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_COLOR1, CUR0_COLOR1, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_EXPANSION_MODE, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_MAX, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_MIN, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_SURFACE_ADDRESS_HIGH, CURSOR_SURFACE_ADDRESS_HIGH, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_SURFACE_ADDRESS, CURSOR_SURFACE_ADDRESS, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_SIZE, CURSOR_WIDTH, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_SIZE, CURSOR_HEIGHT, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_CONTROL, CURSOR_MODE, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_CONTROL, CURSOR_PITCH, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_CONTROL, CURSOR_LINES_PER_CHUNK, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_CONTROL, CURSOR_ENABLE, mask_sh), \
+	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_ENABLE, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_POSITION, CURSOR_X_POSITION, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_POSITION, CURSOR_Y_POSITION, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_HOT_SPOT, CURSOR_HOT_SPOT_X, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_HOT_SPOT, CURSOR_HOT_SPOT_Y, mask_sh), \
+	IPP_SF(CURSOR0_CURSOR_DST_OFFSET, CURSOR_DST_X_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, mask_sh), \
+	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, OUTPUT_FP, mask_sh)
+
+#define IPP_DCN10_REG_FIELD_LIST(type) \
+	type CM_ICSC_MODE; \
+	type CM_ICSC_C11; \
+	type CM_ICSC_C12; \
+	type CM_ICSC_C13; \
+	type CM_ICSC_C14; \
+	type CM_ICSC_C21; \
+	type CM_ICSC_C22; \
+	type CM_ICSC_C23; \
+	type CM_ICSC_C24; \
+	type CM_ICSC_C31; \
+	type CM_ICSC_C32; \
+	type CM_ICSC_C33; \
+	type CM_ICSC_C34; \
+	type CM_COMA_C11; \
+	type CM_COMA_C12; \
+	type CM_COMA_C13; \
+	type CM_COMA_C14; \
+	type CM_COMA_C21; \
+	type CM_COMA_C22; \
+	type CM_COMA_C23; \
+	type CM_COMA_C24; \
+	type CM_COMA_C31; \
+	type CM_COMA_C32; \
+	type CM_COMA_C33; \
+	type CM_COMA_C34; \
+	type CM_DGAM_RAMB_EXP_REGION_START_B; \
+	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B; \
+	type CM_DGAM_RAMB_EXP_REGION_START_G; \
+	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G; \
+	type CM_DGAM_RAMB_EXP_REGION_START_R; \
+	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R; \
+	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B; \
+	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G; \
+	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R; \
+	type CM_DGAM_RAMB_EXP_REGION_END_B; \
+	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B; \
+	type CM_DGAM_RAMB_EXP_REGION_END_BASE_B; \
+	type CM_DGAM_RAMB_EXP_REGION_END_G; \
+	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G; \
+	type CM_DGAM_RAMB_EXP_REGION_END_BASE_G; \
+	type CM_DGAM_RAMB_EXP_REGION_END_R; \
+	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R; \
+	type CM_DGAM_RAMB_EXP_REGION_END_BASE_R; \
+	type CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION_START_B; \
+	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B; \
+	type CM_DGAM_RAMA_EXP_REGION_START_G; \
+	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G; \
+	type CM_DGAM_RAMA_EXP_REGION_START_R; \
+	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R; \
+	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B; \
+	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G; \
+	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R; \
+	type CM_DGAM_RAMA_EXP_REGION_END_B; \
+	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B; \
+	type CM_DGAM_RAMA_EXP_REGION_END_BASE_B; \
+	type CM_DGAM_RAMA_EXP_REGION_END_G; \
+	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G; \
+	type CM_DGAM_RAMA_EXP_REGION_END_BASE_G; \
+	type CM_DGAM_RAMA_EXP_REGION_END_R; \
+	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R; \
+	type CM_DGAM_RAMA_EXP_REGION_END_BASE_R; \
+	type CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS; \
+	type SHARED_MEM_PWR_DIS; \
+	type CM_IGAM_LUT_HOST_EN; \
+	type CM_DGAM_LUT_WRITE_EN_MASK; \
+	type CM_DGAM_LUT_WRITE_SEL; \
+	type CM_DGAM_LUT_INDEX; \
+	type CM_DGAM_LUT_DATA; \
+	type DPP_CLOCK_ENABLE; \
+	type CM_BYPASS_EN; \
+	type CNVC_SURFACE_PIXEL_FORMAT; \
+	type CNVC_BYPASS; \
+	type ALPHA_EN; \
+	type FORMAT_EXPANSION_MODE; \
+	type CM_DGAM_LUT_MODE; \
+	type CM_IGAM_LUT_MODE; \
+	type CURSOR0_DST_Y_OFFSET; \
+	type CURSOR0_CHUNK_HDL_ADJUST; \
+	type CUR0_MODE; \
+	type CUR0_INVERT_MODE; \
+	type CUR0_COLOR0; \
+	type CUR0_COLOR1; \
+	type CUR0_EXPANSION_MODE; \
+	type CUR0_MAX; \
+	type CUR0_MIN; \
+	type CURSOR_SURFACE_ADDRESS_HIGH; \
+	type CURSOR_SURFACE_ADDRESS; \
+	type CURSOR_WIDTH; \
+	type CURSOR_HEIGHT; \
+	type CURSOR_MODE; \
+	type CURSOR_PITCH; \
+	type CURSOR_LINES_PER_CHUNK; \
+	type CURSOR_ENABLE; \
+	type CUR0_ENABLE; \
+	type CURSOR_X_POSITION; \
+	type CURSOR_Y_POSITION; \
+	type CURSOR_HOT_SPOT_X; \
+	type CURSOR_HOT_SPOT_Y; \
+	type CURSOR_DST_X_OFFSET; \
+	type CM_IGAM_INPUT_FORMAT; \
+	type OUTPUT_FP
+
+struct dcn10_ipp_shift {
+	IPP_DCN10_REG_FIELD_LIST(uint8_t);
+};
+
+struct dcn10_ipp_mask {
+	IPP_DCN10_REG_FIELD_LIST(uint32_t);
+};
+
+struct dcn10_ipp_registers {
+	uint32_t CM_ICSC_CONTROL;
+	uint32_t CM_ICSC_C11_C12;
+	uint32_t CM_ICSC_C13_C14;
+	uint32_t CM_ICSC_C21_C22;
+	uint32_t CM_ICSC_C23_C24;
+	uint32_t CM_ICSC_C31_C32;
+	uint32_t CM_ICSC_C33_C34;
+	uint32_t CM_COMA_C11_C12;
+	uint32_t CM_COMA_C13_C14;
+	uint32_t CM_COMA_C21_C22;
+	uint32_t CM_COMA_C23_C24;
+	uint32_t CM_COMA_C31_C32;
+	uint32_t CM_COMA_C33_C34;
+	uint32_t CM_DGAM_RAMB_START_CNTL_B;
+	uint32_t CM_DGAM_RAMB_START_CNTL_G;
+	uint32_t CM_DGAM_RAMB_START_CNTL_R;
+	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_B;
+	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_G;
+	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_R;
+	uint32_t CM_DGAM_RAMB_END_CNTL1_B;
+	uint32_t CM_DGAM_RAMB_END_CNTL2_B;
+	uint32_t CM_DGAM_RAMB_END_CNTL1_G;
+	uint32_t CM_DGAM_RAMB_END_CNTL2_G;
+	uint32_t CM_DGAM_RAMB_END_CNTL1_R;
+	uint32_t CM_DGAM_RAMB_END_CNTL2_R;
+	uint32_t CM_DGAM_RAMB_REGION_0_1;
+	uint32_t CM_DGAM_RAMB_REGION_2_3;
+	uint32_t CM_DGAM_RAMB_REGION_4_5;
+	uint32_t CM_DGAM_RAMB_REGION_6_7;
+	uint32_t CM_DGAM_RAMB_REGION_8_9;
+	uint32_t CM_DGAM_RAMB_REGION_10_11;
+	uint32_t CM_DGAM_RAMB_REGION_12_13;
+	uint32_t CM_DGAM_RAMB_REGION_14_15;
+	uint32_t CM_DGAM_RAMA_START_CNTL_B;
+	uint32_t CM_DGAM_RAMA_START_CNTL_G;
+	uint32_t CM_DGAM_RAMA_START_CNTL_R;
+	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_B;
+	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_G;
+	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_R;
+	uint32_t CM_DGAM_RAMA_END_CNTL1_B;
+	uint32_t CM_DGAM_RAMA_END_CNTL2_B;
+	uint32_t CM_DGAM_RAMA_END_CNTL1_G;
+	uint32_t CM_DGAM_RAMA_END_CNTL2_G;
+	uint32_t CM_DGAM_RAMA_END_CNTL1_R;
+	uint32_t CM_DGAM_RAMA_END_CNTL2_R;
+	uint32_t CM_DGAM_RAMA_REGION_0_1;
+	uint32_t CM_DGAM_RAMA_REGION_2_3;
+	uint32_t CM_DGAM_RAMA_REGION_4_5;
+	uint32_t CM_DGAM_RAMA_REGION_6_7;
+	uint32_t CM_DGAM_RAMA_REGION_8_9;
+	uint32_t CM_DGAM_RAMA_REGION_10_11;
+	uint32_t CM_DGAM_RAMA_REGION_12_13;
+	uint32_t CM_DGAM_RAMA_REGION_14_15;
+	uint32_t CM_MEM_PWR_CTRL;
+	uint32_t CM_IGAM_LUT_RW_CONTROL;
+	uint32_t CM_DGAM_LUT_WRITE_EN_MASK;
+	uint32_t CM_DGAM_LUT_INDEX;
+	uint32_t CM_DGAM_LUT_DATA;
+	uint32_t CM_CONTROL;
+	uint32_t CM_DGAM_CONTROL;
+	uint32_t CM_IGAM_CONTROL;
+	uint32_t DPP_CONTROL;
+	uint32_t CURSOR_SETTINS;
+	uint32_t CNVC_SURFACE_PIXEL_FORMAT;
+	uint32_t CURSOR0_CONTROL;
+	uint32_t CURSOR0_COLOR0;
+	uint32_t CURSOR0_COLOR1;
+	uint32_t FORMAT_CONTROL;
+	uint32_t CURSOR_SURFACE_ADDRESS_HIGH;
+	uint32_t CURSOR_SURFACE_ADDRESS;
+	uint32_t CURSOR_SIZE;
+	uint32_t CURSOR_CONTROL;
+	uint32_t CURSOR_POSITION;
+	uint32_t CURSOR_HOT_SPOT;
+	uint32_t CURSOR_DST_OFFSET;
+};
+
+struct dcn10_ipp {
+	struct input_pixel_processor base;
+
+	const struct dcn10_ipp_registers *regs;
+	const struct dcn10_ipp_shift *ipp_shift;
+	const struct dcn10_ipp_mask *ipp_mask;
+
+	struct dc_cursor_attributes curs_attr;
+};
+
+void dcn10_ipp_construct(struct dcn10_ipp *ippn10,
+	struct dc_context *ctx,
+	int inst,
+	const struct dcn10_ipp_registers *regs,
+	const struct dcn10_ipp_shift *ipp_shift,
+	const struct dcn10_ipp_mask *ipp_mask);
+
+#endif /* _DCN10_IPP_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
new file mode 100644
index 0000000..bf89608
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
@@ -0,0 +1,1102 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+#include "dm_services.h"
+#include "dce_calcs.h"
+#include "dcn10_mem_input.h"
+#include "reg_helper.h"
+#include "basics/conversion.h"
+
+#define REG(reg)\
+	mi->mi_regs->reg
+
+#define CTX \
+	mi->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	mi->mi_shift->field_name, mi->mi_mask->field_name
+
+static void set_blank(struct dcn10_mem_input *mi, bool blank)
+{
+	uint32_t blank_en = blank ? 1 : 0;
+
+	REG_UPDATE_2(DCHUBP_CNTL,
+			HUBP_BLANK_EN, blank_en,
+			HUBP_TTU_DISABLE, blank_en);
+}
+
+
+static void disable_request(struct mem_input *mem_input)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	/* To disable the requestors, set blank_en to 1 */
+	set_blank(mi, true);
+}
+
+static void vready_workaround(struct mem_input *mem_input,
+		struct _vcs_dpi_display_pipe_dest_params_st *pipe_dest)
+{
+	uint32_t value = 0;
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	/* set HBUBREQ_DEBUG_DB[12] = 1 */
+	value = REG_READ(HUBPREQ_DEBUG_DB);
+
+	/* hack mode disable */
+	value |= 0x100;
+	value &= ~0x1000;
+
+	if ((pipe_dest->vstartup_start - 2*(pipe_dest->vready_offset+pipe_dest->vupdate_width
+		+ pipe_dest->vupdate_offset) / pipe_dest->htotal) <= pipe_dest->vblank_end) {
+		/* if (eco_fix_needed(otg_global_sync_timing)
+		 * set HBUBREQ_DEBUG_DB[12] = 1 */
+		value |= 0x1000;
+	}
+
+	REG_WRITE(HUBPREQ_DEBUG_DB, value);
+}
+
+static void program_tiling(
+	struct dcn10_mem_input *mi,
+	const union dc_tiling_info *info,
+	const enum surface_pixel_format pixel_format)
+{
+	REG_UPDATE_6(DCSURF_ADDR_CONFIG,
+			NUM_PIPES, log_2(info->gfx9.num_pipes),
+			NUM_BANKS, log_2(info->gfx9.num_banks),
+			PIPE_INTERLEAVE, info->gfx9.pipe_interleave,
+			NUM_SE, log_2(info->gfx9.num_shader_engines),
+			NUM_RB_PER_SE, log_2(info->gfx9.num_rb_per_se),
+			MAX_COMPRESSED_FRAGS, log_2(info->gfx9.max_compressed_frags));
+
+	REG_UPDATE_4(DCSURF_TILING_CONFIG,
+			SW_MODE, info->gfx9.swizzle,
+			META_LINEAR, info->gfx9.meta_linear,
+			RB_ALIGNED, info->gfx9.rb_aligned,
+			PIPE_ALIGNED, info->gfx9.pipe_aligned);
+}
+
+static void program_size_and_rotation(
+	struct dcn10_mem_input *mi,
+	enum dc_rotation_angle rotation,
+	enum surface_pixel_format format,
+	const union plane_size *plane_size,
+	struct dc_plane_dcc_param *dcc,
+	bool horizontal_mirror)
+{
+	uint32_t pitch, meta_pitch, pitch_c, meta_pitch_c, mirror;
+
+	/* Program data and meta surface pitch (calculation from addrlib)
+	 * 444 or 420 luma
+	 */
+	if (format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
+		pitch = plane_size->video.luma_pitch - 1;
+		meta_pitch = dcc->video.meta_pitch_l - 1;
+		pitch_c = plane_size->video.chroma_pitch - 1;
+		meta_pitch_c = dcc->video.meta_pitch_c - 1;
+	} else {
+		pitch = plane_size->grph.surface_pitch - 1;
+		meta_pitch = dcc->grph.meta_pitch - 1;
+		pitch_c = 0;
+		meta_pitch_c = 0;
+	}
+
+	if (!dcc->enable) {
+		meta_pitch = 0;
+		meta_pitch_c = 0;
+	}
+
+	REG_UPDATE_2(DCSURF_SURFACE_PITCH,
+			PITCH, pitch, META_PITCH, meta_pitch);
+
+	if (format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+		REG_UPDATE_2(DCSURF_SURFACE_PITCH_C,
+			PITCH_C, pitch_c, META_PITCH_C, meta_pitch_c);
+
+	if (horizontal_mirror)
+		mirror = 1;
+	else
+		mirror = 0;
+
+
+	/* Program rotation angle and horz mirror - no mirror */
+	if (rotation == ROTATION_ANGLE_0)
+		REG_UPDATE_2(DCSURF_SURFACE_CONFIG,
+				ROTATION_ANGLE, 0,
+				H_MIRROR_EN, mirror);
+	else if (rotation == ROTATION_ANGLE_90)
+		REG_UPDATE_2(DCSURF_SURFACE_CONFIG,
+				ROTATION_ANGLE, 1,
+				H_MIRROR_EN, mirror);
+	else if (rotation == ROTATION_ANGLE_180)
+		REG_UPDATE_2(DCSURF_SURFACE_CONFIG,
+				ROTATION_ANGLE, 2,
+				H_MIRROR_EN, mirror);
+	else if (rotation == ROTATION_ANGLE_270)
+		REG_UPDATE_2(DCSURF_SURFACE_CONFIG,
+				ROTATION_ANGLE, 3,
+				H_MIRROR_EN, mirror);
+}
+
+static void program_pixel_format(
+	struct dcn10_mem_input *mi,
+	enum surface_pixel_format format)
+{
+	uint32_t red_bar = 3;
+	uint32_t blue_bar = 2;
+
+	/* swap for ABGR format */
+	if (format == SURFACE_PIXEL_FORMAT_GRPH_ABGR8888
+			|| format == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010
+			|| format == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS
+			|| format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F) {
+		red_bar = 2;
+		blue_bar = 3;
+	}
+
+	REG_UPDATE_2(HUBPRET_CONTROL,
+			CROSSBAR_SRC_CB_B, blue_bar,
+			CROSSBAR_SRC_CR_R, red_bar);
+
+	/* Mapping is same as ipp programming (cnvc) */
+
+	switch (format)	{
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 1);
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 3);
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 8);
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 10);
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 22);
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:/*we use crossbar already*/
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 24);
+		break;
+
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 65);
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 64);
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 67);
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		REG_UPDATE(DCSURF_SURFACE_CONFIG,
+				SURFACE_PIXEL_FORMAT, 66);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+
+	/* don't see the need of program the xbar in DCN 1.0 */
+}
+
+static bool mem_input_program_surface_flip_and_addr(
+	struct mem_input *mem_input,
+	const struct dc_plane_address *address,
+	bool flip_immediate)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	/* program flip type */
+
+	REG_UPDATE(DCSURF_FLIP_CONTROL,
+			SURFACE_FLIP_TYPE, flip_immediate);
+
+	/* REG_UPDATE(FLIP_CONTROL, SURFACE_UPDATE_LOCK, 1); */
+
+
+	/* program high first and then the low addr, order matters! */
+	switch (address->type) {
+	case PLN_ADDR_TYPE_GRAPHICS:
+		if (address->grph.addr.quad_part == 0)
+			break;
+
+		if (address->grph.meta_addr.quad_part != 0) {
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH,
+					PRIMARY_META_SURFACE_ADDRESS_HIGH,
+					address->grph.meta_addr.high_part);
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS,
+					PRIMARY_META_SURFACE_ADDRESS,
+					address->grph.meta_addr.low_part);
+		}
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH,
+				PRIMARY_SURFACE_ADDRESS_HIGH,
+				address->grph.addr.high_part);
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS,
+				PRIMARY_SURFACE_ADDRESS,
+				address->grph.addr.low_part);
+
+
+		/* DCN1.0 does not support const color
+		 * TODO: program DCHUBBUB_RET_PATH_DCC_CFGx_0/1
+		 * base on address->grph.dcc_const_color
+		 * x = 0, 2, 4, 6 for pipe 0, 1, 2, 3 for rgb and luma
+		 * x = 1, 3, 5, 7 for pipe 0, 1, 2, 3 for chroma
+		 */
+		break;
+	case PLN_ADDR_TYPE_VIDEO_PROGRESSIVE:
+		if (address->video_progressive.luma_addr.quad_part == 0
+			|| address->video_progressive.chroma_addr.quad_part == 0)
+			break;
+
+		if (address->video_progressive.luma_meta_addr.quad_part != 0) {
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH,
+				PRIMARY_META_SURFACE_ADDRESS_HIGH,
+				address->video_progressive.luma_meta_addr.high_part);
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS,
+				PRIMARY_META_SURFACE_ADDRESS,
+				address->video_progressive.luma_meta_addr.low_part);
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH_C,
+				PRIMARY_META_SURFACE_ADDRESS_HIGH_C,
+				address->video_progressive.chroma_meta_addr.high_part);
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS_C,
+				PRIMARY_META_SURFACE_ADDRESS_C,
+				address->video_progressive.chroma_meta_addr.low_part);
+		}
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH,
+			PRIMARY_SURFACE_ADDRESS_HIGH,
+			address->video_progressive.luma_addr.high_part);
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS,
+			PRIMARY_SURFACE_ADDRESS,
+			address->video_progressive.luma_addr.low_part);
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH_C,
+			PRIMARY_SURFACE_ADDRESS_HIGH_C,
+			address->video_progressive.chroma_addr.high_part);
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS_C,
+			PRIMARY_SURFACE_ADDRESS_C,
+			address->video_progressive.chroma_addr.low_part);
+
+		break;
+	case PLN_ADDR_TYPE_GRPH_STEREO:
+		if (address->grph_stereo.left_addr.quad_part == 0)
+			break;
+		if (address->grph_stereo.right_addr.quad_part == 0)
+			break;
+		if (address->grph_stereo.right_meta_addr.quad_part != 0) {
+
+			REG_UPDATE(DCSURF_SECONDARY_META_SURFACE_ADDRESS_HIGH,
+					SECONDARY_META_SURFACE_ADDRESS_HIGH,
+					address->grph_stereo.right_meta_addr.high_part);
+
+			REG_UPDATE(DCSURF_SECONDARY_META_SURFACE_ADDRESS,
+					SECONDARY_META_SURFACE_ADDRESS,
+					address->grph_stereo.right_meta_addr.low_part);
+		}
+		if (address->grph_stereo.left_meta_addr.quad_part != 0) {
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH,
+					PRIMARY_META_SURFACE_ADDRESS_HIGH,
+					address->grph_stereo.left_meta_addr.high_part);
+
+			REG_UPDATE(DCSURF_PRIMARY_META_SURFACE_ADDRESS,
+					PRIMARY_META_SURFACE_ADDRESS,
+					address->grph_stereo.left_meta_addr.low_part);
+		}
+
+		REG_UPDATE(DCSURF_SECONDARY_SURFACE_ADDRESS_HIGH,
+				SECONDARY_SURFACE_ADDRESS_HIGH,
+				address->grph_stereo.right_addr.high_part);
+
+		REG_UPDATE(DCSURF_SECONDARY_SURFACE_ADDRESS,
+				SECONDARY_SURFACE_ADDRESS,
+				address->grph_stereo.right_addr.low_part);
+
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH,
+				PRIMARY_SURFACE_ADDRESS_HIGH,
+				address->grph_stereo.left_addr.high_part);
+
+		REG_UPDATE(DCSURF_PRIMARY_SURFACE_ADDRESS,
+				PRIMARY_SURFACE_ADDRESS,
+				address->grph_stereo.left_addr.low_part);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+	/* REG_UPDATE(FLIP_CONTROL, SURFACE_UPDATE_LOCK, 0); */
+
+	mem_input->request_address = *address;
+
+	if (flip_immediate)
+		mem_input->current_address = *address;
+
+	return true;
+}
+
+static void program_control(struct dcn10_mem_input *mi,
+		struct dc_plane_dcc_param *dcc)
+{
+	uint32_t dcc_en = dcc->enable ? 1 : 0;
+	uint32_t dcc_ind_64b_blk = dcc->grph.independent_64b_blks ? 1 : 0;
+
+	REG_UPDATE_2(DCSURF_SURFACE_CONTROL,
+			PRIMARY_SURFACE_DCC_EN, dcc_en,
+			PRIMARY_SURFACE_DCC_IND_64B_BLK, dcc_ind_64b_blk);
+
+}
+
+static void mem_input_program_surface_config(
+	struct mem_input *mem_input,
+	enum surface_pixel_format format,
+	union dc_tiling_info *tiling_info,
+	union plane_size *plane_size,
+	enum dc_rotation_angle rotation,
+	struct dc_plane_dcc_param *dcc,
+	bool horizontal_mirror,
+	bool visible)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	program_control(mi, dcc);
+	program_tiling(mi, tiling_info, format);
+	program_size_and_rotation(
+		mi, rotation, format, plane_size, dcc, horizontal_mirror);
+	program_pixel_format(mi, format);
+
+	set_blank(mi, !visible);
+}
+
+static void program_requestor(
+		struct mem_input *mem_input,
+		struct _vcs_dpi_display_rq_regs_st *rq_regs)
+{
+
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	REG_UPDATE(HUBPRET_CONTROL,
+			DET_BUF_PLANE1_BASE_ADDRESS, rq_regs->plane1_base_address);
+	REG_SET_4(DCN_EXPANSION_MODE, 0,
+			DRQ_EXPANSION_MODE, rq_regs->drq_expansion_mode,
+			PRQ_EXPANSION_MODE, rq_regs->prq_expansion_mode,
+			MRQ_EXPANSION_MODE, rq_regs->mrq_expansion_mode,
+			CRQ_EXPANSION_MODE, rq_regs->crq_expansion_mode);
+	REG_SET_8(DCHUBP_REQ_SIZE_CONFIG, 0,
+		CHUNK_SIZE, rq_regs->rq_regs_l.chunk_size,
+		MIN_CHUNK_SIZE, rq_regs->rq_regs_l.min_chunk_size,
+		META_CHUNK_SIZE, rq_regs->rq_regs_l.meta_chunk_size,
+		MIN_META_CHUNK_SIZE, rq_regs->rq_regs_l.min_meta_chunk_size,
+		DPTE_GROUP_SIZE, rq_regs->rq_regs_l.dpte_group_size,
+		MPTE_GROUP_SIZE, rq_regs->rq_regs_l.mpte_group_size,
+		SWATH_HEIGHT, rq_regs->rq_regs_l.swath_height,
+		PTE_ROW_HEIGHT_LINEAR, rq_regs->rq_regs_l.pte_row_height_linear);
+	REG_SET_8(DCHUBP_REQ_SIZE_CONFIG_C, 0,
+		CHUNK_SIZE_C, rq_regs->rq_regs_c.chunk_size,
+		MIN_CHUNK_SIZE_C, rq_regs->rq_regs_c.min_chunk_size,
+		META_CHUNK_SIZE_C, rq_regs->rq_regs_c.meta_chunk_size,
+		MIN_META_CHUNK_SIZE_C, rq_regs->rq_regs_c.min_meta_chunk_size,
+		DPTE_GROUP_SIZE_C, rq_regs->rq_regs_c.dpte_group_size,
+		MPTE_GROUP_SIZE_C, rq_regs->rq_regs_c.mpte_group_size,
+		SWATH_HEIGHT_C, rq_regs->rq_regs_c.swath_height,
+		PTE_ROW_HEIGHT_LINEAR_C, rq_regs->rq_regs_c.pte_row_height_linear);
+}
+
+
+static void program_deadline(
+		struct mem_input *mem_input,
+		struct _vcs_dpi_display_dlg_regs_st *dlg_attr,
+		struct _vcs_dpi_display_ttu_regs_st *ttu_attr)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	/* DLG - Per hubp */
+	REG_SET_2(BLANK_OFFSET_0, 0,
+		REFCYC_H_BLANK_END, dlg_attr->refcyc_h_blank_end,
+		DLG_V_BLANK_END, dlg_attr->dlg_vblank_end);
+
+	REG_SET(BLANK_OFFSET_1, 0,
+		MIN_DST_Y_NEXT_START, dlg_attr->min_dst_y_next_start);
+
+	REG_SET(DST_DIMENSIONS, 0,
+		REFCYC_PER_HTOTAL, dlg_attr->refcyc_per_htotal);
+
+	REG_SET_2(DST_AFTER_SCALER, 0,
+		REFCYC_X_AFTER_SCALER, dlg_attr->refcyc_x_after_scaler,
+		DST_Y_AFTER_SCALER, dlg_attr->dst_y_after_scaler);
+
+	REG_SET_2(PREFETCH_SETTINS, 0,
+		DST_Y_PREFETCH, dlg_attr->dst_y_prefetch,
+		VRATIO_PREFETCH, dlg_attr->vratio_prefetch);
+
+	REG_SET_2(VBLANK_PARAMETERS_0, 0,
+		DST_Y_PER_VM_VBLANK, dlg_attr->dst_y_per_vm_vblank,
+		DST_Y_PER_ROW_VBLANK, dlg_attr->dst_y_per_row_vblank);
+
+	REG_SET(REF_FREQ_TO_PIX_FREQ, 0,
+		REF_FREQ_TO_PIX_FREQ, dlg_attr->ref_freq_to_pix_freq);
+
+	/* DLG - Per luma/chroma */
+	REG_SET(VBLANK_PARAMETERS_1, 0,
+		REFCYC_PER_PTE_GROUP_VBLANK_L, dlg_attr->refcyc_per_pte_group_vblank_l);
+
+	REG_SET(VBLANK_PARAMETERS_3, 0,
+		REFCYC_PER_META_CHUNK_VBLANK_L, dlg_attr->refcyc_per_meta_chunk_vblank_l);
+
+	REG_SET(NOM_PARAMETERS_0, 0,
+		DST_Y_PER_PTE_ROW_NOM_L, dlg_attr->dst_y_per_pte_row_nom_l);
+
+	REG_SET(NOM_PARAMETERS_1, 0,
+		REFCYC_PER_PTE_GROUP_NOM_L, dlg_attr->refcyc_per_pte_group_nom_l);
+
+	REG_SET(NOM_PARAMETERS_4, 0,
+		DST_Y_PER_META_ROW_NOM_L, dlg_attr->dst_y_per_meta_row_nom_l);
+
+	REG_SET(NOM_PARAMETERS_5, 0,
+		REFCYC_PER_META_CHUNK_NOM_L, dlg_attr->refcyc_per_meta_chunk_nom_l);
+
+	REG_SET_2(PER_LINE_DELIVERY_PRE, 0,
+		REFCYC_PER_LINE_DELIVERY_PRE_L, dlg_attr->refcyc_per_line_delivery_pre_l,
+		REFCYC_PER_LINE_DELIVERY_PRE_C, dlg_attr->refcyc_per_line_delivery_pre_c);
+
+	REG_SET_2(PER_LINE_DELIVERY, 0,
+		REFCYC_PER_LINE_DELIVERY_L, dlg_attr->refcyc_per_line_delivery_l,
+		REFCYC_PER_LINE_DELIVERY_C, dlg_attr->refcyc_per_line_delivery_c);
+
+	REG_SET(PREFETCH_SETTINS_C, 0,
+		VRATIO_PREFETCH_C, dlg_attr->vratio_prefetch_c);
+
+	REG_SET(VBLANK_PARAMETERS_2, 0,
+		REFCYC_PER_PTE_GROUP_VBLANK_C, dlg_attr->refcyc_per_pte_group_vblank_c);
+
+	REG_SET(VBLANK_PARAMETERS_4, 0,
+		REFCYC_PER_META_CHUNK_VBLANK_C, dlg_attr->refcyc_per_meta_chunk_vblank_c);
+
+	REG_SET(NOM_PARAMETERS_2, 0,
+		DST_Y_PER_PTE_ROW_NOM_C, dlg_attr->dst_y_per_pte_row_nom_c);
+
+	REG_SET(NOM_PARAMETERS_3, 0,
+		REFCYC_PER_PTE_GROUP_NOM_C, dlg_attr->refcyc_per_pte_group_nom_c);
+
+	REG_SET(NOM_PARAMETERS_6, 0,
+		DST_Y_PER_META_ROW_NOM_C, dlg_attr->dst_y_per_meta_row_nom_c);
+
+	REG_SET(NOM_PARAMETERS_7, 0,
+		REFCYC_PER_META_CHUNK_NOM_C, dlg_attr->refcyc_per_meta_chunk_nom_c);
+
+	/* TTU - per hubp */
+	REG_SET_2(DCN_TTU_QOS_WM, 0,
+		QoS_LEVEL_LOW_WM, ttu_attr->qos_level_low_wm,
+		QoS_LEVEL_HIGH_WM, ttu_attr->qos_level_high_wm);
+
+	REG_SET_2(DCN_GLOBAL_TTU_CNTL, 0,
+		MIN_TTU_VBLANK, ttu_attr->min_ttu_vblank,
+		QoS_LEVEL_FLIP, ttu_attr->qos_level_flip);
+
+	/* TTU - per luma/chroma */
+	/* Assumed surf0 is luma and 1 is chroma */
+
+	REG_SET_3(DCN_SURF0_TTU_CNTL0, 0,
+		REFCYC_PER_REQ_DELIVERY, ttu_attr->refcyc_per_req_delivery_l,
+		QoS_LEVEL_FIXED, ttu_attr->qos_level_fixed_l,
+		QoS_RAMP_DISABLE, ttu_attr->qos_ramp_disable_l);
+
+	REG_SET(DCN_SURF0_TTU_CNTL1, 0,
+		REFCYC_PER_REQ_DELIVERY_PRE,
+		ttu_attr->refcyc_per_req_delivery_pre_l);
+
+	REG_SET_3(DCN_SURF1_TTU_CNTL0, 0,
+		REFCYC_PER_REQ_DELIVERY, ttu_attr->refcyc_per_req_delivery_c,
+		QoS_LEVEL_FIXED, ttu_attr->qos_level_fixed_c,
+		QoS_RAMP_DISABLE, ttu_attr->qos_ramp_disable_c);
+
+	REG_SET(DCN_SURF1_TTU_CNTL1, 0,
+		REFCYC_PER_REQ_DELIVERY_PRE,
+		ttu_attr->refcyc_per_req_delivery_pre_c);
+}
+
+static void mem_input_setup(
+		struct mem_input *mem_input,
+		struct _vcs_dpi_display_dlg_regs_st *dlg_attr,
+		struct _vcs_dpi_display_ttu_regs_st *ttu_attr,
+		struct _vcs_dpi_display_rq_regs_st *rq_regs,
+		struct _vcs_dpi_display_pipe_dest_params_st *pipe_dest)
+{
+	/* otg is locked when this func is called. Register are double buffered.
+	 * disable the requestors is not needed
+	 */
+	/* disable_request(mem_input); */
+	program_requestor(mem_input, rq_regs);
+	program_deadline(mem_input, dlg_attr, ttu_attr);
+	vready_workaround(mem_input, pipe_dest);
+}
+
+static uint32_t convert_and_clamp(
+	uint32_t wm_ns,
+	uint32_t refclk_mhz,
+	uint32_t clamp_value)
+{
+	uint32_t ret_val = 0;
+	ret_val = wm_ns * refclk_mhz;
+	ret_val /= 1000;
+
+	if (ret_val > clamp_value)
+		ret_val = clamp_value;
+
+	return ret_val;
+}
+
+static void program_watermarks(
+		struct mem_input *mem_input,
+		struct dcn_watermark_set *watermarks,
+		unsigned int refclk_mhz)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	/*
+	 * Need to clamp to max of the register values (i.e. no wrap)
+	 * for dcn1, all wm registers are 21-bit wide
+	 */
+	uint32_t prog_wm_value;
+
+	/* Repeat for water mark set A, B, C and D. */
+	/* clock state A */
+	prog_wm_value = convert_and_clamp(watermarks->a.urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, prog_wm_value);
+
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.urgent_ns, prog_wm_value);
+
+	prog_wm_value = convert_and_clamp(watermarks->a.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->a.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->a.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n\n",
+		watermarks->a.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+
+	/* clock state B */
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.urgent_ns, refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\n\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+	/* clock state C */
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.urgent_ns, refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\n\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+	/* clock state D */
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.urgent_ns, refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.urgent_ns, prog_wm_value);
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, prog_wm_value);
+	dm_logger_write(mem_input->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n\n",
+		watermarks->d.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
+	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 0);
+	REG_UPDATE(DCHUBBUB_ARB_SAT_LEVEL,
+			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
+	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND,
+			DCHUBBUB_ARB_MIN_REQ_OUTSTAND, 68);
+
+#if 0
+	REG_UPDATE_2(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_DONE_INTERRUPT_DISABLE, 1,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
+#endif
+}
+
+static void mem_input_program_display_marks(
+	struct mem_input *mem_input,
+	struct bw_watermarks nbp,
+	struct bw_watermarks stutter,
+	struct bw_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	/* only for dce
+	 * dcn use only program_watermarks
+	 */
+}
+
+bool mem_input_is_flip_pending(struct mem_input *mem_input)
+{
+	uint32_t update_pending = 0;
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+
+	REG_GET(DCSURF_FLIP_CONTROL,
+			SURFACE_UPDATE_PENDING, &update_pending);
+
+	if (update_pending)
+		return true;
+
+	mem_input->current_address = mem_input->request_address;
+	return false;
+}
+
+static void mem_input_update_dchub(
+	struct mem_input *mem_input,
+	struct dchub_init_data *dh_data)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	/* TODO: port code from dal2 */
+	switch (dh_data->fb_mode) {
+	case FRAME_BUFFER_MODE_ZFB_ONLY:
+		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
+		REG_UPDATE(DCHUBBUB_SDPIF_FB_TOP,
+				SDPIF_FB_TOP, 0);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_FB_BASE,
+				SDPIF_FB_BASE, 0x0FFFF);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_LOCAL_ONLY:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, 0);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, 0X03FFFF);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, 0);
+		break;
+	default:
+		break;
+	}
+
+	dh_data->dchub_initialzied = true;
+	dh_data->dchub_info_valid = false;
+}
+
+struct vm_system_aperture_param {
+	PHYSICAL_ADDRESS_LOC sys_default;
+	PHYSICAL_ADDRESS_LOC sys_low;
+	PHYSICAL_ADDRESS_LOC sys_high;
+};
+
+static void read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
+		struct vm_system_aperture_param *apt)
+{
+	PHYSICAL_ADDRESS_LOC physical_page_number;
+	uint32_t logical_addr_low;
+	uint32_t logical_addr_high;
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,
+			PHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,
+			PHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,
+			LOGICAL_ADDR, &logical_addr_low);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,
+			LOGICAL_ADDR, &logical_addr_high);
+
+	apt->sys_default.quad_part =  physical_page_number.quad_part << 12;
+	apt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;
+	apt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;
+}
+
+static void set_vm_system_aperture_settings(struct dcn10_mem_input *mi,
+		struct vm_system_aperture_param *apt)
+{
+	PHYSICAL_ADDRESS_LOC mc_vm_apt_default;
+	PHYSICAL_ADDRESS_LOC mc_vm_apt_low;
+	PHYSICAL_ADDRESS_LOC mc_vm_apt_high;
+
+	mc_vm_apt_default.quad_part = apt->sys_default.quad_part >> 12;
+	mc_vm_apt_low.quad_part = apt->sys_low.quad_part >> 12;
+	mc_vm_apt_high.quad_part = apt->sys_high.quad_part >> 12;
+
+	REG_SET_2(DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0,
+		MC_VM_SYSTEM_APERTURE_DEFAULT_SYSTEM, 1, /* 1 = system physical memory */
+		MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, mc_vm_apt_default.high_part);
+	REG_SET(DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0,
+		MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, mc_vm_apt_default.low_part);
+
+	REG_SET(DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0,
+			MC_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, mc_vm_apt_low.high_part);
+	REG_SET(DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0,
+			MC_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, mc_vm_apt_low.low_part);
+
+	REG_SET(DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0,
+			MC_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, mc_vm_apt_high.high_part);
+	REG_SET(DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0,
+			MC_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, mc_vm_apt_high.low_part);
+}
+
+struct vm_context0_param {
+	PHYSICAL_ADDRESS_LOC pte_base;
+	PHYSICAL_ADDRESS_LOC pte_start;
+	PHYSICAL_ADDRESS_LOC pte_end;
+	PHYSICAL_ADDRESS_LOC fault_default;
+};
+
+/* Temporary read settings, future will get values from kmd directly */
+static void read_vm_context0_settings(struct dcn10_mem_input *mi,
+		struct vm_context0_param *vm0)
+{
+	PHYSICAL_ADDRESS_LOC fb_base;
+	PHYSICAL_ADDRESS_LOC fb_offset;
+	uint32_t fb_base_value;
+	uint32_t fb_offset_value;
+
+	REG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);
+	REG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,
+			PAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,
+			PAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);
+
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,
+			PHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,
+			PHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);
+
+	/*
+	 * The values in VM_CONTEXT0_PAGE_TABLE_BASE_ADDR is in UMA space.
+	 * Therefore we need to do
+	 * DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
+	 * - DCHUBBUB_SDPIF_FB_OFFSET + DCHUBBUB_SDPIF_FB_BASE
+	 */
+	fb_base.quad_part = (uint64_t)fb_base_value << 24;
+	fb_offset.quad_part = (uint64_t)fb_offset_value << 24;
+	vm0->pte_base.quad_part += fb_base.quad_part;
+	vm0->pte_base.quad_part -= fb_offset.quad_part;
+}
+
+static void set_vm_context0_settings(struct dcn10_mem_input *mi,
+		const struct vm_context0_param *vm0)
+{
+	/* pte base */
+	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, vm0->pte_base.high_part);
+	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB, vm0->pte_base.low_part);
+
+	/* pte start */
+	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB, vm0->pte_start.high_part);
+	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB, vm0->pte_start.low_part);
+
+	/* pte end */
+	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB, vm0->pte_end.high_part);
+	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB, vm0->pte_end.low_part);
+
+	/* fault handling */
+	REG_SET(DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_MSB, 0,
+			VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB, vm0->fault_default.high_part);
+	/* VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_SYSTEM, 0 */
+	REG_SET(DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, 0,
+			VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, vm0->fault_default.low_part);
+}
+
+void dcn_mem_input_program_pte_vm(struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct vm_system_aperture_param apt = { {{ 0 } } };
+	struct vm_context0_param vm0 = { { { 0 } } };
+
+
+	read_vm_system_aperture_settings(mi, &apt);
+	read_vm_context0_settings(mi, &vm0);
+
+	set_vm_system_aperture_settings(mi, &apt);
+	set_vm_context0_settings(mi, &vm0);
+
+	/* control: enable VM PTE*/
+	REG_SET_2(DCN_VM_MX_L1_TLB_CNTL, 0,
+			ENABLE_L1_TLB, 1,
+			SYSTEM_ACCESS_MODE, 3);
+}
+
+static struct mem_input_funcs dcn10_mem_input_funcs = {
+	.mem_input_program_display_marks = mem_input_program_display_marks,
+	.allocate_mem_input = NULL,
+	.free_mem_input = NULL,
+	.disable_request = disable_request,
+	.mem_input_program_surface_flip_and_addr =
+			mem_input_program_surface_flip_and_addr,
+	.mem_input_program_surface_config =
+			mem_input_program_surface_config,
+	.mem_input_is_flip_pending = mem_input_is_flip_pending,
+	.mem_input_setup = mem_input_setup,
+	.program_watermarks = program_watermarks,
+	.mem_input_update_dchub = mem_input_update_dchub,
+	.mem_input_program_pte_vm = dcn_mem_input_program_pte_vm,
+};
+
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+bool dcn10_mem_input_construct(
+	struct dcn10_mem_input *mi,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn_mi_registers *mi_regs,
+	const struct dcn_mi_shift *mi_shift,
+	const struct dcn_mi_mask *mi_mask)
+{
+	mi->base.funcs = &dcn10_mem_input_funcs;
+	mi->base.ctx = ctx;
+	mi->mi_regs = mi_regs;
+	mi->mi_shift = mi_shift;
+	mi->mi_mask = mi_mask;
+	mi->base.inst = inst;
+
+	return true;
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
new file mode 100644
index 0000000..4a5eb6a
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
@@ -0,0 +1,553 @@
+/* Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_MEM_INPUT_DCN10_H__
+#define __DC_MEM_INPUT_DCN10_H__
+
+#include "mem_input.h"
+
+#define TO_DCN10_MEM_INPUT(mi)\
+	container_of(mi, struct dcn10_mem_input, base)
+
+
+#define MI_DCN10_REG_LIST(id)\
+	SRI(DCHUBP_CNTL, HUBP, id),\
+	SRI(HUBPREQ_DEBUG_DB, HUBP, id),\
+	SRI(DCSURF_ADDR_CONFIG, HUBP, id),\
+	SRI(DCSURF_TILING_CONFIG, HUBP, id),\
+	SRI(DCSURF_SURFACE_PITCH, HUBPREQ, id),\
+	SRI(DCSURF_SURFACE_PITCH_C, HUBPREQ, id),\
+	SRI(DCSURF_SURFACE_CONFIG, HUBP, id),\
+	SRI(DCSURF_FLIP_CONTROL, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_SURFACE_ADDRESS, HUBPREQ, id),\
+	SRI(DCSURF_SECONDARY_SURFACE_ADDRESS_HIGH, HUBPREQ, id),\
+	SRI(DCSURF_SECONDARY_SURFACE_ADDRESS, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_META_SURFACE_ADDRESS, HUBPREQ, id),\
+	SRI(DCSURF_SECONDARY_META_SURFACE_ADDRESS_HIGH, HUBPREQ, id),\
+	SRI(DCSURF_SECONDARY_META_SURFACE_ADDRESS, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH_C, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_SURFACE_ADDRESS_C, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH_C, HUBPREQ, id),\
+	SRI(DCSURF_PRIMARY_META_SURFACE_ADDRESS_C, HUBPREQ, id),\
+	SRI(DCSURF_SURFACE_CONTROL, HUBPREQ, id),\
+	SRI(HUBPRET_CONTROL, HUBPRET, id),\
+	SRI(DCN_EXPANSION_MODE, HUBPREQ, id),\
+	SRI(DCHUBP_REQ_SIZE_CONFIG, HUBP, id),\
+	SRI(DCHUBP_REQ_SIZE_CONFIG_C, HUBP, id),\
+	SRI(BLANK_OFFSET_0, HUBPREQ, id),\
+	SRI(BLANK_OFFSET_1, HUBPREQ, id),\
+	SRI(DST_DIMENSIONS, HUBPREQ, id),\
+	SRI(DST_AFTER_SCALER, HUBPREQ, id),\
+	SRI(PREFETCH_SETTINS, HUBPREQ, id),\
+	SRI(VBLANK_PARAMETERS_0, HUBPREQ, id),\
+	SRI(REF_FREQ_TO_PIX_FREQ, HUBPREQ, id),\
+	SRI(VBLANK_PARAMETERS_1, HUBPREQ, id),\
+	SRI(VBLANK_PARAMETERS_3, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_0, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_1, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_4, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_5, HUBPREQ, id),\
+	SRI(PER_LINE_DELIVERY_PRE, HUBPREQ, id),\
+	SRI(PER_LINE_DELIVERY, HUBPREQ, id),\
+	SRI(PREFETCH_SETTINS_C, HUBPREQ, id),\
+	SRI(VBLANK_PARAMETERS_2, HUBPREQ, id),\
+	SRI(VBLANK_PARAMETERS_4, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_2, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_3, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_6, HUBPREQ, id),\
+	SRI(NOM_PARAMETERS_7, HUBPREQ, id),\
+	SRI(DCN_TTU_QOS_WM, HUBPREQ, id),\
+	SRI(DCN_GLOBAL_TTU_CNTL, HUBPREQ, id),\
+	SRI(DCN_SURF0_TTU_CNTL0, HUBPREQ, id),\
+	SRI(DCN_SURF0_TTU_CNTL1, HUBPREQ, id),\
+	SRI(DCN_SURF1_TTU_CNTL0, HUBPREQ, id),\
+	SRI(DCN_SURF1_TTU_CNTL1, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, HUBPREQ, id),\
+	SRI(DCN_VM_MX_L1_TLB_CNTL, HUBPREQ, id),\
+	SRI(DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, HUBPREQ, id),\
+	SRI(DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, HUBPREQ, id),\
+	SRI(DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, HUBPREQ, id),\
+	SRI(DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, HUBPREQ, id),\
+	SR(DCHUBBUB_SDPIF_FB_TOP),\
+	SR(DCHUBBUB_SDPIF_FB_BASE),\
+	SR(DCHUBBUB_SDPIF_FB_OFFSET),\
+	SR(DCHUBBUB_SDPIF_AGP_BASE),\
+	SR(DCHUBBUB_SDPIF_AGP_BOT),\
+	SR(DCHUBBUB_SDPIF_AGP_TOP),\
+	SR(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A),\
+	SR(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A),\
+	SR(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A),\
+	SR(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B),\
+	SR(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B),\
+	SR(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B),\
+	SR(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C),\
+	SR(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C),\
+	SR(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C),\
+	SR(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D),\
+	SR(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D),\
+	SR(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D),\
+	SR(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D),\
+	SR(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL),\
+	SR(DCHUBBUB_ARB_SAT_LEVEL),\
+	SR(DCHUBBUB_ARB_DF_REQ_OUTSTAND),\
+	/* todo:  get these from GVM instead of reading registers ourselves */\
+	GC_SR(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32),\
+	GC_SR(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32),\
+	GC_SR(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32),\
+	GC_SR(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32),\
+	GC_SR(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32),\
+	GC_SR(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32),\
+	GC_SR(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32),\
+	GC_SR(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32),\
+	GC_SR(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB),\
+	GC_SR(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB),\
+	GC_SR(MC_VM_SYSTEM_APERTURE_LOW_ADDR),\
+	GC_SR(MC_VM_SYSTEM_APERTURE_HIGH_ADDR)
+
+struct dcn_mi_registers {
+	uint32_t DCHUBP_CNTL;
+	uint32_t HUBPREQ_DEBUG_DB;
+	uint32_t DCSURF_ADDR_CONFIG;
+	uint32_t DCSURF_TILING_CONFIG;
+	uint32_t DCSURF_SURFACE_PITCH;
+	uint32_t DCSURF_SURFACE_PITCH_C;
+	uint32_t DCSURF_SURFACE_CONFIG;
+	uint32_t DCSURF_FLIP_CONTROL;
+	uint32_t DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH;
+	uint32_t DCSURF_PRIMARY_SURFACE_ADDRESS;
+	uint32_t DCSURF_SECONDARY_SURFACE_ADDRESS_HIGH;
+	uint32_t DCSURF_SECONDARY_SURFACE_ADDRESS;
+	uint32_t DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH;
+	uint32_t DCSURF_PRIMARY_META_SURFACE_ADDRESS;
+	uint32_t DCSURF_SECONDARY_META_SURFACE_ADDRESS_HIGH;
+	uint32_t DCSURF_SECONDARY_META_SURFACE_ADDRESS;
+	uint32_t DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH_C;
+	uint32_t DCSURF_PRIMARY_SURFACE_ADDRESS_C;
+	uint32_t DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH_C;
+	uint32_t DCSURF_PRIMARY_META_SURFACE_ADDRESS_C;
+	uint32_t DCSURF_SURFACE_CONTROL;
+	uint32_t HUBPRET_CONTROL;
+	uint32_t DCN_EXPANSION_MODE;
+	uint32_t DCHUBP_REQ_SIZE_CONFIG;
+	uint32_t DCHUBP_REQ_SIZE_CONFIG_C;
+	uint32_t BLANK_OFFSET_0;
+	uint32_t BLANK_OFFSET_1;
+	uint32_t DST_DIMENSIONS;
+	uint32_t DST_AFTER_SCALER;
+	uint32_t PREFETCH_SETTINS;
+	uint32_t VBLANK_PARAMETERS_0;
+	uint32_t REF_FREQ_TO_PIX_FREQ;
+	uint32_t VBLANK_PARAMETERS_1;
+	uint32_t VBLANK_PARAMETERS_3;
+	uint32_t NOM_PARAMETERS_0;
+	uint32_t NOM_PARAMETERS_1;
+	uint32_t NOM_PARAMETERS_4;
+	uint32_t NOM_PARAMETERS_5;
+	uint32_t PER_LINE_DELIVERY_PRE;
+	uint32_t PER_LINE_DELIVERY;
+	uint32_t PREFETCH_SETTINS_C;
+	uint32_t VBLANK_PARAMETERS_2;
+	uint32_t VBLANK_PARAMETERS_4;
+	uint32_t NOM_PARAMETERS_2;
+	uint32_t NOM_PARAMETERS_3;
+	uint32_t NOM_PARAMETERS_6;
+	uint32_t NOM_PARAMETERS_7;
+	uint32_t DCN_TTU_QOS_WM;
+	uint32_t DCN_GLOBAL_TTU_CNTL;
+	uint32_t DCN_SURF0_TTU_CNTL0;
+	uint32_t DCN_SURF0_TTU_CNTL1;
+	uint32_t DCN_SURF1_TTU_CNTL0;
+	uint32_t DCN_SURF1_TTU_CNTL1;
+	uint32_t DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB;
+	uint32_t DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB;
+	uint32_t DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB;
+	uint32_t DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB;
+	uint32_t DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB;
+	uint32_t DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB;
+	uint32_t DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_MSB;
+	uint32_t DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB;
+	uint32_t DCN_VM_MX_L1_TLB_CNTL;
+	uint32_t DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB;
+	uint32_t DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB;
+	uint32_t DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB;
+	uint32_t DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB;
+	uint32_t DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB;
+	uint32_t DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB;
+	uint32_t DCHUBBUB_SDPIF_FB_TOP;
+	uint32_t DCHUBBUB_SDPIF_FB_BASE;
+	uint32_t DCHUBBUB_SDPIF_FB_OFFSET;
+	uint32_t DCHUBBUB_SDPIF_AGP_BASE;
+	uint32_t DCHUBBUB_SDPIF_AGP_BOT;
+	uint32_t DCHUBBUB_SDPIF_AGP_TOP;
+	uint32_t DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A;
+	uint32_t DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A;
+	uint32_t DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A;
+	uint32_t DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B;
+	uint32_t DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B;
+	uint32_t DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B;
+	uint32_t DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C;
+	uint32_t DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C;
+	uint32_t DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C;
+	uint32_t DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D;
+	uint32_t DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D;
+	uint32_t DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D;
+	uint32_t DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D;
+	uint32_t DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL;
+	uint32_t DCHUBBUB_ARB_SAT_LEVEL;
+	uint32_t DCHUBBUB_ARB_DF_REQ_OUTSTAND;
+
+	/* GC registers. read only. temporary hack */
+	uint32_t VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32;
+	uint32_t VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32;
+	uint32_t VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32;
+	uint32_t MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB;
+	uint32_t MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB;
+	uint32_t MC_VM_SYSTEM_APERTURE_LOW_ADDR;
+	uint32_t MC_VM_SYSTEM_APERTURE_HIGH_ADDR;
+};
+
+#define MI_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define MI_DCN10_MASK_SH_LIST(mask_sh)\
+	MI_SF(HUBP0_DCHUBP_CNTL, HUBP_BLANK_EN, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_CNTL, HUBP_TTU_DISABLE, mask_sh),\
+	MI_SF(HUBP0_DCSURF_ADDR_CONFIG, NUM_PIPES, mask_sh),\
+	MI_SF(HUBP0_DCSURF_ADDR_CONFIG, NUM_BANKS, mask_sh),\
+	MI_SF(HUBP0_DCSURF_ADDR_CONFIG, PIPE_INTERLEAVE, mask_sh),\
+	MI_SF(HUBP0_DCSURF_ADDR_CONFIG, NUM_SE, mask_sh),\
+	MI_SF(HUBP0_DCSURF_ADDR_CONFIG, NUM_RB_PER_SE, mask_sh),\
+	MI_SF(HUBP0_DCSURF_ADDR_CONFIG, MAX_COMPRESSED_FRAGS, mask_sh),\
+	MI_SF(HUBP0_DCSURF_TILING_CONFIG, SW_MODE, mask_sh),\
+	MI_SF(HUBP0_DCSURF_TILING_CONFIG, META_LINEAR, mask_sh),\
+	MI_SF(HUBP0_DCSURF_TILING_CONFIG, RB_ALIGNED, mask_sh),\
+	MI_SF(HUBP0_DCSURF_TILING_CONFIG, PIPE_ALIGNED, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SURFACE_PITCH, PITCH, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SURFACE_PITCH, META_PITCH, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SURFACE_PITCH_C, PITCH_C, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SURFACE_PITCH_C, META_PITCH_C, mask_sh),\
+	MI_SF(HUBP0_DCSURF_SURFACE_CONFIG, ROTATION_ANGLE, mask_sh),\
+	MI_SF(HUBP0_DCSURF_SURFACE_CONFIG, H_MIRROR_EN, mask_sh),\
+	MI_SF(HUBP0_DCSURF_SURFACE_CONFIG, SURFACE_PIXEL_FORMAT, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_FLIP_CONTROL, SURFACE_FLIP_TYPE, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_FLIP_CONTROL, SURFACE_UPDATE_PENDING, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH, PRIMARY_SURFACE_ADDRESS_HIGH, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_SURFACE_ADDRESS, PRIMARY_SURFACE_ADDRESS, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SECONDARY_SURFACE_ADDRESS_HIGH, SECONDARY_SURFACE_ADDRESS_HIGH, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SECONDARY_SURFACE_ADDRESS, SECONDARY_SURFACE_ADDRESS, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH, PRIMARY_META_SURFACE_ADDRESS_HIGH, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_META_SURFACE_ADDRESS, PRIMARY_META_SURFACE_ADDRESS, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SECONDARY_META_SURFACE_ADDRESS_HIGH, SECONDARY_META_SURFACE_ADDRESS_HIGH, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SECONDARY_META_SURFACE_ADDRESS, SECONDARY_META_SURFACE_ADDRESS, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_SURFACE_ADDRESS_HIGH_C, PRIMARY_SURFACE_ADDRESS_HIGH_C, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_SURFACE_ADDRESS_C, PRIMARY_SURFACE_ADDRESS_C, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_META_SURFACE_ADDRESS_HIGH_C, PRIMARY_META_SURFACE_ADDRESS_HIGH_C, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_PRIMARY_META_SURFACE_ADDRESS_C, PRIMARY_META_SURFACE_ADDRESS_C, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SURFACE_CONTROL, PRIMARY_SURFACE_DCC_EN, mask_sh),\
+	MI_SF(HUBPREQ0_DCSURF_SURFACE_CONTROL, PRIMARY_SURFACE_DCC_IND_64B_BLK, mask_sh),\
+	MI_SF(HUBPRET0_HUBPRET_CONTROL, DET_BUF_PLANE1_BASE_ADDRESS, mask_sh),\
+	MI_SF(HUBPRET0_HUBPRET_CONTROL, CROSSBAR_SRC_CB_B, mask_sh),\
+	MI_SF(HUBPRET0_HUBPRET_CONTROL, CROSSBAR_SRC_CR_R, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_EXPANSION_MODE, DRQ_EXPANSION_MODE, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_EXPANSION_MODE, PRQ_EXPANSION_MODE, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_EXPANSION_MODE, MRQ_EXPANSION_MODE, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_EXPANSION_MODE, CRQ_EXPANSION_MODE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, CHUNK_SIZE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, MIN_CHUNK_SIZE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, META_CHUNK_SIZE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, MIN_META_CHUNK_SIZE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, DPTE_GROUP_SIZE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, MPTE_GROUP_SIZE, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, SWATH_HEIGHT, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG, PTE_ROW_HEIGHT_LINEAR, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, CHUNK_SIZE_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, MIN_CHUNK_SIZE_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, META_CHUNK_SIZE_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, MIN_META_CHUNK_SIZE_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, DPTE_GROUP_SIZE_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, MPTE_GROUP_SIZE_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, SWATH_HEIGHT_C, mask_sh),\
+	MI_SF(HUBP0_DCHUBP_REQ_SIZE_CONFIG_C, PTE_ROW_HEIGHT_LINEAR_C, mask_sh),\
+	MI_SF(HUBPREQ0_BLANK_OFFSET_0, REFCYC_H_BLANK_END, mask_sh),\
+	MI_SF(HUBPREQ0_BLANK_OFFSET_0, DLG_V_BLANK_END, mask_sh),\
+	MI_SF(HUBPREQ0_BLANK_OFFSET_1, MIN_DST_Y_NEXT_START, mask_sh),\
+	MI_SF(HUBPREQ0_DST_DIMENSIONS, REFCYC_PER_HTOTAL, mask_sh),\
+	MI_SF(HUBPREQ0_DST_AFTER_SCALER, REFCYC_X_AFTER_SCALER, mask_sh),\
+	MI_SF(HUBPREQ0_DST_AFTER_SCALER, DST_Y_AFTER_SCALER, mask_sh),\
+	MI_SF(HUBPREQ0_PREFETCH_SETTINS, DST_Y_PREFETCH, mask_sh),\
+	MI_SF(HUBPREQ0_PREFETCH_SETTINS, VRATIO_PREFETCH, mask_sh),\
+	MI_SF(HUBPREQ0_VBLANK_PARAMETERS_0, DST_Y_PER_VM_VBLANK, mask_sh),\
+	MI_SF(HUBPREQ0_VBLANK_PARAMETERS_0, DST_Y_PER_ROW_VBLANK, mask_sh),\
+	MI_SF(HUBPREQ0_REF_FREQ_TO_PIX_FREQ, REF_FREQ_TO_PIX_FREQ, mask_sh),\
+	MI_SF(HUBPREQ0_VBLANK_PARAMETERS_1, REFCYC_PER_PTE_GROUP_VBLANK_L, mask_sh),\
+	MI_SF(HUBPREQ0_VBLANK_PARAMETERS_3, REFCYC_PER_META_CHUNK_VBLANK_L, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_0, DST_Y_PER_PTE_ROW_NOM_L, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_1, REFCYC_PER_PTE_GROUP_NOM_L, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_4, DST_Y_PER_META_ROW_NOM_L, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_5, REFCYC_PER_META_CHUNK_NOM_L, mask_sh),\
+	MI_SF(HUBPREQ0_PER_LINE_DELIVERY_PRE, REFCYC_PER_LINE_DELIVERY_PRE_L, mask_sh),\
+	MI_SF(HUBPREQ0_PER_LINE_DELIVERY_PRE, REFCYC_PER_LINE_DELIVERY_PRE_C, mask_sh),\
+	MI_SF(HUBPREQ0_PER_LINE_DELIVERY, REFCYC_PER_LINE_DELIVERY_L, mask_sh),\
+	MI_SF(HUBPREQ0_PER_LINE_DELIVERY, REFCYC_PER_LINE_DELIVERY_C, mask_sh),\
+	MI_SF(HUBPREQ0_PREFETCH_SETTINS_C, VRATIO_PREFETCH_C, mask_sh),\
+	MI_SF(HUBPREQ0_VBLANK_PARAMETERS_2, REFCYC_PER_PTE_GROUP_VBLANK_C, mask_sh),\
+	MI_SF(HUBPREQ0_VBLANK_PARAMETERS_4, REFCYC_PER_META_CHUNK_VBLANK_C, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_2, DST_Y_PER_PTE_ROW_NOM_C, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_3, REFCYC_PER_PTE_GROUP_NOM_C, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_6, DST_Y_PER_META_ROW_NOM_C, mask_sh),\
+	MI_SF(HUBPREQ0_NOM_PARAMETERS_7, REFCYC_PER_META_CHUNK_NOM_C, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_TTU_QOS_WM, QoS_LEVEL_LOW_WM, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_TTU_QOS_WM, QoS_LEVEL_HIGH_WM, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_GLOBAL_TTU_CNTL, MIN_TTU_VBLANK, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_GLOBAL_TTU_CNTL, QoS_LEVEL_FLIP, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_SURF0_TTU_CNTL0, REFCYC_PER_REQ_DELIVERY, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_SURF0_TTU_CNTL0, QoS_LEVEL_FIXED, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_SURF0_TTU_CNTL0, QoS_RAMP_DISABLE, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_SURF0_TTU_CNTL1, REFCYC_PER_REQ_DELIVERY_PRE, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB, VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB, VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB, VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB, VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB, VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_MSB, VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_MX_L1_TLB_CNTL, ENABLE_L1_TLB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_MX_L1_TLB_CNTL, SYSTEM_ACCESS_MODE, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, MC_VM_SYSTEM_APERTURE_DEFAULT_SYSTEM, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, MC_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, MC_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, MC_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, mask_sh),\
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, MC_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, mask_sh),\
+	MI_SF(DCHUBBUB_SDPIF_FB_TOP, SDPIF_FB_TOP, mask_sh),\
+	MI_SF(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, mask_sh),\
+	MI_SF(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, mask_sh),\
+	MI_SF(DCHUBBUB_SDPIF_AGP_BASE, SDPIF_AGP_BASE, mask_sh),\
+	MI_SF(DCHUBBUB_SDPIF_AGP_BOT, SDPIF_AGP_BOT, mask_sh),\
+	MI_SF(DCHUBBUB_SDPIF_AGP_TOP, SDPIF_AGP_TOP, mask_sh),\
+	MI_SF(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL, DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, mask_sh),\
+	MI_SF(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL, DCHUBBUB_ARB_WATERMARK_CHANGE_DONE_INTERRUPT_DISABLE, mask_sh),\
+	MI_SF(DCHUBBUB_ARB_SAT_LEVEL, DCHUBBUB_ARB_SAT_LEVEL, mask_sh),\
+	MI_SF(DCHUBBUB_ARB_DF_REQ_OUTSTAND, DCHUBBUB_ARB_MIN_REQ_OUTSTAND, mask_sh),\
+	/* todo:  get these from GVM instead of reading registers ourselves */\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32, PAGE_DIRECTORY_ENTRY_HI32, mask_sh),\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32, PAGE_DIRECTORY_ENTRY_LO32, mask_sh),\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32, LOGICAL_PAGE_NUMBER_HI4, mask_sh),\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32, LOGICAL_PAGE_NUMBER_LO32, mask_sh),\
+	MI_SF(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32, PHYSICAL_PAGE_ADDR_HI4, mask_sh),\
+	MI_SF(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32, PHYSICAL_PAGE_ADDR_LO32, mask_sh),\
+	MI_SF(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, PHYSICAL_PAGE_NUMBER_MSB, mask_sh),\
+	MI_SF(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, PHYSICAL_PAGE_NUMBER_LSB, mask_sh),\
+	MI_SF(MC_VM_SYSTEM_APERTURE_LOW_ADDR, LOGICAL_ADDR, mask_sh)
+
+#define DCN_MI_REG_FIELD_LIST(type) \
+	type HUBP_BLANK_EN;\
+	type HUBP_TTU_DISABLE;\
+	type NUM_PIPES;\
+	type NUM_BANKS;\
+	type PIPE_INTERLEAVE;\
+	type NUM_SE;\
+	type NUM_RB_PER_SE;\
+	type MAX_COMPRESSED_FRAGS;\
+	type SW_MODE;\
+	type META_LINEAR;\
+	type RB_ALIGNED;\
+	type PIPE_ALIGNED;\
+	type PITCH;\
+	type META_PITCH;\
+	type PITCH_C;\
+	type META_PITCH_C;\
+	type ROTATION_ANGLE;\
+	type H_MIRROR_EN;\
+	type SURFACE_PIXEL_FORMAT;\
+	type SURFACE_FLIP_TYPE;\
+	type SURFACE_UPDATE_PENDING;\
+	type PRIMARY_SURFACE_ADDRESS_HIGH;\
+	type PRIMARY_SURFACE_ADDRESS;\
+	type SECONDARY_SURFACE_ADDRESS_HIGH;\
+	type SECONDARY_SURFACE_ADDRESS;\
+	type PRIMARY_META_SURFACE_ADDRESS_HIGH;\
+	type PRIMARY_META_SURFACE_ADDRESS;\
+	type SECONDARY_META_SURFACE_ADDRESS_HIGH;\
+	type SECONDARY_META_SURFACE_ADDRESS;\
+	type PRIMARY_SURFACE_ADDRESS_HIGH_C;\
+	type PRIMARY_SURFACE_ADDRESS_C;\
+	type PRIMARY_META_SURFACE_ADDRESS_HIGH_C;\
+	type PRIMARY_META_SURFACE_ADDRESS_C;\
+	type PRIMARY_SURFACE_DCC_EN;\
+	type PRIMARY_SURFACE_DCC_IND_64B_BLK;\
+	type DET_BUF_PLANE1_BASE_ADDRESS;\
+	type CROSSBAR_SRC_CB_B;\
+	type CROSSBAR_SRC_CR_R;\
+	type DRQ_EXPANSION_MODE;\
+	type PRQ_EXPANSION_MODE;\
+	type MRQ_EXPANSION_MODE;\
+	type CRQ_EXPANSION_MODE;\
+	type CHUNK_SIZE;\
+	type MIN_CHUNK_SIZE;\
+	type META_CHUNK_SIZE;\
+	type MIN_META_CHUNK_SIZE;\
+	type DPTE_GROUP_SIZE;\
+	type MPTE_GROUP_SIZE;\
+	type SWATH_HEIGHT;\
+	type PTE_ROW_HEIGHT_LINEAR;\
+	type CHUNK_SIZE_C;\
+	type MIN_CHUNK_SIZE_C;\
+	type META_CHUNK_SIZE_C;\
+	type MIN_META_CHUNK_SIZE_C;\
+	type DPTE_GROUP_SIZE_C;\
+	type MPTE_GROUP_SIZE_C;\
+	type SWATH_HEIGHT_C;\
+	type PTE_ROW_HEIGHT_LINEAR_C;\
+	type REFCYC_H_BLANK_END;\
+	type DLG_V_BLANK_END;\
+	type MIN_DST_Y_NEXT_START;\
+	type REFCYC_PER_HTOTAL;\
+	type REFCYC_X_AFTER_SCALER;\
+	type DST_Y_AFTER_SCALER;\
+	type DST_Y_PREFETCH;\
+	type VRATIO_PREFETCH;\
+	type DST_Y_PER_VM_VBLANK;\
+	type DST_Y_PER_ROW_VBLANK;\
+	type REF_FREQ_TO_PIX_FREQ;\
+	type REFCYC_PER_PTE_GROUP_VBLANK_L;\
+	type REFCYC_PER_META_CHUNK_VBLANK_L;\
+	type DST_Y_PER_PTE_ROW_NOM_L;\
+	type REFCYC_PER_PTE_GROUP_NOM_L;\
+	type DST_Y_PER_META_ROW_NOM_L;\
+	type REFCYC_PER_META_CHUNK_NOM_L;\
+	type REFCYC_PER_LINE_DELIVERY_PRE_L;\
+	type REFCYC_PER_LINE_DELIVERY_PRE_C;\
+	type REFCYC_PER_LINE_DELIVERY_L;\
+	type REFCYC_PER_LINE_DELIVERY_C;\
+	type VRATIO_PREFETCH_C;\
+	type REFCYC_PER_PTE_GROUP_VBLANK_C;\
+	type REFCYC_PER_META_CHUNK_VBLANK_C;\
+	type DST_Y_PER_PTE_ROW_NOM_C;\
+	type REFCYC_PER_PTE_GROUP_NOM_C;\
+	type DST_Y_PER_META_ROW_NOM_C;\
+	type REFCYC_PER_META_CHUNK_NOM_C;\
+	type QoS_LEVEL_LOW_WM;\
+	type QoS_LEVEL_HIGH_WM;\
+	type MIN_TTU_VBLANK;\
+	type QoS_LEVEL_FLIP;\
+	type REFCYC_PER_REQ_DELIVERY;\
+	type QoS_LEVEL_FIXED;\
+	type QoS_RAMP_DISABLE;\
+	type REFCYC_PER_REQ_DELIVERY_PRE;\
+	type VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB;\
+	type VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LSB;\
+	type VM_CONTEXT0_PAGE_TABLE_START_ADDR_MSB;\
+	type VM_CONTEXT0_PAGE_TABLE_START_ADDR_LSB;\
+	type VM_CONTEXT0_PAGE_TABLE_END_ADDR_MSB;\
+	type VM_CONTEXT0_PAGE_TABLE_END_ADDR_LSB;\
+	type VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_MSB;\
+	type VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB;\
+	type ENABLE_L1_TLB;\
+	type SYSTEM_ACCESS_MODE;\
+	type MC_VM_SYSTEM_APERTURE_DEFAULT_SYSTEM;\
+	type MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB;\
+	type MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB;\
+	type MC_VM_SYSTEM_APERTURE_LOW_ADDR_MSB;\
+	type MC_VM_SYSTEM_APERTURE_LOW_ADDR_LSB;\
+	type MC_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB;\
+	type MC_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB;\
+	type SDPIF_FB_TOP;\
+	type SDPIF_FB_BASE;\
+	type SDPIF_FB_OFFSET;\
+	type SDPIF_AGP_BASE;\
+	type SDPIF_AGP_BOT;\
+	type SDPIF_AGP_TOP;\
+	type DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST;\
+	type DCHUBBUB_ARB_WATERMARK_CHANGE_DONE_INTERRUPT_DISABLE;\
+	type DCHUBBUB_ARB_SAT_LEVEL;\
+	type DCHUBBUB_ARB_MIN_REQ_OUTSTAND;\
+	/* todo:  get these from GVM instead of reading registers ourselves */\
+	type PAGE_DIRECTORY_ENTRY_HI32;\
+	type PAGE_DIRECTORY_ENTRY_LO32;\
+	type LOGICAL_PAGE_NUMBER_HI4;\
+	type LOGICAL_PAGE_NUMBER_LO32;\
+	type PHYSICAL_PAGE_ADDR_HI4;\
+	type PHYSICAL_PAGE_ADDR_LO32;\
+	type PHYSICAL_PAGE_NUMBER_MSB;\
+	type PHYSICAL_PAGE_NUMBER_LSB;\
+	type LOGICAL_ADDR
+
+struct dcn_mi_shift {
+	DCN_MI_REG_FIELD_LIST(uint8_t);
+};
+
+struct dcn_mi_mask {
+	DCN_MI_REG_FIELD_LIST(uint32_t);
+};
+
+struct dcn10_mem_input {
+	struct mem_input base;
+	const struct dcn_mi_registers *mi_regs;
+	const struct dcn_mi_shift *mi_shift;
+	const struct dcn_mi_mask *mi_mask;
+};
+
+bool dcn10_mem_input_construct(
+	struct dcn10_mem_input *mi,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn_mi_registers *mi_regs,
+	const struct dcn_mi_shift *mi_shift,
+	const struct dcn_mi_mask *mi_mask);
+
+
+#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
new file mode 100644
index 0000000..cb22cd1
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -0,0 +1,376 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "dcn10_mpc.h"
+
+#define REG(reg)\
+	mpc->mpc_regs->reg
+
+#define CTX \
+	mpc->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	mpc->mpc_shift->field_name, mpc->mpc_mask->field_name
+
+/* Internal function to set mpc output mux */
+static void set_output_mux(struct dcn10_mpc *mpc,
+	uint8_t opp_id,
+	uint8_t mpcc_id)
+{
+	if (mpcc_id != 0xf)
+		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
+				OPP_PIPE_CLOCK_EN, 1);
+
+	REG_SET(MUX[opp_id], 0,
+			MPC_OUT_MUX, mpcc_id);
+
+/*	TODO: Move to post when ready.
+   if (mpcc_id == 0xf) {
+		MPCC_REG_UPDATE(OPP_PIPE0_OPP_PIPE_CONTROL,
+				OPP_PIPE_CLOCK_EN, 0);
+	}
+*/
+}
+
+static void set_blend_mode(struct dcn10_mpc *mpc,
+	enum blend_mode mode,
+	uint8_t mpcc_id)
+{
+	/* Enable per-pixel alpha on this pipe */
+	if (mode == TOP_BLND)
+		REG_UPDATE_3(MPCC_CONTROL[mpcc_id],
+				MPCC_ALPHA_BLND_MODE, 0,
+				MPCC_ALPHA_MULTIPLIED_MODE, 0,
+				MPCC_BLND_ACTIVE_OVERLAP_ONLY, 0);
+	else
+		REG_UPDATE_3(MPCC_CONTROL[mpcc_id],
+				MPCC_ALPHA_BLND_MODE, 0,
+				MPCC_ALPHA_MULTIPLIED_MODE, 1,
+				MPCC_BLND_ACTIVE_OVERLAP_ONLY, 1);
+}
+
+void dcn10_set_mpc_background_color(struct dcn10_mpc *mpc,
+	unsigned int mpcc_inst,
+	struct tg_color *bg_color)
+{
+	/* mpc color is 12 bit.  tg_color is 10 bit */
+	/* todo: might want to use 16 bit to represent color and have each
+	 * hw block translate to correct color depth.
+	 */
+	uint32_t bg_r_cr = bg_color->color_r_cr << 2;
+	uint32_t bg_g_y = bg_color->color_g_y << 2;
+	uint32_t bg_b_cb = bg_color->color_b_cb << 2;
+
+	REG_SET(MPCC_BG_R_CR[mpcc_inst], 0,
+			MPCC_BG_R_CR, bg_r_cr);
+	REG_SET(MPCC_BG_G_Y[mpcc_inst], 0,
+			MPCC_BG_G_Y, bg_g_y);
+	REG_SET(MPCC_BG_B_CB[mpcc_inst], 0,
+			MPCC_BG_B_CB, bg_b_cb);
+}
+
+/* This function programs MPC tree configuration
+ * Assume it is the initial time to setup MPC tree_configure, means
+ * the instance of dpp/mpcc/opp specified in structure tree_cfg are
+ * in idle status.
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set.
+ *
+ * tree_cfg[in] - new MPC_TREE_CFG
+ */
+
+void dcn10_set_mpc_tree(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg)
+{
+	int i;
+
+	for (i = 0; i < tree_cfg->num_pipes; i++) {
+		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+
+		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+			MPCC_OPP_ID, tree_cfg->opp_id);
+
+		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+			MPCC_TOP_SEL, tree_cfg->dpp[i]);
+
+		if (i == tree_cfg->num_pipes-1) {
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, 0xF);
+
+			/* MPCC_CONTROL->MPCC_MODE */
+			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+					MPCC_MODE, tree_cfg->mode);
+		} else {
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, tree_cfg->dpp[i+1]);
+
+			/* MPCC_CONTROL->MPCC_MODE */
+			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+					MPCC_MODE, 3);
+		}
+
+		if (i == 0)
+			set_output_mux(
+				mpc, tree_cfg->opp_id, mpcc_inst);
+
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_inst);
+	}
+}
+
+void dcn10_set_mpc_passthrough(struct dcn10_mpc *mpc,
+	uint8_t dpp_idx,
+	uint8_t mpcc_idx,
+	uint8_t opp_idx)
+{
+	struct mpc_tree_cfg tree_cfg = { 0 };
+
+	tree_cfg.num_pipes = 1;
+	tree_cfg.opp_id = opp_idx;
+	tree_cfg.mode = TOP_PASSTHRU;
+	/* TODO: FPGA bring up one MPC has only 1 DPP and 1 MPCC
+	 * For blend case, need fill mode DPP and cascade MPCC
+	 */
+	tree_cfg.dpp[0] = dpp_idx;
+	tree_cfg.mpcc[0] = mpcc_idx;
+	dcn10_set_mpc_tree(mpc, &tree_cfg);
+}
+
+/*
+ * This is the function to remove current MPC tree specified by tree_cfg
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set.
+ *
+ *tree_cfg[in/out] - current MPC_TREE_CFG
+ */
+void dcn10_delete_mpc_tree(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg)
+{
+	int i;
+
+	for (i = 0; i < tree_cfg->num_pipes; i++) {
+		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+
+		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+			MPCC_OPP_ID, 0xf);
+
+		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+			MPCC_TOP_SEL, 0xf);
+
+		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+			MPCC_BOT_SEL, 0xF);
+
+		/* add remove dpp/mpcc pair into pending list
+		 * TODO FPGA AddToPendingList if empty from pseudo code
+		 */
+		tree_cfg->dpp[i] = 0xf;
+		tree_cfg->mpcc[i] = 0xf;
+	}
+	set_output_mux(mpc, tree_cfg->opp_id, 0xf);
+	tree_cfg->opp_id = 0xf;
+	tree_cfg->num_pipes = 0;
+}
+
+/* TODO FPGA: how to handle DPP?
+ * Function to remove one of pipe from MPC configure tree by dpp idx
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set
+ * This function can be invoke multiple times to remove more than 1 dpps.
+ *
+ * tree_cfg[in/out] - current MPC_TREE_CFG
+ * idx[in] - index of dpp from tree_cfg to be removed.
+ */
+bool dcn10_remove_dpp(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg,
+	uint8_t idx)
+{
+	int i;
+	bool found = false;
+
+	/* find dpp_idx from dpp array of tree_cfg */
+	for (i = 0; i < tree_cfg->num_pipes; i++) {
+		if (tree_cfg->dpp[i] == idx) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found) {
+		/* add remove dpp/mpcc pair into pending list */
+
+		/* TODO FPGA AddToPendingList if empty from pseudo code
+		 * AddToPendingList(tree_cfg->dpp[i],tree_cfg->mpcc[i]);
+		 */
+		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+
+		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+				MPCC_OPP_ID, 0xf);
+
+		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+				MPCC_TOP_SEL, 0xf);
+
+		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, 0xF);
+
+		if (i == 0) {
+			if (tree_cfg->num_pipes > 1)
+				set_output_mux(mpc,
+					tree_cfg->opp_id, tree_cfg->mpcc[i+1]);
+			else
+				set_output_mux(mpc, tree_cfg->opp_id, 0xf);
+		} else if (i == tree_cfg->num_pipes-1) {
+			mpcc_inst = tree_cfg->mpcc[i - 1];
+
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+					MPCC_BOT_SEL, 0xF);
+
+			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+					MPCC_MODE, tree_cfg->mode);
+		} else {
+			mpcc_inst = tree_cfg->mpcc[i - 1];
+
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, tree_cfg->mpcc[i+1]);
+		}
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_inst);
+
+		/* update tree_cfg structure */
+		while (i < tree_cfg->num_pipes - 1) {
+			tree_cfg->dpp[i] = tree_cfg->dpp[i+1];
+			tree_cfg->mpcc[i] = tree_cfg->mpcc[i+1];
+			i++;
+		}
+		tree_cfg->num_pipes--;
+	}
+	return found;
+}
+
+/* TODO FPGA: how to handle DPP?
+ * Function to add DPP/MPCC pair into MPC configure tree by position.
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set
+ * This function can be invoke multiple times to add more than 1 pipes.
+ *
+ * tree_cfg[in/out] - current MPC_TREE_CFG
+ * dpp_idx[in]	 - index of an idle dpp insatnce to be added.
+ * mpcc_idx[in]	 - index of an idle mpcc instance to be added.
+ * poistion[in]	 - position of dpp/mpcc pair to be added into current tree_cfg
+ *                 0 means insert to the most top layer of MPC tree
+ */
+void dcn10_add_dpp(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg,
+	uint8_t dpp_idx,
+	uint8_t mpcc_idx,
+	uint8_t position)
+{
+	uint8_t temp;
+	uint8_t temp1;
+
+	REG_SET(MPCC_OPP_ID[mpcc_idx], 0,
+			MPCC_OPP_ID, tree_cfg->opp_id);
+
+	REG_SET(MPCC_TOP_SEL[mpcc_idx], 0,
+			MPCC_TOP_SEL, dpp_idx);
+
+	if (position == 0) {
+		/* idle dpp/mpcc is added to the top layer of tree */
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, tree_cfg->mpcc[0]);
+		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
+				MPCC_MODE, 3);
+
+		/* opp will get new output. from new added mpcc */
+		set_output_mux(mpc, tree_cfg->opp_id, mpcc_idx);
+
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_idx);
+
+	} else if (position == tree_cfg->num_pipes) {
+		/* idle dpp/mpcc is added to the bottom layer of tree */
+
+		/* get instance of previous bottom mpcc, set to middle layer */
+		temp = tree_cfg->mpcc[tree_cfg->num_pipes - 1];
+
+		REG_SET(MPCC_BOT_SEL[temp], 0,
+				MPCC_BOT_SEL, mpcc_idx);
+
+		REG_UPDATE(MPCC_CONTROL[temp],
+				MPCC_MODE, 3);
+
+		/* mpcc_idx become new bottom mpcc*/
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, 0xf);
+
+		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
+				MPCC_MODE, tree_cfg->mode);
+
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_idx);
+	} else {
+		/* idle dpp/mpcc is added to middle of tree */
+		temp = tree_cfg->mpcc[position - 1];
+		temp1 = tree_cfg->mpcc[position];
+
+		/* new mpcc instance temp1 is added right after temp*/
+		REG_SET(MPCC_BOT_SEL[temp], 0,
+				MPCC_BOT_SEL, mpcc_idx);
+
+		/* mpcc_idx connect previous temp+1 to new mpcc */
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, temp1);
+
+		/* temp TODO: may not need*/
+		REG_UPDATE(MPCC_CONTROL[temp],
+				MPCC_MODE, 3);
+
+		set_blend_mode(mpc, tree_cfg->mode, temp);
+	}
+
+	/* update tree_cfg structure */
+	temp = tree_cfg->num_pipes - 1;
+
+	/*
+	 * iterating from the last mpc/dpp pair to the one being added, shift
+	 * them down one position
+	 */
+	while (temp > position) {
+		tree_cfg->dpp[temp + 1] = tree_cfg->dpp[temp];
+		tree_cfg->mpcc[temp + 1] = tree_cfg->mpcc[temp];
+		temp--;
+	}
+
+	/* insert the new mpc/dpp pair into the tree_cfg*/
+	tree_cfg->dpp[position] = dpp_idx;
+	tree_cfg->mpcc[position] = mpcc_idx;
+	tree_cfg->num_pipes++;
+}
+
+void wait_mpcc_idle(struct dcn10_mpc *mpc,
+	uint8_t mpcc_id)
+{
+	REG_WAIT(MPCC_STATUS[mpcc_id],
+			MPCC_IDLE, 1,
+			1000, 1000);
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.h
new file mode 100644
index 0000000..6550b93
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.h
@@ -0,0 +1,135 @@
+/* Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_MPC_DCN10_H__
+#define __DC_MPC_DCN10_H__
+
+#include "mpc.h"
+
+#define TO_DCN10_MPC(mpc_base)\
+	container_of(mpc_base, struct dcn10_mpc, base)
+
+#define MAX_MPCC 4
+#define MAX_MPC_OUT 4
+#define MAX_OPP 4
+
+#define MPC_COMMON_REG_LIST_DCN1_0(inst) \
+	SRII(MPCC_TOP_SEL, MPCC, inst),\
+	SRII(MPCC_BOT_SEL, MPCC, inst),\
+	SRII(MPCC_CONTROL, MPCC, inst),\
+	SRII(MPCC_STATUS, MPCC, inst),\
+	SRII(MPCC_OPP_ID, MPCC, inst),\
+	SRII(MPCC_BG_G_Y, MPCC, inst),\
+	SRII(MPCC_BG_R_CR, MPCC, inst),\
+	SRII(MPCC_BG_B_CB, MPCC, inst),\
+	SRII(MPCC_BG_B_CB, MPCC, inst),\
+	SRII(MUX, MPC_OUT, inst),\
+	SRII(OPP_PIPE_CONTROL, OPP_PIPE, inst)
+
+struct dcn_mpc_registers {
+	uint32_t MPCC_TOP_SEL[MAX_MPCC];
+	uint32_t MPCC_BOT_SEL[MAX_MPCC];
+	uint32_t MPCC_CONTROL[MAX_MPCC];
+	uint32_t MPCC_STATUS[MAX_MPCC];
+	uint32_t MPCC_OPP_ID[MAX_MPCC];
+	uint32_t MPCC_BG_G_Y[MAX_MPCC];
+	uint32_t MPCC_BG_R_CR[MAX_MPCC];
+	uint32_t MPCC_BG_B_CB[MAX_MPCC];
+	uint32_t MUX[MAX_MPC_OUT];
+	uint32_t OPP_PIPE_CONTROL[MAX_OPP];
+};
+
+#define MPC_COMMON_MASK_SH_LIST_DCN1_0(mask_sh)\
+	SF(MPCC0_MPCC_TOP_SEL, MPCC_TOP_SEL, mask_sh),\
+	SF(MPCC0_MPCC_BOT_SEL, MPCC_BOT_SEL, mask_sh),\
+	SF(MPCC0_MPCC_CONTROL, MPCC_MODE, mask_sh),\
+	SF(MPCC0_MPCC_CONTROL, MPCC_ALPHA_BLND_MODE, mask_sh),\
+	SF(MPCC0_MPCC_CONTROL, MPCC_ALPHA_MULTIPLIED_MODE, mask_sh),\
+	SF(MPCC0_MPCC_CONTROL, MPCC_BLND_ACTIVE_OVERLAP_ONLY, mask_sh),\
+	SF(MPCC0_MPCC_STATUS, MPCC_IDLE, mask_sh),\
+	SF(MPCC0_MPCC_OPP_ID, MPCC_OPP_ID, mask_sh),\
+	SF(MPCC0_MPCC_BG_G_Y, MPCC_BG_G_Y, mask_sh),\
+	SF(MPCC0_MPCC_BG_R_CR, MPCC_BG_R_CR, mask_sh),\
+	SF(MPCC0_MPCC_BG_B_CB, MPCC_BG_B_CB, mask_sh),\
+	SF(MPC_OUT0_MUX, MPC_OUT_MUX, mask_sh),\
+	SF(OPP_PIPE0_OPP_PIPE_CONTROL, OPP_PIPE_CLOCK_EN, mask_sh)
+
+#define MPC_REG_FIELD_LIST(type) \
+	type MPCC_TOP_SEL;\
+	type MPCC_BOT_SEL;\
+	type MPCC_MODE;\
+	type MPCC_ALPHA_BLND_MODE;\
+	type MPCC_ALPHA_MULTIPLIED_MODE;\
+	type MPCC_BLND_ACTIVE_OVERLAP_ONLY;\
+	type MPCC_IDLE;\
+	type MPCC_OPP_ID;\
+	type MPCC_BG_G_Y;\
+	type MPCC_BG_R_CR;\
+	type MPCC_BG_B_CB;\
+	type MPC_OUT_MUX;\
+	type OPP_PIPE_CLOCK_EN;\
+
+struct dcn_mpc_shift {
+	MPC_REG_FIELD_LIST(uint8_t)
+};
+
+struct dcn_mpc_mask {
+	MPC_REG_FIELD_LIST(uint32_t)
+};
+
+struct dcn10_mpc {
+	struct mpc base;
+	const struct dcn_mpc_registers *mpc_regs;
+	const struct dcn_mpc_shift *mpc_shift;
+	const struct dcn_mpc_mask *mpc_mask;
+};
+
+void dcn10_set_mpc_passthrough(struct dcn10_mpc *mpc,
+	uint8_t dpp_idx,
+	uint8_t mpcc_idx,
+	uint8_t opp_idx);
+
+void dcn10_delete_mpc_tree(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg);
+
+bool dcn10_remove_dpp(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg,
+	uint8_t idx);
+
+void dcn10_add_dpp(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg,
+	uint8_t dpp_idx,
+	uint8_t mpcc_idx,
+	uint8_t position);
+
+void wait_mpcc_idle(struct dcn10_mpc *mpc,
+	uint8_t mpcc_id);
+
+void dcn10_set_mpc_tree(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg);
+
+void dcn10_set_mpc_background_color(struct dcn10_mpc *mpc,
+	unsigned int mpcc_inst,
+	struct tg_color *bg_color);
+#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
new file mode 100644
index 0000000..fce08e5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -0,0 +1,801 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dcn10_opp.h"
+#include "reg_helper.h"
+
+#define REG(reg) \
+	(oppn10->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	oppn10->opp_shift->field_name, oppn10->opp_mask->field_name
+
+#define CTX \
+	oppn10->base.ctx
+
+static void opp_set_regamma_mode(
+	struct output_pixel_processor *opp,
+	enum opp_regamma mode)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	uint32_t re_mode = 0;
+	uint32_t obuf_bypass = 0; /* need for pipe split */
+	uint32_t obuf_hupscale = 0;
+
+	switch (mode) {
+	case OPP_REGAMMA_BYPASS:
+		re_mode = 0;
+		break;
+	case OPP_REGAMMA_SRGB:
+		re_mode = 1;
+		break;
+	case OPP_REGAMMA_3_6:
+		re_mode = 2;
+		break;
+	case OPP_REGAMMA_USER:
+		re_mode = oppn10->is_write_to_ram_a_safe ? 3 : 4;
+		oppn10->is_write_to_ram_a_safe = !oppn10->is_write_to_ram_a_safe;
+		break;
+	default:
+		break;
+	}
+
+	REG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);
+	REG_UPDATE_2(OBUF_CONTROL,
+			OBUF_BYPASS, obuf_bypass,
+			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
+}
+
+/************* FORMATTER ************/
+
+/**
+ *	set_truncation
+ *	1) set truncation depth: 0 for 18 bpp or 1 for 24 bpp
+ *	2) enable truncation
+ *	3) HW remove 12bit FMT support for DCE11 power saving reason.
+ */
+static void set_truncation(
+		struct dcn10_opp *oppn10,
+		const struct bit_depth_reduction_params *params)
+{
+	REG_UPDATE_3(FMT_BIT_DEPTH_CONTROL,
+		FMT_TRUNCATE_EN, params->flags.TRUNCATE_ENABLED,
+		FMT_TRUNCATE_DEPTH, params->flags.TRUNCATE_DEPTH,
+		FMT_TRUNCATE_MODE, params->flags.TRUNCATE_MODE);
+}
+
+static void set_spatial_dither(
+	struct dcn10_opp *oppn10,
+	const struct bit_depth_reduction_params *params)
+{
+	/*Disable spatial (random) dithering*/
+	REG_UPDATE_7(FMT_BIT_DEPTH_CONTROL,
+			FMT_SPATIAL_DITHER_EN, 0,
+			FMT_SPATIAL_DITHER_MODE, 0,
+			FMT_SPATIAL_DITHER_DEPTH, 0,
+			FMT_TEMPORAL_DITHER_EN, 0,
+			FMT_HIGHPASS_RANDOM_ENABLE, 0,
+			FMT_FRAME_RANDOM_ENABLE, 0,
+			FMT_RGB_RANDOM_ENABLE, 0);
+
+
+	/* only use FRAME_COUNTER_MAX if frameRandom == 1*/
+	if (params->flags.FRAME_RANDOM == 1) {
+		if (params->flags.SPATIAL_DITHER_DEPTH == 0 || params->flags.SPATIAL_DITHER_DEPTH == 1) {
+			REG_UPDATE_2(FMT_CONTROL,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 15,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 2);
+		} else if (params->flags.SPATIAL_DITHER_DEPTH == 2) {
+			REG_UPDATE_2(FMT_CONTROL,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 3,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 1);
+		} else {
+			return;
+		}
+	} else {
+		REG_UPDATE_2(FMT_CONTROL,
+				FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 0,
+				FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 0);
+	}
+
+	/*Set seed for random values for
+	 * spatial dithering for R,G,B channels*/
+
+	REG_SET(FMT_DITHER_RAND_R_SEED, 0,
+			FMT_RAND_R_SEED, params->r_seed_value);
+
+	REG_SET(FMT_DITHER_RAND_G_SEED, 0,
+			FMT_RAND_G_SEED, params->g_seed_value);
+
+	REG_SET(FMT_DITHER_RAND_B_SEED, 0,
+			FMT_RAND_B_SEED, params->b_seed_value);
+
+	/* FMT_OFFSET_R_Cr  31:16 0x0 Setting the zero
+	 * offset for the R/Cr channel, lower 4LSB
+	 * is forced to zeros. Typically set to 0
+	 * RGB and 0x80000 YCbCr.
+	 */
+	/* FMT_OFFSET_G_Y   31:16 0x0 Setting the zero
+	 * offset for the G/Y  channel, lower 4LSB is
+	 * forced to zeros. Typically set to 0 RGB
+	 * and 0x80000 YCbCr.
+	 */
+	/* FMT_OFFSET_B_Cb  31:16 0x0 Setting the zero
+	 * offset for the B/Cb channel, lower 4LSB is
+	 * forced to zeros. Typically set to 0 RGB and
+	 * 0x80000 YCbCr.
+	 */
+
+	REG_UPDATE_6(FMT_BIT_DEPTH_CONTROL,
+			/*Enable spatial dithering*/
+			FMT_SPATIAL_DITHER_EN, params->flags.SPATIAL_DITHER_ENABLED,
+			/* Set spatial dithering mode
+			 * (default is Seed patterrn AAAA...)
+			 */
+			FMT_SPATIAL_DITHER_MODE, params->flags.SPATIAL_DITHER_MODE,
+			/*Set spatial dithering bit depth*/
+			FMT_SPATIAL_DITHER_DEPTH, params->flags.SPATIAL_DITHER_DEPTH,
+			/*Disable High pass filter*/
+			FMT_HIGHPASS_RANDOM_ENABLE, params->flags.HIGHPASS_RANDOM,
+			/*Reset only at startup*/
+			FMT_FRAME_RANDOM_ENABLE, params->flags.FRAME_RANDOM,
+			/*Set RGB data dithered with x^28+x^3+1*/
+			FMT_RGB_RANDOM_ENABLE, params->flags.RGB_RANDOM);
+}
+
+static void opp_program_bit_depth_reduction(
+	struct output_pixel_processor *opp,
+	const struct bit_depth_reduction_params *params)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	set_truncation(oppn10, params);
+	set_spatial_dither(oppn10, params);
+	/* TODO
+	 * set_temporal_dither(oppn10, params);
+	 */
+}
+
+/**
+ *	set_pixel_encoding
+ *
+ *	Set Pixel Encoding
+ *		0: RGB 4:4:4 or YCbCr 4:4:4 or YOnly
+ *		1: YCbCr 4:2:2
+ */
+static void set_pixel_encoding(
+	struct dcn10_opp *oppn10,
+	const struct clamping_and_pixel_encoding_params *params)
+{
+	switch (params->pixel_encoding)	{
+
+	case PIXEL_ENCODING_RGB:
+	case PIXEL_ENCODING_YCBCR444:
+		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 0);
+		break;
+	case PIXEL_ENCODING_YCBCR422:
+		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 1);
+		break;
+	case PIXEL_ENCODING_YCBCR420:
+		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 2);
+		break;
+	default:
+		break;
+	}
+}
+
+/**
+ *	Set Clamping
+ *	1) Set clamping format based on bpc - 0 for 6bpc (No clamping)
+ *		1 for 8 bpc
+ *		2 for 10 bpc
+ *		3 for 12 bpc
+ *		7 for programable
+ *	2) Enable clamp if Limited range requested
+ */
+static void opp_set_clamping(
+	struct dcn10_opp *oppn10,
+	const struct clamping_and_pixel_encoding_params *params)
+{
+	REG_UPDATE_2(FMT_CLAMP_CNTL,
+			FMT_CLAMP_DATA_EN, 0,
+			FMT_CLAMP_COLOR_FORMAT, 0);
+
+	switch (params->clamping_level) {
+	case CLAMPING_FULL_RANGE:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 0);
+		break;
+	case CLAMPING_LIMITED_RANGE_8BPC:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 1);
+		break;
+	case CLAMPING_LIMITED_RANGE_10BPC:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 2);
+
+		break;
+	case CLAMPING_LIMITED_RANGE_12BPC:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 3);
+		break;
+	case CLAMPING_LIMITED_RANGE_PROGRAMMABLE:
+		/* TODO */
+	default:
+		break;
+	}
+
+}
+
+static void opp_set_dyn_expansion(
+	struct output_pixel_processor *opp,
+	enum dc_color_space color_sp,
+	enum dc_color_depth color_dpth,
+	enum signal_type signal)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+			FMT_DYNAMIC_EXP_EN, 0,
+			FMT_DYNAMIC_EXP_MODE, 0);
+
+	/*00 - 10-bit -> 12-bit dynamic expansion*/
+	/*01 - 8-bit  -> 12-bit dynamic expansion*/
+	if (signal == SIGNAL_TYPE_HDMI_TYPE_A ||
+		signal == SIGNAL_TYPE_DISPLAY_PORT ||
+		signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
+		switch (color_dpth) {
+		case COLOR_DEPTH_888:
+			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+				FMT_DYNAMIC_EXP_EN, 1,
+				FMT_DYNAMIC_EXP_MODE, 1);
+			break;
+		case COLOR_DEPTH_101010:
+			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+				FMT_DYNAMIC_EXP_EN, 1,
+				FMT_DYNAMIC_EXP_MODE, 0);
+			break;
+		case COLOR_DEPTH_121212:
+			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+				FMT_DYNAMIC_EXP_EN, 1,/*otherwise last two bits are zero*/
+				FMT_DYNAMIC_EXP_MODE, 0);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static void opp_program_clamping_and_pixel_encoding(
+	struct output_pixel_processor *opp,
+	const struct clamping_and_pixel_encoding_params *params)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	opp_set_clamping(oppn10, params);
+	set_pixel_encoding(oppn10, params);
+}
+
+static void opp_program_fmt(
+	struct output_pixel_processor *opp,
+	struct bit_depth_reduction_params *fmt_bit_depth,
+	struct clamping_and_pixel_encoding_params *clamping)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	if (clamping->pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		REG_UPDATE(FMT_MAP420_MEMORY_CONTROL, FMT_MAP420MEM_PWR_FORCE, 0);
+
+	/* dithering is affected by <CrtcSourceSelect>, hence should be
+	 * programmed afterwards */
+	opp_program_bit_depth_reduction(
+		opp,
+		fmt_bit_depth);
+
+	opp_program_clamping_and_pixel_encoding(
+		opp,
+		clamping);
+
+	return;
+}
+
+static void opp_set_output_csc_default(
+		struct output_pixel_processor *opp,
+		const struct default_adjustment *default_adjust)
+{
+
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	uint32_t ocsc_mode = 0;
+
+	if (default_adjust != NULL) {
+		switch (default_adjust->out_color_space) {
+		case COLOR_SPACE_SRGB:
+			ocsc_mode = 0;
+			break;
+		case COLOR_SPACE_SRGB_LIMITED:
+			ocsc_mode = 1;
+			break;
+		case COLOR_SPACE_YCBCR601:
+		case COLOR_SPACE_YCBCR601_LIMITED:
+			ocsc_mode = 2;
+			break;
+		case COLOR_SPACE_YCBCR709:
+		case COLOR_SPACE_YCBCR709_LIMITED:
+			ocsc_mode = 3;
+			break;
+		case COLOR_SPACE_UNKNOWN:
+		default:
+			break;
+		}
+	}
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+
+}
+/*program re gamma RAM B*/
+static void opp_program_regamma_lutb_settings(
+		struct output_pixel_processor *opp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
+		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
+		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
+		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
+		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
+		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
+		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
+		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
+		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
+		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
+		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
+		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
+		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
+		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
+		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
+		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
+		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
+		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+
+}
+
+/*program re gamma RAM A*/
+static void opp_program_regamma_luta_settings(
+		struct output_pixel_processor *opp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
+		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
+		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
+		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
+		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
+		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
+		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
+		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
+		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
+		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
+		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
+		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
+		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
+		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
+		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
+		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
+		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
+		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+static void opp_configure_regamma_lut(
+		struct output_pixel_processor *opp,
+		bool is_ram_a)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
+	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
+}
+
+static void opp_power_on_regamma_lut(
+	struct output_pixel_processor *opp,
+	bool power_on)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
+
+}
+
+static void opp_program_regamma_lut(
+		struct output_pixel_processor *opp,
+		const struct pwl_result_data *rgb,
+		uint32_t num)
+{
+	uint32_t i;
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
+
+	}
+
+}
+
+static bool opp_set_regamma_pwl(
+	struct output_pixel_processor *opp, const struct pwl_params *params)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	opp_power_on_regamma_lut(opp, true);
+	opp_configure_regamma_lut(opp, oppn10->is_write_to_ram_a_safe);
+
+	if (oppn10->is_write_to_ram_a_safe)
+		 opp_program_regamma_luta_settings(opp, params);
+	else
+		 opp_program_regamma_lutb_settings(opp, params);
+
+	opp_program_regamma_lut(
+		opp, params->rgb_resulted, params->hw_points_num);
+
+	return true;
+}
+
+static void opp_set_stereo_polarity(
+		struct output_pixel_processor *opp,
+		bool enable, bool rightEyePolarity)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_UPDATE(FMT_CONTROL, FMT_STEREOSYNC_OVERRIDE, enable);
+}
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+static void dcn10_opp_destroy(struct output_pixel_processor **opp)
+{
+	dm_free(TO_DCN10_OPP(*opp));
+	*opp = NULL;
+}
+
+static struct opp_funcs dcn10_opp_funcs = {
+		.opp_power_on_regamma_lut = opp_power_on_regamma_lut,
+		.opp_set_csc_adjustment = NULL,
+		.opp_set_csc_default = opp_set_output_csc_default,
+		.opp_set_dyn_expansion = opp_set_dyn_expansion,
+		.opp_program_regamma_pwl = opp_set_regamma_pwl,
+		.opp_set_regamma_mode = opp_set_regamma_mode,
+		.opp_program_fmt = opp_program_fmt,
+		.opp_program_bit_depth_reduction = opp_program_bit_depth_reduction,
+		.opp_set_stereo_polarity = opp_set_stereo_polarity,
+		.opp_destroy = dcn10_opp_destroy
+};
+
+void dcn10_opp_construct(struct dcn10_opp *oppn10,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn10_opp_registers *regs,
+	const struct dcn10_opp_shift *opp_shift,
+	const struct dcn10_opp_mask *opp_mask)
+{
+	oppn10->base.ctx = ctx;
+	oppn10->base.inst = inst;
+	oppn10->base.funcs = &dcn10_opp_funcs;
+
+	oppn10->regs = regs;
+	oppn10->opp_shift = opp_shift;
+	oppn10->opp_mask = opp_mask;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.h
new file mode 100644
index 0000000..113e0bc
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.h
@@ -0,0 +1,622 @@
+/* Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_OPP_DCN10_H__
+#define __DC_OPP_DCN10_H__
+
+#include "opp.h"
+
+#define TO_DCN10_OPP(opp)\
+	container_of(opp, struct dcn10_opp, base)
+
+#define OPP_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define OPP_DCN10_REG_LIST(id) \
+	SRI(CM_RGAM_LUT_WRITE_EN_MASK, CM, id), \
+	SRI(CM_RGAM_CONTROL, CM, id), \
+	SRI(OBUF_CONTROL, DSCL, id), \
+	SRI(FMT_BIT_DEPTH_CONTROL, FMT, id), \
+	SRI(FMT_CONTROL, FMT, id), \
+	SRI(FMT_DITHER_RAND_R_SEED, FMT, id), \
+	SRI(FMT_DITHER_RAND_G_SEED, FMT, id), \
+	SRI(FMT_DITHER_RAND_B_SEED, FMT, id), \
+	SRI(FMT_CLAMP_CNTL, FMT, id), \
+	SRI(FMT_DYNAMIC_EXP_CNTL, FMT, id), \
+	SRI(FMT_MAP420_MEMORY_CONTROL, FMT, id), \
+	SRI(CM_OCSC_CONTROL, CM, id), \
+	SRI(CM_RGAM_RAMB_START_CNTL_B, CM, id), \
+	SRI(CM_RGAM_RAMB_START_CNTL_G, CM, id), \
+	SRI(CM_RGAM_RAMB_START_CNTL_R, CM, id), \
+	SRI(CM_RGAM_RAMB_SLOPE_CNTL_B, CM, id), \
+	SRI(CM_RGAM_RAMB_SLOPE_CNTL_G, CM, id), \
+	SRI(CM_RGAM_RAMB_SLOPE_CNTL_R, CM, id), \
+	SRI(CM_RGAM_RAMB_END_CNTL1_B, CM, id), \
+	SRI(CM_RGAM_RAMB_END_CNTL2_B, CM, id), \
+	SRI(CM_RGAM_RAMB_END_CNTL1_G, CM, id), \
+	SRI(CM_RGAM_RAMB_END_CNTL2_G, CM, id), \
+	SRI(CM_RGAM_RAMB_END_CNTL1_R, CM, id), \
+	SRI(CM_RGAM_RAMB_END_CNTL2_R, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_0_1, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_2_3, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_4_5, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_6_7, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_8_9, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_10_11, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_12_13, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_14_15, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_16_17, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_18_19, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_20_21, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_22_23, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_24_25, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_26_27, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_28_29, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_30_31, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_32_33, CM, id), \
+	SRI(CM_RGAM_RAMA_START_CNTL_B, CM, id), \
+	SRI(CM_RGAM_RAMA_START_CNTL_G, CM, id), \
+	SRI(CM_RGAM_RAMA_START_CNTL_R, CM, id), \
+	SRI(CM_RGAM_RAMA_SLOPE_CNTL_B, CM, id), \
+	SRI(CM_RGAM_RAMA_SLOPE_CNTL_G, CM, id), \
+	SRI(CM_RGAM_RAMA_SLOPE_CNTL_R, CM, id), \
+	SRI(CM_RGAM_RAMA_END_CNTL1_B, CM, id), \
+	SRI(CM_RGAM_RAMA_END_CNTL2_B, CM, id), \
+	SRI(CM_RGAM_RAMA_END_CNTL1_G, CM, id), \
+	SRI(CM_RGAM_RAMA_END_CNTL2_G, CM, id), \
+	SRI(CM_RGAM_RAMA_END_CNTL1_R, CM, id), \
+	SRI(CM_RGAM_RAMA_END_CNTL2_R, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_0_1, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_2_3, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_4_5, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_6_7, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_8_9, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_10_11, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_12_13, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_14_15, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_16_17, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_18_19, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_20_21, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_22_23, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_24_25, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_26_27, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_28_29, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_30_31, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_32_33, CM, id), \
+	SRI(CM_RGAM_LUT_INDEX, CM, id), \
+	SRI(CM_MEM_PWR_CTRL, CM, id), \
+	SRI(CM_RGAM_LUT_DATA, CM, id)
+
+#define OPP_DCN10_MASK_SH_LIST(mask_sh) \
+	OPP_SF(CM0_CM_RGAM_CONTROL, CM_RGAM_LUT_MODE, mask_sh), \
+	OPP_SF(DSCL0_OBUF_CONTROL, OBUF_BYPASS, mask_sh), \
+	OPP_SF(DSCL0_OBUF_CONTROL, OBUF_H_2X_UPSCALE_EN, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_TRUNCATE_EN, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_TRUNCATE_DEPTH, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_TRUNCATE_MODE, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_SPATIAL_DITHER_EN, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_SPATIAL_DITHER_MODE, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_SPATIAL_DITHER_DEPTH, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_TEMPORAL_DITHER_EN, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_HIGHPASS_RANDOM_ENABLE, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_FRAME_RANDOM_ENABLE, mask_sh), \
+	OPP_SF(FMT0_FMT_BIT_DEPTH_CONTROL, FMT_RGB_RANDOM_ENABLE, mask_sh), \
+	OPP_SF(FMT0_FMT_CONTROL, FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, mask_sh), \
+	OPP_SF(FMT0_FMT_CONTROL, FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, mask_sh), \
+	OPP_SF(FMT0_FMT_DITHER_RAND_R_SEED, FMT_RAND_R_SEED, mask_sh), \
+	OPP_SF(FMT0_FMT_DITHER_RAND_G_SEED, FMT_RAND_G_SEED, mask_sh), \
+	OPP_SF(FMT0_FMT_DITHER_RAND_B_SEED, FMT_RAND_B_SEED, mask_sh), \
+	OPP_SF(FMT0_FMT_CONTROL, FMT_PIXEL_ENCODING, mask_sh), \
+	OPP_SF(FMT0_FMT_CLAMP_CNTL, FMT_CLAMP_DATA_EN, mask_sh), \
+	OPP_SF(FMT0_FMT_CLAMP_CNTL, FMT_CLAMP_COLOR_FORMAT, mask_sh), \
+	OPP_SF(FMT0_FMT_DYNAMIC_EXP_CNTL, FMT_DYNAMIC_EXP_EN, mask_sh), \
+	OPP_SF(FMT0_FMT_DYNAMIC_EXP_CNTL, FMT_DYNAMIC_EXP_MODE, mask_sh), \
+	OPP_SF(FMT0_FMT_MAP420_MEMORY_CONTROL, FMT_MAP420MEM_PWR_FORCE, mask_sh), \
+	OPP_SF(CM0_CM_OCSC_CONTROL, CM_OCSC_MODE, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_START_CNTL_B, CM_RGAM_RAMB_EXP_REGION_START_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_START_CNTL_B, CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_START_CNTL_G, CM_RGAM_RAMB_EXP_REGION_START_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_START_CNTL_G, CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_START_CNTL_R, CM_RGAM_RAMB_EXP_REGION_START_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_START_CNTL_R, CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_SLOPE_CNTL_B, CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_SLOPE_CNTL_G, CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_SLOPE_CNTL_R, CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL1_B, CM_RGAM_RAMB_EXP_REGION_END_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL2_B, CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL2_B, CM_RGAM_RAMB_EXP_REGION_END_BASE_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL1_G, CM_RGAM_RAMB_EXP_REGION_END_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL2_G, CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL2_G, CM_RGAM_RAMB_EXP_REGION_END_BASE_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL1_R, CM_RGAM_RAMB_EXP_REGION_END_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL2_R, CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_END_CNTL2_R, CM_RGAM_RAMB_EXP_REGION_END_BASE_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_START_CNTL_B, CM_RGAM_RAMA_EXP_REGION_START_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_START_CNTL_B, CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_START_CNTL_G, CM_RGAM_RAMA_EXP_REGION_START_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_START_CNTL_G, CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_START_CNTL_R, CM_RGAM_RAMA_EXP_REGION_START_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_START_CNTL_R, CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_SLOPE_CNTL_B, CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_SLOPE_CNTL_G, CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_SLOPE_CNTL_R, CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL1_B, CM_RGAM_RAMA_EXP_REGION_END_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL2_B, CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL2_B, CM_RGAM_RAMA_EXP_REGION_END_BASE_B, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL1_G, CM_RGAM_RAMA_EXP_REGION_END_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL2_G, CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL2_G, CM_RGAM_RAMA_EXP_REGION_END_BASE_G, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL1_R, CM_RGAM_RAMA_EXP_REGION_END_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL2_R, CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_END_CNTL2_R, CM_RGAM_RAMA_EXP_REGION_END_BASE_R, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_LUT_WRITE_EN_MASK, CM_RGAM_LUT_WRITE_EN_MASK, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_LUT_WRITE_EN_MASK, CM_RGAM_LUT_WRITE_SEL, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_LUT_INDEX, CM_RGAM_LUT_INDEX, mask_sh), \
+	OPP_SF(CM0_CM_MEM_PWR_CTRL, RGAM_MEM_PWR_FORCE, mask_sh), \
+	OPP_SF(CM0_CM_RGAM_LUT_DATA, CM_RGAM_LUT_DATA, mask_sh), \
+	OPP_SF(FMT0_FMT_CONTROL, FMT_STEREOSYNC_OVERRIDE, mask_sh)
+
+#define OPP_DCN10_REG_FIELD_LIST(type) \
+	type CM_RGAM_LUT_MODE; \
+	type OBUF_BYPASS; \
+	type OBUF_H_2X_UPSCALE_EN; \
+	type FMT_TRUNCATE_EN; \
+	type FMT_TRUNCATE_DEPTH; \
+	type FMT_TRUNCATE_MODE; \
+	type FMT_SPATIAL_DITHER_EN; \
+	type FMT_SPATIAL_DITHER_MODE; \
+	type FMT_SPATIAL_DITHER_DEPTH; \
+	type FMT_TEMPORAL_DITHER_EN; \
+	type FMT_HIGHPASS_RANDOM_ENABLE; \
+	type FMT_FRAME_RANDOM_ENABLE; \
+	type FMT_RGB_RANDOM_ENABLE; \
+	type FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX; \
+	type FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP; \
+	type FMT_RAND_R_SEED; \
+	type FMT_RAND_G_SEED; \
+	type FMT_RAND_B_SEED; \
+	type FMT_PIXEL_ENCODING; \
+	type FMT_CLAMP_DATA_EN; \
+	type FMT_CLAMP_COLOR_FORMAT; \
+	type FMT_DYNAMIC_EXP_EN; \
+	type FMT_DYNAMIC_EXP_MODE; \
+	type FMT_MAP420MEM_PWR_FORCE; \
+	type CM_OCSC_MODE; \
+	type CM_RGAM_RAMB_EXP_REGION_START_B; \
+	type CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B; \
+	type CM_RGAM_RAMB_EXP_REGION_START_G; \
+	type CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G; \
+	type CM_RGAM_RAMB_EXP_REGION_START_R; \
+	type CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R; \
+	type CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B; \
+	type CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G; \
+	type CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R; \
+	type CM_RGAM_RAMB_EXP_REGION_END_B; \
+	type CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B; \
+	type CM_RGAM_RAMB_EXP_REGION_END_BASE_B; \
+	type CM_RGAM_RAMB_EXP_REGION_END_G; \
+	type CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G; \
+	type CM_RGAM_RAMB_EXP_REGION_END_BASE_G; \
+	type CM_RGAM_RAMB_EXP_REGION_END_R; \
+	type CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R; \
+	type CM_RGAM_RAMB_EXP_REGION_END_BASE_R; \
+	type CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION_START_B; \
+	type CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B; \
+	type CM_RGAM_RAMA_EXP_REGION_START_G; \
+	type CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G; \
+	type CM_RGAM_RAMA_EXP_REGION_START_R; \
+	type CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R; \
+	type CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B; \
+	type CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G; \
+	type CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R; \
+	type CM_RGAM_RAMA_EXP_REGION_END_B; \
+	type CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B; \
+	type CM_RGAM_RAMA_EXP_REGION_END_BASE_B; \
+	type CM_RGAM_RAMA_EXP_REGION_END_G; \
+	type CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G; \
+	type CM_RGAM_RAMA_EXP_REGION_END_BASE_G; \
+	type CM_RGAM_RAMA_EXP_REGION_END_R; \
+	type CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R; \
+	type CM_RGAM_RAMA_EXP_REGION_END_BASE_R; \
+	type CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS; \
+	type CM_RGAM_LUT_WRITE_EN_MASK; \
+	type CM_RGAM_LUT_WRITE_SEL; \
+	type CM_RGAM_LUT_INDEX; \
+	type RGAM_MEM_PWR_FORCE; \
+	type CM_RGAM_LUT_DATA; \
+	type FMT_STEREOSYNC_OVERRIDE
+
+struct dcn10_opp_shift {
+	OPP_DCN10_REG_FIELD_LIST(uint8_t);
+};
+
+struct dcn10_opp_mask {
+	OPP_DCN10_REG_FIELD_LIST(uint32_t);
+};
+
+struct dcn10_opp_registers {
+	uint32_t CM_RGAM_LUT_WRITE_EN_MASK;
+	uint32_t CM_RGAM_CONTROL;
+	uint32_t OBUF_CONTROL;
+	uint32_t FMT_BIT_DEPTH_CONTROL;
+	uint32_t FMT_CONTROL;
+	uint32_t FMT_DITHER_RAND_R_SEED;
+	uint32_t FMT_DITHER_RAND_G_SEED;
+	uint32_t FMT_DITHER_RAND_B_SEED;
+	uint32_t FMT_CLAMP_CNTL;
+	uint32_t FMT_DYNAMIC_EXP_CNTL;
+	uint32_t FMT_MAP420_MEMORY_CONTROL;
+	uint32_t CM_OCSC_CONTROL;
+	uint32_t CM_RGAM_RAMB_START_CNTL_B;
+	uint32_t CM_RGAM_RAMB_START_CNTL_G;
+	uint32_t CM_RGAM_RAMB_START_CNTL_R;
+	uint32_t CM_RGAM_RAMB_SLOPE_CNTL_B;
+	uint32_t CM_RGAM_RAMB_SLOPE_CNTL_G;
+	uint32_t CM_RGAM_RAMB_SLOPE_CNTL_R;
+	uint32_t CM_RGAM_RAMB_END_CNTL1_B;
+	uint32_t CM_RGAM_RAMB_END_CNTL2_B;
+	uint32_t CM_RGAM_RAMB_END_CNTL1_G;
+	uint32_t CM_RGAM_RAMB_END_CNTL2_G;
+	uint32_t CM_RGAM_RAMB_END_CNTL1_R;
+	uint32_t CM_RGAM_RAMB_END_CNTL2_R;
+	uint32_t CM_RGAM_RAMB_REGION_0_1;
+	uint32_t CM_RGAM_RAMB_REGION_2_3;
+	uint32_t CM_RGAM_RAMB_REGION_4_5;
+	uint32_t CM_RGAM_RAMB_REGION_6_7;
+	uint32_t CM_RGAM_RAMB_REGION_8_9;
+	uint32_t CM_RGAM_RAMB_REGION_10_11;
+	uint32_t CM_RGAM_RAMB_REGION_12_13;
+	uint32_t CM_RGAM_RAMB_REGION_14_15;
+	uint32_t CM_RGAM_RAMB_REGION_16_17;
+	uint32_t CM_RGAM_RAMB_REGION_18_19;
+	uint32_t CM_RGAM_RAMB_REGION_20_21;
+	uint32_t CM_RGAM_RAMB_REGION_22_23;
+	uint32_t CM_RGAM_RAMB_REGION_24_25;
+	uint32_t CM_RGAM_RAMB_REGION_26_27;
+	uint32_t CM_RGAM_RAMB_REGION_28_29;
+	uint32_t CM_RGAM_RAMB_REGION_30_31;
+	uint32_t CM_RGAM_RAMB_REGION_32_33;
+	uint32_t CM_RGAM_RAMA_START_CNTL_B;
+	uint32_t CM_RGAM_RAMA_START_CNTL_G;
+	uint32_t CM_RGAM_RAMA_START_CNTL_R;
+	uint32_t CM_RGAM_RAMA_SLOPE_CNTL_B;
+	uint32_t CM_RGAM_RAMA_SLOPE_CNTL_G;
+	uint32_t CM_RGAM_RAMA_SLOPE_CNTL_R;
+	uint32_t CM_RGAM_RAMA_END_CNTL1_B;
+	uint32_t CM_RGAM_RAMA_END_CNTL2_B;
+	uint32_t CM_RGAM_RAMA_END_CNTL1_G;
+	uint32_t CM_RGAM_RAMA_END_CNTL2_G;
+	uint32_t CM_RGAM_RAMA_END_CNTL1_R;
+	uint32_t CM_RGAM_RAMA_END_CNTL2_R;
+	uint32_t CM_RGAM_RAMA_REGION_0_1;
+	uint32_t CM_RGAM_RAMA_REGION_2_3;
+	uint32_t CM_RGAM_RAMA_REGION_4_5;
+	uint32_t CM_RGAM_RAMA_REGION_6_7;
+	uint32_t CM_RGAM_RAMA_REGION_8_9;
+	uint32_t CM_RGAM_RAMA_REGION_10_11;
+	uint32_t CM_RGAM_RAMA_REGION_12_13;
+	uint32_t CM_RGAM_RAMA_REGION_14_15;
+	uint32_t CM_RGAM_RAMA_REGION_16_17;
+	uint32_t CM_RGAM_RAMA_REGION_18_19;
+	uint32_t CM_RGAM_RAMA_REGION_20_21;
+	uint32_t CM_RGAM_RAMA_REGION_22_23;
+	uint32_t CM_RGAM_RAMA_REGION_24_25;
+	uint32_t CM_RGAM_RAMA_REGION_26_27;
+	uint32_t CM_RGAM_RAMA_REGION_28_29;
+	uint32_t CM_RGAM_RAMA_REGION_30_31;
+	uint32_t CM_RGAM_RAMA_REGION_32_33;
+	uint32_t CM_RGAM_LUT_INDEX;
+	uint32_t CM_MEM_PWR_CTRL;
+	uint32_t CM_RGAM_LUT_DATA;
+};
+
+struct dcn10_opp {
+	struct output_pixel_processor base;
+
+	const struct dcn10_opp_registers *regs;
+	const struct dcn10_opp_shift *opp_shift;
+	const struct dcn10_opp_mask *opp_mask;
+
+	bool is_write_to_ram_a_safe;
+};
+
+void dcn10_opp_construct(struct dcn10_opp *oppn10,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn10_opp_registers *regs,
+	const struct dcn10_opp_shift *opp_shift,
+	const struct dcn10_opp_mask *opp_mask);
+
+#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
new file mode 100644
index 0000000..7aa438c
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -0,0 +1,1475 @@
+/*
+* Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dc.h"
+
+#include "resource.h"
+#include "include/irq_service_interface.h"
+#include "dcn10/dcn10_resource.h"
+
+#include "dcn10/dcn10_ipp.h"
+#include "dcn10/dcn10_mpc.h"
+#include "irq/dcn10/irq_service_dcn10.h"
+#include "dcn10/dcn10_transform.h"
+#include "dcn10/dcn10_timing_generator.h"
+#include "dcn10/dcn10_hw_sequencer.h"
+#include "dce110/dce110_hw_sequencer.h"
+#include "dcn10/dcn10_opp.h"
+#include "dce/dce_link_encoder.h"
+#include "dce/dce_stream_encoder.h"
+#include "dce/dce_clocks.h"
+#include "dce/dce_clock_source.h"
+#include "dcn10/dcn10_mem_input.h"
+#include "dce/dce_audio.h"
+#include "dce/dce_hwseq.h"
+#include "../virtual/virtual_stream_encoder.h"
+#include "dce110/dce110_resource.h"
+
+#include "vega10/soc15ip.h"
+
+#include "raven1/DCN/dcn_1_0_offset.h"
+#include "raven1/DCN/dcn_1_0_sh_mask.h"
+
+#include "raven1/NBIO/nbio_7_0_offset.h"
+
+#include "raven1/MMHUB/mmhub_9_1_offset.h"
+#include "raven1/MMHUB/mmhub_9_1_sh_mask.h"
+
+#include "reg_helper.h"
+#include "dce/dce_abm.h"
+#include "dce/dce_dmcu.h"
+
+#ifndef mmDP0_DP_DPHY_INTERNAL_CTRL
+	#define mmDP0_DP_DPHY_INTERNAL_CTRL		0x210f
+	#define mmDP0_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+	#define mmDP1_DP_DPHY_INTERNAL_CTRL		0x220f
+	#define mmDP1_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+	#define mmDP2_DP_DPHY_INTERNAL_CTRL		0x230f
+	#define mmDP2_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+	#define mmDP3_DP_DPHY_INTERNAL_CTRL		0x240f
+	#define mmDP3_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+	#define mmDP4_DP_DPHY_INTERNAL_CTRL		0x250f
+	#define mmDP4_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+	#define mmDP5_DP_DPHY_INTERNAL_CTRL		0x260f
+	#define mmDP5_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+	#define mmDP6_DP_DPHY_INTERNAL_CTRL		0x270f
+	#define mmDP6_DP_DPHY_INTERNAL_CTRL_BASE_IDX	2
+#endif
+
+
+enum dcn10_clk_src_array_id {
+	DCN10_CLK_SRC_PLL0,
+	DCN10_CLK_SRC_PLL1,
+	DCN10_CLK_SRC_PLL2,
+	DCN10_CLK_SRC_PLL3,
+	DCN10_CLK_SRC_TOTAL
+};
+
+/* begin *********************
+ * macros to expend register list macro defined in HW object header file */
+
+/* DCN */
+#define BASE_INNER(seg) \
+	DCE_BASE__INST0_SEG ## seg
+
+#define BASE(seg) \
+	BASE_INNER(seg)
+
+#define SR(reg_name)\
+		.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \
+					mm ## reg_name
+
+#define SRI(reg_name, block, id)\
+	.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \
+					mm ## block ## id ## _ ## reg_name
+
+
+#define SRII(reg_name, block, id)\
+	.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \
+					mm ## block ## id ## _ ## reg_name
+
+/* NBIO */
+#define NBIO_BASE_INNER(seg) \
+	NBIF_BASE__INST0_SEG ## seg
+
+#define NBIO_BASE(seg) \
+	NBIO_BASE_INNER(seg)
+
+#define NBIO_SR(reg_name)\
+		.reg_name = NBIO_BASE(mm ## reg_name ## _BASE_IDX) +  \
+					mm ## reg_name
+
+/* GC */
+#define GC_BASE_INNER(seg) \
+	GC_BASE__INST0_SEG ## seg
+
+#define GC_BASE(seg) \
+	GC_BASE_INNER(seg)
+
+#define GC_SR(reg_name)\
+		.reg_name = GC_BASE(mm ## reg_name ## _BASE_IDX) +  \
+					mm ## reg_name
+
+/* macros to expend register list macro defined in HW object header file
+ * end *********************/
+
+static const struct dce_disp_clk_registers disp_clk_regs = {
+		CLK_DCN10_REG_LIST()
+};
+
+static const struct dce_disp_clk_shift disp_clk_shift = {
+		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+};
+
+static const struct dce_disp_clk_mask disp_clk_mask = {
+		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+};
+
+static const struct dce_dmcu_registers dmcu_regs = {
+		DMCU_DCN10_REG_LIST()
+};
+
+static const struct dce_dmcu_shift dmcu_shift = {
+		DMCU_MASK_SH_LIST_DCN10(__SHIFT)
+};
+
+static const struct dce_dmcu_mask dmcu_mask = {
+		DMCU_MASK_SH_LIST_DCN10(_MASK)
+};
+
+static const struct dce_abm_registers abm_regs = {
+		ABM_DCN10_REG_LIST(0)
+};
+
+static const struct dce_abm_shift abm_shift = {
+		ABM_MASK_SH_LIST_DCN10(__SHIFT)
+};
+
+static const struct dce_abm_mask abm_mask = {
+		ABM_MASK_SH_LIST_DCN10(_MASK)
+};
+
+#define stream_enc_regs(id)\
+[id] = {\
+	SE_DCN_REG_LIST(id),\
+	.TMDS_CNTL = 0,\
+	.AFMT_AVI_INFO0 = 0,\
+	.AFMT_AVI_INFO1 = 0,\
+	.AFMT_AVI_INFO2 = 0,\
+	.AFMT_AVI_INFO3 = 0,\
+}
+
+static const struct dce110_stream_enc_registers stream_enc_regs[] = {
+	stream_enc_regs(0),
+	stream_enc_regs(1),
+	stream_enc_regs(2),
+	stream_enc_regs(3),
+};
+
+static const struct dce_stream_encoder_shift se_shift = {
+		SE_COMMON_MASK_SH_LIST_DCN10(__SHIFT)
+};
+
+static const struct dce_stream_encoder_mask se_mask = {
+		SE_COMMON_MASK_SH_LIST_DCN10(_MASK),
+		.AFMT_GENERIC0_UPDATE = 0,
+		.AFMT_GENERIC2_UPDATE = 0,
+		.DP_DYN_RANGE = 0,
+		.DP_YCBCR_RANGE = 0,
+		.HDMI_AVI_INFO_SEND = 0,
+		.HDMI_AVI_INFO_CONT = 0,
+		.HDMI_AVI_INFO_LINE = 0,
+		.DP_SEC_AVI_ENABLE = 0,
+		.AFMT_AVI_INFO_VERSION = 0
+};
+
+#define audio_regs(id)\
+[id] = {\
+		AUD_COMMON_REG_LIST(id)\
+}
+
+static const struct dce_audio_registers audio_regs[] = {
+	audio_regs(0),
+	audio_regs(1),
+	audio_regs(2),
+	audio_regs(3),
+};
+
+#define DCE120_AUD_COMMON_MASK_SH_LIST(mask_sh)\
+		SF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX, AZALIA_ENDPOINT_REG_INDEX, mask_sh),\
+		SF(AZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA, AZALIA_ENDPOINT_REG_DATA, mask_sh),\
+		AUD_COMMON_MASK_SH_LIST_BASE(mask_sh)
+
+static const struct dce_audio_shift audio_shift = {
+		DCE120_AUD_COMMON_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce_aduio_mask audio_mask = {
+		DCE120_AUD_COMMON_MASK_SH_LIST(_MASK)
+};
+
+#define aux_regs(id)\
+[id] = {\
+	AUX_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
+		aux_regs(0),
+		aux_regs(1),
+		aux_regs(2),
+		aux_regs(3),
+		aux_regs(4),
+		aux_regs(5)
+};
+
+#define hpd_regs(id)\
+[id] = {\
+	HPD_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {
+		hpd_regs(0),
+		hpd_regs(1),
+		hpd_regs(2),
+		hpd_regs(3),
+		hpd_regs(4),
+		hpd_regs(5)
+};
+
+#define link_regs(id)\
+[id] = {\
+	LE_DCN10_REG_LIST(id), \
+	SRI(DP_DPHY_INTERNAL_CTRL, DP, id) \
+}
+
+static const struct dce110_link_enc_registers link_enc_regs[] = {
+	link_regs(0),
+	link_regs(1),
+	link_regs(2),
+	link_regs(3),
+	link_regs(4),
+	link_regs(5),
+	link_regs(6),
+};
+
+#define ipp_regs(id)\
+[id] = {\
+	IPP_DCN10_REG_LIST(id),\
+}
+
+static const struct dcn10_ipp_registers ipp_regs[] = {
+	ipp_regs(0),
+	ipp_regs(1),
+	ipp_regs(2),
+	ipp_regs(3),
+};
+
+static const struct dcn10_ipp_shift ipp_shift = {
+		IPP_DCN10_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dcn10_ipp_mask ipp_mask = {
+		IPP_DCN10_MASK_SH_LIST(_MASK),
+};
+
+#define opp_regs(id)\
+[id] = {\
+	OPP_DCN10_REG_LIST(id),\
+}
+
+static const struct dcn10_opp_registers opp_regs[] = {
+	opp_regs(0),
+	opp_regs(1),
+	opp_regs(2),
+	opp_regs(3),
+};
+
+static const struct dcn10_opp_shift opp_shift = {
+		OPP_DCN10_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dcn10_opp_mask opp_mask = {
+		OPP_DCN10_MASK_SH_LIST(_MASK),
+};
+
+#define tf_regs(id)\
+[id] = {\
+	TF_REG_LIST_DCN(id),\
+}
+
+static const struct dcn_transform_registers tf_regs[] = {
+	tf_regs(0),
+	tf_regs(1),
+	tf_regs(2),
+	tf_regs(3),
+};
+
+static const struct dcn_transform_shift tf_shift = {
+		TF_REG_LIST_SH_MASK_DCN(__SHIFT)
+};
+
+static const struct dcn_transform_mask tf_mask = {
+		TF_REG_LIST_SH_MASK_DCN(_MASK),
+};
+
+
+static const struct dcn_mpc_registers mpc_regs = {
+	MPC_COMMON_REG_LIST_DCN1_0(0),
+	MPC_COMMON_REG_LIST_DCN1_0(1),
+	MPC_COMMON_REG_LIST_DCN1_0(2),
+	MPC_COMMON_REG_LIST_DCN1_0(3),
+};
+
+static const struct dcn_mpc_shift mpc_shift = {
+	MPC_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)
+};
+
+static const struct dcn_mpc_mask mpc_mask = {
+	MPC_COMMON_MASK_SH_LIST_DCN1_0(_MASK),
+};
+
+#define tg_regs(id)\
+[id] = {TG_COMMON_REG_LIST_DCN1_0(id)}
+
+static const struct dcn_tg_registers tg_regs[] = {
+	tg_regs(0),
+	tg_regs(1),
+	tg_regs(2),
+	tg_regs(3),
+};
+
+static const struct dcn_tg_shift tg_shift = {
+	TG_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)
+};
+
+static const struct dcn_tg_mask tg_mask = {
+	TG_COMMON_MASK_SH_LIST_DCN1_0(_MASK)
+};
+
+
+static const struct bios_registers bios_regs = {
+		NBIO_SR(BIOS_SCRATCH_6)
+};
+
+#define mi_regs(id)\
+[id] = {\
+	MI_DCN10_REG_LIST(id)\
+}
+
+
+static const struct dcn_mi_registers mi_regs[] = {
+	mi_regs(0),
+	mi_regs(1),
+	mi_regs(2),
+	mi_regs(3),
+};
+
+static const struct dcn_mi_shift mi_shift = {
+		MI_DCN10_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dcn_mi_mask mi_mask = {
+		MI_DCN10_MASK_SH_LIST(_MASK)
+};
+
+#define clk_src_regs(index, pllid)\
+[index] = {\
+	CS_COMMON_REG_LIST_DCN1_0(index, pllid),\
+}
+
+static const struct dce110_clk_src_regs clk_src_regs[] = {
+	clk_src_regs(0, A),
+	clk_src_regs(1, B),
+	clk_src_regs(2, C),
+	clk_src_regs(3, D)
+};
+
+static const struct dce110_clk_src_shift cs_shift = {
+		CS_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)
+};
+
+static const struct dce110_clk_src_mask cs_mask = {
+		CS_COMMON_MASK_SH_LIST_DCN1_0(_MASK)
+};
+
+
+static const struct resource_caps res_cap = {
+		.num_timing_generator = 4,
+		.num_video_plane = 4,
+		.num_audio = 4,
+		.num_stream_encoder = 4,
+		.num_pll = 4,
+};
+
+static const struct dc_debug debug_defaults_drv = {
+		.disable_dcc = false,
+		.disable_dpp_power_gate = false,
+		.disable_hubp_power_gate = false,
+		.disable_dmcu = true,
+		.force_abm_enable = false,
+		.timing_trace = false,
+		.disable_pplib_clock_request = true,
+		.disable_pplib_wm_range = true,
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		.use_dml_wm = false,
+		.use_max_voltage = true
+#endif
+};
+
+static const struct dc_debug debug_defaults_diags = {
+		.disable_dpp_power_gate = false,
+		.disable_hubp_power_gate = false,
+		.disable_clock_gate = true,
+		.disable_dmcu = true,
+		.force_abm_enable = false,
+		.timing_trace = true,
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		.disable_pplib_clock_request = true,
+		.disable_pplib_wm_range = true,
+		.use_dml_wm = false,
+		.use_max_voltage = false
+#endif
+};
+
+static void dcn10_transform_destroy(struct transform **xfm)
+{
+	dm_free(TO_DCN10_TRANSFORM(*xfm));
+	*xfm = NULL;
+}
+
+static struct transform *dcn10_transform_create(
+	struct dc_context *ctx,
+	uint32_t inst)
+{
+	struct dcn10_transform *transform =
+		dm_alloc(sizeof(struct dcn10_transform));
+
+	if (!transform)
+		return NULL;
+
+	if (dcn10_transform_construct(transform, ctx,
+			&tf_regs[inst], &tf_shift, &tf_mask))
+		return &transform->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(transform);
+	return NULL;
+}
+
+static struct input_pixel_processor *dcn10_ipp_create(
+	struct dc_context *ctx, uint32_t inst)
+{
+	struct dcn10_ipp *ipp =
+		dm_alloc(sizeof(struct dcn10_ipp));
+
+	if (!ipp) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	dcn10_ipp_construct(ipp, ctx, inst,
+			&ipp_regs[inst], &ipp_shift, &ipp_mask);
+	return &ipp->base;
+}
+
+
+static struct output_pixel_processor *dcn10_opp_create(
+	struct dc_context *ctx, uint32_t inst)
+{
+	struct dcn10_opp *opp =
+		dm_alloc(sizeof(struct dcn10_opp));
+
+	if (!opp) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	dcn10_opp_construct(opp, ctx, inst,
+			&opp_regs[inst], &opp_shift, &opp_mask);
+	return &opp->base;
+}
+
+static struct mpc *dcn10_mpc_create(
+	struct dc_context *ctx)
+{
+	struct dcn10_mpc *mpc = dm_alloc(sizeof(struct dcn10_mpc));
+
+	if (!mpc)
+		return NULL;
+
+	mpc->base.ctx = ctx;
+	mpc->mpc_regs = &mpc_regs;
+	mpc->mpc_shift = &mpc_shift;
+	mpc->mpc_mask = &mpc_mask;
+
+	return &mpc->base;
+}
+
+static void dcn10_mpc_destroy(struct mpc **mpc_base)
+{
+	if (*mpc_base)
+		dm_free(TO_DCN10_MPC(*mpc_base));
+
+	*mpc_base = NULL;
+}
+
+static struct timing_generator *dcn10_timing_generator_create(
+		struct dc_context *ctx,
+		uint32_t instance)
+{
+	struct dcn10_timing_generator *tgn10 =
+		dm_alloc(sizeof(struct dcn10_timing_generator));
+
+	if (!tgn10)
+		return NULL;
+
+	tgn10->base.inst = instance;
+	tgn10->base.ctx = ctx;
+
+	tgn10->tg_regs = &tg_regs[instance];
+	tgn10->tg_shift = &tg_shift;
+	tgn10->tg_mask = &tg_mask;
+
+	dcn10_timing_generator_init(tgn10);
+
+	return &tgn10->base;
+}
+
+static const struct encoder_feature_support link_enc_feature = {
+		.max_hdmi_deep_color = COLOR_DEPTH_121212,
+		.max_hdmi_pixel_clock = 600000,
+		.ycbcr420_supported = true,
+		.flags.bits.IS_HBR2_CAPABLE = true,
+		.flags.bits.IS_HBR3_CAPABLE = true,
+		.flags.bits.IS_TPS3_CAPABLE = true,
+		.flags.bits.IS_TPS4_CAPABLE = true,
+		.flags.bits.IS_YCBCR_CAPABLE = true
+};
+
+struct link_encoder *dcn10_link_encoder_create(
+	const struct encoder_init_data *enc_init_data)
+{
+	struct dce110_link_encoder *enc110 =
+		dm_alloc(sizeof(struct dce110_link_encoder));
+
+	if (!enc110)
+		return NULL;
+
+	if (dce110_link_encoder_construct(
+			enc110,
+			enc_init_data,
+			&link_enc_feature,
+			&link_enc_regs[enc_init_data->transmitter],
+			&link_enc_aux_regs[enc_init_data->channel - 1],
+			&link_enc_hpd_regs[enc_init_data->hpd_source])) {
+
+		return &enc110->base;
+	}
+
+	BREAK_TO_DEBUGGER();
+	dm_free(enc110);
+	return NULL;
+}
+
+struct clock_source *dcn10_clock_source_create(
+	struct dc_context *ctx,
+	struct dc_bios *bios,
+	enum clock_source_id id,
+	const struct dce110_clk_src_regs *regs,
+	bool dp_clk_src)
+{
+	struct dce110_clk_src *clk_src =
+		dm_alloc(sizeof(struct dce110_clk_src));
+
+	if (!clk_src)
+		return NULL;
+
+	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
+			regs, &cs_shift, &cs_mask)) {
+		clk_src->base.dp_clk_src = dp_clk_src;
+		return &clk_src->base;
+	}
+
+	BREAK_TO_DEBUGGER();
+	return NULL;
+}
+
+static void read_dce_straps(
+	struct dc_context *ctx,
+	struct resource_straps *straps)
+{
+	/* TODO: Registers are missing */
+	/*REG_GET_2(CC_DC_HDMI_STRAPS,
+			HDMI_DISABLE, &straps->hdmi_disable,
+			AUDIO_STREAM_NUMBER, &straps->audio_stream_number);
+
+	REG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);*/
+}
+
+static struct audio *create_audio(
+		struct dc_context *ctx, unsigned int inst)
+{
+	return dce_audio_create(ctx, inst,
+			&audio_regs[inst], &audio_shift, &audio_mask);
+}
+
+static struct stream_encoder *dcn10_stream_encoder_create(
+	enum engine_id eng_id,
+	struct dc_context *ctx)
+{
+	struct dce110_stream_encoder *enc110 =
+		dm_alloc(sizeof(struct dce110_stream_encoder));
+
+	if (!enc110)
+		return NULL;
+
+	if (dce110_stream_encoder_construct(
+			enc110, ctx, ctx->dc_bios, eng_id,
+			&stream_enc_regs[eng_id], &se_shift, &se_mask))
+		return &enc110->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(enc110);
+	return NULL;
+}
+
+static const struct dce_hwseq_registers hwseq_reg = {
+		HWSEQ_DCN1_REG_LIST()
+};
+
+static const struct dce_hwseq_shift hwseq_shift = {
+		HWSEQ_DCN1_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce_hwseq_mask hwseq_mask = {
+		HWSEQ_DCN1_MASK_SH_LIST(_MASK)
+};
+
+static struct dce_hwseq *dcn10_hwseq_create(
+	struct dc_context *ctx)
+{
+	struct dce_hwseq *hws = dm_alloc(sizeof(struct dce_hwseq));
+
+	if (hws) {
+		hws->ctx = ctx;
+		hws->regs = &hwseq_reg;
+		hws->shifts = &hwseq_shift;
+		hws->masks = &hwseq_mask;
+	}
+	return hws;
+}
+
+static const struct resource_create_funcs res_create_funcs = {
+	.read_dce_straps = read_dce_straps,
+	.create_audio = create_audio,
+	.create_stream_encoder = dcn10_stream_encoder_create,
+	.create_hwseq = dcn10_hwseq_create,
+};
+
+static const struct resource_create_funcs res_create_maximus_funcs = {
+	.read_dce_straps = NULL,
+	.create_audio = NULL,
+	.create_stream_encoder = NULL,
+	.create_hwseq = dcn10_hwseq_create,
+};
+
+void dcn10_clock_source_destroy(struct clock_source **clk_src)
+{
+	dm_free(TO_DCE110_CLK_SRC(*clk_src));
+	*clk_src = NULL;
+}
+
+static void destruct(struct dcn10_resource_pool *pool)
+{
+	unsigned int i;
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL) {
+			/* TODO: free dcn version of stream encoder once implemented
+			 * rather than using virtual stream encoder
+			 */
+			dm_free(pool->base.stream_enc[i]);
+			pool->base.stream_enc[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			pool->base.opps[i]->funcs->opp_destroy(&pool->base.opps[i]);
+
+		if (pool->base.transforms[i] != NULL)
+			dcn10_transform_destroy(&pool->base.transforms[i]);
+
+		if (pool->base.ipps[i] != NULL)
+			pool->base.ipps[i]->funcs->ipp_destroy(&pool->base.ipps[i]);
+
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCN10_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
+
+		if (pool->base.irqs != NULL) {
+			dal_irq_service_destroy(&pool->base.irqs);
+		}
+
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCN10TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+		dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
+
+	for (i = 0; i < pool->base.audio_count; i++) {
+		if (pool->base.audios[i])
+			dce_aud_destroy(&pool->base.audios[i]);
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL) {
+			dcn10_clock_source_destroy(&pool->base.clock_sources[i]);
+			pool->base.clock_sources[i] = NULL;
+		}
+	}
+
+	if (pool->base.dp_clock_source != NULL) {
+		dcn10_clock_source_destroy(&pool->base.dp_clock_source);
+		pool->base.dp_clock_source = NULL;
+	}
+
+	if (pool->base.mpc != NULL)
+		dcn10_mpc_destroy(&pool->base.mpc);
+
+	if (pool->base.abm != NULL)
+		dce_abm_destroy(&pool->base.abm);
+
+	if (pool->base.dmcu != NULL)
+		dce_dmcu_destroy(&pool->base.dmcu);
+
+	if (pool->base.display_clock != NULL)
+		dce_disp_clk_destroy(&pool->base.display_clock);
+}
+
+static struct mem_input *dcn10_mem_input_create(
+	struct dc_context *ctx,
+	uint32_t inst)
+{
+	struct dcn10_mem_input *mem_inputn10 =
+		dm_alloc(sizeof(struct dcn10_mem_input));
+
+	if (!mem_inputn10)
+		return NULL;
+
+	if (dcn10_mem_input_construct(mem_inputn10, ctx, inst,
+			&mi_regs[inst], &mi_shift, &mi_mask))
+		return &mem_inputn10->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(mem_inputn10);
+	return NULL;
+}
+
+static void get_pixel_clock_parameters(
+	const struct pipe_ctx *pipe_ctx,
+	struct pixel_clk_params *pixel_clk_params)
+{
+	const struct core_stream *stream = pipe_ctx->stream;
+	pixel_clk_params->requested_pix_clk = stream->public.timing.pix_clk_khz;
+	pixel_clk_params->encoder_object_id = stream->sink->link->link_enc->id;
+	pixel_clk_params->signal_type = pipe_ctx->stream->signal;
+	pixel_clk_params->controller_id = pipe_ctx->pipe_idx + 1;
+	/* TODO: un-hardcode*/
+	pixel_clk_params->requested_sym_clk = LINK_RATE_LOW *
+		LINK_RATE_REF_FREQ_IN_KHZ;
+	pixel_clk_params->flags.ENABLE_SS = 0;
+	pixel_clk_params->color_depth =
+		stream->public.timing.display_color_depth;
+	pixel_clk_params->flags.DISPLAY_BLANKED = 1;
+	pixel_clk_params->pixel_encoding = stream->public.timing.pixel_encoding;
+
+	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR422)
+		pixel_clk_params->color_depth = COLOR_DEPTH_888;
+
+	if (stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		pixel_clk_params->requested_pix_clk  /= 2;
+
+	if (stream->public.timing. timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING ||
+		stream->public.timing. timing_3d_format == TIMING_3D_FORMAT_SW_FRAME_PACKING ||
+		stream->public.timing. timing_3d_format == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA)
+		pixel_clk_params->requested_pix_clk *= 2;
+}
+
+static void build_clamping_params(struct core_stream *stream)
+{
+	stream->clamping.clamping_level = CLAMPING_FULL_RANGE;
+	stream->clamping.c_depth = stream->public.timing.display_color_depth;
+	stream->clamping.pixel_encoding = stream->public.timing.pixel_encoding;
+}
+
+static enum dc_status build_pipe_hw_param(struct pipe_ctx *pipe_ctx)
+{
+
+	get_pixel_clock_parameters(pipe_ctx, &pipe_ctx->pix_clk_params);
+
+	pipe_ctx->clock_source->funcs->get_pix_clk_dividers(
+		pipe_ctx->clock_source,
+		&pipe_ctx->pix_clk_params,
+		&pipe_ctx->pll_settings);
+
+	pipe_ctx->stream->clamping.pixel_encoding = pipe_ctx->stream->public.timing.pixel_encoding;
+
+	resource_build_bit_depth_reduction_params(pipe_ctx->stream,
+					&pipe_ctx->stream->bit_depth_params);
+	build_clamping_params(pipe_ctx->stream);
+
+	return DC_OK;
+}
+
+static enum dc_status validate_mapped_resource(
+		const struct core_dc *dc,
+		struct validate_context *context)
+{
+	enum dc_status status = DC_OK;
+	uint8_t i, j;
+
+	for (i = 0; i < context->stream_count; i++) {
+		struct core_stream *stream = context->streams[i];
+		struct core_link *link = stream->sink->link;
+
+		if (resource_is_stream_unchanged(dc->current_context, stream)) {
+			if (stream != NULL && dc->current_context->streams[i] != NULL) {
+				/* todo: shouldn't have to copy missing parameter here */
+				resource_build_bit_depth_reduction_params(stream,
+						&stream->bit_depth_params);
+				stream->clamping.pixel_encoding =
+						stream->public.timing.pixel_encoding;
+
+				resource_build_bit_depth_reduction_params(stream,
+								&stream->bit_depth_params);
+				build_clamping_params(stream);
+
+				continue;
+			}
+		}
+
+		for (j = 0; j < dc->res_pool->pipe_count ; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
+
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
+
+
+			if (!pipe_ctx->tg->funcs->validate_timing(
+					pipe_ctx->tg, &stream->public.timing))
+				return DC_FAIL_CONTROLLER_VALIDATE;
+
+			status = build_pipe_hw_param(pipe_ctx);
+
+			if (status != DC_OK)
+				return status;
+
+			if (!link->link_enc->funcs->validate_output_with_stream(
+				link->link_enc, pipe_ctx))
+				return DC_FAIL_ENC_VALIDATE;
+
+			/* TODO: validate audio ASIC caps, encoder */
+
+			status = dc_link_validate_mode_timing(
+				stream, link, &stream->public.timing);
+
+			if (status != DC_OK)
+				return status;
+
+
+			/* do not need to validate non root pipes */
+			break;
+		}
+	}
+
+	return DC_OK;
+}
+
+enum dc_status dcn10_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context)
+{
+	enum dc_status result = DC_OK;
+	int i;
+
+	if (set_count == 0)
+		return result;
+
+	for (i = 0; i < set_count; i++) {
+		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
+		dc_stream_retain(&context->streams[i]->public);
+		context->stream_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context);
+	if (result != DC_OK)
+		return result;
+
+	result = resource_map_phy_clock_resources(dc, context);
+	if (result != DC_OK)
+		return result;
+
+	result = validate_mapped_resource(dc, context);
+	if (result != DC_OK)
+		return result;
+
+	if (!resource_validate_attach_surfaces(set, set_count,
+			dc->current_context, context, dc->res_pool))
+		return DC_FAIL_ATTACH_SURFACES;
+
+	result = resource_build_scaling_params_for_context(dc, context);
+	if (result != DC_OK)
+		return result;
+
+	if (!dcn_validate_bandwidth(dc, context))
+		return DC_FAIL_BANDWIDTH_VALIDATE;
+
+	return result;
+}
+
+enum dc_status dcn10_validate_guaranteed(
+		const struct core_dc *dc,
+		const struct dc_stream *dc_stream,
+		struct validate_context *context)
+{
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+
+	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
+	dc_stream_retain(&context->streams[0]->public);
+	context->stream_count++;
+
+	result = resource_map_pool_resources(dc, context);
+
+	if (result == DC_OK)
+		result = resource_map_phy_clock_resources(dc, context);
+
+	if (result == DC_OK)
+		result = validate_mapped_resource(dc, context);
+
+	if (result == DC_OK) {
+		validate_guaranteed_copy_streams(
+				context, dc->public.caps.max_streams);
+		result = resource_build_scaling_params_for_context(dc, context);
+	}
+	if (result == DC_OK && !dcn_validate_bandwidth(dc, context))
+		return DC_FAIL_BANDWIDTH_VALIDATE;
+
+	return result;
+}
+
+static struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(
+		struct validate_context *context,
+		const struct resource_pool *pool,
+		struct core_stream *stream)
+{
+	struct resource_context *res_ctx = &context->res_ctx;
+	struct pipe_ctx *head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
+	struct pipe_ctx *idle_pipe = find_idle_secondary_pipe(res_ctx, pool);
+
+	if (!head_pipe)
+		ASSERT(0);
+
+	if (!idle_pipe)
+		return false;
+
+	idle_pipe->stream = head_pipe->stream;
+	idle_pipe->tg = head_pipe->tg;
+
+	idle_pipe->mi = pool->mis[idle_pipe->pipe_idx];
+	idle_pipe->ipp = pool->ipps[idle_pipe->pipe_idx];
+	idle_pipe->xfm = pool->transforms[idle_pipe->pipe_idx];
+	idle_pipe->opp = pool->opps[idle_pipe->pipe_idx];
+
+	return idle_pipe;
+}
+
+enum dcc_control {
+	dcc_control__256_256_xxx,
+	dcc_control__128_128_xxx,
+	dcc_control__256_64_64,
+};
+
+enum segment_order {
+	segment_order__na,
+	segment_order__contiguous,
+	segment_order__non_contiguous,
+};
+
+static bool dcc_support_pixel_format(
+		enum surface_pixel_format format,
+		unsigned int *bytes_per_element)
+{
+	/* DML: get_bytes_per_element */
+	switch (format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		*bytes_per_element = 2;
+		return true;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		*bytes_per_element = 4;
+		return true;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		*bytes_per_element = 8;
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool dcc_support_swizzle(
+		enum swizzle_mode_values swizzle,
+		unsigned int bytes_per_element,
+		enum segment_order *segment_order_horz,
+		enum segment_order *segment_order_vert)
+{
+	bool standard_swizzle = false;
+	bool display_swizzle = false;
+
+	switch (swizzle) {
+	case DC_SW_4KB_S:
+	case DC_SW_64KB_S:
+	case DC_SW_VAR_S:
+	case DC_SW_4KB_S_X:
+	case DC_SW_64KB_S_X:
+	case DC_SW_VAR_S_X:
+		standard_swizzle = true;
+		break;
+	case DC_SW_4KB_D:
+	case DC_SW_64KB_D:
+	case DC_SW_VAR_D:
+	case DC_SW_4KB_D_X:
+	case DC_SW_64KB_D_X:
+	case DC_SW_VAR_D_X:
+		display_swizzle = true;
+		break;
+	default:
+		break;
+	};
+
+	if (bytes_per_element == 1 && standard_swizzle) {
+		*segment_order_horz = segment_order__contiguous;
+		*segment_order_vert = segment_order__na;
+		return true;
+	}
+	if (bytes_per_element == 2 && standard_swizzle) {
+		*segment_order_horz = segment_order__non_contiguous;
+		*segment_order_vert = segment_order__contiguous;
+		return true;
+	}
+	if (bytes_per_element == 4 && standard_swizzle) {
+		*segment_order_horz = segment_order__non_contiguous;
+		*segment_order_vert = segment_order__contiguous;
+		return true;
+	}
+	if (bytes_per_element == 8 && standard_swizzle) {
+		*segment_order_horz = segment_order__na;
+		*segment_order_vert = segment_order__contiguous;
+		return true;
+	}
+	if (bytes_per_element == 8 && display_swizzle) {
+		*segment_order_horz = segment_order__contiguous;
+		*segment_order_vert = segment_order__non_contiguous;
+		return true;
+	}
+
+	return false;
+}
+
+static void get_blk256_size(unsigned int *blk256_width, unsigned int *blk256_height,
+		unsigned int bytes_per_element)
+{
+	/* copied from DML.  might want to refactor DML to leverage from DML */
+	/* DML : get_blk256_size */
+	if (bytes_per_element == 1) {
+		*blk256_width = 16;
+		*blk256_height = 16;
+	} else if (bytes_per_element == 2) {
+		*blk256_width = 16;
+		*blk256_height = 8;
+	} else if (bytes_per_element == 4) {
+		*blk256_width = 8;
+		*blk256_height = 8;
+	} else if (bytes_per_element == 8) {
+		*blk256_width = 8;
+		*blk256_height = 4;
+	}
+}
+
+static void det_request_size(
+		unsigned int height,
+		unsigned int width,
+		unsigned int bpe,
+		bool *req128_horz_wc,
+		bool *req128_vert_wc)
+{
+	unsigned int detile_buf_size = 164 * 1024;  /* 164KB for DCN1.0 */
+
+	unsigned int blk256_height = 0;
+	unsigned int blk256_width = 0;
+	unsigned int swath_bytes_horz_wc, swath_bytes_vert_wc;
+
+	get_blk256_size(&blk256_width, &blk256_height, bpe);
+
+	swath_bytes_horz_wc = height * blk256_height * bpe;
+	swath_bytes_vert_wc = width * blk256_width * bpe;
+
+	*req128_horz_wc = (2 * swath_bytes_horz_wc <= detile_buf_size) ?
+			false : /* full 256B request */
+			true; /* half 128b request */
+
+	*req128_vert_wc = (2 * swath_bytes_vert_wc <= detile_buf_size) ?
+			false : /* full 256B request */
+			true; /* half 128b request */
+}
+
+static bool get_dcc_compression_cap(const struct dc *dc,
+		const struct dc_dcc_surface_param *input,
+		struct dc_surface_dcc_cap *output)
+{
+	/* implement section 1.6.2.1 of DCN1_Programming_Guide.docx */
+	enum dcc_control dcc_control;
+	unsigned int bpe;
+	enum segment_order segment_order_horz, segment_order_vert;
+	bool req128_horz_wc, req128_vert_wc;
+
+	memset(output, 0, sizeof(*output));
+
+	if (dc->debug.disable_dcc)
+		return false;
+
+	if (!dcc_support_pixel_format(input->format,
+			&bpe))
+		return false;
+
+	if (!dcc_support_swizzle(input->swizzle_mode, bpe,
+			&segment_order_horz, &segment_order_vert))
+		return false;
+
+	det_request_size(input->surface_size.height,  input->surface_size.width,
+			bpe, &req128_horz_wc, &req128_vert_wc);
+
+	if (!req128_horz_wc && !req128_vert_wc) {
+		dcc_control = dcc_control__256_256_xxx;
+	} else if (input->scan == SCAN_DIRECTION_HORIZONTAL) {
+		if (!req128_horz_wc)
+			dcc_control = dcc_control__256_256_xxx;
+		else if (segment_order_horz == segment_order__contiguous)
+			dcc_control = dcc_control__128_128_xxx;
+		else
+			dcc_control = dcc_control__256_64_64;
+	} else if (input->scan == SCAN_DIRECTION_VERTICAL) {
+		if (!req128_vert_wc)
+			dcc_control = dcc_control__256_256_xxx;
+		else if (segment_order_vert == segment_order__contiguous)
+			dcc_control = dcc_control__128_128_xxx;
+		else
+			dcc_control = dcc_control__256_64_64;
+	} else {
+		if ((req128_horz_wc &&
+			segment_order_horz == segment_order__non_contiguous) ||
+			(req128_vert_wc &&
+			segment_order_vert == segment_order__non_contiguous))
+			/* access_dir not known, must use most constraining */
+			dcc_control = dcc_control__256_64_64;
+		else
+			/* reg128 is true for either horz and vert
+			 * but segment_order is contiguous
+			 */
+			dcc_control = dcc_control__128_128_xxx;
+	}
+
+	switch (dcc_control) {
+	case dcc_control__256_256_xxx:
+		output->grph.rgb.max_uncompressed_blk_size = 256;
+		output->grph.rgb.max_compressed_blk_size = 256;
+		output->grph.rgb.independent_64b_blks = false;
+		break;
+	case dcc_control__128_128_xxx:
+		output->grph.rgb.max_uncompressed_blk_size = 128;
+		output->grph.rgb.max_compressed_blk_size = 128;
+		output->grph.rgb.independent_64b_blks = false;
+		break;
+	case dcc_control__256_64_64:
+		output->grph.rgb.max_uncompressed_blk_size = 256;
+		output->grph.rgb.max_compressed_blk_size = 64;
+		output->grph.rgb.independent_64b_blks = true;
+		break;
+	}
+	output->capable = true;
+	output->const_color_support = false;
+
+	return true;
+}
+
+
+static void dcn10_destroy_resource_pool(struct resource_pool **pool)
+{
+	struct dcn10_resource_pool *dcn10_pool = TO_DCN10_RES_POOL(*pool);
+
+	destruct(dcn10_pool);
+	dm_free(dcn10_pool);
+	*pool = NULL;
+}
+
+
+static struct dc_cap_funcs cap_funcs = {
+	.get_dcc_compression_cap = get_dcc_compression_cap
+};
+
+static struct resource_funcs dcn10_res_pool_funcs = {
+	.destroy = dcn10_destroy_resource_pool,
+	.link_enc_create = dcn10_link_encoder_create,
+	.validate_with_context = dcn10_validate_with_context,
+	.validate_guaranteed = dcn10_validate_guaranteed,
+	.validate_bandwidth = dcn_validate_bandwidth,
+	.acquire_idle_pipe_for_layer = dcn10_acquire_idle_pipe_for_layer,
+};
+
+static bool construct(
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dcn10_resource_pool *pool)
+{
+	int i;
+	struct dc_context *ctx = dc->ctx;
+
+	ctx->dc_bios->regs = &bios_regs;
+
+	pool->base.res_cap = &res_cap;
+	pool->base.funcs = &dcn10_res_pool_funcs;
+
+	/*
+	 * TODO fill in from actual raven resource when we create
+	 * more than virtual encoder
+	 */
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
+
+	/* TODO: Hardcode to correct number of functional controllers */
+	pool->base.pipe_count = 4;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 100;
+	dc->public.caps.max_cursor_size = 256;
+
+	if (dc->ctx->dce_environment == DCE_ENV_PRODUCTION_DRV)
+		dc->public.debug = debug_defaults_drv;
+	else
+		dc->public.debug = debug_defaults_diags;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+	pool->base.clock_sources[DCN10_CLK_SRC_PLL0] =
+			dcn10_clock_source_create(ctx, ctx->dc_bios,
+				CLOCK_SOURCE_COMBO_PHY_PLL0,
+				&clk_src_regs[0], false);
+	pool->base.clock_sources[DCN10_CLK_SRC_PLL1] =
+			dcn10_clock_source_create(ctx, ctx->dc_bios,
+				CLOCK_SOURCE_COMBO_PHY_PLL1,
+				&clk_src_regs[1], false);
+	pool->base.clock_sources[DCN10_CLK_SRC_PLL2] =
+			dcn10_clock_source_create(ctx, ctx->dc_bios,
+				CLOCK_SOURCE_COMBO_PHY_PLL2,
+				&clk_src_regs[2], false);
+	pool->base.clock_sources[DCN10_CLK_SRC_PLL3] =
+			dcn10_clock_source_create(ctx, ctx->dc_bios,
+				CLOCK_SOURCE_COMBO_PHY_PLL3,
+				&clk_src_regs[3], false);
+
+	pool->base.clk_src_count = DCN10_CLK_SRC_TOTAL;
+
+	pool->base.dp_clock_source =
+			dcn10_clock_source_create(ctx, ctx->dc_bios,
+				CLOCK_SOURCE_ID_DP_DTO,
+				/* todo: not reuse phy_pll registers */
+				&clk_src_regs[0], true);
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto clock_source_create_fail;
+		}
+	}
+
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		pool->base.display_clock = dce120_disp_clk_create(ctx,
+				&disp_clk_regs,
+				&disp_clk_shift,
+				&disp_clk_mask);
+		if (pool->base.display_clock == NULL) {
+			dm_error("DC: failed to create display clock!\n");
+			BREAK_TO_DEBUGGER();
+			goto disp_clk_create_fail;
+		}
+	}
+
+	pool->base.dmcu = dcn10_dmcu_create(ctx,
+			&dmcu_regs,
+			&dmcu_shift,
+			&dmcu_mask);
+	if (pool->base.dmcu == NULL) {
+		dm_error("DC: failed to create dmcu!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	pool->base.abm = dce_abm_create(ctx,
+			&abm_regs,
+			&abm_shift,
+			&abm_mask);
+	if (pool->base.abm == NULL) {
+		dm_error("DC: failed to create abm!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	dml_init_instance(&dc->dml, DML_PROJECT_RAVEN1);
+	dc->dcn_ip = dcn10_ip_defaults;
+	dc->dcn_soc = dcn10_soc_defaults;
+	if (!dc->public.debug.disable_pplib_clock_request)
+		dcn_bw_update_from_pplib(dc);
+	dcn_bw_sync_calcs_and_dml(dc);
+	if (!dc->public.debug.disable_pplib_wm_range)
+		dcn_bw_notify_pplib_of_wm_ranges(dc);
+
+	{
+	#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_dcn10_create(&init_data);
+		if (!pool->base.irqs)
+			goto irqs_create_fail;
+	#endif
+	}
+
+	/* mem input -> ipp -> transform -> opp -> TG */
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.mis[i] = dcn10_mem_input_create(ctx, i);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create memory input!\n");
+			goto mi_create_fail;
+		}
+
+		pool->base.ipps[i] = dcn10_ipp_create(ctx, i);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create input pixel processor!\n");
+			goto ipp_create_fail;
+		}
+
+		pool->base.transforms[i] = dcn10_transform_create(ctx, i);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create transform!\n");
+			goto transform_create_fail;
+		}
+
+		pool->base.opps[i] = dcn10_opp_create(ctx, i);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC: failed to create output pixel processor!\n");
+			goto opp_create_fail;
+		}
+
+		pool->base.timing_generators[i] = dcn10_timing_generator_create(
+				ctx, i);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto otg_create_fail;
+		}
+	}
+
+	pool->base.mpc = dcn10_mpc_create(ctx);
+
+	if (!resource_construct(num_virtual_links, dc, &pool->base,
+			(!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment) ?
+			&res_create_funcs : &res_create_maximus_funcs)))
+			goto res_create_fail;
+
+	dcn10_hw_sequencer_construct(dc);
+	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+
+	dc->public.cap_funcs = cap_funcs;
+
+	return true;
+
+disp_clk_create_fail:
+otg_create_fail:
+opp_create_fail:
+transform_create_fail:
+ipp_create_fail:
+mi_create_fail:
+irqs_create_fail:
+res_create_fail:
+clock_source_create_fail:
+
+	destruct(pool);
+
+	return false;
+}
+
+struct resource_pool *dcn10_create_resource_pool(
+		uint8_t num_virtual_links,
+		struct core_dc *dc)
+{
+	struct dcn10_resource_pool *pool =
+		dm_alloc(sizeof(struct dcn10_resource_pool));
+
+	if (!pool)
+		return NULL;
+
+	if (construct(num_virtual_links, dc, pool))
+		return &pool->base;
+
+	BREAK_TO_DEBUGGER();
+	return NULL;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h
new file mode 100644
index 0000000..5f84dbd
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h
@@ -0,0 +1,47 @@
+/*
+* Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_RESOURCE_DCN10_H__
+#define __DC_RESOURCE_DCN10_H__
+
+#include "core_types.h"
+
+#define TO_DCN10_RES_POOL(pool)\
+	container_of(pool, struct dcn10_resource_pool, base)
+
+struct core_dc;
+struct resource_pool;
+struct _vcs_dpi_display_pipe_params_st;
+
+struct dcn10_resource_pool {
+	struct resource_pool base;
+};
+struct resource_pool *dcn10_create_resource_pool(
+		uint8_t num_virtual_links,
+		struct core_dc *dc);
+
+
+#endif /* __DC_RESOURCE_DCN10_H__ */
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c
new file mode 100644
index 0000000..d7072132
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c
@@ -0,0 +1,1202 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "dcn10_timing_generator.h"
+
+#define REG(reg)\
+	tgn10->tg_regs->reg
+
+#define CTX \
+	tgn10->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	tgn10->tg_shift->field_name, tgn10->tg_mask->field_name
+
+#define STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN 0x100
+
+/**
+* apply_front_porch_workaround  TODO FPGA still need?
+*
+* This is a workaround for a bug that has existed since R5xx and has not been
+* fixed keep Front porch at minimum 2 for Interlaced mode or 1 for progressive.
+*/
+static void tg_apply_front_porch_workaround(
+	struct timing_generator *tg,
+	struct dc_crtc_timing *timing)
+{
+	if (timing->flags.INTERLACE == 1) {
+		if (timing->v_front_porch < 2)
+			timing->v_front_porch = 2;
+	} else {
+		if (timing->v_front_porch < 1)
+			timing->v_front_porch = 1;
+	}
+}
+
+static void dcn10_program_global_sync(
+		struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	if (tg->dlg_otg_param.vstartup_start == 0) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	REG_SET(OTG_VSTARTUP_PARAM, 0,
+		VSTARTUP_START, tg->dlg_otg_param.vstartup_start);
+
+	REG_SET_2(OTG_VUPDATE_PARAM, 0,
+			VUPDATE_OFFSET, tg->dlg_otg_param.vupdate_offset,
+			VUPDATE_WIDTH, tg->dlg_otg_param.vupdate_width);
+
+	REG_SET(OTG_VREADY_PARAM, 0,
+			VREADY_OFFSET, tg->dlg_otg_param.vready_offset);
+}
+
+struct crtc_stereo_flags {
+	uint8_t PROGRAM_STEREO         :1;
+	uint8_t PROGRAM_POLARITY       :1;
+	uint8_t RIGHT_EYE_POLARITY     :1;
+	uint8_t FRAME_PACKED           :1;
+	uint8_t DISABLE_STEREO_DP_SYNC :1;
+};
+
+static void dcn10_enable_stereo(struct timing_generator *tg,
+		const struct crtc_stereo_flags *flags,
+		const struct dc_crtc_timing *timing)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	uint32_t active_width = timing->h_addressable;
+	uint32_t space1_size = timing->v_total - timing->v_addressable;
+
+	if (flags) {
+		uint32_t stereo_en = flags->FRAME_PACKED == 0 ? 1 : 0;
+
+		if (flags->PROGRAM_STEREO)
+			REG_UPDATE_3(OTG_STEREO_CONTROL,
+					OTG_STEREO_EN, stereo_en,
+					OTG_STEREO_SYNC_OUTPUT_LINE_NUM, 0,
+					OTG_STEREO_SYNC_OUTPUT_POLARITY, 0);
+
+		if (flags->PROGRAM_POLARITY)
+			REG_UPDATE(OTG_STEREO_CONTROL,
+					OTG_STEREO_EYE_FLAG_POLARITY,
+					flags->RIGHT_EYE_POLARITY == 0 ? 0:1);
+
+		if (flags->DISABLE_STEREO_DP_SYNC)
+			REG_UPDATE(OTG_STEREO_CONTROL,
+					OTG_DISABLE_STEREOSYNC_OUTPUT_FOR_DP, 1);
+
+		if (flags->PROGRAM_STEREO && flags->FRAME_PACKED)
+			REG_UPDATE_3(OTG_3D_STRUCTURE_CONTROL,
+					OTG_3D_STRUCTURE_EN, 1,
+					OTG_3D_STRUCTURE_V_UPDATE_MODE, 1,
+					OTG_3D_STRUCTURE_STEREO_SEL_OVR, 1);
+
+	}
+
+	REG_UPDATE(OPPBUF_CONTROL,
+			OPPBUF_ACTIVE_WIDTH, active_width);
+
+	REG_UPDATE(OPPBUF_3D_PARAMETERS_0,
+			OPPBUF_3D_VACT_SPACE1_SIZE, space1_size);
+
+	return;
+}
+
+static void dcn10_disable_stereo(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_SET(OTG_STEREO_CONTROL, 0,
+			OTG_STEREO_EN, 0);
+
+	REG_SET_3(OTG_3D_STRUCTURE_CONTROL, 0,
+			OTG_3D_STRUCTURE_EN, 0,
+			OTG_3D_STRUCTURE_V_UPDATE_MODE, 0,
+			OTG_3D_STRUCTURE_STEREO_SEL_OVR, 0);
+
+	REG_UPDATE(OPPBUF_CONTROL,
+			OPPBUF_ACTIVE_WIDTH, 0);
+	REG_UPDATE(OPPBUF_3D_PARAMETERS_0,
+			OPPBUF_3D_VACT_SPACE1_SIZE, 0);
+	return;
+}
+
+static bool is_frame_alternate_stereo(enum dc_timing_3d_format fmt)
+{
+	bool ret = false;
+	if (fmt == TIMING_3D_FORMAT_FRAME_ALTERNATE ||
+		fmt == TIMING_3D_FORMAT_INBAND_FA ||
+		fmt == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA ||
+		fmt == TIMING_3D_FORMAT_SIDEBAND_FA)
+		ret = true;
+	return ret;
+}
+
+static void dcn10_do_stereo(struct timing_generator *tg,
+		const struct dc_crtc_timing *dc_crtc_timing)
+{
+	struct crtc_stereo_flags stereo_flags = {0};
+	if (dc_crtc_timing->timing_3d_format == TIMING_3D_FORMAT_NONE ||
+		dc_crtc_timing->timing_3d_format == TIMING_3D_FORMAT_SIDE_BY_SIDE ||
+		dc_crtc_timing->timing_3d_format == TIMING_3D_FORMAT_TOP_AND_BOTTOM)
+		dcn10_disable_stereo(tg);
+	else {
+		stereo_flags.PROGRAM_STEREO = 1;
+		stereo_flags.PROGRAM_POLARITY = 1;
+		stereo_flags.DISABLE_STEREO_DP_SYNC = 0;
+		stereo_flags.RIGHT_EYE_POLARITY =
+				dc_crtc_timing->flags.RIGHT_EYE_3D_POLARITY;
+		if (dc_crtc_timing->timing_3d_format ==
+				TIMING_3D_FORMAT_HW_FRAME_PACKING)
+			stereo_flags.FRAME_PACKED = 1;
+
+		if (is_frame_alternate_stereo(
+				dc_crtc_timing->timing_3d_format) ||
+				dc_crtc_timing->timing_3d_format ==
+					TIMING_3D_FORMAT_HW_FRAME_PACKING)
+			dcn10_enable_stereo(tg, &stereo_flags, dc_crtc_timing);
+	}
+}
+
+/**
+ * program_timing_generator   used by mode timing set
+ * Program CRTC Timing Registers - OTG_H_*, OTG_V_*, Pixel repetition.
+ * Including SYNC. Call BIOS command table to program Timings.
+ */
+static void tg_program_timing_generator(
+	struct timing_generator *tg,
+	const struct dc_crtc_timing *dc_crtc_timing)
+{
+	struct dc_crtc_timing patched_crtc_timing;
+	uint32_t vesa_sync_start;
+	uint32_t asic_blank_end;
+	uint32_t asic_blank_start;
+	uint32_t v_total;
+	uint32_t v_sync_end;
+	uint32_t v_init, v_fp2;
+	uint32_t h_sync_polarity, v_sync_polarity;
+	uint32_t interlace_factor;
+	uint32_t start_point = 0;
+	uint32_t field_num = 0;
+	uint32_t h_div_2;
+
+
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	patched_crtc_timing = *dc_crtc_timing;
+	tg_apply_front_porch_workaround(tg, &patched_crtc_timing);
+
+	/* Load horizontal timing */
+
+	/* CRTC_H_TOTAL = vesa.h_total - 1 */
+	REG_SET(OTG_H_TOTAL, 0,
+			OTG_H_TOTAL,  patched_crtc_timing.h_total - 1);
+
+	/* h_sync_start = 0, h_sync_end = vesa.h_sync_width */
+	REG_UPDATE_2(OTG_H_SYNC_A,
+			OTG_H_SYNC_A_START, 0,
+			OTG_H_SYNC_A_END, patched_crtc_timing.h_sync_width);
+
+	/* asic_h_blank_end = HsyncWidth + HbackPorch =
+	 * vesa. usHorizontalTotal - vesa. usHorizontalSyncStart -
+	 * vesa.h_left_border
+	 */
+	vesa_sync_start = patched_crtc_timing.h_addressable +
+			patched_crtc_timing.h_border_right +
+			patched_crtc_timing.h_front_porch;
+
+	asic_blank_end = patched_crtc_timing.h_total -
+			vesa_sync_start -
+			patched_crtc_timing.h_border_left;
+
+	/* h_blank_start = v_blank_end + v_active */
+	asic_blank_start = asic_blank_end +
+			patched_crtc_timing.h_border_left +
+			patched_crtc_timing.h_addressable +
+			patched_crtc_timing.h_border_right;
+
+	REG_UPDATE_2(OTG_H_BLANK_START_END,
+			OTG_H_BLANK_START, asic_blank_start,
+			OTG_H_BLANK_END, asic_blank_end);
+
+	/* h_sync polarity */
+	h_sync_polarity = patched_crtc_timing.flags.HSYNC_POSITIVE_POLARITY ?
+			0 : 1;
+
+	REG_UPDATE(OTG_H_SYNC_A_CNTL,
+			OTG_H_SYNC_A_POL, h_sync_polarity);
+
+	/* Load vertical timing */
+
+	/* CRTC_V_TOTAL = v_total - 1 */
+	if (patched_crtc_timing.flags.INTERLACE) {
+		interlace_factor = 2;
+		v_total = 2 * patched_crtc_timing.v_total;
+	} else {
+		interlace_factor = 1;
+		v_total = patched_crtc_timing.v_total - 1;
+	}
+	REG_SET(OTG_V_TOTAL, 0,
+			OTG_V_TOTAL, v_total);
+
+	/* v_sync_start = 0, v_sync_end = v_sync_width */
+	v_sync_end = patched_crtc_timing.v_sync_width * interlace_factor;
+
+	REG_UPDATE_2(OTG_V_SYNC_A,
+			OTG_V_SYNC_A_START, 0,
+			OTG_V_SYNC_A_END, v_sync_end);
+
+	vesa_sync_start = patched_crtc_timing.v_addressable +
+			patched_crtc_timing.v_border_bottom +
+			patched_crtc_timing.v_front_porch;
+
+	asic_blank_end = (patched_crtc_timing.v_total -
+			vesa_sync_start -
+			patched_crtc_timing.v_border_top)
+			* interlace_factor;
+
+	/* v_blank_start = v_blank_end + v_active */
+	asic_blank_start = asic_blank_end +
+			(patched_crtc_timing.v_border_top +
+			patched_crtc_timing.v_addressable +
+			patched_crtc_timing.v_border_bottom)
+			* interlace_factor;
+
+	REG_UPDATE_2(OTG_V_BLANK_START_END,
+			OTG_V_BLANK_START, asic_blank_start,
+			OTG_V_BLANK_END, asic_blank_end);
+
+
+	/* v_sync polarity */
+	v_sync_polarity = patched_crtc_timing.flags.VSYNC_POSITIVE_POLARITY ?
+			0 : 1;
+
+	REG_UPDATE(OTG_V_SYNC_A_CNTL,
+			OTG_V_SYNC_A_POL, v_sync_polarity);
+
+	v_init = asic_blank_start;
+	if (tg->dlg_otg_param.signal == SIGNAL_TYPE_DISPLAY_PORT ||
+		tg->dlg_otg_param.signal == SIGNAL_TYPE_DISPLAY_PORT_MST ||
+		tg->dlg_otg_param.signal == SIGNAL_TYPE_EDP) {
+		v_init = asic_blank_start;
+		start_point = 1;
+		if (patched_crtc_timing.flags.INTERLACE == 1)
+			field_num = 1;
+	}
+	if (v_init < 0)
+		v_init = 0;
+	v_fp2 = 0;
+	if (tg->dlg_otg_param.vstartup_start > asic_blank_end)
+		v_fp2 = tg->dlg_otg_param.vstartup_start > asic_blank_end;
+
+	/* Interlace */
+	if (patched_crtc_timing.flags.INTERLACE == 1) {
+		REG_UPDATE(OTG_INTERLACE_CONTROL,
+				OTG_INTERLACE_ENABLE, 1);
+		v_init = v_init / 2;
+		if ((tg->dlg_otg_param.vstartup_start/2)*2 > asic_blank_end)
+			v_fp2 = v_fp2 / 2;
+	}
+	else
+		REG_UPDATE(OTG_INTERLACE_CONTROL,
+				OTG_INTERLACE_ENABLE, 0);
+
+
+	/* VTG enable set to 0 first VInit */
+	REG_UPDATE(CONTROL,
+			VTG0_ENABLE, 0);
+
+	REG_UPDATE_2(CONTROL,
+			VTG0_FP2, v_fp2,
+			VTG0_VCOUNT_INIT, v_init);
+
+	/* original code is using VTG offset to address OTG reg, seems wrong */
+	REG_UPDATE_2(OTG_CONTROL,
+			OTG_START_POINT_CNTL, start_point,
+			OTG_FIELD_NUMBER_CNTL, field_num);
+
+	dcn10_program_global_sync(tg);
+
+	/* TODO
+	 * patched_crtc_timing.flags.HORZ_COUNT_BY_TWO == 1
+	 * program_horz_count_by_2
+	 * for DVI 30bpp mode, 0 otherwise
+	 * program_horz_count_by_2(tg, &patched_crtc_timing);
+	 */
+
+	/* Enable stereo - only when we need to pack 3D frame. Other types
+	 * of stereo handled in explicit call
+	 */
+	h_div_2 = (dc_crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) ?
+			1 : 0;
+
+	REG_UPDATE(OTG_H_TIMING_CNTL,
+			OTG_H_TIMING_DIV_BY2, h_div_2);
+
+	/* Enable crtc stereo frame pack tested... todo more
+	 */
+	dcn10_do_stereo(tg, &patched_crtc_timing);
+}
+
+/** tg_program_blanking
+ * Only programmed part of OTG_H, OTG_V register for set_plane_config
+ * Assume other OTG registers are programmed by video mode set already.
+ * This function is for underlay. DCN will have new sequence.
+ * This function will be removed. Need remove it from set_plane_config
+ */
+
+static void tg_program_timing(struct timing_generator *tg,
+	const struct dc_crtc_timing *timing,
+	bool use_vbios)
+{
+	tg_program_timing_generator(tg, timing);
+}
+
+/**
+ * unblank_crtc
+ * Call ASIC Control Object to UnBlank CRTC.
+ */
+static void tg_unblank_crtc(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_UPDATE_2(OTG_BLANK_CONTROL,
+			OTG_BLANK_DATA_EN, 0,
+			OTG_BLANK_DE_MODE, 0);
+}
+
+/**
+ * blank_crtc
+ * Call ASIC Control Object to Blank CRTC.
+ */
+
+static void tg_blank_crtc(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_UPDATE_2(OTG_BLANK_CONTROL,
+			OTG_BLANK_DATA_EN, 1,
+			OTG_BLANK_DE_MODE, 0);
+
+	/* todo: why are we waiting for BLANK_DATA_EN?  shouldn't we be waiting
+	 * for status?
+	 */
+	REG_WAIT(OTG_BLANK_CONTROL,
+			OTG_BLANK_DATA_EN, 1,
+			20000, 200000);
+
+	REG_UPDATE(OTG_DOUBLE_BUFFER_CONTROL,
+			OTG_BLANK_DATA_DOUBLE_BUFFER_EN, 0);
+}
+
+static void tg_set_blank(struct timing_generator *tg,
+		bool enable_blanking)
+{
+	if (enable_blanking)
+		tg_blank_crtc(tg);
+	else
+		tg_unblank_crtc(tg);
+}
+
+static bool tg_is_blanked(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+	uint32_t blank_en;
+	uint32_t blank_state;
+
+	REG_GET_2(OTG_BLANK_CONTROL,
+			OTG_BLANK_DATA_EN, &blank_en,
+			OTG_CURRENT_BLANK_STATE, &blank_state);
+
+	return blank_en && blank_state;
+}
+
+static void enable_optc_clock(struct timing_generator *tg, bool enable)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	if (enable) {
+		REG_UPDATE(OPTC_INPUT_CLOCK_CONTROL,
+				OPTC_INPUT_CLK_EN, 1);
+
+		REG_WAIT(OPTC_INPUT_CLOCK_CONTROL,
+				OPTC_INPUT_CLK_ON, 1,
+				20000, 200000);
+
+		/* Enable clock */
+		REG_UPDATE(OTG_CLOCK_CONTROL,
+				OTG_CLOCK_EN, 1);
+
+		REG_WAIT(OTG_CLOCK_CONTROL,
+				OTG_CLOCK_ON, 1,
+				20000, 200000);
+	} else  {
+		REG_UPDATE_2(OTG_CLOCK_CONTROL,
+				OTG_CLOCK_GATE_DIS, 0,
+				OTG_CLOCK_EN, 0);
+
+		REG_WAIT(OTG_CLOCK_CONTROL,
+				OTG_CLOCK_ON, 0,
+				20000, 200000);
+
+		REG_UPDATE_2(OPTC_INPUT_CLOCK_CONTROL,
+				OPTC_INPUT_CLK_GATE_DIS, 0,
+				OPTC_INPUT_CLK_EN, 0);
+
+		REG_WAIT(OPTC_INPUT_CLOCK_CONTROL,
+				OPTC_INPUT_CLK_ON, 0,
+				20000, 200000);
+	}
+}
+
+/**
+ * Enable CRTC
+ * Enable CRTC - call ASIC Control Object to enable Timing generator.
+ */
+static bool tg_enable_crtc(struct timing_generator *tg)
+{
+	/* TODO FPGA wait for answer
+	 * OTG_MASTER_UPDATE_MODE != CRTC_MASTER_UPDATE_MODE
+	 * OTG_MASTER_UPDATE_LOCK != CRTC_MASTER_UPDATE_LOCK
+	 */
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	/* opp instance for OTG. For DCN1.0, ODM is remoed.
+	 * OPP and OPTC should 1:1 mapping
+	 */
+	REG_UPDATE(OPTC_DATA_SOURCE_SELECT,
+			OPTC_SRC_SEL, tg->inst);
+
+	/* VTG enable first is for HW workaround */
+	REG_UPDATE(CONTROL,
+			VTG0_ENABLE, 1);
+
+	/* Enable CRTC */
+	REG_UPDATE_2(OTG_CONTROL,
+			OTG_DISABLE_POINT_CNTL, 3,
+			OTG_MASTER_EN, 1);
+
+	return true;
+}
+
+/* disable_crtc - call ASIC Control Object to disable Timing generator. */
+static bool tg_disable_crtc(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	/* disable otg request until end of the first line
+	 * in the vertical blank region
+	 */
+	REG_UPDATE_2(OTG_CONTROL,
+			OTG_DISABLE_POINT_CNTL, 3,
+			OTG_MASTER_EN, 0);
+
+	REG_UPDATE(CONTROL,
+			VTG0_ENABLE, 0);
+
+	/* CRTC disabled, so disable  clock. */
+	REG_WAIT(OTG_CLOCK_CONTROL,
+			OTG_BUSY, 0,
+			2000, 20000);
+
+	return true;
+}
+
+
+static void tg_program_blank_color(
+		struct timing_generator *tg,
+		const struct tg_color *black_color)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_SET_3(OTG_BLACK_COLOR, 0,
+			OTG_BLACK_COLOR_B_CB, black_color->color_b_cb,
+			OTG_BLACK_COLOR_G_Y, black_color->color_g_y,
+			OTG_BLACK_COLOR_R_CR, black_color->color_r_cr);
+}
+
+/**
+ * dcn10_dcn10_timing_generator_disable_vga
+ * Turn OFF VGA Mode and Timing  - DxVGA_CONTROL
+ * VGA Mode and VGA Timing is used by VBIOS on CRT Monitors;
+ */
+/* TODO FPGA FPGA setup is done by Diag which does not enable VGA mode.
+ * VGA is disable by ASIC default. This function is not needed for
+ * FPGA story.
+ * usage:
+ * init_hw  within dc.c
+ * disable_vga_and_power_gate_all_controllers within dce110_hw_sequencer.c
+ * We may move init_hw into DC specific so that we can remove
+ * .disable_vga from upper layer stack
+ */
+static void dcn10_timing_generator_disable_vga(
+			struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	switch (tgn10->base.inst) {
+	case 0:
+		REG_WRITE(D1VGA_CONTROL, 0);
+		break;
+	case 1:
+		REG_WRITE(D2VGA_CONTROL, 0);
+		break;
+	case 2:
+		REG_WRITE(D2VGA_CONTROL, 0);
+		break;
+	case 3:
+		REG_WRITE(D4VGA_CONTROL, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static bool tg_validate_timing(
+	struct timing_generator *tg,
+	const struct dc_crtc_timing *timing)
+{
+	uint32_t interlace_factor;
+	uint32_t v_blank;
+	uint32_t h_blank;
+	uint32_t min_v_blank;
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	ASSERT(timing != NULL);
+
+	interlace_factor = timing->flags.INTERLACE ? 2 : 1;
+	v_blank = (timing->v_total - timing->v_addressable -
+					timing->v_border_top - timing->v_border_bottom) *
+					interlace_factor;
+
+	h_blank = (timing->h_total - timing->h_addressable -
+		timing->h_border_right -
+		timing->h_border_left);
+
+	if (timing->timing_3d_format != TIMING_3D_FORMAT_NONE &&
+		timing->timing_3d_format != TIMING_3D_FORMAT_HW_FRAME_PACKING &&
+		timing->timing_3d_format != TIMING_3D_FORMAT_TOP_AND_BOTTOM &&
+		timing->timing_3d_format != TIMING_3D_FORMAT_SIDE_BY_SIDE &&
+		timing->timing_3d_format != TIMING_3D_FORMAT_FRAME_ALTERNATE)
+		return false;
+
+	/* Temporarily blocking interlacing mode until it's supported */
+	if (timing->flags.INTERLACE == 1)
+		return false;
+
+	/* Check maximum number of pixels supported by Timing Generator
+	 * (Currently will never fail, in order to fail needs display which
+	 * needs more than 8192 horizontal and
+	 * more than 8192 vertical total pixels)
+	 */
+	if (timing->h_total > tgn10->max_h_total ||
+		timing->v_total > tgn10->max_v_total)
+		return false;
+
+
+	if (h_blank < tgn10->min_h_blank)
+		return false;
+
+	if (timing->h_sync_width  < tgn10->min_h_sync_width ||
+		 timing->v_sync_width  < tgn10->min_v_sync_width)
+		return false;
+
+	min_v_blank = timing->flags.INTERLACE?tgn10->min_v_blank_interlace:tgn10->min_v_blank;
+
+	if (v_blank < min_v_blank)
+		return false;
+
+	return true;
+
+}
+
+/*
+ * get_vblank_counter
+ *
+ * @brief
+ * Get counter for vertical blanks. use register CRTC_STATUS_FRAME_COUNT which
+ * holds the counter of frames.
+ *
+ * @param
+ * struct timing_generator *tg - [in] timing generator which controls the
+ * desired CRTC
+ *
+ * @return
+ * Counter of frames, which should equal to number of vblanks.
+ */
+static uint32_t tg_get_vblank_counter(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+	uint32_t frame_count;
+
+	REG_GET(OTG_STATUS_FRAME_COUNT,
+		OTG_FRAME_COUNT, &frame_count);
+
+	return frame_count;
+}
+
+void dcn10_lock(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+			OTG_MASTER_UPDATE_LOCK, 1);
+}
+
+void dcn10_unlock(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+			OTG_MASTER_UPDATE_LOCK, 0);
+
+	/* why are we waiting here? */
+	REG_WAIT(OTG_DOUBLE_BUFFER_CONTROL,
+			OTG_UPDATE_PENDING, 0,
+			20000, 200000);
+}
+
+static void dcn10_get_position(struct timing_generator *tg,
+		struct crtc_position *position)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_GET_2(OTG_STATUS_POSITION,
+			OTG_HORZ_COUNT, &position->horizontal_count,
+			OTG_VERT_COUNT, &position->vertical_count);
+
+	REG_GET(OTG_NOM_VERT_POSITION,
+			OTG_VERT_COUNT_NOM, &position->nominal_vcount);
+}
+
+bool  dcn10_is_counter_moving(struct timing_generator *tg)
+{
+	struct crtc_position position1, position2;
+
+	tg->funcs->get_position(tg, &position1);
+	tg->funcs->get_position(tg, &position2);
+
+	if (position1.horizontal_count == position2.horizontal_count &&
+		position1.vertical_count == position2.vertical_count)
+		return false;
+	else
+		return true;
+}
+
+static bool dcn10_did_triggered_reset_occur(
+	struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+	uint32_t occurred;
+
+	REG_GET(OTG_FORCE_COUNT_NOW_CNTL,
+		OTG_FORCE_COUNT_NOW_OCCURRED, &occurred);
+
+	return occurred != 0;
+}
+
+static void dcn10_enable_reset_trigger(struct timing_generator *tg, int source_tg_inst)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+	uint32_t falling_edge;
+
+	REG_GET(OTG_V_SYNC_A_CNTL,
+			OTG_V_SYNC_A_POL, &falling_edge);
+
+	if (falling_edge)
+		REG_SET_3(OTG_TRIGA_CNTL, 0,
+				/* vsync signal from selected OTG pipe based
+				 * on OTG_TRIG_SOURCE_PIPE_SELECT setting
+				 */
+				OTG_TRIGA_SOURCE_SELECT, 20,
+				OTG_TRIGA_SOURCE_PIPE_SELECT, source_tg_inst,
+				/* always detect falling edge */
+				OTG_TRIGA_FALLING_EDGE_DETECT_CNTL, 1);
+	else
+		REG_SET_3(OTG_TRIGA_CNTL, 0,
+				/* vsync signal from selected OTG pipe based
+				 * on OTG_TRIG_SOURCE_PIPE_SELECT setting
+				 */
+				OTG_TRIGA_SOURCE_SELECT, 20,
+				OTG_TRIGA_SOURCE_PIPE_SELECT, source_tg_inst,
+				/* always detect rising edge */
+				OTG_TRIGA_RISING_EDGE_DETECT_CNTL, 1);
+
+	REG_SET(OTG_FORCE_COUNT_NOW_CNTL, 0,
+			/* force H count to H_TOTAL and V count to V_TOTAL in
+			 * progressive mode and V_TOTAL-1 in interlaced mode
+			 */
+			OTG_FORCE_COUNT_NOW_MODE, 2);
+}
+
+static void dcn10_disable_reset_trigger(struct timing_generator *tg)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	REG_WRITE(OTG_TRIGA_CNTL, 0);
+
+	REG_SET(OTG_FORCE_COUNT_NOW_CNTL, 0,
+			OTG_FORCE_COUNT_NOW_CLEAR, 1);
+}
+
+static void dcn10_wait_for_state(struct timing_generator *tg,
+		enum crtc_state state)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	switch (state) {
+	case CRTC_STATE_VBLANK:
+		REG_WAIT(OTG_STATUS,
+				OTG_V_BLANK, 1,
+				100, 100000); /* 1 vupdate at 10hz */
+		break;
+
+	case CRTC_STATE_VACTIVE:
+		REG_WAIT(OTG_STATUS,
+				OTG_V_ACTIVE_DISP, 1,
+				100, 100000); /* 1 vupdate at 10hz */
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void set_early_control(
+	struct timing_generator *tg,
+	uint32_t early_cntl)
+{
+	/* asic design change, do not need this control
+	 * empty for share caller logic
+	 */
+}
+
+
+static void set_static_screen_control(
+	struct timing_generator *tg,
+	uint32_t value)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	/* Bit 8 is no longer applicable in RV for PSR case,
+	 * set bit 8 to 0 if given
+	 */
+	if ((value & STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN)
+			!= 0)
+		value = value &
+		~STATIC_SCREEN_EVENT_MASK_RANGETIMING_DOUBLE_BUFFER_UPDATE_EN;
+
+	REG_SET_2(OTG_STATIC_SCREEN_CONTROL, 0,
+			OTG_STATIC_SCREEN_EVENT_MASK, value,
+			OTG_STATIC_SCREEN_FRAME_COUNT, 2);
+}
+
+
+/**
+ *****************************************************************************
+ *  Function: set_drr
+ *
+ *  @brief
+ *     Program dynamic refresh rate registers m_OTGx_OTG_V_TOTAL_*.
+ *
+ *****************************************************************************
+ */
+void dcn10_timing_generator_set_drr(
+	struct timing_generator *tg,
+	const struct drr_params *params)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+
+	if (params != NULL &&
+		params->vertical_total_max > 0 &&
+		params->vertical_total_min > 0) {
+
+		REG_SET(OTG_V_TOTAL_MAX, 0,
+			OTG_V_TOTAL_MAX, params->vertical_total_max - 1);
+
+		REG_SET(OTG_V_TOTAL_MIN, 0,
+			OTG_V_TOTAL_MIN, params->vertical_total_min - 1);
+
+		REG_UPDATE_5(OTG_V_TOTAL_CONTROL,
+				OTG_V_TOTAL_MIN_SEL, 1,
+				OTG_V_TOTAL_MAX_SEL, 1,
+				OTG_FORCE_LOCK_ON_EVENT, 0,
+				OTG_SET_V_TOTAL_MIN_MASK_EN, 0,
+				OTG_SET_V_TOTAL_MIN_MASK, 0);
+	} else {
+		REG_SET(OTG_V_TOTAL_MIN, 0,
+			OTG_V_TOTAL_MIN, 0);
+
+		REG_SET(OTG_V_TOTAL_MAX, 0,
+			OTG_V_TOTAL_MAX, 0);
+
+		REG_UPDATE_4(OTG_V_TOTAL_CONTROL,
+				OTG_SET_V_TOTAL_MIN_MASK, 0,
+				OTG_V_TOTAL_MIN_SEL, 0,
+				OTG_V_TOTAL_MAX_SEL, 0,
+				OTG_FORCE_LOCK_ON_EVENT, 0);
+	}
+}
+
+static void dcn10_timing_generator_set_test_pattern(
+	struct timing_generator *tg,
+	/* TODO: replace 'controller_dp_test_pattern' by 'test_pattern_mode'
+	 * because this is not DP-specific (which is probably somewhere in DP
+	 * encoder) */
+	enum controller_dp_test_pattern test_pattern,
+	enum dc_color_depth color_depth)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+	enum test_pattern_color_format bit_depth;
+	enum test_pattern_dyn_range dyn_range;
+	enum test_pattern_mode mode;
+	uint32_t pattern_mask;
+	uint32_t pattern_data;
+	/* color ramp generator mixes 16-bits color */
+	uint32_t src_bpc = 16;
+	/* requested bpc */
+	uint32_t dst_bpc;
+	uint32_t index;
+	/* RGB values of the color bars.
+	 * Produce two RGB colors: RGB0 - white (all Fs)
+	 * and RGB1 - black (all 0s)
+	 * (three RGB components for two colors)
+	 */
+	uint16_t src_color[6] = {0xFFFF, 0xFFFF, 0xFFFF, 0x0000,
+						0x0000, 0x0000};
+	/* dest color (converted to the specified color format) */
+	uint16_t dst_color[6];
+	uint32_t inc_base;
+
+	/* translate to bit depth */
+	switch (color_depth) {
+	case COLOR_DEPTH_666:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_6;
+	break;
+	case COLOR_DEPTH_888:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;
+	break;
+	case COLOR_DEPTH_101010:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_10;
+	break;
+	case COLOR_DEPTH_121212:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_12;
+	break;
+	default:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;
+	break;
+	}
+
+	switch (test_pattern) {
+	case CONTROLLER_DP_TEST_PATTERN_COLORSQUARES:
+	case CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA:
+	{
+		dyn_range = (test_pattern ==
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA ?
+				TEST_PATTERN_DYN_RANGE_CEA :
+				TEST_PATTERN_DYN_RANGE_VESA);
+		mode = TEST_PATTERN_MODE_COLORSQUARES_RGB;
+
+		REG_UPDATE_2(OTG_TEST_PATTERN_PARAMETERS,
+				OTG_TEST_PATTERN_VRES, 6,
+				OTG_TEST_PATTERN_HRES, 6);
+
+		REG_UPDATE_4(OTG_TEST_PATTERN_CONTROL,
+				OTG_TEST_PATTERN_EN, 1,
+				OTG_TEST_PATTERN_MODE, mode,
+				OTG_TEST_PATTERN_DYNAMIC_RANGE, dyn_range,
+				OTG_TEST_PATTERN_COLOR_FORMAT, bit_depth);
+	}
+	break;
+
+	case CONTROLLER_DP_TEST_PATTERN_VERTICALBARS:
+	case CONTROLLER_DP_TEST_PATTERN_HORIZONTALBARS:
+	{
+		mode = (test_pattern ==
+			CONTROLLER_DP_TEST_PATTERN_VERTICALBARS ?
+			TEST_PATTERN_MODE_VERTICALBARS :
+			TEST_PATTERN_MODE_HORIZONTALBARS);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+			dst_bpc = 6;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+			dst_bpc = 8;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+			dst_bpc = 10;
+		break;
+		default:
+			dst_bpc = 8;
+		break;
+		}
+
+		/* adjust color to the required colorFormat */
+		for (index = 0; index < 6; index++) {
+			/* dst = 2^dstBpc * src / 2^srcBpc = src >>
+			 * (srcBpc - dstBpc);
+			 */
+			dst_color[index] =
+				src_color[index] >> (src_bpc - dst_bpc);
+		/* CRTC_TEST_PATTERN_DATA has 16 bits,
+		 * lowest 6 are hardwired to ZERO
+		 * color bits should be left aligned aligned to MSB
+		 * XXXXXXXXXX000000 for 10 bit,
+		 * XXXXXXXX00000000 for 8 bit and XXXXXX0000000000 for 6
+		 */
+			dst_color[index] <<= (16 - dst_bpc);
+		}
+
+		REG_WRITE(OTG_TEST_PATTERN_PARAMETERS, 0);
+
+		/* We have to write the mask before data, similar to pipeline.
+		 * For example, for 8 bpc, if we want RGB0 to be magenta,
+		 * and RGB1 to be cyan,
+		 * we need to make 7 writes:
+		 * MASK   DATA
+		 * 000001 00000000 00000000                     set mask to R0
+		 * 000010 11111111 00000000     R0 255, 0xFF00, set mask to G0
+		 * 000100 00000000 00000000     G0 0,   0x0000, set mask to B0
+		 * 001000 11111111 00000000     B0 255, 0xFF00, set mask to R1
+		 * 010000 00000000 00000000     R1 0,   0x0000, set mask to G1
+		 * 100000 11111111 00000000     G1 255, 0xFF00, set mask to B1
+		 * 100000 11111111 00000000     B1 255, 0xFF00
+		 *
+		 * we will make a loop of 6 in which we prepare the mask,
+		 * then write, then prepare the color for next write.
+		 * first iteration will write mask only,
+		 * but each next iteration color prepared in
+		 * previous iteration will be written within new mask,
+		 * the last component will written separately,
+		 * mask is not changing between 6th and 7th write
+		 * and color will be prepared by last iteration
+		 */
+
+		/* write color, color values mask in CRTC_TEST_PATTERN_MASK
+		 * is B1, G1, R1, B0, G0, R0
+		 */
+		pattern_data = 0;
+		for (index = 0; index < 6; index++) {
+			/* prepare color mask, first write PATTERN_DATA
+			 * will have all zeros
+			 */
+			pattern_mask = (1 << index);
+
+			/* write color component */
+			REG_SET_2(OTG_TEST_PATTERN_COLOR, 0,
+					OTG_TEST_PATTERN_MASK, pattern_mask,
+					OTG_TEST_PATTERN_DATA, pattern_data);
+
+			/* prepare next color component,
+			 * will be written in the next iteration
+			 */
+			pattern_data = dst_color[index];
+		}
+		/* write last color component,
+		 * it's been already prepared in the loop
+		 */
+		REG_SET_2(OTG_TEST_PATTERN_COLOR, 0,
+				OTG_TEST_PATTERN_MASK, pattern_mask,
+				OTG_TEST_PATTERN_DATA, pattern_data);
+
+		/* enable test pattern */
+		REG_UPDATE_4(OTG_TEST_PATTERN_CONTROL,
+				OTG_TEST_PATTERN_EN, 1,
+				OTG_TEST_PATTERN_MODE, mode,
+				OTG_TEST_PATTERN_DYNAMIC_RANGE, 0,
+				OTG_TEST_PATTERN_COLOR_FORMAT, bit_depth);
+	}
+	break;
+
+	case CONTROLLER_DP_TEST_PATTERN_COLORRAMP:
+	{
+		mode = (bit_depth ==
+			TEST_PATTERN_COLOR_FORMAT_BPC_10 ?
+			TEST_PATTERN_MODE_DUALRAMP_RGB :
+			TEST_PATTERN_MODE_SINGLERAMP_RGB);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+			dst_bpc = 6;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+			dst_bpc = 8;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+			dst_bpc = 10;
+		break;
+		default:
+			dst_bpc = 8;
+		break;
+		}
+
+		/* increment for the first ramp for one color gradation
+		 * 1 gradation for 6-bit color is 2^10
+		 * gradations in 16-bit color
+		 */
+		inc_base = (src_bpc - dst_bpc);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+		{
+			REG_UPDATE_5(OTG_TEST_PATTERN_PARAMETERS,
+					OTG_TEST_PATTERN_INC0, inc_base,
+					OTG_TEST_PATTERN_INC1, 0,
+					OTG_TEST_PATTERN_HRES, 6,
+					OTG_TEST_PATTERN_VRES, 6,
+					OTG_TEST_PATTERN_RAMP0_OFFSET, 0);
+		}
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+		{
+			REG_UPDATE_5(OTG_TEST_PATTERN_PARAMETERS,
+					OTG_TEST_PATTERN_INC0, inc_base,
+					OTG_TEST_PATTERN_INC1, 0,
+					OTG_TEST_PATTERN_HRES, 8,
+					OTG_TEST_PATTERN_VRES, 6,
+					OTG_TEST_PATTERN_RAMP0_OFFSET, 0);
+		}
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+		{
+			REG_UPDATE_5(OTG_TEST_PATTERN_PARAMETERS,
+					OTG_TEST_PATTERN_INC0, inc_base,
+					OTG_TEST_PATTERN_INC1, inc_base + 2,
+					OTG_TEST_PATTERN_HRES, 8,
+					OTG_TEST_PATTERN_VRES, 5,
+					OTG_TEST_PATTERN_RAMP0_OFFSET, 384 << 6);
+		}
+		break;
+		default:
+		break;
+		}
+
+		REG_WRITE(OTG_TEST_PATTERN_COLOR, 0);
+
+		/* enable test pattern */
+		REG_WRITE(OTG_TEST_PATTERN_CONTROL, 0);
+
+		REG_SET_4(OTG_TEST_PATTERN_CONTROL, 0,
+				OTG_TEST_PATTERN_EN, 1,
+				OTG_TEST_PATTERN_MODE, mode,
+				OTG_TEST_PATTERN_DYNAMIC_RANGE, 0,
+				OTG_TEST_PATTERN_COLOR_FORMAT, bit_depth);
+	}
+	break;
+	case CONTROLLER_DP_TEST_PATTERN_VIDEOMODE:
+	{
+		REG_WRITE(OTG_TEST_PATTERN_CONTROL, 0);
+		REG_WRITE(OTG_TEST_PATTERN_COLOR, 0);
+		REG_WRITE(OTG_TEST_PATTERN_PARAMETERS, 0);
+	}
+	break;
+	default:
+		break;
+
+	}
+}
+
+void dcn10_timing_generator_get_crtc_scanoutpos(
+	struct timing_generator *tg,
+	uint32_t *v_blank_start,
+	uint32_t *v_blank_end,
+	uint32_t *h_position,
+	uint32_t *v_position)
+{
+	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
+	struct crtc_position position;
+
+	REG_GET_2(OTG_V_BLANK_START_END,
+			OTG_V_BLANK_START, v_blank_start,
+			OTG_V_BLANK_END, v_blank_end);
+
+	dcn10_get_position(tg, &position);
+
+	*h_position = position.horizontal_count;
+	*v_position = position.vertical_count;
+}
+
+static struct timing_generator_funcs dcn10_tg_funcs = {
+		.validate_timing = tg_validate_timing,
+		.program_timing = tg_program_timing,
+		.program_global_sync = dcn10_program_global_sync,
+		.enable_crtc = tg_enable_crtc,
+		.disable_crtc = tg_disable_crtc,
+		/* used by enable_timing_synchronization. Not need for FPGA */
+		.is_counter_moving = dcn10_is_counter_moving,
+		/* never be called */
+		.get_position = dcn10_get_position,
+		.get_frame_count = tg_get_vblank_counter,
+		.get_scanoutpos = dcn10_timing_generator_get_crtc_scanoutpos,
+		.set_early_control = set_early_control,
+		/* used by enable_timing_synchronization. Not need for FPGA */
+		.wait_for_state = dcn10_wait_for_state,
+		.set_blank = tg_set_blank,
+		.is_blanked = tg_is_blanked,
+		/* never be called */
+		.set_colors = NULL,
+		/* this function will be called by .progam_scaler. dcn and dce
+		 * scaler top level functions are different. .program_scaler is
+		 * not need for dcn. within program_scaler, dcn will return
+		 * early before set_overscan_blank_color is reached
+		 */
+		.set_overscan_blank_color = NULL,
+		.set_blank_color = tg_program_blank_color,
+		/* dcn10_timing_generator_disable_vga */
+		.disable_vga = dcn10_timing_generator_disable_vga,
+		.did_triggered_reset_occur = dcn10_did_triggered_reset_occur,
+		.enable_reset_trigger = dcn10_enable_reset_trigger,
+		.disable_reset_trigger = dcn10_disable_reset_trigger,
+		.lock = dcn10_lock,
+		.unlock = dcn10_unlock,
+		/* dcn10_timing_generator_enable_advanced_request*/
+		.enable_advanced_request = NULL,
+		.enable_optc_clock = enable_optc_clock,
+		.set_drr = dcn10_timing_generator_set_drr,
+		.set_static_screen_control = set_static_screen_control,
+		.set_test_pattern = dcn10_timing_generator_set_test_pattern
+};
+
+void dcn10_timing_generator_init(struct dcn10_timing_generator *tgn10)
+{
+	tgn10->base.funcs = &dcn10_tg_funcs;
+
+	tgn10->max_h_total = tgn10->tg_mask->OTG_H_TOTAL + 1;
+	tgn10->max_v_total = tgn10->tg_mask->OTG_V_TOTAL + 1;
+
+	tgn10->min_h_blank = 32;
+	tgn10->min_v_blank = 3;
+	tgn10->min_v_blank_interlace = 5;
+	tgn10->min_h_sync_width = 8;
+	tgn10->min_v_sync_width = 1;
+}
+
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h
new file mode 100644
index 0000000..85a763a
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h
@@ -0,0 +1,335 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DC_TIMING_GENERATOR_DCN10_H__
+#define __DC_TIMING_GENERATOR_DCN10_H__
+
+#include "timing_generator.h"
+
+#define DCN10TG_FROM_TG(tg)\
+	container_of(tg, struct dcn10_timing_generator, base)
+
+#define TG_COMMON_REG_LIST_DCN1_0(inst) \
+	SRI(OTG_VSTARTUP_PARAM, OTG, inst),\
+	SRI(OTG_VUPDATE_PARAM, OTG, inst),\
+	SRI(OTG_VREADY_PARAM, OTG, inst),\
+	SRI(OTG_BLANK_CONTROL, OTG, inst),\
+	SRI(OTG_MASTER_UPDATE_LOCK, OTG, inst),\
+	SRI(OTG_DOUBLE_BUFFER_CONTROL, OTG, inst),\
+	SRI(OTG_H_TOTAL, OTG, inst),\
+	SRI(OTG_H_BLANK_START_END, OTG, inst),\
+	SRI(OTG_H_SYNC_A, OTG, inst),\
+	SRI(OTG_H_SYNC_A_CNTL, OTG, inst),\
+	SRI(OTG_H_TIMING_CNTL, OTG, inst),\
+	SRI(OTG_V_TOTAL, OTG, inst),\
+	SRI(OTG_V_BLANK_START_END, OTG, inst),\
+	SRI(OTG_V_SYNC_A, OTG, inst),\
+	SRI(OTG_V_SYNC_A_CNTL, OTG, inst),\
+	SRI(OTG_INTERLACE_CONTROL, OTG, inst),\
+	SRI(OTG_CONTROL, OTG, inst),\
+	SRI(OTG_STEREO_CONTROL, OTG, inst),\
+	SRI(OTG_3D_STRUCTURE_CONTROL, OTG, inst),\
+	SRI(OTG_V_TOTAL_MAX, OTG, inst),\
+	SRI(OTG_V_TOTAL_MIN, OTG, inst),\
+	SRI(OTG_V_TOTAL_CONTROL, OTG, inst),\
+	SRI(OTG_TRIGA_CNTL, OTG, inst),\
+	SRI(OTG_FORCE_COUNT_NOW_CNTL, OTG, inst),\
+	SRI(OTG_STATIC_SCREEN_CONTROL, OTG, inst),\
+	SRI(OTG_STATUS_FRAME_COUNT, OTG, inst),\
+	SRI(OTG_STATUS, OTG, inst),\
+	SRI(OTG_STATUS_POSITION, OTG, inst),\
+	SRI(OTG_NOM_VERT_POSITION, OTG, inst),\
+	SRI(OTG_BLACK_COLOR, OTG, inst),\
+	SRI(OTG_TEST_PATTERN_PARAMETERS, OTG, inst),\
+	SRI(OTG_TEST_PATTERN_CONTROL, OTG, inst),\
+	SRI(OTG_TEST_PATTERN_COLOR, OTG, inst),\
+	SRI(OTG_CLOCK_CONTROL, OTG, inst),\
+	SRI(OPTC_INPUT_CLOCK_CONTROL, ODM, inst),\
+	SRI(OPTC_DATA_SOURCE_SELECT, ODM, inst),\
+	SRI(OPPBUF_CONTROL, OPPBUF, inst),\
+	SRI(OPPBUF_3D_PARAMETERS_0, OPPBUF, inst),\
+	SRI(CONTROL, VTG, inst),\
+	SR(D1VGA_CONTROL),\
+	SR(D2VGA_CONTROL),\
+	SR(D3VGA_CONTROL),\
+	SR(D4VGA_CONTROL),\
+
+struct dcn_tg_registers {
+	uint32_t OTG_VSTARTUP_PARAM;
+	uint32_t OTG_VUPDATE_PARAM;
+	uint32_t OTG_VREADY_PARAM;
+	uint32_t OTG_BLANK_CONTROL;
+	uint32_t OTG_MASTER_UPDATE_LOCK;
+	uint32_t OTG_DOUBLE_BUFFER_CONTROL;
+	uint32_t OTG_H_TOTAL;
+	uint32_t OTG_H_BLANK_START_END;
+	uint32_t OTG_H_SYNC_A;
+	uint32_t OTG_H_SYNC_A_CNTL;
+	uint32_t OTG_H_TIMING_CNTL;
+	uint32_t OTG_V_TOTAL;
+	uint32_t OTG_V_BLANK_START_END;
+	uint32_t OTG_V_SYNC_A;
+	uint32_t OTG_V_SYNC_A_CNTL;
+	uint32_t OTG_INTERLACE_CONTROL;
+	uint32_t OTG_CONTROL;
+	uint32_t OTG_STEREO_CONTROL;
+	uint32_t OTG_3D_STRUCTURE_CONTROL;
+	uint32_t OTG_V_TOTAL_MAX;
+	uint32_t OTG_V_TOTAL_MIN;
+	uint32_t OTG_V_TOTAL_CONTROL;
+	uint32_t OTG_TRIGA_CNTL;
+	uint32_t OTG_FORCE_COUNT_NOW_CNTL;
+	uint32_t OTG_STATIC_SCREEN_CONTROL;
+	uint32_t OTG_STATUS_FRAME_COUNT;
+	uint32_t OTG_STATUS;
+	uint32_t OTG_STATUS_POSITION;
+	uint32_t OTG_NOM_VERT_POSITION;
+	uint32_t OTG_BLACK_COLOR;
+	uint32_t OTG_TEST_PATTERN_PARAMETERS;
+	uint32_t OTG_TEST_PATTERN_CONTROL;
+	uint32_t OTG_TEST_PATTERN_COLOR;
+	uint32_t OTG_CLOCK_CONTROL;
+	uint32_t OPTC_INPUT_CLOCK_CONTROL;
+	uint32_t OPTC_DATA_SOURCE_SELECT;
+	uint32_t OPPBUF_CONTROL;
+	uint32_t OPPBUF_3D_PARAMETERS_0;
+	uint32_t CONTROL;
+	/*todo: move VGA to HWSS */
+	uint32_t D1VGA_CONTROL;
+	uint32_t D2VGA_CONTROL;
+	uint32_t D3VGA_CONTROL;
+	uint32_t D4VGA_CONTROL;
+};
+
+#define TG_COMMON_MASK_SH_LIST_DCN1_0(mask_sh)\
+	SF(OTG0_OTG_VSTARTUP_PARAM, VSTARTUP_START, mask_sh),\
+	SF(OTG0_OTG_VUPDATE_PARAM, VUPDATE_OFFSET, mask_sh),\
+	SF(OTG0_OTG_VUPDATE_PARAM, VUPDATE_WIDTH, mask_sh),\
+	SF(OTG0_OTG_VREADY_PARAM, VREADY_OFFSET, mask_sh),\
+	SF(OTG0_OTG_BLANK_CONTROL, OTG_BLANK_DATA_EN, mask_sh),\
+	SF(OTG0_OTG_BLANK_CONTROL, OTG_BLANK_DE_MODE, mask_sh),\
+	SF(OTG0_OTG_BLANK_CONTROL, OTG_CURRENT_BLANK_STATE, mask_sh),\
+	SF(OTG0_OTG_MASTER_UPDATE_LOCK, OTG_MASTER_UPDATE_LOCK, mask_sh),\
+	SF(OTG0_OTG_DOUBLE_BUFFER_CONTROL, OTG_UPDATE_PENDING, mask_sh),\
+	SF(OTG0_OTG_DOUBLE_BUFFER_CONTROL, OTG_BLANK_DATA_DOUBLE_BUFFER_EN, mask_sh),\
+	SF(OTG0_OTG_H_TOTAL, OTG_H_TOTAL, mask_sh),\
+	SF(OTG0_OTG_H_BLANK_START_END, OTG_H_BLANK_START, mask_sh),\
+	SF(OTG0_OTG_H_BLANK_START_END, OTG_H_BLANK_END, mask_sh),\
+	SF(OTG0_OTG_H_SYNC_A, OTG_H_SYNC_A_START, mask_sh),\
+	SF(OTG0_OTG_H_SYNC_A, OTG_H_SYNC_A_END, mask_sh),\
+	SF(OTG0_OTG_H_SYNC_A_CNTL, OTG_H_SYNC_A_POL, mask_sh),\
+	SF(OTG0_OTG_H_TIMING_CNTL, OTG_H_TIMING_DIV_BY2, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL, OTG_V_TOTAL, mask_sh),\
+	SF(OTG0_OTG_V_BLANK_START_END, OTG_V_BLANK_START, mask_sh),\
+	SF(OTG0_OTG_V_BLANK_START_END, OTG_V_BLANK_END, mask_sh),\
+	SF(OTG0_OTG_V_SYNC_A, OTG_V_SYNC_A_START, mask_sh),\
+	SF(OTG0_OTG_V_SYNC_A, OTG_V_SYNC_A_END, mask_sh),\
+	SF(OTG0_OTG_V_SYNC_A_CNTL, OTG_V_SYNC_A_POL, mask_sh),\
+	SF(OTG0_OTG_INTERLACE_CONTROL, OTG_INTERLACE_ENABLE, mask_sh),\
+	SF(OTG0_OTG_CONTROL, OTG_MASTER_EN, mask_sh),\
+	SF(OTG0_OTG_CONTROL, OTG_START_POINT_CNTL, mask_sh),\
+	SF(OTG0_OTG_CONTROL, OTG_DISABLE_POINT_CNTL, mask_sh),\
+	SF(OTG0_OTG_CONTROL, OTG_FIELD_NUMBER_CNTL, mask_sh),\
+	SF(OTG0_OTG_STEREO_CONTROL, OTG_STEREO_EN, mask_sh),\
+	SF(OTG0_OTG_STEREO_CONTROL, OTG_STEREO_SYNC_OUTPUT_LINE_NUM, mask_sh),\
+	SF(OTG0_OTG_STEREO_CONTROL, OTG_STEREO_SYNC_OUTPUT_POLARITY, mask_sh),\
+	SF(OTG0_OTG_STEREO_CONTROL, OTG_STEREO_EYE_FLAG_POLARITY, mask_sh),\
+	SF(OTG0_OTG_STEREO_CONTROL, OTG_DISABLE_STEREOSYNC_OUTPUT_FOR_DP, mask_sh),\
+	SF(OTG0_OTG_3D_STRUCTURE_CONTROL, OTG_3D_STRUCTURE_EN, mask_sh),\
+	SF(OTG0_OTG_3D_STRUCTURE_CONTROL, OTG_3D_STRUCTURE_V_UPDATE_MODE, mask_sh),\
+	SF(OTG0_OTG_3D_STRUCTURE_CONTROL, OTG_3D_STRUCTURE_STEREO_SEL_OVR, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_MAX, OTG_V_TOTAL_MAX, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_MIN, OTG_V_TOTAL_MIN, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_CONTROL, OTG_V_TOTAL_MIN_SEL, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_CONTROL, OTG_V_TOTAL_MAX_SEL, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_CONTROL, OTG_FORCE_LOCK_ON_EVENT, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_CONTROL, OTG_SET_V_TOTAL_MIN_MASK_EN, mask_sh),\
+	SF(OTG0_OTG_V_TOTAL_CONTROL, OTG_SET_V_TOTAL_MIN_MASK, mask_sh),\
+	SF(OTG0_OTG_FORCE_COUNT_NOW_CNTL, OTG_FORCE_COUNT_NOW_CLEAR, mask_sh),\
+	SF(OTG0_OTG_FORCE_COUNT_NOW_CNTL, OTG_FORCE_COUNT_NOW_MODE, mask_sh),\
+	SF(OTG0_OTG_FORCE_COUNT_NOW_CNTL, OTG_FORCE_COUNT_NOW_OCCURRED, mask_sh),\
+	SF(OTG0_OTG_TRIGA_CNTL, OTG_TRIGA_SOURCE_SELECT, mask_sh),\
+	SF(OTG0_OTG_TRIGA_CNTL, OTG_TRIGA_SOURCE_PIPE_SELECT, mask_sh),\
+	SF(OTG0_OTG_TRIGA_CNTL, OTG_TRIGA_RISING_EDGE_DETECT_CNTL, mask_sh),\
+	SF(OTG0_OTG_TRIGA_CNTL, OTG_TRIGA_FALLING_EDGE_DETECT_CNTL, mask_sh),\
+	SF(OTG0_OTG_STATIC_SCREEN_CONTROL, OTG_STATIC_SCREEN_EVENT_MASK, mask_sh),\
+	SF(OTG0_OTG_STATIC_SCREEN_CONTROL, OTG_STATIC_SCREEN_FRAME_COUNT, mask_sh),\
+	SF(OTG0_OTG_STATUS_FRAME_COUNT, OTG_FRAME_COUNT, mask_sh),\
+	SF(OTG0_OTG_STATUS, OTG_V_BLANK, mask_sh),\
+	SF(OTG0_OTG_STATUS, OTG_V_ACTIVE_DISP, mask_sh),\
+	SF(OTG0_OTG_STATUS_POSITION, OTG_HORZ_COUNT, mask_sh),\
+	SF(OTG0_OTG_STATUS_POSITION, OTG_VERT_COUNT, mask_sh),\
+	SF(OTG0_OTG_NOM_VERT_POSITION, OTG_VERT_COUNT_NOM, mask_sh),\
+	SF(OTG0_OTG_BLACK_COLOR, OTG_BLACK_COLOR_B_CB, mask_sh),\
+	SF(OTG0_OTG_BLACK_COLOR, OTG_BLACK_COLOR_G_Y, mask_sh),\
+	SF(OTG0_OTG_BLACK_COLOR, OTG_BLACK_COLOR_R_CR, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_PARAMETERS, OTG_TEST_PATTERN_INC0, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_PARAMETERS, OTG_TEST_PATTERN_INC1, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_PARAMETERS, OTG_TEST_PATTERN_VRES, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_PARAMETERS, OTG_TEST_PATTERN_HRES, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_PARAMETERS, OTG_TEST_PATTERN_RAMP0_OFFSET, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_CONTROL, OTG_TEST_PATTERN_EN, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_CONTROL, OTG_TEST_PATTERN_MODE, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_CONTROL, OTG_TEST_PATTERN_DYNAMIC_RANGE, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_CONTROL, OTG_TEST_PATTERN_COLOR_FORMAT, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_COLOR, OTG_TEST_PATTERN_MASK, mask_sh),\
+	SF(OTG0_OTG_TEST_PATTERN_COLOR, OTG_TEST_PATTERN_DATA, mask_sh),\
+	SF(OTG0_OTG_CLOCK_CONTROL, OTG_BUSY, mask_sh),\
+	SF(OTG0_OTG_CLOCK_CONTROL, OTG_CLOCK_EN, mask_sh),\
+	SF(OTG0_OTG_CLOCK_CONTROL, OTG_CLOCK_ON, mask_sh),\
+	SF(OTG0_OTG_CLOCK_CONTROL, OTG_CLOCK_GATE_DIS, mask_sh),\
+	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_EN, mask_sh),\
+	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_ON, mask_sh),\
+	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_GATE_DIS, mask_sh),\
+	SF(ODM0_OPTC_DATA_SOURCE_SELECT, OPTC_SRC_SEL, mask_sh),\
+	SF(OPPBUF0_OPPBUF_CONTROL, OPPBUF_ACTIVE_WIDTH, mask_sh),\
+	SF(OPPBUF0_OPPBUF_3D_PARAMETERS_0, OPPBUF_3D_VACT_SPACE1_SIZE, mask_sh),\
+	SF(VTG0_CONTROL, VTG0_ENABLE, mask_sh),\
+	SF(VTG0_CONTROL, VTG0_FP2, mask_sh),\
+	SF(VTG0_CONTROL, VTG0_VCOUNT_INIT, mask_sh),\
+
+#define TG_REG_FIELD_LIST(type) \
+	type VSTARTUP_START;\
+	type VUPDATE_OFFSET;\
+	type VUPDATE_WIDTH;\
+	type VREADY_OFFSET;\
+	type OTG_BLANK_DATA_EN;\
+	type OTG_BLANK_DE_MODE;\
+	type OTG_CURRENT_BLANK_STATE;\
+	type OTG_MASTER_UPDATE_LOCK;\
+	type OTG_UPDATE_PENDING;\
+	type OTG_BLANK_DATA_DOUBLE_BUFFER_EN;\
+	type OTG_H_TOTAL;\
+	type OTG_H_BLANK_START;\
+	type OTG_H_BLANK_END;\
+	type OTG_H_SYNC_A_START;\
+	type OTG_H_SYNC_A_END;\
+	type OTG_H_SYNC_A_POL;\
+	type OTG_H_TIMING_DIV_BY2;\
+	type OTG_V_TOTAL;\
+	type OTG_V_BLANK_START;\
+	type OTG_V_BLANK_END;\
+	type OTG_V_SYNC_A_START;\
+	type OTG_V_SYNC_A_END;\
+	type OTG_V_SYNC_A_POL;\
+	type OTG_INTERLACE_ENABLE;\
+	type OTG_MASTER_EN;\
+	type OTG_START_POINT_CNTL;\
+	type OTG_DISABLE_POINT_CNTL;\
+	type OTG_FIELD_NUMBER_CNTL;\
+	type OTG_STEREO_EN;\
+	type OTG_STEREO_SYNC_OUTPUT_LINE_NUM;\
+	type OTG_STEREO_SYNC_OUTPUT_POLARITY;\
+	type OTG_STEREO_EYE_FLAG_POLARITY;\
+	type OTG_DISABLE_STEREOSYNC_OUTPUT_FOR_DP;\
+	type OTG_3D_STRUCTURE_EN;\
+	type OTG_3D_STRUCTURE_V_UPDATE_MODE;\
+	type OTG_3D_STRUCTURE_STEREO_SEL_OVR;\
+	type OTG_V_TOTAL_MAX;\
+	type OTG_V_TOTAL_MIN;\
+	type OTG_V_TOTAL_MIN_SEL;\
+	type OTG_V_TOTAL_MAX_SEL;\
+	type OTG_FORCE_LOCK_ON_EVENT;\
+	type OTG_SET_V_TOTAL_MIN_MASK_EN;\
+	type OTG_SET_V_TOTAL_MIN_MASK;\
+	type OTG_FORCE_COUNT_NOW_CLEAR;\
+	type OTG_FORCE_COUNT_NOW_MODE;\
+	type OTG_FORCE_COUNT_NOW_OCCURRED;\
+	type OTG_TRIGA_SOURCE_SELECT;\
+	type OTG_TRIGA_SOURCE_PIPE_SELECT;\
+	type OTG_TRIGA_RISING_EDGE_DETECT_CNTL;\
+	type OTG_TRIGA_FALLING_EDGE_DETECT_CNTL;\
+	type OTG_STATIC_SCREEN_EVENT_MASK;\
+	type OTG_STATIC_SCREEN_FRAME_COUNT;\
+	type OTG_FRAME_COUNT;\
+	type OTG_V_BLANK;\
+	type OTG_V_ACTIVE_DISP;\
+	type OTG_HORZ_COUNT;\
+	type OTG_VERT_COUNT;\
+	type OTG_VERT_COUNT_NOM;\
+	type OTG_BLACK_COLOR_B_CB;\
+	type OTG_BLACK_COLOR_G_Y;\
+	type OTG_BLACK_COLOR_R_CR;\
+	type OTG_TEST_PATTERN_INC0;\
+	type OTG_TEST_PATTERN_INC1;\
+	type OTG_TEST_PATTERN_VRES;\
+	type OTG_TEST_PATTERN_HRES;\
+	type OTG_TEST_PATTERN_RAMP0_OFFSET;\
+	type OTG_TEST_PATTERN_EN;\
+	type OTG_TEST_PATTERN_MODE;\
+	type OTG_TEST_PATTERN_DYNAMIC_RANGE;\
+	type OTG_TEST_PATTERN_COLOR_FORMAT;\
+	type OTG_TEST_PATTERN_MASK;\
+	type OTG_TEST_PATTERN_DATA;\
+	type OTG_BUSY;\
+	type OTG_CLOCK_EN;\
+	type OTG_CLOCK_ON;\
+	type OTG_CLOCK_GATE_DIS;\
+	type OPTC_INPUT_CLK_EN;\
+	type OPTC_INPUT_CLK_ON;\
+	type OPTC_INPUT_CLK_GATE_DIS;\
+	type OPTC_SRC_SEL;\
+	type OPPBUF_ACTIVE_WIDTH;\
+	type OPPBUF_3D_VACT_SPACE1_SIZE;\
+	type VTG0_ENABLE;\
+	type VTG0_FP2;\
+	type VTG0_VCOUNT_INIT;\
+
+struct dcn_tg_shift {
+	TG_REG_FIELD_LIST(uint8_t)
+};
+
+struct dcn_tg_mask {
+	TG_REG_FIELD_LIST(uint32_t)
+};
+
+struct dcn10_timing_generator {
+	struct timing_generator base;
+
+	const struct dcn_tg_registers *tg_regs;
+	const struct dcn_tg_shift *tg_shift;
+	const struct dcn_tg_mask *tg_mask;
+
+	enum controller_id controller_id;
+
+	uint32_t max_h_total;
+	uint32_t max_v_total;
+
+	uint32_t min_h_blank;
+
+	uint32_t min_h_sync_width;
+	uint32_t min_v_sync_width;
+	uint32_t min_v_blank;
+	uint32_t min_v_blank_interlace;
+};
+
+void dcn10_timing_generator_init(struct dcn10_timing_generator *tg);
+
+void dcn10_timing_generator_set_drr(struct timing_generator *tg,
+	const struct drr_params *params);
+
+void dcn10_unlock(struct timing_generator *tg);
+void dcn10_lock(struct timing_generator *tg);
+#endif /* __DC_TIMING_GENERATOR_DCN10_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.c
new file mode 100644
index 0000000..3718fb5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.c
@@ -0,0 +1,1057 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+
+#include "core_types.h"
+
+#include "include/grph_object_id.h"
+#include "include/fixed31_32.h"
+#include "include/logger_interface.h"
+
+#include "reg_helper.h"
+#include "dcn10_transform.h"
+#include "basics/conversion.h"
+
+#define NUM_PHASES    64
+#define HORZ_MAX_TAPS 8
+#define VERT_MAX_TAPS 8
+
+#define BLACK_OFFSET_RGB_Y 0x0
+#define BLACK_OFFSET_CBCR  0x8000
+
+#define REG(reg)\
+	xfm->tf_regs->reg
+
+#define CTX \
+	xfm->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+
+
+enum dcn10_coef_filter_type_sel {
+	SCL_COEF_LUMA_VERT_FILTER = 0,
+	SCL_COEF_LUMA_HORZ_FILTER = 1,
+	SCL_COEF_CHROMA_VERT_FILTER = 2,
+	SCL_COEF_CHROMA_HORZ_FILTER = 3,
+	SCL_COEF_ALPHA_VERT_FILTER = 4,
+	SCL_COEF_ALPHA_HORZ_FILTER = 5
+};
+
+enum lb_memory_config {
+	/* Enable all 3 pieces of memory */
+	LB_MEMORY_CONFIG_0 = 0,
+
+	/* Enable only the first piece of memory */
+	LB_MEMORY_CONFIG_1 = 1,
+
+	/* Enable only the second piece of memory */
+	LB_MEMORY_CONFIG_2 = 2,
+
+	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
+	 * last piece of chroma memory used for the luma storage
+	 */
+	LB_MEMORY_CONFIG_3 = 3
+};
+
+enum dscl_autocal_mode {
+	AUTOCAL_MODE_OFF = 0,
+
+	/* Autocal calculate the scaling ratio and initial phase and the
+	 * DSCL_MODE_SEL must be set to 1
+	 */
+	AUTOCAL_MODE_AUTOSCALE = 1,
+	/* Autocal perform auto centering without replication and the
+	 * DSCL_MODE_SEL must be set to 0
+	 */
+	AUTOCAL_MODE_AUTOCENTER = 2,
+	/* Autocal perform auto centering and auto replication and the
+	 * DSCL_MODE_SEL must be set to 0
+	 */
+	AUTOCAL_MODE_AUTOREPLICATE = 3
+};
+
+enum dscl_mode_sel {
+	DSCL_MODE_SCALING_444_BYPASS = 0,
+	DSCL_MODE_SCALING_444_RGB_ENABLE = 1,
+	DSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
+	DSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
+	DSCL_MODE_SCALING_420_LUMA_BYPASS = 4,
+	DSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
+	DSCL_MODE_DSCL_BYPASS = 6
+};
+
+enum gamut_remap_select {
+	GAMUT_REMAP_BYPASS = 0,
+	GAMUT_REMAP_COEFF,
+	GAMUT_REMAP_COMA_COEFF,
+	GAMUT_REMAP_COMB_COEFF
+};
+
+static void transform_set_overscan(
+	struct dcn10_transform *xfm,
+	const struct scaler_data *data)
+{
+	uint32_t left = data->recout.x;
+	uint32_t top = data->recout.y;
+
+	int right = data->h_active - data->recout.x - data->recout.width;
+	int bottom = data->v_active - data->recout.y - data->recout.height;
+
+	if (right < 0) {
+		BREAK_TO_DEBUGGER();
+		right = 0;
+	}
+	if (bottom < 0) {
+		BREAK_TO_DEBUGGER();
+		bottom = 0;
+	}
+
+	REG_SET_2(DSCL_EXT_OVERSCAN_LEFT_RIGHT, 0,
+		EXT_OVERSCAN_LEFT, left,
+		EXT_OVERSCAN_RIGHT, right);
+
+	REG_SET_2(DSCL_EXT_OVERSCAN_TOP_BOTTOM, 0,
+		EXT_OVERSCAN_BOTTOM, bottom,
+		EXT_OVERSCAN_TOP, top);
+}
+
+static void transform_set_otg_blank(
+		struct dcn10_transform *xfm, const struct scaler_data *data)
+{
+	uint32_t h_blank_start = data->h_active;
+	uint32_t h_blank_end = 0;
+	uint32_t v_blank_start = data->v_active;
+	uint32_t v_blank_end = 0;
+
+	REG_SET_2(OTG_H_BLANK, 0,
+			OTG_H_BLANK_START, h_blank_start,
+			OTG_H_BLANK_END, h_blank_end);
+
+	REG_SET_2(OTG_V_BLANK, 0,
+			OTG_V_BLANK_START, v_blank_start,
+			OTG_V_BLANK_END, v_blank_end);
+}
+
+static enum dscl_mode_sel get_dscl_mode(const struct scaler_data *data)
+{
+	const long long one = dal_fixed31_32_one.value;
+	bool ycbcr = false;
+	bool format420 = false;
+
+	if (data->format == PIXEL_FORMAT_FP16)
+		return DSCL_MODE_DSCL_BYPASS;
+
+	if (data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+			&& data->format <= PIXEL_FORMAT_VIDEO_END)
+		ycbcr = true;
+
+	if (data->format == PIXEL_FORMAT_420BPP12 ||
+			data->format == PIXEL_FORMAT_420BPP15)
+		format420 = true;
+
+	if (data->ratios.horz.value == one
+			&& data->ratios.vert.value == one
+			&& data->ratios.horz_c.value == one
+			&& data->ratios.vert_c.value == one)
+		return DSCL_MODE_SCALING_444_BYPASS;
+
+	if (!format420) {
+		if (ycbcr)
+			return DSCL_MODE_SCALING_444_YCBCR_ENABLE;
+		else
+			return DSCL_MODE_SCALING_444_RGB_ENABLE;
+	}
+	if (data->ratios.horz.value == one && data->ratios.vert.value == one)
+		return DSCL_MODE_SCALING_420_LUMA_BYPASS;
+	if (data->ratios.horz_c.value == one && data->ratios.vert_c.value == one)
+		return DSCL_MODE_SCALING_420_CHROMA_BYPASS;
+
+	return DSCL_MODE_SCALING_420_YCBCR_ENABLE;
+}
+
+static int get_pixel_depth_val(enum lb_pixel_depth depth)
+{
+	if (depth == LB_PIXEL_DEPTH_30BPP)
+		return 0; /* 10 bpc */
+	else if (depth == LB_PIXEL_DEPTH_24BPP)
+		return 1; /* 8 bpc */
+	else if (depth == LB_PIXEL_DEPTH_18BPP)
+		return 2; /* 6 bpc */
+	else if (depth == LB_PIXEL_DEPTH_36BPP)
+		return 3; /* 12 bpc */
+	else {
+		ASSERT(0);
+		return -1; /* Unsupported */
+	}
+}
+
+static void transform_set_lb(
+	struct dcn10_transform *xfm,
+	const struct line_buffer_params *lb_params,
+	enum lb_memory_config mem_size_config)
+{
+	uint32_t pixel_depth = get_pixel_depth_val(lb_params->depth);
+	uint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;
+	REG_SET_7(LB_DATA_FORMAT, 0,
+		PIXEL_DEPTH, pixel_depth, /* Pixel depth stored in LB */
+		PIXEL_EXPAN_MODE, lb_params->pixel_expan_mode, /* Pixel expansion mode */
+		PIXEL_REDUCE_MODE, 1, /* Pixel reduction mode: Rounding */
+		DYNAMIC_PIXEL_DEPTH, dyn_pix_depth, /* Dynamic expansion pixel depth */
+		DITHER_EN, 0, /* Dithering enable: Disabled */
+		INTERLEAVE_EN, lb_params->interleave_en, /* Interleave source enable */
+		ALPHA_EN, lb_params->alpha_en); /* Alpha enable */
+
+	REG_SET_2(LB_MEMORY_CTRL, 0,
+		MEMORY_CONFIG, mem_size_config,
+		LB_MAX_PARTITIONS, 63);
+}
+
+static void transform_set_scaler_filter(
+		struct dcn10_transform *xfm,
+		uint32_t taps,
+		enum dcn10_coef_filter_type_sel filter_type,
+		const uint16_t *filter)
+{
+	const int tap_pairs = (taps + 1) / 2;
+	int phase;
+	int pair;
+	uint16_t odd_coef, even_coef;
+
+	REG_SET_3(SCL_COEF_RAM_TAP_SELECT, 0,
+		SCL_COEF_RAM_TAP_PAIR_IDX, 0,
+		SCL_COEF_RAM_PHASE, 0,
+		SCL_COEF_RAM_FILTER_TYPE, filter_type);
+
+	for (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {
+		for (pair = 0; pair < tap_pairs; pair++) {
+			even_coef = filter[phase * taps + 2 * pair];
+			if ((pair * 2 + 1) < taps)
+				odd_coef = filter[phase * taps + 2 * pair + 1];
+			else
+				odd_coef = 0;
+
+			REG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,
+				/* Even tap coefficient (bits 1:0 fixed to 0) */
+				SCL_COEF_RAM_EVEN_TAP_COEF, even_coef,
+				/* Write/read control for even coefficient */
+				SCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,
+				/* Odd tap coefficient (bits 1:0 fixed to 0) */
+				SCL_COEF_RAM_ODD_TAP_COEF, odd_coef,
+				/* Write/read control for odd coefficient */
+				SCL_COEF_RAM_ODD_TAP_COEF_EN, 1);
+		}
+	}
+
+}
+
+#if 0
+bool transform_set_pixel_storage_depth(
+	struct transform *xfm,
+	enum lb_pixel_depth depth,
+	const struct bit_depth_reduction_params *bit_depth_params)
+{
+	struct dcn10_transform *xfm110 = TO_DCN10_TRANSFORM(xfm);
+	bool ret = true;
+	uint32_t value;
+	enum dc_color_depth color_depth;
+
+	value = dm_read_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT));
+	switch (depth) {
+	case LB_PIXEL_DEPTH_18BPP:
+		color_depth = COLOR_DEPTH_666;
+		set_reg_field_value(value, 2, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_24BPP:
+		color_depth = COLOR_DEPTH_888;
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_30BPP:
+		color_depth = COLOR_DEPTH_101010;
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_36BPP:
+		color_depth = COLOR_DEPTH_121212;
+		set_reg_field_value(value, 3, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	if (ret == true) {
+		set_denormalization(xfm110, color_depth);
+		ret = program_bit_depth_reduction(xfm110, color_depth,
+				bit_depth_params);
+
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, ALPHA_EN);
+		dm_write_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT), value);
+		if (!(xfm110->lb_pixel_depth_supported & depth)) {
+			/* We should use unsupported capabilities
+			 * unless it is required by w/a
+			 */
+			dm_logger_write(xfm->ctx->logger, LOG_WARNING,
+				"%s: Capability not supported",
+				__func__);
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)
+{
+	if (taps == 8)
+		return get_filter_8tap_64p(ratio);
+	else if (taps == 7)
+		return get_filter_7tap_64p(ratio);
+	else if (taps == 6)
+		return get_filter_6tap_64p(ratio);
+	else if (taps == 5)
+		return get_filter_5tap_64p(ratio);
+	else if (taps == 4)
+		return get_filter_4tap_64p(ratio);
+	else if (taps == 3)
+		return get_filter_3tap_64p(ratio);
+	else if (taps == 2)
+		return filter_2tap_64p;
+	else if (taps == 1)
+		return NULL;
+	else {
+		/* should never happen, bug */
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+}
+
+static void transform_set_scl_filter(
+		struct dcn10_transform *xfm,
+		const struct scaler_data *scl_data,
+		bool chroma_coef_mode)
+{
+	bool h_2tap_hardcode_coef_en = false;
+	bool v_2tap_hardcode_coef_en = false;
+	bool h_2tap_sharp_en = false;
+	bool v_2tap_sharp_en = false;
+	uint32_t h_2tap_sharp_factor = scl_data->sharpness.horz;
+	uint32_t v_2tap_sharp_factor = scl_data->sharpness.vert;
+	bool coef_ram_current;
+	const uint16_t *filter_h = NULL;
+	const uint16_t *filter_v = NULL;
+	const uint16_t *filter_h_c = NULL;
+	const uint16_t *filter_v_c = NULL;
+
+	h_2tap_hardcode_coef_en = scl_data->taps.h_taps < 3
+					&& scl_data->taps.h_taps_c < 3
+		&& (scl_data->taps.h_taps > 1 || scl_data->taps.h_taps_c > 1);
+	v_2tap_hardcode_coef_en = scl_data->taps.v_taps < 3
+					&& scl_data->taps.v_taps_c < 3
+		&& (scl_data->taps.v_taps > 1 || scl_data->taps.v_taps_c > 1);
+
+	h_2tap_sharp_en = h_2tap_hardcode_coef_en && h_2tap_sharp_factor != 0;
+	v_2tap_sharp_en = v_2tap_hardcode_coef_en && v_2tap_sharp_factor != 0;
+
+	REG_UPDATE_6(DSCL_2TAP_CONTROL,
+		SCL_H_2TAP_HARDCODE_COEF_EN, h_2tap_hardcode_coef_en,
+		SCL_H_2TAP_SHARP_EN, h_2tap_sharp_en,
+		SCL_H_2TAP_SHARP_FACTOR, h_2tap_sharp_factor,
+		SCL_V_2TAP_HARDCODE_COEF_EN, v_2tap_hardcode_coef_en,
+		SCL_V_2TAP_SHARP_EN, v_2tap_sharp_en,
+		SCL_V_2TAP_SHARP_FACTOR, v_2tap_sharp_factor);
+
+	if (!v_2tap_hardcode_coef_en || !h_2tap_hardcode_coef_en) {
+		bool filter_updated = false;
+
+		filter_h = get_filter_coeffs_64p(
+				scl_data->taps.h_taps, scl_data->ratios.horz);
+		filter_v = get_filter_coeffs_64p(
+				scl_data->taps.v_taps, scl_data->ratios.vert);
+
+		filter_updated = (filter_h && (filter_h != xfm->filter_h))
+				|| (filter_v && (filter_v != xfm->filter_v));
+
+		if (chroma_coef_mode) {
+			filter_h_c = get_filter_coeffs_64p(
+					scl_data->taps.h_taps_c, scl_data->ratios.horz_c);
+			filter_v_c = get_filter_coeffs_64p(
+					scl_data->taps.v_taps_c, scl_data->ratios.vert_c);
+			filter_updated = filter_updated || (filter_h_c && (filter_h_c != xfm->filter_h_c))
+							|| (filter_v_c && (filter_v_c != xfm->filter_v_c));
+		}
+
+		if (filter_updated) {
+			uint32_t scl_mode = REG_READ(SCL_MODE);
+
+			if (!h_2tap_hardcode_coef_en && filter_h) {
+				transform_set_scaler_filter(
+					xfm, scl_data->taps.h_taps,
+					SCL_COEF_LUMA_HORZ_FILTER, filter_h);
+			}
+			xfm->filter_h = filter_h;
+			if (!v_2tap_hardcode_coef_en && filter_v) {
+				transform_set_scaler_filter(
+					xfm, scl_data->taps.v_taps,
+					SCL_COEF_LUMA_VERT_FILTER, filter_v);
+			}
+			xfm->filter_v = filter_v;
+			if (chroma_coef_mode) {
+				if (!h_2tap_hardcode_coef_en && filter_h_c) {
+					transform_set_scaler_filter(
+						xfm, scl_data->taps.h_taps_c,
+						SCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);
+				}
+				if (!v_2tap_hardcode_coef_en && filter_v_c) {
+					transform_set_scaler_filter(
+						xfm, scl_data->taps.v_taps_c,
+						SCL_COEF_CHROMA_VERT_FILTER, filter_v_c);
+				}
+			}
+			xfm->filter_h_c = filter_h_c;
+			xfm->filter_v_c = filter_v_c;
+
+			coef_ram_current = get_reg_field_value_ex(
+				scl_mode, xfm->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
+				xfm->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
+
+			/* Swap coefficient RAM and set chroma coefficient mode */
+			REG_SET_2(SCL_MODE, scl_mode,
+					SCL_COEF_RAM_SELECT, !coef_ram_current,
+					SCL_CHROMA_COEF_MODE, chroma_coef_mode);
+		}
+	}
+}
+
+static void transform_set_viewport(
+		struct dcn10_transform *xfm,
+		const struct rect *viewport,
+		const struct rect *viewport_c)
+{
+	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION, 0,
+			PRI_VIEWPORT_WIDTH, viewport->width,
+			PRI_VIEWPORT_HEIGHT, viewport->height);
+
+	REG_SET_2(DCSURF_PRI_VIEWPORT_START, 0,
+			PRI_VIEWPORT_X_START, viewport->x,
+			PRI_VIEWPORT_Y_START, viewport->y);
+
+	/*for stereo*/
+	REG_SET_2(DCSURF_SEC_VIEWPORT_DIMENSION, 0,
+				SEC_VIEWPORT_WIDTH, viewport->width,
+				SEC_VIEWPORT_HEIGHT, viewport->height);
+
+	REG_SET_2(DCSURF_SEC_VIEWPORT_START, 0,
+				SEC_VIEWPORT_X_START, viewport->x,
+				SEC_VIEWPORT_Y_START, viewport->y);
+
+	/* DC supports NV12 only at the moment */
+	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION_C, 0,
+			PRI_VIEWPORT_WIDTH_C, viewport_c->width,
+			PRI_VIEWPORT_HEIGHT_C, viewport_c->height);
+
+	REG_SET_2(DCSURF_PRI_VIEWPORT_START_C, 0,
+			PRI_VIEWPORT_X_START_C, viewport_c->x,
+			PRI_VIEWPORT_Y_START_C, viewport_c->y);
+}
+
+static int get_lb_depth_bpc(enum lb_pixel_depth depth)
+{
+	if (depth == LB_PIXEL_DEPTH_30BPP)
+		return 10;
+	else if (depth == LB_PIXEL_DEPTH_24BPP)
+		return 8;
+	else if (depth == LB_PIXEL_DEPTH_18BPP)
+		return 6;
+	else if (depth == LB_PIXEL_DEPTH_36BPP)
+		return 12;
+	else {
+		BREAK_TO_DEBUGGER();
+		return -1; /* Unsupported */
+	}
+}
+
+static void calc_lb_num_partitions(
+		const struct scaler_data *scl_data,
+		enum lb_memory_config lb_config,
+		int *num_part_y,
+		int *num_part_c)
+{
+	int line_size = scl_data->viewport.width < scl_data->recout.width ?
+			scl_data->viewport.width : scl_data->recout.width;
+	int line_size_c = scl_data->viewport_c.width < scl_data->recout.width ?
+			scl_data->viewport_c.width : scl_data->recout.width;
+	int lb_bpc = get_lb_depth_bpc(scl_data->lb_params.depth);
+	int memory_line_size_y = (line_size * lb_bpc + 71) / 72; /* +71 to ceil */
+	int memory_line_size_c = (line_size_c * lb_bpc + 71) / 72; /* +71 to ceil */
+	int memory_line_size_a = (line_size + 5) / 6; /* +5 to ceil */
+	int lb_memory_size, lb_memory_size_c, lb_memory_size_a, num_partitions_a;
+
+	if (lb_config == LB_MEMORY_CONFIG_1) {
+		lb_memory_size = 816;
+		lb_memory_size_c = 816;
+		lb_memory_size_a = 984;
+	} else if (lb_config == LB_MEMORY_CONFIG_2) {
+		lb_memory_size = 1088;
+		lb_memory_size_c = 1088;
+		lb_memory_size_a = 1312;
+	} else if (lb_config == LB_MEMORY_CONFIG_3) {
+		lb_memory_size = 816 + 1088 + 848 + 848 + 848;
+		lb_memory_size_c = 816 + 1088;
+		lb_memory_size_a = 984 + 1312 + 456;
+	} else {
+		lb_memory_size = 816 + 1088 + 848;
+		lb_memory_size_c = 816 + 1088 + 848;
+		lb_memory_size_a = 984 + 1312 + 456;
+	}
+	*num_part_y = lb_memory_size / memory_line_size_y;
+	*num_part_c = lb_memory_size_c / memory_line_size_c;
+	num_partitions_a = lb_memory_size_a / memory_line_size_a;
+
+	if (scl_data->lb_params.alpha_en
+			&& (num_partitions_a < *num_part_y))
+		*num_part_y = num_partitions_a;
+
+	if (*num_part_y > 64)
+		*num_part_y = 64;
+	if (*num_part_c > 64)
+		*num_part_c = 64;
+
+}
+
+static bool is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)
+{
+	if (ceil_vratio > 2)
+		return vtaps <= (num_partitions - ceil_vratio + 2);
+	else
+		return vtaps <= num_partitions;
+}
+
+/*find first match configuration which meets the min required lb size*/
+static enum lb_memory_config find_lb_memory_config(const struct scaler_data *scl_data)
+{
+	int num_part_y, num_part_c;
+	int vtaps = scl_data->taps.v_taps;
+	int vtaps_c = scl_data->taps.v_taps_c;
+	int ceil_vratio = dal_fixed31_32_ceil(scl_data->ratios.vert);
+	int ceil_vratio_c = dal_fixed31_32_ceil(scl_data->ratios.vert_c);
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_1, &num_part_y, &num_part_c);
+
+	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+		return LB_MEMORY_CONFIG_1;
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_2, &num_part_y, &num_part_c);
+
+	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+		return LB_MEMORY_CONFIG_2;
+
+	if (scl_data->format == PIXEL_FORMAT_420BPP12
+			|| scl_data->format == PIXEL_FORMAT_420BPP15) {
+		calc_lb_num_partitions(
+				scl_data, LB_MEMORY_CONFIG_3, &num_part_y, &num_part_c);
+
+		if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+				&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+			return LB_MEMORY_CONFIG_3;
+	}
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_0, &num_part_y, &num_part_c);
+
+	/*Ensure we can support the requested number of vtaps*/
+	ASSERT(is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c));
+
+	return LB_MEMORY_CONFIG_0;
+}
+
+void transform_set_scaler_auto_scale(
+	struct transform *xfm_base,
+	const struct scaler_data *scl_data)
+{
+	enum lb_memory_config lb_config;
+	struct dcn10_transform *xfm = TO_DCN10_TRANSFORM(xfm_base);
+	enum dscl_mode_sel dscl_mode = get_dscl_mode(scl_data);
+	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
+
+	transform_set_overscan(xfm, scl_data);
+
+	transform_set_otg_blank(xfm, scl_data);
+
+	REG_UPDATE(SCL_MODE, DSCL_MODE, get_dscl_mode(scl_data));
+
+	transform_set_viewport(xfm, &scl_data->viewport, &scl_data->viewport_c);
+
+	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
+		return;
+
+	lb_config =  find_lb_memory_config(scl_data);
+	transform_set_lb(xfm, &scl_data->lb_params, lb_config);
+
+	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
+		return;
+
+	/* TODO: v_min */
+	REG_SET_3(DSCL_AUTOCAL, 0,
+		AUTOCAL_MODE, AUTOCAL_MODE_AUTOSCALE,
+		AUTOCAL_NUM_PIPE, 0,
+		AUTOCAL_PIPE_ID, 0);
+
+	/* Black offsets */
+	if (ycbcr)
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
+	else
+
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
+
+	REG_SET_4(SCL_TAP_CONTROL, 0,
+		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
+		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
+		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
+		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
+
+	transform_set_scl_filter(xfm, scl_data, ycbcr);
+}
+
+/* Program gamut remap in bypass mode */
+void transform_set_gamut_remap_bypass(struct dcn10_transform *xfm)
+{
+	REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
+			CM_GAMUT_REMAP_MODE, 0);
+	/* Gamut remap in bypass */
+}
+
+static void transform_set_recout(
+			struct dcn10_transform *xfm, const struct rect *recout)
+{
+	REG_SET_2(RECOUT_START, 0,
+		/* First pixel of RECOUT */
+			 RECOUT_START_X, recout->x,
+		/* First line of RECOUT */
+			 RECOUT_START_Y, recout->y);
+
+	REG_SET_2(RECOUT_SIZE, 0,
+		/* Number of RECOUT horizontal pixels */
+			 RECOUT_WIDTH, recout->width,
+		/* Number of RECOUT vertical lines */
+			 RECOUT_HEIGHT, recout->height
+			 - xfm->base.ctx->dc->debug.surface_visual_confirm * 2);
+}
+
+static void transform_set_manual_ratio_init(
+		struct dcn10_transform *xfm, const struct scaler_data *data)
+{
+	uint32_t init_frac = 0;
+	uint32_t init_int = 0;
+
+	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,
+			SCL_H_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.horz) << 5);
+
+	REG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,
+			SCL_V_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.vert) << 5);
+
+	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO_C, 0,
+			SCL_H_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.horz_c) << 5);
+
+	REG_SET(SCL_VERT_FILTER_SCALE_RATIO_C, 0,
+			SCL_V_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.vert_c) << 5);
+
+	/*
+	 * 0.24 format for fraction, first five bits zeroed
+	 */
+	init_frac = dal_fixed31_32_u0d19(data->inits.h) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.h);
+	REG_SET_2(SCL_HORZ_FILTER_INIT, 0,
+		SCL_H_INIT_FRAC, init_frac,
+		SCL_H_INIT_INT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.h_c) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.h_c);
+	REG_SET_2(SCL_HORZ_FILTER_INIT_C, 0,
+		SCL_H_INIT_FRAC_C, init_frac,
+		SCL_H_INIT_INT_C, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v);
+	REG_SET_2(SCL_VERT_FILTER_INIT, 0,
+		SCL_V_INIT_FRAC, init_frac,
+		SCL_V_INIT_INT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_bot) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_bot);
+	REG_SET_2(SCL_VERT_FILTER_INIT_BOT, 0,
+		SCL_V_INIT_FRAC_BOT, init_frac,
+		SCL_V_INIT_INT_BOT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_c) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_c);
+	REG_SET_2(SCL_VERT_FILTER_INIT_C, 0,
+		SCL_V_INIT_FRAC_C, init_frac,
+		SCL_V_INIT_INT_C, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_c_bot) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_c_bot);
+	REG_SET_2(SCL_VERT_FILTER_INIT_BOT_C, 0,
+		SCL_V_INIT_FRAC_BOT_C, init_frac,
+		SCL_V_INIT_INT_BOT_C, init_int);
+}
+
+/* Main function to program scaler and line buffer in manual scaling mode */
+static void transform_set_scaler_manual_scale(
+	struct transform *xfm_base,
+	const struct scaler_data *scl_data)
+{
+	enum lb_memory_config lb_config;
+	struct dcn10_transform *xfm = TO_DCN10_TRANSFORM(xfm_base);
+	enum dscl_mode_sel dscl_mode = get_dscl_mode(scl_data);
+	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
+
+	/* Recout */
+	transform_set_recout(xfm, &scl_data->recout);
+
+	/* MPC Size */
+	REG_SET_2(MPC_SIZE, 0,
+		/* Number of horizontal pixels of MPC */
+			 MPC_WIDTH, scl_data->h_active,
+		/* Number of vertical lines of MPC */
+			 MPC_HEIGHT, scl_data->v_active);
+
+	/* SCL mode */
+	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
+
+	/* Viewport */
+	transform_set_viewport(xfm, &scl_data->viewport, &scl_data->viewport_c);
+
+	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
+		return;
+	/* LB */
+	lb_config =  find_lb_memory_config(scl_data);
+	transform_set_lb(xfm, &scl_data->lb_params, lb_config);
+
+	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
+		return;
+
+	/* Autocal off */
+	REG_SET_3(DSCL_AUTOCAL, 0,
+		AUTOCAL_MODE, AUTOCAL_MODE_OFF,
+		AUTOCAL_NUM_PIPE, 0,
+		AUTOCAL_PIPE_ID, 0);
+
+	/* Black offsets */
+	if (ycbcr)
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
+	else
+
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
+
+	/* Manually calculate scale ratio and init values */
+	transform_set_manual_ratio_init(xfm, scl_data);
+
+	/* HTaps/VTaps */
+	REG_SET_4(SCL_TAP_CONTROL, 0,
+		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
+		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
+		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
+		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
+
+	transform_set_scl_filter(xfm, scl_data, ycbcr);
+}
+
+#define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
+
+
+static bool transform_get_optimal_number_of_taps(
+		struct transform *xfm,
+		struct scaler_data *scl_data,
+		const struct scaling_taps *in_taps)
+{
+	uint32_t pixel_width;
+
+	if (scl_data->viewport.width > scl_data->recout.width)
+		pixel_width = scl_data->recout.width;
+	else
+		pixel_width = scl_data->viewport.width;
+
+	/* TODO: add lb check */
+
+	/* No support for programming ratio of 4, drop to 3.99999.. */
+	if (scl_data->ratios.horz.value == (4ll << 32))
+		scl_data->ratios.horz.value--;
+	if (scl_data->ratios.vert.value == (4ll << 32))
+		scl_data->ratios.vert.value--;
+	if (scl_data->ratios.horz_c.value == (4ll << 32))
+		scl_data->ratios.horz_c.value--;
+	if (scl_data->ratios.vert_c.value == (4ll << 32))
+		scl_data->ratios.vert_c.value--;
+
+	/* Set default taps if none are provided */
+	if (in_taps->h_taps == 0)
+		scl_data->taps.h_taps = 4;
+	else
+		scl_data->taps.h_taps = in_taps->h_taps;
+	if (in_taps->v_taps == 0)
+		scl_data->taps.v_taps = 4;
+	else
+		scl_data->taps.v_taps = in_taps->v_taps;
+	if (in_taps->v_taps_c == 0)
+		scl_data->taps.v_taps_c = 2;
+	else
+		scl_data->taps.v_taps_c = in_taps->v_taps_c;
+	if (in_taps->h_taps_c == 0)
+		scl_data->taps.h_taps_c = 2;
+	/* Only 1 and even h_taps_c are supported by hw */
+	else if ((in_taps->h_taps_c % 2) != 0 && in_taps->h_taps_c != 1)
+		scl_data->taps.h_taps_c = in_taps->h_taps_c - 1;
+	else
+		scl_data->taps.h_taps_c = in_taps->h_taps_c;
+
+	if (IDENTITY_RATIO(scl_data->ratios.horz))
+		scl_data->taps.h_taps = 1;
+	if (IDENTITY_RATIO(scl_data->ratios.vert))
+		scl_data->taps.v_taps = 1;
+	if (IDENTITY_RATIO(scl_data->ratios.horz_c))
+		scl_data->taps.h_taps_c = 1;
+	if (IDENTITY_RATIO(scl_data->ratios.vert_c))
+		scl_data->taps.v_taps_c = 1;
+
+	return true;
+}
+
+static void transform_reset(struct transform *xfm_base)
+{
+	struct dcn10_transform *xfm = TO_DCN10_TRANSFORM(xfm_base);
+
+	xfm->filter_h_c = NULL;
+	xfm->filter_v_c = NULL;
+	xfm->filter_h = NULL;
+	xfm->filter_v = NULL;
+
+	/* set boundary mode to 0 */
+	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
+}
+
+static void program_gamut_remap(
+		struct dcn10_transform *xfm,
+		const uint16_t *regval,
+		enum gamut_remap_select select)
+{
+	 uint16_t selection = 0;
+
+	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
+		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
+				CM_GAMUT_REMAP_MODE, 0);
+		return;
+	}
+	switch (select) {
+	case GAMUT_REMAP_COEFF:
+		selection = 1;
+		break;
+	case GAMUT_REMAP_COMA_COEFF:
+		selection = 2;
+		break;
+	case GAMUT_REMAP_COMB_COEFF:
+		selection = 3;
+		break;
+	default:
+		break;
+	}
+
+
+	if (select == GAMUT_REMAP_COEFF) {
+
+		REG_SET_2(CM_GAMUT_REMAP_C11_C12, 0,
+				CM_GAMUT_REMAP_C11, regval[0],
+				CM_GAMUT_REMAP_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C13_C14, 0,
+				CM_GAMUT_REMAP_C13, regval[0],
+				CM_GAMUT_REMAP_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C21_C22, 0,
+				CM_GAMUT_REMAP_C21, regval[0],
+				CM_GAMUT_REMAP_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C23_C24, 0,
+				CM_GAMUT_REMAP_C23, regval[0],
+				CM_GAMUT_REMAP_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C31_C32, 0,
+				CM_GAMUT_REMAP_C31, regval[0],
+				CM_GAMUT_REMAP_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C33_C34, 0,
+				CM_GAMUT_REMAP_C33, regval[0],
+				CM_GAMUT_REMAP_C34, regval[1]);
+
+	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
+		REG_SET_2(CM_COMA_C11_C12, 0,
+				CM_COMA_C11, regval[0],
+				CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+				CM_COMA_C13, regval[0],
+				CM_COMA_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+				CM_COMA_C21, regval[0],
+				CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+				CM_COMA_C23, regval[0],
+				CM_COMA_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+				CM_COMA_C31, regval[0],
+				CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+				CM_COMA_C33, regval[0],
+				CM_COMA_C34, regval[1]);
+
+	} else {
+		REG_SET_2(CM_COMB_C11_C12, 0,
+				CM_COMB_C11, regval[0],
+				CM_COMB_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C13_C14, 0,
+				CM_COMB_C13, regval[0],
+				CM_COMB_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C21_C22, 0,
+				CM_COMB_C21, regval[0],
+				CM_COMB_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C23_C24, 0,
+				CM_COMB_C23, regval[0],
+				CM_COMB_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C31_C32, 0,
+				CM_COMB_C31, regval[0],
+				CM_COMB_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C33_C34, 0,
+				CM_COMB_C33, regval[0],
+				CM_COMB_C34, regval[1]);
+	}
+
+	REG_SET(
+			CM_GAMUT_REMAP_CONTROL, 0,
+			CM_GAMUT_REMAP_MODE, selection);
+
+}
+
+static void dcn_transform_set_gamut_remap(
+	struct transform *xfm,
+	const struct xfm_grph_csc_adjustment *adjust)
+{
+	struct dcn10_transform *dcn_xfm = TO_DCN10_TRANSFORM(xfm);
+
+	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
+		/* Bypass if type is bypass or hw */
+		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
+	else {
+		struct fixed31_32 arr_matrix[12];
+		uint16_t arr_reg_val[12];
+
+		arr_matrix[0] = adjust->temperature_matrix[0];
+		arr_matrix[1] = adjust->temperature_matrix[1];
+		arr_matrix[2] = adjust->temperature_matrix[2];
+		arr_matrix[3] = dal_fixed31_32_zero;
+
+		arr_matrix[4] = adjust->temperature_matrix[3];
+		arr_matrix[5] = adjust->temperature_matrix[4];
+		arr_matrix[6] = adjust->temperature_matrix[5];
+		arr_matrix[7] = dal_fixed31_32_zero;
+
+		arr_matrix[8] = adjust->temperature_matrix[6];
+		arr_matrix[9] = adjust->temperature_matrix[7];
+		arr_matrix[10] = adjust->temperature_matrix[8];
+		arr_matrix[11] = dal_fixed31_32_zero;
+
+		convert_float_matrix(
+			arr_reg_val, arr_matrix, 12);
+
+		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
+	}
+}
+
+static struct transform_funcs dcn10_transform_funcs = {
+
+	.transform_reset = transform_reset,
+	.transform_set_scaler = transform_set_scaler_manual_scale,
+	.transform_get_optimal_number_of_taps =
+			transform_get_optimal_number_of_taps,
+	.transform_set_gamut_remap = dcn_transform_set_gamut_remap
+};
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+bool dcn10_transform_construct(
+	struct dcn10_transform *xfm,
+	struct dc_context *ctx,
+	const struct dcn_transform_registers *tf_regs,
+	const struct dcn_transform_shift *tf_shift,
+	const struct dcn_transform_mask *tf_mask)
+{
+	xfm->base.ctx = ctx;
+
+	xfm->base.funcs = &dcn10_transform_funcs;
+
+	xfm->tf_regs = tf_regs;
+	xfm->tf_shift = tf_shift;
+	xfm->tf_mask = tf_mask;
+
+	xfm->lb_pixel_depth_supported =
+		LB_PIXEL_DEPTH_18BPP |
+		LB_PIXEL_DEPTH_24BPP |
+		LB_PIXEL_DEPTH_30BPP;
+
+	xfm->lb_bits_per_entry = LB_BITS_PER_ENTRY;
+	xfm->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
+
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.h
new file mode 100644
index 0000000..7c0089d
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_transform.h
@@ -0,0 +1,416 @@
+/* Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DAL_TRANSFORM_DCN10_H__
+#define __DAL_TRANSFORM_DCN10_H__
+
+#include "transform.h"
+
+#define TO_DCN10_TRANSFORM(transform)\
+	container_of(transform, struct dcn10_transform, base)
+
+/* TODO: Use correct number of taps. Using polaris values for now */
+#define LB_TOTAL_NUMBER_OF_ENTRIES 5124
+#define LB_BITS_PER_ENTRY 144
+
+#define TF_SF(reg_name, field_name, post_fix)\
+	.field_name = reg_name ## __ ## field_name ## post_fix
+
+#define TF_REG_LIST_DCN(id) \
+	SRI(DSCL_EXT_OVERSCAN_LEFT_RIGHT, DSCL, id), \
+	SRI(DSCL_EXT_OVERSCAN_TOP_BOTTOM, DSCL, id), \
+	SRI(OTG_H_BLANK, DSCL, id), \
+	SRI(OTG_V_BLANK, DSCL, id), \
+	SRI(SCL_MODE, DSCL, id), \
+	SRI(LB_DATA_FORMAT, DSCL, id), \
+	SRI(LB_MEMORY_CTRL, DSCL, id), \
+	SRI(DSCL_AUTOCAL, DSCL, id), \
+	SRI(SCL_BLACK_OFFSET, DSCL, id), \
+	SRI(DSCL_CONTROL, DSCL, id), \
+	SRI(SCL_TAP_CONTROL, DSCL, id), \
+	SRI(SCL_COEF_RAM_TAP_SELECT, DSCL, id), \
+	SRI(SCL_COEF_RAM_TAP_DATA, DSCL, id), \
+	SRI(DSCL_2TAP_CONTROL, DSCL, id), \
+	SRI(DCSURF_PRI_VIEWPORT_DIMENSION, HUBP, id), \
+	SRI(DCSURF_PRI_VIEWPORT_START, HUBP, id), \
+	SRI(DCSURF_SEC_VIEWPORT_DIMENSION, HUBP, id), \
+	SRI(DCSURF_SEC_VIEWPORT_START, HUBP, id), \
+	SRI(DCSURF_PRI_VIEWPORT_DIMENSION_C, HUBP, id), \
+	SRI(DCSURF_PRI_VIEWPORT_START_C, HUBP, id), \
+	SRI(CM_GAMUT_REMAP_CONTROL, CM, id), \
+	SRI(MPC_SIZE, DSCL, id), \
+	SRI(SCL_HORZ_FILTER_SCALE_RATIO, DSCL, id), \
+	SRI(SCL_VERT_FILTER_SCALE_RATIO, DSCL, id), \
+	SRI(SCL_HORZ_FILTER_SCALE_RATIO_C, DSCL, id), \
+	SRI(SCL_VERT_FILTER_SCALE_RATIO_C, DSCL, id), \
+	SRI(SCL_HORZ_FILTER_INIT, DSCL, id), \
+	SRI(SCL_HORZ_FILTER_INIT_C, DSCL, id), \
+	SRI(SCL_VERT_FILTER_INIT, DSCL, id), \
+	SRI(SCL_VERT_FILTER_INIT_BOT, DSCL, id), \
+	SRI(SCL_VERT_FILTER_INIT_C, DSCL, id), \
+	SRI(SCL_VERT_FILTER_INIT_BOT_C, DSCL, id), \
+	SRI(RECOUT_START, DSCL, id), \
+	SRI(RECOUT_SIZE, DSCL, id), \
+	SRI(CM_GAMUT_REMAP_CONTROL, CM, id),\
+	SRI(CM_GAMUT_REMAP_C11_C12, CM, id),\
+	SRI(CM_GAMUT_REMAP_C13_C14, CM, id),\
+	SRI(CM_GAMUT_REMAP_C21_C22, CM, id),\
+	SRI(CM_GAMUT_REMAP_C23_C24, CM, id),\
+	SRI(CM_GAMUT_REMAP_C31_C32, CM, id),\
+	SRI(CM_GAMUT_REMAP_C33_C34, CM, id),\
+	SRI(CM_COMA_C11_C12, CM, id),\
+	SRI(CM_COMA_C13_C14, CM, id),\
+	SRI(CM_COMA_C21_C22, CM, id),\
+	SRI(CM_COMA_C23_C24, CM, id),\
+	SRI(CM_COMA_C31_C32, CM, id),\
+	SRI(CM_COMA_C33_C34, CM, id),\
+	SRI(CM_COMB_C11_C12, CM, id),\
+	SRI(CM_COMB_C13_C14, CM, id),\
+	SRI(CM_COMB_C21_C22, CM, id),\
+	SRI(CM_COMB_C23_C24, CM, id),\
+	SRI(CM_COMB_C31_C32, CM, id),\
+	SRI(CM_COMB_C33_C34, CM, id)
+
+
+
+#define TF_REG_LIST_SH_MASK_DCN(mask_sh)\
+	TF_SF(DSCL0_DSCL_EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT, mask_sh),\
+	TF_SF(DSCL0_DSCL_EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_RIGHT, mask_sh),\
+	TF_SF(DSCL0_DSCL_EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM, mask_sh),\
+	TF_SF(DSCL0_DSCL_EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_TOP, mask_sh),\
+	TF_SF(DSCL0_OTG_H_BLANK, OTG_H_BLANK_START, mask_sh),\
+	TF_SF(DSCL0_OTG_H_BLANK, OTG_H_BLANK_END, mask_sh),\
+	TF_SF(DSCL0_OTG_V_BLANK, OTG_V_BLANK_START, mask_sh),\
+	TF_SF(DSCL0_OTG_V_BLANK, OTG_V_BLANK_END, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, PIXEL_DEPTH, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, PIXEL_EXPAN_MODE, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, PIXEL_REDUCE_MODE, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, DYNAMIC_PIXEL_DEPTH, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, DITHER_EN, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, INTERLEAVE_EN, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, ALPHA_EN, mask_sh),\
+	TF_SF(DSCL0_LB_MEMORY_CTRL, MEMORY_CONFIG, mask_sh),\
+	TF_SF(DSCL0_LB_MEMORY_CTRL, LB_MAX_PARTITIONS, mask_sh),\
+	TF_SF(DSCL0_DSCL_AUTOCAL, AUTOCAL_MODE, mask_sh),\
+	TF_SF(DSCL0_DSCL_AUTOCAL, AUTOCAL_NUM_PIPE, mask_sh),\
+	TF_SF(DSCL0_DSCL_AUTOCAL, AUTOCAL_PIPE_ID, mask_sh),\
+	TF_SF(DSCL0_SCL_BLACK_OFFSET, SCL_BLACK_OFFSET_RGB_Y, mask_sh),\
+	TF_SF(DSCL0_SCL_BLACK_OFFSET, SCL_BLACK_OFFSET_CBCR, mask_sh),\
+	TF_SF(DSCL0_DSCL_CONTROL, SCL_BOUNDARY_MODE, mask_sh),\
+	TF_SF(DSCL0_SCL_TAP_CONTROL, SCL_V_NUM_TAPS, mask_sh),\
+	TF_SF(DSCL0_SCL_TAP_CONTROL, SCL_H_NUM_TAPS, mask_sh),\
+	TF_SF(DSCL0_SCL_TAP_CONTROL, SCL_V_NUM_TAPS_C, mask_sh),\
+	TF_SF(DSCL0_SCL_TAP_CONTROL, SCL_H_NUM_TAPS_C, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_SELECT, SCL_COEF_RAM_TAP_PAIR_IDX, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_SELECT, SCL_COEF_RAM_PHASE, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_SELECT, SCL_COEF_RAM_FILTER_TYPE, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_DATA, SCL_COEF_RAM_EVEN_TAP_COEF, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_DATA, SCL_COEF_RAM_EVEN_TAP_COEF_EN, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_DATA, SCL_COEF_RAM_ODD_TAP_COEF, mask_sh),\
+	TF_SF(DSCL0_SCL_COEF_RAM_TAP_DATA, SCL_COEF_RAM_ODD_TAP_COEF_EN, mask_sh),\
+	TF_SF(DSCL0_DSCL_2TAP_CONTROL, SCL_H_2TAP_HARDCODE_COEF_EN, mask_sh),\
+	TF_SF(DSCL0_DSCL_2TAP_CONTROL, SCL_H_2TAP_SHARP_EN, mask_sh),\
+	TF_SF(DSCL0_DSCL_2TAP_CONTROL, SCL_H_2TAP_SHARP_FACTOR, mask_sh),\
+	TF_SF(DSCL0_DSCL_2TAP_CONTROL, SCL_V_2TAP_HARDCODE_COEF_EN, mask_sh),\
+	TF_SF(DSCL0_DSCL_2TAP_CONTROL, SCL_V_2TAP_SHARP_EN, mask_sh),\
+	TF_SF(DSCL0_DSCL_2TAP_CONTROL, SCL_V_2TAP_SHARP_FACTOR, mask_sh),\
+	TF_SF(DSCL0_SCL_MODE, SCL_COEF_RAM_SELECT, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION, PRI_VIEWPORT_WIDTH, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION, PRI_VIEWPORT_HEIGHT, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_START, PRI_VIEWPORT_X_START, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_START, PRI_VIEWPORT_Y_START, mask_sh),\
+	TF_SF(HUBP0_DCSURF_SEC_VIEWPORT_DIMENSION, SEC_VIEWPORT_WIDTH, mask_sh),\
+	TF_SF(HUBP0_DCSURF_SEC_VIEWPORT_DIMENSION, SEC_VIEWPORT_HEIGHT, mask_sh),\
+	TF_SF(HUBP0_DCSURF_SEC_VIEWPORT_START, SEC_VIEWPORT_X_START, mask_sh),\
+	TF_SF(HUBP0_DCSURF_SEC_VIEWPORT_START, SEC_VIEWPORT_Y_START, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION_C, PRI_VIEWPORT_WIDTH_C, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_DIMENSION_C, PRI_VIEWPORT_HEIGHT_C, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_START_C, PRI_VIEWPORT_X_START_C, mask_sh),\
+	TF_SF(HUBP0_DCSURF_PRI_VIEWPORT_START_C, PRI_VIEWPORT_Y_START_C, mask_sh),\
+	TF_SF(DSCL0_SCL_MODE, DSCL_MODE, mask_sh),\
+	TF_SF(DSCL0_RECOUT_START, RECOUT_START_X, mask_sh),\
+	TF_SF(DSCL0_RECOUT_START, RECOUT_START_Y, mask_sh),\
+	TF_SF(DSCL0_RECOUT_SIZE, RECOUT_WIDTH, mask_sh),\
+	TF_SF(DSCL0_RECOUT_SIZE, RECOUT_HEIGHT, mask_sh),\
+	TF_SF(DSCL0_MPC_SIZE, MPC_WIDTH, mask_sh),\
+	TF_SF(DSCL0_MPC_SIZE, MPC_HEIGHT, mask_sh),\
+	TF_SF(DSCL0_SCL_HORZ_FILTER_SCALE_RATIO, SCL_H_SCALE_RATIO, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_SCALE_RATIO, SCL_V_SCALE_RATIO, mask_sh),\
+	TF_SF(DSCL0_SCL_HORZ_FILTER_SCALE_RATIO_C, SCL_H_SCALE_RATIO_C, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_SCALE_RATIO_C, SCL_V_SCALE_RATIO_C, mask_sh),\
+	TF_SF(DSCL0_SCL_HORZ_FILTER_INIT, SCL_H_INIT_FRAC, mask_sh),\
+	TF_SF(DSCL0_SCL_HORZ_FILTER_INIT, SCL_H_INIT_INT, mask_sh),\
+	TF_SF(DSCL0_SCL_HORZ_FILTER_INIT_C, SCL_H_INIT_FRAC_C, mask_sh),\
+	TF_SF(DSCL0_SCL_HORZ_FILTER_INIT_C, SCL_H_INIT_INT_C, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT, SCL_V_INIT_FRAC, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT, SCL_V_INIT_INT, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_BOT, SCL_V_INIT_FRAC_BOT, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_BOT, SCL_V_INIT_INT_BOT, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_C, SCL_V_INIT_FRAC_C, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_C, SCL_V_INIT_INT_C, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_BOT_C, SCL_V_INIT_FRAC_BOT_C, mask_sh),\
+	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_BOT_C, SCL_V_INIT_INT_BOT_C, mask_sh),\
+	TF_SF(DSCL0_SCL_MODE, SCL_CHROMA_COEF_MODE, mask_sh),\
+	TF_SF(DSCL0_SCL_MODE, SCL_COEF_RAM_SELECT_CURRENT, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_CONTROL, CM_GAMUT_REMAP_MODE, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C11_C12, CM_GAMUT_REMAP_C11, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C11_C12, CM_GAMUT_REMAP_C12, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C13_C14, CM_GAMUT_REMAP_C13, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C13_C14, CM_GAMUT_REMAP_C14, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C21_C22, CM_GAMUT_REMAP_C21, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C21_C22, CM_GAMUT_REMAP_C22, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C23_C24, CM_GAMUT_REMAP_C23, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C23_C24, CM_GAMUT_REMAP_C24, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C31_C32, CM_GAMUT_REMAP_C31, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C31_C32, CM_GAMUT_REMAP_C32, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C33_C34, CM_GAMUT_REMAP_C33, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C33_C34, CM_GAMUT_REMAP_C34, mask_sh),\
+	TF_SF(CM0_CM_COMA_C11_C12, CM_COMA_C11, mask_sh),\
+	TF_SF(CM0_CM_COMA_C11_C12, CM_COMA_C12, mask_sh),\
+	TF_SF(CM0_CM_COMA_C13_C14, CM_COMA_C13, mask_sh),\
+	TF_SF(CM0_CM_COMA_C13_C14, CM_COMA_C14, mask_sh),\
+	TF_SF(CM0_CM_COMA_C21_C22, CM_COMA_C21, mask_sh),\
+	TF_SF(CM0_CM_COMA_C21_C22, CM_COMA_C22, mask_sh),\
+	TF_SF(CM0_CM_COMA_C23_C24, CM_COMA_C23, mask_sh),\
+	TF_SF(CM0_CM_COMA_C23_C24, CM_COMA_C24, mask_sh),\
+	TF_SF(CM0_CM_COMA_C31_C32, CM_COMA_C31, mask_sh),\
+	TF_SF(CM0_CM_COMA_C31_C32, CM_COMA_C32, mask_sh),\
+	TF_SF(CM0_CM_COMA_C33_C34, CM_COMA_C33, mask_sh),\
+	TF_SF(CM0_CM_COMA_C33_C34, CM_COMA_C34, mask_sh),\
+	TF_SF(CM0_CM_COMB_C11_C12, CM_COMB_C11, mask_sh),\
+	TF_SF(CM0_CM_COMB_C11_C12, CM_COMB_C12, mask_sh),\
+	TF_SF(CM0_CM_COMB_C13_C14, CM_COMB_C13, mask_sh),\
+	TF_SF(CM0_CM_COMB_C13_C14, CM_COMB_C14, mask_sh),\
+	TF_SF(CM0_CM_COMB_C21_C22, CM_COMB_C21, mask_sh),\
+	TF_SF(CM0_CM_COMB_C21_C22, CM_COMB_C22, mask_sh),\
+	TF_SF(CM0_CM_COMB_C23_C24, CM_COMB_C23, mask_sh),\
+	TF_SF(CM0_CM_COMB_C23_C24, CM_COMB_C24, mask_sh),\
+	TF_SF(CM0_CM_COMB_C31_C32, CM_COMB_C31, mask_sh),\
+	TF_SF(CM0_CM_COMB_C33_C34, CM_COMB_C33, mask_sh),\
+	TF_SF(CM0_CM_COMB_C31_C32, CM_COMB_C32, mask_sh),\
+	TF_SF(CM0_CM_COMB_C33_C34, CM_COMB_C34, mask_sh)
+
+
+#define TF_REG_FIELD_LIST(type) \
+	type EXT_OVERSCAN_LEFT; \
+	type EXT_OVERSCAN_RIGHT; \
+	type EXT_OVERSCAN_BOTTOM; \
+	type EXT_OVERSCAN_TOP; \
+	type OTG_H_BLANK_START; \
+	type OTG_H_BLANK_END; \
+	type OTG_V_BLANK_START; \
+	type OTG_V_BLANK_END; \
+	type PIXEL_DEPTH; \
+	type PIXEL_EXPAN_MODE; \
+	type PIXEL_REDUCE_MODE; \
+	type DYNAMIC_PIXEL_DEPTH; \
+	type DITHER_EN; \
+	type INTERLEAVE_EN; \
+	type ALPHA_EN; \
+	type MEMORY_CONFIG; \
+	type LB_MAX_PARTITIONS; \
+	type AUTOCAL_MODE; \
+	type AUTOCAL_NUM_PIPE; \
+	type AUTOCAL_PIPE_ID; \
+	type SCL_BLACK_OFFSET_RGB_Y; \
+	type SCL_BLACK_OFFSET_CBCR; \
+	type SCL_BOUNDARY_MODE; \
+	type SCL_V_NUM_TAPS; \
+	type SCL_H_NUM_TAPS; \
+	type SCL_V_NUM_TAPS_C; \
+	type SCL_H_NUM_TAPS_C; \
+	type SCL_COEF_RAM_TAP_PAIR_IDX; \
+	type SCL_COEF_RAM_PHASE; \
+	type SCL_COEF_RAM_FILTER_TYPE; \
+	type SCL_COEF_RAM_EVEN_TAP_COEF; \
+	type SCL_COEF_RAM_EVEN_TAP_COEF_EN; \
+	type SCL_COEF_RAM_ODD_TAP_COEF; \
+	type SCL_COEF_RAM_ODD_TAP_COEF_EN; \
+	type SCL_H_2TAP_HARDCODE_COEF_EN; \
+	type SCL_H_2TAP_SHARP_EN; \
+	type SCL_H_2TAP_SHARP_FACTOR; \
+	type SCL_V_2TAP_HARDCODE_COEF_EN; \
+	type SCL_V_2TAP_SHARP_EN; \
+	type SCL_V_2TAP_SHARP_FACTOR; \
+	type SCL_COEF_RAM_SELECT; \
+	type PRI_VIEWPORT_WIDTH; \
+	type PRI_VIEWPORT_HEIGHT; \
+	type PRI_VIEWPORT_X_START; \
+	type PRI_VIEWPORT_Y_START; \
+	type SEC_VIEWPORT_WIDTH; \
+	type SEC_VIEWPORT_HEIGHT; \
+	type SEC_VIEWPORT_X_START; \
+	type SEC_VIEWPORT_Y_START; \
+	type PRI_VIEWPORT_WIDTH_C; \
+	type PRI_VIEWPORT_HEIGHT_C; \
+	type PRI_VIEWPORT_X_START_C; \
+	type PRI_VIEWPORT_Y_START_C; \
+	type DSCL_MODE; \
+	type RECOUT_START_X; \
+	type RECOUT_START_Y; \
+	type RECOUT_WIDTH; \
+	type RECOUT_HEIGHT; \
+	type MPC_WIDTH; \
+	type MPC_HEIGHT; \
+	type SCL_H_SCALE_RATIO; \
+	type SCL_V_SCALE_RATIO; \
+	type SCL_H_SCALE_RATIO_C; \
+	type SCL_V_SCALE_RATIO_C; \
+	type SCL_H_INIT_FRAC; \
+	type SCL_H_INIT_INT; \
+	type SCL_H_INIT_FRAC_C; \
+	type SCL_H_INIT_INT_C; \
+	type SCL_V_INIT_FRAC; \
+	type SCL_V_INIT_INT; \
+	type SCL_V_INIT_FRAC_BOT; \
+	type SCL_V_INIT_INT_BOT; \
+	type SCL_V_INIT_FRAC_C; \
+	type SCL_V_INIT_INT_C; \
+	type SCL_V_INIT_FRAC_BOT_C; \
+	type SCL_V_INIT_INT_BOT_C; \
+	type SCL_CHROMA_COEF_MODE; \
+	type SCL_COEF_RAM_SELECT_CURRENT; \
+	type CM_GAMUT_REMAP_MODE; \
+	type CM_GAMUT_REMAP_C11; \
+	type CM_GAMUT_REMAP_C12; \
+	type CM_GAMUT_REMAP_C13; \
+	type CM_GAMUT_REMAP_C14; \
+	type CM_GAMUT_REMAP_C21; \
+	type CM_GAMUT_REMAP_C22; \
+	type CM_GAMUT_REMAP_C23; \
+	type CM_GAMUT_REMAP_C24; \
+	type CM_GAMUT_REMAP_C31; \
+	type CM_GAMUT_REMAP_C32; \
+	type CM_GAMUT_REMAP_C33; \
+	type CM_GAMUT_REMAP_C34; \
+	type CM_COMA_C11; \
+	type CM_COMA_C12; \
+	type CM_COMA_C13; \
+	type CM_COMA_C14; \
+	type CM_COMA_C21; \
+	type CM_COMA_C22; \
+	type CM_COMA_C23; \
+	type CM_COMA_C24; \
+	type CM_COMA_C31; \
+	type CM_COMA_C32; \
+	type CM_COMA_C33; \
+	type CM_COMA_C34; \
+	type CM_COMB_C11; \
+	type CM_COMB_C12; \
+	type CM_COMB_C13; \
+	type CM_COMB_C14; \
+	type CM_COMB_C21; \
+	type CM_COMB_C22; \
+	type CM_COMB_C23; \
+	type CM_COMB_C24; \
+	type CM_COMB_C31; \
+	type CM_COMB_C32; \
+	type CM_COMB_C33; \
+	type CM_COMB_C34
+
+struct dcn_transform_shift {
+	TF_REG_FIELD_LIST(uint8_t);
+};
+
+struct dcn_transform_mask {
+	TF_REG_FIELD_LIST(uint32_t);
+};
+
+struct dcn_transform_registers {
+	uint32_t DSCL_EXT_OVERSCAN_LEFT_RIGHT;
+	uint32_t DSCL_EXT_OVERSCAN_TOP_BOTTOM;
+	uint32_t OTG_H_BLANK;
+	uint32_t OTG_V_BLANK;
+	uint32_t SCL_MODE;
+	uint32_t LB_DATA_FORMAT;
+	uint32_t LB_MEMORY_CTRL;
+	uint32_t DSCL_AUTOCAL;
+	uint32_t SCL_BLACK_OFFSET;
+	uint32_t DSCL_CONTROL;
+	uint32_t SCL_TAP_CONTROL;
+	uint32_t SCL_COEF_RAM_TAP_SELECT;
+	uint32_t SCL_COEF_RAM_TAP_DATA;
+	uint32_t DSCL_2TAP_CONTROL;
+	uint32_t DCSURF_PRI_VIEWPORT_DIMENSION;
+	uint32_t DCSURF_PRI_VIEWPORT_START;
+	uint32_t DCSURF_SEC_VIEWPORT_DIMENSION;
+	uint32_t DCSURF_SEC_VIEWPORT_START;
+	uint32_t DCSURF_PRI_VIEWPORT_DIMENSION_C;
+	uint32_t DCSURF_PRI_VIEWPORT_START_C;
+	uint32_t MPC_SIZE;
+	uint32_t SCL_HORZ_FILTER_SCALE_RATIO;
+	uint32_t SCL_VERT_FILTER_SCALE_RATIO;
+	uint32_t SCL_HORZ_FILTER_SCALE_RATIO_C;
+	uint32_t SCL_VERT_FILTER_SCALE_RATIO_C;
+	uint32_t SCL_HORZ_FILTER_INIT;
+	uint32_t SCL_HORZ_FILTER_INIT_C;
+	uint32_t SCL_VERT_FILTER_INIT;
+	uint32_t SCL_VERT_FILTER_INIT_BOT;
+	uint32_t SCL_VERT_FILTER_INIT_C;
+	uint32_t SCL_VERT_FILTER_INIT_BOT_C;
+	uint32_t RECOUT_START;
+	uint32_t RECOUT_SIZE;
+	uint32_t CM_GAMUT_REMAP_CONTROL;
+	uint32_t CM_GAMUT_REMAP_C11_C12;
+	uint32_t CM_GAMUT_REMAP_C13_C14;
+	uint32_t CM_GAMUT_REMAP_C21_C22;
+	uint32_t CM_GAMUT_REMAP_C23_C24;
+	uint32_t CM_GAMUT_REMAP_C31_C32;
+	uint32_t CM_GAMUT_REMAP_C33_C34;
+	uint32_t CM_COMA_C11_C12;
+	uint32_t CM_COMA_C13_C14;
+	uint32_t CM_COMA_C21_C22;
+	uint32_t CM_COMA_C23_C24;
+	uint32_t CM_COMA_C31_C32;
+	uint32_t CM_COMA_C33_C34;
+	uint32_t CM_COMB_C11_C12;
+	uint32_t CM_COMB_C13_C14;
+	uint32_t CM_COMB_C21_C22;
+	uint32_t CM_COMB_C23_C24;
+	uint32_t CM_COMB_C31_C32;
+	uint32_t CM_COMB_C33_C34;
+};
+
+struct dcn10_transform {
+	struct transform base;
+
+	const struct dcn_transform_registers *tf_regs;
+	const struct dcn_transform_shift *tf_shift;
+	const struct dcn_transform_mask *tf_mask;
+
+	const uint16_t *filter_v;
+	const uint16_t *filter_h;
+	const uint16_t *filter_v_c;
+	const uint16_t *filter_h_c;
+	int lb_pixel_depth_supported;
+	int lb_memory_size;
+	int lb_bits_per_entry;
+};
+
+bool dcn10_transform_construct(struct dcn10_transform *xfm110,
+	struct dc_context *ctx,
+	const struct dcn_transform_registers *tf_regs,
+	const struct dcn_transform_shift *tf_shift,
+	const struct dcn_transform_mask *tf_mask);
+#endif
-- 
2.7.4

