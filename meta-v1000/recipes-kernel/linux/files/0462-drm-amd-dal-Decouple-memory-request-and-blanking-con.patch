From fea122b5a6274d656a3ca21f802d11424f94f1cf Mon Sep 17 00:00:00 2001
From: Hersen Wu <hersenxs.wu@amd.com>
Date: Thu, 2 Jun 2016 14:49:54 -0400
Subject: [PATCH 0462/1722] drm/amd/dal: Decouple memory request and blanking
 concepts

Allow to disable/enable memory request independently of blanking

Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               | 43 +++++++++++-----------
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 10 ++++-
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |  7 +++-
 3 files changed, 37 insertions(+), 23 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index b604daf..2688f32 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -375,10 +375,7 @@ static int8_t acquire_first_free_underlay(
 			DCE110_UNDERLAY_IDX,
 			dcb, PIPE_GATING_CONTROL_DISABLE);
 
-		if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
-			dm_error("DC: failed to blank crtc!\n");
-			BREAK_TO_DEBUGGER();
-		}
+		core_dc->hwss.enable_memory_request(pipe_ctx, false);
 
 		if (!pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
 			BREAK_TO_DEBUGGER();
@@ -540,7 +537,9 @@ static bool targets_changed(
 	return false;
 }
 
-static void target_enable_memory_requests(struct dc_target *dc_target,
+static void target_enable_memory_requests(
+		struct core_dc *core_dc,
+		struct dc_target *dc_target,
 		struct resource_context *res_ctx)
 {
 	uint8_t i, j;
@@ -548,21 +547,19 @@ static void target_enable_memory_requests(struct dc_target *dc_target,
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
-			struct timing_generator *tg = res_ctx->pipe_ctx[j].tg;
-
 			if (res_ctx->pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(target->public.streams[i]))
 				continue;
 
-			if (!tg->funcs->set_blank(tg, false)) {
-				dm_error("DC: failed to unblank crtc!\n");
-				BREAK_TO_DEBUGGER();
-			}
+			core_dc->hwss.enable_memory_request(
+					&res_ctx->pipe_ctx[j], true);
 		}
 	}
 }
 
-static void target_disable_memory_requests(struct dc_target *dc_target,
+static void target_disable_memory_requests(
+		struct core_dc *core_dc,
+		struct dc_target *dc_target,
 		struct resource_context *res_ctx)
 {
 	uint8_t i, j;
@@ -570,16 +567,12 @@ static void target_disable_memory_requests(struct dc_target *dc_target,
 
 	for (i = 0; i < target->public.stream_count; i++) {
 		for (j = 0; j < MAX_PIPES; j++) {
-			struct timing_generator *tg = res_ctx->pipe_ctx[j].tg;
-
 			if (res_ctx->pipe_ctx[j].stream !=
 				DC_STREAM_TO_CORE(target->public.streams[i]))
 				continue;
 
-			if (!tg->funcs->set_blank(tg, true)) {
-				dm_error("DC: failed to blank crtc!\n");
-				BREAK_TO_DEBUGGER();
-			}
+			core_dc->hwss.enable_memory_request(
+					&res_ctx->pipe_ctx[j], false);
 		}
 	}
 }
@@ -784,7 +777,9 @@ bool dc_commit_targets(
 	for (i = 0; i < core_dc->current_context.target_count; i++) {
 		/*TODO: optimize this to happen only when necessary*/
 		target_disable_memory_requests(
-				&core_dc->current_context.targets[i]->public, &core_dc->current_context.res_ctx);
+				core_dc,
+				&core_dc->current_context.targets[i]->public,
+				&core_dc->current_context.res_ctx);
 	}
 
 	if (result == DC_OK) {
@@ -796,7 +791,10 @@ bool dc_commit_targets(
 		struct core_sink *sink = DC_SINK_TO_CORE(dc_target->streams[0]->sink);
 
 		if (context->target_status[i].surface_count > 0)
-			target_enable_memory_requests(dc_target, &core_dc->current_context.res_ctx);
+			target_enable_memory_requests(
+					core_dc,
+					dc_target,
+					&core_dc->current_context.res_ctx);
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
 				dc_target->streams[0]->timing.h_addressable,
@@ -917,7 +915,10 @@ bool dc_commit_surfaces_to_target(
 	}
 
 	if (current_enabled_surface_count > 0 && new_enabled_surface_count == 0)
-		target_disable_memory_requests(dc_target, &core_dc->current_context.res_ctx);
+		target_disable_memory_requests(
+				core_dc,
+				dc_target,
+				&core_dc->current_context.res_ctx);
 
 	for (i = 0; i < new_surface_count; i++)
 		for (j = 0; j < MAX_PIPES; j++) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index c91c71b..70bd6ac 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1634,6 +1634,13 @@ static void init_hw(struct core_dc *dc)
 	}
 }
 
+static void enable_memory_request(
+	struct pipe_ctx *pipe_ctx,
+	bool enable)
+{
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, enable);
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = apply_ctx_to_hw,
@@ -1655,7 +1662,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.clock_gating_power_up = dal_dc_clock_gating_dce110_power_up,/*todo*/
 	.set_display_clock = set_display_clock,
 	.set_displaymarks = set_displaymarks,
-	.set_drr = set_drr
+	.set_drr = set_drr,
+	.enable_memory_request = enable_memory_request
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index e36a9a9..3add573 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -111,7 +111,12 @@ struct hw_sequencer_funcs {
 
 	void (*set_display_clock)(struct validate_context *context);
 
-	void (*set_drr)(struct pipe_ctx **pipe_ctx, int num_pipes, int vmin, int vmax);
+	void (*set_drr)(struct pipe_ctx **pipe_ctx, int num_pipes,
+			int vmin, int vmax);
+
+	void (*enable_memory_request)(
+		struct pipe_ctx *pipe_ctx,
+		bool enable);
 };
 
 bool dc_construct_hw_sequencer(
-- 
2.7.4

