From f8ea47b5a7f6c811fe4f2deeecfb510bf1746386 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Mon, 18 Jul 2016 15:14:03 -0400
Subject: [PATCH 0659/1722] drm/amd/dal: hook up new commit surface interfaces

Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c          | 60 ++++++++++++++++++++++++++-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c |  3 ++
 drivers/gpu/drm/amd/dal/dc/dc.h               | 26 ++++++++++++
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h   |  3 ++
 4 files changed, 91 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index d98844c..a5a411d 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -1009,6 +1009,8 @@ struct validate_context *dc_pre_commit_surfaces_to_target(
 				&core_dc->current_context->res_ctx);
 
         core_dc->hwss.apply_ctx_to_surface_locked(core_dc, context);
+ 
+        context->locked = true;
 
         return context;
  
@@ -1034,6 +1036,7 @@ bool dc_isr_commit_surfaces_to_target(
         if (!core_dc->hwss.apply_ctx_to_surface_unlock)
                 return true;
         status = core_dc->hwss.apply_ctx_to_surface_unlock(core_dc, context);
+        context->locked = false;
         return status == DC_OK;
 }
 
@@ -1043,7 +1046,10 @@ bool dc_post_commit_surfaces_to_target(
 {
         struct core_dc *core_dc = DC_TO_CORE(dc);
         /* TODO: lower display clock if needed*/
-
+ 
+        if (context->locked)
+                dc_isr_commit_surfaces_to_target(dc, context);
+ 
 	resource_validate_ctx_destruct(core_dc->current_context);
 	dm_free(core_dc->current_context);
 	core_dc->current_context = context;
@@ -1174,6 +1180,58 @@ const struct audio **dc_get_audios(struct dc *dc)
 	return (const struct audio **)core_dc->res_pool.audios;
 }
 
+void dc_flip_surface_addrs_on_context(
+                struct dc *dc,
+                struct validate_context *context,
+                const struct dc_surface *const surfaces[],
+                struct dc_flip_addrs flip_addrs[],
+                uint32_t count)
+{
+        struct core_dc *core_dc = DC_TO_CORE(dc);
+        int i, j;
+        int pipe_count = core_dc->res_pool->pipe_count;
+ 
+        for (i = 0; i < count; i++)
+                for (j = 0; j < pipe_count; j++) {
+                        struct pipe_ctx *pipe_ctx =
+                                &context->res_ctx.pipe_ctx[j];
+                        struct core_surface *ctx_surface = pipe_ctx->surface;
+ 
+                        if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
+                                continue;
+ 
+                        ctx_surface->public.address = flip_addrs[i].address;
+                        ctx_surface->public.flip_immediate = flip_addrs[i].flip_immediate;
+ 
+                        if (!ctx_surface->public.flip_immediate)
+                                core_dc->hwss.pipe_control_lock(
+                                                core_dc->ctx,
+                                                pipe_ctx->pipe_idx,
+                                                PIPE_LOCK_CONTROL_SURFACE |
+                                                PIPE_LOCK_CONTROL_MODE,
+                                                true);
+ 
+                        core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+                }
+ 
+        for (j = pipe_count - 1; j >= 0; j--)
+                for (i = count - 1; i >= 0; i--) {
+                        struct pipe_ctx *pipe_ctx =
+                                &context->res_ctx.pipe_ctx[j];
+                        struct core_surface *ctx_surface = pipe_ctx->surface;
+ 
+                        if (DC_SURFACE_TO_CORE(surfaces[i]) != ctx_surface)
+                                continue;
+ 
+                        if (!ctx_surface->public.flip_immediate)
+                                core_dc->hwss.pipe_control_lock(
+                                                core_dc->ctx,
+                                                pipe_ctx->pipe_idx,
+                                                PIPE_LOCK_CONTROL_SURFACE,
+                                                false);
+                }
+}
+
 void dc_flip_surface_addrs(
 		struct dc *dc,
 		const struct dc_surface *const surfaces[],
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 565dabf..8518907 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -464,6 +464,9 @@ bool resource_build_scaling_params(
 
 	calculate_viewport(surface, pipe_ctx);
 
+	if (pipe_ctx->scl_data.viewport.height < 16 || pipe_ctx->scl_data.viewport.width < 16)
+		return false;
+
 	calculate_scaling_ratios(surface, pipe_ctx);
 
 	calculate_recout(surface, pipe_ctx);
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 478c8d9..a1a82eb 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -215,12 +215,38 @@ void dc_flip_surface_addrs(struct dc *dc,
  *   Surfaces attributes are programmed and configured to be composed into target.
  *   This does not trigger a flip.  No surface address is programmed.
  */
+
+/* Forward declaration*/
+struct validate_context;
+
+void dc_flip_surface_addrs_on_context(
+		struct dc *dc,
+		struct validate_context *context,
+		const struct dc_surface *const surfaces[],
+		struct dc_flip_addrs flip_addrs[],
+		uint32_t count);
+
 bool dc_commit_surfaces_to_target(
 		struct dc *dc,
 		struct dc_surface *dc_surfaces[],
 		uint8_t surface_count,
 		struct dc_target *dc_target);
 
+struct validate_context *dc_pre_commit_surfaces_to_target(
+		struct dc *dc,
+		struct dc_surface *new_surfaces[],
+		uint8_t new_surface_count,
+		struct dc_target *dc_target);
+
+bool dc_isr_commit_surfaces_to_target(
+		struct dc *dc,
+		struct validate_context *context);
+
+bool dc_post_commit_surfaces_to_target(
+		struct dc *dc,
+		struct validate_context *context);
+
+
 bool dc_update_surfaces_for_target(
 		struct dc *dc,
 		struct dc_surface *dc_surfaces[],
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 03ca083..c992665 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -310,6 +310,9 @@ struct validate_context {
 	struct bw_calcs_output bw_results;
 	/* Note: this is a big structure, do *not* put on stack! */
 	struct dm_pp_display_configuration pp_display_cfg;
+
+	/* Temporary*/
+	bool locked;
 };
 
 #endif /* _CORE_TYPES_H_ */
-- 
2.7.4

