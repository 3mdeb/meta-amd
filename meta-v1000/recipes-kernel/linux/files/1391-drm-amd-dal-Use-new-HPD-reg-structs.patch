From dca5dd6c68bfaf0bd39c3952b18bc597ea53c7c5 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Wed, 19 Oct 2016 16:33:43 -0400
Subject: [PATCH 1391/1722] drm/amd/dal: Use new HPD reg structs

Change-Id: I383e4d8f95f6e8881d98fc36b2cfd4494c70ce49
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c |  66 ++++-------
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c   | 126 +++++++++------------
 drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.h           |   5 +
 3 files changed, 82 insertions(+), 115 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
index a5cb053..bbaa4b5 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_hpd_dce110.c
@@ -38,8 +38,18 @@
 #define SF(reg_name, field_name, post_fix)\
 	.field_name = reg_name ## __ ## field_name ## post_fix
 
+#include "reg_helper.h"
 #include "../hpd_regs.h"
 
+#undef FN
+#define FN(reg_name, field_name) \
+	hpd->shifts->field_name, hpd->masks->field_name
+
+#define CTX \
+	hpd->base.base.ctx
+#define REG(reg)\
+	(hpd->regs->reg)
+
 
 #define hpd_regs(id) \
 {\
@@ -245,27 +255,15 @@ static enum gpio_result get_value(
 	uint32_t *value)
 {
 	struct hw_hpd_dce110 *pin = HPD_DCE110_FROM_BASE(ptr);
+	struct hw_hpd *hpd = &pin->base;
+	uint32_t hpd_delayed = 0;
 
 	/* in Interrupt mode we ask for SENSE bit */
 
 	if (ptr->mode == GPIO_MODE_INTERRUPT) {
-		uint32_t regval;
-		uint32_t hpd_delayed = 0;
-		uint32_t hpd_sense = 0;
-
-		regval = dm_read_reg(
-				ptr->ctx,
-				pin->addr.DC_HPD_INT_STATUS);
-
-		hpd_delayed = get_reg_field_value(
-				regval,
-				DC_HPD_INT_STATUS,
-				DC_HPD_SENSE_DELAYED);
 
-		hpd_sense = get_reg_field_value(
-				regval,
-				DC_HPD_INT_STATUS,
-				DC_HPD_SENSE);
+		REG_GET(int_status,
+			DC_HPD_SENSE_DELAYED, &hpd_delayed);
 
 		*value = hpd_delayed;
 		return GPIO_RESULT_OK;
@@ -281,35 +279,14 @@ static enum gpio_result set_config(
 	const struct gpio_config_data *config_data)
 {
 	struct hw_hpd_dce110 *pin = HPD_DCE110_FROM_BASE(ptr);
+	struct hw_hpd *hpd = &pin->base;
 
 	if (!config_data)
 		return GPIO_RESULT_INVALID_DATA;
 
-	{
-		uint32_t value;
-
-		value = dm_read_reg(
-			ptr->ctx,
-			pin->addr.DC_HPD_TOGGLE_FILT_CNTL);
-
-		set_reg_field_value(
-			value,
-			config_data->config.hpd.delay_on_connect / 10,
-			DC_HPD_TOGGLE_FILT_CNTL,
-			DC_HPD_CONNECT_INT_DELAY);
-
-		set_reg_field_value(
-			value,
-			config_data->config.hpd.delay_on_disconnect / 10,
-			DC_HPD_TOGGLE_FILT_CNTL,
-			DC_HPD_DISCONNECT_INT_DELAY);
-
-		dm_write_reg(
-			ptr->ctx,
-			pin->addr.DC_HPD_TOGGLE_FILT_CNTL,
-			value);
-
-	}
+	REG_UPDATE_2(toggle_filt_cntl,
+		DC_HPD_CONNECT_INT_DELAY, config_data->config.hpd.delay_on_connect / 10,
+		DC_HPD_DISCONNECT_INT_DELAY, config_data->config.hpd.delay_on_disconnect / 10);
 
 	return GPIO_RESULT_OK;
 }
@@ -331,6 +308,7 @@ static bool construct(
 	struct dc_context *ctx)
 {
 	const struct hw_gpio_generic_dce110_init *init;
+	struct hw_hpd *hpd = &pin->base;
 
 	if (id != GPIO_ID_HPD) {
 		ASSERT_CRITICAL(false);
@@ -355,6 +333,12 @@ static bool construct(
 
 	pin->addr = init->addr;
 
+	hpd->regs = &hpd_regs[en];
+	hpd->shifts = &hpd_shift;
+	hpd->masks = &hpd_mask;
+
+	hpd->base.regs = &hpd_regs[en].gpio;
+
 	return true;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c
index de80965..ea7aa7c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_hpd_dce80.c
@@ -45,8 +45,19 @@
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
+
+#include "reg_helper.h"
 #include "../hpd_regs.h"
 
+#undef FN
+#define FN(reg_name, field_name) \
+	hpd->shifts->field_name, hpd->masks->field_name
+
+#define CTX \
+	hpd->base.base.ctx
+#define REG(reg)\
+	(hpd->regs->reg)
+
 #define HPD_REG_LIST_DCE8(id) \
 	HPD_GPIO_REG_LIST(id), \
 	.int_status = mmDC_HPD ## id ## _INT_STATUS,\
@@ -108,80 +119,6 @@ static void destroy(
 	*ptr = NULL;
 }
 
-static enum gpio_result get_value(
-	const struct hw_gpio_pin *ptr,
-	uint32_t *value)
-{
-	struct hw_hpd_dce80 *pin = FROM_HW_GPIO_PIN(ptr);
-
-	/* in Interrupt mode we ask for SENSE bit */
-
-	if (ptr->mode == GPIO_MODE_INTERRUPT) {
-		uint32_t regval;
-		uint32_t hpd_delayed = 0;
-		uint32_t hpd_sense = 0;
-
-		regval = dm_read_reg(
-				ptr->ctx,
-				pin->addr.DC_HPD_INT_STATUS);
-
-		hpd_delayed = get_reg_field_value(
-				regval,
-				DC_HPD1_INT_STATUS,
-				DC_HPD1_SENSE_DELAYED);
-
-		hpd_sense = get_reg_field_value(
-				regval,
-				DC_HPD1_INT_STATUS,
-				DC_HPD1_SENSE);
-
-		*value = hpd_delayed;
-		return GPIO_RESULT_OK;
-	}
-
-	/* in any other modes, operate as normal GPIO */
-
-	return dal_hw_gpio_get_value(ptr, value);
-}
-
-static enum gpio_result set_config(
-	struct hw_gpio_pin *ptr,
-	const struct gpio_config_data *config_data)
-{
-	struct hw_hpd_dce80 *pin = FROM_HW_GPIO_PIN(ptr);
-
-	if (!config_data)
-		return GPIO_RESULT_INVALID_DATA;
-
-	{
-		uint32_t value;
-
-		value = dm_read_reg(
-			ptr->ctx,
-			pin->addr.DC_HPD_TOGGLE_FILT_CNTL);
-
-		set_reg_field_value(
-			value,
-			config_data->config.hpd.delay_on_connect / 10,
-			DC_HPD1_TOGGLE_FILT_CNTL,
-			DC_HPD1_CONNECT_INT_DELAY);
-
-		set_reg_field_value(
-			value,
-			config_data->config.hpd.delay_on_disconnect / 10,
-			DC_HPD1_TOGGLE_FILT_CNTL,
-			DC_HPD1_DISCONNECT_INT_DELAY);
-
-		dm_write_reg(
-			ptr->ctx,
-			pin->addr.DC_HPD_TOGGLE_FILT_CNTL,
-			value);
-
-	}
-
-	return GPIO_RESULT_OK;
-}
-
 struct hw_gpio_generic_dce80_init {
 	struct hw_gpio_pin_reg hw_gpio_data_reg;
 	struct hw_hpd_dce80_addr addr;
@@ -341,6 +278,47 @@ static const struct hw_gpio_generic_dce80_init
 	}
 };
 
+static enum gpio_result get_value(
+	const struct hw_gpio_pin *ptr,
+	uint32_t *value)
+{
+	struct hw_hpd_dce80 *pin = FROM_HW_GPIO_PIN(ptr);
+	struct hw_hpd *hpd = &pin->base;
+	uint32_t hpd_delayed = 0;
+
+	/* in Interrupt mode we ask for SENSE bit */
+
+	if (ptr->mode == GPIO_MODE_INTERRUPT) {
+
+		REG_GET(int_status,
+			DC_HPD_SENSE_DELAYED, &hpd_delayed);
+
+		*value = hpd_delayed;
+		return GPIO_RESULT_OK;
+	}
+
+	/* in any other modes, operate as normal GPIO */
+
+	return dal_hw_gpio_get_value(ptr, value);
+}
+
+static enum gpio_result set_config(
+	struct hw_gpio_pin *ptr,
+	const struct gpio_config_data *config_data)
+{
+	struct hw_hpd_dce80 *pin = FROM_HW_GPIO_PIN(ptr);
+	struct hw_hpd *hpd = &pin->base;
+
+	if (!config_data)
+		return GPIO_RESULT_INVALID_DATA;
+
+	REG_UPDATE_2(toggle_filt_cntl,
+		DC_HPD_CONNECT_INT_DELAY, config_data->config.hpd.delay_on_connect / 10,
+		DC_HPD_DISCONNECT_INT_DELAY, config_data->config.hpd.delay_on_disconnect / 10);
+
+	return GPIO_RESULT_OK;
+}
+
 static const struct hw_gpio_pin_funcs funcs = {
 	.destroy = destroy,
 	.open = dal_hw_gpio_open,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.h b/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.h
index 3fb82df..3abb537 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_hpd.h
@@ -26,8 +26,13 @@
 #ifndef __DAL_HW_HPD_H__
 #define __DAL_HW_HPD_H__
 
+#include "hpd_regs.h"
+
 struct hw_hpd {
 	struct hw_gpio base;
+	const struct hpd_registers *regs;
+	const struct hpd_sh_mask *shifts;
+	const struct hpd_sh_mask *masks;
 };
 
 #define HW_HPD_FROM_BASE(hw_gpio) \
-- 
2.7.4

