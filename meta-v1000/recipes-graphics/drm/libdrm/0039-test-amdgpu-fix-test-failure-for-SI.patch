From 66f95d615faca3ce857e59e3c06ee9469be942a8 Mon Sep 17 00:00:00 2001
From: Flora Cui <Flora.Cui@amd.com>
Date: Wed, 19 Jul 2017 10:52:33 +0800
Subject: [PATCH 39/39] test/amdgpu: fix test failure for SI

Change-Id: I646f1bf844bd92962b9f71aa287f90173ae233c6
Signed-off-by: Flora Cui <Flora.Cui@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
---
 tests/amdgpu/basic_tests.c | 273 ++++++++++++++++++++++++++++++---------------
 tests/amdgpu/cs_tests.c    |  41 +++----
 tests/amdgpu/vce_tests.c   |  41 +++----
 3 files changed, 229 insertions(+), 126 deletions(-)

diff --git a/tests/amdgpu/basic_tests.c b/tests/amdgpu/basic_tests.c
index 1807538..c767f7e 100644
--- a/tests/amdgpu/basic_tests.c
+++ b/tests/amdgpu/basic_tests.c
@@ -40,6 +40,7 @@
 static  amdgpu_device_handle device_handle;
 static  uint32_t  major_version;
 static  uint32_t  minor_version;
+static  uint32_t  family_id;
 
 static void amdgpu_query_info_test(void);
 static void amdgpu_memory_alloc(void);
@@ -206,22 +207,56 @@ CU_TestInfo basic_tests[] = {
 #              define PACKET3_DMA_DATA_CMD_DAIC    (1 << 29)
 #              define PACKET3_DMA_DATA_CMD_RAW_WAIT  (1 << 30)
 
+#define SDMA_PACKET_SI(op, b, t, s, cnt)	((((op) & 0xF) << 28) |	\
+						(((b) & 0x1) << 26) |		\
+						(((t) & 0x1) << 23) |		\
+						(((s) & 0x1) << 22) |		\
+						(((cnt) & 0xFFFFF) << 0))
+#define	SDMA_OPCODE_COPY_SI	3
+#define SDMA_OPCODE_CONSTANT_FILL_SI	13
+#define SDMA_NOP_SI  0xf
+#define GFX_COMPUTE_NOP_SI 0x80000000
+#define	PACKET3_DMA_DATA_SI	0x41
+#              define PACKET3_DMA_DATA_SI_ENGINE(x)     ((x) << 27)
+		/* 0 - ME
+		 * 1 - PFP
+		 */
+#              define PACKET3_DMA_DATA_SI_DST_SEL(x)  ((x) << 20)
+		/* 0 - DST_ADDR using DAS
+		 * 1 - GDS
+		 * 3 - DST_ADDR using L2
+		 */
+#              define PACKET3_DMA_DATA_SI_SRC_SEL(x)  ((x) << 29)
+		/* 0 - SRC_ADDR using SAS
+		 * 1 - GDS
+		 * 2 - DATA
+		 * 3 - SRC_ADDR using L2
+		 */
+#              define PACKET3_DMA_DATA_SI_CP_SYNC     (1 << 31)
+
 int suite_basic_tests_init(void)
 {
+	struct amdgpu_gpu_info gpu_info = {0};
 	int r;
 
 	r = amdgpu_device_initialize(drm_amdgpu[0], &major_version,
 				   &minor_version, &device_handle);
 
-	if (r == 0)
-		return CUE_SUCCESS;
-	else {
+	if (r) {
 		if ((r == -EACCES) && (errno == EACCES))
 			printf("\n\nError:%s. "
 				"Hint:Try to run this test program as root.",
 				strerror(errno));
 		return CUE_SINIT_FAILED;
 	}
+
+	r = amdgpu_query_gpu_info(device_handle, &gpu_info);
+	if (r)
+		return CUE_SINIT_FAILED;
+
+	family_id = gpu_info.family_id;
+
+	return CUE_SUCCESS;
 }
 
 int suite_basic_tests_clean(void)
@@ -308,7 +343,7 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 	uint32_t expired;
 	amdgpu_bo_list_handle bo_list;
 	amdgpu_va_handle va_handle, va_handle_ce;
-	int r;
+	int r, i = 0;
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
 	CU_ASSERT_EQUAL(r, 0);
@@ -333,12 +368,14 @@ static void amdgpu_command_submission_gfx_separate_ibs(void)
 
 	/* IT_SET_CE_DE_COUNTERS */
 	ptr = ib_result_ce_cpu;
-	ptr[0] = 0xc0008900;
-	ptr[1] = 0;
-	ptr[2] = 0xc0008400;
-	ptr[3] = 1;
+	if (family_id != AMDGPU_FAMILY_SI) {
+		ptr[i++] = 0xc0008900;
+		ptr[i++] = 0;
+	}
+	ptr[i++] = 0xc0008400;
+	ptr[i++] = 1;
 	ib_info[0].ib_mc_address = ib_result_ce_mc_address;
-	ib_info[0].size = 4;
+	ib_info[0].size = i;
 	ib_info[0].flags = AMDGPU_IB_FLAG_CE;
 
 	/* IT_WAIT_ON_CE_COUNTER */
@@ -397,7 +434,7 @@ static void amdgpu_command_submission_gfx_shared_ib(void)
 	uint32_t expired;
 	amdgpu_bo_list_handle bo_list;
 	amdgpu_va_handle va_handle;
-	int r;
+	int r, i = 0;
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
 	CU_ASSERT_EQUAL(r, 0);
@@ -416,12 +453,14 @@ static void amdgpu_command_submission_gfx_shared_ib(void)
 
 	/* IT_SET_CE_DE_COUNTERS */
 	ptr = ib_result_cpu;
-	ptr[0] = 0xc0008900;
-	ptr[1] = 0;
-	ptr[2] = 0xc0008400;
-	ptr[3] = 1;
+	if (family_id != AMDGPU_FAMILY_SI) {
+		ptr[i++] = 0xc0008900;
+		ptr[i++] = 0;
+	}
+	ptr[i++] = 0xc0008400;
+	ptr[i++] = 1;
 	ib_info[0].ib_mc_address = ib_result_mc_address;
-	ib_info[0].size = 4;
+	ib_info[0].size = i;
 	ib_info[0].flags = AMDGPU_IB_FLAG_CE;
 
 	ptr = (uint32_t *)ib_result_cpu + 4;
@@ -502,12 +541,21 @@ static void amdgpu_semaphore_test(void)
 	struct amdgpu_cs_fence fence_status = {0};
 	uint32_t *ptr;
 	uint32_t expired;
+	uint32_t sdma_nop, gfx_nop;
 	amdgpu_bo_list_handle bo_list[2];
 	amdgpu_va_handle va_handle[2];
 	amdgpu_sem_handle sem_handle, sem_handle_import;
 	int fd;
 	int r, i;
 
+	if (family_id == AMDGPU_FAMILY_SI) {
+		sdma_nop = SDMA_PACKET_SI(SDMA_NOP_SI, 0, 0, 0, 0);
+		gfx_nop = GFX_COMPUTE_NOP_SI;
+	} else {
+		sdma_nop = SDMA_PKT_HEADER_OP(SDMA_NOP);
+		gfx_nop = GFX_COMPUTE_NOP;
+	}
+
 	r = amdgpu_cs_create_semaphore(&sem);
 	CU_ASSERT_EQUAL(r, 0);
 	for (i = 0; i < 2; i++) {
@@ -527,7 +575,7 @@ static void amdgpu_semaphore_test(void)
 
 	/* 1. same context different engine */
 	ptr = ib_result_cpu[0];
-	ptr[0] = SDMA_NOP;
+	ptr[0] = sdma_nop;
 	ib_info[0].ib_mc_address = ib_result_mc_address[0];
 	ib_info[0].size = 1;
 
@@ -544,7 +592,7 @@ static void amdgpu_semaphore_test(void)
 	r = amdgpu_cs_wait_semaphore(context_handle[0], AMDGPU_HW_IP_GFX, 0, 0, sem);
 	CU_ASSERT_EQUAL(r, 0);
 	ptr = ib_result_cpu[1];
-	ptr[0] = GFX_COMPUTE_NOP;
+	ptr[0] = gfx_nop;
 	ib_info[1].ib_mc_address = ib_result_mc_address[1];
 	ib_info[1].size = 1;
 
@@ -568,7 +616,7 @@ static void amdgpu_semaphore_test(void)
 
 	/* 2. same engine different context */
 	ptr = ib_result_cpu[0];
-	ptr[0] = GFX_COMPUTE_NOP;
+	ptr[0] = gfx_nop;
 	ib_info[0].ib_mc_address = ib_result_mc_address[0];
 	ib_info[0].size = 1;
 
@@ -585,7 +633,7 @@ static void amdgpu_semaphore_test(void)
 	r = amdgpu_cs_wait_semaphore(context_handle[1], AMDGPU_HW_IP_GFX, 0, 0, sem);
 	CU_ASSERT_EQUAL(r, 0);
 	ptr = ib_result_cpu[1];
-	ptr[0] = GFX_COMPUTE_NOP;
+	ptr[0] = gfx_nop;
 	ib_info[1].ib_mc_address = ib_result_mc_address[1];
 	ib_info[1].size = 1;
 
@@ -612,7 +660,7 @@ static void amdgpu_semaphore_test(void)
 	CU_ASSERT_EQUAL(r, 0);
 
 	ptr = ib_result_cpu[0];
-	ptr[0] = SDMA_NOP;
+	ptr[0] = sdma_nop;
 	ib_info[0].ib_mc_address = ib_result_mc_address[0];
 	ib_info[0].size = 1;
 
@@ -639,7 +687,7 @@ static void amdgpu_semaphore_test(void)
 	r = amdgpu_cs_wait_sem(device_handle, context_handle[1], AMDGPU_HW_IP_GFX, 0, 0, sem_handle_import);
 	CU_ASSERT_EQUAL(r, 0);
 	ptr = ib_result_cpu[1];
-	ptr[0] = GFX_COMPUTE_NOP;
+	ptr[0] = gfx_nop;
 	ib_info[1].ib_mc_address = ib_result_mc_address[1];
 	ib_info[1].size = 1;
 
@@ -694,11 +742,15 @@ static void amdgpu_command_submission_compute_nop(void)
 	int i, r, instance;
 	amdgpu_bo_list_handle bo_list;
 	amdgpu_va_handle va_handle;
+	struct drm_amdgpu_info_hw_ip info;
+
+	r = amdgpu_query_hw_ip_info(device_handle, AMDGPU_HW_IP_COMPUTE, 0, &info);
+	CU_ASSERT_EQUAL(r, 0);
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
 	CU_ASSERT_EQUAL(r, 0);
 
-	for (instance = 0; instance < 8; instance++) {
+	for (instance = 0; (1 << instance) & info.available_rings; instance++) {
 		r = amdgpu_bo_alloc_and_map(device_handle, 4096, 4096,
 					    AMDGPU_GEM_DOMAIN_GTT, 0,
 					    &ib_result_handle, &ib_result_cpu,
@@ -710,8 +762,8 @@ static void amdgpu_command_submission_compute_nop(void)
 		CU_ASSERT_EQUAL(r, 0);
 
 		ptr = ib_result_cpu;
-		for (i = 0; i < 16; ++i)
-			ptr[i] = 0xffff1000;
+		memset(ptr, 0, 16);
+		ptr[0]=PACKET3(PACKET3_NOP, 14);
 
 		memset(&ib_info, 0, sizeof(struct amdgpu_cs_ib_info));
 		ib_info.ib_mc_address = ib_result_mc_address;
@@ -872,16 +924,12 @@ static void amdgpu_command_submission_write_linear_helper(unsigned ip_type)
 	uint32_t *pm4;
 	struct amdgpu_cs_ib_info *ib_info;
 	struct amdgpu_cs_request *ibs_request;
-	struct amdgpu_gpu_info gpu_info = {0};
 	uint64_t bo_mc;
 	volatile uint32_t *bo_cpu;
 	int i, j, r, loop;
 	uint64_t gtt_flags[2] = {0, AMDGPU_GEM_CREATE_CPU_GTT_USWC};
 	amdgpu_va_handle va_handle;
 
-	r = amdgpu_query_gpu_info(device_handle, &gpu_info);
-	CU_ASSERT_EQUAL(r, 0);
-
 	pm4 = calloc(pm4_dw, sizeof(*pm4));
 	CU_ASSERT_NOT_EQUAL(pm4, NULL);
 
@@ -917,13 +965,17 @@ static void amdgpu_command_submission_write_linear_helper(unsigned ip_type)
 		/* fulfill PM4: test DMA write-linear */
 		i = j = 0;
 		if (ip_type == AMDGPU_HW_IP_DMA) {
-			pm4[i++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
-					       SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
+			if (family_id == AMDGPU_FAMILY_SI)
+				pm4[i++] = SDMA_PACKET_SI(SDMA_OPCODE_WRITE, 0, 0, 0,
+							  sdma_write_length);
+			else
+				pm4[i++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
+						       SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
 			pm4[i++] = 0xffffffff & bo_mc;
 			pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
-			if (gpu_info.family_id >= AMDGPU_FAMILY_AI)
+			if (family_id >= AMDGPU_FAMILY_AI)
 				pm4[i++] = sdma_write_length - 1;
-			else
+			else if (family_id != AMDGPU_FAMILY_SI)
 				pm4[i++] = sdma_write_length;
 			while(j++ < sdma_write_length)
 				pm4[i++] = 0xdeadbeaf;
@@ -980,16 +1032,12 @@ static void amdgpu_command_submission_const_fill_helper(unsigned ip_type)
 	uint32_t *pm4;
 	struct amdgpu_cs_ib_info *ib_info;
 	struct amdgpu_cs_request *ibs_request;
-	struct amdgpu_gpu_info gpu_info = {0};
 	uint64_t bo_mc;
 	volatile uint32_t *bo_cpu;
 	int i, j, r, loop;
 	uint64_t gtt_flags[2] = {0, AMDGPU_GEM_CREATE_CPU_GTT_USWC};
 	amdgpu_va_handle va_handle;
 
-	r = amdgpu_query_gpu_info(device_handle, &gpu_info);
-	CU_ASSERT_EQUAL(r, 0);
-
 	pm4 = calloc(pm4_dw, sizeof(*pm4));
 	CU_ASSERT_NOT_EQUAL(pm4, NULL);
 
@@ -1024,27 +1072,47 @@ static void amdgpu_command_submission_const_fill_helper(unsigned ip_type)
 		/* fulfill PM4: test DMA const fill */
 		i = j = 0;
 		if (ip_type == AMDGPU_HW_IP_DMA) {
-			pm4[i++] = SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
-					       SDMA_CONSTANT_FILL_EXTRA_SIZE(2));
-			pm4[i++] = 0xffffffff & bo_mc;
-			pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
-			pm4[i++] = 0xdeadbeaf;
-			if (gpu_info.family_id >= AMDGPU_FAMILY_AI)
-				pm4[i++] = sdma_write_length - 1;
-			else
-				pm4[i++] = sdma_write_length;
+			if (family_id == AMDGPU_FAMILY_SI) {
+				pm4[i++] = SDMA_PACKET_SI(SDMA_OPCODE_CONSTANT_FILL_SI, 0, 0, 0,
+							  sdma_write_length / 4);
+				pm4[i++] = 0xfffffffc & bo_mc;
+				pm4[i++] = 0xdeadbeaf;
+				pm4[i++] = (0xffffffff00000000 & bo_mc) >> 16;
+			} else {
+				pm4[i++] = SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+						       SDMA_CONSTANT_FILL_EXTRA_SIZE(2));
+				pm4[i++] = 0xffffffff & bo_mc;
+				pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
+				pm4[i++] = 0xdeadbeaf;
+				if (family_id >= AMDGPU_FAMILY_AI)
+					pm4[i++] = sdma_write_length - 1;
+				else
+					pm4[i++] = sdma_write_length;
+			}
 		} else if ((ip_type == AMDGPU_HW_IP_GFX) ||
 			   (ip_type == AMDGPU_HW_IP_COMPUTE)) {
-			pm4[i++] = PACKET3(PACKET3_DMA_DATA, 5);
-			pm4[i++] = PACKET3_DMA_DATA_ENGINE(0) |
-				PACKET3_DMA_DATA_DST_SEL(0) |
-				PACKET3_DMA_DATA_SRC_SEL(2) |
-				PACKET3_DMA_DATA_CP_SYNC;
-			pm4[i++] = 0xdeadbeaf;
-			pm4[i++] = 0;
-			pm4[i++] = 0xfffffffc & bo_mc;
-			pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
-			pm4[i++] = sdma_write_length;
+			if (family_id == AMDGPU_FAMILY_SI) {
+				pm4[i++] = PACKET3(PACKET3_DMA_DATA_SI, 4);
+				pm4[i++] = 0xdeadbeaf;
+				pm4[i++] = PACKET3_DMA_DATA_SI_ENGINE(0) |
+					PACKET3_DMA_DATA_SI_DST_SEL(0) |
+					PACKET3_DMA_DATA_SI_SRC_SEL(2) |
+					PACKET3_DMA_DATA_SI_CP_SYNC;
+				pm4[i++] = 0xffffffff & bo_mc;
+				pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
+				pm4[i++] = sdma_write_length;
+			} else {
+				pm4[i++] = PACKET3(PACKET3_DMA_DATA, 5);
+				pm4[i++] = PACKET3_DMA_DATA_ENGINE(0) |
+					PACKET3_DMA_DATA_DST_SEL(0) |
+					PACKET3_DMA_DATA_SRC_SEL(2) |
+					PACKET3_DMA_DATA_CP_SYNC;
+				pm4[i++] = 0xdeadbeaf;
+				pm4[i++] = 0;
+				pm4[i++] = 0xfffffffc & bo_mc;
+				pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
+				pm4[i++] = sdma_write_length;
+			}
 		}
 
 		amdgpu_test_exec_cs_helper(context_handle,
@@ -1090,16 +1158,12 @@ static void amdgpu_command_submission_copy_linear_helper(unsigned ip_type)
 	uint32_t *pm4;
 	struct amdgpu_cs_ib_info *ib_info;
 	struct amdgpu_cs_request *ibs_request;
-	struct amdgpu_gpu_info gpu_info = {0};
 	uint64_t bo1_mc, bo2_mc;
 	volatile unsigned char *bo1_cpu, *bo2_cpu;
 	int i, j, r, loop1, loop2;
 	uint64_t gtt_flags[2] = {0, AMDGPU_GEM_CREATE_CPU_GTT_USWC};
 	amdgpu_va_handle bo1_va_handle, bo2_va_handle;
 
-	r = amdgpu_query_gpu_info(device_handle, &gpu_info);
-	CU_ASSERT_EQUAL(r, 0);
-
 	pm4 = calloc(pm4_dw, sizeof(*pm4));
 	CU_ASSERT_NOT_EQUAL(pm4, NULL);
 
@@ -1150,28 +1214,51 @@ static void amdgpu_command_submission_copy_linear_helper(unsigned ip_type)
 			/* fulfill PM4: test DMA copy linear */
 			i = j = 0;
 			if (ip_type == AMDGPU_HW_IP_DMA) {
-				pm4[i++] = SDMA_PACKET(SDMA_OPCODE_COPY, SDMA_COPY_SUB_OPCODE_LINEAR, 0);
-				if (gpu_info.family_id >= AMDGPU_FAMILY_AI)
-					pm4[i++] = sdma_write_length - 1;
-				else
-					pm4[i++] = sdma_write_length;
-				pm4[i++] = 0;
-				pm4[i++] = 0xffffffff & bo1_mc;
-				pm4[i++] = (0xffffffff00000000 & bo1_mc) >> 32;
-				pm4[i++] = 0xffffffff & bo2_mc;
-				pm4[i++] = (0xffffffff00000000 & bo2_mc) >> 32;
+				if (family_id == AMDGPU_FAMILY_SI) {
+					pm4[i++] = SDMA_PACKET_SI(SDMA_OPCODE_COPY_SI, 0, 0, 0,
+								  sdma_write_length);
+					pm4[i++] = 0xffffffff & bo2_mc;
+					pm4[i++] = 0xffffffff & bo1_mc;
+					pm4[i++] = (0xffffffff00000000 & bo2_mc) >> 32;
+					pm4[i++] = (0xffffffff00000000 & bo1_mc) >> 32;
+				} else {
+					pm4[i++] = SDMA_PACKET(SDMA_OPCODE_COPY, SDMA_COPY_SUB_OPCODE_LINEAR, 0);
+					if (family_id >= AMDGPU_FAMILY_AI)
+						pm4[i++] = sdma_write_length - 1;
+					else
+						pm4[i++] = sdma_write_length;
+					pm4[i++] = 0;
+					pm4[i++] = 0xffffffff & bo1_mc;
+					pm4[i++] = (0xffffffff00000000 & bo1_mc) >> 32;
+					pm4[i++] = 0xffffffff & bo2_mc;
+					pm4[i++] = (0xffffffff00000000 & bo2_mc) >> 32;
+				}
+
 			} else if ((ip_type == AMDGPU_HW_IP_GFX) ||
 				   (ip_type == AMDGPU_HW_IP_COMPUTE)) {
-				pm4[i++] = PACKET3(PACKET3_DMA_DATA, 5);
-				pm4[i++] = PACKET3_DMA_DATA_ENGINE(0) |
-					PACKET3_DMA_DATA_DST_SEL(0) |
-					PACKET3_DMA_DATA_SRC_SEL(0) |
-					PACKET3_DMA_DATA_CP_SYNC;
-				pm4[i++] = 0xfffffffc & bo1_mc;
-				pm4[i++] = (0xffffffff00000000 & bo1_mc) >> 32;
-				pm4[i++] = 0xfffffffc & bo2_mc;
-				pm4[i++] = (0xffffffff00000000 & bo2_mc) >> 32;
-				pm4[i++] = sdma_write_length;
+				if (family_id == AMDGPU_FAMILY_SI) {
+					pm4[i++] = PACKET3(PACKET3_DMA_DATA_SI, 4);
+					pm4[i++] = 0xfffffffc & bo1_mc;
+					pm4[i++] = PACKET3_DMA_DATA_SI_ENGINE(0) |
+						PACKET3_DMA_DATA_SI_DST_SEL(0) |
+						PACKET3_DMA_DATA_SI_SRC_SEL(0) |
+						PACKET3_DMA_DATA_SI_CP_SYNC |
+						(0xffff00000000 & bo1_mc) >> 32;
+					pm4[i++] = 0xfffffffc & bo2_mc;
+					pm4[i++] = (0xffffffff00000000 & bo2_mc) >> 32;
+					pm4[i++] = sdma_write_length;
+				} else {
+					pm4[i++] = PACKET3(PACKET3_DMA_DATA, 5);
+					pm4[i++] = PACKET3_DMA_DATA_ENGINE(0) |
+						PACKET3_DMA_DATA_DST_SEL(0) |
+						PACKET3_DMA_DATA_SRC_SEL(0) |
+						PACKET3_DMA_DATA_CP_SYNC;
+					pm4[i++] = 0xfffffffc & bo1_mc;
+					pm4[i++] = (0xffffffff00000000 & bo1_mc) >> 32;
+					pm4[i++] = 0xfffffffc & bo2_mc;
+					pm4[i++] = (0xffffffff00000000 & bo2_mc) >> 32;
+					pm4[i++] = sdma_write_length;
+				}
 			}
 
 			amdgpu_test_exec_cs_helper(context_handle,
@@ -1232,7 +1319,7 @@ static void amdgpu_command_submission_multi_fence_wait_all(bool wait_all)
 	amdgpu_bo_list_handle bo_list;
 	amdgpu_va_handle va_handle, va_handle_ce;
 	int r;
-	int i, ib_cs_num = 2;
+	int i = 0, ib_cs_num = 2;
 
 	r = amdgpu_cs_ctx_create(device_handle, &context_handle);
 	CU_ASSERT_EQUAL(r, 0);
@@ -1257,12 +1344,14 @@ static void amdgpu_command_submission_multi_fence_wait_all(bool wait_all)
 
 	/* IT_SET_CE_DE_COUNTERS */
 	ptr = ib_result_ce_cpu;
-	ptr[0] = 0xc0008900;
-	ptr[1] = 0;
-	ptr[2] = 0xc0008400;
-	ptr[3] = 1;
+	if (family_id != AMDGPU_FAMILY_SI) {
+		ptr[i++] = 0xc0008900;
+		ptr[i++] = 0;
+	}
+	ptr[i++] = 0xc0008400;
+	ptr[i++] = 1;
 	ib_info[0].ib_mc_address = ib_result_ce_mc_address;
-	ib_info[0].size = 4;
+	ib_info[0].size = i;
 	ib_info[0].flags = AMDGPU_IB_FLAG_CE;
 
 	/* IT_WAIT_ON_CE_COUNTER */
@@ -1363,11 +1452,19 @@ static void amdgpu_userptr_test(void)
 	handle = buf_handle;
 
 	j = i = 0;
-	pm4[i++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
-			       SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
+
+	if (family_id == AMDGPU_FAMILY_SI)
+		pm4[i++] = SDMA_PACKET_SI(SDMA_OPCODE_WRITE, 0, 0, 0,
+				sdma_write_length);
+	else
+		pm4[i++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
+				SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
 	pm4[i++] = 0xffffffff & bo_mc;
 	pm4[i++] = (0xffffffff00000000 & bo_mc) >> 32;
-	pm4[i++] = sdma_write_length;
+	if (family_id >= AMDGPU_FAMILY_AI)
+		pm4[i++] = sdma_write_length - 1;
+	else if (family_id != AMDGPU_FAMILY_SI)
+		pm4[i++] = sdma_write_length;
 
 	while (j++ < sdma_write_length)
 		pm4[i++] = 0xdeadbeaf;
diff --git a/tests/amdgpu/cs_tests.c b/tests/amdgpu/cs_tests.c
index df55c70..3b2f17d 100644
--- a/tests/amdgpu/cs_tests.c
+++ b/tests/amdgpu/cs_tests.c
@@ -90,7 +90,7 @@ int suite_cs_tests_init(void)
 	chip_rev = device_handle->info.chip_rev;
 	chip_id = device_handle->info.chip_external_rev;
 
-	if (family_id >= AMDGPU_FAMILY_RV) {
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI) {
 		printf("\n\nThe ASIC NOT support UVD, all sub-tests will pass\n");
 		return CUE_SUCCESS;
 	}
@@ -119,21 +119,24 @@ int suite_cs_tests_clean(void)
 {
 	int r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
-		return CUE_SUCCESS;
-
-	r = amdgpu_bo_unmap_and_free(ib_handle, ib_va_handle,
-				     ib_mc_address, IB_SIZE);
-	if (r)
-		return CUE_SCLEAN_FAILED;
-
-	r = amdgpu_cs_ctx_free(context_handle);
-	if (r)
-		return CUE_SCLEAN_FAILED;
-
-	r = amdgpu_device_deinitialize(device_handle);
-	if (r)
-		return CUE_SCLEAN_FAILED;
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI) {
+		r = amdgpu_device_deinitialize(device_handle);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+	} else {
+		r = amdgpu_bo_unmap_and_free(ib_handle, ib_va_handle,
+					     ib_mc_address, IB_SIZE);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+
+		r = amdgpu_cs_ctx_free(context_handle);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+
+		r = amdgpu_device_deinitialize(device_handle);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+	}
 
 	return CUE_SUCCESS;
 }
@@ -200,7 +203,7 @@ static void amdgpu_cs_uvd_create(void)
 	void *msg;
 	int i, r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI)
 		return;
 
 	req.alloc_size = 4*1024;
@@ -274,7 +277,7 @@ static void amdgpu_cs_uvd_decode(void)
 	uint8_t *ptr;
 	int i, r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI)
                 return;
 
 	req.alloc_size = 4*1024; /* msg */
@@ -416,7 +419,7 @@ static void amdgpu_cs_uvd_destroy(void)
 	void *msg;
 	int i, r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI)
                 return;
 
 	req.alloc_size = 4*1024;
diff --git a/tests/amdgpu/vce_tests.c b/tests/amdgpu/vce_tests.c
index 8d61a3b..cf44c13 100644
--- a/tests/amdgpu/vce_tests.c
+++ b/tests/amdgpu/vce_tests.c
@@ -106,7 +106,7 @@ int suite_vce_tests_init(void)
 	family_id = device_handle->info.family_id;
 	vce_harvest_config = device_handle->info.vce_harvest_config;
 
-	if (family_id >= AMDGPU_FAMILY_RV) {
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI) {
 		printf("\n\nThe ASIC NOT support VCE, all sub-tests will pass\n");
 		return CUE_SUCCESS;
 	}
@@ -131,21 +131,24 @@ int suite_vce_tests_clean(void)
 {
 	int r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
-		return CUE_SUCCESS;
-
-	r = amdgpu_bo_unmap_and_free(ib_handle, ib_va_handle,
-				     ib_mc_address, IB_SIZE);
-	if (r)
-		return CUE_SCLEAN_FAILED;
-
-	r = amdgpu_cs_ctx_free(context_handle);
-	if (r)
-		return CUE_SCLEAN_FAILED;
-
-	r = amdgpu_device_deinitialize(device_handle);
-	if (r)
-		return CUE_SCLEAN_FAILED;
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI) {
+		r = amdgpu_device_deinitialize(device_handle);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+	} else {
+		r = amdgpu_bo_unmap_and_free(ib_handle, ib_va_handle,
+					     ib_mc_address, IB_SIZE);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+
+		r = amdgpu_cs_ctx_free(context_handle);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+
+		r = amdgpu_device_deinitialize(device_handle);
+		if (r)
+			return CUE_SCLEAN_FAILED;
+	}
 
 	return CUE_SUCCESS;
 }
@@ -245,7 +248,7 @@ static void amdgpu_cs_vce_create(void)
 	unsigned align = (family_id >= AMDGPU_FAMILY_AI) ? 256 : 16;
 	int len, r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI)
 		return;
 
 	enc.width = vce_create[6];
@@ -441,7 +444,7 @@ static void amdgpu_cs_vce_encode(void)
 	unsigned align = (family_id >= AMDGPU_FAMILY_AI) ? 256 : 16;
 	int i, r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI)
 		return;
 
 	vbuf_size = ALIGN(enc.width, align) * ALIGN(enc.height, 16) * 1.5;
@@ -522,7 +525,7 @@ static void amdgpu_cs_vce_destroy(void)
 {
 	int len, r;
 
-	if (family_id >= AMDGPU_FAMILY_RV)
+	if (family_id >= AMDGPU_FAMILY_RV || family_id == AMDGPU_FAMILY_SI)
 		return;
 
 	num_resources  = 0;
-- 
2.7.4

