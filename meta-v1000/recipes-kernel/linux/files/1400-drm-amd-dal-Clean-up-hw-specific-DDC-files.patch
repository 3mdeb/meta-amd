From 52236aab7633e0c958e9af04c7db0dfef4721d07 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 20 Oct 2016 21:22:58 -0400
Subject: [PATCH 1400/1722] drm/amd/dal: Clean up hw specific DDC files

Change-Id: Ide70fd289996fa4c060630de5dedca76a3650a7f
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/gpio/Makefile           |   2 +-
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c | 238 ------------------
 .../gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h |   5 -
 .../drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c |   4 +-
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c   | 238 ------------------
 .../gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h   |   5 -
 .../drm/amd/dal/dc/gpio/dce80/hw_factory_dce80.c   |   4 +-
 drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c           | 272 +++++++++++++++++++++
 drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.h           |   5 +
 9 files changed, 282 insertions(+), 491 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c

diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/Makefile b/drivers/gpu/drm/amd/dal/dc/gpio/Makefile
index e23dd96..b82acd0 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/Makefile
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/Makefile
@@ -3,7 +3,7 @@
 # It provides the control and status of HW GPIO pins.
 
 GPIO = gpio_base.o gpio_service.o hw_factory.o \
-       hw_gpio.o hw_hpd.o hw_translate.o
+       hw_gpio.o hw_hpd.o hw_ddc.o hw_translate.o
 
 AMD_DAL_GPIO = $(addprefix $(AMDDALPATH)/dc/gpio/,$(GPIO))
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
index a01c3cc..545d1d9 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.c
@@ -42,16 +42,6 @@
 #define SF(reg_name, field_name, post_fix)\
 	.field_name = reg_name ## __ ## field_name ## post_fix
 
-
-#undef FN
-#define FN(reg_name, field_name) \
-	ddc->shifts->field_name, ddc->masks->field_name
-
-#define CTX \
-	ddc->base.base.ctx
-#define REG(reg)\
-	(ddc->regs->reg)
-
 static const struct ddc_registers ddc_data_regs[] = {
 	ddc_data_regs(1),
 	ddc_data_regs(2),
@@ -82,192 +72,6 @@ static const struct ddc_sh_mask ddc_mask = {
 		DDC_MASK_SH_LIST(_MASK)
 };
 
-static void destruct(
-	struct hw_ddc *pin)
-{
-	dal_hw_gpio_destruct(&pin->base);
-}
-
-static void destroy(
-	struct hw_gpio_pin **ptr)
-{
-	struct hw_ddc *pin = HW_DDC_FROM_BASE(*ptr);
-
-	destruct(pin);
-
-	dm_free(pin);
-
-	*ptr = NULL;
-}
-
-static enum gpio_result set_config(
-	struct hw_gpio_pin *ptr,
-	const struct gpio_config_data *config_data)
-{
-	struct hw_ddc *ddc = HW_DDC_FROM_BASE(ptr);
-	struct hw_gpio *hw_gpio = NULL;
-	uint32_t addr;
-	uint32_t regval;
-	uint32_t ddc_data_pd_en = 0;
-	uint32_t ddc_clk_pd_en = 0;
-	uint32_t aux_pad_mode = 0;
-
-	hw_gpio = &ddc->base;
-
-	if (hw_gpio == NULL) {
-		ASSERT_CRITICAL(false);
-		return GPIO_RESULT_NULL_HANDLE;
-	}
-
-	/* switch dual mode GPIO to I2C/AUX mode */
-	addr = ddc->base.regs->MASK_reg;
-
-	regval = REG_READ(gpio.MASK_reg);
-
-	ddc_data_pd_en = get_reg_field_value_ex(
-			regval,
-			FN(,DC_GPIO_DDC1DATA_PD_EN));
-
-	ddc_clk_pd_en = get_reg_field_value_ex(
-			regval,
-			FN(,DC_GPIO_DDC1CLK_PD_EN));
-
-	aux_pad_mode = get_reg_field_value_ex(
-			regval,
-			FN(,AUX_PAD1_MODE));
-
-	switch (config_data->config.ddc.type) {
-	case GPIO_DDC_CONFIG_TYPE_MODE_I2C:
-		/* On plug-in, there is a transient level on the pad
-		 * which must be discharged through the internal pull-down.
-		 * Enable internal pull-down, 2.5msec discharge time
-		 * is required for detection of AUX mode */
-		if (hw_gpio->base.en != GPIO_DDC_LINE_VIP_PAD) {
-			if (!ddc_data_pd_en || !ddc_clk_pd_en) {
-				set_reg_field_value_ex(
-					regval,
-					1,
-					FN(,DC_GPIO_DDC1DATA_PD_EN));
-
-				set_reg_field_value_ex(
-					regval,
-					1,
-					FN(,DC_GPIO_DDC1CLK_PD_EN));
-
-				REG_WRITE(gpio.MASK_reg, regval);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-		} else {
-			uint32_t reg2 = regval;
-			uint32_t sda_pd_dis = 0;
-			uint32_t scl_pd_dis = 0;
-
-			sda_pd_dis = get_reg_field_value_ex(
-					reg2,
-					FN(,DC_GPIO_SDA_PD_DIS));
-
-			scl_pd_dis = get_reg_field_value_ex(
-					reg2,
-					FN(,DC_GPIO_SCL_PD_DIS));
-
-			if (sda_pd_dis)
-				sda_pd_dis = 0;
-
-			if (!scl_pd_dis)
-				scl_pd_dis = 1;
-
-			if (sda_pd_dis || !scl_pd_dis) {
-				REG_WRITE(gpio.MASK_reg, reg2);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-		}
-
-		if (aux_pad_mode) {
-			/* let pins to get de-asserted
-			 * before setting pad to I2C mode */
-			if (config_data->config.ddc.data_en_bit_present ||
-				config_data->config.ddc.clock_en_bit_present)
-				/* [anaumov] in DAL2, there was
-				 * dc_service_delay_in_microseconds(2000); */
-				msleep(2);
-
-			/* set the I2C pad mode */
-			/* read the register again,
-			 * some bits may have been changed */
-			REG_UPDATE(gpio.MASK_reg, AUX_PAD1_MODE, 1);
-		}
-
-		return GPIO_RESULT_OK;
-	case GPIO_DDC_CONFIG_TYPE_MODE_AUX:
-		/* set the AUX pad mode */
-		if (!aux_pad_mode) {
-			set_reg_field_value_ex(
-				regval,
-				1,
-				FN(,AUX_PAD1_MODE));
-
-			REG_WRITE(gpio.MASK_reg, regval);
-		}
-
-		return GPIO_RESULT_OK;
-	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_CONNECT:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			REG_UPDATE_3(ddc_setup,
-				DC_I2C_DDC1_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_MODE, 0);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_DISCONNECT:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			REG_UPDATE_3(ddc_setup,
-				DC_I2C_DDC1_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_MODE, 1);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	case GPIO_DDC_CONFIG_TYPE_DISABLE_POLLING:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			REG_UPDATE_2(ddc_setup,
-				DC_I2C_DDC1_ENABLE, 0,
-				DC_I2C_DDC1_EDID_DETECT_ENABLE, 0);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	}
-
-	BREAK_TO_DEBUGGER();
-
-	return GPIO_RESULT_NON_SPECIFIC_ERROR;
-}
-
-static const struct hw_gpio_pin_funcs funcs = {
-	.destroy = destroy,
-	.open = dal_hw_gpio_open,
-	.get_value = dal_hw_gpio_get_value,
-	.set_value = dal_hw_gpio_set_value,
-	.set_config = set_config,
-	.change_mode = dal_hw_gpio_change_mode,
-	.close = dal_hw_gpio_close,
-};
-
 void define_ddc_dce110_registers(
 		struct hw_gpio_pin *pin,
 		uint32_t en)
@@ -293,45 +97,3 @@ void define_ddc_dce110_registers(
 
 }
 
-static bool construct(
-	struct hw_ddc *ddc,
-	enum gpio_id id,
-	uint32_t en,
-	struct dc_context *ctx)
-{
-	if ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	if (!dal_hw_gpio_construct(&ddc->base, id, en, ctx)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	ddc->base.base.funcs = &funcs;
-
-	return true;
-}
-
-struct hw_gpio_pin *dal_hw_ddc_dce110_create(
-	struct dc_context *ctx,
-	enum gpio_id id,
-	uint32_t en)
-{
-	struct hw_ddc *pin = dm_alloc(sizeof(struct hw_ddc));
-
-	if (!pin) {
-		ASSERT_CRITICAL(false);
-		return NULL;
-	}
-
-	if (construct(pin, id, en, ctx))
-		return &pin->base.base;
-
-	ASSERT_CRITICAL(false);
-
-	dm_free(pin);
-
-	return NULL;
-}
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h
index 2206b7e..ecad81e 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_ddc_dce110.h
@@ -26,11 +26,6 @@
 #ifndef __DAL_HW_DDC_DCE110_H__
 #define __DAL_HW_DDC_DCE110_H__
 
-struct hw_gpio_pin *dal_hw_ddc_dce110_create(
-	struct dc_context *ctx,
-	enum gpio_id id,
-	uint32_t en);
-
 void define_ddc_dce110_registers(
 		struct hw_gpio_pin *pin,
 		uint32_t en);
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c
index 6e504ff..3188570 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce110/hw_factory_dce110.c
@@ -79,8 +79,8 @@ static void define_hpd_registers(struct hw_gpio_pin *pin, uint32_t en)
 }
 
 static const struct hw_factory_funcs funcs = {
-	.create_ddc_data = dal_hw_ddc_dce110_create,
-	.create_ddc_clock = dal_hw_ddc_dce110_create,
+	.create_ddc_data = dal_hw_ddc_create,
+	.create_ddc_clock = dal_hw_ddc_create,
 	.create_generic = NULL,
 	.create_hpd = dal_hw_hpd_create,
 	.create_sync = NULL,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
index cecd665..04878ed 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.c
@@ -42,15 +42,6 @@
 #define SF(reg_name, field_name, post_fix)\
 	.field_name = reg_name ## __ ## field_name ## post_fix
 
-#undef FN
-#define FN(reg_name, field_name) \
-	ddc->shifts->field_name, ddc->masks->field_name
-
-#define CTX \
-	ddc->base.base.ctx
-#define REG(reg)\
-	(ddc->regs->reg)
-
 static const struct ddc_registers ddc_data_regs[] = {
 	ddc_data_regs(1),
 	ddc_data_regs(2),
@@ -81,192 +72,6 @@ static const struct ddc_sh_mask ddc_mask = {
 		DDC_MASK_SH_LIST(_MASK)
 };
 
-static void destruct(
-	struct hw_ddc *pin)
-{
-	dal_hw_gpio_destruct(&pin->base);
-}
-
-static void destroy(
-	struct hw_gpio_pin **ptr)
-{
-	struct hw_ddc *pin = HW_DDC_FROM_BASE(*ptr);
-
-	destruct(pin);
-
-	dm_free(pin);
-
-	*ptr = NULL;
-}
-
-static enum gpio_result set_config(
-	struct hw_gpio_pin *ptr,
-	const struct gpio_config_data *config_data)
-{
-	struct hw_ddc *ddc = HW_DDC_FROM_BASE(ptr);
-	struct hw_gpio *hw_gpio = NULL;
-	uint32_t addr;
-	uint32_t regval;
-	uint32_t ddc_data_pd_en = 0;
-	uint32_t ddc_clk_pd_en = 0;
-	uint32_t aux_pad_mode = 0;
-
-	hw_gpio = &ddc->base;
-
-	if (hw_gpio == NULL) {
-		ASSERT_CRITICAL(false);
-		return GPIO_RESULT_NULL_HANDLE;
-	}
-
-	/* switch dual mode GPIO to I2C/AUX mode */
-	addr = ddc->base.regs->MASK_reg;
-
-	regval = REG_READ(gpio.MASK_reg);
-
-	ddc_data_pd_en = get_reg_field_value_ex(
-			regval,
-			FN(,DC_GPIO_DDC1DATA_PD_EN));
-
-	ddc_clk_pd_en = get_reg_field_value_ex(
-			regval,
-			FN(,DC_GPIO_DDC1CLK_PD_EN));
-
-	aux_pad_mode = get_reg_field_value_ex(
-			regval,
-			FN(,AUX_PAD1_MODE));
-
-	switch (config_data->config.ddc.type) {
-	case GPIO_DDC_CONFIG_TYPE_MODE_I2C:
-		/* On plug-in, there is a transient level on the pad
-		 * which must be discharged through the internal pull-down.
-		 * Enable internal pull-down, 2.5msec discharge time
-		 * is required for detection of AUX mode */
-		if (hw_gpio->base.en != GPIO_DDC_LINE_VIP_PAD) {
-			if (!ddc_data_pd_en || !ddc_clk_pd_en) {
-				set_reg_field_value_ex(
-					regval,
-					1,
-					FN(,DC_GPIO_DDC1DATA_PD_EN));
-
-				set_reg_field_value_ex(
-					regval,
-					1,
-					FN(,DC_GPIO_DDC1CLK_PD_EN));
-
-				REG_WRITE(gpio.MASK_reg, regval);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-		} else {
-			uint32_t reg2 = regval;
-			uint32_t sda_pd_dis = 0;
-			uint32_t scl_pd_dis = 0;
-
-			sda_pd_dis = get_reg_field_value_ex(
-					reg2,
-					FN(,DC_GPIO_SDA_PD_DIS));
-
-			scl_pd_dis = get_reg_field_value_ex(
-					reg2,
-					FN(,DC_GPIO_SCL_PD_DIS));
-
-			if (sda_pd_dis)
-				sda_pd_dis = 0;
-
-			if (!scl_pd_dis)
-				scl_pd_dis = 1;
-
-			if (sda_pd_dis || !scl_pd_dis) {
-				REG_WRITE(gpio.MASK_reg, reg2);
-
-				if (config_data->type ==
-					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
-					/* should not affect normal I2C R/W */
-					/* [anaumov] in DAL2, there was
-					 * dc_service_delay_in_microseconds(2500); */
-					msleep(3);
-			}
-		}
-
-		if (aux_pad_mode) {
-			/* let pins to get de-asserted
-			 * before setting pad to I2C mode */
-			if (config_data->config.ddc.data_en_bit_present ||
-				config_data->config.ddc.clock_en_bit_present)
-				/* [anaumov] in DAL2, there was
-				 * dc_service_delay_in_microseconds(2000); */
-				msleep(2);
-
-			/* set the I2C pad mode */
-			/* read the register again,
-			 * some bits may have been changed */
-			REG_UPDATE(gpio.MASK_reg, AUX_PAD1_MODE, 1);
-		}
-
-		return GPIO_RESULT_OK;
-	case GPIO_DDC_CONFIG_TYPE_MODE_AUX:
-		/* set the AUX pad mode */
-		if (!aux_pad_mode) {
-			set_reg_field_value_ex(
-				regval,
-				1,
-				FN(,AUX_PAD1_MODE));
-
-			REG_WRITE(gpio.MASK_reg, regval);
-		}
-
-		return GPIO_RESULT_OK;
-	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_CONNECT:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			REG_UPDATE_3(ddc_setup,
-				DC_I2C_DDC1_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_MODE, 0);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_DISCONNECT:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			REG_UPDATE_3(ddc_setup,
-				DC_I2C_DDC1_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_ENABLE, 1,
-				DC_I2C_DDC1_EDID_DETECT_MODE, 1);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	case GPIO_DDC_CONFIG_TYPE_DISABLE_POLLING:
-		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
-			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
-			REG_UPDATE_2(ddc_setup,
-				DC_I2C_DDC1_ENABLE, 0,
-				DC_I2C_DDC1_EDID_DETECT_ENABLE, 0);
-			return GPIO_RESULT_OK;
-		}
-	break;
-	}
-
-	BREAK_TO_DEBUGGER();
-
-	return GPIO_RESULT_NON_SPECIFIC_ERROR;
-}
-
-static const struct hw_gpio_pin_funcs funcs = {
-	.destroy = destroy,
-	.open = dal_hw_gpio_open,
-	.get_value = dal_hw_gpio_get_value,
-	.set_value = dal_hw_gpio_set_value,
-	.set_config = set_config,
-	.change_mode = dal_hw_gpio_change_mode,
-	.close = dal_hw_gpio_close,
-};
-
 void define_ddc_dce80_registers(
 		struct hw_gpio_pin *pin,
 		uint32_t en)
@@ -291,46 +96,3 @@ void define_ddc_dce80_registers(
 	ddc->masks = &ddc_mask;
 
 }
-
-static bool construct(
-	struct hw_ddc *ddc,
-	enum gpio_id id,
-	uint32_t en,
-	struct dc_context *ctx)
-{
-	if ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	if (!dal_hw_gpio_construct(&ddc->base, id, en, ctx)) {
-		ASSERT_CRITICAL(false);
-		return false;
-	}
-
-	ddc->base.base.funcs = &funcs;
-
-	return true;
-}
-
-struct hw_gpio_pin *dal_hw_ddc_dce80_create(
-	struct dc_context *ctx,
-	enum gpio_id id,
-	uint32_t en)
-{
-	struct hw_ddc *pin = dm_alloc(sizeof(struct hw_ddc));
-
-	if (!pin) {
-		ASSERT_CRITICAL(false);
-		return NULL;
-	}
-
-	if (construct(pin, id, en, ctx))
-		return &pin->base.base;
-
-	ASSERT_CRITICAL(false);
-
-	dm_free(pin);
-
-	return NULL;
-}
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h
index cd907ae..df3eee6 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_ddc_dce80.h
@@ -26,11 +26,6 @@
 #ifndef __DAL_HW_DDC_DCE80_H__
 #define __DAL_HW_DDC_DCE80_H__
 
-struct hw_gpio_pin *dal_hw_ddc_dce80_create(
-	struct dc_context *ctx,
-	enum gpio_id id,
-	uint32_t en);
-
 void define_ddc_dce80_registers(
 		struct hw_gpio_pin *pin,
 		uint32_t en);
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_factory_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_factory_dce80.c
index a007a0a..3dd1bb5 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_factory_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/dce80/hw_factory_dce80.c
@@ -84,8 +84,8 @@ static void define_hpd_registers(struct hw_gpio_pin *pin, uint32_t en)
 }
 
 static const struct hw_factory_funcs funcs = {
-	.create_ddc_data = dal_hw_ddc_dce80_create,
-	.create_ddc_clock = dal_hw_ddc_dce80_create,
+	.create_ddc_data = dal_hw_ddc_create,
+	.create_ddc_clock = dal_hw_ddc_create,
 	.create_generic = NULL,
 	.create_hpd = dal_hw_hpd_create,
 	.create_sync = NULL,
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c b/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c
new file mode 100644
index 0000000..3f54cd9
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+
+#include "include/gpio_types.h"
+#include "hw_gpio.h"
+#include "hw_ddc.h"
+
+#include "reg_helper.h"
+#include "gpio_regs.h"
+
+
+#undef FN
+#define FN(reg_name, field_name) \
+	ddc->shifts->field_name, ddc->masks->field_name
+
+#define CTX \
+	ddc->base.base.ctx
+#define REG(reg)\
+	(ddc->regs->reg)
+
+static void destruct(
+	struct hw_ddc *pin)
+{
+	dal_hw_gpio_destruct(&pin->base);
+}
+
+static void destroy(
+	struct hw_gpio_pin **ptr)
+{
+	struct hw_ddc *pin = HW_DDC_FROM_BASE(*ptr);
+
+	destruct(pin);
+
+	dm_free(pin);
+
+	*ptr = NULL;
+}
+
+static enum gpio_result set_config(
+	struct hw_gpio_pin *ptr,
+	const struct gpio_config_data *config_data)
+{
+	struct hw_ddc *ddc = HW_DDC_FROM_BASE(ptr);
+	struct hw_gpio *hw_gpio = NULL;
+	uint32_t addr;
+	uint32_t regval;
+	uint32_t ddc_data_pd_en = 0;
+	uint32_t ddc_clk_pd_en = 0;
+	uint32_t aux_pad_mode = 0;
+
+	hw_gpio = &ddc->base;
+
+	if (hw_gpio == NULL) {
+		ASSERT_CRITICAL(false);
+		return GPIO_RESULT_NULL_HANDLE;
+	}
+
+	/* switch dual mode GPIO to I2C/AUX mode */
+	addr = ddc->base.regs->MASK_reg;
+
+	regval = REG_READ(gpio.MASK_reg);
+
+	ddc_data_pd_en = get_reg_field_value_ex(
+			regval,
+			FN(,DC_GPIO_DDC1DATA_PD_EN));
+
+	ddc_clk_pd_en = get_reg_field_value_ex(
+			regval,
+			FN(,DC_GPIO_DDC1CLK_PD_EN));
+
+	aux_pad_mode = get_reg_field_value_ex(
+			regval,
+			FN(,AUX_PAD1_MODE));
+
+	switch (config_data->config.ddc.type) {
+	case GPIO_DDC_CONFIG_TYPE_MODE_I2C:
+		/* On plug-in, there is a transient level on the pad
+		 * which must be discharged through the internal pull-down.
+		 * Enable internal pull-down, 2.5msec discharge time
+		 * is required for detection of AUX mode */
+		if (hw_gpio->base.en != GPIO_DDC_LINE_VIP_PAD) {
+			if (!ddc_data_pd_en || !ddc_clk_pd_en) {
+				set_reg_field_value_ex(
+					regval,
+					1,
+					FN(,DC_GPIO_DDC1DATA_PD_EN));
+
+				set_reg_field_value_ex(
+					regval,
+					1,
+					FN(,DC_GPIO_DDC1CLK_PD_EN));
+
+				REG_WRITE(gpio.MASK_reg, regval);
+
+				if (config_data->type ==
+					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
+					/* should not affect normal I2C R/W */
+					/* [anaumov] in DAL2, there was
+					 * dc_service_delay_in_microseconds(2500); */
+					msleep(3);
+			}
+		} else {
+			uint32_t reg2 = regval;
+			uint32_t sda_pd_dis = 0;
+			uint32_t scl_pd_dis = 0;
+
+			sda_pd_dis = get_reg_field_value_ex(
+					reg2,
+					FN(,DC_GPIO_SDA_PD_DIS));
+
+			scl_pd_dis = get_reg_field_value_ex(
+					reg2,
+					FN(,DC_GPIO_SCL_PD_DIS));
+
+			if (sda_pd_dis)
+				sda_pd_dis = 0;
+
+			if (!scl_pd_dis)
+				scl_pd_dis = 1;
+
+			if (sda_pd_dis || !scl_pd_dis) {
+				REG_WRITE(gpio.MASK_reg, reg2);
+
+				if (config_data->type ==
+					GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE)
+					/* should not affect normal I2C R/W */
+					/* [anaumov] in DAL2, there was
+					 * dc_service_delay_in_microseconds(2500); */
+					msleep(3);
+			}
+		}
+
+		if (aux_pad_mode) {
+			/* let pins to get de-asserted
+			 * before setting pad to I2C mode */
+			if (config_data->config.ddc.data_en_bit_present ||
+				config_data->config.ddc.clock_en_bit_present)
+				/* [anaumov] in DAL2, there was
+				 * dc_service_delay_in_microseconds(2000); */
+				msleep(2);
+
+			/* set the I2C pad mode */
+			/* read the register again,
+			 * some bits may have been changed */
+			REG_UPDATE(gpio.MASK_reg, AUX_PAD1_MODE, 1);
+		}
+
+		return GPIO_RESULT_OK;
+	case GPIO_DDC_CONFIG_TYPE_MODE_AUX:
+		/* set the AUX pad mode */
+		if (!aux_pad_mode) {
+			set_reg_field_value_ex(
+				regval,
+				1,
+				FN(,AUX_PAD1_MODE));
+
+			REG_WRITE(gpio.MASK_reg, regval);
+		}
+
+		return GPIO_RESULT_OK;
+	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_CONNECT:
+		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
+			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
+			REG_UPDATE_3(ddc_setup,
+				DC_I2C_DDC1_ENABLE, 1,
+				DC_I2C_DDC1_EDID_DETECT_ENABLE, 1,
+				DC_I2C_DDC1_EDID_DETECT_MODE, 0);
+			return GPIO_RESULT_OK;
+		}
+	break;
+	case GPIO_DDC_CONFIG_TYPE_POLL_FOR_DISCONNECT:
+		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
+			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
+			REG_UPDATE_3(ddc_setup,
+				DC_I2C_DDC1_ENABLE, 1,
+				DC_I2C_DDC1_EDID_DETECT_ENABLE, 1,
+				DC_I2C_DDC1_EDID_DETECT_MODE, 1);
+			return GPIO_RESULT_OK;
+		}
+	break;
+	case GPIO_DDC_CONFIG_TYPE_DISABLE_POLLING:
+		if ((hw_gpio->base.en >= GPIO_DDC_LINE_DDC1) &&
+			(hw_gpio->base.en <= GPIO_DDC_LINE_DDC_VGA)) {
+			REG_UPDATE_2(ddc_setup,
+				DC_I2C_DDC1_ENABLE, 0,
+				DC_I2C_DDC1_EDID_DETECT_ENABLE, 0);
+			return GPIO_RESULT_OK;
+		}
+	break;
+	}
+
+	BREAK_TO_DEBUGGER();
+
+	return GPIO_RESULT_NON_SPECIFIC_ERROR;
+}
+
+static const struct hw_gpio_pin_funcs funcs = {
+	.destroy = destroy,
+	.open = dal_hw_gpio_open,
+	.get_value = dal_hw_gpio_get_value,
+	.set_value = dal_hw_gpio_set_value,
+	.set_config = set_config,
+	.change_mode = dal_hw_gpio_change_mode,
+	.close = dal_hw_gpio_close,
+};
+
+static bool construct(
+	struct hw_ddc *ddc,
+	enum gpio_id id,
+	uint32_t en,
+	struct dc_context *ctx)
+{
+	if ((en < GPIO_DDC_LINE_MIN) || (en > GPIO_DDC_LINE_MAX)) {
+		ASSERT_CRITICAL(false);
+		return false;
+	}
+
+	if (!dal_hw_gpio_construct(&ddc->base, id, en, ctx)) {
+		ASSERT_CRITICAL(false);
+		return false;
+	}
+
+	ddc->base.base.funcs = &funcs;
+
+	return true;
+}
+
+struct hw_gpio_pin *dal_hw_ddc_create(
+	struct dc_context *ctx,
+	enum gpio_id id,
+	uint32_t en)
+{
+	struct hw_ddc *pin = dm_alloc(sizeof(struct hw_ddc));
+
+	if (!pin) {
+		ASSERT_CRITICAL(false);
+		return NULL;
+	}
+
+	if (construct(pin, id, en, ctx))
+		return &pin->base.base;
+
+	ASSERT_CRITICAL(false);
+
+	dm_free(pin);
+
+	return NULL;
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.h b/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.h
index e522900..9690e2a 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.h
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/hw_ddc.h
@@ -38,4 +38,9 @@ struct hw_ddc {
 #define HW_DDC_FROM_BASE(hw_gpio) \
 	container_of((HW_GPIO_FROM_BASE(hw_gpio)), struct hw_ddc, base)
 
+struct hw_gpio_pin *dal_hw_ddc_create(
+	struct dc_context *ctx,
+	enum gpio_id id,
+	uint32_t en);
+
 #endif
-- 
2.7.4

