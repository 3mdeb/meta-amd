From 8797fbb14185139017d41e5a60f1ef96642a9698 Mon Sep 17 00:00:00 2001
From: Tony Cheng <tony.cheng@amd.com>
Date: Fri, 16 Sep 2016 20:29:58 -0400
Subject: [PATCH 1097/1722] drm/amd/dal: common register access helper

- refactor audio, stream_encoder

Change-Id: Icc0f9d378c75fcaf3ac378d89ecb92acea62dc74
Signed-off-by: Tony Cheng <tony.cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c   |  48 ++-----
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  | 143 +++++++++------------
 drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h        | 143 +++++++++++++++++++++
 3 files changed, 217 insertions(+), 117 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h

diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
index db550ad..007533e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
@@ -32,47 +32,23 @@
 #define DCE110_AUD(audio)\
 	container_of(audio, struct audio_dce110, base)
 
+
 #define CTX \
 	aud110->base.ctx
-
 #define REG(reg)\
 	(aud110->regs->reg)
+#include "reg_helper.h"
+
 
 #define IX_REG(reg)\
 	ix ## reg
 
-
-#define REG_READ(reg_name) \
-		dm_read_reg(CTX, REG(reg_name))
-
-#define REG_WRITE(reg_name, value) \
-		dm_write_reg(CTX, REG(reg_name), value)
-
-#define REG_SET_N(reg_name, n, ...)	\
-		generic_reg_update_ex(CTX, \
-				REG(reg_name), \
-				0, \
-				n, __VA_ARGS__)
-
-#define REG_SET(reg_name, field, val)	\
-		REG_SET_N(reg_name, 1, FD(reg_name##__##field), val)
-
-#define REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_ex(CTX, \
-				REG(reg_name), \
-				REG_READ(reg_name), \
-				n, __VA_ARGS__)
-
-#define REG_UPDATE(reg_name, field, val)	\
-		REG_UPDATE_N(reg_name, 1, FD(reg_name##__##field), val)
-
 #define AZ_REG_READ(reg_name) \
 		read_indirect_azalia_reg(audio, IX_REG(reg_name))
 
 #define AZ_REG_WRITE(reg_name, value) \
 		write_indirect_azalia_reg(audio, IX_REG(reg_name), value)
 
-
 static void write_indirect_azalia_reg(struct audio *audio,
 	uint32_t reg_index,
 	uint32_t reg_data)
@@ -815,9 +791,9 @@ void dce110_aud_wall_dto_setup(
 		HDMI enabled, using DTO0
 		program master CRTC for DTO0 */
 		src_sel = pll_info->dto_source - DTO_SOURCE_ID0;
-		REG_UPDATE_N(DCCG_AUDIO_DTO_SOURCE, 2,
-			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO0_SOURCE_SEL), src_sel,
-			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO_SEL), 0);
+		REG_UPDATE_2(DCCG_AUDIO_DTO_SOURCE,
+			DCCG_AUDIO_DTO0_SOURCE_SEL, src_sel,
+			DCCG_AUDIO_DTO_SEL, 0);
 
 		/* module */
 		REG_UPDATE(DCCG_AUDIO_DTO0_MODULE,
@@ -845,9 +821,9 @@ void dce110_aud_wall_dto_setup(
 		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
 				DCCG_AUDIO_DTO_SEL, 1);
 
-		REG_UPDATE_N(DCCG_AUDIO_DTO_SOURCE, 1,
-			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO_SEL), 1);
-			/* FD(DCCG_AUDIO_DTO2_USE_512FBR_DTO), 1)
+		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+			DCCG_AUDIO_DTO_SEL, 1);
+			/* DCCG_AUDIO_DTO2_USE_512FBR_DTO, 1)
 			 * Select 512fs for DP TODO: web register definition
 			 * does not match register header file
 			 * DCE11 version it's commented out while DCE8 it's set to 1
@@ -888,9 +864,9 @@ void dce110_aud_hw_init(
 			AUDIO_RATE_CAPABILITIES, 0x70);
 
 	/*Keep alive bit to verify HW block in BU. */
-	REG_UPDATE_N(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES, 2,
-			FD(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES__CLKSTOP), 1,
-			FD(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES__EPSS), 1);
+	REG_UPDATE_2(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
+			CLKSTOP, 1,
+			EPSS, 1);
 }
 
 static const struct audio_funcs funcs = {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index 6bfe2d4..12c0235 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -31,6 +31,20 @@
 #include "dce/dce_11_0_sh_mask.h"
 #include "dce/dce_11_0_enum.h"
 
+#include "include/audio_types.h"
+
+
+#define CTX \
+		enc110->base.ctx
+#define REG(reg)\
+		LINK_REG(reg)
+#include "reg_helper.h"
+
+
+#define DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT 0x8000
+#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC 1
+
+
 #define LINK_REG(reg)\
 	(enc110->regs->reg)
 
@@ -1069,39 +1083,6 @@ static void dce110_stream_encoder_dp_unblank(
 	dm_write_reg(ctx, addr, value);
 }
 
-#define LINK_REG_READ(reg_name) \
-		dm_read_reg(enc110->base.ctx, LINK_REG(reg_name))
-
-#define LINK_REG_WRITE(reg_name, value) \
-		dm_write_reg(enc110->base.ctx, LINK_REG(reg_name), value)
-
-#define LINK_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_update_ex(enc110->base.ctx, \
-				LINK_REG(reg_name), \
-				0, \
-				n, __VA_ARGS__)
-
-#define LINK_REG_SET(reg_name, field, val)	\
-		LINK_REG_SET_N(reg_name, 1, FD(reg_name##__##field), val)
-
-#define LINK_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_ex(enc110->base.ctx, \
-				LINK_REG(reg_name), \
-				LINK_REG_READ(reg_name), \
-				n, __VA_ARGS__)
-
-#define LINK_REG_UPDATE(reg_name, field, val)	\
-		LINK_REG_UPDATE_N(reg_name, 1, FD(reg_name##__##field), val)
-
-#define LINK_REG_WAIT(reg_name, field, val, delay, max_try)	\
-		generic_reg_wait(enc110->base.ctx, \
-				LINK_REG(reg_name), FD(reg_name##__##field), val,\
-				delay, max_try)
-
-#define DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT 0x8000
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC 1
-
-#include "include/audio_types.h"
 
 /**
 * speakersToChannels
@@ -1399,10 +1380,10 @@ static void dce110_se_audio_setup(
 	channels = speakers_to_channels(audio_info->flags.speaker_flags).all;
 
 	/* setup the audio stream source select (audio -> dig mapping) */
-	LINK_REG_SET(AFMT_AUDIO_SRC_CONTROL, AFMT_AUDIO_SRC_SELECT, az_inst);
+	REG_SET(AFMT_AUDIO_SRC_CONTROL, AFMT_AUDIO_SRC_SELECT, az_inst);
 
 	/* Channel allocation */
-	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL2, AFMT_AUDIO_CHANNEL_ENABLE, channels);
+	REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL2, AFMT_AUDIO_CHANNEL_ENABLE, channels);
 }
 
 static void dce110_se_setup_hdmi_audio(
@@ -1421,23 +1402,23 @@ static void dce110_se_setup_hdmi_audio(
 	max_packets_per_line = calc_max_audio_packets_per_line(crtc_info);
 
 	/* HDMI_AUDIO_PACKET_CONTROL */
-	LINK_REG_UPDATE_N(HDMI_AUDIO_PACKET_CONTROL, 2,
-			FD(HDMI_AUDIO_PACKET_CONTROL__HDMI_AUDIO_PACKETS_PER_LINE), max_packets_per_line,
-			FD(HDMI_AUDIO_PACKET_CONTROL__HDMI_AUDIO_DELAY_EN), 1);
+	REG_UPDATE_2(HDMI_AUDIO_PACKET_CONTROL,
+			HDMI_AUDIO_PACKETS_PER_LINE, max_packets_per_line,
+			HDMI_AUDIO_DELAY_EN, 1);
 
 	/* AFMT_AUDIO_PACKET_CONTROL */
-	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);
+	REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);
 
 	/* AFMT_AUDIO_PACKET_CONTROL2 */
-	LINK_REG_UPDATE_N(AFMT_AUDIO_PACKET_CONTROL2, 2,
-			FD(AFMT_AUDIO_PACKET_CONTROL2__AFMT_AUDIO_LAYOUT_OVRD), 0,
-			FD(AFMT_AUDIO_PACKET_CONTROL2__AFMT_60958_OSF_OVRD), 0);
+	REG_UPDATE_2(AFMT_AUDIO_PACKET_CONTROL2,
+			AFMT_AUDIO_LAYOUT_OVRD, 0,
+			AFMT_60958_OSF_OVRD, 0);
 
 	/* HDMI_ACR_PACKET_CONTROL */
-	LINK_REG_UPDATE_N(HDMI_ACR_PACKET_CONTROL, 3,
-			FD(HDMI_ACR_PACKET_CONTROL__HDMI_ACR_AUTO_SEND), 1,
-			FD(HDMI_ACR_PACKET_CONTROL__HDMI_ACR_SOURCE), 0,
-			FD(HDMI_ACR_PACKET_CONTROL__HDMI_ACR_AUDIO_PRIORITY), 0);
+	REG_UPDATE_3(HDMI_ACR_PACKET_CONTROL,
+			HDMI_ACR_AUTO_SEND, 1,
+			HDMI_ACR_SOURCE, 0,
+			HDMI_ACR_AUDIO_PRIORITY, 0);
 
 	/* Program audio clock sample/regeneration parameters */
 	if (get_audio_clock_info(
@@ -1447,22 +1428,22 @@ static void dce110_se_setup_hdmi_audio(
 		&audio_clock_info)) {
 
 		/* HDMI_ACR_32_0__HDMI_ACR_CTS_32_MASK */
-		LINK_REG_UPDATE(HDMI_ACR_32_0, HDMI_ACR_CTS_32, audio_clock_info.cts_32khz);
+		REG_UPDATE(HDMI_ACR_32_0, HDMI_ACR_CTS_32, audio_clock_info.cts_32khz);
 
 		/* HDMI_ACR_32_1__HDMI_ACR_N_32_MASK */
-		LINK_REG_UPDATE(HDMI_ACR_32_1, HDMI_ACR_N_32, audio_clock_info.n_32khz);
+		REG_UPDATE(HDMI_ACR_32_1, HDMI_ACR_N_32, audio_clock_info.n_32khz);
 
 		/* HDMI_ACR_44_0__HDMI_ACR_CTS_44_MASK */
-		LINK_REG_UPDATE(HDMI_ACR_44_0, HDMI_ACR_CTS_44, audio_clock_info.cts_44khz);
+		REG_UPDATE(HDMI_ACR_44_0, HDMI_ACR_CTS_44, audio_clock_info.cts_44khz);
 
 		/* HDMI_ACR_44_1__HDMI_ACR_N_44_MASK */
-		LINK_REG_UPDATE(HDMI_ACR_44_1, HDMI_ACR_N_44, audio_clock_info.n_44khz);
+		REG_UPDATE(HDMI_ACR_44_1, HDMI_ACR_N_44, audio_clock_info.n_44khz);
 
 		/* HDMI_ACR_48_0__HDMI_ACR_CTS_48_MASK */
-		LINK_REG_UPDATE(HDMI_ACR_48_0, HDMI_ACR_CTS_48, audio_clock_info.cts_48khz);
+		REG_UPDATE(HDMI_ACR_48_0, HDMI_ACR_CTS_48, audio_clock_info.cts_48khz);
 
 		/* HDMI_ACR_48_1__HDMI_ACR_N_48_MASK */
-		LINK_REG_UPDATE(HDMI_ACR_48_1, HDMI_ACR_N_48, audio_clock_info.n_48khz);
+		REG_UPDATE(HDMI_ACR_48_1, HDMI_ACR_N_48, audio_clock_info.n_48khz);
 
 		/* Video driver cannot know in advance which sample rate will
 		be used by HD Audio driver
@@ -1472,22 +1453,22 @@ static void dce110_se_setup_hdmi_audio(
 
 	/* AFMT_60958_0__AFMT_60958_CS_CHANNEL_NUMBER_L_MASK &
 	AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY_MASK */
-	LINK_REG_UPDATE_N(AFMT_60958_0, 2,
-			FD(AFMT_60958_0__AFMT_60958_CS_CHANNEL_NUMBER_L), 1,
-			FD(AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY), 0);
+	REG_UPDATE_2(AFMT_60958_0,
+			AFMT_60958_CS_CHANNEL_NUMBER_L, 1,
+			AFMT_60958_CS_CLOCK_ACCURACY, 0);
 
 	/* AFMT_60958_1 AFMT_60958_CS_CHALNNEL_NUMBER_R */
-	LINK_REG_UPDATE(AFMT_60958_1, AFMT_60958_CS_CHANNEL_NUMBER_R, 2);
+	REG_UPDATE(AFMT_60958_1, AFMT_60958_CS_CHANNEL_NUMBER_R, 2);
 
 	/*AFMT_60958_2 now keep this settings until
 	 *  Programming guide comes out*/
-	LINK_REG_UPDATE_N(AFMT_60958_2, 6,
-			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_2), 3,
-			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_3), 4,
-			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_4), 5,
-			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_5), 6,
-			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_6), 7,
-			FD(AFMT_60958_2__AFMT_60958_CS_CHANNEL_NUMBER_7), 8);
+	REG_UPDATE_6(AFMT_60958_2,
+			AFMT_60958_CS_CHANNEL_NUMBER_2, 3,
+			AFMT_60958_CS_CHANNEL_NUMBER_3, 4,
+			AFMT_60958_CS_CHANNEL_NUMBER_4, 5,
+			AFMT_60958_CS_CHANNEL_NUMBER_5, 6,
+			AFMT_60958_CS_CHANNEL_NUMBER_6, 7,
+			AFMT_60958_CS_CHANNEL_NUMBER_7, 8);
 }
 
 static void dce110_se_setup_dp_audio(
@@ -1500,29 +1481,29 @@ static void dce110_se_setup_dp_audio(
 	uint32_t value = 0;
 
 	/* ATP Configuration */
-	LINK_REG_SET(DP_SEC_AUD_N, DP_SEC_AUD_N, DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT);
+	REG_SET(DP_SEC_AUD_N, DP_SEC_AUD_N, DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT);
 
 	/* Async/auto-calc timestamp mode */
-	LINK_REG_SET(DP_SEC_TIMESTAMP, DP_SEC_TIMESTAMP_MODE,
+	REG_SET(DP_SEC_TIMESTAMP, DP_SEC_TIMESTAMP_MODE,
 			DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC);
 
 	/* --- The following are the registers
 	 *  copied from the SetupHDMI --- */
 
 	/* AFMT_AUDIO_PACKET_CONTROL */
-	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);
+	REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_60958_CS_UPDATE, 1);
 
 	/* AFMT_AUDIO_PACKET_CONTROL2 */
 	/* Program the ATP and AIP next */
-	LINK_REG_UPDATE_N(AFMT_AUDIO_PACKET_CONTROL2, 2,
-			FD(AFMT_AUDIO_PACKET_CONTROL2__AFMT_AUDIO_LAYOUT_OVRD), 0,
-			FD(AFMT_AUDIO_PACKET_CONTROL2__AFMT_60958_OSF_OVRD), 0);
+	REG_UPDATE_2(AFMT_AUDIO_PACKET_CONTROL2,
+			AFMT_AUDIO_LAYOUT_OVRD, 0,
+			AFMT_60958_OSF_OVRD, 0);
 
 	/* AFMT_INFOFRAME_CONTROL0 */
-	LINK_REG_UPDATE(AFMT_INFOFRAME_CONTROL0, AFMT_AUDIO_INFO_UPDATE, 1);
+	REG_UPDATE(AFMT_INFOFRAME_CONTROL0, AFMT_AUDIO_INFO_UPDATE, 1);
 
 	/* AFMT_60958_0__AFMT_60958_CS_CLOCK_ACCURACY_MASK */
-	LINK_REG_UPDATE(AFMT_60958_0, AFMT_60958_CS_CLOCK_ACCURACY, 0);
+	REG_UPDATE(AFMT_60958_0, AFMT_60958_CS_CLOCK_ACCURACY, 0);
 }
 
 static void dce110_se_enable_audio_clock(
@@ -1534,12 +1515,12 @@ static void dce110_se_enable_audio_clock(
 	if (LINK_REG(AFMT_CNTL) == 0)
 		return;   /* DCE8/10 does not have this register */
 
-	LINK_REG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, !!enable);
+	REG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, !!enable);
 
 	/* wait for AFMT clock to turn on,
 	 * expectation: this should complete in 1-2 reads
 	 */
-	LINK_REG_WAIT(AFMT_CNTL, AFMT_AUDIO_CLOCK_ON, !!enable,
+	REG_WAIT(AFMT_CNTL, AFMT_AUDIO_CLOCK_ON, !!enable,
 			1, 10);
 }
 
@@ -1549,15 +1530,15 @@ static void dce110_se_enable_dp_audio(
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 
 	/* Enable Audio packets */
-	LINK_REG_UPDATE(DP_SEC_CNTL, DP_SEC_ASP_ENABLE, 1);
+	REG_UPDATE(DP_SEC_CNTL, DP_SEC_ASP_ENABLE, 1);
 
 	/* Program the ATP and AIP next */
-	LINK_REG_UPDATE_N(DP_SEC_CNTL, 2,
-			FD(DP_SEC_CNTL__DP_SEC_ATP_ENABLE), 1,
-			FD(DP_SEC_CNTL__DP_SEC_AIP_ENABLE), 1);
+	REG_UPDATE_2(DP_SEC_CNTL,
+			DP_SEC_ATP_ENABLE, 1,
+			DP_SEC_AIP_ENABLE, 1);
 
 	/* Program STREAM_ENABLE after all the other enables. */
-	LINK_REG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);
+	REG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);
 }
 
 static void dce110_se_disable_dp_audio(
@@ -1565,7 +1546,7 @@ static void dce110_se_disable_dp_audio(
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 
-	uint32_t value = LINK_REG_READ(DP_SEC_CNTL);
+	uint32_t value = REG_READ(DP_SEC_CNTL);
 
 	/* Disable Audio packets */
 	set_reg_field_value(value, 0,
@@ -1589,7 +1570,7 @@ static void dce110_se_disable_dp_audio(
 		set_reg_field_value(value, 1,
 			DP_SEC_CNTL, DP_SEC_STREAM_ENABLE);
 
-	LINK_REG_WRITE(DP_SEC_CNTL, value);
+	REG_WRITE(DP_SEC_CNTL, value);
 }
 
 void dce110_se_audio_mute_control(
@@ -1598,7 +1579,7 @@ void dce110_se_audio_mute_control(
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 
-	LINK_REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_AUDIO_SAMPLE_SEND, !mute);
+	REG_UPDATE(AFMT_AUDIO_PACKET_CONTROL, AFMT_AUDIO_SAMPLE_SEND, !mute);
 }
 
 void dce110_se_dp_audio_setup(
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h b/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h
new file mode 100644
index 0000000..e1fcaae
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/inc/reg_helper.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ */
+
+#ifndef DRIVERS_GPU_DRM_AMD_DAL_DEV_DC_INC_REG_HELPER_H_
+#define DRIVERS_GPU_DRM_AMD_DAL_DEV_DC_INC_REG_HELPER_H_
+
+/* macro for register read/write
+ * user of macro need to define
+ *
+ * CTX ==> macro to ptr to dc_context
+ *    eg. aud110->base.ctx
+ *
+ * REG ==> macro to location of register offset
+ *    eg. aud110->regs->reg
+ */
+#define REG_READ(reg_name) \
+		dm_read_reg(CTX, REG(reg_name))
+
+#define REG_WRITE(reg_name, value) \
+		dm_write_reg(CTX, REG(reg_name), value)
+
+
+/* macro to set register fields.
+ * note: assume initial value of register is 0.  be careful about that assumption
+ */
+#define REG_SET_N(reg_name, n, ...)	\
+		generic_reg_update_ex(CTX, \
+				REG(reg_name), \
+				0, \
+				n, __VA_ARGS__)
+
+#define REG_SET(reg_name, field, val)	\
+		REG_SET_N(reg_name, 1, FD(reg_name##__##field), val)
+
+/* macro to poll and wait for a register field to read back given value */
+
+#define REG_WAIT(reg_name, field, val, delay, max_try)	\
+		generic_reg_wait(CTX, \
+				REG(reg_name), FD(reg_name##__##field), val,\
+				delay, max_try)
+
+/* macro to update (read, modify, write) register fields
+ */
+#define REG_UPDATE_N(reg_name, n, ...)	\
+		generic_reg_update_ex(CTX, \
+				REG(reg_name), \
+				REG_READ(reg_name), \
+				n, __VA_ARGS__)
+
+#define REG_UPDATE(reg_name, field, val)	\
+		REG_UPDATE_N(reg_name, 1, \
+				FD(reg_name##__##field), val)
+
+#define REG_UPDATE_2(reg, f1, v1, f2, v2)	\
+		REG_UPDATE_N(reg, 2,\
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2)
+
+#define REG_UPDATE_3(reg, f1, v1, f2, v2, f3, v3)	\
+		REG_UPDATE_N(reg, 3, \
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2, \
+				FD(reg##__##f3), v3)
+
+#define REG_UPDATE_4(reg, f1, v1, f2, v2, f3, v3, f4, v4)	\
+		REG_UPDATE_N(reg, 4, \
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2, \
+				FD(reg##__##f3), v3, \
+				FD(reg##__##f4), v4)
+
+#define REG_UPDATE_5(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5)	\
+		REG_UPDATE_N(reg, 5, \
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2, \
+				FD(reg##__##f3), v3, \
+				FD(reg##__##f4), v4, \
+				FD(reg##__##f5), v5)
+
+#define REG_UPDATE_6(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6)	\
+		REG_UPDATE_N(reg, 6, \
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2, \
+				FD(reg##__##f3), v3, \
+				FD(reg##__##f4), v4, \
+				FD(reg##__##f5), v5, \
+				FD(reg##__##f6), v6)
+
+#define REG_UPDATE_7(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7)	\
+		REG_UPDATE_N(reg, 7, \
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2, \
+				FD(reg##__##f3), v3, \
+				FD(reg##__##f4), v4, \
+				FD(reg##__##f5), v5, \
+				FD(reg##__##f6), v6, \
+				FD(reg##__##f7), v7)
+
+#define REG_UPDATE_8(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8)	\
+		REG_UPDATE_N(reg, 8, \
+				FD(reg##__##f1), v1,\
+				FD(reg##__##f2), v2, \
+				FD(reg##__##f3), v3, \
+				FD(reg##__##f4), v4, \
+				FD(reg##__##f5), v5, \
+				FD(reg##__##f6), v6, \
+				FD(reg##__##f7), v7, \
+				FD(reg##__##f8), v8)
+
+#define REG_UPDATE_9(reg, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8, f9, v9)	\
+		REG_UPDATE_N(reg, 9, \
+				FD(reg##__##f1), val1,\
+				FD(reg##__##f2), val2, \
+				FD(reg##__##f3), val3, \
+				FD(reg##__##f4), val4, \
+				FD(reg##__##f5), val5, \
+				FD(reg##__##f6), val6, \
+				FD(reg##__##f7), val7, \
+				FD(reg##__##f8), val8, \
+				FD(reg##__##f9), val9)
+
+#endif /* DRIVERS_GPU_DRM_AMD_DAL_DEV_DC_INC_REG_HELPER_H_ */
-- 
2.7.4

