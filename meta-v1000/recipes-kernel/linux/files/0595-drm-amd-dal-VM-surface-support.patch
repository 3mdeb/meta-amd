From 67303bf551c2b1d9f2b52a2c70b0a33bc9e76276 Mon Sep 17 00:00:00 2001
From: Aberback <jaberbac@amd.com>
Date: Mon, 27 Jun 2016 11:00:22 -0400
Subject: [PATCH 0595/1722] drm/amd/dal: VM surface support

This adds virtual memory support for surfaces, also
called scatter gather.

For now, hardcoding outstanding request limit to maximum.

Change-Id: I7a43e5b0045a84be30f14e418135de3c7e3d385c
Signed-off-by: Joshua Aberback <Joshua.Aberback@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |   2 +
 drivers/gpu/drm/amd/dal/dc/dc.h                    |   8 ++
 drivers/gpu/drm/amd/dal/dc/dc_hw_types.h           |  19 ++-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |   7 ++
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c   | 113 +++++++++++++++++
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h   |  11 ++
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c | 138 +++++++++++++++++++++
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h |  11 ++
 drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h      |   6 +
 9 files changed, 312 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index bc2dee3..a4115ec 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -398,6 +398,8 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 			core_dc->res_pool.stream_enc_count);
 	core_dc->public.caps.max_links = core_dc->link_count;
 	core_dc->public.caps.max_audios = core_dc->res_pool.audio_count;
+ 
+        core_dc->public.config.gpu_vm_support = init_params->flags.gpu_vm_support;
 
 	dal_logger_write(core_dc->ctx->logger,
 			LOG_MAJOR_INTERFACE_TRACE,
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index d5966c8..5ee045a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -56,9 +56,15 @@ struct dc_stream_funcs {
 			const struct dc_stream **stream, int num_streams, int vmin, int vmax);
 };
 
+/* Structure to hold configuration flags set by dm at dc creation. */
+struct dc_config {
+	bool gpu_vm_support;
+};
+
 struct dc {
 	struct dc_caps caps;
 	struct dc_stream_funcs stream_funcs;
+	struct dc_config config;
 };
 
 struct dc_init_data {
@@ -74,6 +80,8 @@ struct dc_init_data {
 	 */
 	struct dc_bios *vbios_override;
 	enum dce_environment dce_environment;
+
+	struct dc_config flags;
 };
 
 struct dc *dc_create(const struct dc_init_data *init_params);
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
index e979295..7c0879e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_hw_types.h
@@ -191,9 +191,22 @@ enum tile_split_values {
  * if they ever change.
  */
 enum array_mode_values {
-	DC_ARRAY_UNDEFINED = 0,
-	DC_ARRAY_1D_TILED_THIN1 = 0x2,
-	DC_ARRAY_2D_TILED_THIN1 = 0x4,
+	DC_ARRAY_LINEAR_GENERAL = 0,
+	DC_ARRAY_LINEAR_ALLIGNED,
+	DC_ARRAY_1D_TILED_THIN1,
+	DC_ARRAY_1D_TILED_THICK,
+	DC_ARRAY_2D_TILED_THIN1,
+	DC_ARRAY_PRT_TILED_THIN1,
+	DC_ARRAY_PRT_2D_TILED_THIN1,
+	DC_ARRAY_2D_TILED_THICK,
+	DC_ARRAY_2D_TILED_X_THICK,
+	DC_ARRAY_PRT_TILED_THICK,
+	DC_ARRAY_PRT_2D_TILED_THICK,
+	DC_ARRAY_PRT_3D_TILED_THIN1,
+	DC_ARRAY_3D_TILED_THIN1,
+	DC_ARRAY_3D_TILED_THICK,
+	DC_ARRAY_3D_TILED_X_THICK,
+	DC_ARRAY_PRT_3D_TILED_THICK,
 };
 
 enum tile_mode_values {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 2ad7eed..9439a1a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1486,6 +1486,13 @@ static void set_plane_config(
 			&surface->public.tiling_info,
 			&surface->public.plane_size,
 			surface->public.rotation);
+
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
+				pipe_ctx->mi,
+				surface->public.format,
+				&surface->public.tiling_info,
+				surface->public.rotation);
 }
 
 static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
index 0235560..e6b6fe9 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.c
@@ -403,6 +403,117 @@ bool dce110_mem_input_program_surface_flip_and_addr(
 	return true;
 }
 
+/* Scatter Gather param tables */
+static const unsigned int dvmm_Hw_Setting_2DTiling[4][9] = {
+		{  8, 64, 64,  8,  8, 1, 4, 0, 0},
+		{ 16, 64, 32,  8, 16, 1, 8, 0, 0},
+		{ 32, 32, 32, 16, 16, 1, 8, 0, 0},
+		{ 64,  8, 32, 16, 16, 1, 8, 0, 0}, /* fake */
+};
+
+static const unsigned int dvmm_Hw_Setting_1DTiling[4][9] = {
+		{  8, 512, 8, 1, 0, 1, 0, 0, 0},  /* 0 for invalid */
+		{ 16, 256, 8, 2, 0, 1, 0, 0, 0},
+		{ 32, 128, 8, 4, 0, 1, 0, 0, 0},
+		{ 64,  64, 8, 4, 0, 1, 0, 0, 0}, /* fake */
+};
+
+static const unsigned int dvmm_Hw_Setting_Linear[4][9] = {
+		{  8, 4096, 1, 8, 0, 1, 0, 0, 0},
+		{ 16, 2048, 1, 8, 0, 1, 0, 0, 0},
+		{ 32, 1024, 1, 8, 0, 1, 0, 0, 0},
+		{ 64,  512, 1, 8, 0, 1, 0, 0, 0}, /* new for 64bpp from HW */
+};
+
+/* Helper to get table entry from surface info */
+static const unsigned int *get_dvmm_hw_setting(
+		struct dc_tiling_info *tiling_info,
+		enum surface_pixel_format format)
+{
+	enum bits_per_pixel {
+		bpp_8 = 0,
+		bpp_16,
+		bpp_32,
+		bpp_64
+	} bpp;
+
+	if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)
+		bpp = bpp_64;
+	else if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB8888)
+		bpp = bpp_32;
+	else if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB1555)
+		bpp = bpp_16;
+	else
+		bpp = bpp_8;
+
+	switch (tiling_info->array_mode) {
+	case DC_ARRAY_1D_TILED_THIN1:
+	case DC_ARRAY_1D_TILED_THICK:
+	case DC_ARRAY_PRT_TILED_THIN1:
+		return dvmm_Hw_Setting_1DTiling[bpp];
+	case DC_ARRAY_2D_TILED_THIN1:
+	case DC_ARRAY_2D_TILED_THICK:
+	case DC_ARRAY_2D_TILED_X_THICK:
+	case DC_ARRAY_PRT_2D_TILED_THIN1:
+	case DC_ARRAY_PRT_2D_TILED_THICK:
+		return dvmm_Hw_Setting_2DTiling[bpp];
+	case DC_ARRAY_LINEAR_GENERAL:
+	case DC_ARRAY_LINEAR_ALLIGNED:
+		return dvmm_Hw_Setting_Linear[bpp];
+	default:
+		return dvmm_Hw_Setting_2DTiling[bpp];
+	}
+}
+
+bool dce110_mem_input_program_pte_vm(
+		struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		struct dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation)
+{
+	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	const unsigned int *pte = get_dvmm_hw_setting(tiling_info, format);
+
+	unsigned int page_width = 0;
+	unsigned int page_height = 0;
+	unsigned int temp_page_width = pte[1];
+	unsigned int temp_page_height = pte[2];
+	unsigned int min_pte_before_flip = 0;
+	uint32_t value = 0;
+
+	while ((temp_page_width >>= 1) != 0)
+		page_width++;
+	while ((temp_page_height >>= 1) != 0)
+		page_height++;
+
+	switch (rotation) {
+	case ROTATION_ANGLE_90:
+	case ROTATION_ANGLE_270:
+		min_pte_before_flip = pte[4];
+		break;
+	default:
+		min_pte_before_flip = pte[3];
+		break;
+	}
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_PIPE_OUTSTANDING_REQUEST_LIMIT));
+	set_reg_field_value(value, 0xff, GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmGRPH_PIPE_OUTSTANDING_REQUEST_LIMIT), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmDVMM_PTE_CONTROL));
+	set_reg_field_value(value, page_width, DVMM_PTE_CONTROL, DVMM_PAGE_WIDTH);
+	set_reg_field_value(value, page_height, DVMM_PTE_CONTROL, DVMM_PAGE_HEIGHT);
+	set_reg_field_value(value, min_pte_before_flip, DVMM_PTE_CONTROL, DVMM_MIN_PTE_BEFORE_FLIP);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmDVMM_PTE_CONTROL), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmDVMM_PTE_ARB_CONTROL));
+	set_reg_field_value(value, pte[5], DVMM_PTE_ARB_CONTROL, DVMM_PTE_REQ_PER_CHUNK);
+	set_reg_field_value(value, 0xff, DVMM_PTE_ARB_CONTROL, DVMM_MAX_PTE_REQ_OUTSTANDING);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmDVMM_PTE_ARB_CONTROL), value);
+
+	return true;
+}
+
 bool dce110_mem_input_program_surface_config(
 	struct mem_input *mem_input,
 	enum surface_pixel_format format,
@@ -871,6 +982,8 @@ static struct mem_input_funcs dce110_mem_input_funcs = {
 	.free_mem_input = dce110_free_mem_input,
 	.mem_input_program_surface_flip_and_addr =
 			dce110_mem_input_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm =
+			dce110_mem_input_program_pte_vm,
 	.mem_input_program_surface_config =
 			dce110_mem_input_program_surface_config,
 	.mem_input_is_flip_pending =
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
index f36f0fe..0205bf5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input.h
@@ -130,6 +130,17 @@ bool  dce110_mem_input_program_surface_config(
 	enum dc_rotation_angle rotation);
 
 /*
+ * dce110_mem_input_program_pte_vm
+ *
+ * This function will program pte vm registers.
+ */
+bool  dce110_mem_input_program_pte_vm(
+	struct mem_input *mem_input,
+	enum surface_pixel_format format,
+	struct dc_tiling_info *tiling_info,
+	enum dc_rotation_angle rotation);
+
+/*
  * dce110_mem_input_is_flip_pending
  *
  * This function will wait until the surface update-pending bit is cleared.
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
index 45dc985..f8cb11f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
@@ -520,6 +520,142 @@ bool dce110_mem_input_v_program_surface_flip_and_addr(
 	return true;
 }
 
+/* Scatter Gather param tables */
+static const unsigned int dvmm_Hw_Setting_2DTiling[4][9] = {
+		{  8, 64, 64,  8,  8, 1, 4, 0, 0},
+		{ 16, 64, 32,  8, 16, 1, 8, 0, 0},
+		{ 32, 32, 32, 16, 16, 1, 8, 0, 0},
+		{ 64,  8, 32, 16, 16, 1, 8, 0, 0}, /* fake */
+};
+
+static const unsigned int dvmm_Hw_Setting_1DTiling[4][9] = {
+		{  8, 512, 8, 1, 0, 1, 0, 0, 0},  /* 0 for invalid */
+		{ 16, 256, 8, 2, 0, 1, 0, 0, 0},
+		{ 32, 128, 8, 4, 0, 1, 0, 0, 0},
+		{ 64,  64, 8, 4, 0, 1, 0, 0, 0}, /* fake */
+};
+
+static const unsigned int dvmm_Hw_Setting_Linear[4][9] = {
+		{  8, 4096, 1, 8, 0, 1, 0, 0, 0},
+		{ 16, 2048, 1, 8, 0, 1, 0, 0, 0},
+		{ 32, 1024, 1, 8, 0, 1, 0, 0, 0},
+		{ 64,  512, 1, 8, 0, 1, 0, 0, 0}, /* new for 64bpp from HW */
+};
+
+/* Helper to get table entry from surface info */
+static const unsigned int *get_dvmm_hw_setting(
+		struct dc_tiling_info *tiling_info,
+		enum surface_pixel_format format,
+		bool chroma)
+{
+	enum bits_per_pixel {
+		bpp_8 = 0,
+		bpp_16,
+		bpp_32,
+		bpp_64
+	} bpp;
+
+	if (format >= SURFACE_PIXEL_FORMAT_INVALID)
+		bpp = bpp_32;
+	else if (format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+		bpp = chroma ? bpp_16 : bpp_8;
+	else
+		bpp = bpp_8;
+
+	switch (tiling_info->array_mode) {
+	case DC_ARRAY_1D_TILED_THIN1:
+	case DC_ARRAY_1D_TILED_THICK:
+	case DC_ARRAY_PRT_TILED_THIN1:
+		return dvmm_Hw_Setting_1DTiling[bpp];
+	case DC_ARRAY_2D_TILED_THIN1:
+	case DC_ARRAY_2D_TILED_THICK:
+	case DC_ARRAY_2D_TILED_X_THICK:
+	case DC_ARRAY_PRT_2D_TILED_THIN1:
+	case DC_ARRAY_PRT_2D_TILED_THICK:
+		return dvmm_Hw_Setting_2DTiling[bpp];
+	case DC_ARRAY_LINEAR_GENERAL:
+	case DC_ARRAY_LINEAR_ALLIGNED:
+		return dvmm_Hw_Setting_Linear[bpp];
+	default:
+		return dvmm_Hw_Setting_2DTiling[bpp];
+	}
+}
+
+bool dce110_mem_input_v_program_pte_vm(
+		struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		struct dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation)
+{
+	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	const unsigned int *pte = get_dvmm_hw_setting(tiling_info, format, false);
+	const unsigned int *pte_chroma = get_dvmm_hw_setting(tiling_info, format, true);
+
+	unsigned int page_width = 0;
+	unsigned int page_height = 0;
+	unsigned int page_width_chroma = 0;
+	unsigned int page_height_chroma = 0;
+	unsigned int temp_page_width = pte[1];
+	unsigned int temp_page_height = pte[2];
+	unsigned int min_pte_before_flip = 0;
+	unsigned int min_pte_before_flip_chroma = 0;
+	uint32_t value = 0;
+
+	while ((temp_page_width >>= 1) != 0)
+		page_width++;
+	while ((temp_page_height >>= 1) != 0)
+		page_height++;
+
+	temp_page_width = pte_chroma[1];
+	temp_page_height = pte_chroma[2];
+	while ((temp_page_width >>= 1) != 0)
+		page_width_chroma++;
+	while ((temp_page_height >>= 1) != 0)
+		page_height_chroma++;
+
+	switch (rotation) {
+	case ROTATION_ANGLE_90:
+	case ROTATION_ANGLE_270:
+		min_pte_before_flip = pte[4];
+		min_pte_before_flip_chroma = pte_chroma[4];
+		break;
+	default:
+		min_pte_before_flip = pte[3];
+		min_pte_before_flip_chroma = pte_chroma[3];
+		break;
+	}
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT));
+	/* TODO: un-hardcode requestlimit */
+	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_L);
+	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_C);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL));
+	set_reg_field_value(value, page_width, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_WIDTH);
+	set_reg_field_value(value, page_height, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_HEIGHT);
+	set_reg_field_value(value, min_pte_before_flip, UNP_DVMM_PTE_CONTROL, DVMM_MIN_PTE_BEFORE_FLIP);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL));
+	set_reg_field_value(value, pte[5], UNP_DVMM_PTE_ARB_CONTROL, DVMM_PTE_REQ_PER_CHUNK);
+	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL, DVMM_MAX_PTE_REQ_OUTSTANDING);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C));
+	set_reg_field_value(value, page_width_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_WIDTH_C);
+	set_reg_field_value(value, page_height_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_HEIGHT_C);
+	set_reg_field_value(value, min_pte_before_flip_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_MIN_PTE_BEFORE_FLIP_C);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C));
+	set_reg_field_value(value, pte_chroma[5], UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_PTE_REQ_PER_CHUNK_C);
+	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_MAX_PTE_REQ_OUTSTANDING_C);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C), value);
+
+	return true;
+}
+
 bool dce110_mem_input_v_program_surface_config(
 	struct mem_input *mem_input,
 	enum surface_pixel_format format,
@@ -874,6 +1010,8 @@ static struct mem_input_funcs dce110_mem_input_v_funcs = {
 	.free_mem_input = dce110_free_mem_input_v,
 	.mem_input_program_surface_flip_and_addr =
 			dce110_mem_input_v_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm =
+			dce110_mem_input_v_program_pte_vm,
 	.mem_input_program_surface_config =
 			dce110_mem_input_v_program_surface_config,
 	.mem_input_is_flip_pending =
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
index 9852363..840741f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.h
@@ -71,6 +71,17 @@ bool dce110_mem_input_v_program_surface_flip_and_addr(
 	bool flip_immediate);
 
 /*
+ * dce110_mem_input_v_program_scatter_gather
+ *
+ * This function will program scatter gather registers.
+ */
+bool  dce110_mem_input_v_program_pte_vm(
+	struct mem_input *mem_input,
+	enum surface_pixel_format format,
+	struct dc_tiling_info *tiling_info,
+	enum dc_rotation_angle rotation);
+
+/*
  * This function will program surface tiling, size, rotation and pixel format
  * to corresponding dcp registers.
  */
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
index 2d5dff0..55b90b3 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/mem_input.h
@@ -66,6 +66,12 @@ struct mem_input_funcs {
 		const struct dc_plane_address *address,
 		bool flip_immediate);
 
+	bool (*mem_input_program_pte_vm)(
+		struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		struct dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation);
+
 	bool (*mem_input_program_surface_config)(
 		struct mem_input *mem_input,
 		enum surface_pixel_format format,
-- 
2.7.4

