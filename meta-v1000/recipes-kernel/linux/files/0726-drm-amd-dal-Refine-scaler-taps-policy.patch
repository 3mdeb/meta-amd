From db3180ddc31446101c76e80400dcda47d6d49a2e Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 15 Jul 2016 08:33:26 -0400
Subject: [PATCH 0726/1722] drm/amd/dal: Refine scaler taps policy

Contain this in transform.

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 26 +------
 .../drm/amd/dal/dc/dce110/dce110_transform_scl.c   | 80 ++++++++++++++++------
 2 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 31d1efc..98a2ecd 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -444,6 +444,7 @@ bool resource_build_scaling_params(
 {
 	bool res;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
 	 */
@@ -473,29 +474,6 @@ bool resource_build_scaling_params(
 	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
 		pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
 
-	/* Check if scaling is required, if so  fail in case optimal taps calc
-	 * failed. Otherwise just update taps here
-	 */
-	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.horz) == (1 << 19))
-		pipe_ctx->scl_data.taps.h_taps = 1;
-	else if (!res)
-		return false;
-
-	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.horz_c) == (1 << 19))
-		pipe_ctx->scl_data.taps.h_taps_c = 1;
-	else if (!res)
-		return false;
-
-	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.vert) == (1 << 19))
-		pipe_ctx->scl_data.taps.v_taps = 1;
-	else if (!res)
-		return false;
-
-	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.vert_c) == (1 << 19))
-		pipe_ctx->scl_data.taps.v_taps_c = 1;
-	else if (!res)
-		return false;
-
 	dal_logger_write(pipe_ctx->stream->ctx->logger,
 				LOG_MAJOR_DCP,
 				LOG_MINOR_DCP_SCALER,
@@ -512,7 +490,7 @@ bool resource_build_scaling_params(
 				surface->dst_rect.x,
 				surface->dst_rect.y);
 
-	return true;
+	return res;
 }
 
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
index 876c00f..5e8472e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
@@ -683,17 +683,35 @@ void dce110_transform_set_scaler_filter(
 	xfm->filter = filter;
 }
 
+#define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
+
+static uint32_t decide_taps(struct fixed31_32 ratio, uint32_t in_taps, bool chroma)
+{
+	uint32_t taps;
+
+	if (IDENTITY_RATIO(ratio)) {
+		return 1;
+	} else if (in_taps != 0) {
+		taps = in_taps;
+	} else {
+		taps = 4;
+	}
+
+	if (chroma) {
+		taps /= 2;
+		if (taps < 2)
+			taps = 2;
+	}
+
+	return taps;
+}
+
 bool transform_get_optimal_number_of_taps_helper(
 	struct transform *xfm,
 	struct scaler_data *scl_data,
 	uint32_t pixel_width,
 	const struct scaling_taps *in_taps) {
 
-	/*In gcc linux, the scl_data->taps.v_taps will somehow be optimized out by compiler
-	 *and thus causing a scale tap validation failure. Declaring the scaler data with volatile
-	 *will avoid it to be optimized.
-	 */
-	volatile struct scaler_data *scl = scl_data;
 	int max_num_of_lines;
 
 	max_num_of_lines = dce110_transform_get_max_num_of_supported_lines(
@@ -701,27 +719,47 @@ bool transform_get_optimal_number_of_taps_helper(
 		scl_data->lb_bpp,
 		pixel_width);
 
-	/* If num of taps is given as input fail if we cannot
-	 * maintain that much taps
-	 */
-	if (in_taps->v_taps) {
-		scl->taps = *in_taps;
-		return max_num_of_lines > scl->taps.v_taps;
-	}
+	/* Fail if in_taps are impossible */
+	if (in_taps->v_taps >= max_num_of_lines)
+		return false;
 
-	/*If no taps given as input set to max and reduce
-	 * as needed to get along, also
-	 * set horizontal taps to 4 regardless
+	/*
+	 * Set taps according to this policy (in this order)
+	 * - Use 1 for no scaling
+	 * - Use input taps
+	 * - Use 4 and reduce as required by line buffer size
+	 * - Decide chroma taps if chroma is scaled
+	 *
+	 * Ignore input chroma taps. Decide based on non-chroma
 	 */
-	scl->taps.h_taps = 4;
-	scl->taps.v_taps = 4;
+	scl_data->taps.h_taps = decide_taps(scl_data->ratios.horz, in_taps->h_taps, false);
+	scl_data->taps.v_taps = decide_taps(scl_data->ratios.vert, in_taps->v_taps, false);
+	scl_data->taps.h_taps_c = decide_taps(scl_data->ratios.horz_c, in_taps->h_taps, true);
+	scl_data->taps.v_taps_c = decide_taps(scl_data->ratios.vert_c, in_taps->v_taps, true);
+
+	if (!IDENTITY_RATIO(scl_data->ratios.vert)) {
+		/* reduce v_taps if needed but ensure we have at least two */
+		if (in_taps->v_taps == 0
+				&& max_num_of_lines <= scl_data->taps.v_taps
+				&& scl_data->taps.v_taps > 1) {
+			scl_data->taps.v_taps = max_num_of_lines - 1;
+		}
 
-	if (max_num_of_lines > scl->taps.v_taps)
-		return true;
+		if (scl_data->taps.v_taps <= 1)
+			return false;
+	}
 
-	scl->taps.v_taps = max_num_of_lines - 1;
+	if (!IDENTITY_RATIO(scl_data->ratios.vert_c)) {
+		/* reduce chroma v_taps if needed but ensure we have at least two */
+		if (max_num_of_lines <= scl_data->taps.v_taps_c && scl_data->taps.v_taps_c > 1) {
+			scl_data->taps.v_taps_c = max_num_of_lines - 1;
+		}
 
+		if (scl_data->taps.v_taps_c <= 1)
+			return false;
+	}
 
-	return scl->taps.v_taps > 1;
+	/* we've got valid taps */
+	return true;
 
 }
-- 
2.7.4

