From d2c52861a049d0cb13ad0e34f9fb60e00aec2d1e Mon Sep 17 00:00:00 2001
From: Tony Cheng <tony.cheng@amd.com>
Date: Thu, 15 Sep 2016 13:22:24 -0400
Subject: [PATCH 1084/1722] drm/amd/dal: refactor audio step 8

- delete obsolete files
- move audio to proper location.  remove audio component.

Change-Id: I67c7b121f94c28e61fd06cd85450dfdd18c7c22a
Signed-off-by: Tony Cheng <tony.cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/Makefile                |    2 +-
 drivers/gpu/drm/amd/dal/dc/audio/Makefile          |   35 -
 drivers/gpu/drm/amd/dal/dc/audio/audio.h           |  143 ---
 drivers/gpu/drm/amd/dal/dc/audio/audio_base.c      |  101 --
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c | 1015 --------------------
 .../gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h |   93 --
 .../amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c  |  211 ----
 .../amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.h  |   47 -
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c   |  144 ---
 .../gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h   |   34 -
 .../amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c    |  231 -----
 .../amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h    |   72 --
 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h    |   97 --
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |    1 -
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |    1 +
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |   88 +-
 drivers/gpu/drm/amd/dal/dc/dce110/Makefile         |    2 +-
 drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h   |   92 ++
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c   |  953 ++++++++++++++++++
 .../drm/amd/dal/dc/dce110/dce110_clock_source.c    |    1 +
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |    2 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.h    |    1 +
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  100 +-
 .../drm/amd/dal/dc/dce112/dce112_clock_source.c    |    1 +
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |   98 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  102 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |    3 +-
 drivers/gpu/drm/amd/dal/dc/inc/hw/audio.h          |   65 ++
 drivers/gpu/drm/amd/dal/include/audio_interface.h  |   72 --
 drivers/gpu/drm/amd/dal/include/audio_types.h      |    1 -
 30 files changed, 1310 insertions(+), 2498 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/Makefile
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/audio.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
 create mode 100644 drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h
 create mode 100644 drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
 create mode 100644 drivers/gpu/drm/amd/dal/dc/inc/hw/audio.h
 delete mode 100644 drivers/gpu/drm/amd/dal/include/audio_interface.h

diff --git a/drivers/gpu/drm/amd/dal/dc/Makefile b/drivers/gpu/drm/amd/dal/dc/Makefile
index faf0d03..8f57424 100644
--- a/drivers/gpu/drm/amd/dal/dc/Makefile
+++ b/drivers/gpu/drm/amd/dal/dc/Makefile
@@ -2,7 +2,7 @@
 # Makefile for Display Core (dc) component.
 #
 
-DC_LIBS = adapter asic_capability audio basics bios calcs \
+DC_LIBS = adapter asic_capability basics bios calcs \
 gpio gpu i2caux irq virtual
 
 ifdef CONFIG_DRM_AMD_DAL_DCE11_2
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/Makefile b/drivers/gpu/drm/amd/dal/dc/audio/Makefile
deleted file mode 100644
index e78897a..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-#
-# Makefile for the 'audio' sub-component of DAL.
-# It provides the control and status of HW adapter resources,
-# that are global for the ASIC and sharable between pipes.
-
-AUDIO = audio_base.o
-
-AMD_DAL_AUDIO = $(addprefix $(AMDDALPATH)/dc/audio/,$(AUDIO))
-
-AMD_DAL_FILES += $(AMD_DAL_AUDIO)
-
-
-###############################################################################
-# DCE 8x
-###############################################################################
-ifdef CONFIG_DRM_AMD_DAL_DCE8_0
-AUDIO_DCE80 = audio_dce80.o hw_ctx_audio_dce80.o
-
-AMD_DAL_AUDIO_DCE80 = $(addprefix $(AMDDALPATH)/dc/audio/dce80/,$(AUDIO_DCE80))
-
-AMD_DAL_FILES += $(AMD_DAL_AUDIO_DCE80)
-endif
-
-
-###############################################################################
-# DCE 11x
-###############################################################################
-ifdef CONFIG_DRM_AMD_DAL_DCE11_0
-AUDIO_DCE11 = audio_dce110.o hw_ctx_audio_dce110.o
-
-AMD_DAL_AUDIO_DCE11 = $(addprefix $(AMDDALPATH)/dc/audio/dce110/,$(AUDIO_DCE11))
-
-AMD_DAL_FILES += $(AMD_DAL_AUDIO_DCE11)
-endif
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio.h b/drivers/gpu/drm/amd/dal/dc/audio/audio.h
deleted file mode 100644
index a36b7ea..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_AUDIO_H__
-#define __DAL_AUDIO_H__
-
-#include "include/audio_interface.h"
-#include "hw_ctx_audio.h"
-#include "include/link_service_types.h"
-
-/***** only for hook functions  *****/
-/**
- *which will be overwritten by derived audio object.
- *audio hw context object is independent object
- */
-
-struct audio;
-
-struct audio_funcs {
-
-	void (*hw_init)(struct audio *audio);
-
-	void (*az_enable)(struct audio *audio);
-
-	void (*az_disable)(struct audio *audio);
-
-	void (*az_configure)(struct audio *audio,
-		enum signal_type signal,
-		const struct audio_crtc_info *crtc_info,
-		const struct audio_info *audio_info);
-
-	void (*wall_dto_setup)(struct audio *audio,
-		enum signal_type signal,
-		const struct audio_crtc_info *crtc_info,
-		const struct audio_pll_info *pll_info);
-	/*
-	 *get_object_id
-	 *get_object_type
-	 *enumerate_input_signals
-	 *enumerate_output_signals
-	 *is_input_signal_supported
-	 *is_output_signal_supported
-	 *set_object_properties
-	 *get_object_properties
-	 */
-
-	void (*destroy)(struct audio **audio);
-	/*power_up
-	 *power_down
-	 *release_hw_base
-	 */
-
-	/*enable_azalia_audio_jack_presence
-	 * disable_azalia_audio_jack_presence
-	 */
-
-
-
-	/* Update audio wall clock source */
-
-
-	/* options and features supported by Audio */
-
-	/*
-	 *check_audio_bandwidth
-	 *write_reg
-	 *read_reg
-	 *register_interrupt
-	 *unregister_interrupt
-	 *process_interrupt
-	 *create_hw_ctx
-	 *getHwCtx
-	 *setHwCtx
-	 *handle_interrupt
-	 */
-};
-
-struct audio {
-	/* hook functions. they will be overwritten by specific ASIC */
-	const struct audio_funcs *funcs;
-
-	/*external structures - get service from external*/
-	struct graphics_object_id id;
-	/* audio HW context */
-	struct hw_ctx_audio *hw_ctx;
-	struct dc_context *ctx;
-	unsigned int inst;
-};
-
-/* - functions defined by audio.h will be used by audio component only.
- *   but audio.c also implements some function defined by dal\include
- */
-
-/* graphics_object_base implemention
- * 1.input_signals and output_signals are moved
- * into audio object.
- *
- * 2.Get the Graphics Object ID
- *
- * Outside audio:
- * use dal_graphics_object_id_get_audio_id
- * Within audio:
- *	use audio->go_base.id
- *
- * 3. Get the Graphics Object Type
- *
- *  use object_id.type
- *  not function implemented.
- * 4. Common Graphics Object Properties
- * use object id ->go_properties.multi_path
- * not function implemented.
- */
-
-bool dal_audio_construct_base(
-	struct audio *audio,
-	const struct audio_init_data *init_data);
-
-void dal_audio_destruct_base(
-	struct audio *audio);
-
-#endif  /* __DAL_AUDIO__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c b/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
deleted file mode 100644
index 707c824..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/audio_base.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "include/logger_interface.h"
-
-#include "audio.h"
-#include "hw_ctx_audio.h"
-
-#if defined(CONFIG_DRM_AMD_DAL_DCE8_0)
-#include "dce80/audio_dce80.h"
-#include "dce80/hw_ctx_audio_dce80.h"
-#endif
-
-#if defined(CONFIG_DRM_AMD_DAL_DCE11_0)
-#include "dce110/audio_dce110.h"
-#include "dce110/hw_ctx_audio_dce110.h"
-#endif
-
-
-/***** static function : only used within audio.c *****/
-
-/* stub for hook functions */
-static void destroy(
-	struct audio **audio)
-{
-	/*DCE specific, must be implemented in derived*/
-	BREAK_TO_DEBUGGER();
-}
-
-static const struct audio_funcs audio_funcs = {
-	.destroy = destroy,
-};
-
-/***** SCOPE : declare in audio.h. use within dal-audio. *****/
-
-bool dal_audio_construct_base(
-	struct audio *audio,
-	const struct audio_init_data *init_data)
-{
-	/* base hook functions */
-	audio->funcs = &audio_funcs;
-
-	audio->ctx = init_data->ctx;
-
-	/* save audio endpoint number to identify object creating */
-	audio->id = init_data->audio_stream_id;
-	audio->inst = init_data->inst;
-
-	return true;
-}
-
-/* except hw_ctx, no other hw need reset. so do nothing */
-void dal_audio_destruct_base(
-	struct audio *audio)
-{
-}
-
-/* audio object creator triage.
- * memory for "struct audio   dal_audio_create_dce8x" allocate
- * will happens within dal_audio_dce8x. memory allocate is done
- * with dal_audio_create_dce8x. memory release is initiated by
- * dal_audio_destroy. It will call hook function which will finially
- * used destroy() of dal_audio_dce8x. therefore, no memroy allocate
- *and release happen physcially at audio base object.
- */
-void dal_audio_destroy(
-	struct audio **audio)
-{
-	if (!audio || !*audio) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	(*audio)->funcs->destroy(audio);
-
-	*audio = NULL;
-}
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
deleted file mode 100644
index 0612e21..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.c
+++ /dev/null
@@ -1,1015 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "include/logger_interface.h"
-
-#include "audio_dce110.h"
-
-#include "dce/dce_11_0_d.h"
-#include "dce/dce_11_0_sh_mask.h"
-
-/***** static functions  *****/
-
-static void destruct(struct audio_dce110 *audio)
-{
-	/*release memory allocated for hw_ctx -- allocated is initiated
-	 *by audio_dce110 power_up
-	 *audio->base->hw_ctx = NULL is done within hw-ctx->destroy
-	 */
-	if (audio->base.hw_ctx)
-		audio->base.hw_ctx->funcs->destroy(&(audio->base.hw_ctx));
-
-	/* reset base_audio_block */
-	dal_audio_destruct_base(&audio->base);
-}
-
-static void destroy(struct audio **ptr)
-{
-	struct audio_dce110 *audio = NULL;
-
-	audio = container_of(*ptr, struct audio_dce110, base);
-
-	destruct(audio);
-
-	/* release memory allocated for audio_dce110*/
-	dm_free(audio);
-	*ptr = NULL;
-}
-
-#define DCE110_AUD(audio)\
-	container_of(audio, struct audio_dce110, base)
-
-#define CTX \
-	aud110->base.ctx
-
-#define REG(reg)\
-	(aud110->regs->reg)
-
-#define IX_REG(reg)\
-	ix ## reg
-
-
-#define REG_READ(reg_name) \
-		dm_read_reg(CTX, REG(reg_name))
-
-#define REG_WRITE(reg_name, value) \
-		dm_write_reg(CTX, REG(reg_name), value)
-
-#define REG_SET_N(reg_name, n, ...)	\
-		generic_reg_update_ex(CTX, \
-				REG(reg_name), \
-				0, \
-				n, __VA_ARGS__)
-
-#define REG_SET(reg_name, field, val)	\
-		REG_SET_N(reg_name, 1, FD(reg_name##__##field), val)
-
-#define REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_ex(CTX, \
-				REG(reg_name), \
-				REG_READ(reg_name), \
-				n, __VA_ARGS__)
-
-#define REG_UPDATE(reg_name, field, val)	\
-		REG_UPDATE_N(reg_name, 1, FD(reg_name##__##field), val)
-
-#define AZ_REG_READ(reg_name) \
-		read_indirect_azalia_reg(audio, IX_REG(reg_name))
-
-#define AZ_REG_WRITE(reg_name, value) \
-		write_indirect_azalia_reg(audio, IX_REG(reg_name), value)
-
-
-static void write_indirect_azalia_reg(struct audio *audio,
-	uint32_t reg_index,
-	uint32_t reg_data)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
-	REG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX,
-			AZALIA_ENDPOINT_REG_INDEX, reg_index);
-
-	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
-	REG_SET(AZALIA_F0_CODEC_ENDPOINT_DATA,
-			AZALIA_ENDPOINT_REG_DATA, reg_data);
-
-	dal_logger_write(CTX->logger,
-		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_AUDIO,
-		"AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
-		reg_index, reg_data);
-}
-
-static uint32_t read_indirect_azalia_reg(struct audio *audio, uint32_t reg_index)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	uint32_t value = 0;
-
-	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
-	REG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX,
-			AZALIA_ENDPOINT_REG_INDEX, reg_index);
-
-	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
-	value = REG_READ(AZALIA_F0_CODEC_ENDPOINT_DATA);
-
-	dal_logger_write(CTX->logger,
-		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_AUDIO,
-		"AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
-		reg_index, value);
-
-	return value;
-}
-
-static bool is_audio_format_supported(
-	const struct audio_info *audio_info,
-	enum audio_format_code audio_format_code,
-	uint32_t *format_index)
-{
-	uint32_t index;
-	uint32_t max_channe_index = 0;
-	bool found = false;
-
-	if (audio_info == NULL)
-		return found;
-
-	/* pass through whole array */
-	for (index = 0; index < audio_info->mode_count; index++) {
-		if (audio_info->modes[index].format_code == audio_format_code) {
-			if (found) {
-				/* format has multiply entries, choose one with
-				 *  highst number of channels */
-				if (audio_info->modes[index].channel_count >
-		audio_info->modes[max_channe_index].channel_count) {
-					max_channe_index = index;
-				}
-			} else {
-				/* format found, save it's index */
-				found = true;
-				max_channe_index = index;
-			}
-		}
-	}
-
-	/* return index */
-	if (found && format_index != NULL)
-		*format_index = max_channe_index;
-
-	return found;
-}
-
-/*For HDMI, calculate if specified sample rates can fit into a given timing */
-static void check_audio_bandwidth_hdmi(
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates)
-{
-	uint32_t samples;
-	uint32_t  h_blank;
-	bool limit_freq_to_48_khz = false;
-	bool limit_freq_to_88_2_khz = false;
-	bool limit_freq_to_96_khz = false;
-	bool limit_freq_to_174_4_khz = false;
-
-	/* For two channels supported return whatever sink support,unmodified*/
-	if (channel_count > 2) {
-
-		/* Based on HDMI spec 1.3 Table 7.5 */
-		if ((crtc_info->requested_pixel_clock <= 27000) &&
-		(crtc_info->v_active <= 576) &&
-		!(crtc_info->interlaced) &&
-		!(crtc_info->pixel_repetition == 2 ||
-		crtc_info->pixel_repetition == 4)) {
-			limit_freq_to_48_khz = true;
-
-		} else if ((crtc_info->requested_pixel_clock <= 27000) &&
-				(crtc_info->v_active <= 576) &&
-				(crtc_info->interlaced) &&
-				(crtc_info->pixel_repetition == 2)) {
-			limit_freq_to_88_2_khz = true;
-
-		} else if ((crtc_info->requested_pixel_clock <= 54000) &&
-				(crtc_info->v_active <= 576) &&
-				!(crtc_info->interlaced)) {
-			limit_freq_to_174_4_khz = true;
-		}
-	}
-
-	/* Also do some calculation for the available Audio Bandwidth for the
-	 * 8 ch (i.e. for the Layout 1 => ch > 2)
-	 */
-	h_blank = crtc_info->h_total - crtc_info->h_active;
-
-	if (crtc_info->pixel_repetition)
-		h_blank *= crtc_info->pixel_repetition;
-
-	/*based on HDMI spec 1.3 Table 7.5 */
-	h_blank -= 58;
-	/*for Control Period */
-	h_blank -= 16;
-
-	samples = h_blank * 10;
-	/* Number of Audio Packets (multiplied by 10) per Line (for 8 ch number
-	 * of Audio samples per line multiplied by 10 - Layout 1)
-	 */
-	 samples /= 32;
-	 samples *= crtc_info->v_active;
-	 /*Number of samples multiplied by 10, per second */
-	 samples *= crtc_info->refresh_rate;
-	 /*Number of Audio samples per second */
-	 samples /= 10;
-
-	 /* @todo do it after deep color is implemented
-	  * 8xx - deep color bandwidth scaling
-	  * Extra bandwidth is avaliable in deep color b/c link runs faster than
-	  * pixel rate. This has the effect of allowing more tmds characters to
-	  * be transmitted during blank
-	  */
-
-	switch (crtc_info->color_depth) {
-	case COLOR_DEPTH_888:
-		samples *= 4;
-		break;
-	case COLOR_DEPTH_101010:
-		samples *= 5;
-		break;
-	case COLOR_DEPTH_121212:
-		samples *= 6;
-		break;
-	default:
-		samples *= 4;
-		break;
-	}
-
-	samples /= 4;
-
-	/*check limitation*/
-	if (samples < 88200)
-		limit_freq_to_48_khz = true;
-	else if (samples < 96000)
-		limit_freq_to_88_2_khz = true;
-	else if (samples < 176400)
-		limit_freq_to_96_khz = true;
-	else if (samples < 192000)
-		limit_freq_to_174_4_khz = true;
-
-	if (sample_rates != NULL) {
-		/* limit frequencies */
-		if (limit_freq_to_174_4_khz)
-			sample_rates->rate.RATE_192 = 0;
-
-		if (limit_freq_to_96_khz) {
-			sample_rates->rate.RATE_192 = 0;
-			sample_rates->rate.RATE_176_4 = 0;
-		}
-		if (limit_freq_to_88_2_khz) {
-			sample_rates->rate.RATE_192 = 0;
-			sample_rates->rate.RATE_176_4 = 0;
-			sample_rates->rate.RATE_96 = 0;
-		}
-		if (limit_freq_to_48_khz) {
-			sample_rates->rate.RATE_192 = 0;
-			sample_rates->rate.RATE_176_4 = 0;
-			sample_rates->rate.RATE_96 = 0;
-			sample_rates->rate.RATE_88_2 = 0;
-		}
-	}
-}
-
-/*For DP SST, calculate if specified sample rates can fit into a given timing */
-static void check_audio_bandwidth_dpsst(
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates)
-{
-	/* do nothing */
-}
-
-/*For DP MST, calculate if specified sample rates can fit into a given timing */
-static void check_audio_bandwidth_dpmst(
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	union audio_sample_rates *sample_rates)
-{
-	/* do nothing  */
-}
-
-static void check_audio_bandwidth(
-	const struct audio_crtc_info *crtc_info,
-	uint32_t channel_count,
-	enum signal_type signal,
-	union audio_sample_rates *sample_rates)
-{
-	switch (signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		check_audio_bandwidth_hdmi(
-			crtc_info, channel_count, sample_rates);
-		break;
-	case SIGNAL_TYPE_EDP:
-	case SIGNAL_TYPE_DISPLAY_PORT:
-		check_audio_bandwidth_dpsst(
-			crtc_info, channel_count, sample_rates);
-		break;
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-		check_audio_bandwidth_dpmst(
-			crtc_info, channel_count, sample_rates);
-		break;
-	default:
-		break;
-	}
-}
-
-/* expose/not expose HBR capability to Audio driver */
-static void set_high_bit_rate_capable(
-	struct audio *audio,
-	bool capable)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-	uint32_t value = 0;
-
-	/* set high bit rate audio capable*/
-	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR);
-
-	set_reg_field_value(value, capable,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
-		HBR_CAPABLE);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR, value);
-}
-
-/* set video latency in in ms/2+1 */
-static void set_video_latency(
-	struct audio *audio,
-	int latency_in_ms)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	uint32_t value = 0;
-
-	if ((latency_in_ms < 0) || (latency_in_ms > 255))
-		return;
-
-	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
-
-	set_reg_field_value(value, latency_in_ms,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		VIDEO_LIPSYNC);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		value);
-}
-
-/* set audio latency in in ms/2+1 */
-static void set_audio_latency(
-	struct audio *audio,
-	int latency_in_ms)
-{
-	uint32_t value = 0;
-
-	if (latency_in_ms < 0)
-		latency_in_ms = 0;
-
-	if (latency_in_ms > 255)
-		latency_in_ms = 255;
-
-	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
-
-	set_reg_field_value(value, latency_in_ms,
-		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		AUDIO_LIPSYNC);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
-		value);
-}
-
-void dce110_aud_az_enable(struct audio *audio)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	uint32_t value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-
-	if (get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-			AUDIO_ENABLED) != 1)
-		set_reg_field_value(value, 1,
-			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-			AUDIO_ENABLED);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
-}
-
-void dce110_aud_az_disable(struct audio *audio)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	uint32_t value;
-
-	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-
-	set_reg_field_value(value, 0,
-		AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
-		AUDIO_ENABLED);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
-}
-
-void dce110_aud_az_configure(
-	struct audio *audio,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_info *audio_info)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	uint32_t speakers = audio_info->flags.info.ALLSPEAKERS;
-	uint32_t value;
-	uint32_t field = 0;
-	enum audio_format_code audio_format_code;
-	uint32_t format_index;
-	uint32_t index;
-	bool is_ac3_supported = false;
-	union audio_sample_rates sample_rate;
-	uint32_t strlen = 0;
-
-	/* Speaker Allocation */
-	/*
-	uint32_t value;
-	uint32_t field = 0;*/
-	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);
-
-	set_reg_field_value(value,
-		speakers,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		SPEAKER_ALLOCATION);
-
-	/* LFE_PLAYBACK_LEVEL = LFEPBL
-	 * LFEPBL = 0 : Unknown or refer to other information
-	 * LFEPBL = 1 : 0dB playback
-	 * LFEPBL = 2 : +10dB playback
-	 * LFE_BL = 3 : Reserved
-	 */
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		LFE_PLAYBACK_LEVEL);
-	/* todo: according to reg spec LFE_PLAYBACK_LEVEL is read only.
-	 *  why are we writing to it?  DCE8 does not write this */
-
-
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		HDMI_CONNECTION);
-
-	set_reg_field_value(value,
-		0,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		DP_CONNECTION);
-
-	field = get_reg_field_value(value,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			EXTRA_CONNECTION_INFO);
-
-	field &= ~0x1;
-
-	set_reg_field_value(value,
-		field,
-		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-		EXTRA_CONNECTION_INFO);
-
-	/* set audio for output signal */
-	switch (signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			HDMI_CONNECTION);
-
-		break;
-
-	case SIGNAL_TYPE_EDP:
-	case SIGNAL_TYPE_DISPLAY_PORT:
-	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-		set_reg_field_value(value,
-			1,
-			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
-			DP_CONNECTION);
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		break;
-	}
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, value);
-
-	/*  Audio Descriptors   */
-	/* pass through all formats */
-	for (format_index = 0; format_index < AUDIO_FORMAT_CODE_COUNT;
-			format_index++) {
-		audio_format_code =
-			(AUDIO_FORMAT_CODE_FIRST + format_index);
-
-		/* those are unsupported, skip programming */
-		if (audio_format_code == AUDIO_FORMAT_CODE_1BITAUDIO ||
-			audio_format_code == AUDIO_FORMAT_CODE_DST)
-			continue;
-
-		value = 0;
-
-		/* check if supported */
-		if (is_audio_format_supported(
-				audio_info, audio_format_code, &index)) {
-			const struct audio_mode *audio_mode =
-					&audio_info->modes[index];
-			union audio_sample_rates sample_rates =
-					audio_mode->sample_rates;
-			uint8_t byte2 = audio_mode->max_bit_rate;
-
-			/* adjust specific properties */
-			switch (audio_format_code) {
-			case AUDIO_FORMAT_CODE_LINEARPCM: {
-				check_audio_bandwidth(
-					crtc_info,
-					audio_mode->channel_count,
-					signal,
-					&sample_rates);
-
-				byte2 = audio_mode->sample_size;
-
-				set_reg_field_value(value,
-						sample_rates.all,
-						AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-						SUPPORTED_FREQUENCIES_STEREO);
-				}
-				break;
-			case AUDIO_FORMAT_CODE_AC3:
-				is_ac3_supported = true;
-				break;
-			case AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS:
-			case AUDIO_FORMAT_CODE_DTS_HD:
-			case AUDIO_FORMAT_CODE_MAT_MLP:
-			case AUDIO_FORMAT_CODE_DST:
-			case AUDIO_FORMAT_CODE_WMAPRO:
-				byte2 = audio_mode->vendor_specific;
-				break;
-			default:
-				break;
-			}
-
-			/* fill audio format data */
-			set_reg_field_value(value,
-					audio_mode->channel_count - 1,
-					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-					MAX_CHANNELS);
-
-			set_reg_field_value(value,
-					sample_rates.all,
-					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-					SUPPORTED_FREQUENCIES);
-
-			set_reg_field_value(value,
-					byte2,
-					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
-					DESCRIPTOR_BYTE_2);
-		} /* if */
-
-		AZ_REG_WRITE(
-				AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0 + format_index,
-				value);
-	} /* for */
-
-	if (is_ac3_supported)
-		/* todo: this reg global.  why program global register? */
-		REG_WRITE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
-				0x05);
-
-	/* check for 192khz/8-Ch support for HBR requirements */
-	sample_rate.all = 0;
-	sample_rate.rate.RATE_192 = 1;
-
-	check_audio_bandwidth(
-		crtc_info,
-		8,
-		signal,
-		&sample_rate);
-
-	set_high_bit_rate_capable(audio, sample_rate.rate.RATE_192);
-
-	/* Audio and Video Lipsync */
-	set_video_latency(audio, audio_info->video_latency);
-	set_audio_latency(audio, audio_info->audio_latency);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->manufacture_id,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		MANUFACTURER_ID);
-
-	set_reg_field_value(value, audio_info->product_id,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		PRODUCT_ID);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
-		value);
-
-	value = 0;
-
-	/*get display name string length */
-	while (audio_info->display_name[strlen++] != '\0') {
-		if (strlen >=
-		MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS)
-			break;
-		}
-	set_reg_field_value(value, strlen,
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
-		SINK_DESCRIPTION_LEN);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
-		value);
-
-	/*
-	*write the port ID:
-	*PORT_ID0 = display index
-	*PORT_ID1 = 16bit BDF
-	*(format MSB->LSB: 8bit Bus, 5bit Device, 3bit Function)
-	*/
-
-	value = 0;
-
-	set_reg_field_value(value, audio_info->port_id[0],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
-		PORT_ID0);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2, value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->port_id[1],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
-		PORT_ID1);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3, value);
-
-	/*write the 18 char monitor string */
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[0],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION0);
-
-	set_reg_field_value(value, audio_info->display_name[1],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION1);
-
-	set_reg_field_value(value, audio_info->display_name[2],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION2);
-
-	set_reg_field_value(value, audio_info->display_name[3],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
-		DESCRIPTION3);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4, value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[4],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION4);
-
-	set_reg_field_value(value, audio_info->display_name[5],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION5);
-
-	set_reg_field_value(value, audio_info->display_name[6],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION6);
-
-	set_reg_field_value(value, audio_info->display_name[7],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
-		DESCRIPTION7);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5, value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[8],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION8);
-
-	set_reg_field_value(value, audio_info->display_name[9],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION9);
-
-	set_reg_field_value(value, audio_info->display_name[10],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION10);
-
-	set_reg_field_value(value, audio_info->display_name[11],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
-		DESCRIPTION11);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6, value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[12],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION12);
-
-	set_reg_field_value(value, audio_info->display_name[13],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION13);
-
-	set_reg_field_value(value, audio_info->display_name[14],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION14);
-
-	set_reg_field_value(value, audio_info->display_name[15],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
-		DESCRIPTION15);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7, value);
-
-	value = 0;
-	set_reg_field_value(value, audio_info->display_name[16],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		DESCRIPTION16);
-
-	set_reg_field_value(value, audio_info->display_name[17],
-		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
-		DESCRIPTION17);
-
-	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8, value);
-}
-
-/**
-* initialize
-*
-* @brief
-*  Perform SW initialization - create audio hw context. Then do HW
-*  initialization. this function is called at dal_audio_power_up.
-*
-*/
-static enum audio_result initialize(struct audio *audio)
-{
-	uint8_t audio_endpoint_enum_id = 0;
-
-	audio_endpoint_enum_id = audio->id.enum_id;
-
-	/* HW CTX already create*/
-	if (audio->hw_ctx != NULL)
-		return AUDIO_RESULT_OK;
-
-	audio->hw_ctx = dal_hw_ctx_audio_dce110_create(
-			audio->ctx,
-			audio_endpoint_enum_id);
-
-	if (audio->hw_ctx == NULL)
-		return AUDIO_RESULT_ERROR;
-
-	/* override HW default settings */
-	audio->hw_ctx->funcs->hw_initialize(audio->hw_ctx);
-
-	return AUDIO_RESULT_OK;
-}
-
-/*
-* todo: wall clk related functionality probably belong to clock_src.
-*/
-
-/* search pixel clock value for Azalia HDMI Audio */
-static bool get_azalia_clock_info_hdmi(
-	uint32_t crtc_pixel_clock_in_khz,
-	uint32_t actual_pixel_clock_in_khz,
-	struct azalia_clock_info *azalia_clock_info)
-{
-	if (azalia_clock_info == NULL)
-		return false;
-
-	/* audio_dto_phase= 24 * 10,000;
-	 *   24MHz in [100Hz] units */
-	azalia_clock_info->audio_dto_phase =
-			24 * 10000;
-
-	/* audio_dto_module = PCLKFrequency * 10,000;
-	 *  [khz] -> [100Hz] */
-	azalia_clock_info->audio_dto_module =
-			actual_pixel_clock_in_khz * 10;
-
-	return true;
-}
-
-static bool get_azalia_clock_info_dp(
-	uint32_t requested_pixel_clock_in_khz,
-	const struct audio_pll_info *pll_info,
-	struct azalia_clock_info *azalia_clock_info)
-{
-	if (pll_info == NULL || azalia_clock_info == NULL)
-		return false;
-
-	/* Reported dpDtoSourceClockInkhz value for
-	 * DCE8 already adjusted for SS, do not need any
-	 * adjustment here anymore
-	 */
-
-	/*audio_dto_phase = 24 * 10,000;
-	 * 24MHz in [100Hz] units */
-	azalia_clock_info->audio_dto_phase = 24 * 10000;
-
-	/*audio_dto_module = dpDtoSourceClockInkhz * 10,000;
-	 *  [khz] ->[100Hz] */
-	azalia_clock_info->audio_dto_module =
-		pll_info->dp_dto_source_clock_in_khz * 10;
-
-	return true;
-}
-
-void dce110_aud_wall_dto_setup(
-	struct audio *audio,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_pll_info *pll_info)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	struct azalia_clock_info clock_info = { 0 };
-
-	if (dc_is_hdmi_signal(signal)) {
-		uint32_t src_sel;
-
-		/*DTO0 Programming goal:
-		-generate 24MHz, 128*Fs from 24MHz
-		-use DTO0 when an active HDMI port is connected
-		(optionally a DP is connected) */
-
-		/* calculate DTO settings */
-		get_azalia_clock_info_hdmi(
-			crtc_info->requested_pixel_clock,
-			crtc_info->calculated_pixel_clock,
-			&clock_info);
-
-		/* On TN/SI, Program DTO source select and DTO select before
-		programming DTO modulo and DTO phase. These bits must be
-		programmed first, otherwise there will be no HDMI audio at boot
-		up. This is a HW sequence change (different from old ASICs).
-		Caution when changing this programming sequence.
-
-		HDMI enabled, using DTO0
-		program master CRTC for DTO0 */
-		src_sel = pll_info->dto_source - DTO_SOURCE_ID0;
-		REG_UPDATE_N(DCCG_AUDIO_DTO_SOURCE, 2,
-			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO0_SOURCE_SEL), src_sel,
-			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO_SEL), 0);
-
-		/* module */
-		REG_UPDATE(DCCG_AUDIO_DTO0_MODULE,
-			DCCG_AUDIO_DTO0_MODULE, clock_info.audio_dto_module);
-
-		/* phase */
-		REG_UPDATE(DCCG_AUDIO_DTO0_PHASE,
-			DCCG_AUDIO_DTO0_PHASE, clock_info.audio_dto_phase);
-	} else {
-		/*DTO1 Programming goal:
-		-generate 24MHz, 512*Fs, 128*Fs from 24MHz
-		-default is to used DTO1, and switch to DTO0 when an audio
-		master HDMI port is connected
-		-use as default for DP
-
-		calculate DTO settings */
-		get_azalia_clock_info_dp(
-			crtc_info->requested_pixel_clock,
-			pll_info,
-			&clock_info);
-
-		/* Program DTO select before programming DTO modulo and DTO
-		phase. default to use DTO1 */
-
-		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
-				DCCG_AUDIO_DTO_SEL, 1);
-
-		REG_UPDATE_N(DCCG_AUDIO_DTO_SOURCE, 1,
-			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO_SEL), 1);
-			/* FD(DCCG_AUDIO_DTO2_USE_512FBR_DTO), 1)
-			 * Select 512fs for DP TODO: web register definition
-			 * does not match register header file
-			 * DCE11 version it's commented out while DCE8 it's set to 1
-			*/
-
-		/* module */
-		REG_UPDATE(DCCG_AUDIO_DTO1_MODULE,
-				DCCG_AUDIO_DTO1_MODULE, clock_info.audio_dto_module);
-
-		/* phase */
-		REG_UPDATE(DCCG_AUDIO_DTO1_PHASE,
-				DCCG_AUDIO_DTO1_PHASE, clock_info.audio_dto_phase);
-
-		/* DAL2 code separate DCCG_AUDIO_DTO_SEL and
-		DCCG_AUDIO_DTO2_USE_512FBR_DTO programming into two different
-		location. merge together should not hurt */
-		/*value.bits.DCCG_AUDIO_DTO2_USE_512FBR_DTO = 1;
-		dal_write_reg(mmDCCG_AUDIO_DTO_SOURCE, value);*/
-	}
-}
-
-/* initialize HW state */
-void dce110_aud_hw_init(
-		struct audio *audio)
-{
-	struct audio_dce110 *aud110 = DCE110_AUD(audio);
-
-	/* we only need to program the following registers once, so we only do
-	it for the inst 0*/
-	if (audio->inst != 0)
-		return;
-
-	/* Suport R5 - 32khz
-	 * Suport R6 - 44.1khz
-	 * Suport R7 - 48khz
-	 */
-	REG_UPDATE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES,
-			AUDIO_RATE_CAPABILITIES, 0x70);
-
-	/*Keep alive bit to verify HW block in BU. */
-	REG_UPDATE_N(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES, 2,
-			FD(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES__CLKSTOP), 1,
-			FD(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES__EPSS), 1);
-}
-
-static const struct audio_funcs funcs = {
-	.destroy = destroy,
-	.hw_init = dce110_aud_hw_init,
-	.wall_dto_setup = dce110_aud_wall_dto_setup,
-	.az_enable = dce110_aud_az_enable,
-	.az_disable = dce110_aud_az_disable,
-	.az_configure = dce110_aud_az_configure,
-};
-
-static bool construct(
-	struct audio_dce110 *audio,
-	const struct audio_init_data *init_data)
-{
-	struct audio *base = &audio->base;
-
-	/* base audio construct*/
-	if (!dal_audio_construct_base(base, init_data))
-		return false;
-
-	/*vtable methods*/
-	base->funcs = &funcs;
-	return true;
-}
-
-/* --- audio scope functions  --- */
-
-struct audio *dal_audio_create_dce110(
-	const struct audio_init_data *init_data)
-{
-	/*allocate memory for audio_dce110 */
-	struct audio_dce110 *audio = dm_alloc(sizeof(*audio));
-
-	if (audio == NULL) {
-		ASSERT_CRITICAL(audio);
-		return NULL;
-	}
-
-	audio->regs = init_data->reg;
-
-	/*pointer to base_audio_block of audio_dce110 ==> audio base object */
-	if (construct(audio, init_data))
-		return &audio->base;
-
-	dal_logger_write(
-		init_data->ctx->logger,
-		LOG_MAJOR_ERROR,
-		LOG_MINOR_COMPONENT_AUDIO,
-		"Failed to create audio object for DCE11\n");
-
-	 /*release memory allocated if fail */
-	dm_free(audio);
-	return NULL;
-}
-
-/* Do not need expose construct_dce110 and destruct_dce110 becuase there is
- *derived object after dce110
- */
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h b/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
deleted file mode 100644
index 545d2a0..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/audio_dce110.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#ifndef __DAL_AUDIO_DCE_110_H__
-#define __DAL_AUDIO_DCE_110_H__
-
-#include "audio/audio.h"
-#include "audio/hw_ctx_audio.h"
-#include "audio/dce110/hw_ctx_audio_dce110.h"
-
-#define AUD_REG(reg_name, block_prefix, id)\
-	.reg_name = block_prefix ## id ## _ ## reg_name
-
-#define MM_REG(reg_name)\
-	.reg_name = mm ## reg_name
-
-#define AUD_COMMON_REG_LIST_BASE(id)\
-	SE_REG(AZALIA_F0_CODEC_ENDPOINT_INDEX, mmAZF0ENDPOINT, id),\
-	SE_REG(AZALIA_F0_CODEC_ENDPOINT_DATA, mmAZF0ENDPOINT, id),\
-	MM_REG(AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS),\
-	MM_REG(AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES),\
-	MM_REG(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES),\
-	MM_REG(DCCG_AUDIO_DTO_SOURCE),\
-	MM_REG(DCCG_AUDIO_DTO0_MODULE),\
-	MM_REG(DCCG_AUDIO_DTO0_PHASE),\
-	MM_REG(DCCG_AUDIO_DTO1_MODULE),\
-	MM_REG(DCCG_AUDIO_DTO1_PHASE)
-
-#define AUD_COMMON_REG_LIST(id)\
-	AUD_COMMON_REG_LIST_BASE(id)
-
-
-struct dce110_audio_registers {
-	uint32_t AZALIA_F0_CODEC_ENDPOINT_INDEX;
-	uint32_t AZALIA_F0_CODEC_ENDPOINT_DATA;
-
-	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS;
-	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES;
-	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES;
-
-	uint32_t DCCG_AUDIO_DTO_SOURCE;
-	uint32_t DCCG_AUDIO_DTO0_MODULE;
-	uint32_t DCCG_AUDIO_DTO0_PHASE;
-	uint32_t DCCG_AUDIO_DTO1_MODULE;
-	uint32_t DCCG_AUDIO_DTO1_PHASE;
-};
-
-struct audio_dce110 {
-	struct audio base;
-	const struct dce110_audio_registers *regs;
-	/* dce-specific members are following */
-	/* none */
-};
-
-struct audio *dal_audio_create_dce110(const struct audio_init_data *init_data);
-
-void dce110_aud_hw_init(struct audio *audio);
-
-void dce110_aud_az_enable(struct audio *audio);
-void dce110_aud_az_disable(struct audio *audio);
-
-void dce110_aud_az_configure(struct audio *audio,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_info *audio_info);
-
-void dce110_aud_wall_dto_setup(struct audio *audio,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_pll_info *pll_info);
-
-#endif   /*__DAL_AUDIO_DCE_110_H__*/
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
deleted file mode 100644
index 50ad162..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.c
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "include/logger_interface.h"
-#include "../hw_ctx_audio.h"
-#include "hw_ctx_audio_dce110.h"
-
-#include "dce/dce_11_0_d.h"
-#include "dce/dce_11_0_sh_mask.h"
-
-#define FROM_BASE(ptr) \
-	container_of((ptr), struct hw_ctx_audio_dce110, base)
-
-#define DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT 0x8000
-#define DP_AUDIO_DTO_MODULE_WITHOUT_SS 360
-#define DP_AUDIO_DTO_PHASE_WITHOUT_SS 24
-
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUDIO_FRONT_END 0
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC 1
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__REGISTER_PROGRAMMABLE 2
-
-#define FIRST_AUDIO_STREAM_ID 1
-
-#define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_AUDIO, \
-			"Audio:%s()\n", __func__)
-
-
-static void destroy(
-	struct hw_ctx_audio **ptr)
-{
-	struct hw_ctx_audio_dce110 *hw_ctx_dce110;
-
-	hw_ctx_dce110 = container_of(
-		*ptr, struct hw_ctx_audio_dce110, base);
-
-	/* release memory allocated for struct hw_ctx_audio_dce110 */
-	dm_free(hw_ctx_dce110);
-
-	*ptr = NULL;
-}
-
-/* initialize HW state */
-static void hw_initialize(
-	const struct hw_ctx_audio *hw_ctx)
-{
-	uint32_t stream_id = FROM_BASE(hw_ctx)->azalia_stream_id;
-	uint32_t addr;
-
-	/* we only need to program the following registers once, so we only do
-	it for the first audio stream.*/
-	if (stream_id != FIRST_AUDIO_STREAM_ID)
-		return;
-
-	/* Suport R5 - 32khz
-	 * Suport R6 - 44.1khz
-	 * Suport R7 - 48khz
-	 */
-	addr = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES;
-	{
-		uint32_t value;
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 0x70,
-		AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES,
-		AUDIO_RATE_CAPABILITIES);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/*Keep alive bit to verify HW block in BU. */
-	addr = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES;
-	{
-		uint32_t value;
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 1,
-		AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
-		CLKSTOP);
-
-		set_reg_field_value(value, 1,
-		AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
-		EPSS);
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-}
-
-static const struct hw_ctx_audio_funcs funcs = {
-	.destroy = destroy,
-	.hw_initialize =
-		hw_initialize,
-};
-
-static bool construct(
-	struct hw_ctx_audio_dce110 *hw_ctx,
-	uint8_t azalia_stream_id,
-	struct dc_context *ctx)
-{
-	struct hw_ctx_audio *base = &hw_ctx->base;
-
-	base->funcs = &funcs;
-
-	/* save audio endpoint or dig front for current dce110 audio object */
-	hw_ctx->azalia_stream_id = azalia_stream_id;
-	hw_ctx->base.ctx = ctx;
-
-	/* azalia audio endpoints register offsets. azalia is associated with
-	DIG front. save AUDIO register offset */
-	switch (azalia_stream_id) {
-	case 1: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 2: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT1_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT1_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 3: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT2_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT2_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 4: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT3_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT3_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	default:
-		dal_logger_write(
-			hw_ctx->base.ctx->logger,
-			LOG_MAJOR_WARNING,
-			LOG_MINOR_COMPONENT_AUDIO,
-			"Invalid Azalia stream ID!");
-		break;
-	}
-
-	return true;
-}
-
-/* audio_dce110 is derived from audio directly, not via dce80  */
-struct hw_ctx_audio *dal_hw_ctx_audio_dce110_create(
-	struct dc_context *ctx,
-	uint32_t azalia_stream_id)
-{
-	/* allocate memory for struc hw_ctx_audio_dce110 */
-	struct hw_ctx_audio_dce110 *hw_ctx_dce110 =
-			dm_alloc(sizeof(struct hw_ctx_audio_dce110));
-
-	if (!hw_ctx_dce110) {
-		ASSERT_CRITICAL(hw_ctx_dce110);
-		return NULL;
-	}
-
-	/*return pointer to hw_ctx_audio back to caller  -- audio object */
-	if (construct(
-			hw_ctx_dce110, azalia_stream_id, ctx))
-		return &hw_ctx_dce110->base;
-
-	dal_logger_write(
-		ctx->logger,
-		LOG_MAJOR_ERROR,
-		LOG_MINOR_COMPONENT_AUDIO,
-		"Failed to create hw_ctx_audio for DCE11\n");
-
-	dm_free(hw_ctx_dce110);
-
-	return NULL;
-}
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.h b/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.h
deleted file mode 100644
index 1ad3826..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce110/hw_ctx_audio_dce110.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_HW_CTX_AUDIO_DCE110_H__
-#define __DAL_HW_CTX_AUDIO_DCE110_H__
-
-#include "audio/hw_ctx_audio.h"
-
-struct hw_ctx_audio_dce110 {
-	struct hw_ctx_audio base;
-
-	/* azalia stream id 1 based indexing, corresponding to audio GO enumId*/
-	uint32_t azalia_stream_id;
-
-	/* azalia stream endpoint register offsets */
-	struct azalia_reg_offsets az_mm_reg_offsets;
-
-	/* audio encoder block MM register offset -- associate with DIG FRONT */
-};
-
-struct hw_ctx_audio *dal_hw_ctx_audio_dce110_create(
-	struct dc_context *ctx,
-	uint32_t azalia_stream_id);
-
-#endif  /* __DAL_HW_CTX_AUDIO_DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
deleted file mode 100644
index bea346c..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.c
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "include/logger_interface.h"
-
-#include "audio_dce80.h"
-#include "../dce110/audio_dce110.h"
-
-/***** static functions  *****/
-
-static void destruct(struct audio_dce110 *audio)
-{
-	/*release memory allocated for hw_ctx -- allocated is initiated
-	 *by audio_dce80 power_up
-	 *audio->base->hw_ctx = NULL is done within hw-ctx->destroy
-	 */
-	if (audio->base.hw_ctx)
-		audio->base.hw_ctx->funcs->destroy(&(audio->base.hw_ctx));
-
-	/* reset base_audio_block */
-	dal_audio_destruct_base(&audio->base);
-}
-
-static void destroy(struct audio **ptr)
-{
-	struct audio_dce110 *audio = NULL;
-
-	audio = container_of(*ptr, struct audio_dce110, base);
-
-	destruct(audio);
-
-	/* release memory allocated for audio_dce110*/
-	dm_free(audio);
-	*ptr = NULL;
-}
-
-/**
-* initialize
-*
-* @brief
-*  Perform SW initialization - create audio hw context. Then do HW
-*  initialization. this function is called at dal_audio_power_up.
-*
-* @param
-*  NONE
-*/
-static enum audio_result initialize(
-	struct audio *audio)
-{
-	uint8_t audio_endpoint_enum_id = 0;
-
-	audio_endpoint_enum_id = audio->id.enum_id;
-
-	/* HW CTX already create*/
-	if (audio->hw_ctx != NULL)
-		return AUDIO_RESULT_OK;
-
-	audio->hw_ctx = dal_audio_create_hw_ctx_audio_dce80(
-			audio->ctx,
-			audio_endpoint_enum_id);
-
-	if (audio->hw_ctx == NULL)
-		return AUDIO_RESULT_ERROR;
-
-	/* override HW default settings */
-	audio->hw_ctx->funcs->hw_initialize(audio->hw_ctx);
-
-	return AUDIO_RESULT_OK;
-}
-
-static const struct audio_funcs funcs = {
-	.destroy = destroy,
-	.hw_init = dce110_aud_hw_init,
-	.wall_dto_setup = dce110_aud_wall_dto_setup,
-	.az_enable = dce110_aud_az_enable,
-	.az_disable = dce110_aud_az_disable,
-	.az_configure = dce110_aud_az_configure,
-};
-
-static bool construct(
-	struct audio_dce110 *audio,
-	const struct audio_init_data *init_data)
-{
-	struct audio *base = &audio->base;
-
-	/* base audio construct*/
-	if (!dal_audio_construct_base(base, init_data))
-		return false;
-
-	/*vtable methods*/
-	base->funcs = &funcs;
-	return true;
-}
-
-/* --- audio scope functions  --- */
-
-struct audio *dal_audio_create_dce80(
-	const struct audio_init_data *init_data)
-{
-	/*allocate memory for audio_dce110 */
-	struct audio_dce110 *audio = dm_alloc(sizeof(struct audio_dce110));
-
-	if (audio == NULL)
-		return NULL;
-
-	audio->regs = init_data->reg;
-
-	/*pointer to base_audio_block of audio_dce110 ==> audio base object */
-	if (construct(audio, init_data))
-		return &audio->base;
-
-	 /*release memory allocated if fail */
-	dm_free(audio);
-	return NULL;
-}
-
-/* Do not need expose construct_dce80 and destruct_dce80 becuase there is
- *derived object after dce80
- */
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h b/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
deleted file mode 100644
index 9ecd076..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/audio_dce80.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#ifndef __DAL_AUDIO_80__
-#define __DAL_AUDIO_80__
-
-#include "audio/audio.h"
-#include "audio/hw_ctx_audio.h"
-#include "audio/dce80/hw_ctx_audio_dce80.h"
-
-struct audio *dal_audio_create_dce80(const struct audio_init_data *init_data);
-
-#endif   /* __DAL_AUDIO_80__  */
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
deleted file mode 100644
index f7554fd4..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "include/logger_interface.h"
-#include "../hw_ctx_audio.h"
-#include "dce/dce_8_0_d.h"
-#include "dce/dce_8_0_sh_mask.h"
-#include "hw_ctx_audio_dce80.h"
-
-#define FROM_BASE(ptr) \
-	container_of((ptr), struct hw_ctx_audio_dce80, base)
-
-#define DP_SEC_AUD_N__DP_SEC_AUD_N__DEFAULT 0x8000
-#define DP_AUDIO_DTO_MODULE_WITHOUT_SS 360
-#define DP_AUDIO_DTO_PHASE_WITHOUT_SS 24
-
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUDIO_FRONT_END 0
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__AUTO_CALC 1
-#define DP_SEC_TIMESTAMP__DP_SEC_TIMESTAMP_MODE__REGISTER_PROGRAMMABLE 2
-
-#define FIRST_AUDIO_STREAM_ID 1
-
-/* --- static functions --- */
-
-/* static void dal_audio_destruct_hw_ctx_audio_dce80(
-	struct hw_ctx_audio_dce80 *ctx);*/
-
-static void destroy(
-	struct hw_ctx_audio **ptr)
-{
-	struct hw_ctx_audio_dce80 *hw_ctx_dce80;
-
-	hw_ctx_dce80 = container_of(
-		*ptr, struct hw_ctx_audio_dce80, base);
-
-	/* release memory allocated for struct hw_ctx_audio_dce80 */
-	dm_free(hw_ctx_dce80);
-
-	*ptr = NULL;
-}
-
-/* initialize HW state */
-static void hw_initialize(
-	const struct hw_ctx_audio *hw_ctx)
-{
-	uint32_t stream_id = FROM_BASE(hw_ctx)->azalia_stream_id;
-	uint32_t addr;
-
-	/* we only need to program the following registers once, so we only do
-	it for the first audio stream.*/
-	if (stream_id != FIRST_AUDIO_STREAM_ID)
-		return;
-
-	/* Suport R5 - 32khz
-	 * Suport R6 - 44.1khz
-	 * Suport R7 - 48khz
-	 */
-	addr = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES;
-	{
-		uint32_t value;
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 0x70,
-		AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES,
-		AUDIO_RATE_CAPABILITIES);
-
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-
-	/*Keep alive bit to verify HW block in BU. */
-	addr = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES;
-	{
-		uint32_t value;
-
-		value = dm_read_reg(hw_ctx->ctx, addr);
-
-		set_reg_field_value(value, 1,
-		AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
-		CLKSTOP);
-
-		set_reg_field_value(value, 1,
-		AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES,
-		EPSS);
-		dm_write_reg(hw_ctx->ctx, addr, value);
-	}
-}
-
-static const struct hw_ctx_audio_funcs funcs = {
-	.destroy = destroy,
-	.hw_initialize =
-		hw_initialize,
-};
-
-bool dal_audio_construct_hw_ctx_audio_dce80(
-	struct hw_ctx_audio_dce80 *hw_ctx,
-	uint8_t azalia_stream_id,
-	struct dc_context *ctx)
-{
-	struct hw_ctx_audio *base = &hw_ctx->base;
-
-	base->funcs = &funcs;
-
-	/* save audio endpoint or dig front for current dce80 audio object */
-	hw_ctx->azalia_stream_id = azalia_stream_id;
-	hw_ctx->base.ctx = ctx;
-
-	/* azalia audio endpoints register offsets. azalia is associated with
-	DIG front. save AUDIO register offset */
-	switch (azalia_stream_id) {
-	case 1: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT0_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 2: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT1_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT1_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 3: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT2_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT2_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 4: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT3_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT3_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 5: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT4_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT4_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 6: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT5_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT5_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	case 7: {
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_index =
-			mmAZF0ENDPOINT6_AZALIA_F0_CODEC_ENDPOINT_INDEX;
-			hw_ctx->az_mm_reg_offsets.
-			azf0endpointx_azalia_f0_codec_endpoint_data =
-			mmAZF0ENDPOINT6_AZALIA_F0_CODEC_ENDPOINT_DATA;
-		}
-		break;
-	default:
-		/*DALASSERT_MSG(false,("Invalid Azalia stream ID!"));*/
-		BREAK_TO_DEBUGGER();
-		break;
-	}
-
-	return true;
-}
-
-struct hw_ctx_audio *dal_audio_create_hw_ctx_audio_dce80(
-	struct dc_context *ctx,
-	uint32_t azalia_stream_id)
-{
-	/* allocate memory for struc hw_ctx_audio_dce80 */
-	struct hw_ctx_audio_dce80 *hw_ctx_dce80 =
-			dm_alloc(sizeof(struct hw_ctx_audio_dce80));
-
-	if (!hw_ctx_dce80) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	/*return pointer to hw_ctx_audio back to caller  -- audio object */
-	if (dal_audio_construct_hw_ctx_audio_dce80(
-			hw_ctx_dce80, azalia_stream_id, ctx))
-		return &hw_ctx_dce80->base;
-
-	BREAK_TO_DEBUGGER();
-
-	dm_free(hw_ctx_dce80);
-
-	return NULL;
-}
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h b/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h
deleted file mode 100644
index 51b467b..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/dce80/hw_ctx_audio_dce80.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_HW_CTX_AUDIO_DCE80_H__
-#define __DAL_HW_CTX_AUDIO_DCE80_H__
-
-#include "audio/hw_ctx_audio.h"
-
-struct hw_ctx_audio_dce80 {
-	struct hw_ctx_audio base;
-
-	/* azalia stream id 1 based indexing, corresponding to audio GO enumId*/
-	uint32_t azalia_stream_id;
-
-	/* azalia stream endpoint register offsets */
-	struct azalia_reg_offsets az_mm_reg_offsets;
-
-	/* audio encoder block MM register offset -- associate with DIG FRONT */
-};
-
-/* ---  helpers ---  all static functions*/
-/*set_high_bit_rate_capable
-set_hbr_channel_count
-set_compressed_audio_channel_count
-set_video_latency
-set_audio_latency
-enable_hw_sw_sync
-disable_hw_sw_sync
-update_sw_write_ptr
-update_av_association
-write_indirect_azalia_reg
-read_indirect_azalia_reg
-*/
-
-/* in case dce83 may derived from dce80, expose dce80 constructor
-*and destroy for derived */
-bool dal_audio_construct_hw_ctx_audio_dce80(
-	struct hw_ctx_audio_dce80 *hw_ctx,
-	uint8_t azalia_stream_id,
-	struct dc_context *ctx);
-
-void dal_audio_destruct_hw_ctx_audio_dce80(
-	struct hw_ctx_audio_dce80 *hw_ctx);
-
-struct hw_ctx_audio *dal_audio_create_hw_ctx_audio_dce80(
-	struct dc_context *ctx,
-	uint32_t azalia_stream_id);
-
-#endif  /* __DAL_HW_CTX_AUDIO_DCE80_H__ */
-
diff --git a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h b/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
deleted file mode 100644
index 1fbb526..0000000
--- a/drivers/gpu/drm/amd/dal/dc/audio/hw_ctx_audio.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_HW_CTX_AUDIO_H__
-#define __DAL_HW_CTX_AUDIO_H__
-
-#include "include/audio_interface.h"
-#include "include/link_service_types.h"
-
-struct hw_ctx_audio;
-
-struct azalia_reg_offsets {
-	uint32_t azf0endpointx_azalia_f0_codec_endpoint_index;
-	uint32_t azf0endpointx_azalia_f0_codec_endpoint_data;
-};
-
-/***** hook functions *****/
-
-struct hw_ctx_audio_funcs {
-
-	/* functions for hw_ctx creation */
-	void (*destroy)(
-		struct hw_ctx_audio **ptr);
-
-	/***** from dal2 hwcontextaudio.hpp *****/
-
-	/* MM register access  read_register  write_register */
-
-	/* initialize HW state */
-	void (*hw_initialize)(
-		const struct hw_ctx_audio *hw_ctx);
-
-	/* check_audio_bandwidth */
-
-	/* ~~~~  protected: ~~~~*/
-
-	/* calc_max_audio_packets_per_line */
-	/* speakers_to_channels */
-	/* is_audio_format_supported */
-	/* get_audio_clock_info */
-
-	/* @@@@   private:  @@@@  */
-
-	/* check_audio_bandwidth_hdmi  */
-	/* check_audio_bandwidth_dpsst */
-	/* check_audio_bandwidth_dpmst */
-
-};
-
-struct hw_ctx_audio {
-	const struct hw_ctx_audio_funcs *funcs;
-	struct dc_context *ctx;
-
-	/*audio_clock_infoTable[12];
-	 *audio_clock_infoTable_36bpc[12];
-	 *audio_clock_infoTable_48bpc[12];
-	 *used by hw_ctx_audio.c file only. Will declare as static array
-	 *azaliaclockinfoTable[12]  -- not used
-	 *BusNumberMask;   BusNumberShift; DeviceNumberMask;
-	 *not used by dce6 and after
-	 */
-};
-
-/* --- object construct, destruct --- */
-
-/*
- *called by derived audio object for specific ASIC. In case no derived object,
- *these two functions do not need exposed.
- */
-bool dal_audio_construct_hw_ctx_audio(
-	struct hw_ctx_audio *hw_ctx);
-
-
-#endif  /* __DAL_HW_CTX_AUDIO_H__ */
-
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 5e95c2a..ae34228 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -35,7 +35,6 @@
 #include "dc_link_ddc.h"
 #include "link_hwss.h"
 #include "stream_encoder.h"
-#include "audio/audio.h"
 #include "link_encoder.h"
 #include "hw_sequencer.h"
 #include "fixed31_32.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index 7671c44..c914876 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -32,6 +32,7 @@
 #include "timing_generator.h"
 #include "transform.h"
 #include "set_mode_types.h"
+#include "adapter_service_interface.h"
 
 #if defined(CONFIG_DRM_AMD_DAL_DCE8_0)
 #include "dce80/dce80_resource.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index 9bcad48..bddeb66 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -22,7 +22,6 @@
  * Authors: AMD
  *
  */
-
 #include "dm_services.h"
 
 #include "link_encoder.h"
@@ -30,6 +29,7 @@
 
 #include "resource.h"
 #include "include/irq_service_interface.h"
+#include "include/adapter_service_interface.h"
 #include "../virtual/virtual_stream_encoder.h"
 #include "dce110/dce110_resource.h"
 #include "dce110/dce110_timing_generator.h"
@@ -42,8 +42,7 @@
 #include "dce110/dce110_stream_encoder.h"
 #include "dce110/dce110_opp.h"
 #include "dce110/dce110_clock_source.h"
-#include "audio/dce110/audio_dce110.h"
-
+#include "dce110/audio_dce110.h"
 #include "dce100/dce100_hw_sequencer.h"
 #include "dce/dce_10_0_d.h"
 
@@ -531,60 +530,60 @@ void dce100_clock_source_destroy(struct clock_source **clk_src)
 	*clk_src = NULL;
 }
 
-void dce100_destruct_resource_pool(struct resource_pool *pool)
+static void destruct(struct dce110_resource_pool *pool)
 {
-	unsigned int i;
+        unsigned int i;
 
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce100_opp_destroy(&pool->opps[i]);
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce100_opp_destroy(&pool->base.opps[i]);
 
-		if (pool->transforms[i] != NULL)
-			dce100_transform_destroy(&pool->transforms[i]);
+                if (pool->base.transforms[i] != NULL)
+                        dce100_transform_destroy(&pool->base.transforms[i]);
 
-		if (pool->ipps[i] != NULL)
-			dce110_ipp_destroy(&pool->ipps[i]);
+                if (pool->base.ipps[i] != NULL)
+                        dce110_ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
 
-		if (pool->timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+                if (pool->base.timing_generators[i] != NULL)    {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL)
-			dce100_clock_source_destroy(&pool->clock_sources[i]);
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL)
+                        dce100_clock_source_destroy(&pool->base.clock_sources[i]);
+        }
 
-	if (pool->dp_clock_source != NULL)
-		dce100_clock_source_destroy(&pool->dp_clock_source);
+        if (pool->base.dp_clock_source != NULL)
+                dce100_clock_source_destroy(&pool->base.dp_clock_source);
 
-	for (i = 0; i < pool->audio_count; i++)	{
-		if (pool->audios[i] != NULL)
-			dal_audio_destroy(&pool->audios[i]);
-	}
+        for (i = 0; i < pool->base.audio_count; i++)    {
+                if (pool->base.audios[i] != NULL)
+                        dce110_aud_destroy(&pool->base.audios[i]);
+        }
 
-	if (pool->display_clock != NULL)
-		dal_display_clock_destroy(&pool->display_clock);
+        if (pool->base.display_clock != NULL)
+                dal_display_clock_destroy(&pool->base.display_clock);
 
-	if (pool->scaler_filter != NULL)
-		dal_scaler_filter_destroy(&pool->scaler_filter);
+        if (pool->base.scaler_filter != NULL)
+                dal_scaler_filter_destroy(&pool->base.scaler_filter);
 
-	if (pool->irqs != NULL)
-		dal_irq_service_destroy(&pool->irqs);
+        if (pool->base.irqs != NULL)
+                dal_irq_service_destroy(&pool->base.irqs);
 
-	if (pool->adapter_srv != NULL)
-		dal_adapter_service_destroy(&pool->adapter_srv);
+        if (pool->base.adapter_srv != NULL)
+                dal_adapter_service_destroy(&pool->base.adapter_srv);
 }
 
 static enum dc_status validate_mapped_resource(
@@ -924,7 +923,6 @@ static bool construct(
                         break;
                 }
 
-                audio_init_data.audio_stream_id = obj_id;
                 audio_init_data.inst = i;
                 audio_init_data.reg = &audio_regs[i];
 
@@ -980,7 +978,7 @@ stream_enc_create_fail:
 audio_create_fail:
         for (i = 0; i < pool->base.pipe_count; i++) {
                 if (pool->base.audios[i] != NULL)
-                        dal_audio_destroy(&pool->base.audios[i]);
+                        dce110_aud_destroy(&pool->base.audios[i]);
         }
 
 controller_create_fail:
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/Makefile b/drivers/gpu/drm/amd/dal/dc/dce110/Makefile
index 170c273..060756d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/Makefile
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the 'controller' sub-component of DAL.
 # It provides the control and status of HW CRTC block.
 
-DCE110 = dce110_ipp.o dce110_ipp_cursor.o \
+DCE110 = dce110_audio.o dce110_ipp.o dce110_ipp_cursor.o \
 dce110_ipp_gamma.o dce110_link_encoder.o dce110_opp.o \
 dce110_opp_formatter.o dce110_opp_regamma.o dce110_stream_encoder.o \
 dce110_timing_generator.o dce110_transform.o dce110_transform_v.o \
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h b/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h
new file mode 100644
index 0000000..d0e257c
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/audio_dce110.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+#ifndef __DAL_AUDIO_DCE_110_H__
+#define __DAL_AUDIO_DCE_110_H__
+
+#include "audio.h"
+
+#define AUD_REG(reg_name, block_prefix, id)\
+	.reg_name = block_prefix ## id ## _ ## reg_name
+
+#define MM_REG(reg_name)\
+	.reg_name = mm ## reg_name
+
+#define AUD_COMMON_REG_LIST_BASE(id)\
+	SE_REG(AZALIA_F0_CODEC_ENDPOINT_INDEX, mmAZF0ENDPOINT, id),\
+	SE_REG(AZALIA_F0_CODEC_ENDPOINT_DATA, mmAZF0ENDPOINT, id),\
+	MM_REG(AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS),\
+	MM_REG(AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES),\
+	MM_REG(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES),\
+	MM_REG(DCCG_AUDIO_DTO_SOURCE),\
+	MM_REG(DCCG_AUDIO_DTO0_MODULE),\
+	MM_REG(DCCG_AUDIO_DTO0_PHASE),\
+	MM_REG(DCCG_AUDIO_DTO1_MODULE),\
+	MM_REG(DCCG_AUDIO_DTO1_PHASE)
+
+#define AUD_COMMON_REG_LIST(id)\
+	AUD_COMMON_REG_LIST_BASE(id)
+
+
+struct dce110_audio_registers {
+	uint32_t AZALIA_F0_CODEC_ENDPOINT_INDEX;
+	uint32_t AZALIA_F0_CODEC_ENDPOINT_DATA;
+
+	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS;
+	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES;
+	uint32_t AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES;
+
+	uint32_t DCCG_AUDIO_DTO_SOURCE;
+	uint32_t DCCG_AUDIO_DTO0_MODULE;
+	uint32_t DCCG_AUDIO_DTO0_PHASE;
+	uint32_t DCCG_AUDIO_DTO1_MODULE;
+	uint32_t DCCG_AUDIO_DTO1_PHASE;
+};
+
+struct audio_dce110 {
+	struct audio base;
+	const struct dce110_audio_registers *regs;
+	/* dce-specific members are following */
+	/* none */
+};
+
+struct audio *dal_audio_create_dce110(const struct audio_init_data *init_data);
+void dce110_aud_destroy(struct audio **audio);
+
+void dce110_aud_hw_init(struct audio *audio);
+
+void dce110_aud_az_enable(struct audio *audio);
+void dce110_aud_az_disable(struct audio *audio);
+
+void dce110_aud_az_configure(struct audio *audio,
+	enum signal_type signal,
+	const struct audio_crtc_info *crtc_info,
+	const struct audio_info *audio_info);
+
+void dce110_aud_wall_dto_setup(struct audio *audio,
+	enum signal_type signal,
+	const struct audio_crtc_info *crtc_info,
+	const struct audio_pll_info *pll_info);
+
+#endif   /*__DAL_AUDIO_DCE_110_H__*/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
new file mode 100644
index 0000000..be9b9af
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_audio.c
@@ -0,0 +1,953 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "audio_dce110.h"
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+
+
+#define DCE110_AUD(audio)\
+	container_of(audio, struct audio_dce110, base)
+
+#define CTX \
+	aud110->base.ctx
+
+#define REG(reg)\
+	(aud110->regs->reg)
+
+#define IX_REG(reg)\
+	ix ## reg
+
+
+#define REG_READ(reg_name) \
+		dm_read_reg(CTX, REG(reg_name))
+
+#define REG_WRITE(reg_name, value) \
+		dm_write_reg(CTX, REG(reg_name), value)
+
+#define REG_SET_N(reg_name, n, ...)	\
+		generic_reg_update_ex(CTX, \
+				REG(reg_name), \
+				0, \
+				n, __VA_ARGS__)
+
+#define REG_SET(reg_name, field, val)	\
+		REG_SET_N(reg_name, 1, FD(reg_name##__##field), val)
+
+#define REG_UPDATE_N(reg_name, n, ...)	\
+		generic_reg_update_ex(CTX, \
+				REG(reg_name), \
+				REG_READ(reg_name), \
+				n, __VA_ARGS__)
+
+#define REG_UPDATE(reg_name, field, val)	\
+		REG_UPDATE_N(reg_name, 1, FD(reg_name##__##field), val)
+
+#define AZ_REG_READ(reg_name) \
+		read_indirect_azalia_reg(audio, IX_REG(reg_name))
+
+#define AZ_REG_WRITE(reg_name, value) \
+		write_indirect_azalia_reg(audio, IX_REG(reg_name), value)
+
+
+static void write_indirect_azalia_reg(struct audio *audio,
+	uint32_t reg_index,
+	uint32_t reg_data)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
+	REG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX,
+			AZALIA_ENDPOINT_REG_INDEX, reg_index);
+
+	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
+	REG_SET(AZALIA_F0_CODEC_ENDPOINT_DATA,
+			AZALIA_ENDPOINT_REG_DATA, reg_data);
+
+	dal_logger_write(CTX->logger,
+		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_AUDIO,
+		"AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
+		reg_index, reg_data);
+}
+
+static uint32_t read_indirect_azalia_reg(struct audio *audio, uint32_t reg_index)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value = 0;
+
+	/* AZALIA_F0_CODEC_ENDPOINT_INDEX  endpoint index  */
+	REG_SET(AZALIA_F0_CODEC_ENDPOINT_INDEX,
+			AZALIA_ENDPOINT_REG_INDEX, reg_index);
+
+	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
+	value = REG_READ(AZALIA_F0_CODEC_ENDPOINT_DATA);
+
+	dal_logger_write(CTX->logger,
+		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_AUDIO,
+		"AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
+		reg_index, value);
+
+	return value;
+}
+
+static bool is_audio_format_supported(
+	const struct audio_info *audio_info,
+	enum audio_format_code audio_format_code,
+	uint32_t *format_index)
+{
+	uint32_t index;
+	uint32_t max_channe_index = 0;
+	bool found = false;
+
+	if (audio_info == NULL)
+		return found;
+
+	/* pass through whole array */
+	for (index = 0; index < audio_info->mode_count; index++) {
+		if (audio_info->modes[index].format_code == audio_format_code) {
+			if (found) {
+				/* format has multiply entries, choose one with
+				 *  highst number of channels */
+				if (audio_info->modes[index].channel_count >
+		audio_info->modes[max_channe_index].channel_count) {
+					max_channe_index = index;
+				}
+			} else {
+				/* format found, save it's index */
+				found = true;
+				max_channe_index = index;
+			}
+		}
+	}
+
+	/* return index */
+	if (found && format_index != NULL)
+		*format_index = max_channe_index;
+
+	return found;
+}
+
+/*For HDMI, calculate if specified sample rates can fit into a given timing */
+static void check_audio_bandwidth_hdmi(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	union audio_sample_rates *sample_rates)
+{
+	uint32_t samples;
+	uint32_t  h_blank;
+	bool limit_freq_to_48_khz = false;
+	bool limit_freq_to_88_2_khz = false;
+	bool limit_freq_to_96_khz = false;
+	bool limit_freq_to_174_4_khz = false;
+
+	/* For two channels supported return whatever sink support,unmodified*/
+	if (channel_count > 2) {
+
+		/* Based on HDMI spec 1.3 Table 7.5 */
+		if ((crtc_info->requested_pixel_clock <= 27000) &&
+		(crtc_info->v_active <= 576) &&
+		!(crtc_info->interlaced) &&
+		!(crtc_info->pixel_repetition == 2 ||
+		crtc_info->pixel_repetition == 4)) {
+			limit_freq_to_48_khz = true;
+
+		} else if ((crtc_info->requested_pixel_clock <= 27000) &&
+				(crtc_info->v_active <= 576) &&
+				(crtc_info->interlaced) &&
+				(crtc_info->pixel_repetition == 2)) {
+			limit_freq_to_88_2_khz = true;
+
+		} else if ((crtc_info->requested_pixel_clock <= 54000) &&
+				(crtc_info->v_active <= 576) &&
+				!(crtc_info->interlaced)) {
+			limit_freq_to_174_4_khz = true;
+		}
+	}
+
+	/* Also do some calculation for the available Audio Bandwidth for the
+	 * 8 ch (i.e. for the Layout 1 => ch > 2)
+	 */
+	h_blank = crtc_info->h_total - crtc_info->h_active;
+
+	if (crtc_info->pixel_repetition)
+		h_blank *= crtc_info->pixel_repetition;
+
+	/*based on HDMI spec 1.3 Table 7.5 */
+	h_blank -= 58;
+	/*for Control Period */
+	h_blank -= 16;
+
+	samples = h_blank * 10;
+	/* Number of Audio Packets (multiplied by 10) per Line (for 8 ch number
+	 * of Audio samples per line multiplied by 10 - Layout 1)
+	 */
+	 samples /= 32;
+	 samples *= crtc_info->v_active;
+	 /*Number of samples multiplied by 10, per second */
+	 samples *= crtc_info->refresh_rate;
+	 /*Number of Audio samples per second */
+	 samples /= 10;
+
+	 /* @todo do it after deep color is implemented
+	  * 8xx - deep color bandwidth scaling
+	  * Extra bandwidth is avaliable in deep color b/c link runs faster than
+	  * pixel rate. This has the effect of allowing more tmds characters to
+	  * be transmitted during blank
+	  */
+
+	switch (crtc_info->color_depth) {
+	case COLOR_DEPTH_888:
+		samples *= 4;
+		break;
+	case COLOR_DEPTH_101010:
+		samples *= 5;
+		break;
+	case COLOR_DEPTH_121212:
+		samples *= 6;
+		break;
+	default:
+		samples *= 4;
+		break;
+	}
+
+	samples /= 4;
+
+	/*check limitation*/
+	if (samples < 88200)
+		limit_freq_to_48_khz = true;
+	else if (samples < 96000)
+		limit_freq_to_88_2_khz = true;
+	else if (samples < 176400)
+		limit_freq_to_96_khz = true;
+	else if (samples < 192000)
+		limit_freq_to_174_4_khz = true;
+
+	if (sample_rates != NULL) {
+		/* limit frequencies */
+		if (limit_freq_to_174_4_khz)
+			sample_rates->rate.RATE_192 = 0;
+
+		if (limit_freq_to_96_khz) {
+			sample_rates->rate.RATE_192 = 0;
+			sample_rates->rate.RATE_176_4 = 0;
+		}
+		if (limit_freq_to_88_2_khz) {
+			sample_rates->rate.RATE_192 = 0;
+			sample_rates->rate.RATE_176_4 = 0;
+			sample_rates->rate.RATE_96 = 0;
+		}
+		if (limit_freq_to_48_khz) {
+			sample_rates->rate.RATE_192 = 0;
+			sample_rates->rate.RATE_176_4 = 0;
+			sample_rates->rate.RATE_96 = 0;
+			sample_rates->rate.RATE_88_2 = 0;
+		}
+	}
+}
+
+/*For DP SST, calculate if specified sample rates can fit into a given timing */
+static void check_audio_bandwidth_dpsst(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	union audio_sample_rates *sample_rates)
+{
+	/* do nothing */
+}
+
+/*For DP MST, calculate if specified sample rates can fit into a given timing */
+static void check_audio_bandwidth_dpmst(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	union audio_sample_rates *sample_rates)
+{
+	/* do nothing  */
+}
+
+static void check_audio_bandwidth(
+	const struct audio_crtc_info *crtc_info,
+	uint32_t channel_count,
+	enum signal_type signal,
+	union audio_sample_rates *sample_rates)
+{
+	switch (signal) {
+	case SIGNAL_TYPE_HDMI_TYPE_A:
+		check_audio_bandwidth_hdmi(
+			crtc_info, channel_count, sample_rates);
+		break;
+	case SIGNAL_TYPE_EDP:
+	case SIGNAL_TYPE_DISPLAY_PORT:
+		check_audio_bandwidth_dpsst(
+			crtc_info, channel_count, sample_rates);
+		break;
+	case SIGNAL_TYPE_DISPLAY_PORT_MST:
+		check_audio_bandwidth_dpmst(
+			crtc_info, channel_count, sample_rates);
+		break;
+	default:
+		break;
+	}
+}
+
+/* expose/not expose HBR capability to Audio driver */
+static void set_high_bit_rate_capable(
+	struct audio *audio,
+	bool capable)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+	uint32_t value = 0;
+
+	/* set high bit rate audio capable*/
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR);
+
+	set_reg_field_value(value, capable,
+		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR,
+		HBR_CAPABLE);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_HBR, value);
+}
+
+/* set video latency in in ms/2+1 */
+static void set_video_latency(
+	struct audio *audio,
+	int latency_in_ms)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value = 0;
+
+	if ((latency_in_ms < 0) || (latency_in_ms > 255))
+		return;
+
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
+
+	set_reg_field_value(value, latency_in_ms,
+		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		VIDEO_LIPSYNC);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		value);
+}
+
+/* set audio latency in in ms/2+1 */
+static void set_audio_latency(
+	struct audio *audio,
+	int latency_in_ms)
+{
+	uint32_t value = 0;
+
+	if (latency_in_ms < 0)
+		latency_in_ms = 0;
+
+	if (latency_in_ms > 255)
+		latency_in_ms = 255;
+
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC);
+
+	set_reg_field_value(value, latency_in_ms,
+		AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		AUDIO_LIPSYNC);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC,
+		value);
+}
+
+void dce110_aud_az_enable(struct audio *audio)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
+
+	if (get_reg_field_value(value,
+			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
+			AUDIO_ENABLED) != 1)
+		set_reg_field_value(value, 1,
+			AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
+			AUDIO_ENABLED);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
+}
+
+void dce110_aud_az_disable(struct audio *audio)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t value;
+
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
+
+	set_reg_field_value(value, 0,
+		AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,
+		AUDIO_ENABLED);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
+}
+
+void dce110_aud_az_configure(
+	struct audio *audio,
+	enum signal_type signal,
+	const struct audio_crtc_info *crtc_info,
+	const struct audio_info *audio_info)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	uint32_t speakers = audio_info->flags.info.ALLSPEAKERS;
+	uint32_t value;
+	uint32_t field = 0;
+	enum audio_format_code audio_format_code;
+	uint32_t format_index;
+	uint32_t index;
+	bool is_ac3_supported = false;
+	union audio_sample_rates sample_rate;
+	uint32_t strlen = 0;
+
+	/* Speaker Allocation */
+	/*
+	uint32_t value;
+	uint32_t field = 0;*/
+	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);
+
+	set_reg_field_value(value,
+		speakers,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		SPEAKER_ALLOCATION);
+
+	/* LFE_PLAYBACK_LEVEL = LFEPBL
+	 * LFEPBL = 0 : Unknown or refer to other information
+	 * LFEPBL = 1 : 0dB playback
+	 * LFEPBL = 2 : +10dB playback
+	 * LFE_BL = 3 : Reserved
+	 */
+	set_reg_field_value(value,
+		0,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		LFE_PLAYBACK_LEVEL);
+	/* todo: according to reg spec LFE_PLAYBACK_LEVEL is read only.
+	 *  why are we writing to it?  DCE8 does not write this */
+
+
+	set_reg_field_value(value,
+		0,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		HDMI_CONNECTION);
+
+	set_reg_field_value(value,
+		0,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		DP_CONNECTION);
+
+	field = get_reg_field_value(value,
+			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+			EXTRA_CONNECTION_INFO);
+
+	field &= ~0x1;
+
+	set_reg_field_value(value,
+		field,
+		AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+		EXTRA_CONNECTION_INFO);
+
+	/* set audio for output signal */
+	switch (signal) {
+	case SIGNAL_TYPE_HDMI_TYPE_A:
+		set_reg_field_value(value,
+			1,
+			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+			HDMI_CONNECTION);
+
+		break;
+
+	case SIGNAL_TYPE_EDP:
+	case SIGNAL_TYPE_DISPLAY_PORT:
+	case SIGNAL_TYPE_DISPLAY_PORT_MST:
+		set_reg_field_value(value,
+			1,
+			AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER,
+			DP_CONNECTION);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, value);
+
+	/*  Audio Descriptors   */
+	/* pass through all formats */
+	for (format_index = 0; format_index < AUDIO_FORMAT_CODE_COUNT;
+			format_index++) {
+		audio_format_code =
+			(AUDIO_FORMAT_CODE_FIRST + format_index);
+
+		/* those are unsupported, skip programming */
+		if (audio_format_code == AUDIO_FORMAT_CODE_1BITAUDIO ||
+			audio_format_code == AUDIO_FORMAT_CODE_DST)
+			continue;
+
+		value = 0;
+
+		/* check if supported */
+		if (is_audio_format_supported(
+				audio_info, audio_format_code, &index)) {
+			const struct audio_mode *audio_mode =
+					&audio_info->modes[index];
+			union audio_sample_rates sample_rates =
+					audio_mode->sample_rates;
+			uint8_t byte2 = audio_mode->max_bit_rate;
+
+			/* adjust specific properties */
+			switch (audio_format_code) {
+			case AUDIO_FORMAT_CODE_LINEARPCM: {
+				check_audio_bandwidth(
+					crtc_info,
+					audio_mode->channel_count,
+					signal,
+					&sample_rates);
+
+				byte2 = audio_mode->sample_size;
+
+				set_reg_field_value(value,
+						sample_rates.all,
+						AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+						SUPPORTED_FREQUENCIES_STEREO);
+				}
+				break;
+			case AUDIO_FORMAT_CODE_AC3:
+				is_ac3_supported = true;
+				break;
+			case AUDIO_FORMAT_CODE_DOLBYDIGITALPLUS:
+			case AUDIO_FORMAT_CODE_DTS_HD:
+			case AUDIO_FORMAT_CODE_MAT_MLP:
+			case AUDIO_FORMAT_CODE_DST:
+			case AUDIO_FORMAT_CODE_WMAPRO:
+				byte2 = audio_mode->vendor_specific;
+				break;
+			default:
+				break;
+			}
+
+			/* fill audio format data */
+			set_reg_field_value(value,
+					audio_mode->channel_count - 1,
+					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+					MAX_CHANNELS);
+
+			set_reg_field_value(value,
+					sample_rates.all,
+					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+					SUPPORTED_FREQUENCIES);
+
+			set_reg_field_value(value,
+					byte2,
+					AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0,
+					DESCRIPTOR_BYTE_2);
+		} /* if */
+
+		AZ_REG_WRITE(
+				AZALIA_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0 + format_index,
+				value);
+	} /* for */
+
+	if (is_ac3_supported)
+		/* todo: this reg global.  why program global register? */
+		REG_WRITE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_STREAM_FORMATS,
+				0x05);
+
+	/* check for 192khz/8-Ch support for HBR requirements */
+	sample_rate.all = 0;
+	sample_rate.rate.RATE_192 = 1;
+
+	check_audio_bandwidth(
+		crtc_info,
+		8,
+		signal,
+		&sample_rate);
+
+	set_high_bit_rate_capable(audio, sample_rate.rate.RATE_192);
+
+	/* Audio and Video Lipsync */
+	set_video_latency(audio, audio_info->video_latency);
+	set_audio_latency(audio, audio_info->audio_latency);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->manufacture_id,
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
+		MANUFACTURER_ID);
+
+	set_reg_field_value(value, audio_info->product_id,
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
+		PRODUCT_ID);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO0,
+		value);
+
+	value = 0;
+
+	/*get display name string length */
+	while (audio_info->display_name[strlen++] != '\0') {
+		if (strlen >=
+		MAX_HW_AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS)
+			break;
+		}
+	set_reg_field_value(value, strlen,
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
+		SINK_DESCRIPTION_LEN);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO1,
+		value);
+
+	/*
+	*write the port ID:
+	*PORT_ID0 = display index
+	*PORT_ID1 = 16bit BDF
+	*(format MSB->LSB: 8bit Bus, 5bit Device, 3bit Function)
+	*/
+
+	value = 0;
+
+	set_reg_field_value(value, audio_info->port_id[0],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2,
+		PORT_ID0);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO2, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->port_id[1],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3,
+		PORT_ID1);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO3, value);
+
+	/*write the 18 char monitor string */
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[0],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION0);
+
+	set_reg_field_value(value, audio_info->display_name[1],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION1);
+
+	set_reg_field_value(value, audio_info->display_name[2],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION2);
+
+	set_reg_field_value(value, audio_info->display_name[3],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4,
+		DESCRIPTION3);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO4, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[4],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION4);
+
+	set_reg_field_value(value, audio_info->display_name[5],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION5);
+
+	set_reg_field_value(value, audio_info->display_name[6],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION6);
+
+	set_reg_field_value(value, audio_info->display_name[7],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5,
+		DESCRIPTION7);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO5, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[8],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION8);
+
+	set_reg_field_value(value, audio_info->display_name[9],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION9);
+
+	set_reg_field_value(value, audio_info->display_name[10],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION10);
+
+	set_reg_field_value(value, audio_info->display_name[11],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6,
+		DESCRIPTION11);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO6, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[12],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION12);
+
+	set_reg_field_value(value, audio_info->display_name[13],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION13);
+
+	set_reg_field_value(value, audio_info->display_name[14],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION14);
+
+	set_reg_field_value(value, audio_info->display_name[15],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7,
+		DESCRIPTION15);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO7, value);
+
+	value = 0;
+	set_reg_field_value(value, audio_info->display_name[16],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
+		DESCRIPTION16);
+
+	set_reg_field_value(value, audio_info->display_name[17],
+		AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8,
+		DESCRIPTION17);
+
+	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_SINK_INFO8, value);
+}
+
+/*
+* todo: wall clk related functionality probably belong to clock_src.
+*/
+
+/* search pixel clock value for Azalia HDMI Audio */
+static bool get_azalia_clock_info_hdmi(
+	uint32_t crtc_pixel_clock_in_khz,
+	uint32_t actual_pixel_clock_in_khz,
+	struct azalia_clock_info *azalia_clock_info)
+{
+	if (azalia_clock_info == NULL)
+		return false;
+
+	/* audio_dto_phase= 24 * 10,000;
+	 *   24MHz in [100Hz] units */
+	azalia_clock_info->audio_dto_phase =
+			24 * 10000;
+
+	/* audio_dto_module = PCLKFrequency * 10,000;
+	 *  [khz] -> [100Hz] */
+	azalia_clock_info->audio_dto_module =
+			actual_pixel_clock_in_khz * 10;
+
+	return true;
+}
+
+static bool get_azalia_clock_info_dp(
+	uint32_t requested_pixel_clock_in_khz,
+	const struct audio_pll_info *pll_info,
+	struct azalia_clock_info *azalia_clock_info)
+{
+	if (pll_info == NULL || azalia_clock_info == NULL)
+		return false;
+
+	/* Reported dpDtoSourceClockInkhz value for
+	 * DCE8 already adjusted for SS, do not need any
+	 * adjustment here anymore
+	 */
+
+	/*audio_dto_phase = 24 * 10,000;
+	 * 24MHz in [100Hz] units */
+	azalia_clock_info->audio_dto_phase = 24 * 10000;
+
+	/*audio_dto_module = dpDtoSourceClockInkhz * 10,000;
+	 *  [khz] ->[100Hz] */
+	azalia_clock_info->audio_dto_module =
+		pll_info->dp_dto_source_clock_in_khz * 10;
+
+	return true;
+}
+
+void dce110_aud_wall_dto_setup(
+	struct audio *audio,
+	enum signal_type signal,
+	const struct audio_crtc_info *crtc_info,
+	const struct audio_pll_info *pll_info)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	struct azalia_clock_info clock_info = { 0 };
+
+	if (dc_is_hdmi_signal(signal)) {
+		uint32_t src_sel;
+
+		/*DTO0 Programming goal:
+		-generate 24MHz, 128*Fs from 24MHz
+		-use DTO0 when an active HDMI port is connected
+		(optionally a DP is connected) */
+
+		/* calculate DTO settings */
+		get_azalia_clock_info_hdmi(
+			crtc_info->requested_pixel_clock,
+			crtc_info->calculated_pixel_clock,
+			&clock_info);
+
+		/* On TN/SI, Program DTO source select and DTO select before
+		programming DTO modulo and DTO phase. These bits must be
+		programmed first, otherwise there will be no HDMI audio at boot
+		up. This is a HW sequence change (different from old ASICs).
+		Caution when changing this programming sequence.
+
+		HDMI enabled, using DTO0
+		program master CRTC for DTO0 */
+		src_sel = pll_info->dto_source - DTO_SOURCE_ID0;
+		REG_UPDATE_N(DCCG_AUDIO_DTO_SOURCE, 2,
+			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO0_SOURCE_SEL), src_sel,
+			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO_SEL), 0);
+
+		/* module */
+		REG_UPDATE(DCCG_AUDIO_DTO0_MODULE,
+			DCCG_AUDIO_DTO0_MODULE, clock_info.audio_dto_module);
+
+		/* phase */
+		REG_UPDATE(DCCG_AUDIO_DTO0_PHASE,
+			DCCG_AUDIO_DTO0_PHASE, clock_info.audio_dto_phase);
+	} else {
+		/*DTO1 Programming goal:
+		-generate 24MHz, 512*Fs, 128*Fs from 24MHz
+		-default is to used DTO1, and switch to DTO0 when an audio
+		master HDMI port is connected
+		-use as default for DP
+
+		calculate DTO settings */
+		get_azalia_clock_info_dp(
+			crtc_info->requested_pixel_clock,
+			pll_info,
+			&clock_info);
+
+		/* Program DTO select before programming DTO modulo and DTO
+		phase. default to use DTO1 */
+
+		REG_UPDATE(DCCG_AUDIO_DTO_SOURCE,
+				DCCG_AUDIO_DTO_SEL, 1);
+
+		REG_UPDATE_N(DCCG_AUDIO_DTO_SOURCE, 1,
+			FD(DCCG_AUDIO_DTO_SOURCE__DCCG_AUDIO_DTO_SEL), 1);
+			/* FD(DCCG_AUDIO_DTO2_USE_512FBR_DTO), 1)
+			 * Select 512fs for DP TODO: web register definition
+			 * does not match register header file
+			 * DCE11 version it's commented out while DCE8 it's set to 1
+			*/
+
+		/* module */
+		REG_UPDATE(DCCG_AUDIO_DTO1_MODULE,
+				DCCG_AUDIO_DTO1_MODULE, clock_info.audio_dto_module);
+
+		/* phase */
+		REG_UPDATE(DCCG_AUDIO_DTO1_PHASE,
+				DCCG_AUDIO_DTO1_PHASE, clock_info.audio_dto_phase);
+
+		/* DAL2 code separate DCCG_AUDIO_DTO_SEL and
+		DCCG_AUDIO_DTO2_USE_512FBR_DTO programming into two different
+		location. merge together should not hurt */
+		/*value.bits.DCCG_AUDIO_DTO2_USE_512FBR_DTO = 1;
+		dal_write_reg(mmDCCG_AUDIO_DTO_SOURCE, value);*/
+	}
+}
+
+/* initialize HW state */
+void dce110_aud_hw_init(
+		struct audio *audio)
+{
+	struct audio_dce110 *aud110 = DCE110_AUD(audio);
+
+	/* we only need to program the following registers once, so we only do
+	it for the inst 0*/
+	if (audio->inst != 0)
+		return;
+
+	/* Suport R5 - 32khz
+	 * Suport R6 - 44.1khz
+	 * Suport R7 - 48khz
+	 */
+	REG_UPDATE(AZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES,
+			AUDIO_RATE_CAPABILITIES, 0x70);
+
+	/*Keep alive bit to verify HW block in BU. */
+	REG_UPDATE_N(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES, 2,
+			FD(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES__CLKSTOP), 1,
+			FD(AZALIA_F0_CODEC_FUNCTION_PARAMETER_POWER_STATES__EPSS), 1);
+}
+
+static const struct audio_funcs funcs = {
+	.hw_init = dce110_aud_hw_init,
+	.wall_dto_setup = dce110_aud_wall_dto_setup,
+	.az_enable = dce110_aud_az_enable,
+	.az_disable = dce110_aud_az_disable,
+	.az_configure = dce110_aud_az_configure,
+};
+
+static bool construct(
+	struct audio_dce110 *audio,
+	const struct audio_init_data *init_data)
+{
+	struct audio *base = &audio->base;
+
+	base->ctx = init_data->ctx;
+	base->inst = init_data->inst;
+	base->funcs = &funcs;
+
+	audio->regs = init_data->reg;
+
+	return true;
+}
+
+void dce110_aud_destroy(struct audio **audio)
+{
+	dm_free(audio);
+	*audio = NULL;
+}
+
+struct audio *dal_audio_create_dce110(
+	const struct audio_init_data *init_data)
+{
+	/*allocate memory for audio_dce110 */
+	struct audio_dce110 *audio = dm_alloc(sizeof(*audio));
+	struct audio *base = &audio->base;
+
+	if (audio == NULL) {
+		ASSERT_CRITICAL(audio);
+		return NULL;
+	}
+
+	base->ctx = init_data->ctx;
+	base->inst = init_data->inst;
+	base->funcs = &funcs;
+
+	audio->regs = init_data->reg;
+
+	dal_logger_write(
+		init_data->ctx->logger,
+		LOG_MAJOR_ERROR,
+		LOG_MINOR_COMPONENT_AUDIO,
+		"Failed to create audio object for DCE11\n");
+
+	 /*release memory allocated if fail */
+	dm_free(audio);
+	return NULL;
+}
+
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
index 3509c5d4..f60f292 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
@@ -36,6 +36,7 @@
 #include "include/logger_interface.h"
 
 #include "dce110_clock_source.h"
+#include "adapter_service_interface.h"
 
 #define FRACT_FB_DIVIDER_DEC_POINTS_MAX_NUM 6
 #define CALC_PLL_CLK_SRC_ERR_TOLERANCE 1
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 1e38cc4..5cf86fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -44,8 +44,8 @@
 #include "stream_encoder.h"
 #include "link_encoder.h"
 #include "clock_source.h"
-#include "audio/audio.h"
 #include "gamma_calcs.h"
+#include "audio.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.h
index ba4b81b14..38550ac 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.h
@@ -27,6 +27,7 @@
 #define __DC_HWSS_DCE110_H__
 
 #include "core_types.h"
+#include "adapter_service_interface.h"
 
 #define GAMMA_HW_POINTS_NUM 256
 struct core_dc;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index b666376..0616fef 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -31,6 +31,7 @@
 #include "resource.h"
 #include "include/irq_service_interface.h"
 #include "../virtual/virtual_stream_encoder.h"
+#include "dce110/audio_dce110.h"
 #include "dce110/dce110_timing_generator.h"
 #include "dce110/dce110_timing_generator_v.h"
 #include "dce110/dce110_link_encoder.h"
@@ -43,10 +44,9 @@
 #include "dce110/dce110_opp.h"
 #include "dce110/dce110_opp_v.h"
 #include "dce110/dce110_clock_source.h"
-#include "audio/dce110/audio_dce110.h"
-
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_11_0_d.h"
+#include "adapter_service_interface.h"
 
 #ifndef mmDP_DPHY_INTERNAL_CTRL
 	#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7
@@ -484,68 +484,67 @@ void dce110_clock_source_destroy(struct clock_source **clk_src)
 	*clk_src = NULL;
 }
 
-void dce110_destruct_resource_pool(struct resource_pool *pool)
+static void destruct(struct dce110_resource_pool *pool)
 {
-	unsigned int i;
+        unsigned int i;
 
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce110_opp_destroy(&pool->opps[i]);
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce110_opp_destroy(&pool->base.opps[i]);
 
-		if (pool->transforms[i] != NULL)
-			dce110_transform_destroy(&pool->transforms[i]);
+                if (pool->base.transforms[i] != NULL)
+                        dce110_transform_destroy(&pool->base.transforms[i]);
 
-		if (pool->ipps[i] != NULL)
-			dce110_ipp_destroy(&pool->ipps[i]);
+                if (pool->base.ipps[i] != NULL)
+                        dce110_ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
 
-		if (pool->timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+                if (pool->base.timing_generators[i] != NULL)    {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL) {
-			dce110_clock_source_destroy(&pool->clock_sources[i]);
-		}
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL) {
+                        dce110_clock_source_destroy(&pool->base.clock_sources[i]);
+                }
+        }
 
-	if (pool->dp_clock_source != NULL)
-		dce110_clock_source_destroy(&pool->dp_clock_source);
+        if (pool->base.dp_clock_source != NULL)
+                dce110_clock_source_destroy(&pool->base.dp_clock_source);
 
-	for (i = 0; i < pool->audio_count; i++)	{
-		if (pool->audios[i] != NULL) {
-			dal_audio_destroy(&pool->audios[i]);
-		}
-	}
+        for (i = 0; i < pool->base.audio_count; i++)    {
+                if (pool->base.audios[i] != NULL) {
+                        dce110_aud_destroy(&pool->base.audios[i]);
+                }
+        }
 
-	if (pool->display_clock != NULL) {
-		dal_display_clock_destroy(&pool->display_clock);
-	}
+        if (pool->base.display_clock != NULL) {
+                dal_display_clock_destroy(&pool->base.display_clock);
+        }
 
-	if (pool->scaler_filter != NULL) {
-		dal_scaler_filter_destroy(&pool->scaler_filter);
-	}
-	if (pool->irqs != NULL) {
-		dal_irq_service_destroy(&pool->irqs);
-	}
+        if (pool->base.scaler_filter != NULL) {
+                dal_scaler_filter_destroy(&pool->base.scaler_filter);
+        }
+        if (pool->base.irqs != NULL) {
+                dal_irq_service_destroy(&pool->base.irqs);
+        }
 
-	if (pool->adapter_srv != NULL) {
-		dal_adapter_service_destroy(&pool->adapter_srv);
-	}
+        if (pool->base.adapter_srv != NULL) {
+                dal_adapter_service_destroy(&pool->base.adapter_srv);
+        }
 }
 
-
 static void get_pixel_clock_parameters(
 	const struct pipe_ctx *pipe_ctx,
 	struct pixel_clk_params *pixel_clk_params)
@@ -1278,7 +1277,6 @@ static bool construct(
                         break;
                 }
 
-                audio_init_data.audio_stream_id = obj_id;
                 audio_init_data.inst = i;
                 audio_init_data.reg = &audio_regs[i];
 
@@ -1339,7 +1337,7 @@ stream_enc_create_fail:
 audio_create_fail:
         for (i = 0; i < pool->base.pipe_count; i++) {
                 if (pool->base.audios[i] != NULL)
-                        dal_audio_destroy(&pool->base.audios[i]);
+                        dce110_aud_destroy(&pool->base.audios[i]);
         }
 
 controller_create_fail:
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
index 10393a4..6fde33a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
@@ -36,6 +36,7 @@
 
 #include "include/grph_object_id.h"
 #include "include/logger_interface.h"
+#include "dc_bios_types.h"
 
 /**
  * Calculate PLL Dividers for given Clock Value.
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index aea0192..c38508f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -30,6 +30,7 @@
 
 #include "resource.h"
 #include "include/irq_service_interface.h"
+#include "include/adapter_service_interface.h"
 #include "../virtual/virtual_stream_encoder.h"
 #include "dce110/dce110_resource.h"
 #include "dce110/dce110_timing_generator.h"
@@ -38,10 +39,10 @@
 #include "dce110/dce110_link_encoder.h"
 #include "dce110/dce110_transform.h"
 #include "dce110/dce110_stream_encoder.h"
+#include "dce110/audio_dce110.h"
 #include "dce112/dce112_opp.h"
 #include "dce110/dce110_ipp.h"
 #include "dce112/dce112_clock_source.h"
-#include "audio/dce110/audio_dce110.h"
 
 #include "dce112/dce112_hw_sequencer.h"
 
@@ -552,65 +553,65 @@ void dce112_clock_source_destroy(struct clock_source **clk_src)
 	*clk_src = NULL;
 }
 
-void dce112_destruct_resource_pool(struct resource_pool *pool)
+static void destruct(struct dce110_resource_pool *pool)
 {
-	unsigned int i;
+        unsigned int i;
 
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce112_opp_destroy(&pool->opps[i]);
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce112_opp_destroy(&pool->base.opps[i]);
 
-		if (pool->transforms[i] != NULL)
-			dce112_transform_destroy(&pool->transforms[i]);
+                if (pool->base.transforms[i] != NULL)
+                        dce112_transform_destroy(&pool->base.transforms[i]);
 
-		if (pool->ipps[i] != NULL)
-			dce112_ipp_destroy(&pool->ipps[i]);
+                if (pool->base.ipps[i] != NULL)
+                        dce112_ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
 
-		if (pool->timing_generators[i] != NULL) {
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+                if (pool->base.timing_generators[i] != NULL) {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL) {
-			dce112_clock_source_destroy(&pool->clock_sources[i]);
-		}
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL) {
+                        dce112_clock_source_destroy(&pool->base.clock_sources[i]);
+                }
+        }
 
-	if (pool->dp_clock_source != NULL)
-		dce112_clock_source_destroy(&pool->dp_clock_source);
+        if (pool->base.dp_clock_source != NULL)
+                dce112_clock_source_destroy(&pool->base.dp_clock_source);
 
-	for (i = 0; i < pool->audio_count; i++)	{
-		if (pool->audios[i] != NULL) {
-			dal_audio_destroy(&pool->audios[i]);
-		}
-	}
+        for (i = 0; i < pool->base.audio_count; i++)    {
+                if (pool->base.audios[i] != NULL) {
+                        dce110_aud_destroy(&pool->base.audios[i]);
+                }
+        }
 
-	if (pool->display_clock != NULL) {
-		dal_display_clock_destroy(&pool->display_clock);
-	}
+        if (pool->base.display_clock != NULL) {
+                dal_display_clock_destroy(&pool->base.display_clock);
+        }
 
-	if (pool->scaler_filter != NULL) {
-		dal_scaler_filter_destroy(&pool->scaler_filter);
-	}
-	if (pool->irqs != NULL) {
-		dal_irq_service_destroy(&pool->irqs);
-	}
+        if (pool->base.scaler_filter != NULL) {
+                dal_scaler_filter_destroy(&pool->base.scaler_filter);
+        }
+        if (pool->base.irqs != NULL) {
+                dal_irq_service_destroy(&pool->base.irqs);
+        }
 
-	if (pool->adapter_srv != NULL) {
-		dal_adapter_service_destroy(&pool->adapter_srv);
-	}
+        if (pool->base.adapter_srv != NULL) {
+                dal_adapter_service_destroy(&pool->base.adapter_srv);
+        }
 }
 
 static struct clock_source *find_matching_pll(struct resource_context *res_ctx,
@@ -1237,7 +1238,6 @@ static bool construct(
                         break;
                 }
 
-                audio_init_data.audio_stream_id = obj_id;
                 audio_init_data.inst = i;
                 audio_init_data.reg = &audio_regs[i];
 
@@ -1298,7 +1298,7 @@ stream_enc_create_fail:
 audio_create_fail:
         for (i = 0; i < pool->base.pipe_count; i++) {
                 if (pool->base.audios[i] != NULL)
-                        dal_audio_destroy(&pool->base.audios[i]);
+                        dce110_aud_destroy(&pool->base.audios[i]);
         }
 
 controller_create_fail:
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index 54a8589..8560476 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -30,6 +30,7 @@
 
 #include "resource.h"
 #include "include/irq_service_interface.h"
+#include "include/adapter_service_interface.h"
 #include "../virtual/virtual_stream_encoder.h"
 #include "dce110/dce110_timing_generator.h"
 #include "dce110/dce110_mem_input.h"
@@ -45,9 +46,7 @@
 #include "dce80/dce80_opp.h"
 #include "dce110/dce110_ipp.h"
 #include "dce110/dce110_clock_source.h"
-#include "audio/dce80/audio_dce80.h"
-#include "audio/dce110/audio_dce110.h"
-
+#include "dce110/audio_dce110.h"
 #include "dce80/dce80_hw_sequencer.h"
 
 #include "dce/dce_8_0_d.h"
@@ -468,65 +467,65 @@ void dce80_clock_source_destroy(struct clock_source **clk_src)
 	*clk_src = NULL;
 }
 
-void dce80_destruct_resource_pool(struct resource_pool *pool)
+static void destruct(struct dce110_resource_pool *pool)
 {
-	unsigned int i;
+        unsigned int i;
 
-	for (i = 0; i < pool->pipe_count; i++) {
-		if (pool->opps[i] != NULL)
-			dce80_opp_destroy(&pool->opps[i]);
+        for (i = 0; i < pool->base.pipe_count; i++) {
+                if (pool->base.opps[i] != NULL)
+                        dce80_opp_destroy(&pool->base.opps[i]);
 
-		if (pool->transforms[i] != NULL)
-			dce80_transform_destroy(&pool->transforms[i]);
+                if (pool->base.transforms[i] != NULL)
+                        dce80_transform_destroy(&pool->base.transforms[i]);
 
-		if (pool->ipps[i] != NULL)
-			dce80_ipp_destroy(&pool->ipps[i]);
+                if (pool->base.ipps[i] != NULL)
+                        dce80_ipp_destroy(&pool->base.ipps[i]);
 
-		if (pool->mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->mis[i]));
-			pool->mis[i] = NULL;
-		}
+                if (pool->base.mis[i] != NULL) {
+                        dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+                        pool->base.mis[i] = NULL;
+                }
 
-		if (pool->timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->timing_generators[i]));
-			pool->timing_generators[i] = NULL;
-		}
-	}
+                if (pool->base.timing_generators[i] != NULL)    {
+                        dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+                        pool->base.timing_generators[i] = NULL;
+                }
+        }
 
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (pool->stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->stream_enc[i]));
-	}
+        for (i = 0; i < pool->base.stream_enc_count; i++) {
+                if (pool->base.stream_enc[i] != NULL)
+                        dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+        }
 
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != NULL) {
-			dce80_clock_source_destroy(&pool->clock_sources[i]);
-		}
-	}
+        for (i = 0; i < pool->base.clk_src_count; i++) {
+                if (pool->base.clock_sources[i] != NULL) {
+                        dce80_clock_source_destroy(&pool->base.clock_sources[i]);
+                }
+        }
 
-	if (pool->dp_clock_source != NULL)
-		dce80_clock_source_destroy(&pool->dp_clock_source);
+        if (pool->base.dp_clock_source != NULL)
+                dce80_clock_source_destroy(&pool->base.dp_clock_source);
 
-	for (i = 0; i < pool->audio_count; i++)	{
-		if (pool->audios[i] != NULL) {
-			dal_audio_destroy(&pool->audios[i]);
-		}
-	}
+        for (i = 0; i < pool->base.audio_count; i++)    {
+                if (pool->base.audios[i] != NULL) {
+                        dce110_aud_destroy(&pool->base.audios[i]);
+                }
+        }
 
-	if (pool->display_clock != NULL) {
-		dal_display_clock_destroy(&pool->display_clock);
-	}
+        if (pool->base.display_clock != NULL) {
+                dal_display_clock_destroy(&pool->base.display_clock);
+        }
 
-	if (pool->scaler_filter != NULL) {
-		dal_scaler_filter_destroy(&pool->scaler_filter);
-	}
-	if (pool->irqs != NULL) {
-		dal_irq_service_destroy(&pool->irqs);
-	}
+        if (pool->base.scaler_filter != NULL) {
+                dal_scaler_filter_destroy(&pool->base.scaler_filter);
+        }
+        if (pool->base.irqs != NULL) {
+                dal_irq_service_destroy(&pool->base.irqs);
+        }
 
-	if (pool->adapter_srv != NULL) {
-		dal_adapter_service_destroy(&pool->adapter_srv);
-	}
+        if (pool->base.adapter_srv != NULL) {
+                dal_adapter_service_destroy(&pool->base.adapter_srv);
+        }
 }
 
 static enum dc_status validate_mapped_resource(
@@ -863,11 +862,10 @@ static bool construct(
                         break;
                 }
 
-                audio_init_data.audio_stream_id = obj_id;
                 audio_init_data.inst = i;
                 audio_init_data.reg = &audio_regs[i];
 
-		pool->base.audios[i] = dal_audio_create_dce80(&audio_init_data);
+                pool->base.audios[i] = dal_audio_create_dce110(&audio_init_data);
                 if (pool->base.audios[i] == NULL) {
                         BREAK_TO_DEBUGGER();
                         dm_error("DC: failed to create DPPs!\n");
@@ -920,7 +918,7 @@ stream_enc_create_fail:
 audio_create_fail:
         for (i = 0; i < pool->base.pipe_count; i++) {
                 if (pool->base.audios[i] != NULL)
-                        dal_audio_destroy(&pool->base.audios[i]);
+                        dce110_aud_destroy(&pool->base.audios[i]);
         }
 
 controller_create_fail:
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 0a944e9..67003b9 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -30,6 +30,7 @@
 #include "bandwidth_calcs.h"
 #include "ddc_service_types.h"
 #include "scaler_types.h"
+#include "dc_bios_types.h"
 
 struct core_stream;
 /********* core_target *************/
@@ -74,7 +75,7 @@ void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 #include "link_encoder.h"
 #include "stream_encoder.h"
 #include "clock_source.h"
-#include "audio_interface.h"
+#include "audio.h"
 #include "scaler_types.h"
 #include "hw_sequencer_types.h"
 #include "opp.h"
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/audio.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/audio.h
new file mode 100644
index 0000000..e22b383
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/audio.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DAL_AUDIO_H__
+#define __DAL_AUDIO_H__
+
+#include "audio_types.h"
+
+struct audio;
+
+struct audio_funcs {
+
+	void (*hw_init)(struct audio *audio);
+
+	void (*az_enable)(struct audio *audio);
+
+	void (*az_disable)(struct audio *audio);
+
+	void (*az_configure)(struct audio *audio,
+		enum signal_type signal,
+		const struct audio_crtc_info *crtc_info,
+		const struct audio_info *audio_info);
+
+	void (*wall_dto_setup)(struct audio *audio,
+		enum signal_type signal,
+		const struct audio_crtc_info *crtc_info,
+		const struct audio_pll_info *pll_info);
+};
+
+struct audio_init_data {
+	struct dc_context *ctx;
+
+	unsigned int inst;
+	const struct dce110_audio_registers *reg;
+};
+
+struct audio {
+	const struct audio_funcs *funcs;
+	struct dc_context *ctx;
+	unsigned int inst;
+};
+
+#endif  /* __DAL_AUDIO__ */
diff --git a/drivers/gpu/drm/amd/dal/include/audio_interface.h b/drivers/gpu/drm/amd/dal/include/audio_interface.h
deleted file mode 100644
index 22d0d3c..0000000
--- a/drivers/gpu/drm/amd/dal/include/audio_interface.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_AUDIO_INTERFACE_H__
-#define __DAL_AUDIO_INTERFACE_H__
-
-#include "audio_types.h"
-#include "adapter_service_interface.h"
-#include "signal_types.h"
-#include "link_service_types.h"
-
-/* forward declaration */
-struct audio;
-struct dal_adapter_service;
-
-/*****  audio initialization data  *****/
-/*
- * by audio, it means audio endpoint id. ASIC may have many endpoints.
- * upper sw layer will create one audio object instance for each endpoints.
- * ASIC support internal audio only. So enum number is used to differ
- * each endpoint
- */
-struct audio_init_data {
-	struct graphics_object_id audio_stream_id;
-	struct dc_context *ctx;
-
-	unsigned int inst;
-	const struct dce110_audio_registers *reg;
-};
-
-enum audio_result {
-	AUDIO_RESULT_OK,
-	AUDIO_RESULT_ERROR,
-};
-
-/****** audio object create, destroy ******/
-
-void dal_audio_destroy(
-	struct audio **audio);
-
-/***** information interface *****/
-
-/* Update audio wall clock source */
-void dal_audio_setup_audio_wall_dto(
-	struct audio *audio,
-	enum signal_type signal,
-	const struct audio_crtc_info *crtc_info,
-	const struct audio_pll_info *pll_info);
-
-#endif
diff --git a/drivers/gpu/drm/amd/dal/include/audio_types.h b/drivers/gpu/drm/amd/dal/include/audio_types.h
index 55044b3..6364fbc 100644
--- a/drivers/gpu/drm/amd/dal/include/audio_types.h
+++ b/drivers/gpu/drm/amd/dal/include/audio_types.h
@@ -26,7 +26,6 @@
 #ifndef __AUDIO_TYPES_H__
 #define __AUDIO_TYPES_H__
 
-#include "grph_object_defs.h"
 #include "signal_types.h"
 
 #define AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS 20
-- 
2.7.4

