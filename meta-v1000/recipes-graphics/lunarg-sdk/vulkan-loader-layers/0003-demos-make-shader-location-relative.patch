From 8797907d97a10ce64b03bef80fd67bc9117712b2 Mon Sep 17 00:00:00 2001
From: Awais Belal <awais_belal@mentor.com>
Date: Wed, 6 Dec 2017 18:09:55 +0500
Subject: [PATCH] demos: make shader location relative

The demo binaries expect the shader (frag/vert.spv)
location to be PWD so a user has to cd to /usr/bin
if the binaries are installed there in order to
run them correctly.
This patch tries to find the location of the binary
and then assumes that the shaders are located in the
same location as the binary so a user can install
everything to a single dir and that will work.

Signed-off-by: Awais Belal <awais_belal@mentor.com>
---
 demos/cube.c   | 66 ++++++++++++++++++++++++++++++++++++++++++++++++----
 demos/cube.cpp | 73 ++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 129 insertions(+), 10 deletions(-)

diff --git a/demos/cube.c b/demos/cube.c
index dd7bd906b..c8bc00e04 100644
--- a/demos/cube.c
+++ b/demos/cube.c
@@ -33,6 +33,7 @@
 #include <stdbool.h>
 #include <assert.h>
 #include <signal.h>
+#include <unistd.h>
 #if defined(VK_USE_PLATFORM_XLIB_KHR) || defined(VK_USE_PLATFORM_XCB_KHR)
 #include <X11/Xutil.h>
 #elif defined(VK_USE_PLATFORM_WAYLAND_KHR)
@@ -453,6 +454,8 @@ struct demo {
 
     uint32_t current_buffer;
     uint32_t queue_family_count;
+
+    char bin_path[255];
 };
 
 VKAPI_ATTR VkBool32 VKAPI_CALL dbgFunc(VkFlags msgFlags, VkDebugReportObjectTypeEXT objType, uint64_t srcObject, size_t location,
@@ -1611,18 +1614,27 @@ static void demo_prepare_textures(struct demo *demo) {
     const VkFormat tex_format = VK_FORMAT_R8G8B8A8_UNORM;
     VkFormatProperties props;
     uint32_t i;
+    char tex_file[255];
 
     vkGetPhysicalDeviceFormatProperties(demo->gpu, tex_format, &props);
 
     for (i = 0; i < DEMO_TEXTURE_COUNT; i++) {
         VkResult U_ASSERT_ONLY err;
 
+        if (strlen(demo->bin_path) > 0) {
+            strcpy(tex_file, demo->bin_path);
+            strcat(tex_file, "/");
+            strcat(tex_file, tex_files[i]);
+        }
+        else
+            strcpy(tex_file, tex_files[i]);
+
         if ((props.linearTilingFeatures &
              VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) &&
             !demo->use_staging_buffer) {
             /* Device can texture using linear textures */
             demo_prepare_texture_image(
-                demo, tex_files[i], &demo->textures[i], VK_IMAGE_TILING_LINEAR,
+                demo, tex_file, &demo->textures[i], VK_IMAGE_TILING_LINEAR,
                 VK_IMAGE_USAGE_SAMPLED_BIT,
                 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                     VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
@@ -1639,13 +1651,13 @@ static void demo_prepare_textures(struct demo *demo) {
 
             memset(&demo->staging_texture, 0, sizeof(demo->staging_texture));
             demo_prepare_texture_image(
-                demo, tex_files[i], &demo->staging_texture, VK_IMAGE_TILING_LINEAR,
+                demo, tex_file, &demo->staging_texture, VK_IMAGE_TILING_LINEAR,
                 VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
                 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                     VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
 
             demo_prepare_texture_image(
-                demo, tex_files[i], &demo->textures[i], VK_IMAGE_TILING_OPTIMAL,
+                demo, tex_file, &demo->textures[i], VK_IMAGE_TILING_OPTIMAL,
                 (VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT),
                 VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
 
@@ -1986,8 +1998,17 @@ static VkShaderModule demo_prepare_vs(struct demo *demo) {
 #else
     void *vertShaderCode;
     size_t size;
+    char fname[255];
 
-    vertShaderCode = demo_read_spv("cube-vert.spv", &size);
+    if (strlen(demo->bin_path) > 0) {
+        strcpy(fname, demo->bin_path);
+        strcat(fname, "/");
+        strcat(fname, "cube-vert.spv");
+    }
+    else
+        strcpy(fname, "cube-vert.spv");
+
+    vertShaderCode = demo_read_spv(fname, &size);
     if (!vertShaderCode) {
         ERR_EXIT("Failed to load cube-vert.spv", "Load Shader Failure");
     }
@@ -2014,8 +2035,17 @@ static VkShaderModule demo_prepare_fs(struct demo *demo) {
 #else
     void *fragShaderCode;
     size_t size;
+    char fname[255];
+
+    if (strlen(demo->bin_path) > 0) {
+        strcpy(fname, demo->bin_path);
+        strcat(fname, "/");
+        strcat(fname, "cube-frag.spv");
+    }
+    else
+        strcpy(fname, "cube-frag.spv");
 
-    fragShaderCode = demo_read_spv("cube-frag.spv", &size);
+    fragShaderCode = demo_read_spv(fname, &size);
     if (!fragShaderCode) {
         ERR_EXIT("Failed to load cube-frag.spv", "Load Shader Failure");
     }
@@ -3866,6 +3896,30 @@ static void demo_init_connection(struct demo *demo) {
 #endif
 }
 
+static void find_bin_path(char *in_arg, char *ret_path) {
+    char *ptr = getenv("PATH");
+    char *pch_temp;
+    char pch[255];
+
+    if (access(in_arg, F_OK ) == 0) {
+        pch_temp = strrchr(in_arg, '/');
+        strncpy(ret_path, in_arg, strlen(in_arg) - strlen(pch_temp));
+    } else if (in_arg[0] != '/') {
+        pch_temp = strtok(ptr, ":");
+        while (pch_temp != NULL) {
+            strcpy(pch, pch_temp);
+            strcat(pch, "/");
+            strcat(pch, in_arg);
+            if ((access(pch, F_OK ) == 0)) {
+                strcpy(ret_path, pch_temp);
+                break;
+            }
+            else
+                pch_temp = strtok(NULL, ":");
+        }
+    }
+}
+
 static void demo_init(struct demo *demo, int argc, char **argv) {
     vec3 eye = {0.0f, 3.0f, 5.0f};
     vec3 origin = {0, 0, 0};
@@ -3960,6 +4014,8 @@ static void demo_init(struct demo *demo, int argc, char **argv) {
     mat4x4_identity(demo->model_matrix);
 
     demo->projection_matrix[1][1]*=-1;  //Flip projection matrix from GL to Vulkan orientation.
+
+    find_bin_path(argv[0], demo->bin_path);
 }
 
 #if defined(VK_USE_PLATFORM_WIN32_KHR)
diff --git a/demos/cube.cpp b/demos/cube.cpp
index 9b6fe5107..f867e30ab 100644
--- a/demos/cube.cpp
+++ b/demos/cube.cpp
@@ -30,6 +30,7 @@
 #include <cstring>
 #include <csignal>
 #include <memory>
+#include <unistd.h>
 
 #if defined(VK_USE_PLATFORM_MIR_KHR)
 #warning "Cubepp does not have code for Mir at this time"
@@ -219,6 +220,7 @@ struct Demo {
     void draw();
     void draw_build_cmd(vk::CommandBuffer);
     void flush_init_cmd();
+    void find_bin_path(char *, char *);
     void init(int, char **);
     void init_connection();
     void init_vk();
@@ -384,6 +386,8 @@ struct Demo {
 
     uint32_t current_buffer;
     uint32_t queue_family_count;
+
+    char bin_path[255];
 };
 
 #ifdef _WIN32
@@ -556,6 +560,7 @@ Demo::Demo()
         memset(projection_matrix, 0, sizeof(projection_matrix));
         memset(view_matrix, 0, sizeof(view_matrix));
         memset(model_matrix, 0, sizeof(model_matrix));
+        memset(bin_path, '\0', 255);
     }
 
     void Demo::build_image_ownership_cmd(uint32_t const &i) {
@@ -888,6 +893,30 @@ Demo::Demo()
         cmd = vk::CommandBuffer();
     }
 
+    void Demo::find_bin_path(char *in_arg, char *ret_path) {
+        char *ptr = getenv("PATH");
+        char *pch_temp;
+        char pch[255];
+
+        if (access(in_arg, F_OK ) == 0) {
+            pch_temp = strrchr(in_arg, '/');
+            strncpy(ret_path, in_arg, strlen(in_arg) - strlen(pch_temp));
+        } else if (in_arg[0] != '/') {
+            pch_temp = strtok(ptr, ":");
+            while (pch_temp != NULL) {
+                strcpy(pch, pch_temp);
+                strcat(pch, "/");
+                strcat(pch, in_arg);
+                if ((access(pch, F_OK ) == 0)) {
+                    strcpy(ret_path, pch_temp);
+                    break;
+                }
+                else
+                    pch_temp = strtok(NULL, ":");
+            }
+        }
+    }
+
     void Demo::init(int argc, char **argv) {
         vec3 eye = {0.0f, 3.0f, 5.0f};
         vec3 origin = {0, 0, 0};
@@ -962,6 +991,8 @@ Demo::Demo()
         mat4x4_identity(model_matrix);
 
         projection_matrix[1][1] *= -1;  // Flip projection matrix from GL to Vulkan orientation.
+
+	find_bin_path(argv[0], bin_path);
     }
 
     void Demo::init_connection() {
@@ -1858,7 +1889,18 @@ Demo::Demo()
 
     vk::ShaderModule Demo::prepare_fs() {
         size_t size = 0;
-        void *fragShaderCode = read_spv("cube-frag.spv", &size);
+        char fname[255];
+        memset(fname, '\0', 255);
+
+        if (strlen(bin_path) > 0) {
+            strcpy(fname, bin_path);
+            strcat(fname, "/");
+            strcat(fname, "cube-frag.spv");
+        }
+        else
+            strcpy(fname, "cube-frag.spv");
+
+        void *fragShaderCode = read_spv(fname, &size);
         if (!fragShaderCode) {
             ERR_EXIT("Failed to load cube-frag.spv", "Load Shader Failure");
         }
@@ -2079,11 +2121,21 @@ Demo::Demo()
         vk::Format const tex_format = vk::Format::eR8G8B8A8Unorm;
         vk::FormatProperties props;
         gpu.getFormatProperties(tex_format, &props);
+        char tex_file[255];
+	memset(tex_file, '\0', 255);
 
         for (uint32_t i = 0; i < texture_count; i++) {
+            if (strlen(bin_path) > 0) {
+                strcpy(tex_file, bin_path);
+                strcat(tex_file, "/");
+                strcat(tex_file, tex_files[i]);
+            }
+            else
+                strcpy(tex_file, tex_files[i]);
+
             if ((props.linearTilingFeatures & vk::FormatFeatureFlagBits::eSampledImage) && !use_staging_buffer) {
                 /* Device can texture using linear textures */
-                prepare_texture_image(tex_files[i], &textures[i], vk::ImageTiling::eLinear, vk::ImageUsageFlagBits::eSampled,
+                prepare_texture_image(tex_file, &textures[i], vk::ImageTiling::eLinear, vk::ImageUsageFlagBits::eSampled,
                                       vk::MemoryPropertyFlagBits::eHostVisible | vk::MemoryPropertyFlagBits::eHostCoherent);
                 // Nothing in the pipeline needs to be complete to start, and don't allow fragment
                 // shader to run until layout transition completes
@@ -2094,11 +2146,11 @@ Demo::Demo()
             } else if (props.optimalTilingFeatures & vk::FormatFeatureFlagBits::eSampledImage) {
                 /* Must use staging buffer to copy linear texture to optimized */
 
-                prepare_texture_image(tex_files[i], &staging_texture, vk::ImageTiling::eLinear,
+                prepare_texture_image(tex_file, &staging_texture, vk::ImageTiling::eLinear,
                                       vk::ImageUsageFlagBits::eTransferSrc,
                                       vk::MemoryPropertyFlagBits::eHostVisible | vk::MemoryPropertyFlagBits::eHostCoherent);
 
-                prepare_texture_image(tex_files[i], &textures[i], vk::ImageTiling::eOptimal,
+                prepare_texture_image(tex_file, &textures[i], vk::ImageTiling::eOptimal,
                                       vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled,
                                       vk::MemoryPropertyFlagBits::eDeviceLocal);
 
@@ -2167,7 +2219,18 @@ Demo::Demo()
 
     vk::ShaderModule Demo::prepare_vs() {
         size_t size = 0;
-        void *vertShaderCode = read_spv("cube-vert.spv", &size);
+        char fname[255];
+        memset(fname, '\0', 255);
+
+        if (strlen(bin_path) > 0) {
+            strcpy(fname, bin_path);
+            strcat(fname, "/");
+            strcat(fname, "cube-vert.spv");
+        }
+        else
+            strcpy(fname, "cube-vert.spv");
+
+        void *vertShaderCode = read_spv(fname, &size);
         if (!vertShaderCode) {
             ERR_EXIT("Failed to load cube-vert.spv", "Load Shader Failure");
         }
-- 
2.11.1

