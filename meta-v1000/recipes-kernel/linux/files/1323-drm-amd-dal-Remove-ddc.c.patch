From 76c2aba3ef8e8827ae551f3a0fbcc17c3f20c004 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Wed, 12 Oct 2016 21:18:39 -0400
Subject: [PATCH 1323/1722] drm/amd/dal: Remove ddc.c

Change-Id: I66a0bba128c646d3f317eb4293dfea18e47bb782
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/gpio/Makefile           |   2 +-
 drivers/gpu/drm/amd/dal/dc/gpio/ddc.c              | 282 ---------------------
 drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c     | 227 ++++++++++++++++-
 drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c         |   2 +-
 .../amd/dal/include/adapter_service_interface.h    |   1 -
 drivers/gpu/drm/amd/dal/include/ddc_interface.h    |  74 ------
 .../drm/amd/dal/include/gpio_service_interface.h   |  43 +++-
 drivers/gpu/drm/amd/dal/include/i2caux_interface.h |   3 +-
 8 files changed, 272 insertions(+), 362 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
 delete mode 100644 drivers/gpu/drm/amd/dal/include/ddc_interface.h

diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/Makefile b/drivers/gpu/drm/amd/dal/dc/gpio/Makefile
index 2f8123b..61a69d1 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/Makefile
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the 'gpio' sub-component of DAL.
 # It provides the control and status of HW GPIO pins.
 
-GPIO = ddc.o gpio_base.o gpio_service.o hw_ddc.o hw_factory.o \
+GPIO = gpio_base.o gpio_service.o hw_ddc.o hw_factory.o \
        hw_gpio.o hw_gpio_pad.o hw_hpd.o hw_translate.o
 
 AMD_DAL_GPIO = $(addprefix $(AMDDALPATH)/dc/gpio/,$(GPIO))
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c b/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
deleted file mode 100644
index a44b5cd..0000000
--- a/drivers/gpu/drm/amd/dal/dc/gpio/ddc.c
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-/*
- * Pre-requisites: headers required by header of this unit
- */
-
-#include "dm_services.h"
-
-#include "include/gpio_interface.h"
-#include "include/ddc_interface.h"
-#include "include/gpio_service_interface.h"
-#include "hw_translate.h"
-#include "hw_factory.h"
-#include "gpio_service.h"
-
-/*
- * Post-requisites: headers required by this unit
- */
-
-/*
- * This unit
- */
-
-enum gpio_result dal_ddc_open(
-	struct ddc *ddc,
-	enum gpio_mode mode,
-	enum gpio_ddc_config_type config_type)
-{
-	enum gpio_result result;
-
-	struct gpio_ddc_open_options data_options;
-	struct gpio_ddc_open_options clock_options;
-	struct gpio_config_data config_data;
-
-	result = dal_gpio_open_ex(ddc->pin_data, mode, &data_options);
-
-	if (result != GPIO_RESULT_OK) {
-		BREAK_TO_DEBUGGER();
-		return result;
-	}
-
-	result = dal_gpio_open_ex(ddc->pin_clock, mode, &clock_options);
-
-	if (result != GPIO_RESULT_OK) {
-		BREAK_TO_DEBUGGER();
-		goto failure;
-	}
-
-	/* DDC clock and data pins should belong
-	 * to the same DDC block id,
-	 * we use the data pin to set the pad mode. */
-
-	if (mode == GPIO_MODE_INPUT)
-		/* this is from detect_sink_type,
-		 * we need extra delay there */
-		config_data.type = GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE;
-	else
-		config_data.type = GPIO_CONFIG_TYPE_DDC;
-
-	config_data.config.ddc.type = config_type;
-	config_data.config.ddc.data_en_bit_present =
-		data_options.en_bit_present;
-	config_data.config.ddc.clock_en_bit_present =
-		clock_options.en_bit_present;
-
-	result = dal_gpio_set_config(ddc->pin_data, &config_data);
-
-	if (result == GPIO_RESULT_OK)
-		return result;
-
-	BREAK_TO_DEBUGGER();
-
-	dal_gpio_close(ddc->pin_clock);
-
-failure:
-	dal_gpio_close(ddc->pin_data);
-
-	return result;
-}
-
-enum gpio_result dal_ddc_get_clock(
-	const struct ddc *ddc,
-	uint32_t *value)
-{
-	return dal_gpio_get_value(ddc->pin_clock, value);
-}
-
-enum gpio_result dal_ddc_set_clock(
-	const struct ddc *ddc,
-	uint32_t value)
-{
-	return dal_gpio_set_value(ddc->pin_clock, value);
-}
-
-enum gpio_result dal_ddc_get_data(
-	const struct ddc *ddc,
-	uint32_t *value)
-{
-	return dal_gpio_get_value(ddc->pin_data, value);
-}
-
-enum gpio_result dal_ddc_set_data(
-	const struct ddc *ddc,
-	uint32_t value)
-{
-	return dal_gpio_set_value(ddc->pin_data, value);
-}
-
-enum gpio_result dal_ddc_change_mode(
-	struct ddc *ddc,
-	enum gpio_mode mode)
-{
-	enum gpio_result result;
-
-	enum gpio_mode original_mode =
-		dal_gpio_get_mode(ddc->pin_data);
-
-	result = dal_gpio_change_mode(ddc->pin_data, mode);
-
-	/* [anaumov] DAL2 code returns GPIO_RESULT_NON_SPECIFIC_ERROR
-	 * in case of failures;
-	 * set_mode() is so that, in case of failure,
-	 * we must explicitly set original mode */
-
-	if (result != GPIO_RESULT_OK)
-		goto failure;
-
-	result = dal_gpio_change_mode(ddc->pin_clock, mode);
-
-	if (result == GPIO_RESULT_OK)
-		return result;
-
-	dal_gpio_change_mode(ddc->pin_clock, original_mode);
-
-failure:
-	dal_gpio_change_mode(ddc->pin_data, original_mode);
-
-	return result;
-}
-
-bool dal_ddc_is_hw_supported(
-	const struct ddc *ddc)
-{
-	return ddc->hw_info.hw_supported;
-}
-
-enum gpio_ddc_line dal_ddc_get_line(
-	const struct ddc *ddc)
-{
-	return (enum gpio_ddc_line)dal_gpio_get_enum(ddc->pin_data);
-}
-
-bool dal_ddc_check_line_aborted(
-	const struct ddc *self)
-{
-	/* No arbitration with VBIOS is performed since DCE 6.0 */
-
-	return false;
-}
-
-enum gpio_result dal_ddc_set_config(
-	struct ddc *ddc,
-	enum gpio_ddc_config_type config_type)
-{
-	struct gpio_config_data config_data;
-
-	config_data.type = GPIO_CONFIG_TYPE_DDC;
-
-	config_data.config.ddc.type = config_type;
-	config_data.config.ddc.data_en_bit_present = false;
-	config_data.config.ddc.clock_en_bit_present = false;
-
-	return dal_gpio_set_config(ddc->pin_data, &config_data);
-}
-
-void dal_ddc_close(
-	struct ddc *ddc)
-{
-	dal_gpio_close(ddc->pin_clock);
-	dal_gpio_close(ddc->pin_data);
-}
-
-/*
- * @brief
- * Creation and destruction
- */
-
-struct ddc *dal_gpio_create_ddc(
-	struct gpio_service *service,
-	uint32_t offset,
-	uint32_t mask,
-	struct gpio_ddc_hw_info *info)
-{
-	enum gpio_id id;
-	uint32_t en;
-	struct ddc *ddc;
-
-	if (!service->translate.funcs->offset_to_id(offset, mask, &id, &en))
-		return NULL;
-
-	ddc = dm_alloc(sizeof(struct ddc));
-
-	if (!ddc) {
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-
-	ddc->pin_data = dal_gpio_create(
-		service, GPIO_ID_DDC_DATA, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);
-
-	if (!ddc->pin_data) {
-		BREAK_TO_DEBUGGER();
-		goto failure_1;
-	}
-
-	ddc->pin_clock = dal_gpio_create(
-		service, GPIO_ID_DDC_CLOCK, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);
-
-	if (!ddc->pin_clock) {
-		BREAK_TO_DEBUGGER();
-		goto failure_2;
-	}
-
-	ddc->hw_info = *info;
-
-	ddc->ctx = service->ctx;
-
-	return ddc;
-
-failure_2:
-	dal_gpio_destroy(&ddc->pin_data);
-
-failure_1:
-	dm_free(ddc);
-
-	return NULL;
-}
-
-static void destruct(struct ddc *ddc)
-{
-	dal_ddc_close(ddc);
-	dal_gpio_destroy(&ddc->pin_data);
-	dal_gpio_destroy(&ddc->pin_clock);
-
-}
-
-void dal_gpio_destroy_ddc(
-	struct ddc **ddc)
-{
-	if (!ddc || !*ddc) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	destruct(*ddc);
-	dm_free(*ddc);
-
-	*ddc = NULL;
-}
diff --git a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
index 0e6ddbe..26007a9 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpio/gpio_service.c
@@ -29,7 +29,6 @@
 
 #include "dm_services.h"
 #include "include/gpio_interface.h"
-#include "include/ddc_interface.h"
 #include "include/gpio_service_interface.h"
 #include "hw_translate.h"
 #include "hw_factory.h"
@@ -412,3 +411,229 @@ void dal_gpio_destroy_irq(
 
 	*irq = NULL;
 }
+
+struct ddc *dal_gpio_create_ddc(
+	struct gpio_service *service,
+	uint32_t offset,
+	uint32_t mask,
+	struct gpio_ddc_hw_info *info)
+{
+	enum gpio_id id;
+	uint32_t en;
+	struct ddc *ddc;
+
+	if (!service->translate.funcs->offset_to_id(offset, mask, &id, &en))
+		return NULL;
+
+	ddc = dm_alloc(sizeof(struct ddc));
+
+	if (!ddc) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	ddc->pin_data = dal_gpio_create(
+		service, GPIO_ID_DDC_DATA, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);
+
+	if (!ddc->pin_data) {
+		BREAK_TO_DEBUGGER();
+		goto failure_1;
+	}
+
+	ddc->pin_clock = dal_gpio_create(
+		service, GPIO_ID_DDC_CLOCK, en, GPIO_PIN_OUTPUT_STATE_DEFAULT);
+
+	if (!ddc->pin_clock) {
+		BREAK_TO_DEBUGGER();
+		goto failure_2;
+	}
+
+	ddc->hw_info = *info;
+
+	ddc->ctx = service->ctx;
+
+	return ddc;
+
+failure_2:
+	dal_gpio_destroy(&ddc->pin_data);
+
+failure_1:
+	dm_free(ddc);
+
+	return NULL;
+}
+
+void dal_gpio_destroy_ddc(
+	struct ddc **ddc)
+{
+	if (!ddc || !*ddc) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	dal_ddc_close(*ddc);
+	dal_gpio_destroy(&(*ddc)->pin_data);
+	dal_gpio_destroy(&(*ddc)->pin_clock);
+	dm_free(*ddc);
+
+	*ddc = NULL;
+}
+
+enum gpio_result dal_ddc_open(
+	struct ddc *ddc,
+	enum gpio_mode mode,
+	enum gpio_ddc_config_type config_type)
+{
+	enum gpio_result result;
+
+	struct gpio_ddc_open_options data_options;
+	struct gpio_ddc_open_options clock_options;
+	struct gpio_config_data config_data;
+
+	result = dal_gpio_open_ex(ddc->pin_data, mode, &data_options);
+
+	if (result != GPIO_RESULT_OK) {
+		BREAK_TO_DEBUGGER();
+		return result;
+	}
+
+	result = dal_gpio_open_ex(ddc->pin_clock, mode, &clock_options);
+
+	if (result != GPIO_RESULT_OK) {
+		BREAK_TO_DEBUGGER();
+		goto failure;
+	}
+
+	/* DDC clock and data pins should belong
+	 * to the same DDC block id,
+	 * we use the data pin to set the pad mode. */
+
+	if (mode == GPIO_MODE_INPUT)
+		/* this is from detect_sink_type,
+		 * we need extra delay there */
+		config_data.type = GPIO_CONFIG_TYPE_I2C_AUX_DUAL_MODE;
+	else
+		config_data.type = GPIO_CONFIG_TYPE_DDC;
+
+	config_data.config.ddc.type = config_type;
+	config_data.config.ddc.data_en_bit_present =
+		data_options.en_bit_present;
+	config_data.config.ddc.clock_en_bit_present =
+		clock_options.en_bit_present;
+
+	result = dal_gpio_set_config(ddc->pin_data, &config_data);
+
+	if (result == GPIO_RESULT_OK)
+		return result;
+
+	BREAK_TO_DEBUGGER();
+
+	dal_gpio_close(ddc->pin_clock);
+
+failure:
+	dal_gpio_close(ddc->pin_data);
+
+	return result;
+}
+
+enum gpio_result dal_ddc_get_clock(
+	const struct ddc *ddc,
+	uint32_t *value)
+{
+	return dal_gpio_get_value(ddc->pin_clock, value);
+}
+
+enum gpio_result dal_ddc_set_clock(
+	const struct ddc *ddc,
+	uint32_t value)
+{
+	return dal_gpio_set_value(ddc->pin_clock, value);
+}
+
+enum gpio_result dal_ddc_get_data(
+	const struct ddc *ddc,
+	uint32_t *value)
+{
+	return dal_gpio_get_value(ddc->pin_data, value);
+}
+
+enum gpio_result dal_ddc_set_data(
+	const struct ddc *ddc,
+	uint32_t value)
+{
+	return dal_gpio_set_value(ddc->pin_data, value);
+}
+
+enum gpio_result dal_ddc_change_mode(
+	struct ddc *ddc,
+	enum gpio_mode mode)
+{
+	enum gpio_result result;
+
+	enum gpio_mode original_mode =
+		dal_gpio_get_mode(ddc->pin_data);
+
+	result = dal_gpio_change_mode(ddc->pin_data, mode);
+
+	/* [anaumov] DAL2 code returns GPIO_RESULT_NON_SPECIFIC_ERROR
+	 * in case of failures;
+	 * set_mode() is so that, in case of failure,
+	 * we must explicitly set original mode */
+
+	if (result != GPIO_RESULT_OK)
+		goto failure;
+
+	result = dal_gpio_change_mode(ddc->pin_clock, mode);
+
+	if (result == GPIO_RESULT_OK)
+		return result;
+
+	dal_gpio_change_mode(ddc->pin_clock, original_mode);
+
+failure:
+	dal_gpio_change_mode(ddc->pin_data, original_mode);
+
+	return result;
+}
+
+bool dal_ddc_is_hw_supported(
+	const struct ddc *ddc)
+{
+	return ddc->hw_info.hw_supported;
+}
+
+enum gpio_ddc_line dal_ddc_get_line(
+	const struct ddc *ddc)
+{
+	return (enum gpio_ddc_line)dal_gpio_get_enum(ddc->pin_data);
+}
+
+bool dal_ddc_check_line_aborted(
+	const struct ddc *self)
+{
+	/* No arbitration with VBIOS is performed since DCE 6.0 */
+
+	return false;
+}
+
+enum gpio_result dal_ddc_set_config(
+	struct ddc *ddc,
+	enum gpio_ddc_config_type config_type)
+{
+	struct gpio_config_data config_data;
+
+	config_data.type = GPIO_CONFIG_TYPE_DDC;
+
+	config_data.config.ddc.type = config_type;
+	config_data.config.ddc.data_en_bit_present = false;
+	config_data.config.ddc.clock_en_bit_present = false;
+
+	return dal_gpio_set_config(ddc->pin_data, &config_data);
+}
+
+void dal_ddc_close(
+	struct ddc *ddc)
+{
+	dal_gpio_close(ddc->pin_clock);
+	dal_gpio_close(ddc->pin_data);
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c b/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c
index 6c39423..ecd6f65 100644
--- a/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c
+++ b/drivers/gpu/drm/amd/dal/dc/i2caux/i2caux.c
@@ -265,7 +265,7 @@ static bool get_hw_supported_ddc_line(
 		return false;
 	}
 
-	if (!dal_ddc_is_hw_supported(ddc))
+	if (!ddc->hw_info.hw_supported)
 		return false;
 
 	line_found = dal_ddc_get_line(ddc);
diff --git a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
index 0c8c1c2..65c3a32 100644
--- a/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adapter_service_interface.h
@@ -28,7 +28,6 @@
 
 #include "grph_object_ctrl_defs.h"
 #include "gpio_interface.h"
-#include "ddc_interface.h"
 #include "bios_parser_interface.h"
 #include "adapter_service_types.h"
 #include "dal_types.h"
diff --git a/drivers/gpu/drm/amd/dal/include/ddc_interface.h b/drivers/gpu/drm/amd/dal/include/ddc_interface.h
deleted file mode 100644
index 22fd31f..0000000
--- a/drivers/gpu/drm/amd/dal/include/ddc_interface.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2012-15 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DAL_DDC_INTERFACE_H__
-#define __DAL_DDC_INTERFACE_H__
-
-#include "gpio_types.h"
-
-struct ddc;
-
-enum gpio_result dal_ddc_open(
-	struct ddc *ddc,
-	enum gpio_mode mode,
-	enum gpio_ddc_config_type config_type);
-
-enum gpio_result dal_ddc_get_clock(
-	const struct ddc *ddc,
-	uint32_t *value);
-
-enum gpio_result dal_ddc_set_clock(
-	const struct ddc *ddc,
-	uint32_t value);
-
-enum gpio_result dal_ddc_get_data(
-	const struct ddc *ddc,
-	uint32_t *value);
-
-enum gpio_result dal_ddc_set_data(
-	const struct ddc *ddc,
-	uint32_t value);
-
-enum gpio_result dal_ddc_change_mode(
-	struct ddc *ddc,
-	enum gpio_mode mode);
-
-bool dal_ddc_is_hw_supported(
-	const struct ddc *ddc);
-
-enum gpio_ddc_line dal_ddc_get_line(
-	const struct ddc *ddc);
-
-bool dal_ddc_check_line_aborted(
-	const struct ddc *ddc);
-
-enum gpio_result dal_ddc_set_config(
-	struct ddc *ddc,
-	enum gpio_ddc_config_type config_type);
-
-void dal_ddc_close(
-	struct ddc *ddc);
-
-#endif
diff --git a/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h b/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h
index e69f0a1..7e99a04 100644
--- a/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/gpio_service_interface.h
@@ -28,7 +28,6 @@
 
 #include "gpio_types.h"
 #include "gpio_interface.h"
-#include "ddc_interface.h"
 #include "hw/gpio.h"
 
 struct gpio_service;
@@ -86,4 +85,46 @@ struct gpio *dal_gpio_create_irq(
 void dal_gpio_destroy_irq(
 	struct gpio **ptr);
 
+
+enum gpio_result dal_ddc_open(
+	struct ddc *ddc,
+	enum gpio_mode mode,
+	enum gpio_ddc_config_type config_type);
+
+enum gpio_result dal_ddc_get_clock(
+	const struct ddc *ddc,
+	uint32_t *value);
+
+enum gpio_result dal_ddc_set_clock(
+	const struct ddc *ddc,
+	uint32_t value);
+
+enum gpio_result dal_ddc_get_data(
+	const struct ddc *ddc,
+	uint32_t *value);
+
+enum gpio_result dal_ddc_set_data(
+	const struct ddc *ddc,
+	uint32_t value);
+
+enum gpio_result dal_ddc_change_mode(
+	struct ddc *ddc,
+	enum gpio_mode mode);
+
+bool dal_ddc_is_hw_supported(
+	const struct ddc *ddc);
+
+enum gpio_ddc_line dal_ddc_get_line(
+	const struct ddc *ddc);
+
+bool dal_ddc_check_line_aborted(
+	const struct ddc *ddc);
+
+enum gpio_result dal_ddc_set_config(
+	struct ddc *ddc,
+	enum gpio_ddc_config_type config_type);
+
+void dal_ddc_close(
+	struct ddc *ddc);
+
 #endif
diff --git a/drivers/gpu/drm/amd/dal/include/i2caux_interface.h b/drivers/gpu/drm/amd/dal/include/i2caux_interface.h
index b23e6c0..ecbf849 100644
--- a/drivers/gpu/drm/amd/dal/include/i2caux_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/i2caux_interface.h
@@ -26,8 +26,9 @@
 #ifndef __DAL_I2CAUX_INTERFACE_H__
 #define __DAL_I2CAUX_INTERFACE_H__
 
-#include "ddc_interface.h"
 #include "adapter_service_interface.h"
+#include "gpio_service_interface.h"
+
 
 #define DEFAULT_AUX_MAX_DATA_SIZE 16
 #define AUX_MAX_DEFER_WRITE_RETRY 20
-- 
2.7.4

