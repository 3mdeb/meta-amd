From 96bcd3e235a5d326f455944e8393e254925b58bc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 16 Apr 2015 22:53:04 +0200
Subject: [PATCH 07/29] winsys/radeon: add a private interface for
 radeon_surface

Signed-off-by: Arindam Nath <arindam.nath@amd.com>
---
 src/gallium/drivers/r600/evergreen_state.c         |   6 +-
 src/gallium/drivers/r600/r600_uvd.c                |   2 +-
 src/gallium/drivers/radeon/r600_pipe_common.h      |   2 +-
 src/gallium/drivers/radeon/r600_texture.c          |  12 +-
 src/gallium/drivers/radeon/radeon_uvd.c            |   6 +-
 src/gallium/drivers/radeon/radeon_uvd.h            |   4 +-
 src/gallium/drivers/radeon/radeon_vce.c            |   2 +-
 src/gallium/drivers/radeon/radeon_vce.h            |   6 +-
 src/gallium/drivers/radeon/radeon_video.c          |   2 +-
 src/gallium/drivers/radeon/radeon_video.h          |   2 +-
 src/gallium/drivers/radeonsi/si_state.c            |   4 +-
 src/gallium/drivers/radeonsi/si_uvd.c              |   4 +-
 src/gallium/winsys/radeon/drm/Makefile.sources     |   1 +
 src/gallium/winsys/radeon/drm/radeon_drm_surface.c | 180 +++++++++++++++++++++
 src/gallium/winsys/radeon/drm/radeon_drm_winsys.c  |  20 +--
 src/gallium/winsys/radeon/drm/radeon_drm_winsys.h  |   1 +
 src/gallium/winsys/radeon/radeon_winsys.h          |  79 ++++++++-
 17 files changed, 286 insertions(+), 47 deletions(-)
 create mode 100644 src/gallium/winsys/radeon/drm/radeon_drm_surface.c

diff --git a/src/gallium/drivers/r600/evergreen_state.c b/src/gallium/drivers/r600/evergreen_state.c
index edd886b..8951ab0 100644
--- a/src/gallium/drivers/r600/evergreen_state.c
+++ b/src/gallium/drivers/r600/evergreen_state.c
@@ -664,7 +664,7 @@ evergreen_create_sampler_view_custom(struct pipe_context *ctx,
 	unsigned height, depth, width;
 	unsigned macro_aspect, tile_split, bankh, bankw, nbanks, fmask_bankh;
 	enum pipe_format pipe_format = state->format;
-	struct radeon_surface_level *surflevel;
+	struct radeon_surf_level *surflevel;
 	unsigned base_level, first_level, last_level;
 	uint64_t va;
 
@@ -918,7 +918,7 @@ static void evergreen_emit_scissor_state(struct r600_context *rctx, struct r600_
 /**
  * This function intializes the CB* register values for RATs.  It is meant
  * to be used for 1D aligned buffers that do not have an associated
- * radeon_surface.
+ * radeon_surf.
  */
 void evergreen_init_color_surface_rat(struct r600_context *rctx,
 					struct r600_surface *surf)
@@ -1163,7 +1163,7 @@ static void evergreen_init_depth_surface(struct r600_context *rctx,
 	struct r600_screen *rscreen = rctx->screen;
 	struct r600_texture *rtex = (struct r600_texture*)surf->base.texture;
 	unsigned level = surf->base.u.tex.level;
-	struct radeon_surface_level *levelinfo = &rtex->surface.level[level];
+	struct radeon_surf_level *levelinfo = &rtex->surface.level[level];
 	uint64_t offset;
 	unsigned format, array_mode;
 	unsigned macro_aspect, tile_split, bankh, bankw, nbanks;
diff --git a/src/gallium/drivers/r600/r600_uvd.c b/src/gallium/drivers/r600/r600_uvd.c
index ee5288f..357e901 100644
--- a/src/gallium/drivers/r600/r600_uvd.c
+++ b/src/gallium/drivers/r600/r600_uvd.c
@@ -57,7 +57,7 @@ struct pipe_video_buffer *r600_video_buffer_create(struct pipe_context *pipe,
 {
 	struct r600_context *ctx = (struct r600_context *)pipe;
 	struct r600_texture *resources[VL_NUM_COMPONENTS] = {};
-	struct radeon_surface* surfaces[VL_NUM_COMPONENTS] = {};
+	struct radeon_surf* surfaces[VL_NUM_COMPONENTS] = {};
 	struct pb_buffer **pbs[VL_NUM_COMPONENTS] = {};
 	const enum pipe_format *resource_formats;
 	struct pipe_video_buffer template;
diff --git a/src/gallium/drivers/radeon/r600_pipe_common.h b/src/gallium/drivers/radeon/r600_pipe_common.h
index b7df001..bdb4541 100644
--- a/src/gallium/drivers/radeon/r600_pipe_common.h
+++ b/src/gallium/drivers/radeon/r600_pipe_common.h
@@ -195,7 +195,7 @@ struct r600_texture {
 	unsigned			dirty_level_mask; /* each bit says if that mipmap is compressed */
 	struct r600_texture		*flushed_depth_texture;
 	boolean				is_flushing_texture;
-	struct radeon_surface		surface;
+	struct radeon_surf		surface;
 
 	/* Colorbuffer compression and fast clear. */
 	struct r600_fmask_info		fmask;
diff --git a/src/gallium/drivers/radeon/r600_texture.c b/src/gallium/drivers/radeon/r600_texture.c
index ab8ce7b..dc510c9 100644
--- a/src/gallium/drivers/radeon/r600_texture.c
+++ b/src/gallium/drivers/radeon/r600_texture.c
@@ -119,7 +119,7 @@ static unsigned r600_texture_get_offset(struct r600_texture *rtex, unsigned leve
 }
 
 static int r600_init_surface(struct r600_common_screen *rscreen,
-			     struct radeon_surface *surface,
+			     struct radeon_surf *surface,
 			     const struct pipe_resource *ptex,
 			     unsigned array_mode,
 			     bool is_flushed_depth)
@@ -234,7 +234,7 @@ static boolean r600_texture_get_handle(struct pipe_screen* screen,
 {
 	struct r600_texture *rtex = (struct r600_texture*)ptex;
 	struct r600_resource *resource = &rtex->resource;
-	struct radeon_surface *surface = &rtex->surface;
+	struct radeon_surf *surface = &rtex->surface;
 	struct r600_common_screen *rscreen = (struct r600_common_screen*)screen;
 
 	rscreen->ws->buffer_set_tiling(resource->buf,
@@ -280,7 +280,7 @@ void r600_texture_get_fmask_info(struct r600_common_screen *rscreen,
 				 struct r600_fmask_info *out)
 {
 	/* FMASK is allocated like an ordinary texture. */
-	struct radeon_surface fmask = rtex->surface;
+	struct radeon_surf fmask = rtex->surface;
 
 	memset(out, 0, sizeof(*out));
 
@@ -570,7 +570,7 @@ r600_texture_create_object(struct pipe_screen *screen,
 			   const struct pipe_resource *base,
 			   unsigned pitch_in_bytes_override,
 			   struct pb_buffer *buf,
-			   struct radeon_surface *surface)
+			   struct radeon_surf *surface)
 {
 	struct r600_texture *rtex;
 	struct r600_resource *resource;
@@ -764,7 +764,7 @@ struct pipe_resource *r600_texture_create(struct pipe_screen *screen,
 					  const struct pipe_resource *templ)
 {
 	struct r600_common_screen *rscreen = (struct r600_common_screen*)screen;
-	struct radeon_surface surface = {0};
+	struct radeon_surf surface = {0};
 	int r;
 
 	r = r600_init_surface(rscreen, &surface, templ,
@@ -790,7 +790,7 @@ static struct pipe_resource *r600_texture_from_handle(struct pipe_screen *screen
 	unsigned stride = 0;
 	unsigned array_mode;
 	enum radeon_bo_layout micro, macro;
-	struct radeon_surface surface;
+	struct radeon_surf surface;
 	bool scanout;
 	int r;
 
diff --git a/src/gallium/drivers/radeon/radeon_uvd.c b/src/gallium/drivers/radeon/radeon_uvd.c
index 4d4b54b..be58d0b 100644
--- a/src/gallium/drivers/radeon/radeon_uvd.c
+++ b/src/gallium/drivers/radeon/radeon_uvd.c
@@ -870,7 +870,7 @@ error:
 }
 
 /* calculate top/bottom offset */
-static unsigned texture_offset(struct radeon_surface *surface, unsigned layer)
+static unsigned texture_offset(struct radeon_surf *surface, unsigned layer)
 {
 	return surface->level[0].offset +
 		layer * surface->level[0].slice_size;
@@ -905,8 +905,8 @@ static unsigned bank_wh(unsigned bankwh)
 /**
  * fill decoding target field from the luma and chroma surfaces
  */
-void ruvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surface *luma,
-			  struct radeon_surface *chroma)
+void ruvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surf *luma,
+			  struct radeon_surf *chroma)
 {
 	msg->body.decode.dt_pitch = luma->level[0].pitch_bytes;
 	switch (luma->level[0].mode) {
diff --git a/src/gallium/drivers/radeon/radeon_uvd.h b/src/gallium/drivers/radeon/radeon_uvd.h
index 41a6fb4..7442865 100644
--- a/src/gallium/drivers/radeon/radeon_uvd.h
+++ b/src/gallium/drivers/radeon/radeon_uvd.h
@@ -353,6 +353,6 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 					     ruvd_set_dtb set_dtb);
 
 /* fill decoding target field from the luma and chroma surfaces */
-void ruvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surface *luma,
-			  struct radeon_surface *chroma);
+void ruvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surf *luma,
+			  struct radeon_surf *chroma);
 #endif
diff --git a/src/gallium/drivers/radeon/radeon_vce.c b/src/gallium/drivers/radeon/radeon_vce.c
index 5f710e6..e220f40 100644
--- a/src/gallium/drivers/radeon/radeon_vce.c
+++ b/src/gallium/drivers/radeon/radeon_vce.c
@@ -337,7 +337,7 @@ struct pipe_video_codec *rvce_create_encoder(struct pipe_context *context,
 	struct r600_common_screen *rscreen = (struct r600_common_screen *)context->screen;
 	struct rvce_encoder *enc;
 	struct pipe_video_buffer *tmp_buf, templat = {};
-	struct radeon_surface *tmp_surf;
+	struct radeon_surf *tmp_surf;
 	unsigned cpb_size;
 
 	if (!rscreen->info.vce_fw_version) {
diff --git a/src/gallium/drivers/radeon/radeon_vce.h b/src/gallium/drivers/radeon/radeon_vce.h
index 7f0cd1f..5c6317a 100644
--- a/src/gallium/drivers/radeon/radeon_vce.h
+++ b/src/gallium/drivers/radeon/radeon_vce.h
@@ -50,7 +50,7 @@ struct r600_common_screen;
 /* driver dependent callback */
 typedef void (*rvce_get_buffer)(struct pipe_resource *resource,
 				struct radeon_winsys_cs_handle **handle,
-				struct radeon_surface **surface);
+				struct radeon_surf **surface);
 
 /* Coded picture buffer slot */
 struct rvce_cpb_slot {
@@ -88,8 +88,8 @@ struct rvce_encoder {
 	rvce_get_buffer			get_buffer;
 
 	struct radeon_winsys_cs_handle*	handle;
-	struct radeon_surface*		luma;
-	struct radeon_surface*		chroma;
+	struct radeon_surf*		luma;
+	struct radeon_surf*		chroma;
 
 	struct radeon_winsys_cs_handle*	bs_handle;
 	unsigned			bs_size;
diff --git a/src/gallium/drivers/radeon/radeon_video.c b/src/gallium/drivers/radeon/radeon_video.c
index 6ec10c1..826e076 100644
--- a/src/gallium/drivers/radeon/radeon_video.c
+++ b/src/gallium/drivers/radeon/radeon_video.c
@@ -132,7 +132,7 @@ void rvid_clear_buffer(struct pipe_context *context, struct rvid_buffer* buffer)
  */
 void rvid_join_surfaces(struct radeon_winsys* ws, unsigned bind,
 			struct pb_buffer** buffers[VL_NUM_COMPONENTS],
-			struct radeon_surface *surfaces[VL_NUM_COMPONENTS])
+			struct radeon_surf *surfaces[VL_NUM_COMPONENTS])
 {
 	unsigned best_tiling, best_wh, off;
 	unsigned size, alignment;
diff --git a/src/gallium/drivers/radeon/radeon_video.h b/src/gallium/drivers/radeon/radeon_video.h
index 6d0ff28..c9ee67f 100644
--- a/src/gallium/drivers/radeon/radeon_video.h
+++ b/src/gallium/drivers/radeon/radeon_video.h
@@ -68,7 +68,7 @@ void rvid_clear_buffer(struct pipe_context *context, struct rvid_buffer* buffer)
    sumup their sizes and replace the backend buffers with a single bo */
 void rvid_join_surfaces(struct radeon_winsys* ws, unsigned bind,
                         struct pb_buffer** buffers[VL_NUM_COMPONENTS],
-                        struct radeon_surface *surfaces[VL_NUM_COMPONENTS]);
+                        struct radeon_surf *surfaces[VL_NUM_COMPONENTS]);
 
 /* returns supported codecs and other parameters */
 int rvid_get_video_param(struct pipe_screen *screen,
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index dc19d29..7f0fdd5 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -1852,7 +1852,7 @@ static void si_init_depth_surface(struct si_context *sctx,
 	struct si_screen *sscreen = sctx->screen;
 	struct r600_texture *rtex = (struct r600_texture*)surf->base.texture;
 	unsigned level = surf->base.u.tex.level;
-	struct radeon_surface_level *levelinfo = &rtex->surface.level[level];
+	struct radeon_surf_level *levelinfo = &rtex->surface.level[level];
 	unsigned format, tile_mode_index, array_mode;
 	unsigned macro_aspect, tile_split, stile_split, bankh, bankw, nbanks, pipe_config;
 	uint32_t z_info, s_info, db_depth_info;
@@ -2258,7 +2258,7 @@ static struct pipe_sampler_view *si_create_sampler_view(struct pipe_context *ctx
 	unsigned char state_swizzle[4], swizzle[4];
 	unsigned height, depth, width;
 	enum pipe_format pipe_format = state->format;
-	struct radeon_surface_level *surflevel;
+	struct radeon_surf_level *surflevel;
 	int first_non_void;
 	uint64_t va;
 
diff --git a/src/gallium/drivers/radeonsi/si_uvd.c b/src/gallium/drivers/radeonsi/si_uvd.c
index 0ba3b12..2f10f9b 100644
--- a/src/gallium/drivers/radeonsi/si_uvd.c
+++ b/src/gallium/drivers/radeonsi/si_uvd.c
@@ -44,7 +44,7 @@ struct pipe_video_buffer *si_video_buffer_create(struct pipe_context *pipe,
 {
 	struct si_context *ctx = (struct si_context *)pipe;
 	struct r600_texture *resources[VL_NUM_COMPONENTS] = {};
-	struct radeon_surface *surfaces[VL_NUM_COMPONENTS] = {};
+	struct radeon_surf *surfaces[VL_NUM_COMPONENTS] = {};
 	struct pb_buffer **pbs[VL_NUM_COMPONENTS] = {};
 	const enum pipe_format *resource_formats;
 	struct pipe_video_buffer template;
@@ -136,7 +136,7 @@ static struct radeon_winsys_cs_handle* si_uvd_set_dtb(struct ruvd_msg *msg, stru
 /* get the radeon resources for VCE */
 static void si_vce_get_buffer(struct pipe_resource *resource,
 			      struct radeon_winsys_cs_handle **handle,
-			      struct radeon_surface **surface)
+			      struct radeon_surf **surface)
 {
 	struct r600_texture *res = (struct r600_texture *)resource;
 
diff --git a/src/gallium/winsys/radeon/drm/Makefile.sources b/src/gallium/winsys/radeon/drm/Makefile.sources
index ced788b..13a71c4 100644
--- a/src/gallium/winsys/radeon/drm/Makefile.sources
+++ b/src/gallium/winsys/radeon/drm/Makefile.sources
@@ -5,6 +5,7 @@ C_SOURCES := \
 	radeon_drm_cs_dump.c \
 	radeon_drm_cs.h \
 	radeon_drm_public.h \
+	radeon_drm_surface.c \
 	radeon_drm_winsys.c \
 	radeon_drm_winsys.h \
 	../radeon_winsys.h
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_surface.c b/src/gallium/winsys/radeon/drm/radeon_drm_surface.c
new file mode 100644
index 0000000..29d3467
--- /dev/null
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_surface.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright © 2014 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
+ * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * Authors:
+ *   Marek Olšák <maraeo@gmail.com>
+ */
+
+#include "radeon_drm_winsys.h"
+
+#include <radeon_surface.h>
+
+static void surf_level_winsys_to_drm(struct radeon_surface_level *level_drm,
+                                     const struct radeon_surf_level *level_ws)
+{
+    level_drm->offset = level_ws->offset;
+    level_drm->slice_size = level_ws->slice_size;
+    level_drm->npix_x = level_ws->npix_x;
+    level_drm->npix_y = level_ws->npix_y;
+    level_drm->npix_z = level_ws->npix_z;
+    level_drm->nblk_x = level_ws->nblk_x;
+    level_drm->nblk_y = level_ws->nblk_y;
+    level_drm->nblk_z = level_ws->nblk_z;
+    level_drm->pitch_bytes = level_ws->pitch_bytes;
+    level_drm->mode = level_ws->mode;
+}
+
+static void surf_level_drm_to_winsys(struct radeon_surf_level *level_ws,
+                                     const struct radeon_surface_level *level_drm)
+{
+    level_ws->offset = level_drm->offset;
+    level_ws->slice_size = level_drm->slice_size;
+    level_ws->npix_x = level_drm->npix_x;
+    level_ws->npix_y = level_drm->npix_y;
+    level_ws->npix_z = level_drm->npix_z;
+    level_ws->nblk_x = level_drm->nblk_x;
+    level_ws->nblk_y = level_drm->nblk_y;
+    level_ws->nblk_z = level_drm->nblk_z;
+    level_ws->pitch_bytes = level_drm->pitch_bytes;
+    level_ws->mode = level_drm->mode;
+}
+
+static void surf_winsys_to_drm(struct radeon_surface *surf_drm,
+                               const struct radeon_surf *surf_ws)
+{
+    int i;
+
+    memset(surf_drm, 0, sizeof(*surf_drm));
+
+    surf_drm->npix_x = surf_ws->npix_x;
+    surf_drm->npix_y = surf_ws->npix_y;
+    surf_drm->npix_z = surf_ws->npix_z;
+    surf_drm->blk_w = surf_ws->blk_w;
+    surf_drm->blk_h = surf_ws->blk_h;
+    surf_drm->blk_d = surf_ws->blk_d;
+    surf_drm->array_size = surf_ws->array_size;
+    surf_drm->last_level = surf_ws->last_level;
+    surf_drm->bpe = surf_ws->bpe;
+    surf_drm->nsamples = surf_ws->nsamples;
+    surf_drm->flags = surf_ws->flags;
+
+    surf_drm->bo_size = surf_ws->bo_size;
+    surf_drm->bo_alignment = surf_ws->bo_alignment;
+
+    surf_drm->bankw = surf_ws->bankw;
+    surf_drm->bankh = surf_ws->bankh;
+    surf_drm->mtilea = surf_ws->mtilea;
+    surf_drm->tile_split = surf_ws->tile_split;
+    surf_drm->stencil_tile_split = surf_ws->stencil_tile_split;
+    surf_drm->stencil_offset = surf_ws->stencil_offset;
+
+    for (i = 0; i < RADEON_SURF_MAX_LEVEL; i++) {
+        surf_level_winsys_to_drm(&surf_drm->level[i], &surf_ws->level[i]);
+        surf_level_winsys_to_drm(&surf_drm->stencil_level[i],
+                                 &surf_ws->stencil_level[i]);
+
+        surf_drm->tiling_index[i] = surf_ws->tiling_index[i];
+        surf_drm->stencil_tiling_index[i] = surf_ws->stencil_tiling_index[i];
+    }
+}
+
+static void surf_drm_to_winsys(struct radeon_surf *surf_ws,
+                               const struct radeon_surface *surf_drm)
+{
+    int i;
+
+    memset(surf_ws, 0, sizeof(*surf_ws));
+
+    surf_ws->npix_x = surf_drm->npix_x;
+    surf_ws->npix_y = surf_drm->npix_y;
+    surf_ws->npix_z = surf_drm->npix_z;
+    surf_ws->blk_w = surf_drm->blk_w;
+    surf_ws->blk_h = surf_drm->blk_h;
+    surf_ws->blk_d = surf_drm->blk_d;
+    surf_ws->array_size = surf_drm->array_size;
+    surf_ws->last_level = surf_drm->last_level;
+    surf_ws->bpe = surf_drm->bpe;
+    surf_ws->nsamples = surf_drm->nsamples;
+    surf_ws->flags = surf_drm->flags;
+
+    surf_ws->bo_size = surf_drm->bo_size;
+    surf_ws->bo_alignment = surf_drm->bo_alignment;
+
+    surf_ws->bankw = surf_drm->bankw;
+    surf_ws->bankh = surf_drm->bankh;
+    surf_ws->mtilea = surf_drm->mtilea;
+    surf_ws->tile_split = surf_drm->tile_split;
+    surf_ws->stencil_tile_split = surf_drm->stencil_tile_split;
+    surf_ws->stencil_offset = surf_drm->stencil_offset;
+
+    for (i = 0; i < RADEON_SURF_MAX_LEVEL; i++) {
+        surf_level_drm_to_winsys(&surf_ws->level[i], &surf_drm->level[i]);
+        surf_level_drm_to_winsys(&surf_ws->stencil_level[i],
+                                 &surf_drm->stencil_level[i]);
+
+        surf_ws->tiling_index[i] = surf_drm->tiling_index[i];
+        surf_ws->stencil_tiling_index[i] = surf_drm->stencil_tiling_index[i];
+    }
+}
+
+static int radeon_winsys_surface_init(struct radeon_winsys *rws,
+                                      struct radeon_surf *surf_ws)
+{
+    struct radeon_drm_winsys *ws = (struct radeon_drm_winsys*)rws;
+    struct radeon_surface surf_drm;
+    int r;
+
+    surf_winsys_to_drm(&surf_drm, surf_ws);
+
+    r = radeon_surface_init(ws->surf_man, &surf_drm);
+    if (r)
+        return r;
+
+    surf_drm_to_winsys(surf_ws, &surf_drm);
+    return 0;
+}
+
+static int radeon_winsys_surface_best(struct radeon_winsys *rws,
+                                      struct radeon_surf *surf_ws)
+{
+    struct radeon_drm_winsys *ws = (struct radeon_drm_winsys*)rws;
+    struct radeon_surface surf_drm;
+    int r;
+
+    surf_winsys_to_drm(&surf_drm, surf_ws);
+
+    r = radeon_surface_best(ws->surf_man, &surf_drm);
+    if (r)
+        return r;
+
+    surf_drm_to_winsys(surf_ws, &surf_drm);
+    return 0;
+}
+
+void radeon_surface_init_functions(struct radeon_drm_winsys *ws)
+{
+    ws->base.surface_init = radeon_winsys_surface_init;
+    ws->base.surface_best = radeon_winsys_surface_best;
+}
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
index 2b12f4d..12767bf 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
@@ -44,6 +44,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <radeon_surface.h>
 
 #ifndef RADEON_INFO_ACTIVE_CU_COUNT
 #define RADEON_INFO_ACTIVE_CU_COUNT 0x20
@@ -507,22 +508,6 @@ static boolean radeon_cs_request_feature(struct radeon_winsys_cs *rcs,
     return FALSE;
 }
 
-static int radeon_drm_winsys_surface_init(struct radeon_winsys *rws,
-                                          struct radeon_surface *surf)
-{
-    struct radeon_drm_winsys *ws = (struct radeon_drm_winsys*)rws;
-
-    return radeon_surface_init(ws->surf_man, surf);
-}
-
-static int radeon_drm_winsys_surface_best(struct radeon_winsys *rws,
-                                          struct radeon_surface *surf)
-{
-    struct radeon_drm_winsys *ws = (struct radeon_drm_winsys*)rws;
-
-    return radeon_surface_best(ws->surf_man, surf);
-}
-
 static uint64_t radeon_query_value(struct radeon_winsys *rws,
                                    enum radeon_value_id value)
 {
@@ -706,12 +691,11 @@ radeon_drm_winsys_create(int fd, radeon_screen_create_t screen_create)
     ws->base.destroy = radeon_winsys_destroy;
     ws->base.query_info = radeon_query_info;
     ws->base.cs_request_feature = radeon_cs_request_feature;
-    ws->base.surface_init = radeon_drm_winsys_surface_init;
-    ws->base.surface_best = radeon_drm_winsys_surface_best;
     ws->base.query_value = radeon_query_value;
 
     radeon_bomgr_init_functions(ws);
     radeon_drm_cs_init_functions(ws);
+    radeon_surface_init_functions(ws);
 
     pipe_mutex_init(ws->hyperz_owner_mutex);
     pipe_mutex_init(ws->cmask_owner_mutex);
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.h b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.h
index 70657be..3200f0d 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.h
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.h
@@ -103,5 +103,6 @@ radeon_drm_winsys(struct radeon_winsys *base)
 }
 
 void radeon_drm_ws_queue_cs(struct radeon_drm_winsys *ws, struct radeon_drm_cs *cs);
+void radeon_surface_init_functions(struct radeon_drm_winsys *ws);
 
 #endif
diff --git a/src/gallium/winsys/radeon/radeon_winsys.h b/src/gallium/winsys/radeon/radeon_winsys.h
index a8cc60a..7fb7ac9 100644
--- a/src/gallium/winsys/radeon/radeon_winsys.h
+++ b/src/gallium/winsys/radeon/radeon_winsys.h
@@ -41,7 +41,6 @@
  */
 
 #include "pipebuffer/pb_buffer.h"
-#include "radeon_surface.h"
 
 #define RADEON_MAX_CMDBUF_DWORDS (16 * 1024)
 
@@ -243,6 +242,80 @@ enum radeon_feature_id {
     RADEON_FID_R300_CMASK_ACCESS,
 };
 
+#define RADEON_SURF_MAX_LEVEL                   32
+
+#define RADEON_SURF_TYPE_MASK                   0xFF
+#define RADEON_SURF_TYPE_SHIFT                  0
+#define     RADEON_SURF_TYPE_1D                     0
+#define     RADEON_SURF_TYPE_2D                     1
+#define     RADEON_SURF_TYPE_3D                     2
+#define     RADEON_SURF_TYPE_CUBEMAP                3
+#define     RADEON_SURF_TYPE_1D_ARRAY               4
+#define     RADEON_SURF_TYPE_2D_ARRAY               5
+#define RADEON_SURF_MODE_MASK                   0xFF
+#define RADEON_SURF_MODE_SHIFT                  8
+#define     RADEON_SURF_MODE_LINEAR                 0
+#define     RADEON_SURF_MODE_LINEAR_ALIGNED         1
+#define     RADEON_SURF_MODE_1D                     2
+#define     RADEON_SURF_MODE_2D                     3
+#define RADEON_SURF_SCANOUT                     (1 << 16)
+#define RADEON_SURF_ZBUFFER                     (1 << 17)
+#define RADEON_SURF_SBUFFER                     (1 << 18)
+#define RADEON_SURF_Z_OR_SBUFFER                (RADEON_SURF_ZBUFFER | RADEON_SURF_SBUFFER)
+#define RADEON_SURF_HAS_SBUFFER_MIPTREE         (1 << 19)
+#define RADEON_SURF_HAS_TILE_MODE_INDEX         (1 << 20)
+#define RADEON_SURF_FMASK                       (1 << 21)
+
+#define RADEON_SURF_GET(v, field)   (((v) >> RADEON_SURF_ ## field ## _SHIFT) & RADEON_SURF_ ## field ## _MASK)
+#define RADEON_SURF_SET(v, field)   (((v) & RADEON_SURF_ ## field ## _MASK) << RADEON_SURF_ ## field ## _SHIFT)
+#define RADEON_SURF_CLR(v, field)   ((v) & ~(RADEON_SURF_ ## field ## _MASK << RADEON_SURF_ ## field ## _SHIFT))
+
+struct radeon_surf_level {
+    uint64_t                    offset;
+    uint64_t                    slice_size;
+    uint32_t                    npix_x;
+    uint32_t                    npix_y;
+    uint32_t                    npix_z;
+    uint32_t                    nblk_x;
+    uint32_t                    nblk_y;
+    uint32_t                    nblk_z;
+    uint32_t                    pitch_bytes;
+    uint32_t                    mode;
+};
+
+struct radeon_surf {
+    /* These are inputs to the calculator. */
+    uint32_t                    npix_x;
+    uint32_t                    npix_y;
+    uint32_t                    npix_z;
+    uint32_t                    blk_w;
+    uint32_t                    blk_h;
+    uint32_t                    blk_d;
+    uint32_t                    array_size;
+    uint32_t                    last_level;
+    uint32_t                    bpe;
+    uint32_t                    nsamples;
+    uint32_t                    flags;
+
+    /* These are return values. Some of them can be set by the caller, but
+     * they will be treated as hints (e.g. bankw, bankh) and might be
+     * changed by the calculator.
+     */
+    uint64_t                    bo_size;
+    uint64_t                    bo_alignment;
+    /* This applies to EG and later. */
+    uint32_t                    bankw;
+    uint32_t                    bankh;
+    uint32_t                    mtilea;
+    uint32_t                    tile_split;
+    uint32_t                    stencil_tile_split;
+    uint64_t                    stencil_offset;
+    struct radeon_surf_level    level[RADEON_SURF_MAX_LEVEL];
+    struct radeon_surf_level    stencil_level[RADEON_SURF_MAX_LEVEL];
+    uint32_t                    tiling_index[RADEON_SURF_MAX_LEVEL];
+    uint32_t                    stencil_tiling_index[RADEON_SURF_MAX_LEVEL];
+};
+
 struct radeon_winsys {
     /**
      * The screen object this winsys was created for
@@ -573,7 +646,7 @@ struct radeon_winsys {
      * \param surf      Surface structure ptr
      */
     int (*surface_init)(struct radeon_winsys *ws,
-                        struct radeon_surface *surf);
+                        struct radeon_surf *surf);
 
     /**
      * Find best values for a surface
@@ -582,7 +655,7 @@ struct radeon_winsys {
      * \param surf      Surface structure ptr
      */
     int (*surface_best)(struct radeon_winsys *ws,
-                        struct radeon_surface *surf);
+                        struct radeon_surf *surf);
 
     uint64_t (*query_value)(struct radeon_winsys *ws,
                             enum radeon_value_id value);
-- 
1.9.1

