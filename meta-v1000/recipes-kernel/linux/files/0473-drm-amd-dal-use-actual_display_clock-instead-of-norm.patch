From 4ca62273115cf4aa56ab57a79d2bfc80cfccc3f9 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Tue, 10 May 2016 15:17:37 -0400
Subject: [PATCH 0473/1722] drm/amd/dal: use actual_display_clock instead of
 normalizing everywhere for hdmi

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/bios/command_table.c    |  93 ---------------
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |   2 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |  36 +-----
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |   6 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |   1 +
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |  36 ++----
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |   7 +-
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  | 127 ++++++++++-----------
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.h  |  46 --------
 .../drm/amd/dal/dc/dce112/dce112_link_encoder.c    |  36 ++----
 .../drm/amd/dal/dc/dce80/dce80_stream_encoder.c    | 118 +++++++++----------
 .../drm/amd/dal/dc/dce80/dce80_stream_encoder.h    |  46 --------
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   2 +-
 drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h |   1 +
 .../amd/dal/dc/virtual/virtual_stream_encoder.c    |   1 +
 15 files changed, 148 insertions(+), 410 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
index 22524b3..802ebef 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/command_table.c
@@ -245,24 +245,6 @@ static enum bp_result encoder_control_digx_v3(
 					cntl->enable_dp_audio);
 	params.ucLaneNum = (uint8_t)(cntl->lanes_number);
 
-	if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
-		switch (cntl->color_depth) {
-		case COLOR_DEPTH_101010:
-			params.usPixelClock =
-				cpu_to_le16((le32_to_cpu(params.usPixelClock) * 30) / 24);
-			break;
-		case COLOR_DEPTH_121212:
-			params.usPixelClock =
-				cpu_to_le16((le32_to_cpu(params.usPixelClock) * 36) / 24);
-			break;
-		case COLOR_DEPTH_161616:
-			params.usPixelClock =
-				cpu_to_le16((le32_to_cpu(params.usPixelClock) * 48) / 24);
-			break;
-		default:
-			break;
-		}
-
 	if (EXEC_BIOS_CMD_TABLE(DIGxEncoderControl, params))
 		result = BP_RESULT_OK;
 
@@ -292,24 +274,6 @@ static enum bp_result encoder_control_digx_v4(
 					cntl->enable_dp_audio));
 	params.ucLaneNum = (uint8_t)(cntl->lanes_number);
 
-	if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
-		switch (cntl->color_depth) {
-		case COLOR_DEPTH_101010:
-			params.usPixelClock =
-				cpu_to_le16((le32_to_cpu(params.usPixelClock) * 30) / 24);
-			break;
-		case COLOR_DEPTH_121212:
-			params.usPixelClock =
-				cpu_to_le16((le32_to_cpu(params.usPixelClock) * 36) / 24);
-			break;
-		case COLOR_DEPTH_161616:
-			params.usPixelClock =
-				cpu_to_le16((le32_to_cpu(params.usPixelClock) * 48) / 24);
-			break;
-		default:
-			break;
-		}
-
 	if (EXEC_BIOS_CMD_TABLE(DIGxEncoderControl, params))
 		result = BP_RESULT_OK;
 
@@ -634,23 +598,6 @@ static enum bp_result transmitter_control_v3(
 			 */
 			params.usPixelClock =
 					cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
-			if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
-				switch (cntl->color_depth) {
-				case COLOR_DEPTH_101010:
-					params.usPixelClock =
-							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 30) / 24);
-					break;
-				case COLOR_DEPTH_121212:
-					params.usPixelClock =
-							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 36) / 24);
-					break;
-				case COLOR_DEPTH_161616:
-					params.usPixelClock =
-							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 48) / 24);
-					break;
-				default:
-					break;
-				}
 		}
 		break;
 	}
@@ -777,24 +724,6 @@ static enum bp_result transmitter_control_v4(
 			 */
 			params.usPixelClock =
 					cpu_to_le16((uint16_t)(cntl->pixel_clock / 10));
-
-			if (cntl->signal == SIGNAL_TYPE_HDMI_TYPE_A)
-				switch (cntl->color_depth) {
-				case COLOR_DEPTH_101010:
-					params.usPixelClock =
-							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 30) / 24);
-					break;
-				case COLOR_DEPTH_121212:
-					params.usPixelClock =
-							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 36) / 24);
-					break;
-				case COLOR_DEPTH_161616:
-					params.usPixelClock =
-							cpu_to_le16((le16_to_cpu(params.usPixelClock) * 48) / 24);
-					break;
-				default:
-					break;
-				}
 		}
 		break;
 	}
@@ -878,28 +807,6 @@ static enum bp_result transmitter_control_v1_5(
 	 * (=1: 8bpp, =1.25: 10bpp, =1.5:12bpp, =2: 16bpp)
 	 * LVDS mode: usPixelClock = pixel clock
 	 */
-	switch (cntl->signal) {
-	case SIGNAL_TYPE_HDMI_TYPE_A:
-		switch (cntl->color_depth) {
-		case COLOR_DEPTH_101010:
-			params.usSymClock =
-				cpu_to_le16((le16_to_cpu(params.usSymClock) * 30) / 24);
-			break;
-		case COLOR_DEPTH_121212:
-			params.usSymClock =
-				cpu_to_le16((le16_to_cpu(params.usSymClock) * 36) / 24);
-			break;
-		case COLOR_DEPTH_161616:
-			params.usSymClock =
-				cpu_to_le16((le16_to_cpu(params.usSymClock) * 48) / 24);
-			break;
-		default:
-			break;
-		}
-		break;
-		default:
-			break;
-	}
 
 	if (EXEC_BIOS_CMD_TABLE(UNIPHYTransmitterControl, params))
 		result = BP_RESULT_OK;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index 01b5c2f..98d0362 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -620,7 +620,7 @@ static void fill_display_configs(
 			cfg->link_settings.lane_count = stream->sink->link->public.cur_link_settings.lane_count;
 			cfg->link_settings.link_rate = stream->sink->link->public.cur_link_settings.link_rate;
 			cfg->link_settings.link_spread = stream->sink->link->public.cur_link_settings.link_spread;
-			cfg->sym_clock = stream->actual_pix_clk_khz;
+			cfg->sym_clock = stream->adjusted_pix_clk_khz;
 			/* Round v_refresh*/
 			cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
 			cfg->v_refresh /= stream->public.timing.h_total;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index 2dbcce5..6c6ce55 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -1244,40 +1244,10 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 	struct core_stream *stream = pipe_ctx->stream;
 	struct core_link *link = stream->sink->link;
 
-	/* enable video output */
-	/* here we need to specify that encoder output settings
-	 * need to be calculated as for the set mode,
-	 * it will lead to querying dynamic link capabilities
-	 * which should be done before enable output */
-	uint32_t pix_clk = stream->public.timing.pix_clk_khz;
-	uint32_t normalized_pix_clk = pix_clk;
-
-	if (stream->sink->public.sink_signal == SIGNAL_TYPE_HDMI_TYPE_A &&
-			stream->public.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
-		pix_clk /= 2;
-
-	switch (stream->public.timing.display_color_depth) {
-	case COLOR_DEPTH_888:
-		normalized_pix_clk = pix_clk;
-		break;
-	case COLOR_DEPTH_101010:
-		normalized_pix_clk = (pix_clk * 30) / 24;
-		break;
-	case COLOR_DEPTH_121212:
-		normalized_pix_clk = (pix_clk * 36) / 24;
-		break;
-	case COLOR_DEPTH_161616:
-		normalized_pix_clk = (pix_clk * 48) / 24;
-		break;
-	default:
-		ASSERT(0);
-		break;
-	}
-
-	if (pipe_ctx->signal == SIGNAL_TYPE_HDMI_TYPE_A)
+	if (dc_is_hdmi_signal(pipe_ctx->signal))
 		dal_ddc_service_write_scdc_data(
 			stream->sink->link->ddc,
-			normalized_pix_clk,
+			stream->adjusted_pix_clk_khz,
 			stream->public.timing.flags.LTE_340MCSC_SCRAMBLE);
 
 	memset(&stream->sink->link->public.cur_link_settings, 0,
@@ -1289,7 +1259,7 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 			stream->public.timing.display_color_depth,
 			pipe_ctx->signal == SIGNAL_TYPE_HDMI_TYPE_A,
 			pipe_ctx->signal == SIGNAL_TYPE_DVI_DUAL_LINK,
-			pix_clk);
+			stream->adjusted_pix_clk_khz);
 
 	if (pipe_ctx->signal == SIGNAL_TYPE_HDMI_TYPE_A)
 		dal_ddc_service_read_scdc_data(link->ddc);
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index de6e4c9..c7e3f22 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -171,7 +171,7 @@ bool resource_are_streams_clk_sharable(
 	if (stream1->public.timing.v_total != stream2->public.timing.v_total)
 		return false;
 
-	if (stream1->actual_pix_clk_khz != stream2->actual_pix_clk_khz)
+	if (stream1->adjusted_pix_clk_khz != stream2->adjusted_pix_clk_khz)
 		return false;
 
 	return true;
@@ -791,10 +791,10 @@ enum dc_status resource_map_pool_resources(
 
 			/* update actual pixel clock on all streams */
 			if (dc_is_hdmi_signal(stream->sink->public.sink_signal))
-				stream->actual_pix_clk_khz = get_norm_pix_clk(
+				stream->adjusted_pix_clk_khz = get_norm_pix_clk(
 					&stream->public.timing);
 			else
-				stream->actual_pix_clk_khz =
+				stream->adjusted_pix_clk_khz =
 					stream->public.timing.pix_clk_khz;
 
 			if (!resource_is_stream_unchanged(&dc->current_context, stream))
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 89d9a54..941929a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -778,6 +778,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_enc->funcs->hdmi_set_stream_attribute(
 			pipe_ctx->stream_enc,
 			&stream->public.timing,
+			stream->adjusted_pix_clk_khz,
 			pipe_ctx->audio != NULL);
 
 	if (dc_is_dvi_signal(pipe_ctx->signal))
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 6e21d4e..d80ca1c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -929,12 +929,11 @@ bool dce110_link_encoder_validate_dvi_output(
 
 static bool dce110_link_encoder_validate_hdmi_output(
 	const struct dce110_link_encoder *enc110,
-	const struct dc_crtc_timing *crtc_timing)
+	const struct dc_crtc_timing *crtc_timing,
+	int adjusted_pix_clk_khz)
 {
 	enum dc_color_depth max_deep_color =
 			enc110->base.features.max_hdmi_deep_color;
-	/* expressed in KHz */
-	uint32_t pixel_clock = 0;
 
 	if (max_deep_color > enc110->base.features.max_deep_color)
 		max_deep_color = enc110->base.features.max_deep_color;
@@ -942,32 +941,12 @@ static bool dce110_link_encoder_validate_hdmi_output(
 	if (max_deep_color < crtc_timing->display_color_depth)
 		return false;
 
-	if (crtc_timing->pix_clk_khz < TMDS_MIN_PIXEL_CLOCK)
+	if (adjusted_pix_clk_khz < TMDS_MIN_PIXEL_CLOCK)
 		return false;
 
-	switch (crtc_timing->display_color_depth) {
-	case COLOR_DEPTH_666:
-		pixel_clock = (crtc_timing->pix_clk_khz * 3) >> 2;
-	break;
-	case COLOR_DEPTH_888:
-		pixel_clock = crtc_timing->pix_clk_khz;
-	break;
-	case COLOR_DEPTH_101010:
-		pixel_clock = (crtc_timing->pix_clk_khz * 10) >> 3;
-	break;
-	case COLOR_DEPTH_121212:
-		pixel_clock = (crtc_timing->pix_clk_khz * 3) >> 1;
-	break;
-	case COLOR_DEPTH_161616:
-		pixel_clock = crtc_timing->pix_clk_khz << 1;
-	break;
-	default:
-	break;
-	}
-
-	if ((pixel_clock == 0) ||
-		(pixel_clock > enc110->base.features.max_hdmi_pixel_clock) ||
-		(pixel_clock > enc110->base.features.max_pixel_clock))
+	if ((adjusted_pix_clk_khz == 0) ||
+		(adjusted_pix_clk_khz > enc110->base.features.max_hdmi_pixel_clock) ||
+		(adjusted_pix_clk_khz > enc110->base.features.max_pixel_clock))
 		return false;
 
 	/* DCE11 HW does not support 420 */
@@ -1168,7 +1147,8 @@ bool dce110_link_encoder_validate_output_with_stream(
 	case SIGNAL_TYPE_HDMI_TYPE_A:
 		is_valid = dce110_link_encoder_validate_hdmi_output(
 				enc110,
-				&stream->public.timing);
+				&stream->public.timing,
+				stream->adjusted_pix_clk_khz);
 	break;
 	case SIGNAL_TYPE_RGB:
 		is_valid = dce110_link_encoder_validate_rgb_output(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index aaf22bf..046c427 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -529,13 +529,18 @@ static void get_pixel_clock_parameters(
 	struct pixel_clk_params *pixel_clk_params)
 {
 	const struct core_stream *stream = pipe_ctx->stream;
+
+	/*TODO: is this halved for YCbCr 420? in that case we might want to move
+	 * the pixel clock normalization for hdmi up to here instead of doing it
+	 * in pll_adjust_pix_clk
+	 */
 	pixel_clk_params->requested_pix_clk = stream->public.timing.pix_clk_khz;
 	pixel_clk_params->encoder_object_id = stream->sink->link->link_enc->id;
 	pixel_clk_params->signal_type = stream->sink->public.sink_signal;
 	pixel_clk_params->controller_id = pipe_ctx->pipe_idx + 1;
 	/* TODO: un-hardcode*/
 	pixel_clk_params->requested_sym_clk = LINK_RATE_LOW *
-		LINK_RATE_REF_FREQ_IN_KHZ;
+						LINK_RATE_REF_FREQ_IN_KHZ;
 	pixel_clk_params->flags.ENABLE_SS = 0;
 	pixel_clk_params->color_depth =
 		stream->public.timing.display_color_depth;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index efb0df4..4c75425a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -47,29 +47,6 @@ enum {
 	DP_MST_UPDATE_MAX_RETRY = 50
 };
 
-static struct stream_encoder_funcs dce110_str_enc_funcs = {
-	.dp_set_stream_attribute =
-		dce110_stream_encoder_dp_set_stream_attribute,
-	.hdmi_set_stream_attribute =
-		dce110_stream_encoder_hdmi_set_stream_attribute,
-	.dvi_set_stream_attribute =
-		dce110_stream_encoder_dvi_set_stream_attribute,
-	.set_mst_bandwidth =
-		dce110_stream_encoder_set_mst_bandwidth,
-	.update_hdmi_info_packets =
-		dce110_stream_encoder_update_hdmi_info_packets,
-	.stop_hdmi_info_packets =
-		dce110_stream_encoder_stop_hdmi_info_packets,
-	.update_dp_info_packets =
-		dce110_stream_encoder_update_dp_info_packets,
-	.stop_dp_info_packets =
-		dce110_stream_encoder_stop_dp_info_packets,
-	.dp_blank =
-		dce110_stream_encoder_dp_blank,
-	.dp_unblank =
-		dce110_stream_encoder_dp_unblank,
-};
-
 static void dce110_update_generic_info_packet(
 	struct dce110_stream_encoder *enc110,
 	uint32_t packet_index,
@@ -278,29 +255,8 @@ static void dce110_update_hdmi_info_packet(
 	dm_write_reg(ctx, addr, regval);
 }
 
-bool dce110_stream_encoder_construct(
-	struct dce110_stream_encoder *enc110,
-	struct dc_context *ctx,
-	struct dc_bios *bp,
-	enum engine_id eng_id,
-	const struct dce110_stream_enc_registers *regs)
-{
-	if (!enc110)
-		return false;
-	if (!bp)
-		return false;
-
-	enc110->base.funcs = &dce110_str_enc_funcs;
-	enc110->base.ctx = ctx;
-	enc110->base.id = eng_id;
-	enc110->base.bp = bp;
-	enc110->regs = regs;
-
-	return true;
-}
-
 /* setup stream encoder in dp mode */
-void dce110_stream_encoder_dp_set_stream_attribute(
+static void dce110_stream_encoder_dp_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing)
 {
@@ -390,16 +346,14 @@ void dce110_stream_encoder_dp_set_stream_attribute(
 }
 
 /* setup stream encoder in hdmi mode */
-void dce110_stream_encoder_hdmi_set_stream_attribute(
+static void dce110_stream_encoder_hdmi_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
+	int actual_pix_clk_khz,
 	bool enable_audio)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
-	uint32_t output_pixel_clock = (crtc_timing->pixel_encoding ==
-			PIXEL_ENCODING_YCBCR420) ?
-			crtc_timing->pix_clk_khz / 2 : crtc_timing->pix_clk_khz;
 	uint32_t value;
 	uint32_t addr;
 	struct bp_encoder_control cntl = {0};
@@ -408,9 +362,8 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 	cntl.engine_id = enc110->base.id;
 	cntl.signal = SIGNAL_TYPE_HDMI_TYPE_A;
 	cntl.enable_dp_audio = enable_audio;
-	cntl.pixel_clock = output_pixel_clock;
+        cntl.pixel_clock = actual_pix_clk_khz;
 	cntl.lanes_number = LANE_COUNT_FOUR;
-	cntl.color_depth = crtc_timing->display_color_depth;
 
 	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
@@ -457,7 +410,6 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 			1,
 			HDMI_CONTROL,
 			HDMI_DEEP_COLOR_ENABLE);
-		output_pixel_clock = (output_pixel_clock * 30) / 24;
 		break;
 	case COLOR_DEPTH_121212:
 		set_reg_field_value(
@@ -470,7 +422,6 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 			1,
 			HDMI_CONTROL,
 			HDMI_DEEP_COLOR_ENABLE);
-		output_pixel_clock = (output_pixel_clock * 36) / 24;
 		break;
 	case COLOR_DEPTH_161616:
 		set_reg_field_value(
@@ -483,13 +434,12 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 			1,
 			HDMI_CONTROL,
 			HDMI_DEEP_COLOR_ENABLE);
-		output_pixel_clock = (output_pixel_clock * 48) / 24;
 		break;
 	default:
 		break;
 	}
 
-	if (output_pixel_clock >= HDMI_CLOCK_CHANNEL_RATE_MORE_340M) {
+	if (actual_pix_clk_khz >= HDMI_CLOCK_CHANNEL_RATE_MORE_340M) {
 		/* enable HDMI data scrambler */
 		set_reg_field_value(
 			value,
@@ -570,7 +520,7 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 }
 
 /* setup stream encoder in dvi mode */
-void dce110_stream_encoder_dvi_set_stream_attribute(
+static void dce110_stream_encoder_dvi_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
 	bool is_dual_link)
@@ -584,13 +534,10 @@ void dce110_stream_encoder_dvi_set_stream_attribute(
 	cntl.action = ENCODER_CONTROL_SETUP;
 	cntl.engine_id = enc110->base.id;
 	cntl.signal = is_dual_link ?
-		SIGNAL_TYPE_DVI_DUAL_LINK :
-		SIGNAL_TYPE_DVI_SINGLE_LINK;
+                        SIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;
 	cntl.enable_dp_audio = false;
 	cntl.pixel_clock = crtc_timing->pix_clk_khz;
-	cntl.lanes_number = (is_dual_link) ?
-				LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
-	cntl.color_depth = crtc_timing->display_color_depth;
+        cntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 
 	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
@@ -626,7 +573,7 @@ void dce110_stream_encoder_dvi_set_stream_attribute(
 	dm_write_reg(ctx, addr, value);
 }
 
-void dce110_stream_encoder_set_mst_bandwidth(
+static void dce110_stream_encoder_set_mst_bandwidth(
 	struct stream_encoder *enc,
 	struct fixed31_32 avg_time_slots_per_mtp)
 {
@@ -689,7 +636,7 @@ void dce110_stream_encoder_set_mst_bandwidth(
 	}
 }
 
-void dce110_stream_encoder_update_hdmi_info_packets(
+static void dce110_stream_encoder_update_hdmi_info_packets(
 	struct stream_encoder *enc,
 	const struct encoder_info_frame *info_frame)
 {
@@ -793,7 +740,7 @@ void dce110_stream_encoder_update_hdmi_info_packets(
 	dce110_update_hdmi_info_packet(enc110, 2, &info_frame->spd);
 }
 
-void dce110_stream_encoder_stop_hdmi_info_packets(
+static void dce110_stream_encoder_stop_hdmi_info_packets(
 	struct stream_encoder *enc)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
@@ -895,7 +842,8 @@ void dce110_stream_encoder_stop_hdmi_info_packets(
 
 	dm_write_reg(ctx, addr, value);
 }
-void dce110_stream_encoder_update_dp_info_packets(
+
+static void dce110_stream_encoder_update_dp_info_packets(
 	struct stream_encoder *enc,
 	const struct encoder_info_frame *info_frame)
 {
@@ -938,7 +886,7 @@ void dce110_stream_encoder_update_dp_info_packets(
 	dm_write_reg(ctx, addr, value);
 }
 
-void dce110_stream_encoder_stop_dp_info_packets(
+static void dce110_stream_encoder_stop_dp_info_packets(
 	struct stream_encoder *enc)
 {
 	/* stop generic packets on DP */
@@ -969,7 +917,7 @@ void dce110_stream_encoder_stop_dp_info_packets(
 	dm_write_reg(ctx, addr, value);
 }
 
-void dce110_stream_encoder_dp_blank(
+static void dce110_stream_encoder_dp_blank(
 	struct stream_encoder *enc)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
@@ -1036,7 +984,7 @@ void dce110_stream_encoder_dp_blank(
 }
 
 /* output video stream to link encoder */
-void dce110_stream_encoder_dp_unblank(
+static void dce110_stream_encoder_dp_unblank(
 	struct stream_encoder *enc,
 	const struct encoder_unblank_param *param)
 {
@@ -1121,3 +1069,46 @@ void dce110_stream_encoder_dp_unblank(
 	dm_write_reg(ctx, addr, value);
 }
 
+static struct stream_encoder_funcs dce110_str_enc_funcs = {
+	.dp_set_stream_attribute =
+		dce110_stream_encoder_dp_set_stream_attribute,
+	.hdmi_set_stream_attribute =
+		dce110_stream_encoder_hdmi_set_stream_attribute,
+	.dvi_set_stream_attribute =
+		dce110_stream_encoder_dvi_set_stream_attribute,
+	.set_mst_bandwidth =
+		dce110_stream_encoder_set_mst_bandwidth,
+	.update_hdmi_info_packets =
+		dce110_stream_encoder_update_hdmi_info_packets,
+	.stop_hdmi_info_packets =
+		dce110_stream_encoder_stop_hdmi_info_packets,
+	.update_dp_info_packets =
+		dce110_stream_encoder_update_dp_info_packets,
+	.stop_dp_info_packets =
+		dce110_stream_encoder_stop_dp_info_packets,
+	.dp_blank =
+		dce110_stream_encoder_dp_blank,
+	.dp_unblank =
+		dce110_stream_encoder_dp_unblank,
+};
+
+bool dce110_stream_encoder_construct(
+	struct dce110_stream_encoder *enc110,
+	struct dc_context *ctx,
+	struct dc_bios *bp,
+	enum engine_id eng_id,
+	const struct dce110_stream_enc_registers *regs)
+{
+	if (!enc110)
+		return false;
+	if (!bp)
+		return false;
+
+	enc110->base.funcs = &dce110_str_enc_funcs;
+	enc110->base.ctx = ctx;
+	enc110->base.id = eng_id;
+	enc110->base.bp = bp;
+	enc110->regs = regs;
+
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
index f187ad3..de2090a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.h
@@ -73,50 +73,4 @@ bool dce110_stream_encoder_construct(
 	enum engine_id eng_id,
 	const struct dce110_stream_enc_registers *regs);
 
-/***** HW programming ***********/
-/* setup stream encoder in dp mode */
-void dce110_stream_encoder_dp_set_stream_attribute(
-	struct stream_encoder *enc,
-	struct dc_crtc_timing *crtc_timing);
-
-/* setup stream encoder in hdmi mode */
-void dce110_stream_encoder_hdmi_set_stream_attribute(
-	struct stream_encoder *enc,
-	struct dc_crtc_timing *crtc_timing,
-	bool enable_audio);
-
-/* setup stream encoder in dvi mode */
-void dce110_stream_encoder_dvi_set_stream_attribute(
-	struct stream_encoder *enc,
-	struct dc_crtc_timing *crtc_timing,
-	bool is_dual_link);
-
-/* set throttling for DP MST */
-void dce110_stream_encoder_set_mst_bandwidth(
-	struct stream_encoder *enc,
-	struct fixed31_32 avg_time_slots_per_mtp);
-
-void dce110_stream_encoder_update_hdmi_info_packets(
-	struct stream_encoder *enc,
-	const struct encoder_info_frame *info_frame);
-
-void dce110_stream_encoder_stop_hdmi_info_packets(
-	struct stream_encoder *enc);
-
-void dce110_stream_encoder_update_dp_info_packets(
-	struct stream_encoder *enc,
-	const struct encoder_info_frame *info_frame);
-
-void dce110_stream_encoder_stop_dp_info_packets(
-	struct stream_encoder *enc);
-
-/* output blank/idle stream to link encoder */
-void dce110_stream_encoder_dp_blank(
-	struct stream_encoder *enc);
-
-/* output video stream to link encoder */
-void dce110_stream_encoder_dp_unblank(
-	struct stream_encoder *enc,
-	const struct encoder_unblank_param *param);
-
 #endif /* __DC_STREAM_ENCODER_DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
index 5124c90..4fdf33f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
@@ -74,12 +74,11 @@ static void dce112_link_encoder_dp_set_phy_pattern(
 
 static bool dce112_link_encoder_validate_hdmi_output(
 	const struct dce110_link_encoder *enc110,
-	const struct dc_crtc_timing *crtc_timing)
+	const struct dc_crtc_timing *crtc_timing,
+	int adjusted_pix_clk_khz)
 {
 	enum dc_color_depth max_deep_color =
 			enc110->base.features.max_hdmi_deep_color;
-	/* expressed in KHz */
-	uint32_t pixel_clock = 0;
 
 	if (max_deep_color > enc110->base.features.max_deep_color)
 		max_deep_color = enc110->base.features.max_deep_color;
@@ -87,32 +86,12 @@ static bool dce112_link_encoder_validate_hdmi_output(
 	if (max_deep_color < crtc_timing->display_color_depth)
 		return false;
 
-	if (crtc_timing->pix_clk_khz < TMDS_MIN_PIXEL_CLOCK)
+	if (adjusted_pix_clk_khz < TMDS_MIN_PIXEL_CLOCK)
 		return false;
 
-	switch (crtc_timing->display_color_depth) {
-	case COLOR_DEPTH_666:
-		pixel_clock = (crtc_timing->pix_clk_khz * 3) >> 2;
-	break;
-	case COLOR_DEPTH_888:
-		pixel_clock = crtc_timing->pix_clk_khz;
-	break;
-	case COLOR_DEPTH_101010:
-		pixel_clock = (crtc_timing->pix_clk_khz * 10) >> 3;
-	break;
-	case COLOR_DEPTH_121212:
-		pixel_clock = (crtc_timing->pix_clk_khz * 3) >> 1;
-	break;
-	case COLOR_DEPTH_161616:
-		pixel_clock = crtc_timing->pix_clk_khz << 1;
-	break;
-	default:
-	break;
-	}
-
-	if ((pixel_clock == 0) ||
-		(pixel_clock > enc110->base.features.max_hdmi_pixel_clock) ||
-		(pixel_clock > enc110->base.features.max_pixel_clock))
+	if ((adjusted_pix_clk_khz == 0) ||
+		(adjusted_pix_clk_khz > enc110->base.features.max_hdmi_pixel_clock) ||
+		(adjusted_pix_clk_khz > enc110->base.features.max_pixel_clock))
 		return false;
 
 	return true;
@@ -138,7 +117,8 @@ bool dce112_link_encoder_validate_output_with_stream(
 	case SIGNAL_TYPE_HDMI_TYPE_A:
 		is_valid = dce112_link_encoder_validate_hdmi_output(
 				enc110,
-				&stream->public.timing);
+				&stream->public.timing,
+				stream->adjusted_pix_clk_khz);
 	break;
 	case SIGNAL_TYPE_RGB:
 		is_valid = dce110_link_encoder_validate_rgb_output(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
index 7f62b0d..ed55459 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
@@ -57,28 +57,6 @@ enum {
 	DP_MST_UPDATE_MAX_RETRY = 50
 };
 
-static struct stream_encoder_funcs dce80_str_enc_funcs = {
-	.dp_set_stream_attribute =
-		dce80_stream_encoder_dp_set_stream_attribute,
-	.hdmi_set_stream_attribute =
-		dce80_stream_encoder_hdmi_set_stream_attribute,
-	.dvi_set_stream_attribute =
-		dce80_stream_encoder_dvi_set_stream_attribute,
-	.set_mst_bandwidth =
-		dce80_stream_encoder_set_mst_bandwidth,
-	.update_hdmi_info_packets =
-		dce80_stream_encoder_update_hdmi_info_packets,
-	.stop_hdmi_info_packets =
-		dce80_stream_encoder_stop_hdmi_info_packets,
-	.update_dp_info_packets =
-		dce80_stream_encoder_update_dp_info_packets,
-	.stop_dp_info_packets =
-		dce80_stream_encoder_stop_dp_info_packets,
-	.dp_blank =
-		dce80_stream_encoder_dp_blank,
-	.dp_unblank =
-		dce80_stream_encoder_dp_unblank,
-};
 
 static void dce80_update_generic_info_packet(
 	struct dce110_stream_encoder *enc110,
@@ -291,29 +269,8 @@ static void dce80_update_hdmi_info_packet(
 	dm_write_reg(ctx, addr, regval);
 }
 
-bool dce80_stream_encoder_construct(
-	struct dce110_stream_encoder *enc110,
-	struct dc_context *ctx,
-	struct dc_bios *dcb,
-	enum engine_id eng_id,
-	const struct dce110_stream_enc_registers *regs)
-{
-	if (!enc110)
-		return false;
-	if (!dcb)
-		return false;
-
-	enc110->base.funcs = &dce80_str_enc_funcs;
-	enc110->base.ctx = ctx;
-	enc110->base.id = eng_id;
-	enc110->base.bp = dcb;
-	enc110->regs = regs;
-
-	return true;
-}
-
 /* setup stream encoder in dp mode */
-void dce80_stream_encoder_dp_set_stream_attribute(
+static void dce80_stream_encoder_dp_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing)
 {
@@ -406,23 +363,23 @@ void dce80_stream_encoder_dp_set_stream_attribute(
 }
 
 /* setup stream encoder in hdmi mode */
-void dce80_stream_encoder_hdmi_set_stream_attribute(
+static void dce80_stream_encoder_hdmi_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
+	int actual_pix_clk_khz,
 	bool enable_audio)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t addr = LINK_REG(TMDS_CNTL);
 	uint32_t value = dm_read_reg(ctx, addr);
-	uint32_t output_pixel_clock = crtc_timing->pix_clk_khz;
 	struct bp_encoder_control cntl = {0};
 
 	cntl.action = ENCODER_CONTROL_SETUP;
 	cntl.engine_id = enc110->base.id;
 	cntl.signal = SIGNAL_TYPE_HDMI_TYPE_A;
 	cntl.enable_dp_audio = enable_audio;
-	cntl.pixel_clock = crtc_timing->pix_clk_khz;
+	cntl.pixel_clock = actual_pix_clk_khz;
 	cntl.lanes_number = LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
@@ -467,7 +424,6 @@ void dce80_stream_encoder_hdmi_set_stream_attribute(
 			1,
 			HDMI_CONTROL,
 			HDMI_DEEP_COLOR_ENABLE);
-		output_pixel_clock = (crtc_timing->pix_clk_khz * 30) / 24;
 		break;
 	case COLOR_DEPTH_121212:
 		set_reg_field_value(
@@ -480,7 +436,6 @@ void dce80_stream_encoder_hdmi_set_stream_attribute(
 			1,
 			HDMI_CONTROL,
 			HDMI_DEEP_COLOR_ENABLE);
-		output_pixel_clock = (crtc_timing->pix_clk_khz * 36) / 24;
 		break;
 	case COLOR_DEPTH_161616:
 		set_reg_field_value(
@@ -493,7 +448,6 @@ void dce80_stream_encoder_hdmi_set_stream_attribute(
 			1,
 			HDMI_CONTROL,
 			HDMI_DEEP_COLOR_ENABLE);
-		output_pixel_clock = (crtc_timing->pix_clk_khz * 48) / 24;
 		break;
 	default:
 		break;
@@ -544,7 +498,7 @@ void dce80_stream_encoder_hdmi_set_stream_attribute(
 }
 
 /* setup stream encoder in dvi mode */
-void dce80_stream_encoder_dvi_set_stream_attribute(
+static void dce80_stream_encoder_dvi_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
 	bool is_dual_link)
@@ -558,13 +512,10 @@ void dce80_stream_encoder_dvi_set_stream_attribute(
 	cntl.action = ENCODER_CONTROL_SETUP;
 	cntl.engine_id = enc110->base.id;
 	cntl.signal = is_dual_link ?
-		SIGNAL_TYPE_DVI_DUAL_LINK :
-		SIGNAL_TYPE_DVI_SINGLE_LINK;
+			SIGNAL_TYPE_DVI_DUAL_LINK : SIGNAL_TYPE_DVI_SINGLE_LINK;
 	cntl.enable_dp_audio = false;
 	cntl.pixel_clock = crtc_timing->pix_clk_khz;
-	cntl.lanes_number = (is_dual_link) ?
-				LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
-	cntl.color_depth = crtc_timing->display_color_depth;
+        cntl.lanes_number = (is_dual_link) ? LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 
 	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
@@ -600,7 +551,7 @@ void dce80_stream_encoder_dvi_set_stream_attribute(
 	dm_write_reg(ctx, addr, value);
 }
 
-void dce80_stream_encoder_set_mst_bandwidth(
+static void dce80_stream_encoder_set_mst_bandwidth(
 	struct stream_encoder *enc,
 	struct fixed31_32 avg_time_slots_per_mtp)
 {
@@ -663,7 +614,7 @@ void dce80_stream_encoder_set_mst_bandwidth(
 	}
 }
 
-void dce80_stream_encoder_update_hdmi_info_packets(
+static void dce80_stream_encoder_update_hdmi_info_packets(
 	struct stream_encoder *enc,
 	const struct encoder_info_frame *info_frame)
 {
@@ -769,7 +720,7 @@ void dce80_stream_encoder_update_hdmi_info_packets(
 	dce80_update_hdmi_info_packet(enc110, 2, &info_frame->spd);
 }
 
-void dce80_stream_encoder_stop_hdmi_info_packets(
+static void dce80_stream_encoder_stop_hdmi_info_packets(
 	struct stream_encoder *enc)
 {
 	struct dce110_stream_encoder *enc110 = DCE110STRENC_FROM_STRENC(enc);
@@ -871,7 +822,7 @@ void dce80_stream_encoder_stop_hdmi_info_packets(
 
 	dm_write_reg(ctx, addr, value);
 }
-void dce80_stream_encoder_update_dp_info_packets(
+static void dce80_stream_encoder_update_dp_info_packets(
 	struct stream_encoder *enc,
 	const struct encoder_info_frame *info_frame)
 {
@@ -914,7 +865,7 @@ void dce80_stream_encoder_update_dp_info_packets(
 	dm_write_reg(ctx, addr, value);
 }
 
-void dce80_stream_encoder_stop_dp_info_packets(
+static void dce80_stream_encoder_stop_dp_info_packets(
 	struct stream_encoder *enc)
 {
 	/* stop generic packets on DP */
@@ -1015,7 +966,7 @@ void dce80_stream_encoder_dp_blank(
 }
 
 /* output video stream to link encoder */
-void dce80_stream_encoder_dp_unblank(
+static void dce80_stream_encoder_dp_unblank(
 	struct stream_encoder *enc,
 	const struct encoder_unblank_param *param)
 {
@@ -1100,3 +1051,46 @@ void dce80_stream_encoder_dp_unblank(
 	dm_write_reg(ctx, addr, value);
 }
 
+static struct stream_encoder_funcs dce80_str_enc_funcs = {
+	.dp_set_stream_attribute =
+		dce80_stream_encoder_dp_set_stream_attribute,
+	.hdmi_set_stream_attribute =
+		dce80_stream_encoder_hdmi_set_stream_attribute,
+	.dvi_set_stream_attribute =
+		dce80_stream_encoder_dvi_set_stream_attribute,
+	.set_mst_bandwidth =
+		dce80_stream_encoder_set_mst_bandwidth,
+	.update_hdmi_info_packets =
+		dce80_stream_encoder_update_hdmi_info_packets,
+	.stop_hdmi_info_packets =
+		dce80_stream_encoder_stop_hdmi_info_packets,
+	.update_dp_info_packets =
+		dce80_stream_encoder_update_dp_info_packets,
+	.stop_dp_info_packets =
+		dce80_stream_encoder_stop_dp_info_packets,
+	.dp_blank =
+		dce80_stream_encoder_dp_blank,
+	.dp_unblank =
+		dce80_stream_encoder_dp_unblank,
+};
+
+bool dce80_stream_encoder_construct(
+	struct dce110_stream_encoder *enc110,
+	struct dc_context *ctx,
+	struct dc_bios *dcb,
+	enum engine_id eng_id,
+	const struct dce110_stream_enc_registers *regs)
+{
+	if (!enc110)
+		return false;
+	if (!dcb)
+		return false;
+
+	enc110->base.funcs = &dce80_str_enc_funcs;
+	enc110->base.ctx = ctx;
+	enc110->base.id = eng_id;
+	enc110->base.bp = dcb;
+	enc110->regs = regs;
+
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h
index 158522d..1d7b411 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.h
@@ -35,50 +35,4 @@ bool dce80_stream_encoder_construct(
 	enum engine_id eng_id,
 	const struct dce110_stream_enc_registers *regs);
 
-/***** HW programming ***********/
-/* setup stream encoder in dp mode */
-void dce80_stream_encoder_dp_set_stream_attribute(
-	struct stream_encoder *enc,
-	struct dc_crtc_timing *crtc_timing);
-
-/* setup stream encoder in hdmi mode */
-void dce80_stream_encoder_hdmi_set_stream_attribute(
-	struct stream_encoder *enc,
-	struct dc_crtc_timing *crtc_timing,
-	bool enable_audio);
-
-/* setup stream encoder in dvi mode */
-void dce80_stream_encoder_dvi_set_stream_attribute(
-	struct stream_encoder *enc,
-	struct dc_crtc_timing *crtc_timing,
-	bool is_dual_link);
-
-/* set throttling for DP MST */
-void dce80_stream_encoder_set_mst_bandwidth(
-	struct stream_encoder *enc,
-	struct fixed31_32 avg_time_slots_per_mtp);
-
-void dce80_stream_encoder_update_hdmi_info_packets(
-	struct stream_encoder *enc,
-	const struct encoder_info_frame *info_frame);
-
-void dce80_stream_encoder_stop_hdmi_info_packets(
-	struct stream_encoder *enc);
-
-void dce80_stream_encoder_update_dp_info_packets(
-	struct stream_encoder *enc,
-	const struct encoder_info_frame *info_frame);
-
-void dce80_stream_encoder_stop_dp_info_packets(
-	struct stream_encoder *enc);
-
-/* output blank/idle stream to link encoder */
-void dce80_stream_encoder_dp_blank(
-	struct stream_encoder *enc);
-
-/* output video stream to link encoder */
-void dce80_stream_encoder_dp_unblank(
-	struct stream_encoder *enc,
-	const struct encoder_unblank_param *param);
-
 #endif /* __DC_STREAM_ENCODER_DCE80_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index 764a112..5c41f12 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -93,7 +93,7 @@ struct core_stream {
 	struct bit_depth_reduction_params bit_depth_params;
 	struct clamping_and_pixel_encoding_params clamping;
 
-	int actual_pix_clk_khz;
+	int adjusted_pix_clk_khz;
 
 	struct dc_stream_status status;
 };
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
index 87a1343..4124399 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/stream_encoder.h
@@ -58,6 +58,7 @@ struct stream_encoder_funcs {
 	void (*hdmi_set_stream_attribute)(
 		struct stream_encoder *enc,
 		struct dc_crtc_timing *crtc_timing,
+		int actual_pix_clk_khz,
 		bool enable_audio);
 	void (*dvi_set_stream_attribute)(
 		struct stream_encoder *enc,
diff --git a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
index 33f4ef9..4a77c2c 100644
--- a/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/virtual/virtual_stream_encoder.c
@@ -33,6 +33,7 @@ static void virtual_stream_encoder_dp_set_stream_attribute(
 static void virtual_stream_encoder_hdmi_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
+	int actual_pix_clk_khz,
 	bool enable_audio) {}
 
 static void virtual_stream_encoder_dvi_set_stream_attribute(
-- 
2.7.4

