From 4a449550d0f5a5d1b90e35641eac782202033ff2 Mon Sep 17 00:00:00 2001
From: "Le.Ma" <Le.Ma@amd.com>
Date: Thu, 28 Sep 2017 15:29:29 +0800
Subject: [PATCH 3228/5855] Revert display patches temporarily for build passed

This commit revert several display commits as below:
  - from: "3769698 drm/amd/display: fix gamma distortion on Vega"
  - to: "fe4ca20 drm/amdkcl: [4.12] Reserve flip_flags for display usage"

It's because these patches cause dkms build error, and the fix(kcl) patches may
not be finished in a short time. So temporarily revert them to make daily build
passed for other urgent usage.

Will apply them again after fix(kcl) patches are ready.

Change-Id: I370efc95cbd6b052c7c390d56a4e9c9f146f1f11
Signed-off-by: Le.Ma <Le.Ma@amd.com>
Signed-off-by: Raveendra Talabattula <raveendra.talabattula@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h           |    1 +
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c  |  541 ++++---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h  |    2 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_services.c |   13 +-
 drivers/gpu/drm/amd/display/dc/bios/bios_parser.c  |    1 -
 drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c |   70 +-
 .../gpu/drm/amd/display/dc/bios/command_table2.c   |    1 +
 .../amd/display/dc/bios/command_table_helper2.c    |    1 +
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |  733 +++++-----
 drivers/gpu/drm/amd/display/dc/core/dc.c           |  793 ++++++----
 drivers/gpu/drm/amd/display/dc/core/dc_debug.c     |   22 +-
 .../gpu/drm/amd/display/dc/core/dc_hw_sequencer.c  |    3 +-
 drivers/gpu/drm/amd/display/dc/core/dc_link.c      |  507 +------
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c   |   27 +-
 drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c |   48 +-
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  |  798 ++++------
 drivers/gpu/drm/amd/display/dc/core/dc_sink.c      |   12 +-
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |   68 +-
 drivers/gpu/drm/amd/display/dc/core/dc_surface.c   |   50 +-
 drivers/gpu/drm/amd/display/dc/dc.h                |  215 ++-
 drivers/gpu/drm/amd/display/dc/dc_hw_types.h       |    2 +-
 .../gpu/drm/amd/display/dc/dce/dce_clock_source.c  |   87 +-
 .../gpu/drm/amd/display/dc/dce/dce_clock_source.h  |   14 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c    |   35 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c      |   32 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c     |    4 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h     |   54 +-
 .../gpu/drm/amd/display/dc/dce/dce_link_encoder.c  |    8 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c |    2 -
 drivers/gpu/drm/amd/display/dc/dce/dce_transform.h |   10 -
 .../amd/display/dc/dce100/dce100_hw_sequencer.c    |   17 +-
 .../amd/display/dc/dce100/dce100_hw_sequencer.h    |   10 +-
 .../drm/amd/display/dc/dce100/dce100_resource.c    |  123 +-
 .../drm/amd/display/dc/dce100/dce100_resource.h    |    9 +-
 .../drm/amd/display/dc/dce110/dce110_compressor.c  |   26 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    |  248 ++--
 .../amd/display/dc/dce110/dce110_hw_sequencer.h    |   25 +-
 .../drm/amd/display/dc/dce110/dce110_resource.c    |  185 ++-
 .../drm/amd/display/dc/dce110/dce110_resource.h    |    4 +-
 .../amd/display/dc/dce112/dce112_hw_sequencer.c    |    5 +-
 .../amd/display/dc/dce112/dce112_hw_sequencer.h    |    4 +-
 .../drm/amd/display/dc/dce112/dce112_resource.c    |  237 +--
 .../drm/amd/display/dc/dce112/dce112_resource.h    |   23 +-
 .../amd/display/dc/dce120/dce120_hw_sequencer.c    |    6 +-
 .../amd/display/dc/dce120/dce120_hw_sequencer.h    |    4 +-
 .../drm/amd/display/dc/dce120/dce120_resource.c    |   46 +-
 .../drm/amd/display/dc/dce120/dce120_resource.h    |    4 +-
 .../drm/amd/display/dc/dce80/dce80_hw_sequencer.c  |    5 +-
 .../drm/amd/display/dc/dce80/dce80_hw_sequencer.h  |    4 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.c  |  152 +-
 .../gpu/drm/amd/display/dc/dce80/dce80_resource.h  |    8 +-
 drivers/gpu/drm/amd/display/dc/dcn10/Makefile      |    3 +-
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c   | 1521 +++++++++++++++++---
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h   |  787 +++++-----
 .../gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c    |  864 -----------
 .../gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c  |  710 ---------
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.c   |  651 ---------
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.h   |   32 -
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  |  433 ++----
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h  |    6 +-
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c   |  717 ++++++++-
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h   |  416 ++++++
 .../gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c |  118 +-
 .../gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h |   41 +-
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c   |   16 +-
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.c  |  189 ++-
 .../gpu/drm/amd/display/dc/dcn10/dcn10_resource.h  |    4 +-
 .../amd/display/dc/dcn10/dcn10_timing_generator.c  |   49 -
 .../amd/display/dc/dcn10/dcn10_timing_generator.h  |   29 -
 drivers/gpu/drm/amd/display/dc/dm_helpers.h        |    5 +
 drivers/gpu/drm/amd/display/dc/dm_pp_smu.h         |  131 --
 drivers/gpu/drm/amd/display/dc/dm_services.h       |    7 +-
 drivers/gpu/drm/amd/display/dc/dm_services_types.h |    2 -
 drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c |    6 -
 drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.h |    2 -
 .../display/dc/i2caux/dce110/aux_engine_dce110.c   |   30 +-
 drivers/gpu/drm/amd/display/dc/inc/clock_source.h  |    4 -
 drivers/gpu/drm/amd/display/dc/inc/core_dc.h       |   59 +
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |   57 +-
 drivers/gpu/drm/amd/display/dc/inc/dce_calcs.h     |    4 +-
 drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h     |   16 +-
 .../gpu/drm/amd/display/dc/inc/hw/display_clock.h  |    2 +-
 drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h       |    2 +-
 drivers/gpu/drm/amd/display/dc/inc/hw/dwb.h        |  193 ---
 drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h  |   18 -
 drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h        |   17 +-
 .../gpu/drm/amd/display/dc/inc/hw/link_encoder.h   |    1 -
 drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h  |   24 -
 drivers/gpu/drm/amd/display/dc/inc/hw/transform.h  |   20 -
 drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h  |   61 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h      |   44 +-
 .../amd/display/dc/irq/dce110/irq_service_dce110.c |    8 +-
 .../amd/display/dc/irq/dce80/irq_service_dce80.c   |    1 +
 .../amd/display/include/grph_object_ctrl_defs.h    |   38 -
 .../gpu/drm/amd/display/include/logger_interface.h |   14 +-
 .../drm/amd/display/modules/freesync/freesync.c    |   20 +-
 96 files changed, 5761 insertions(+), 6910 deletions(-)
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.c
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/dm_pp_smu.h
 create mode 100644 drivers/gpu/drm/amd/display/dc/inc/core_dc.h
 delete mode 100644 drivers/gpu/drm/amd/display/dc/inc/hw/dwb.h

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index daddb99..3f3fbf7 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
@@ -441,6 +441,7 @@ struct amdgpu_crtc {
 	enum amdgpu_interrupt_state vsync_timer_enabled;
 
 	int otg_inst;
+	uint32_t flip_flags;
 	/* After Set Mode stream will be non-NULL */
 	const struct dc_stream_state *stream;
 	struct drm_pending_vblank_event *event;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 090ed1f..38245fd 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -25,7 +25,6 @@
 
 #include "dm_services_types.h"
 #include "dc.h"
-#include "dc/inc/core_types.h"
 
 #include "vid.h"
 #include "amdgpu.h"
@@ -816,33 +815,13 @@ struct drm_atomic_state *
 dm_atomic_state_alloc(struct drm_device *dev)
 {
 	struct dm_atomic_state *state = kzalloc(sizeof(*state), GFP_KERNEL);
-	struct dc_state *new_ctx;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct dc *dc = adev->dm.dc;
 
-	if (!state)
+	if (!state || drm_atomic_state_init(dev, &state->base) < 0) {
+		kfree(state);
 		return NULL;
-
-	if (drm_atomic_state_init(dev, &state->base) < 0)
-		goto fail;
-
-	/* copy existing configuration */
-	new_ctx = dm_alloc(sizeof(*new_ctx));
-
-	if (!new_ctx)
-		goto fail;
-
-	atomic_inc(&new_ctx->ref_count);
-
-	dc_resource_state_copy_construct_current(dc, new_ctx);
-
-	state->context = new_ctx;
+	}
 
 	return &state->base;
-
-fail:
-	kfree(state);
-	return NULL;
 }
 
 static void
@@ -851,7 +830,7 @@ dm_atomic_state_clear(struct drm_atomic_state *state)
 	struct dm_atomic_state *dm_state = to_dm_atomic_state(state);
 
 	if (dm_state->context) {
-		dc_release_state(dm_state->context);
+		dc_release_validate_context(dm_state->context);
 		dm_state->context = NULL;
 	}
 
@@ -1784,6 +1763,12 @@ static bool modeset_required(struct drm_crtc_state *crtc_state,
 			     struct dc_stream_state *new_stream,
 			     struct dc_stream_state *old_stream)
 {
+	if (dc_is_stream_unchanged(new_stream, old_stream)) {
+		crtc_state->mode_changed = false;
+		DRM_DEBUG_KMS("Mode change not required, setting mode_changed to %d",
+			      crtc_state->mode_changed);
+	}
+
 	if (!drm_atomic_crtc_needs_modeset(crtc_state))
 		return false;
 
@@ -4113,7 +4098,7 @@ static void amdgpu_dm_do_flip(
 	struct amdgpu_framebuffer *afb = to_amdgpu_framebuffer(fb);
 	struct amdgpu_bo *abo = gem_to_amdgpu_bo(afb->obj);
 	struct amdgpu_device *adev = crtc->dev->dev_private;
-	bool async_flip = (crtc->state->pageflip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;
+	bool async_flip = (acrtc->flip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;
 	struct dc_flip_addrs addr = { {0} };
 	/* TODO eliminate or rename surface_update */
 	struct dc_surface_update surface_updates[1] = { {0} };
@@ -4215,7 +4200,9 @@ static void amdgpu_dm_commit_planes(struct drm_atomic_state *state,
 			continue;
 		}
 
-		if (!fb || !crtc || pcrtc != crtc || !crtc->state->active)
+		if (!fb || !crtc || pcrtc != crtc || !crtc->state->active ||
+				(!crtc->state->planes_changed &&
+						!pcrtc->state->color_mgmt_changed))
 			continue;
 
 		pflip_needed = !state->allow_modeset;
@@ -4245,7 +4232,7 @@ static void amdgpu_dm_commit_planes(struct drm_atomic_state *state,
 			 * TODO Check if it's correct
 			 */
 			*wait_for_vblank =
-					pcrtc->state->pageflip_flags & DRM_MODE_PAGE_FLIP_ASYNC ?
+				acrtc_attach->flip_flags & DRM_MODE_PAGE_FLIP_ASYNC ?
 				false : true;
 
 			/* TODO: Needs rework for multiplane flip */
@@ -4256,6 +4243,11 @@ static void amdgpu_dm_commit_planes(struct drm_atomic_state *state,
 				crtc,
 				fb,
 				drm_crtc_vblank_count(crtc) + *wait_for_vblank);
+
+			/*TODO BUG remove ASAP in 4.12 to avoid race between worker and flip IOCTL */
+
+			/*clean up the flags for next usage*/
+			acrtc_attach->flip_flags = 0;
 		}
 
 	}
@@ -4447,7 +4439,7 @@ void amdgpu_dm_atomic_commit_tail(
 	}
 
 	if (dm_state->context)
-		WARN_ON(!dc_commit_state(dm->dc, dm_state->context));
+		WARN_ON(!dc_commit_context(dm->dc, dm_state->context));
 
 
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
@@ -4640,6 +4632,77 @@ void dm_restore_drm_connector_state(struct drm_device *dev, struct drm_connector
 		dm_force_atomic_commit(&aconnector->base);
 }
 
+static uint32_t add_val_sets_plane(
+	struct dc_validation_set *val_sets,
+	uint32_t set_count,
+	const struct dc_stream_state *stream,
+	struct dc_plane_state *plane_state)
+{
+	uint32_t i = 0, j = 0;
+
+	while (i < set_count) {
+		if (val_sets[i].stream == stream) {
+			while (val_sets[i].plane_states[j])
+				j++;
+			break;
+		}
+		++i;
+	}
+
+	val_sets[i].plane_states[j] = plane_state;
+	val_sets[i].plane_count++;
+
+	return val_sets[i].plane_count;
+}
+
+static uint32_t update_in_val_sets_stream(
+	struct dc_validation_set *val_sets,
+	uint32_t set_count,
+	struct dc_stream_state *old_stream,
+	struct dc_stream_state *new_stream,
+	struct drm_crtc *crtc)
+{
+	uint32_t i = 0;
+
+	while (i < set_count) {
+		if (val_sets[i].stream == old_stream)
+			break;
+		++i;
+	}
+
+	val_sets[i].stream = new_stream;
+
+	if (i == set_count)
+		/* nothing found. add new one to the end */
+		return set_count + 1;
+
+	return set_count;
+}
+
+static uint32_t remove_from_val_sets(
+	struct dc_validation_set *val_sets,
+	uint32_t set_count,
+	const struct dc_stream_state *stream)
+{
+	int i;
+
+	for (i = 0; i < set_count; i++)
+		if (val_sets[i].stream == stream)
+			break;
+
+	if (i == set_count) {
+		/* nothing found */
+		return set_count;
+	}
+
+	set_count--;
+
+	for (; i < set_count; i++)
+		val_sets[i] = val_sets[i + 1];
+
+	return set_count;
+}
+
 /*`
  * Grabs all modesetting locks to serialize against any blocking commits,
  * Waits for completion of all non blocking commits.
@@ -4690,18 +4753,51 @@ static int do_aquire_global_lock(
 	return ret < 0 ? ret : 0;
 }
 
-static int dm_update_crtcs_state(
-		struct dc *dc,
-		struct drm_atomic_state *state,
-		bool enable,
-		bool *lock_and_validation_needed)
+int amdgpu_dm_atomic_check(struct drm_device *dev,
+			struct drm_atomic_state *state)
 {
+	struct dm_atomic_state *dm_state;
 	struct drm_crtc *crtc;
 	struct drm_crtc_state *crtc_state;
-	int i;
+	struct drm_plane *plane;
+	struct drm_plane_state *plane_state;
+	int i, j;
+	int ret;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct dc *dc = adev->dm.dc;
+	struct drm_connector *connector;
+	struct drm_connector_state *conn_state;
+	int set_count;
+	struct dc_validation_set set[MAX_STREAMS] = { { 0 } };
 	struct dm_crtc_state *old_acrtc_state, *new_acrtc_state;
-	struct dm_atomic_state *dm_state = to_dm_atomic_state(state);
-	int ret = 0;
+
+	/*
+	 * This bool will be set for true for any modeset/reset
+	 * or plane update which implies non fast surface update.
+	 */
+	bool lock_and_validation_needed = false;
+
+	ret = drm_atomic_helper_check_modeset(dev, state);
+
+	if (ret) {
+		DRM_ERROR("Atomic state validation failed with error :%d !\n", ret);
+		return ret;
+	}
+
+	dm_state = to_dm_atomic_state(state);
+
+	/* copy existing configuration */
+	set_count = 0;
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+
+		old_acrtc_state = to_dm_crtc_state(crtc->state);
+
+		if (old_acrtc_state->stream) {
+			dc_stream_retain(old_acrtc_state->stream);
+			set[set_count].stream = old_acrtc_state->stream;
+			++set_count;
+		}
+	}
 
 	/*TODO Move this code into dm_crtc_atomic_check once we get rid of dc_validation_set */
 	/* update changed items */
@@ -4712,56 +4808,12 @@ static int dm_update_crtcs_state(
 		struct drm_connector_state *conn_state = NULL;
 		struct dm_connector_state *dm_conn_state = NULL;
 
-
 		old_acrtc_state = to_dm_crtc_state(crtc->state);
 		new_acrtc_state = to_dm_crtc_state(crtc_state);
 		acrtc = to_amdgpu_crtc(crtc);
 
 		aconnector = amdgpu_dm_find_first_crct_matching_connector(state, crtc, true);
 
-		/* TODO This hack should go away */
-		if (aconnector && aconnector->dc_sink) {
-			conn_state = drm_atomic_get_connector_state(state,
-								    &aconnector->base);
-
-			if (IS_ERR(conn_state)) {
-				ret = PTR_ERR_OR_ZERO(conn_state);
-				break;
-			}
-
-			dm_conn_state = to_dm_connector_state(conn_state);
-
-			new_stream = create_stream_for_sink(aconnector,
-							    &crtc_state->mode,
-							    dm_conn_state);
-
-			/*
-			 * we can have no stream on ACTION_SET if a display
-			 * was disconnected during S3, in this case it not and
-			 * error, the OS will be updated after detection, and
-			 * do the right thing on next atomic commit
-			 */
-
-			if (!new_stream) {
-				DRM_DEBUG_KMS("%s: Failed to create new stream for crtc %d\n",
-						__func__, acrtc->base.base.id);
-				break;
-			}
-		}
-
-		if (dc_is_stream_unchanged(new_stream,
-				old_acrtc_state->stream)) {
-
-				crtc_state->mode_changed = false;
-
-				DRM_DEBUG_KMS("Mode change not required, setting mode_changed to %d",
-					      crtc_state->mode_changed);
-		}
-
-
-		if (!drm_atomic_crtc_needs_modeset(crtc_state))
-				continue;
-
 #if !defined(OS_NAME_RHEL_7_2)
 		DRM_DEBUG_KMS(
 			"amdgpu_crtc id:%d crtc_state_flags: enable:%d, active:%d, "
@@ -4776,252 +4828,93 @@ static int dm_update_crtcs_state(
 			crtc_state->connectors_changed);
 #endif
 
-		/* Remove stream for any changed/disabled CRTC */
-		if (!enable) {
+		if (modereset_required(crtc_state)) {
 
-			if (!old_acrtc_state->stream)
-				continue;
+					/* i.e. reset mode */
+			if (new_acrtc_state->stream) {
+				set_count = remove_from_val_sets(
+						set,
+						set_count,
+						new_acrtc_state->stream);
 
-			DRM_DEBUG_KMS("Disabling DRM crtc: %d\n",
-					crtc->base.id);
+				dc_stream_release(new_acrtc_state->stream);
+				new_acrtc_state->stream = NULL;
 
-			/* i.e. reset mode */
-			if (!dc_remove_stream_from_ctx(
-					dc,
-					dm_state->context,
-					old_acrtc_state->stream)) {
-				ret = -EINVAL;
-				break;
+				lock_and_validation_needed = true;
 			}
 
-			dc_stream_release(old_acrtc_state->stream);
-			new_acrtc_state->stream = NULL;
-
-			*lock_and_validation_needed = true;
-
-		} else {/* Add stream for any updated/enabled CRTC */
+		} else {
 
-			if (modereset_required(crtc_state))
-				continue;
+			if (aconnector) {
+				conn_state = drm_atomic_get_connector_state(state,
+									    &aconnector->base);
 
-			if (modeset_required(crtc_state, new_stream,
-					     old_acrtc_state->stream)) {
+				if (IS_ERR(conn_state)) {
+					ret = PTR_ERR_OR_ZERO(conn_state);
+					goto fail;
+				}
 
-				WARN_ON(new_acrtc_state->stream);
+				dm_conn_state = to_dm_connector_state(conn_state);
 
-				new_acrtc_state->stream = new_stream;
-				dc_stream_retain(new_stream);
+				new_stream = create_stream_for_sink(aconnector,
+								    &crtc_state->mode,
+								    dm_conn_state);
 
-				DRM_DEBUG_KMS("Enabling DRM crtc: %d\n",
-							crtc->base.id);
+				/*
+				 * we can have no stream on ACTION_SET if a display
+				 * was disconnected during S3, in this case it not and
+				 * error, the OS will be updated after detection, and
+				 * do the right thing on next atomic commit
+				 */
 
-				if (!dc_add_stream_to_ctx(
-						dc,
-						dm_state->context,
-						new_acrtc_state->stream)) {
-					ret = -EINVAL;
+				if (!new_stream) {
+					DRM_DEBUG_KMS("%s: Failed to create new stream for crtc %d\n",
+							__func__, acrtc->base.base.id);
 					break;
 				}
 
-				*lock_and_validation_needed = true;
-			}
-		}
 
-		/* Release extra reference */
-		if (new_stream)
-			 dc_stream_release(new_stream);
-	}
-
-	return ret;
-}
-
-static int dm_update_planes_state(
-		struct dc *dc,
-		struct drm_atomic_state *state,
-		bool enable,
-		bool *lock_and_validation_needed)
-{
-	struct drm_crtc *new_plane_crtc, *old_plane_crtc;
-	struct drm_crtc_state *new_crtc_state;
-	struct drm_plane *plane;
-	struct drm_plane_state *old_plane_state, *new_plane_state;
-	struct dm_crtc_state *new_acrtc_state, *old_acrtc_state;
-	struct dm_atomic_state *dm_state = to_dm_atomic_state(state);
-	struct dm_plane_state *new_dm_plane_state, *old_dm_plane_state;
-	int i ;
-	/* TODO return page_flip_needed() function */
-	bool pflip_needed  = !state->allow_modeset;
-	int ret = 0;
-
-	if (pflip_needed)
-		return ret;
-
-	/* Add new planes */
-	for_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {
-		new_plane_crtc = new_plane_state->crtc;
-		old_plane_crtc = old_plane_state->crtc;
-		new_dm_plane_state = to_dm_plane_state(new_plane_state);
-		old_dm_plane_state = to_dm_plane_state(old_plane_state);
-
-		/*TODO Implement atomic check for cursor plane */
-		if (plane->type == DRM_PLANE_TYPE_CURSOR)
-			continue;
-
-		/* Remove any changed/removed planes */
-		if (!enable) {
-
-			if (!old_plane_crtc)
-				continue;
-
-			old_acrtc_state = to_dm_crtc_state(
-					drm_atomic_get_old_crtc_state(
-							state,
-							old_plane_crtc));
-
-			if (!old_acrtc_state->stream)
-				continue;
-
-			DRM_DEBUG_KMS("Disabling DRM plane: %d on DRM crtc %d\n",
-					plane->base.id, old_plane_crtc->base.id);
-
-			if (!dc_remove_plane_from_context(
-					dc,
-					old_acrtc_state->stream,
-					old_dm_plane_state->dc_state,
-					dm_state->context)) {
-
-				ret = EINVAL;
-				return ret;
 			}
 
+			if (modeset_required(crtc_state, new_stream,
+					     old_acrtc_state->stream)) {
 
-			dc_plane_state_release(old_dm_plane_state->dc_state);
-			new_dm_plane_state->dc_state = NULL;
-
-			*lock_and_validation_needed = true;
-
-		} else { /* Add new planes */
-
-			if (drm_atomic_plane_disabling(plane->state, new_plane_state))
-				continue;
-
-			if (!new_plane_crtc)
-				continue;
-
-			new_crtc_state = drm_atomic_get_new_crtc_state(state, new_plane_crtc);
-			new_acrtc_state = to_dm_crtc_state(new_crtc_state);
-
-			if (!new_acrtc_state->stream)
-				continue;
-
-
-			WARN_ON(new_dm_plane_state->dc_state);
-
-			new_dm_plane_state->dc_state = dc_create_plane_state(dc);
-
-			DRM_DEBUG_KMS("Enabling DRM plane: %d on DRM crtc %d\n",
-					plane->base.id, new_plane_crtc->base.id);
-
-			if (!new_dm_plane_state->dc_state) {
-				ret = -EINVAL;
-				return ret;
-			}
+				if (new_acrtc_state->stream)
+					dc_stream_release(new_acrtc_state->stream);
 
-			ret = fill_plane_attributes(
-				new_plane_crtc->dev->dev_private,
-				new_dm_plane_state->dc_state,
-				new_plane_state,
-				new_crtc_state,
-				false);
-			if (ret)
-				return ret;
+				new_acrtc_state->stream = new_stream;
 
+				set_count = update_in_val_sets_stream(
+						set,
+						set_count,
+						old_acrtc_state->stream,
+						new_acrtc_state->stream,
+						crtc);
 
-			if (!dc_add_plane_to_context(
-					dc,
-					new_acrtc_state->stream,
-					new_dm_plane_state->dc_state,
-					dm_state->context)) {
+				lock_and_validation_needed = true;
+			} else {
+				/*
+				 * The new stream is unused, so we release it
+				 */
+				if (new_stream)
+					dc_stream_release(new_stream);
 
-				ret = -EINVAL;
-				return ret;
 			}
-
-			*lock_and_validation_needed = true;
 		}
-	}
-
 
-	return ret;
-}
 
-int amdgpu_dm_atomic_check(struct drm_device *dev,
-			struct drm_atomic_state *state)
-{
-	int i;
-	int ret;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct dc *dc = adev->dm.dc;
-	struct dm_atomic_state *dm_state = to_dm_atomic_state(state);
-	struct drm_connector *connector;
-	struct drm_connector_state *conn_state;
-	struct drm_crtc *crtc;
-	struct drm_crtc_state *crtc_state;
-
-	/*
-	 * This bool will be set for true for any modeset/reset
-	 * or plane update which implies non fast surface update.
-	 */
-	bool lock_and_validation_needed = false;
-
-	ret = drm_atomic_helper_check_modeset(dev, state);
-
-	if (ret) {
-		DRM_ERROR("Atomic state validation failed with error :%d !\n", ret);
-		return ret;
-	}
-
-	/*
-	 * Hack: Commit needs planes right now, specifically for gamma
-	 * TODO rework commit to check CRTC for gamma change
-	 */
-	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+		/*
+		 * Hack: Commit needs planes right now, specifically for gamma
+		 * TODO rework commit to check CRTC for gamma change
+		 */
 		if (crtc_state->color_mgmt_changed) {
+
 			ret = drm_atomic_add_affected_planes(state, crtc);
 			if (ret)
 				goto fail;
 		}
 	}
 
-	/* Remove exiting planes if they are modified */
-	ret = dm_update_planes_state(dc, state, false, &lock_and_validation_needed);
-	if (ret) {
-		goto fail;
-	}
-
-	/* Disable all crtcs which require disable */
-	ret = dm_update_crtcs_state(dc, state, false, &lock_and_validation_needed);
-	if (ret) {
-		goto fail;
-	}
-
-	/* Enable all crtcs which require enable */
-	ret = dm_update_crtcs_state(dc, state, true, &lock_and_validation_needed);
-	if (ret) {
-		goto fail;
-	}
-
-	/* Add new/modified planes */
-	ret = dm_update_planes_state(dc, state, true, &lock_and_validation_needed);
-	if (ret) {
-		goto fail;
-	}
-
-	 /* Run this here since we want to validate the streams we created */
-	 ret = drm_atomic_helper_check_planes(dev, state);
-	 if (ret)
-		 goto fail;
-
 	/* Check scaling and undersacn changes*/
 	/*TODO Removed scaling changes validation due to inability to commit
 	 * new stream into context w\o causing full reset. Need to
@@ -5046,6 +4939,59 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 		lock_and_validation_needed = true;
 	}
 
+	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+		new_acrtc_state = to_dm_crtc_state(crtc_state);
+
+		for_each_plane_in_state(state, plane, plane_state, j) {
+			struct drm_crtc *plane_crtc = plane_state->crtc;
+			struct drm_framebuffer *fb = plane_state->fb;
+			bool pflip_needed;
+			struct dm_plane_state *dm_plane_state = to_dm_plane_state(plane_state);
+
+			/*TODO Implement atomic check for cursor plane */
+			if (plane->type == DRM_PLANE_TYPE_CURSOR)
+				continue;
+
+			if (!fb || !plane_crtc || crtc != plane_crtc || !crtc_state->active)
+				continue;
+
+			WARN_ON(!new_acrtc_state->stream);
+
+			pflip_needed = !state->allow_modeset;
+			if (!pflip_needed) {
+				struct dc_plane_state *dc_plane_state;
+
+				dc_plane_state = dc_create_plane_state(dc);
+
+				if (dm_plane_state->dc_state)
+					dc_plane_state_release(dm_plane_state->dc_state);
+
+				dm_plane_state->dc_state = dc_plane_state;
+
+				ret = fill_plane_attributes(
+					plane_crtc->dev->dev_private,
+					dc_plane_state,
+					plane_state,
+					crtc_state,
+					false);
+				if (ret)
+					goto fail;
+
+				add_val_sets_plane(set,
+						     set_count,
+						     new_acrtc_state->stream,
+						     dc_plane_state);
+
+				lock_and_validation_needed = true;
+			}
+		}
+	}
+
+	/* Run this here since we want to validate the streams we created */
+	ret = drm_atomic_helper_check_planes(dev, state);
+	if (ret)
+		goto fail;
+
 	/*
 	 * For full updates case when
 	 * removing/adding/updating  streams on once CRTC while flipping
@@ -5061,8 +5007,9 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 		ret = do_aquire_global_lock(dev, state);
 		if (ret)
 			goto fail;
-
-		if (!dc_validate_global_state(dc, dm_state->context)) {
+		WARN_ON(dm_state->context);
+		dm_state->context = dc_get_validate_context(dc, set, set_count);
+		if (!dm_state->context) {
 			ret = -EINVAL;
 			goto fail;
 		}
@@ -5078,7 +5025,7 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 	else if (ret == -EINTR || ret == -EAGAIN || ret == -ERESTARTSYS)
 		DRM_DEBUG_KMS("Atomic check stopped due to to signal.\n");
 	else
-		DRM_ERROR("Atomic check failed with err: %d \n", ret);
+		DRM_ERROR("Atomic check failed with err: %d .\n", ret);
 
 	return ret;
 }
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index cfed645..3505421 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -209,7 +209,7 @@ struct dm_crtc_state {
 struct dm_atomic_state {
 	struct drm_atomic_state base;
 
-	struct dc_state *context;
+	struct validate_context *context;
 };
 
 #define to_dm_atomic_state(x) container_of(x, struct dm_atomic_state, base)
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_services.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_services.c
index aefd9eb..3348e90 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_services.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_services.c
@@ -401,6 +401,14 @@ bool dm_pp_notify_wm_clock_changes(
 	return false;
 }
 
+bool dm_pp_notify_wm_clock_changes_soc15(
+	const struct dc_context *ctx,
+	struct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)
+{
+	/* TODO: to be implemented */
+	return false;
+}
+
 bool dm_pp_apply_power_level_change_request(
 	const struct dc_context *ctx,
 	struct dm_pp_power_level_change_request *level_change_req)
@@ -425,9 +433,4 @@ bool dm_pp_get_static_clocks(
 	return false;
 }
 
-void dm_pp_get_funcs_rv(
-		struct dc_context *ctx,
-		struct pp_smu_funcs_rv *funcs)
-{}
-
 /**** end of power component interfaces ****/
diff --git a/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
index 2c41144..2c683d4 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
@@ -1853,7 +1853,6 @@ static enum bp_result bios_parser_get_encoder_cap_info(
 
 	info->DP_HBR2_EN = record->usHBR2En;
 	info->DP_HBR3_EN = record->usHBR3En;
-	info->HDMI_6GB_EN = record->usHDMI6GEn;
 	return BP_RESULT_OK;
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c b/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
index 95fe50f..86fce5a 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c
@@ -29,6 +29,7 @@
 
 #include "ObjectID.h"
 #include "atomfirmware.h"
+#include "atomfirmwareid.h"
 
 #include "dc_bios_types.h"
 #include "include/grph_object_ctrl_defs.h"
@@ -992,8 +993,6 @@ static struct device_id device_type_from_device_id(uint16_t device_id)
 
 	struct device_id result_device_id;
 
-	result_device_id.raw_device_tag = device_id;
-
 	switch (device_id) {
 	case ATOM_DISPLAY_LCD1_SUPPORT:
 		result_device_id.device_type = DEVICE_TYPE_LCD;
@@ -1813,77 +1812,10 @@ static enum bp_result get_integrated_info_v11(
 			info_v11->extdispconninfo.path[i].hpdlut_index;
 		info->ext_disp_conn_info.path[i].channel_mapping.raw =
 			info_v11->extdispconninfo.path[i].channelmapping;
-		info->ext_disp_conn_info.path[i].caps =
-				le16_to_cpu(info_v11->extdispconninfo.path[i].caps);
 	}
 	info->ext_disp_conn_info.checksum =
 	info_v11->extdispconninfo.checksum;
 
-	info->dp0_ext_hdmi_slv_addr = info_v11->dp0_retimer_set.HdmiSlvAddr;
-	info->dp0_ext_hdmi_reg_num = info_v11->dp0_retimer_set.HdmiRegNum;
-	for (i = 0; i < info->dp0_ext_hdmi_reg_num; i++) {
-		info->dp0_ext_hdmi_reg_settings[i].i2c_reg_index =
-				info_v11->dp0_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;
-		info->dp0_ext_hdmi_reg_settings[i].i2c_reg_val =
-				info_v11->dp0_retimer_set.HdmiRegSetting[i].ucI2cRegVal;
-	}
-	info->dp0_ext_hdmi_6g_reg_num = info_v11->dp0_retimer_set.Hdmi6GRegNum;
-	for (i = 0; i < info->dp0_ext_hdmi_6g_reg_num; i++) {
-		info->dp0_ext_hdmi_6g_reg_settings[i].i2c_reg_index =
-				info_v11->dp0_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;
-		info->dp0_ext_hdmi_6g_reg_settings[i].i2c_reg_val =
-				info_v11->dp0_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;
-	}
-
-	info->dp1_ext_hdmi_slv_addr = info_v11->dp1_retimer_set.HdmiSlvAddr;
-	info->dp1_ext_hdmi_reg_num = info_v11->dp1_retimer_set.HdmiRegNum;
-	for (i = 0; i < info->dp1_ext_hdmi_reg_num; i++) {
-		info->dp1_ext_hdmi_reg_settings[i].i2c_reg_index =
-				info_v11->dp1_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;
-		info->dp1_ext_hdmi_reg_settings[i].i2c_reg_val =
-				info_v11->dp1_retimer_set.HdmiRegSetting[i].ucI2cRegVal;
-	}
-	info->dp1_ext_hdmi_6g_reg_num = info_v11->dp1_retimer_set.Hdmi6GRegNum;
-	for (i = 0; i < info->dp1_ext_hdmi_6g_reg_num; i++) {
-		info->dp1_ext_hdmi_6g_reg_settings[i].i2c_reg_index =
-				info_v11->dp1_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;
-		info->dp1_ext_hdmi_6g_reg_settings[i].i2c_reg_val =
-				info_v11->dp1_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;
-	}
-
-	info->dp2_ext_hdmi_slv_addr = info_v11->dp2_retimer_set.HdmiSlvAddr;
-	info->dp2_ext_hdmi_reg_num = info_v11->dp2_retimer_set.HdmiRegNum;
-	for (i = 0; i < info->dp2_ext_hdmi_reg_num; i++) {
-		info->dp2_ext_hdmi_reg_settings[i].i2c_reg_index =
-				info_v11->dp2_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;
-		info->dp2_ext_hdmi_reg_settings[i].i2c_reg_val =
-				info_v11->dp2_retimer_set.HdmiRegSetting[i].ucI2cRegVal;
-	}
-	info->dp2_ext_hdmi_6g_reg_num = info_v11->dp2_retimer_set.Hdmi6GRegNum;
-	for (i = 0; i < info->dp2_ext_hdmi_6g_reg_num; i++) {
-		info->dp2_ext_hdmi_6g_reg_settings[i].i2c_reg_index =
-				info_v11->dp2_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;
-		info->dp2_ext_hdmi_6g_reg_settings[i].i2c_reg_val =
-				info_v11->dp2_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;
-	}
-
-	info->dp3_ext_hdmi_slv_addr = info_v11->dp3_retimer_set.HdmiSlvAddr;
-	info->dp3_ext_hdmi_reg_num = info_v11->dp3_retimer_set.HdmiRegNum;
-	for (i = 0; i < info->dp3_ext_hdmi_reg_num; i++) {
-		info->dp3_ext_hdmi_reg_settings[i].i2c_reg_index =
-				info_v11->dp3_retimer_set.HdmiRegSetting[i].ucI2cRegIndex;
-		info->dp3_ext_hdmi_reg_settings[i].i2c_reg_val =
-				info_v11->dp3_retimer_set.HdmiRegSetting[i].ucI2cRegVal;
-	}
-	info->dp3_ext_hdmi_6g_reg_num = info_v11->dp3_retimer_set.Hdmi6GRegNum;
-	for (i = 0; i < info->dp3_ext_hdmi_6g_reg_num; i++) {
-		info->dp3_ext_hdmi_6g_reg_settings[i].i2c_reg_index =
-				info_v11->dp3_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegIndex;
-		info->dp3_ext_hdmi_6g_reg_settings[i].i2c_reg_val =
-				info_v11->dp3_retimer_set.Hdmi6GhzRegSetting[i].ucI2cRegVal;
-	}
-
-
 	/** TODO - review **/
 	#if 0
 	info->boot_up_engine_clock = le32_to_cpu(info_v11->ulBootUpEngineClock)
diff --git a/drivers/gpu/drm/amd/display/dc/bios/command_table2.c b/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
index 64eab35..e33e6bf 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
@@ -27,6 +27,7 @@
 
 #include "ObjectID.h"
 #include "atomfirmware.h"
+#include "atomfirmwareid.h"
 
 #include "include/bios_parser_interface.h"
 
diff --git a/drivers/gpu/drm/amd/display/dc/bios/command_table_helper2.c b/drivers/gpu/drm/amd/display/dc/bios/command_table_helper2.c
index 9a4d30d..35c3f3a 100644
--- a/drivers/gpu/drm/amd/display/dc/bios/command_table_helper2.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/command_table_helper2.c
@@ -27,6 +27,7 @@
 
 #include "ObjectID.h"
 #include "atomfirmware.h"
+#include "atomfirmwareid.h"
 
 #include "include/bios_parser_types.h"
 
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index 1b0f647..67da973 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -27,6 +27,7 @@
 #include "dcn_calcs.h"
 #include "dcn_calc_auto.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "dal_asic_id.h"
 
 #include "resource.h"
@@ -398,7 +399,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 }
 
 static void dcn_bw_calc_rq_dlg_ttu(
-		const struct dc *dc,
+		const struct core_dc *dc,
 		const struct dcn_bw_internal_vars *v,
 		struct pipe_ctx *pipe,
 		int in_idx)
@@ -456,7 +457,7 @@ static void dcn_bw_calc_rq_dlg_ttu(
 	}
 
 	/*todo: soc->sr_enter_plus_exit_time??*/
-	dlg_sys_param.t_srx_delay_us = dc->dcn_ip->dcfclk_cstate_latency / v->dcf_clk_deep_sleep;
+	dlg_sys_param.t_srx_delay_us = dc->dcn_ip.dcfclk_cstate_latency / v->dcf_clk_deep_sleep;
 
 	dml_rq_dlg_get_rq_params(dml, &rq_param, input.pipe.src);
 	extract_rq_regs(dml, rq_regs, rq_param);
@@ -476,7 +477,7 @@ static void dcn_bw_calc_rq_dlg_ttu(
 static void dcn_dml_wm_override(
 		const struct dcn_bw_internal_vars *v,
 		struct display_mode_lib *dml,
-		struct dc_state *context,
+		struct validate_context *context,
 		const struct resource_pool *pool)
 {
 	int i, in_idx, active_count;
@@ -581,7 +582,6 @@ static void split_stream_across_pipes(
 	secondary_pipe->plane_res.ipp = pool->ipps[secondary_pipe->pipe_idx];
 	secondary_pipe->plane_res.xfm = pool->transforms[secondary_pipe->pipe_idx];
 	if (primary_pipe->bottom_pipe) {
-		ASSERT(primary_pipe->bottom_pipe != secondary_pipe);
 		secondary_pipe->bottom_pipe = primary_pipe->bottom_pipe;
 		secondary_pipe->bottom_pipe->top_pipe = secondary_pipe;
 	}
@@ -593,7 +593,7 @@ static void split_stream_across_pipes(
 }
 
 static void calc_wm_sets_and_perf_params(
-		struct dc_state *context,
+		struct validate_context *context,
 		struct dcn_bw_internal_vars *v)
 {
 	/* Calculate set A last to keep internal var state consistent for required config */
@@ -674,45 +674,45 @@ static void calc_wm_sets_and_perf_params(
 		context->bw.dcn.watermarks.d = context->bw.dcn.watermarks.a;
 }
 
-static bool dcn_bw_apply_registry_override(struct dc *dc)
+static bool dcn_bw_apply_registry_override(struct core_dc *dc)
 {
 	bool updated = false;
 
 	kernel_fpu_begin();
-	if ((int)(dc->dcn_soc->sr_exit_time * 1000) != dc->debug.sr_exit_time_ns
-			&& dc->debug.sr_exit_time_ns) {
+	if ((int)(dc->dcn_soc.sr_exit_time * 1000) != dc->public.debug.sr_exit_time_ns
+			&& dc->public.debug.sr_exit_time_ns) {
 		updated = true;
-		dc->dcn_soc->sr_exit_time = dc->debug.sr_exit_time_ns / 1000.0;
+		dc->dcn_soc.sr_exit_time = dc->public.debug.sr_exit_time_ns / 1000.0;
 	}
 
-	if ((int)(dc->dcn_soc->sr_enter_plus_exit_time * 1000)
-				!= dc->debug.sr_enter_plus_exit_time_ns
-			&& dc->debug.sr_enter_plus_exit_time_ns) {
+	if ((int)(dc->dcn_soc.sr_enter_plus_exit_time * 1000)
+				!= dc->public.debug.sr_enter_plus_exit_time_ns
+			&& dc->public.debug.sr_enter_plus_exit_time_ns) {
 		updated = true;
-		dc->dcn_soc->sr_enter_plus_exit_time =
-				dc->debug.sr_enter_plus_exit_time_ns / 1000.0;
+		dc->dcn_soc.sr_enter_plus_exit_time =
+				dc->public.debug.sr_enter_plus_exit_time_ns / 1000.0;
 	}
 
-	if ((int)(dc->dcn_soc->urgent_latency * 1000) != dc->debug.urgent_latency_ns
-			&& dc->debug.urgent_latency_ns) {
+	if ((int)(dc->dcn_soc.urgent_latency * 1000) != dc->public.debug.urgent_latency_ns
+			&& dc->public.debug.urgent_latency_ns) {
 		updated = true;
-		dc->dcn_soc->urgent_latency = dc->debug.urgent_latency_ns / 1000.0;
+		dc->dcn_soc.urgent_latency = dc->public.debug.urgent_latency_ns / 1000.0;
 	}
 
-	if ((int)(dc->dcn_soc->percent_of_ideal_drambw_received_after_urg_latency * 1000)
-				!= dc->debug.percent_of_ideal_drambw
-			&& dc->debug.percent_of_ideal_drambw) {
+	if ((int)(dc->dcn_soc.percent_of_ideal_drambw_received_after_urg_latency * 1000)
+				!= dc->public.debug.percent_of_ideal_drambw
+			&& dc->public.debug.percent_of_ideal_drambw) {
 		updated = true;
-		dc->dcn_soc->percent_of_ideal_drambw_received_after_urg_latency =
-				dc->debug.percent_of_ideal_drambw;
+		dc->dcn_soc.percent_of_ideal_drambw_received_after_urg_latency =
+				dc->public.debug.percent_of_ideal_drambw;
 	}
 
-	if ((int)(dc->dcn_soc->dram_clock_change_latency * 1000)
-				!= dc->debug.dram_clock_change_latency_ns
-			&& dc->debug.dram_clock_change_latency_ns) {
+	if ((int)(dc->dcn_soc.dram_clock_change_latency * 1000)
+				!= dc->public.debug.dram_clock_change_latency_ns
+			&& dc->public.debug.dram_clock_change_latency_ns) {
 		updated = true;
-		dc->dcn_soc->dram_clock_change_latency =
-				dc->debug.dram_clock_change_latency_ns / 1000.0;
+		dc->dcn_soc.dram_clock_change_latency =
+				dc->public.debug.dram_clock_change_latency_ns / 1000.0;
 	}
 	kernel_fpu_end();
 
@@ -720,8 +720,8 @@ static bool dcn_bw_apply_registry_override(struct dc *dc)
 }
 
 bool dcn_validate_bandwidth(
-		struct dc *dc,
-		struct dc_state *context)
+		const struct core_dc *dc,
+		struct validate_context *context)
 {
 	const struct resource_pool *pool = dc->res_pool;
 	struct dcn_bw_internal_vars *v = &context->dcn_bw_vars;
@@ -730,88 +730,88 @@ bool dcn_validate_bandwidth(
 	bool bw_limit_pass;
 	float bw_limit;
 
-	if (dcn_bw_apply_registry_override(dc))
-		dcn_bw_sync_calcs_and_dml(dc);
+	if (dcn_bw_apply_registry_override(DC_TO_CORE(&dc->public)))
+		dcn_bw_sync_calcs_and_dml(DC_TO_CORE(&dc->public));
 
 	memset(v, 0, sizeof(*v));
 	kernel_fpu_begin();
-	v->sr_exit_time = dc->dcn_soc->sr_exit_time;
-	v->sr_enter_plus_exit_time = dc->dcn_soc->sr_enter_plus_exit_time;
-	v->urgent_latency = dc->dcn_soc->urgent_latency;
-	v->write_back_latency = dc->dcn_soc->write_back_latency;
+	v->sr_exit_time = dc->dcn_soc.sr_exit_time;
+	v->sr_enter_plus_exit_time = dc->dcn_soc.sr_enter_plus_exit_time;
+	v->urgent_latency = dc->dcn_soc.urgent_latency;
+	v->write_back_latency = dc->dcn_soc.write_back_latency;
 	v->percent_of_ideal_drambw_received_after_urg_latency =
-			dc->dcn_soc->percent_of_ideal_drambw_received_after_urg_latency;
-
-	v->dcfclkv_min0p65 = dc->dcn_soc->dcfclkv_min0p65;
-	v->dcfclkv_mid0p72 = dc->dcn_soc->dcfclkv_mid0p72;
-	v->dcfclkv_nom0p8 = dc->dcn_soc->dcfclkv_nom0p8;
-	v->dcfclkv_max0p9 = dc->dcn_soc->dcfclkv_max0p9;
-
-	v->max_dispclk_vmin0p65 = dc->dcn_soc->max_dispclk_vmin0p65;
-	v->max_dispclk_vmid0p72 = dc->dcn_soc->max_dispclk_vmid0p72;
-	v->max_dispclk_vnom0p8 = dc->dcn_soc->max_dispclk_vnom0p8;
-	v->max_dispclk_vmax0p9 = dc->dcn_soc->max_dispclk_vmax0p9;
-
-	v->max_dppclk_vmin0p65 = dc->dcn_soc->max_dppclk_vmin0p65;
-	v->max_dppclk_vmid0p72 = dc->dcn_soc->max_dppclk_vmid0p72;
-	v->max_dppclk_vnom0p8 = dc->dcn_soc->max_dppclk_vnom0p8;
-	v->max_dppclk_vmax0p9 = dc->dcn_soc->max_dppclk_vmax0p9;
-
-	v->socclk = dc->dcn_soc->socclk;
-
-	v->fabric_and_dram_bandwidth_vmin0p65 = dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65;
-	v->fabric_and_dram_bandwidth_vmid0p72 = dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72;
-	v->fabric_and_dram_bandwidth_vnom0p8 = dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8;
-	v->fabric_and_dram_bandwidth_vmax0p9 = dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9;
-
-	v->phyclkv_min0p65 = dc->dcn_soc->phyclkv_min0p65;
-	v->phyclkv_mid0p72 = dc->dcn_soc->phyclkv_mid0p72;
-	v->phyclkv_nom0p8 = dc->dcn_soc->phyclkv_nom0p8;
-	v->phyclkv_max0p9 = dc->dcn_soc->phyclkv_max0p9;
-
-	v->downspreading = dc->dcn_soc->downspreading;
-	v->round_trip_ping_latency_cycles = dc->dcn_soc->round_trip_ping_latency_cycles;
-	v->urgent_out_of_order_return_per_channel = dc->dcn_soc->urgent_out_of_order_return_per_channel;
-	v->number_of_channels = dc->dcn_soc->number_of_channels;
-	v->vmm_page_size = dc->dcn_soc->vmm_page_size;
-	v->dram_clock_change_latency = dc->dcn_soc->dram_clock_change_latency;
-	v->return_bus_width = dc->dcn_soc->return_bus_width;
-
-	v->rob_buffer_size_in_kbyte = dc->dcn_ip->rob_buffer_size_in_kbyte;
-	v->det_buffer_size_in_kbyte = dc->dcn_ip->det_buffer_size_in_kbyte;
-	v->dpp_output_buffer_pixels = dc->dcn_ip->dpp_output_buffer_pixels;
-	v->opp_output_buffer_lines = dc->dcn_ip->opp_output_buffer_lines;
-	v->pixel_chunk_size_in_kbyte = dc->dcn_ip->pixel_chunk_size_in_kbyte;
-	v->pte_enable = dc->dcn_ip->pte_enable;
-	v->pte_chunk_size = dc->dcn_ip->pte_chunk_size;
-	v->meta_chunk_size = dc->dcn_ip->meta_chunk_size;
-	v->writeback_chunk_size = dc->dcn_ip->writeback_chunk_size;
-	v->odm_capability = dc->dcn_ip->odm_capability;
-	v->dsc_capability = dc->dcn_ip->dsc_capability;
-	v->line_buffer_size = dc->dcn_ip->line_buffer_size;
-	v->is_line_buffer_bpp_fixed = dc->dcn_ip->is_line_buffer_bpp_fixed;
-	v->line_buffer_fixed_bpp = dc->dcn_ip->line_buffer_fixed_bpp;
-	v->max_line_buffer_lines = dc->dcn_ip->max_line_buffer_lines;
-	v->writeback_luma_buffer_size = dc->dcn_ip->writeback_luma_buffer_size;
-	v->writeback_chroma_buffer_size = dc->dcn_ip->writeback_chroma_buffer_size;
-	v->max_num_dpp = dc->dcn_ip->max_num_dpp;
-	v->max_num_writeback = dc->dcn_ip->max_num_writeback;
-	v->max_dchub_topscl_throughput = dc->dcn_ip->max_dchub_topscl_throughput;
-	v->max_pscl_tolb_throughput = dc->dcn_ip->max_pscl_tolb_throughput;
-	v->max_lb_tovscl_throughput = dc->dcn_ip->max_lb_tovscl_throughput;
-	v->max_vscl_tohscl_throughput = dc->dcn_ip->max_vscl_tohscl_throughput;
-	v->max_hscl_ratio = dc->dcn_ip->max_hscl_ratio;
-	v->max_vscl_ratio = dc->dcn_ip->max_vscl_ratio;
-	v->max_hscl_taps = dc->dcn_ip->max_hscl_taps;
-	v->max_vscl_taps = dc->dcn_ip->max_vscl_taps;
-	v->under_scan_factor = dc->dcn_ip->under_scan_factor;
-	v->pte_buffer_size_in_requests = dc->dcn_ip->pte_buffer_size_in_requests;
-	v->dispclk_ramping_margin = dc->dcn_ip->dispclk_ramping_margin;
-	v->max_inter_dcn_tile_repeaters = dc->dcn_ip->max_inter_dcn_tile_repeaters;
+			dc->dcn_soc.percent_of_ideal_drambw_received_after_urg_latency;
+
+	v->dcfclkv_min0p65 = dc->dcn_soc.dcfclkv_min0p65;
+	v->dcfclkv_mid0p72 = dc->dcn_soc.dcfclkv_mid0p72;
+	v->dcfclkv_nom0p8 = dc->dcn_soc.dcfclkv_nom0p8;
+	v->dcfclkv_max0p9 = dc->dcn_soc.dcfclkv_max0p9;
+
+	v->max_dispclk_vmin0p65 = dc->dcn_soc.max_dispclk_vmin0p65;
+	v->max_dispclk_vmid0p72 = dc->dcn_soc.max_dispclk_vmid0p72;
+	v->max_dispclk_vnom0p8 = dc->dcn_soc.max_dispclk_vnom0p8;
+	v->max_dispclk_vmax0p9 = dc->dcn_soc.max_dispclk_vmax0p9;
+
+	v->max_dppclk_vmin0p65 = dc->dcn_soc.max_dppclk_vmin0p65;
+	v->max_dppclk_vmid0p72 = dc->dcn_soc.max_dppclk_vmid0p72;
+	v->max_dppclk_vnom0p8 = dc->dcn_soc.max_dppclk_vnom0p8;
+	v->max_dppclk_vmax0p9 = dc->dcn_soc.max_dppclk_vmax0p9;
+
+	v->socclk = dc->dcn_soc.socclk;
+
+	v->fabric_and_dram_bandwidth_vmin0p65 = dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65;
+	v->fabric_and_dram_bandwidth_vmid0p72 = dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72;
+	v->fabric_and_dram_bandwidth_vnom0p8 = dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8;
+	v->fabric_and_dram_bandwidth_vmax0p9 = dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9;
+
+	v->phyclkv_min0p65 = dc->dcn_soc.phyclkv_min0p65;
+	v->phyclkv_mid0p72 = dc->dcn_soc.phyclkv_mid0p72;
+	v->phyclkv_nom0p8 = dc->dcn_soc.phyclkv_nom0p8;
+	v->phyclkv_max0p9 = dc->dcn_soc.phyclkv_max0p9;
+
+	v->downspreading = dc->dcn_soc.downspreading;
+	v->round_trip_ping_latency_cycles = dc->dcn_soc.round_trip_ping_latency_cycles;
+	v->urgent_out_of_order_return_per_channel = dc->dcn_soc.urgent_out_of_order_return_per_channel;
+	v->number_of_channels = dc->dcn_soc.number_of_channels;
+	v->vmm_page_size = dc->dcn_soc.vmm_page_size;
+	v->dram_clock_change_latency = dc->dcn_soc.dram_clock_change_latency;
+	v->return_bus_width = dc->dcn_soc.return_bus_width;
+
+	v->rob_buffer_size_in_kbyte = dc->dcn_ip.rob_buffer_size_in_kbyte;
+	v->det_buffer_size_in_kbyte = dc->dcn_ip.det_buffer_size_in_kbyte;
+	v->dpp_output_buffer_pixels = dc->dcn_ip.dpp_output_buffer_pixels;
+	v->opp_output_buffer_lines = dc->dcn_ip.opp_output_buffer_lines;
+	v->pixel_chunk_size_in_kbyte = dc->dcn_ip.pixel_chunk_size_in_kbyte;
+	v->pte_enable = dc->dcn_ip.pte_enable;
+	v->pte_chunk_size = dc->dcn_ip.pte_chunk_size;
+	v->meta_chunk_size = dc->dcn_ip.meta_chunk_size;
+	v->writeback_chunk_size = dc->dcn_ip.writeback_chunk_size;
+	v->odm_capability = dc->dcn_ip.odm_capability;
+	v->dsc_capability = dc->dcn_ip.dsc_capability;
+	v->line_buffer_size = dc->dcn_ip.line_buffer_size;
+	v->is_line_buffer_bpp_fixed = dc->dcn_ip.is_line_buffer_bpp_fixed;
+	v->line_buffer_fixed_bpp = dc->dcn_ip.line_buffer_fixed_bpp;
+	v->max_line_buffer_lines = dc->dcn_ip.max_line_buffer_lines;
+	v->writeback_luma_buffer_size = dc->dcn_ip.writeback_luma_buffer_size;
+	v->writeback_chroma_buffer_size = dc->dcn_ip.writeback_chroma_buffer_size;
+	v->max_num_dpp = dc->dcn_ip.max_num_dpp;
+	v->max_num_writeback = dc->dcn_ip.max_num_writeback;
+	v->max_dchub_topscl_throughput = dc->dcn_ip.max_dchub_topscl_throughput;
+	v->max_pscl_tolb_throughput = dc->dcn_ip.max_pscl_tolb_throughput;
+	v->max_lb_tovscl_throughput = dc->dcn_ip.max_lb_tovscl_throughput;
+	v->max_vscl_tohscl_throughput = dc->dcn_ip.max_vscl_tohscl_throughput;
+	v->max_hscl_ratio = dc->dcn_ip.max_hscl_ratio;
+	v->max_vscl_ratio = dc->dcn_ip.max_vscl_ratio;
+	v->max_hscl_taps = dc->dcn_ip.max_hscl_taps;
+	v->max_vscl_taps = dc->dcn_ip.max_vscl_taps;
+	v->under_scan_factor = dc->dcn_ip.under_scan_factor;
+	v->pte_buffer_size_in_requests = dc->dcn_ip.pte_buffer_size_in_requests;
+	v->dispclk_ramping_margin = dc->dcn_ip.dispclk_ramping_margin;
+	v->max_inter_dcn_tile_repeaters = dc->dcn_ip.max_inter_dcn_tile_repeaters;
 	v->can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one =
-			dc->dcn_ip->can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one;
+			dc->dcn_ip.can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one;
 	v->bug_forcing_luma_and_chroma_request_to_same_size_fixed =
-			dc->dcn_ip->bug_forcing_luma_and_chroma_request_to_same_size_fixed;
+			dc->dcn_ip.bug_forcing_luma_and_chroma_request_to_same_size_fixed;
 
 	v->voltage[5] = dcn_bw_no_support;
 	v->voltage[4] = dcn_bw_v_max0p9;
@@ -850,7 +850,7 @@ bool dcn_validate_bandwidth(
 	v->phyclk_per_state[1] = v->phyclkv_mid0p72;
 	v->phyclk_per_state[0] = v->phyclkv_min0p65;
 
-	if (dc->debug.disable_pipe_split) {
+	if (dc->public.debug.disable_pipe_split) {
 		v->max_dispclk[0] = v->max_dppclk_vmin0p65;
 	}
 
@@ -982,16 +982,17 @@ bool dcn_validate_bandwidth(
 	mode_support_and_system_configuration(v);
 
 	if (v->voltage_level == 0 &&
-			(dc->debug.sr_exit_time_dpm0_ns
-				|| dc->debug.sr_enter_plus_exit_time_dpm0_ns)) {
+			(dc->public.debug.sr_exit_time_dpm0_ns
+				|| dc->public.debug.sr_enter_plus_exit_time_dpm0_ns)) {
+		struct core_dc *dc_core = DC_TO_CORE(&dc->public);
 
-		if (dc->debug.sr_enter_plus_exit_time_dpm0_ns)
+		if (dc->public.debug.sr_enter_plus_exit_time_dpm0_ns)
 			v->sr_enter_plus_exit_time =
-				dc->debug.sr_enter_plus_exit_time_dpm0_ns / 1000.0f;
-		if (dc->debug.sr_exit_time_dpm0_ns)
-			v->sr_exit_time =  dc->debug.sr_exit_time_dpm0_ns / 1000.0f;
-		dc->dml.soc.sr_enter_plus_exit_time_us = v->sr_enter_plus_exit_time;
-		dc->dml.soc.sr_exit_time_us = v->sr_exit_time;
+				dc->public.debug.sr_enter_plus_exit_time_dpm0_ns / 1000.0f;
+		if (dc->public.debug.sr_exit_time_dpm0_ns)
+			v->sr_exit_time =  dc->public.debug.sr_exit_time_dpm0_ns / 1000.0f;
+		dc_core->dml.soc.sr_enter_plus_exit_time_us = v->sr_enter_plus_exit_time;
+		dc_core->dml.soc.sr_exit_time_us = v->sr_exit_time;
 		mode_support_and_system_configuration(v);
 	}
 
@@ -1019,8 +1020,8 @@ bool dcn_validate_bandwidth(
 		context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz = (int)(v->dcf_clk_deep_sleep * 1000);
 		context->bw.dcn.calc_clk.dcfclk_khz = (int)(v->dcfclk * 1000);
 		context->bw.dcn.calc_clk.dispclk_khz = (int)(v->dispclk * 1000);
-		if (dc->debug.max_disp_clk == true)
-			context->bw.dcn.calc_clk.dispclk_khz = (int)(dc->dcn_soc->max_dispclk_vmax0p9 * 1000);
+		if (dc->public.debug.max_disp_clk == true)
+			context->bw.dcn.calc_clk.dispclk_khz = (int)(dc->dcn_soc.max_dispclk_vmax0p9 * 1000);
 		context->bw.dcn.calc_clk.dppclk_div = (int)(v->dispclk_dppclk_ratio) == 2;
 
 		for (i = 0, input_idx = 0; i < pool->pipe_count; i++) {
@@ -1108,23 +1109,24 @@ bool dcn_validate_bandwidth(
 
 			input_idx++;
 		}
-		if (dc->debug.use_dml_wm)
+		if (dc->public.debug.use_dml_wm)
 			dcn_dml_wm_override(v, (struct display_mode_lib *)
 					&dc->dml, context, pool);
 	}
 
 	if (v->voltage_level == 0) {
+		struct core_dc *dc_core = DC_TO_CORE(&dc->public);
 
-		dc->dml.soc.sr_enter_plus_exit_time_us =
-				dc->dcn_soc->sr_enter_plus_exit_time;
-		dc->dml.soc.sr_exit_time_us = dc->dcn_soc->sr_exit_time;
+		dc_core->dml.soc.sr_enter_plus_exit_time_us =
+				dc_core->dcn_soc.sr_enter_plus_exit_time;
+		dc_core->dml.soc.sr_exit_time_us = dc_core->dcn_soc.sr_exit_time;
 	}
 
 	/*
 	 * BW limit is set to prevent display from impacting other system functions
 	 */
 
-	bw_limit = dc->dcn_soc->percent_disp_bw_limit * v->fabric_and_dram_bandwidth_vmax0p9;
+	bw_limit = dc->dcn_soc.percent_disp_bw_limit * v->fabric_and_dram_bandwidth_vmax0p9;
 	bw_limit_pass = (v->total_data_read_bandwidth / 1000.0) < bw_limit;
 
 	kernel_fpu_end();
@@ -1136,7 +1138,7 @@ bool dcn_validate_bandwidth(
 }
 
 unsigned int dcn_find_normalized_clock_vdd_Level(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	enum dm_pp_clock_type clocks_type,
 	int clocks_in_khz)
 {
@@ -1147,41 +1149,41 @@ unsigned int dcn_find_normalized_clock_vdd_Level(
 
 	switch (clocks_type) {
 	case DM_PP_CLOCK_TYPE_DISPLAY_CLK:
-		if (clocks_in_khz > dc->dcn_soc->max_dispclk_vmax0p9*1000) {
+		if (clocks_in_khz > dc->dcn_soc.max_dispclk_vmax0p9*1000) {
 			vdd_level = dcn_bw_v_max0p91;
 			BREAK_TO_DEBUGGER();
-		} else if (clocks_in_khz > dc->dcn_soc->max_dispclk_vnom0p8*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.max_dispclk_vnom0p8*1000) {
 			vdd_level = dcn_bw_v_max0p9;
-		} else if (clocks_in_khz > dc->dcn_soc->max_dispclk_vmid0p72*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.max_dispclk_vmid0p72*1000) {
 			vdd_level = dcn_bw_v_nom0p8;
-		} else if (clocks_in_khz > dc->dcn_soc->max_dispclk_vmin0p65*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.max_dispclk_vmin0p65*1000) {
 			vdd_level = dcn_bw_v_mid0p72;
 		} else
 			vdd_level = dcn_bw_v_min0p65;
 		break;
 	case DM_PP_CLOCK_TYPE_DISPLAYPHYCLK:
-		if (clocks_in_khz > dc->dcn_soc->phyclkv_max0p9*1000) {
+		if (clocks_in_khz > dc->dcn_soc.phyclkv_max0p9*1000) {
 			vdd_level = dcn_bw_v_max0p91;
 			BREAK_TO_DEBUGGER();
-		} else if (clocks_in_khz > dc->dcn_soc->phyclkv_nom0p8*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.phyclkv_nom0p8*1000) {
 			vdd_level = dcn_bw_v_max0p9;
-		} else if (clocks_in_khz > dc->dcn_soc->phyclkv_mid0p72*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.phyclkv_mid0p72*1000) {
 			vdd_level = dcn_bw_v_nom0p8;
-		} else if (clocks_in_khz > dc->dcn_soc->phyclkv_min0p65*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.phyclkv_min0p65*1000) {
 			vdd_level = dcn_bw_v_mid0p72;
 		} else
 			vdd_level = dcn_bw_v_min0p65;
 		break;
 
 	case DM_PP_CLOCK_TYPE_DPPCLK:
-		if (clocks_in_khz > dc->dcn_soc->max_dppclk_vmax0p9*1000) {
+		if (clocks_in_khz > dc->dcn_soc.max_dppclk_vmax0p9*1000) {
 			vdd_level = dcn_bw_v_max0p91;
 			BREAK_TO_DEBUGGER();
-		} else if (clocks_in_khz > dc->dcn_soc->max_dppclk_vnom0p8*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.max_dppclk_vnom0p8*1000) {
 			vdd_level = dcn_bw_v_max0p9;
-		} else if (clocks_in_khz > dc->dcn_soc->max_dppclk_vmid0p72*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.max_dppclk_vmid0p72*1000) {
 			vdd_level = dcn_bw_v_nom0p8;
-		} else if (clocks_in_khz > dc->dcn_soc->max_dppclk_vmin0p65*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.max_dppclk_vmin0p65*1000) {
 			vdd_level = dcn_bw_v_mid0p72;
 		} else
 			vdd_level = dcn_bw_v_min0p65;
@@ -1189,16 +1191,15 @@ unsigned int dcn_find_normalized_clock_vdd_Level(
 
 	case DM_PP_CLOCK_TYPE_MEMORY_CLK:
 		{
-			unsigned factor = (ddr4_dram_factor_single_Channel * dc->dcn_soc->number_of_channels);
-
-			if (clocks_in_khz > dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9*1000000/factor) {
+			unsigned factor = (ddr4_dram_factor_single_Channel * dc->dcn_soc.number_of_channels);
+			if (clocks_in_khz > dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9*1000000/factor) {
 			vdd_level = dcn_bw_v_max0p91;
 				BREAK_TO_DEBUGGER();
-			} else if (clocks_in_khz > dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8*1000000/factor) {
+			} else if (clocks_in_khz > dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8*1000000/factor) {
 				vdd_level = dcn_bw_v_max0p9;
-			} else if (clocks_in_khz > dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72*1000000/factor) {
+			} else if (clocks_in_khz > dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72*1000000/factor) {
 				vdd_level = dcn_bw_v_nom0p8;
-			} else if (clocks_in_khz > dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65*1000000/factor) {
+			} else if (clocks_in_khz > dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65*1000000/factor) {
 				vdd_level = dcn_bw_v_mid0p72;
 			} else
 				vdd_level = dcn_bw_v_min0p65;
@@ -1206,14 +1207,14 @@ unsigned int dcn_find_normalized_clock_vdd_Level(
 		break;
 
 	case DM_PP_CLOCK_TYPE_DCFCLK:
-		if (clocks_in_khz > dc->dcn_soc->dcfclkv_max0p9*1000) {
+		if (clocks_in_khz > dc->dcn_soc.dcfclkv_max0p9*1000) {
 			vdd_level = dcn_bw_v_max0p91;
 			BREAK_TO_DEBUGGER();
-		} else if (clocks_in_khz > dc->dcn_soc->dcfclkv_nom0p8*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.dcfclkv_nom0p8*1000) {
 			vdd_level = dcn_bw_v_max0p9;
-		} else if (clocks_in_khz > dc->dcn_soc->dcfclkv_mid0p72*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.dcfclkv_mid0p72*1000) {
 			vdd_level = dcn_bw_v_nom0p8;
-		} else if (clocks_in_khz > dc->dcn_soc->dcfclkv_min0p65*1000) {
+		} else if (clocks_in_khz > dc->dcn_soc.dcfclkv_min0p65*1000) {
 			vdd_level = dcn_bw_v_mid0p72;
 		} else
 			vdd_level = dcn_bw_v_min0p65;
@@ -1226,7 +1227,7 @@ unsigned int dcn_find_normalized_clock_vdd_Level(
 }
 
 unsigned int dcn_find_dcfclk_suits_all(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	struct clocks_value *clocks)
 {
 	unsigned vdd_level, vdd_level_temp;
@@ -1253,22 +1254,22 @@ unsigned int dcn_find_dcfclk_suits_all(
 	vdd_level = dcn_bw_max(vdd_level, vdd_level_temp);
 	if (vdd_level == dcn_bw_v_max0p91) {
 		BREAK_TO_DEBUGGER();
-		dcf_clk = dc->dcn_soc->dcfclkv_max0p9*1000;
+		dcf_clk = dc->dcn_soc.dcfclkv_max0p9*1000;
 	} else if (vdd_level == dcn_bw_v_max0p9)
-		dcf_clk =  dc->dcn_soc->dcfclkv_max0p9*1000;
+		dcf_clk =  dc->dcn_soc.dcfclkv_max0p9*1000;
 	else if (vdd_level == dcn_bw_v_nom0p8)
-		dcf_clk =  dc->dcn_soc->dcfclkv_nom0p8*1000;
+		dcf_clk =  dc->dcn_soc.dcfclkv_nom0p8*1000;
 	else if (vdd_level == dcn_bw_v_mid0p72)
-		dcf_clk =  dc->dcn_soc->dcfclkv_mid0p72*1000;
+		dcf_clk =  dc->dcn_soc.dcfclkv_mid0p72*1000;
 	else
-		dcf_clk =  dc->dcn_soc->dcfclkv_min0p65*1000;
+		dcf_clk =  dc->dcn_soc.dcfclkv_min0p65*1000;
 
 	dm_logger_write(dc->ctx->logger, LOG_HW_MARKS,
 		"\tdcf_clk for voltage = %d\n", dcf_clk);
 	return dcf_clk;
 }
 
-void dcn_bw_update_from_pplib(struct dc *dc)
+void dcn_bw_update_from_pplib(struct core_dc *dc)
 {
 	struct dc_context *ctx = dc->ctx;
 	struct dm_pp_clock_levels_with_voltage clks = {0};
@@ -1281,54 +1282,50 @@ void dcn_bw_update_from_pplib(struct dc *dc)
 			ctx, DM_PP_CLOCK_TYPE_FCLK, &clks) &&
 			clks.num_levels != 0) {
 		ASSERT(clks.num_levels >= 3);
-		dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 = 32 * (clks.data[0].clocks_in_khz / 1000.0) / 1000.0;
+		dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65 = 32 * (clks.data[0].clocks_in_khz / 1000.0) / 1000.0;
 		if (clks.num_levels > 2) {
-			dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 = dc->dcn_soc->number_of_channels *
+			dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72 = dc->dcn_soc.number_of_channels *
 					(clks.data[clks.num_levels - 3].clocks_in_khz / 1000.0) * ddr4_dram_factor_single_Channel / 1000.0;
 		} else {
-			dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 = dc->dcn_soc->number_of_channels *
+			dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72 = dc->dcn_soc.number_of_channels *
 					(clks.data[clks.num_levels - 2].clocks_in_khz / 1000.0) * ddr4_dram_factor_single_Channel / 1000.0;
 		}
-		dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 = dc->dcn_soc->number_of_channels *
+		dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8 = dc->dcn_soc.number_of_channels *
 				(clks.data[clks.num_levels - 2].clocks_in_khz / 1000.0) * ddr4_dram_factor_single_Channel / 1000.0;
-		dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = dc->dcn_soc->number_of_channels *
+		dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9 = dc->dcn_soc.number_of_channels *
 				(clks.data[clks.num_levels - 1].clocks_in_khz / 1000.0) * ddr4_dram_factor_single_Channel / 1000.0;
 	} else
 		BREAK_TO_DEBUGGER();
 	if (dm_pp_get_clock_levels_by_type_with_voltage(
 				ctx, DM_PP_CLOCK_TYPE_DCFCLK, &clks) &&
 				clks.num_levels >= 3) {
-		dc->dcn_soc->dcfclkv_min0p65 = clks.data[0].clocks_in_khz / 1000.0;
-		dc->dcn_soc->dcfclkv_mid0p72 = clks.data[clks.num_levels - 3].clocks_in_khz / 1000.0;
-		dc->dcn_soc->dcfclkv_nom0p8 = clks.data[clks.num_levels - 2].clocks_in_khz / 1000.0;
-		dc->dcn_soc->dcfclkv_max0p9 = clks.data[clks.num_levels - 1].clocks_in_khz / 1000.0;
+		dc->dcn_soc.dcfclkv_min0p65 = clks.data[0].clocks_in_khz / 1000.0;
+		dc->dcn_soc.dcfclkv_mid0p72 = clks.data[clks.num_levels - 3].clocks_in_khz / 1000.0;
+		dc->dcn_soc.dcfclkv_nom0p8 = clks.data[clks.num_levels - 2].clocks_in_khz / 1000.0;
+		dc->dcn_soc.dcfclkv_max0p9 = clks.data[clks.num_levels - 1].clocks_in_khz / 1000.0;
 	} else
 		BREAK_TO_DEBUGGER();
 
 	kernel_fpu_end();
 }
 
-void dcn_bw_notify_pplib_of_wm_ranges(struct dc *dc)
+void dcn_bw_notify_pplib_of_wm_ranges(struct core_dc *dc)
 {
-	struct pp_smu_funcs_rv *pp = dc->res_pool->pp_smu;
-	struct pp_smu_wm_range_sets ranges = {0};
-	int max_fclk_khz, nom_fclk_khz, mid_fclk_khz, min_fclk_khz;
-	int max_dcfclk_khz, min_dcfclk_khz;
-	int socclk_khz;
+	struct dm_pp_wm_sets_with_clock_ranges_soc15 clk_ranges = {0};
+	int max_fclk_khz, nom_fclk_khz, min_fclk_khz, max_dcfclk_khz,
+		nom_dcfclk_khz, mid_fclk_khz, min_dcfclk_khz, socclk_khz;
 	const int overdrive = 5000000; /* 5 GHz to cover Overdrive */
-	unsigned factor = (ddr4_dram_factor_single_Channel * dc->dcn_soc->number_of_channels);
-
-	if (!pp->set_wm_ranges)
-		return;
+	unsigned factor = (ddr4_dram_factor_single_Channel * dc->dcn_soc.number_of_channels);
 
 	kernel_fpu_begin();
-	max_fclk_khz = dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 * 1000000 / factor;
-	nom_fclk_khz = dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 * 1000000 / factor;
-	mid_fclk_khz = dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 * 1000000 / factor;
-	min_fclk_khz = dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 * 1000000 / 32;
-	max_dcfclk_khz = dc->dcn_soc->dcfclkv_max0p9 * 1000;
-	min_dcfclk_khz = dc->dcn_soc->dcfclkv_min0p65 * 1000;
-	socclk_khz = dc->dcn_soc->socclk * 1000;
+	max_fclk_khz = dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9 * 1000000 / factor;
+	nom_fclk_khz = dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8 * 1000000 / factor;
+	mid_fclk_khz = dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72 * 1000000 / factor;
+	min_fclk_khz = dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65 * 1000000 / 32;
+	max_dcfclk_khz = dc->dcn_soc.dcfclkv_max0p9 * 1000;
+	nom_dcfclk_khz = dc->dcn_soc.dcfclkv_nom0p8 * 1000;
+	min_dcfclk_khz = dc->dcn_soc.dcfclkv_min0p65 * 1000;
+	socclk_khz = dc->dcn_soc.socclk * 1000;
 	kernel_fpu_end();
 
 	/* Now notify PPLib/SMU about which Watermarks sets they should select
@@ -1339,58 +1336,58 @@ void dcn_bw_notify_pplib_of_wm_ranges(struct dc *dc)
 	/* SOCCLK does not affect anytihng but writeback for DCN so for now we dont
 	 * care what the value is, hence min to overdrive level
 	 */
-	ranges.num_reader_wm_sets = WM_COUNT;
-	ranges.num_writer_wm_sets = WM_COUNT;
-	ranges.reader_wm_sets[0].wm_inst = WM_A;
-	ranges.reader_wm_sets[0].min_drain_clk_khz = min_dcfclk_khz;
-	ranges.reader_wm_sets[0].max_drain_clk_khz = max_dcfclk_khz;
-	ranges.reader_wm_sets[0].min_fill_clk_khz = min_fclk_khz;
-	ranges.reader_wm_sets[0].max_fill_clk_khz = min_fclk_khz;
-	ranges.writer_wm_sets[0].wm_inst = WM_A;
-	ranges.writer_wm_sets[0].min_fill_clk_khz = socclk_khz;
-	ranges.writer_wm_sets[0].max_fill_clk_khz = overdrive;
-	ranges.writer_wm_sets[0].min_drain_clk_khz = min_fclk_khz;
-	ranges.writer_wm_sets[0].max_drain_clk_khz = min_fclk_khz;
-
-	ranges.reader_wm_sets[1].wm_inst = WM_B;
-	ranges.reader_wm_sets[1].min_drain_clk_khz = min_fclk_khz;
-	ranges.reader_wm_sets[1].max_drain_clk_khz = max_dcfclk_khz;
-	ranges.reader_wm_sets[1].min_fill_clk_khz = mid_fclk_khz;
-	ranges.reader_wm_sets[1].max_fill_clk_khz = mid_fclk_khz;
-	ranges.writer_wm_sets[1].wm_inst = WM_B;
-	ranges.writer_wm_sets[1].min_fill_clk_khz = socclk_khz;
-	ranges.writer_wm_sets[1].max_fill_clk_khz = overdrive;
-	ranges.writer_wm_sets[1].min_drain_clk_khz = mid_fclk_khz;
-	ranges.writer_wm_sets[1].max_drain_clk_khz = mid_fclk_khz;
-
-
-	ranges.reader_wm_sets[2].wm_inst = WM_C;
-	ranges.reader_wm_sets[2].min_drain_clk_khz = min_fclk_khz;
-	ranges.reader_wm_sets[2].max_drain_clk_khz = max_dcfclk_khz;
-	ranges.reader_wm_sets[2].min_fill_clk_khz = nom_fclk_khz;
-	ranges.reader_wm_sets[2].max_fill_clk_khz = nom_fclk_khz;
-	ranges.writer_wm_sets[2].wm_inst = WM_C;
-	ranges.writer_wm_sets[2].min_fill_clk_khz = socclk_khz;
-	ranges.writer_wm_sets[2].max_fill_clk_khz = overdrive;
-	ranges.writer_wm_sets[2].min_drain_clk_khz = nom_fclk_khz;
-	ranges.writer_wm_sets[2].max_drain_clk_khz = nom_fclk_khz;
-
-	ranges.reader_wm_sets[3].wm_inst = WM_D;
-	ranges.reader_wm_sets[3].min_drain_clk_khz = min_fclk_khz;
-	ranges.reader_wm_sets[3].max_drain_clk_khz = max_dcfclk_khz;
-	ranges.reader_wm_sets[3].min_fill_clk_khz = max_fclk_khz;
-	ranges.reader_wm_sets[3].max_fill_clk_khz = max_fclk_khz;
-	ranges.writer_wm_sets[3].wm_inst = WM_D;
-	ranges.writer_wm_sets[3].min_fill_clk_khz = socclk_khz;
-	ranges.writer_wm_sets[3].max_fill_clk_khz = overdrive;
-	ranges.writer_wm_sets[3].min_drain_clk_khz = max_fclk_khz;
-	ranges.writer_wm_sets[3].max_drain_clk_khz = max_fclk_khz;
+	clk_ranges.num_wm_dmif_sets = 4;
+	clk_ranges.num_wm_mcif_sets = 4;
+	clk_ranges.wm_dmif_clocks_ranges[0].wm_set_id = WM_SET_A;
+	clk_ranges.wm_dmif_clocks_ranges[0].wm_min_dcfclk_clk_in_khz = min_dcfclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[0].wm_max_dcfclk_clk_in_khz = max_dcfclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[0].wm_min_memg_clk_in_khz = min_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[0].wm_max_mem_clk_in_khz = min_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[0].wm_set_id = WM_SET_A;
+	clk_ranges.wm_mcif_clocks_ranges[0].wm_min_socclk_clk_in_khz = socclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[0].wm_max_socclk_clk_in_khz = overdrive;
+	clk_ranges.wm_mcif_clocks_ranges[0].wm_min_memg_clk_in_khz = min_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[0].wm_max_mem_clk_in_khz = min_fclk_khz;
+
+	clk_ranges.wm_dmif_clocks_ranges[1].wm_set_id = WM_SET_B;
+	clk_ranges.wm_dmif_clocks_ranges[1].wm_min_dcfclk_clk_in_khz = min_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[1].wm_max_dcfclk_clk_in_khz = max_dcfclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[1].wm_min_memg_clk_in_khz = mid_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[1].wm_max_mem_clk_in_khz = mid_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[1].wm_set_id = WM_SET_B;
+	clk_ranges.wm_mcif_clocks_ranges[1].wm_min_socclk_clk_in_khz = socclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[1].wm_max_socclk_clk_in_khz = overdrive;
+	clk_ranges.wm_mcif_clocks_ranges[1].wm_min_memg_clk_in_khz = mid_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[1].wm_max_mem_clk_in_khz = mid_fclk_khz;
+
+
+	clk_ranges.wm_dmif_clocks_ranges[2].wm_set_id = WM_SET_C;
+	clk_ranges.wm_dmif_clocks_ranges[2].wm_min_dcfclk_clk_in_khz = min_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[2].wm_max_dcfclk_clk_in_khz = max_dcfclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[2].wm_min_memg_clk_in_khz = nom_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[2].wm_max_mem_clk_in_khz = nom_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[2].wm_set_id = WM_SET_C;
+	clk_ranges.wm_mcif_clocks_ranges[2].wm_min_socclk_clk_in_khz = socclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[2].wm_max_socclk_clk_in_khz = overdrive;
+	clk_ranges.wm_mcif_clocks_ranges[2].wm_min_memg_clk_in_khz = nom_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[2].wm_max_mem_clk_in_khz = nom_fclk_khz;
+
+	clk_ranges.wm_dmif_clocks_ranges[3].wm_set_id = WM_SET_D;
+	clk_ranges.wm_dmif_clocks_ranges[3].wm_min_dcfclk_clk_in_khz = min_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[3].wm_max_dcfclk_clk_in_khz = max_dcfclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[3].wm_min_memg_clk_in_khz = max_fclk_khz;
+	clk_ranges.wm_dmif_clocks_ranges[3].wm_max_mem_clk_in_khz = max_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[3].wm_set_id = WM_SET_D;
+	clk_ranges.wm_mcif_clocks_ranges[3].wm_min_socclk_clk_in_khz = socclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[3].wm_max_socclk_clk_in_khz = overdrive;
+	clk_ranges.wm_mcif_clocks_ranges[3].wm_min_memg_clk_in_khz = max_fclk_khz;
+	clk_ranges.wm_mcif_clocks_ranges[3].wm_max_mem_clk_in_khz = max_fclk_khz;
 
 	/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */
-	pp->set_wm_ranges(&pp->pp_smu, &ranges);
+	dm_pp_notify_wm_clock_changes_soc15(dc->ctx, &clk_ranges);
 }
 
-void dcn_bw_sync_calcs_and_dml(struct dc *dc)
+void dcn_bw_sync_calcs_and_dml(struct core_dc *dc)
 {
 	kernel_fpu_begin();
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
@@ -1428,40 +1425,40 @@ void dcn_bw_sync_calcs_and_dml(struct dc *dc)
 			"vmm_page_size: %d Bytes\n"
 			"dram_clock_change_latency: %d ns\n"
 			"return_bus_width: %d Bytes\n",
-			dc->dcn_soc->sr_exit_time * 1000,
-			dc->dcn_soc->sr_enter_plus_exit_time * 1000,
-			dc->dcn_soc->urgent_latency * 1000,
-			dc->dcn_soc->write_back_latency * 1000,
-			dc->dcn_soc->percent_of_ideal_drambw_received_after_urg_latency,
-			dc->dcn_soc->max_request_size,
-			dc->dcn_soc->dcfclkv_max0p9 * 1000,
-			dc->dcn_soc->dcfclkv_nom0p8 * 1000,
-			dc->dcn_soc->dcfclkv_mid0p72 * 1000,
-			dc->dcn_soc->dcfclkv_min0p65 * 1000,
-			dc->dcn_soc->max_dispclk_vmax0p9 * 1000,
-			dc->dcn_soc->max_dispclk_vnom0p8 * 1000,
-			dc->dcn_soc->max_dispclk_vmid0p72 * 1000,
-			dc->dcn_soc->max_dispclk_vmin0p65 * 1000,
-			dc->dcn_soc->max_dppclk_vmax0p9 * 1000,
-			dc->dcn_soc->max_dppclk_vnom0p8 * 1000,
-			dc->dcn_soc->max_dppclk_vmid0p72 * 1000,
-			dc->dcn_soc->max_dppclk_vmin0p65 * 1000,
-			dc->dcn_soc->socclk * 1000,
-			dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 * 1000,
-			dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 * 1000,
-			dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 * 1000,
-			dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 * 1000,
-			dc->dcn_soc->phyclkv_max0p9 * 1000,
-			dc->dcn_soc->phyclkv_nom0p8 * 1000,
-			dc->dcn_soc->phyclkv_mid0p72 * 1000,
-			dc->dcn_soc->phyclkv_min0p65 * 1000,
-			dc->dcn_soc->downspreading * 100,
-			dc->dcn_soc->round_trip_ping_latency_cycles,
-			dc->dcn_soc->urgent_out_of_order_return_per_channel,
-			dc->dcn_soc->number_of_channels,
-			dc->dcn_soc->vmm_page_size,
-			dc->dcn_soc->dram_clock_change_latency * 1000,
-			dc->dcn_soc->return_bus_width);
+			dc->dcn_soc.sr_exit_time * 1000,
+			dc->dcn_soc.sr_enter_plus_exit_time * 1000,
+			dc->dcn_soc.urgent_latency * 1000,
+			dc->dcn_soc.write_back_latency * 1000,
+			dc->dcn_soc.percent_of_ideal_drambw_received_after_urg_latency,
+			dc->dcn_soc.max_request_size,
+			dc->dcn_soc.dcfclkv_max0p9 * 1000,
+			dc->dcn_soc.dcfclkv_nom0p8 * 1000,
+			dc->dcn_soc.dcfclkv_mid0p72 * 1000,
+			dc->dcn_soc.dcfclkv_min0p65 * 1000,
+			dc->dcn_soc.max_dispclk_vmax0p9 * 1000,
+			dc->dcn_soc.max_dispclk_vnom0p8 * 1000,
+			dc->dcn_soc.max_dispclk_vmid0p72 * 1000,
+			dc->dcn_soc.max_dispclk_vmin0p65 * 1000,
+			dc->dcn_soc.max_dppclk_vmax0p9 * 1000,
+			dc->dcn_soc.max_dppclk_vnom0p8 * 1000,
+			dc->dcn_soc.max_dppclk_vmid0p72 * 1000,
+			dc->dcn_soc.max_dppclk_vmin0p65 * 1000,
+			dc->dcn_soc.socclk * 1000,
+			dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9 * 1000,
+			dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8 * 1000,
+			dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72 * 1000,
+			dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65 * 1000,
+			dc->dcn_soc.phyclkv_max0p9 * 1000,
+			dc->dcn_soc.phyclkv_nom0p8 * 1000,
+			dc->dcn_soc.phyclkv_mid0p72 * 1000,
+			dc->dcn_soc.phyclkv_min0p65 * 1000,
+			dc->dcn_soc.downspreading * 100,
+			dc->dcn_soc.round_trip_ping_latency_cycles,
+			dc->dcn_soc.urgent_out_of_order_return_per_channel,
+			dc->dcn_soc.number_of_channels,
+			dc->dcn_soc.vmm_page_size,
+			dc->dcn_soc.dram_clock_change_latency * 1000,
+			dc->dcn_soc.return_bus_width);
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
 			"rob_buffer_size_in_kbyte: %d\n"
 			"det_buffer_size_in_kbyte: %d\n"
@@ -1497,120 +1494,120 @@ void dcn_bw_sync_calcs_and_dml(struct dc *dc)
 			"can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one: %d\n"
 			"bug_forcing_luma_and_chroma_request_to_same_size_fixed: %d\n"
 			"dcfclk_cstate_latency: %d\n",
-			dc->dcn_ip->rob_buffer_size_in_kbyte,
-			dc->dcn_ip->det_buffer_size_in_kbyte,
-			dc->dcn_ip->dpp_output_buffer_pixels,
-			dc->dcn_ip->opp_output_buffer_lines,
-			dc->dcn_ip->pixel_chunk_size_in_kbyte,
-			dc->dcn_ip->pte_enable,
-			dc->dcn_ip->pte_chunk_size,
-			dc->dcn_ip->meta_chunk_size,
-			dc->dcn_ip->writeback_chunk_size,
-			dc->dcn_ip->odm_capability,
-			dc->dcn_ip->dsc_capability,
-			dc->dcn_ip->line_buffer_size,
-			dc->dcn_ip->max_line_buffer_lines,
-			dc->dcn_ip->is_line_buffer_bpp_fixed,
-			dc->dcn_ip->line_buffer_fixed_bpp,
-			dc->dcn_ip->writeback_luma_buffer_size,
-			dc->dcn_ip->writeback_chroma_buffer_size,
-			dc->dcn_ip->max_num_dpp,
-			dc->dcn_ip->max_num_writeback,
-			dc->dcn_ip->max_dchub_topscl_throughput,
-			dc->dcn_ip->max_pscl_tolb_throughput,
-			dc->dcn_ip->max_lb_tovscl_throughput,
-			dc->dcn_ip->max_vscl_tohscl_throughput,
-			dc->dcn_ip->max_hscl_ratio,
-			dc->dcn_ip->max_vscl_ratio,
-			dc->dcn_ip->max_hscl_taps,
-			dc->dcn_ip->max_vscl_taps,
-			dc->dcn_ip->pte_buffer_size_in_requests,
-			dc->dcn_ip->dispclk_ramping_margin,
-			dc->dcn_ip->under_scan_factor * 100,
-			dc->dcn_ip->max_inter_dcn_tile_repeaters,
-			dc->dcn_ip->can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one,
-			dc->dcn_ip->bug_forcing_luma_and_chroma_request_to_same_size_fixed,
-			dc->dcn_ip->dcfclk_cstate_latency);
-	dc->dml.soc.vmin.socclk_mhz = dc->dcn_soc->socclk;
-	dc->dml.soc.vmid.socclk_mhz = dc->dcn_soc->socclk;
-	dc->dml.soc.vnom.socclk_mhz = dc->dcn_soc->socclk;
-	dc->dml.soc.vmax.socclk_mhz = dc->dcn_soc->socclk;
-
-	dc->dml.soc.vmin.dcfclk_mhz = dc->dcn_soc->dcfclkv_min0p65;
-	dc->dml.soc.vmid.dcfclk_mhz = dc->dcn_soc->dcfclkv_mid0p72;
-	dc->dml.soc.vnom.dcfclk_mhz = dc->dcn_soc->dcfclkv_nom0p8;
-	dc->dml.soc.vmax.dcfclk_mhz = dc->dcn_soc->dcfclkv_max0p9;
-
-	dc->dml.soc.vmin.dispclk_mhz = dc->dcn_soc->max_dispclk_vmin0p65;
-	dc->dml.soc.vmid.dispclk_mhz = dc->dcn_soc->max_dispclk_vmid0p72;
-	dc->dml.soc.vnom.dispclk_mhz = dc->dcn_soc->max_dispclk_vnom0p8;
-	dc->dml.soc.vmax.dispclk_mhz = dc->dcn_soc->max_dispclk_vmax0p9;
-
-	dc->dml.soc.vmin.dppclk_mhz = dc->dcn_soc->max_dppclk_vmin0p65;
-	dc->dml.soc.vmid.dppclk_mhz = dc->dcn_soc->max_dppclk_vmid0p72;
-	dc->dml.soc.vnom.dppclk_mhz = dc->dcn_soc->max_dppclk_vnom0p8;
-	dc->dml.soc.vmax.dppclk_mhz = dc->dcn_soc->max_dppclk_vmax0p9;
-
-	dc->dml.soc.vmin.phyclk_mhz = dc->dcn_soc->phyclkv_min0p65;
-	dc->dml.soc.vmid.phyclk_mhz = dc->dcn_soc->phyclkv_mid0p72;
-	dc->dml.soc.vnom.phyclk_mhz = dc->dcn_soc->phyclkv_nom0p8;
-	dc->dml.soc.vmax.phyclk_mhz = dc->dcn_soc->phyclkv_max0p9;
-
-	dc->dml.soc.vmin.dram_bw_per_chan_gbps = dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65;
-	dc->dml.soc.vmid.dram_bw_per_chan_gbps = dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72;
-	dc->dml.soc.vnom.dram_bw_per_chan_gbps = dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8;
-	dc->dml.soc.vmax.dram_bw_per_chan_gbps = dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9;
-
-	dc->dml.soc.sr_exit_time_us = dc->dcn_soc->sr_exit_time;
-	dc->dml.soc.sr_enter_plus_exit_time_us = dc->dcn_soc->sr_enter_plus_exit_time;
-	dc->dml.soc.urgent_latency_us = dc->dcn_soc->urgent_latency;
-	dc->dml.soc.writeback_latency_us = dc->dcn_soc->write_back_latency;
+			dc->dcn_ip.rob_buffer_size_in_kbyte,
+			dc->dcn_ip.det_buffer_size_in_kbyte,
+			dc->dcn_ip.dpp_output_buffer_pixels,
+			dc->dcn_ip.opp_output_buffer_lines,
+			dc->dcn_ip.pixel_chunk_size_in_kbyte,
+			dc->dcn_ip.pte_enable,
+			dc->dcn_ip.pte_chunk_size,
+			dc->dcn_ip.meta_chunk_size,
+			dc->dcn_ip.writeback_chunk_size,
+			dc->dcn_ip.odm_capability,
+			dc->dcn_ip.dsc_capability,
+			dc->dcn_ip.line_buffer_size,
+			dc->dcn_ip.max_line_buffer_lines,
+			dc->dcn_ip.is_line_buffer_bpp_fixed,
+			dc->dcn_ip.line_buffer_fixed_bpp,
+			dc->dcn_ip.writeback_luma_buffer_size,
+			dc->dcn_ip.writeback_chroma_buffer_size,
+			dc->dcn_ip.max_num_dpp,
+			dc->dcn_ip.max_num_writeback,
+			dc->dcn_ip.max_dchub_topscl_throughput,
+			dc->dcn_ip.max_pscl_tolb_throughput,
+			dc->dcn_ip.max_lb_tovscl_throughput,
+			dc->dcn_ip.max_vscl_tohscl_throughput,
+			dc->dcn_ip.max_hscl_ratio,
+			dc->dcn_ip.max_vscl_ratio,
+			dc->dcn_ip.max_hscl_taps,
+			dc->dcn_ip.max_vscl_taps,
+			dc->dcn_ip.pte_buffer_size_in_requests,
+			dc->dcn_ip.dispclk_ramping_margin,
+			dc->dcn_ip.under_scan_factor * 100,
+			dc->dcn_ip.max_inter_dcn_tile_repeaters,
+			dc->dcn_ip.can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one,
+			dc->dcn_ip.bug_forcing_luma_and_chroma_request_to_same_size_fixed,
+			dc->dcn_ip.dcfclk_cstate_latency);
+	dc->dml.soc.vmin.socclk_mhz = dc->dcn_soc.socclk;
+	dc->dml.soc.vmid.socclk_mhz = dc->dcn_soc.socclk;
+	dc->dml.soc.vnom.socclk_mhz = dc->dcn_soc.socclk;
+	dc->dml.soc.vmax.socclk_mhz = dc->dcn_soc.socclk;
+
+	dc->dml.soc.vmin.dcfclk_mhz = dc->dcn_soc.dcfclkv_min0p65;
+	dc->dml.soc.vmid.dcfclk_mhz = dc->dcn_soc.dcfclkv_mid0p72;
+	dc->dml.soc.vnom.dcfclk_mhz = dc->dcn_soc.dcfclkv_nom0p8;
+	dc->dml.soc.vmax.dcfclk_mhz = dc->dcn_soc.dcfclkv_max0p9;
+
+	dc->dml.soc.vmin.dispclk_mhz = dc->dcn_soc.max_dispclk_vmin0p65;
+	dc->dml.soc.vmid.dispclk_mhz = dc->dcn_soc.max_dispclk_vmid0p72;
+	dc->dml.soc.vnom.dispclk_mhz = dc->dcn_soc.max_dispclk_vnom0p8;
+	dc->dml.soc.vmax.dispclk_mhz = dc->dcn_soc.max_dispclk_vmax0p9;
+
+	dc->dml.soc.vmin.dppclk_mhz = dc->dcn_soc.max_dppclk_vmin0p65;
+	dc->dml.soc.vmid.dppclk_mhz = dc->dcn_soc.max_dppclk_vmid0p72;
+	dc->dml.soc.vnom.dppclk_mhz = dc->dcn_soc.max_dppclk_vnom0p8;
+	dc->dml.soc.vmax.dppclk_mhz = dc->dcn_soc.max_dppclk_vmax0p9;
+
+	dc->dml.soc.vmin.phyclk_mhz = dc->dcn_soc.phyclkv_min0p65;
+	dc->dml.soc.vmid.phyclk_mhz = dc->dcn_soc.phyclkv_mid0p72;
+	dc->dml.soc.vnom.phyclk_mhz = dc->dcn_soc.phyclkv_nom0p8;
+	dc->dml.soc.vmax.phyclk_mhz = dc->dcn_soc.phyclkv_max0p9;
+
+	dc->dml.soc.vmin.dram_bw_per_chan_gbps = dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65;
+	dc->dml.soc.vmid.dram_bw_per_chan_gbps = dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72;
+	dc->dml.soc.vnom.dram_bw_per_chan_gbps = dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8;
+	dc->dml.soc.vmax.dram_bw_per_chan_gbps = dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9;
+
+	dc->dml.soc.sr_exit_time_us = dc->dcn_soc.sr_exit_time;
+	dc->dml.soc.sr_enter_plus_exit_time_us = dc->dcn_soc.sr_enter_plus_exit_time;
+	dc->dml.soc.urgent_latency_us = dc->dcn_soc.urgent_latency;
+	dc->dml.soc.writeback_latency_us = dc->dcn_soc.write_back_latency;
 	dc->dml.soc.ideal_dram_bw_after_urgent_percent =
-			dc->dcn_soc->percent_of_ideal_drambw_received_after_urg_latency;
-	dc->dml.soc.max_request_size_bytes = dc->dcn_soc->max_request_size;
-	dc->dml.soc.downspread_percent = dc->dcn_soc->downspreading;
+			dc->dcn_soc.percent_of_ideal_drambw_received_after_urg_latency;
+	dc->dml.soc.max_request_size_bytes = dc->dcn_soc.max_request_size;
+	dc->dml.soc.downspread_percent = dc->dcn_soc.downspreading;
 	dc->dml.soc.round_trip_ping_latency_dcfclk_cycles =
-			dc->dcn_soc->round_trip_ping_latency_cycles;
+			dc->dcn_soc.round_trip_ping_latency_cycles;
 	dc->dml.soc.urgent_out_of_order_return_per_channel_bytes =
-			dc->dcn_soc->urgent_out_of_order_return_per_channel;
-	dc->dml.soc.num_chans = dc->dcn_soc->number_of_channels;
-	dc->dml.soc.vmm_page_size_bytes = dc->dcn_soc->vmm_page_size;
-	dc->dml.soc.dram_clock_change_latency_us = dc->dcn_soc->dram_clock_change_latency;
-	dc->dml.soc.return_bus_width_bytes = dc->dcn_soc->return_bus_width;
-
-	dc->dml.ip.rob_buffer_size_kbytes = dc->dcn_ip->rob_buffer_size_in_kbyte;
-	dc->dml.ip.det_buffer_size_kbytes = dc->dcn_ip->det_buffer_size_in_kbyte;
-	dc->dml.ip.dpp_output_buffer_pixels = dc->dcn_ip->dpp_output_buffer_pixels;
-	dc->dml.ip.opp_output_buffer_lines = dc->dcn_ip->opp_output_buffer_lines;
-	dc->dml.ip.pixel_chunk_size_kbytes = dc->dcn_ip->pixel_chunk_size_in_kbyte;
-	dc->dml.ip.pte_enable = dc->dcn_ip->pte_enable == dcn_bw_yes;
-	dc->dml.ip.pte_chunk_size_kbytes = dc->dcn_ip->pte_chunk_size;
-	dc->dml.ip.meta_chunk_size_kbytes = dc->dcn_ip->meta_chunk_size;
-	dc->dml.ip.writeback_chunk_size_kbytes = dc->dcn_ip->writeback_chunk_size;
-	dc->dml.ip.line_buffer_size_bits = dc->dcn_ip->line_buffer_size;
-	dc->dml.ip.max_line_buffer_lines = dc->dcn_ip->max_line_buffer_lines;
-	dc->dml.ip.IsLineBufferBppFixed = dc->dcn_ip->is_line_buffer_bpp_fixed == dcn_bw_yes;
-	dc->dml.ip.LineBufferFixedBpp = dc->dcn_ip->line_buffer_fixed_bpp;
-	dc->dml.ip.writeback_luma_buffer_size_kbytes = dc->dcn_ip->writeback_luma_buffer_size;
-	dc->dml.ip.writeback_chroma_buffer_size_kbytes = dc->dcn_ip->writeback_chroma_buffer_size;
-	dc->dml.ip.max_num_dpp = dc->dcn_ip->max_num_dpp;
-	dc->dml.ip.max_num_wb = dc->dcn_ip->max_num_writeback;
-	dc->dml.ip.max_dchub_pscl_bw_pix_per_clk = dc->dcn_ip->max_dchub_topscl_throughput;
-	dc->dml.ip.max_pscl_lb_bw_pix_per_clk = dc->dcn_ip->max_pscl_tolb_throughput;
-	dc->dml.ip.max_lb_vscl_bw_pix_per_clk = dc->dcn_ip->max_lb_tovscl_throughput;
-	dc->dml.ip.max_vscl_hscl_bw_pix_per_clk = dc->dcn_ip->max_vscl_tohscl_throughput;
-	dc->dml.ip.max_hscl_ratio = dc->dcn_ip->max_hscl_ratio;
-	dc->dml.ip.max_vscl_ratio = dc->dcn_ip->max_vscl_ratio;
-	dc->dml.ip.max_hscl_taps = dc->dcn_ip->max_hscl_taps;
-	dc->dml.ip.max_vscl_taps = dc->dcn_ip->max_vscl_taps;
+			dc->dcn_soc.urgent_out_of_order_return_per_channel;
+	dc->dml.soc.num_chans = dc->dcn_soc.number_of_channels;
+	dc->dml.soc.vmm_page_size_bytes = dc->dcn_soc.vmm_page_size;
+	dc->dml.soc.dram_clock_change_latency_us = dc->dcn_soc.dram_clock_change_latency;
+	dc->dml.soc.return_bus_width_bytes = dc->dcn_soc.return_bus_width;
+
+	dc->dml.ip.rob_buffer_size_kbytes = dc->dcn_ip.rob_buffer_size_in_kbyte;
+	dc->dml.ip.det_buffer_size_kbytes = dc->dcn_ip.det_buffer_size_in_kbyte;
+	dc->dml.ip.dpp_output_buffer_pixels = dc->dcn_ip.dpp_output_buffer_pixels;
+	dc->dml.ip.opp_output_buffer_lines = dc->dcn_ip.opp_output_buffer_lines;
+	dc->dml.ip.pixel_chunk_size_kbytes = dc->dcn_ip.pixel_chunk_size_in_kbyte;
+	dc->dml.ip.pte_enable = dc->dcn_ip.pte_enable == dcn_bw_yes;
+	dc->dml.ip.pte_chunk_size_kbytes = dc->dcn_ip.pte_chunk_size;
+	dc->dml.ip.meta_chunk_size_kbytes = dc->dcn_ip.meta_chunk_size;
+	dc->dml.ip.writeback_chunk_size_kbytes = dc->dcn_ip.writeback_chunk_size;
+	dc->dml.ip.line_buffer_size_bits = dc->dcn_ip.line_buffer_size;
+	dc->dml.ip.max_line_buffer_lines = dc->dcn_ip.max_line_buffer_lines;
+	dc->dml.ip.IsLineBufferBppFixed = dc->dcn_ip.is_line_buffer_bpp_fixed == dcn_bw_yes;
+	dc->dml.ip.LineBufferFixedBpp = dc->dcn_ip.line_buffer_fixed_bpp;
+	dc->dml.ip.writeback_luma_buffer_size_kbytes = dc->dcn_ip.writeback_luma_buffer_size;
+	dc->dml.ip.writeback_chroma_buffer_size_kbytes = dc->dcn_ip.writeback_chroma_buffer_size;
+	dc->dml.ip.max_num_dpp = dc->dcn_ip.max_num_dpp;
+	dc->dml.ip.max_num_wb = dc->dcn_ip.max_num_writeback;
+	dc->dml.ip.max_dchub_pscl_bw_pix_per_clk = dc->dcn_ip.max_dchub_topscl_throughput;
+	dc->dml.ip.max_pscl_lb_bw_pix_per_clk = dc->dcn_ip.max_pscl_tolb_throughput;
+	dc->dml.ip.max_lb_vscl_bw_pix_per_clk = dc->dcn_ip.max_lb_tovscl_throughput;
+	dc->dml.ip.max_vscl_hscl_bw_pix_per_clk = dc->dcn_ip.max_vscl_tohscl_throughput;
+	dc->dml.ip.max_hscl_ratio = dc->dcn_ip.max_hscl_ratio;
+	dc->dml.ip.max_vscl_ratio = dc->dcn_ip.max_vscl_ratio;
+	dc->dml.ip.max_hscl_taps = dc->dcn_ip.max_hscl_taps;
+	dc->dml.ip.max_vscl_taps = dc->dcn_ip.max_vscl_taps;
 	/*pte_buffer_size_in_requests missing in dml*/
-	dc->dml.ip.dispclk_ramp_margin_percent = dc->dcn_ip->dispclk_ramping_margin;
-	dc->dml.ip.underscan_factor = dc->dcn_ip->under_scan_factor;
-	dc->dml.ip.max_inter_dcn_tile_repeaters = dc->dcn_ip->max_inter_dcn_tile_repeaters;
+	dc->dml.ip.dispclk_ramp_margin_percent = dc->dcn_ip.dispclk_ramping_margin;
+	dc->dml.ip.underscan_factor = dc->dcn_ip.under_scan_factor;
+	dc->dml.ip.max_inter_dcn_tile_repeaters = dc->dcn_ip.max_inter_dcn_tile_repeaters;
 	dc->dml.ip.can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one =
-		dc->dcn_ip->can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one == dcn_bw_yes;
+		dc->dcn_ip.can_vstartup_lines_exceed_vsync_plus_back_porch_lines_minus_one == dcn_bw_yes;
 	dc->dml.ip.bug_forcing_LC_req_same_size_fixed =
-		dc->dcn_ip->bug_forcing_luma_and_chroma_request_to_same_size_fixed == dcn_bw_yes;
-	dc->dml.ip.dcfclk_cstate_latency = dc->dcn_ip->dcfclk_cstate_latency;
+		dc->dcn_ip.bug_forcing_luma_and_chroma_request_to_same_size_fixed == dcn_bw_yes;
+	dc->dml.ip.dcfclk_cstate_latency = dc->dcn_ip.dcfclk_cstate_latency;
 	kernel_fpu_end();
 }
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8864660..a1d2a40 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -35,6 +35,7 @@
 #include "clock_source.h"
 #include "dc_bios_types.h"
 
+#include "dce_calcs.h"
 #include "bios_parser_interface.h"
 #include "include/irq_service_interface.h"
 #include "transform.h"
@@ -48,13 +49,10 @@
 #include "dm_helpers.h"
 #include "mem_input.h"
 
-
-char dc_ver[] = DC_VER;
-
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static void destroy_links(struct dc *dc)
+static void destroy_links(struct core_dc *dc)
 {
 	uint32_t i;
 
@@ -65,7 +63,7 @@ static void destroy_links(struct dc *dc)
 }
 
 static bool create_links(
-		struct dc *dc,
+		struct core_dc *dc,
 		uint32_t num_virtual_links)
 {
 	int i;
@@ -155,19 +153,20 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		struct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
-			dc->hwss.set_drr(&pipe, 1, vmin, vmax);
+			core_dc->hwss.set_drr(&pipe, 1, vmin, vmax);
 
 			/* build and update the info frame */
 			resource_build_info_frame(pipe);
-			dc->hwss.update_info_frame(pipe);
+			core_dc->hwss.update_info_frame(pipe);
 
 			ret = true;
 		}
@@ -180,6 +179,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
@@ -187,10 +187,10 @@ static bool stream_get_crtc_position(struct dc *dc,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe =
-				&dc->current_state->res_ctx.pipe_ctx[i];
+				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
-			dc->hwss.get_position(&pipe, 1, &position);
+			core_dc->hwss.get_position(&pipe, 1, &position);
 
 			*v_pos = position.vertical_count;
 			*nom_v_pos = position.nominal_vcount;
@@ -202,14 +202,15 @@ static bool stream_get_crtc_position(struct dc *dc,
 
 static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {
-			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
-			dc->hwss.program_gamut_remap(pipes);
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == stream) {
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.program_gamut_remap(pipes);
 			ret = true;
 		}
 	}
@@ -219,16 +220,17 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 
 static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_state->res_ctx.pipe_ctx[i].stream
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
 				== stream) {
 
-			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
-			dc->hwss.program_csc_matrix(pipes,
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.program_csc_matrix(pipes,
 			stream->output_color_space,
 			stream->csc_color_matrix.matrix);
 			ret = true;
@@ -243,6 +245,7 @@ static void set_static_screen_events(struct dc *dc,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
 	int j = 0;
 	struct pipe_ctx *pipes_affected[MAX_PIPES];
@@ -252,44 +255,45 @@ static void set_static_screen_events(struct dc *dc,
 		struct dc_stream_state *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
-			if (dc->current_state->res_ctx.pipe_ctx[j].stream
+			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
 					== stream) {
 				pipes_affected[num_pipes_affected++] =
-						&dc->current_state->res_ctx.pipe_ctx[j];
+						&core_dc->current_context->res_ctx.pipe_ctx[j];
 			}
 		}
 	}
 
-	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
+	core_dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
 static void set_drive_settings(struct dc *dc,
 		struct link_training_settings *lt_settings,
 		const struct dc_link *link)
 {
-
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
 
-	for (i = 0; i < dc->link_count; i++) {
-		if (dc->links[i] == link)
+	for (i = 0; i < core_dc->link_count; i++) {
+		if (core_dc->links[i] == link)
 			break;
 	}
 
-	if (i >= dc->link_count)
+	if (i >= core_dc->link_count)
 		ASSERT_CRITICAL(false);
 
-	dc_link_dp_set_drive_settings(dc->links[i], lt_settings);
+	dc_link_dp_set_drive_settings(core_dc->links[i], lt_settings);
 }
 
 static void perform_link_training(struct dc *dc,
 		struct dc_link_settings *link_setting,
 		bool skip_video_pattern)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
 
-	for (i = 0; i < dc->link_count; i++)
+	for (i = 0; i < core_dc->link_count; i++)
 		dc_link_dp_perform_link_training(
-			dc->links[i],
+			core_dc->links[i],
 			link_setting,
 			skip_video_pattern);
 }
@@ -334,7 +338,7 @@ void set_dither_option(struct dc_stream_state *stream,
 {
 	struct bit_depth_reduction_params params;
 	struct dc_link *link = stream->status.link;
-	struct pipe_ctx *pipes = link->dc->current_state->res_ctx.pipe_ctx;
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
 
 	memset(&params, 0, sizeof(params));
 	if (!stream)
@@ -365,51 +369,51 @@ void set_dither_option(struct dc_stream_state *stream,
 		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }
 
-static void allocate_dc_stream_funcs(struct dc  *dc)
+static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 {
-	if (dc->hwss.set_drr != NULL) {
-		dc->stream_funcs.adjust_vmin_vmax =
+	if (core_dc->hwss.set_drr != NULL) {
+		core_dc->public.stream_funcs.adjust_vmin_vmax =
 				stream_adjust_vmin_vmax;
 	}
 
-	dc->stream_funcs.set_static_screen_events =
+	core_dc->public.stream_funcs.set_static_screen_events =
 			set_static_screen_events;
 
-	dc->stream_funcs.get_crtc_position =
+	core_dc->public.stream_funcs.get_crtc_position =
 			stream_get_crtc_position;
 
-	dc->stream_funcs.set_gamut_remap =
+	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
-	dc->stream_funcs.program_csc_matrix =
+	core_dc->public.stream_funcs.program_csc_matrix =
 			program_csc_matrix;
 
-	dc->stream_funcs.set_dither_option =
+	core_dc->public.stream_funcs.set_dither_option =
 			set_dither_option;
 
-	dc->link_funcs.set_drive_settings =
+	core_dc->public.link_funcs.set_drive_settings =
 			set_drive_settings;
 
-	dc->link_funcs.perform_link_training =
+	core_dc->public.link_funcs.perform_link_training =
 			perform_link_training;
 
-	dc->link_funcs.set_preferred_link_settings =
+	core_dc->public.link_funcs.set_preferred_link_settings =
 			set_preferred_link_settings;
 
-	dc->link_funcs.enable_hpd =
+	core_dc->public.link_funcs.enable_hpd =
 			enable_hpd;
 
-	dc->link_funcs.disable_hpd =
+	core_dc->public.link_funcs.disable_hpd =
 			disable_hpd;
 
-	dc->link_funcs.set_test_pattern =
+	core_dc->public.link_funcs.set_test_pattern =
 			set_test_pattern;
 }
 
-static void destruct(struct dc *dc)
+static void destruct(struct core_dc *dc)
 {
-	dc_release_state(dc->current_state);
-	dc->current_state = NULL;
+	dc_release_validate_context(dc->current_context);
+	dc->current_context = NULL;
 
 	destroy_links(dc);
 
@@ -429,83 +433,32 @@ static void destruct(struct dc *dc)
 
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
-
-	dm_free(dc->bw_vbios);
-	dc->bw_vbios = NULL;
-
-	dm_free(dc->bw_dceip);
-	dc->bw_dceip = NULL;
-
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	dm_free(dc->dcn_soc);
-	dc->dcn_soc = NULL;
-
-	dm_free(dc->dcn_ip);
-	dc->dcn_ip = NULL;
-
-#endif
 }
 
-static bool construct(struct dc *dc,
+static bool construct(struct core_dc *dc,
 		const struct dc_init_data *init_params)
 {
 	struct dal_logger *logger;
 	struct dc_context *dc_ctx = dm_alloc(sizeof(*dc_ctx));
-	struct bw_calcs_dceip *dc_dceip = dm_alloc(sizeof(*dc_dceip));
-	struct bw_calcs_vbios *dc_vbios = dm_alloc(sizeof(*dc_vbios));
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	struct dcn_soc_bounding_box *dcn_soc = dm_alloc(sizeof(*dcn_soc));
-	struct dcn_ip_params *dcn_ip = dm_alloc(sizeof(*dcn_ip));
-#endif
-
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 
-	if (!dc_dceip) {
-		dm_error("%s: failed to create dceip\n", __func__);
-		goto fail;
-	}
-
-	dc->bw_dceip = dc_dceip;
-
-	if (!dc_vbios) {
-		dm_error("%s: failed to create vbios\n", __func__);
-		goto fail;
-	}
-
-	dc->bw_vbios = dc_vbios;
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	if (!dcn_soc) {
-		dm_error("%s: failed to create dcn_soc\n", __func__);
-		goto fail;
-	}
-
-	dc->dcn_soc = dcn_soc;
-
-	if (!dcn_ip) {
-		dm_error("%s: failed to create dcn_ip\n", __func__);
-		goto fail;
-	}
-
-	dc->dcn_ip = dcn_ip;
-#endif
-
 	if (!dc_ctx) {
 		dm_error("%s: failed to create ctx\n", __func__);
-		goto fail;
+		goto ctx_fail;
 	}
 
-	dc->current_state = dm_alloc(sizeof(*dc->current_state));
+	dc->current_context = dm_alloc(sizeof(*dc->current_context));
 
-	if (!dc->current_state) {
+	if (!dc->current_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
-		goto fail;
+		goto val_ctx_fail;
 	}
 
-	atomic_inc(&dc->current_state->ref_count);
+	dc->current_context->ref_count++;
 
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
-	dc_ctx->dc = dc;
+	dc_ctx->dc = &dc->public;
 	dc_ctx->asic_id = init_params->asic_id;
 
 	/* Create logger */
@@ -514,7 +467,7 @@ static bool construct(struct dc *dc,
 	if (!logger) {
 		/* can *not* call logger. call base driver 'print error' */
 		dm_error("%s: failed to create Logger!\n", __func__);
-		goto fail;
+		goto logger_fail;
 	}
 	dc_ctx->logger = logger;
 	dc->ctx = dc_ctx;
@@ -542,7 +495,7 @@ static bool construct(struct dc *dc,
 
 		if (!dc_ctx->dc_bios) {
 			ASSERT_CRITICAL(false);
-			goto fail;
+			goto bios_fail;
 		}
 
 		dc_ctx->created_bios = true;
@@ -553,7 +506,7 @@ static bool construct(struct dc *dc,
 
 	if (!dc_ctx->i2caux) {
 		ASSERT_CRITICAL(false);
-		goto fail;
+		goto failed_to_create_i2caux;
 	}
 
 	/* Create GPIO service */
@@ -564,7 +517,7 @@ static bool construct(struct dc *dc,
 
 	if (!dc_ctx->gpio_service) {
 		ASSERT_CRITICAL(false);
-		goto fail;
+		goto gpio_fail;
 	}
 
 	dc->res_pool = dc_create_resource_pool(
@@ -573,19 +526,24 @@ static bool construct(struct dc *dc,
 			dc_version,
 			init_params->asic_id);
 	if (!dc->res_pool)
-		goto fail;
-
-	dc_resource_state_construct(dc, dc->current_state);
+		goto create_resource_fail;
 
 	if (!create_links(dc, init_params->num_virtual_links))
-		goto fail;
+		goto create_links_fail;
 
 	allocate_dc_stream_funcs(dc);
 
 	return true;
 
-fail:
-
+	/**** error handling here ****/
+create_links_fail:
+create_resource_fail:
+gpio_fail:
+failed_to_create_i2caux:
+bios_fail:
+logger_fail:
+val_ctx_fail:
+ctx_fail:
 	destruct(dc);
 	return false;
 }
@@ -620,41 +578,41 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
 
 struct dc *dc_create(const struct dc_init_data *init_params)
  {
-	struct dc *dc = dm_alloc(sizeof(*dc));
+	struct core_dc *core_dc = dm_alloc(sizeof(*core_dc));
 	unsigned int full_pipe_count;
 
-	if (NULL == dc)
+	if (NULL == core_dc)
 		goto alloc_fail;
 
-	if (false == construct(dc, init_params))
+	if (false == construct(core_dc, init_params))
 		goto construct_fail;
 
 	/*TODO: separate HW and SW initialization*/
-	dc->hwss.init_hw(dc);
+	core_dc->hwss.init_hw(core_dc);
 
-	full_pipe_count = dc->res_pool->pipe_count;
-	if (dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
+	full_pipe_count = core_dc->res_pool->pipe_count;
+	if (core_dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
 		full_pipe_count--;
-	dc->caps.max_streams = min(
+	core_dc->public.caps.max_streams = min(
 			full_pipe_count,
-			dc->res_pool->stream_enc_count);
+			core_dc->res_pool->stream_enc_count);
 
-	dc->caps.max_links = dc->link_count;
-	dc->caps.max_audios = dc->res_pool->audio_count;
+	core_dc->public.caps.max_links = core_dc->link_count;
+	core_dc->public.caps.max_audios = core_dc->res_pool->audio_count;
 
-	dc->config = init_params->flags;
+	core_dc->public.config = init_params->flags;
 
-	dm_logger_write(dc->ctx->logger, LOG_DC,
+	dm_logger_write(core_dc->ctx->logger, LOG_DC,
 			"Display Core initialized\n");
 
 
 	/* TODO: missing feature to be enabled */
-	dc->debug.disable_dfs_bypass = true;
+	core_dc->public.debug.disable_dfs_bypass = true;
 
-	return dc;
+	return &core_dc->public;
 
 construct_fail:
-	dm_free(dc);
+	dm_free(core_dc);
 
 alloc_fail:
 	return NULL;
@@ -662,37 +620,178 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 void dc_destroy(struct dc **dc)
 {
-	destruct(*dc);
-	dm_free(*dc);
+	struct core_dc *core_dc = DC_TO_CORE(*dc);
+	destruct(core_dc);
+	dm_free(core_dc);
 	*dc = NULL;
 }
 
+static bool is_validation_required(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	const struct validate_context *context = dc->current_context;
+	int i, j;
+
+	if (context->stream_count != set_count)
+		return true;
+
+	for (i = 0; i < set_count; i++) {
+
+		if (set[i].plane_count != context->stream_status[i].plane_count)
+			return true;
+		if (!dc_is_stream_unchanged(set[i].stream, context->streams[i]))
+			return true;
+
+		for (j = 0; j < set[i].plane_count; j++) {
+			struct dc_plane_state temp_plane;
+			memset(&temp_plane, 0, sizeof(temp_plane));
+
+			temp_plane = *context->stream_status[i].plane_states[j];
+			temp_plane.clip_rect = set[i].plane_states[j]->clip_rect;
+			temp_plane.dst_rect.x = set[i].plane_states[j]->dst_rect.x;
+			temp_plane.dst_rect.y = set[i].plane_states[j]->dst_rect.y;
+
+			if (memcmp(&temp_plane, set[i].plane_states[j], sizeof(temp_plane)) != 0)
+				return true;
+		}
+	}
+
+	return false;
+}
+
+static bool validate_streams (
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	int i;
+
+	for (i = 0; i < set_count; i++)
+		if (!dc_validate_stream(dc, set[i].stream))
+			return false;
+
+	return true;
+}
+
+static bool validate_surfaces(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	int i, j;
+
+	for (i = 0; i < set_count; i++)
+		for (j = 0; j < set[i].plane_count; j++)
+			if (!dc_validate_plane(dc, set[i].plane_states[j]))
+				return false;
+
+	return true;
+}
+
+struct validate_context *dc_get_validate_context(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	++context->ref_count;
+
+	if (!is_validation_required(core_dc, set, set_count)) {
+		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
+		return context;
+	}
+
+	result = core_dc->res_pool->funcs->validate_with_context(
+			core_dc, set, set_count, context, core_dc->current_context);
+
+context_alloc_fail:
+	if (result != DC_OK) {
+		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
+				"%s:resource validation failed, dc_status:%d\n",
+				__func__,
+				result);
+
+		dc_release_validate_context(context);
+		context = NULL;
+	}
+
+	return context;
+
+}
+
+bool dc_validate_resources(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+
+	if (!validate_streams(dc, set, set_count))
+		return false;
+
+	if (!validate_surfaces(dc, set, set_count))
+		return false;
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	++context->ref_count;
+
+	result = core_dc->res_pool->funcs->validate_with_context(
+				core_dc, set, set_count, context, NULL);
+
+context_alloc_fail:
+	if (result != DC_OK) {
+		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
+				"%s:resource validation failed, dc_status:%d\n",
+				__func__,
+				result);
+	}
+
+	dc_release_validate_context(context);
+	context = NULL;
+
+	return result == DC_OK;
+}
+
 bool dc_validate_guaranteed(
-		struct dc *dc,
+		const struct dc *dc,
 		struct dc_stream_state *stream)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct dc_state *context;
+	struct validate_context *context;
 
 	if (!dc_validate_stream(dc, stream))
 		return false;
 
-	context = dm_alloc(sizeof(struct dc_state));
+	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	dc_resource_state_construct(dc, dc->current_state);
+	++context->ref_count;
 
-	atomic_inc(&context->ref_count);
+	result = core_dc->res_pool->funcs->validate_guaranteed(
+					core_dc, stream, context);
 
-	result = dc->res_pool->funcs->validate_guaranteed(
-					dc, stream, context);
-
-	dc_release_state(context);
+	dc_release_validate_context(context);
 
 context_alloc_fail:
 	if (result != DC_OK) {
-		dm_logger_write(dc->ctx->logger, LOG_WARNING,
+		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
 			"%s:guaranteed validation failed, dc_status:%d\n",
 			__func__,
 			result);
@@ -702,12 +801,12 @@ bool dc_validate_guaranteed(
 }
 
 static void program_timing_sync(
-		struct dc *dc,
-		struct dc_state *ctx)
+		struct core_dc *core_dc,
+		struct validate_context *ctx)
 {
 	int i, j;
 	int group_index = 0;
-	int pipe_count = dc->res_pool->pipe_count;
+	int pipe_count = core_dc->res_pool->pipe_count;
 	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
 
 	for (i = 0; i < pipe_count; i++) {
@@ -768,24 +867,42 @@ static void program_timing_sync(
 		}
 
 		if (group_size > 1) {
-			dc->hwss.enable_timing_synchronization(
-				dc, group_index, group_size, pipe_set);
+			core_dc->hwss.enable_timing_synchronization(
+				core_dc, group_index, group_size, pipe_set);
 			group_index++;
 		}
 	}
 }
 
 static bool context_changed(
-		struct dc *dc,
-		struct dc_state *context)
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	uint8_t i;
+
+	if (context->stream_count != dc->current_context->stream_count)
+		return true;
+
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (dc->current_context->streams[i] != context->streams[i])
+			return true;
+	}
+
+	return false;
+}
+
+static bool streams_changed(
+		struct core_dc *dc,
+		struct dc_stream_state *streams[],
+		uint8_t stream_count)
 {
 	uint8_t i;
 
-	if (context->stream_count != dc->current_state->stream_count)
+	if (stream_count != dc->current_context->stream_count)
 		return true;
 
-	for (i = 0; i < dc->current_state->stream_count; i++) {
-		if (dc->current_state->streams[i] != context->streams[i])
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (dc->current_context->streams[i] != streams[i])
 			return true;
 	}
 
@@ -794,26 +911,38 @@ static bool context_changed(
 
 bool dc_enable_stereo(
 	struct dc *dc,
-	struct dc_state *context,
+	struct validate_context *context,
 	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
 	bool ret = true;
 	int i, j;
 	struct pipe_ctx *pipe;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+#ifdef ENABLE_FBC
+	struct compressor *fbc_compressor = core_dc->fbc_compressor;
+#endif
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context != NULL)
 			pipe = &context->res_ctx.pipe_ctx[i];
 		else
-			pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+			pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 		for (j = 0 ; pipe && j < stream_count; j++)  {
 			if (streams[j] && streams[j] == pipe->stream &&
-				dc->hwss.setup_stereo)
-				dc->hwss.setup_stereo(pipe, dc);
+				core_dc->hwss.setup_stereo)
+				core_dc->hwss.setup_stereo(pipe, core_dc);
 		}
 	}
 
+#ifdef ENABLE_FBC
+	if (fbc_compressor != NULL &&
+	    fbc_compressor->funcs->is_fbc_enabled_in_hw(core_dc->fbc_compressor,
+							NULL))
+		fbc_compressor->funcs->disable_fbc(fbc_compressor);
+
+#endif
 	return ret;
 }
 
@@ -822,9 +951,10 @@ bool dc_enable_stereo(
  * Applies given context to HW and copy it into current context.
  * It's up to the user to release the src context afterwards.
  */
-static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
+static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *context)
 {
-	struct dc_bios *dcb = dc->ctx->dc_bios;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
@@ -834,24 +964,22 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 		dc_streams[i] =  context->streams[i];
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
-		dc->hwss.enable_accelerated_mode(dc);
-
-	dc->hwss.ready_shared_resources(dc);
+		core_dc->hwss.enable_accelerated_mode(core_dc);
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		pipe = &context->res_ctx.pipe_ctx[i];
-		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
+		core_dc->hwss.wait_for_mpcc_disconnect(core_dc, core_dc->res_pool, pipe);
 	}
-	result = dc->hwss.apply_ctx_to_hw(dc, context);
+	result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
 
-	program_timing_sync(dc, context);
+	program_timing_sync(core_dc, context);
 
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].plane_count; j++) {
-			dc->hwss.apply_ctx_for_surface(
-					dc, context->streams[i],
+			core_dc->hwss.apply_ctx_for_surface(
+					core_dc, context->streams[i],
 					context->stream_status[i].plane_count,
 					context);
 
@@ -865,8 +993,8 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 				for (l = 0 ; pipe && l < context->stream_count; l++)  {
 					if (context->streams[l] &&
 					    context->streams[l] == pipe->stream &&
-					    dc->hwss.setup_stereo)
-						dc->hwss.setup_stereo(pipe, dc);
+					    core_dc->hwss.setup_stereo)
+						core_dc->hwss.setup_stereo(pipe, core_dc);
 				}
 			}
 		}
@@ -881,59 +1009,127 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	dc_release_state(dc->current_state);
-
-	dc->current_state = context;
+	dc_release_validate_context(core_dc->current_context);
 
-	dc_retain_state(dc->current_state);
+	core_dc->current_context = context;
 
-	dc->hwss.optimize_shared_resources(dc);
+	dc_retain_validate_context(core_dc->current_context);
 
 	return (result == DC_OK);
 }
 
-bool dc_commit_state(struct dc *dc, struct dc_state *context)
+bool dc_commit_context(struct dc *dc, struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
 
-	if (false == context_changed(dc, context))
+	if (false == context_changed(core_dc, context))
 		return DC_OK;
 
-	dm_logger_write(dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct dc_stream_state *stream = context->streams[i];
 
 		dc_stream_log(stream,
-				dc->ctx->logger,
+				core_dc->ctx->logger,
 				LOG_DC);
 	}
 
-	result = dc_commit_state_no_check(dc, context);
+	result = dc_commit_context_no_check(dc, context);
 
 	return (result == DC_OK);
 }
 
 
+bool dc_commit_streams(
+	struct dc *dc,
+	struct dc_stream_state *streams[],
+	uint8_t stream_count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
+	int i;
+
+	if (false == streams_changed(core_dc, streams, stream_count))
+		return DC_OK;
+
+	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+				__func__, stream_count);
+
+	for (i = 0; i < stream_count; i++) {
+		struct dc_stream_state *stream = streams[i];
+		struct dc_stream_status *status = dc_stream_get_status(stream);
+		int j;
+
+		dc_stream_log(stream,
+				core_dc->ctx->logger,
+				LOG_DC);
+
+		set[i].stream = stream;
+
+		if (status) {
+			set[i].plane_count = status->plane_count;
+			for (j = 0; j < status->plane_count; j++)
+				set[i].plane_states[j] = status->plane_states[j];
+		}
+
+	}
+
+	if (!validate_streams(dc, set, stream_count))
+		return false;
+
+	if (!validate_surfaces(dc, set, stream_count))
+		return false;
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	++context->ref_count;
+
+	result = core_dc->res_pool->funcs->validate_with_context(
+			core_dc, set, stream_count, context, core_dc->current_context);
+	if (result != DC_OK){
+		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
+					"%s: Context validation failed! dc_status:%d\n",
+					__func__,
+					result);
+		BREAK_TO_DEBUGGER();
+		goto fail;
+	}
+
+	result = dc_commit_context_no_check(dc, context);
+
+fail:
+	dc_release_validate_context(context);
+
+context_alloc_fail:
+	return (result == DC_OK);
+}
+
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
-	struct dc_state *context = dc->current_state;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *context = core_dc->current_context;
 
 	post_surface_trace(dc);
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++)
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL
 				|| context->res_ctx.pipe_ctx[i].plane_state == NULL)
-			dc->hwss.power_down_front_end(dc, i);
+			core_dc->hwss.power_down_front_end(core_dc, i);
 
 	/* 3rd param should be true, temp w/a for RV*/
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	dc->hwss.set_bandwidth(dc, context, dc->ctx->dce_version < DCN_VERSION_1_0);
+	core_dc->hwss.set_bandwidth(core_dc, context, core_dc->ctx->dce_version < DCN_VERSION_1_0);
 #else
-	dc->hwss.set_bandwidth(dc, context, true);
+	core_dc->hwss.set_bandwidth(core_dc, context, true);
 #endif
 	return true;
 }
@@ -1005,25 +1201,25 @@ bool dc_commit_planes_to_stream(
 	return true;
 }
 
-void dc_retain_state(struct dc_state *context)
+void dc_retain_validate_context(struct validate_context *context)
 {
-	ASSERT(atomic_read(&context->ref_count) > 0);
-	atomic_inc(&context->ref_count);
+	ASSERT(context->ref_count > 0);
+	++context->ref_count;
 }
 
-void dc_release_state(struct dc_state *context)
+void dc_release_validate_context(struct validate_context *context)
 {
-	ASSERT(atomic_read(&context->ref_count) > 0);
-	atomic_dec(&context->ref_count);
+	ASSERT(context->ref_count > 0);
+	--context->ref_count;
 
-	if (atomic_read(&context->ref_count) == 0) {
-		dc_resource_state_destruct(context);
+	if (context->ref_count == 0) {
+		dc_resource_validate_ctx_destruct(context);
 		dm_free(context);
 	}
 }
 
 static bool is_surface_in_context(
-		const struct dc_state *context,
+		const struct validate_context *context,
 		const struct dc_plane_state *plane_state)
 {
 	int j;
@@ -1136,11 +1332,11 @@ static enum surface_update_type  get_scaling_info_update_type(
 }
 
 static enum surface_update_type det_surface_update(
-		const struct dc *dc,
+		const struct core_dc *dc,
 		const struct dc_surface_update *u,
 		int surface_index)
 {
-	const struct dc_state *context = dc->current_state;
+	const struct validate_context *context = dc->current_context;
 	enum surface_update_type type = UPDATE_TYPE_FAST;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
@@ -1171,6 +1367,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc_stream_update *stream_update,
 		const struct dc_stream_status *stream_status)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
@@ -1182,7 +1379,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
-				det_surface_update(dc, &updates[i], i);
+				det_surface_update(core_dc, &updates[i], i);
 
 		if (type == UPDATE_TYPE_FULL)
 			return type;
@@ -1195,7 +1392,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 }
 
 static struct dc_stream_status *stream_get_status(
-	struct dc_state *ctx,
+	struct validate_context *ctx,
 	struct dc_stream_state *stream)
 {
 	uint8_t i;
@@ -1216,11 +1413,12 @@ void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
 {
-	struct dc_state *context;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *context;
 	int i, j;
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
-	struct dc_context *dc_ctx = dc->ctx;
+	struct dc_context *dc_ctx = core_dc->ctx;
 
 	stream_status = dc_stream_get_status(stream);
 
@@ -1234,7 +1432,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 			ASSERT(0);
 	}
 #endif
-	context = dc->current_state;
+	context = core_dc->current_context;
 
 	/* update current stream with the new updates */
 	if (stream_update) {
@@ -1287,21 +1485,15 @@ void dc_update_planes_and_stream(struct dc *dc,
 		if (context == NULL)
 				goto context_alloc_fail;
 
-		atomic_inc(&context->ref_count);
+		++context->ref_count;
 
-		dc_resource_state_copy_construct(
-				dc->current_state, context);
-
-		/*remove old surfaces from context */
-		if (!dc_rem_all_planes_for_stream(dc, stream, context)) {
-
-			BREAK_TO_DEBUGGER();
-			goto fail;
-		}
+		dc_resource_validate_ctx_copy_construct(
+				core_dc->current_context, context);
 
 		/* add surface to context */
-		if (!dc_add_all_planes_for_stream(dc, stream, new_planes, surface_count, context)) {
-
+		if (!resource_attach_surfaces_to_context(
+				new_planes, surface_count, stream,
+				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
 		}
@@ -1352,7 +1544,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		}
 
 		if (update_type >= UPDATE_TYPE_MED) {
-			for (j = 0; j < dc->res_pool->pipe_count; j++) {
+			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 				if (pipe_ctx->plane_state != surface)
@@ -1390,31 +1582,31 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	if (update_type == UPDATE_TYPE_FULL) {
-		if (!dc->res_pool->funcs->validate_bandwidth(dc, context)) {
+		if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
 		} else {
-			dc->hwss.set_bandwidth(dc, context, false);
+			core_dc->hwss.set_bandwidth(core_dc, context, false);
 			context_clock_trace(dc, context);
 		}
 	}
 
 	if (update_type > UPDATE_TYPE_FAST) {
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
+			core_dc->hwss.wait_for_mpcc_disconnect(core_dc, core_dc->res_pool, pipe_ctx);
 		}
 	}
 
 	if (surface_count == 0)
-		dc->hwss.apply_ctx_for_surface(dc, stream, surface_count, context);
+		core_dc->hwss.apply_ctx_for_surface(core_dc, stream, surface_count, context);
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
 		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->plane_state != plane_state)
@@ -1422,8 +1614,8 @@ void dc_update_planes_and_stream(struct dc *dc,
 			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
-			dc->hwss.pipe_control_lock(
-					dc,
+			core_dc->hwss.pipe_control_lock(
+					core_dc,
 					pipe_ctx,
 					true);
 		}
@@ -1432,9 +1624,9 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	/* Full fe update*/
-	for (j = 0; j < dc->res_pool->pipe_count; j++) {
+	for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[j];
+		struct pipe_ctx *cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
 		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
@@ -1445,18 +1637,18 @@ void dc_update_planes_and_stream(struct dc *dc,
 		if (!pipe_ctx->top_pipe && pipe_ctx->stream) {
 			struct dc_stream_status *stream_status = stream_get_status(context, pipe_ctx->stream);
 
-			dc->hwss.apply_ctx_for_surface(
-					dc, pipe_ctx->stream, stream_status->plane_count, context);
+			core_dc->hwss.apply_ctx_for_surface(
+					core_dc, pipe_ctx->stream, stream_status->plane_count, context);
 		}
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
 
 		if (is_new_pipe_surface) {
-			dc->hwss.update_plane_addr(dc, pipe_ctx);
-			dc->hwss.set_input_transfer_func(
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+			core_dc->hwss.set_input_transfer_func(
 					pipe_ctx, pipe_ctx->plane_state);
-			dc->hwss.set_output_transfer_func(
+			core_dc->hwss.set_output_transfer_func(
 					pipe_ctx, pipe_ctx->stream);
 		}
 	}
@@ -1469,40 +1661,40 @@ void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
-			dc->hwss.apply_ctx_for_surface(
-					dc, stream, surface_count, context);
+			core_dc->hwss.apply_ctx_for_surface(
+					core_dc, stream, surface_count, context);
 
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
 			if (srf_updates[i].flip_addr)
-				dc->hwss.update_plane_addr(dc, pipe_ctx);
+				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
 			if (srf_updates[i].in_transfer_func)
-				dc->hwss.set_input_transfer_func(
+				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->plane_state);
 
 			if (stream_update != NULL &&
 					stream_update->out_transfer_func != NULL) {
-				dc->hwss.set_output_transfer_func(
+				core_dc->hwss.set_output_transfer_func(
 						pipe_ctx, pipe_ctx->stream);
 			}
 
 			if (srf_updates[i].hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);
-				dc->hwss.update_info_frame(pipe_ctx);
+				core_dc->hwss.update_info_frame(pipe_ctx);
 			}
 		}
 	}
 
 	/* Unlock pipes */
-	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
+	for (i = core_dc->res_pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		for (j = 0; j < surface_count; j++) {
@@ -1512,8 +1704,8 @@ void dc_update_planes_and_stream(struct dc *dc,
 			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
-			dc->hwss.pipe_control_lock(
-					dc,
+			core_dc->hwss.pipe_control_lock(
+					core_dc,
 					pipe_ctx,
 					false);
 
@@ -1521,72 +1713,60 @@ void dc_update_planes_and_stream(struct dc *dc,
 		}
 	}
 
-	if (dc->current_state != context) {
-
-		/* Since memory free requires elevated IRQL, an interrupt
-		 * request is generated by mem free. If this happens
-		 * between freeing and reassigning the context, our vsync
-		 * interrupt will call into dc and cause a memory
-		 * corruption BSOD. Hence, we first reassign the context,
-		 * then free the old context.
-		 */
-
-		struct dc_state *old = dc->current_state;
+	if (core_dc->current_context != context) {
+		struct validate_context *old = core_dc->current_context;
 
-		dc->current_state = context;
-		dc_release_state(old);
+		core_dc->current_context = context;
+		dc_release_validate_context(old);
 
 	}
 	return;
 
 fail:
-	dc_release_state(context);
+	dc_release_validate_context(context);
 
 context_alloc_fail:
 	DC_ERROR("Failed to allocate new validate context!\n");
 }
 
-uint8_t dc_get_current_stream_count(struct dc *dc)
+uint8_t dc_get_current_stream_count(const struct dc *dc)
 {
-	return dc->current_state->stream_count;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->current_context->stream_count;
 }
 
-struct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i)
+struct dc_stream_state *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 {
-	if (i < dc->current_state->stream_count)
-		return dc->current_state->streams[i];
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	if (i < core_dc->current_context->stream_count)
+		return core_dc->current_context->streams[i];
 	return NULL;
 }
 
-struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)
-{
-	return dc->links[link_index];
-}
-
-struct dwbc *dc_get_dwb_at_pipe(struct dc *dc, uint32_t pipe)
+struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
 {
-	if ((pipe >= dwb_pipe0) && (pipe < dwb_pipe_max_num)) {
-		return dc->res_pool->dwbc[(int)pipe];
-	} else {
-		return NULL;
-	}
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index];
 }
 
 const struct graphics_object_id dc_get_link_id_at_index(
 	struct dc *dc, uint32_t link_index)
 {
-	return dc->links[link_index]->link_id;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->link_id;
 }
 
 enum dc_irq_source dc_get_hpd_irq_source_at_index(
 	struct dc *dc, uint32_t link_index)
 {
-	return dc->links[link_index]->irq_source_hpd;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->irq_source_hpd;
 }
 
 const struct audio **dc_get_audios(struct dc *dc)
 {
-	return (const struct audio **)dc->res_pool->audios;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return (const struct audio **)core_dc->res_pool->audios;
 }
 
 void dc_flip_plane_addrs(
@@ -1595,7 +1775,7 @@ void dc_flip_plane_addrs(
 		struct dc_flip_addrs flip_addrs[],
 		uint32_t count)
 {
-	struct dc *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i, j;
 
 	for (i = 0; i < count; i++) {
@@ -1619,21 +1799,25 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 		uint32_t src_id,
 		uint32_t ext_id)
 {
-	return dal_irq_service_to_irq_source(dc->res_pool->irqs, src_id, ext_id);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return dal_irq_service_to_irq_source(core_dc->res_pool->irqs, src_id, ext_id);
 }
 
-void dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
+void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable)
 {
+	struct core_dc *core_dc;
 
 	if (dc == NULL)
 		return;
+	core_dc = DC_TO_CORE(dc);
 
-	dal_irq_service_set(dc->res_pool->irqs, src, enable);
+	dal_irq_service_set(core_dc->res_pool->irqs, src, enable);
 }
 
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 {
-	dal_irq_service_ack(dc->res_pool->irqs, src);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	dal_irq_service_ack(core_dc->res_pool->irqs, src);
 }
 
 void dc_set_power_state(
@@ -1641,22 +1825,21 @@ void dc_set_power_state(
 	enum dc_acpi_cm_power_state power_state,
 	enum dc_video_power_state video_power_state)
 {
-	atomic_t ref_count;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int ref_count;
 
 	core_dc->previous_power_state = core_dc->current_power_state;
 	core_dc->current_power_state = video_power_state;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
-		dc_resource_state_construct(dc, dc->current_state);
-
-		dc->hwss.init_hw(dc);
+		core_dc->hwss.init_hw(core_dc);
 		break;
 	default:
 		/* NULL means "reset/release all DC streams" */
 		dc_commit_streams(dc, NULL, 0);
 
-		dc->hwss.power_down(dc);
+		core_dc->hwss.power_down(core_dc);
 
 		/* Zero out the current context so that on resume we start with
 		 * clean state, and dc hw programming optimizations will not
@@ -1664,25 +1847,25 @@ void dc_set_power_state(
 		 */
 
 		/* Preserve refcount */
-		ref_count = dc->current_state->ref_count;
-		dc_resource_state_destruct(dc->current_state);
-		memset(dc->current_state, 0,
-				sizeof(*dc->current_state));
-
-		dc->current_state->ref_count = ref_count;
+		ref_count = core_dc->current_context->ref_count;
+		dc_resource_validate_ctx_destruct(core_dc->current_context);
+		memset(core_dc->current_context, 0,
+				sizeof(*core_dc->current_context));
+		core_dc->current_context->ref_count = ref_count;
 
 		break;
 	}
 
 }
 
-void dc_resume(struct dc *dc)
+void dc_resume(const struct dc *dc)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
 	uint32_t i;
 
-	for (i = 0; i < dc->link_count; i++)
-		core_link_resume(dc->links[i]);
+	for (i = 0; i < core_dc->link_count; i++)
+		core_link_resume(core_dc->links[i]);
 }
 
 bool dc_read_aux_dpcd(
@@ -1692,8 +1875,9 @@ bool dc_read_aux_dpcd(
 		uint8_t *data,
 		uint32_t size)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_link *link = dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
 			link->ddc,
 			false,
@@ -1711,7 +1895,8 @@ bool dc_write_aux_dpcd(
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct dc_link *link = dc->links[link_index];
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
@@ -1731,8 +1916,9 @@ bool dc_read_aux_i2c(
 		uint8_t *data,
 		uint32_t size)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-		struct dc_link *link = dc->links[link_index];
+		struct dc_link *link = core_dc->links[link_index];
 		enum ddc_result r = dal_ddc_service_read_dpcd_data(
 			link->ddc,
 			true,
@@ -1751,7 +1937,8 @@ bool dc_write_aux_i2c(
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct dc_link *link = dc->links[link_index];
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
@@ -1772,8 +1959,9 @@ bool dc_query_ddc_data(
 		uint8_t *read_buf,
 		uint32_t read_size) {
 
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_link *link = dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	bool result = dal_ddc_service_query_ddc_data(
 			link->ddc,
@@ -1791,8 +1979,9 @@ bool dc_submit_i2c(
 		uint32_t link_index,
 		struct i2c_command *cmd)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_link *link = dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 	struct ddc_service *ddc = link->ddc;
 
 	return dal_i2caux_submit_i2c_command(
@@ -1909,11 +2098,12 @@ void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 {
 	int i;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct mem_input *mi = NULL;
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		if (dc->res_pool->mis[i] != NULL) {
-			mi = dc->res_pool->mis[i];
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+		if (core_dc->res_pool->mis[i] != NULL) {
+			mi = core_dc->res_pool->mis[i];
 			break;
 		}
 	}
@@ -1922,10 +2112,10 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 		return false;
 	}
 
-	if (dc->hwss.update_dchub)
-		dc->hwss.update_dchub(dc->hwseq, dh_data);
+	if (core_dc->hwss.update_dchub)
+		core_dc->hwss.update_dchub(core_dc->hwseq, dh_data);
 	else
-		ASSERT(dc->hwss.update_dchub);
+		ASSERT(core_dc->hwss.update_dchub);
 
 
 	return true;
@@ -1934,8 +2124,9 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 
 void dc_log_hw_state(struct dc *dc)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	if (dc->hwss.log_hw_state)
-		dc->hwss.log_hw_state(dc);
+	if (core_dc->hwss.log_hw_state)
+		core_dc->hwss.log_hw_state(core_dc);
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
index 6acee54..21af3bc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_debug.c
@@ -37,12 +37,12 @@
 } while (0)
 
 void pre_surface_trace(
-		struct dc *dc,
+		const struct dc *dc,
 		const struct dc_plane_state *const *plane_states,
 		int surface_count)
 {
 	int i;
-	struct dc  *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dal_logger *logger =  core_dc->ctx->logger;
 
 	for (i = 0; i < surface_count; i++) {
@@ -158,12 +158,12 @@ void pre_surface_trace(
 }
 
 void update_surface_trace(
-		struct dc *dc,
+		const struct dc *dc,
 		const struct dc_surface_update *updates,
 		int surface_count)
 {
 	int i;
-	struct dc  *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dal_logger *logger =  core_dc->ctx->logger;
 
 	for (i = 0; i < surface_count; i++) {
@@ -279,9 +279,9 @@ void update_surface_trace(
 	SURFACE_TRACE("\n");
 }
 
-void post_surface_trace(struct dc *dc)
+void post_surface_trace(const struct dc *dc)
 {
-	struct dc  *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dal_logger *logger =  core_dc->ctx->logger;
 
 	SURFACE_TRACE("post surface process.\n");
@@ -289,11 +289,11 @@ void post_surface_trace(struct dc *dc)
 }
 
 void context_timing_trace(
-		struct dc *dc,
+		const struct dc *dc,
 		struct resource_context *res_ctx)
 {
 	int i;
-	struct dc  *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dal_logger *logger =  core_dc->ctx->logger;
 	int h_pos[MAX_PIPES], v_pos[MAX_PIPES];
 	struct crtc_position position;
@@ -328,11 +328,11 @@ void context_timing_trace(
 }
 
 void context_clock_trace(
-		struct dc *dc,
-		struct dc_state *context)
+		const struct dc *dc,
+		struct validate_context *context)
 {
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	struct dc  *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dal_logger *logger =  core_dc->ctx->logger;
 
 	CLOCK_TRACE("Current: dispclk_khz:%d  dppclk_div:%d  dcfclk_khz:%d\n"
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
index 71993d5..7b1f249 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_hw_sequencer.c
@@ -25,6 +25,7 @@
 
 #include "dm_services.h"
 #include "core_types.h"
+#include "core_dc.h"
 #include "timing_generator.h"
 #include "hw_sequencer.h"
 
@@ -54,7 +55,7 @@ static const struct tg_color black_color_format[] = {
 };
 
 void color_space_to_black_color(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	enum dc_color_space colorspace,
 	struct tg_color *black_color)
 {
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index cea8daf..b858fec 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -26,13 +26,14 @@
 #include "dm_services.h"
 #include "dm_helpers.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "grph_object_id.h"
 #include "gpio_service_interface.h"
 #include "core_status.h"
 #include "dc_link_dp.h"
 #include "dc_link_ddc.h"
 #include "link_hwss.h"
-
+#include "stream_encoder.h"
 #include "link_encoder.h"
 #include "hw_sequencer.h"
 #include "resource.h"
@@ -607,12 +608,6 @@ bool dc_link_detect(struct dc_link *link, bool boot)
 			if (link->type == dc_connection_mst_branch) {
 				LINK_INFO("link=%d, mst branch is now Connected\n",
 					link->link_index);
-				/* Need to setup mst link_cap struct here
-				 * otherwise dc_link_detect() will leave mst link_cap
-				 * empty which leads to allocate_mst_payload() has "0"
-				 * pbn_per_slot value leading to exception on dal_fixed31_32_div()
-				 */
-				link->verified_link_cap = link->reported_link_cap;
 				return false;
 			}
 
@@ -678,9 +673,13 @@ bool dc_link_detect(struct dc_link *link, bool boot)
 			 * TODO debug why Dell 2413 doesn't like
 			 *  two link trainings
 			 */
-
-			/* deal with non-mst cases */
-			dp_hbr_verify_link_cap(link, &link->reported_link_cap);
+			if (is_mst_supported(link)) {
+				link->verified_link_cap =
+						link->reported_link_cap;
+			} else {
+				dp_hbr_verify_link_cap(link,
+				    &link->reported_link_cap);
+			}
 		}
 
 		/* HDMI-DVI Dongle */
@@ -1046,17 +1045,10 @@ static bool construct(
 			&info.ext_disp_conn_info.path[i];
 		if (path->device_connector_id.enum_id == link->link_id.enum_id
 			&& path->device_connector_id.id == link->link_id.id
-			&& path->device_connector_id.type == link->link_id.type) {
-
-			if (link->device_tag.acpi_device != 0
-				&& path->device_acpi_enum == link->device_tag.acpi_device) {
-				link->ddi_channel_mapping = path->channel_mapping;
-				link->chip_caps = path->caps;
-			} else if (path->device_tag ==
-					link->device_tag.dev_id.raw_device_tag) {
-				link->ddi_channel_mapping = path->channel_mapping;
-				link->chip_caps = path->caps;
-			}
+			&& path->device_connector_id.type == link->link_id.type
+			&& path->device_acpi_enum
+					== link->device_tag.acpi_device) {
+			link->ddi_channel_mapping = path->channel_mapping;
 			break;
 		}
 	}
@@ -1181,9 +1173,7 @@ static void enable_stream_features(struct pipe_ctx *pipe_ctx)
 			&downspread.raw, sizeof(downspread));
 }
 
-static enum dc_status enable_link_dp(
-		struct dc_state *state,
-		struct pipe_ctx *pipe_ctx)
+static enum dc_status enable_link_dp(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_status status;
@@ -1203,14 +1193,14 @@ static enum dc_status enable_link_dp(
 		max_link_rate = LINK_RATE_HIGH3;
 
 	if (link_settings.link_rate == max_link_rate) {
-		if (state->dis_clk->funcs->set_min_clocks_state) {
-			if (state->dis_clk->cur_min_clks_state < DM_PP_CLOCKS_STATE_NOMINAL)
-				state->dis_clk->funcs->set_min_clocks_state(
-					state->dis_clk, DM_PP_CLOCKS_STATE_NOMINAL);
+		if (pipe_ctx->dis_clk->funcs->set_min_clocks_state) {
+			if (pipe_ctx->dis_clk->cur_min_clks_state < DM_PP_CLOCKS_STATE_NOMINAL)
+				pipe_ctx->dis_clk->funcs->set_min_clocks_state(
+					pipe_ctx->dis_clk, DM_PP_CLOCKS_STATE_NOMINAL);
 		} else {
 			uint32_t dp_phyclk_in_khz;
 			const struct clocks_value clocks_value =
-					state->dis_clk->cur_clocks_value;
+					pipe_ctx->dis_clk->cur_clocks_value;
 
 			/* 27mhz = 27000000hz= 27000khz */
 			dp_phyclk_in_khz = link_settings.link_rate * 27000;
@@ -1218,8 +1208,8 @@ static enum dc_status enable_link_dp(
 			if (((clocks_value.max_non_dp_phyclk_in_khz != 0) &&
 				(dp_phyclk_in_khz > clocks_value.max_non_dp_phyclk_in_khz)) ||
 				(dp_phyclk_in_khz > clocks_value.max_dp_phyclk_in_khz)) {
-				state->dis_clk->funcs->apply_clock_voltage_request(
-						state->dis_clk,
+				pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+						pipe_ctx->dis_clk,
 						DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
 						dp_phyclk_in_khz,
 						false,
@@ -1258,9 +1248,7 @@ static enum dc_status enable_link_dp(
 	return status;
 }
 
-static enum dc_status enable_link_dp_mst(
-		struct dc_state *state,
-		struct pipe_ctx *pipe_ctx)
+static enum dc_status enable_link_dp_mst(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_link *link = pipe_ctx->stream->sink->link;
 
@@ -1273,386 +1261,7 @@ static enum dc_status enable_link_dp_mst(
 	/* set the sink to MST mode before enabling the link */
 	dp_enable_mst_on_sink(link, true);
 
-	return enable_link_dp(state, pipe_ctx);
-}
-
-static bool get_ext_hdmi_settings(struct pipe_ctx *pipe_ctx,
-		enum engine_id eng_id,
-		struct ext_hdmi_settings *settings)
-{
-	bool result = false;
-	int i = 0;
-	struct integrated_info *integrated_info =
-			pipe_ctx->stream->ctx->dc_bios->integrated_info;
-
-	if (integrated_info == NULL)
-		return false;
-
-	/*
-	 * Get retimer settings from sbios for passing SI eye test for DCE11
-	 * The setting values are varied based on board revision and port id
-	 * Therefore the setting values of each ports is passed by sbios.
-	 */
-
-	// Check if current bios contains ext Hdmi settings
-	if (integrated_info->gpu_cap_info & 0x20) {
-		switch (eng_id) {
-		case ENGINE_ID_DIGA:
-			settings->slv_addr = integrated_info->dp0_ext_hdmi_slv_addr;
-			settings->reg_num = integrated_info->dp0_ext_hdmi_6g_reg_num;
-			settings->reg_num_6g = integrated_info->dp0_ext_hdmi_6g_reg_num;
-			memmove(settings->reg_settings,
-					integrated_info->dp0_ext_hdmi_reg_settings,
-					sizeof(integrated_info->dp0_ext_hdmi_reg_settings));
-			memmove(settings->reg_settings_6g,
-					integrated_info->dp0_ext_hdmi_6g_reg_settings,
-					sizeof(integrated_info->dp0_ext_hdmi_6g_reg_settings));
-			result = true;
-			break;
-		case ENGINE_ID_DIGB:
-			settings->slv_addr = integrated_info->dp1_ext_hdmi_slv_addr;
-			settings->reg_num = integrated_info->dp1_ext_hdmi_6g_reg_num;
-			settings->reg_num_6g = integrated_info->dp1_ext_hdmi_6g_reg_num;
-			memmove(settings->reg_settings,
-					integrated_info->dp1_ext_hdmi_reg_settings,
-					sizeof(integrated_info->dp1_ext_hdmi_reg_settings));
-			memmove(settings->reg_settings_6g,
-					integrated_info->dp1_ext_hdmi_6g_reg_settings,
-					sizeof(integrated_info->dp1_ext_hdmi_6g_reg_settings));
-			result = true;
-			break;
-		case ENGINE_ID_DIGC:
-			settings->slv_addr = integrated_info->dp2_ext_hdmi_slv_addr;
-			settings->reg_num = integrated_info->dp2_ext_hdmi_6g_reg_num;
-			settings->reg_num_6g = integrated_info->dp2_ext_hdmi_6g_reg_num;
-			memmove(settings->reg_settings,
-					integrated_info->dp2_ext_hdmi_reg_settings,
-					sizeof(integrated_info->dp2_ext_hdmi_reg_settings));
-			memmove(settings->reg_settings_6g,
-					integrated_info->dp2_ext_hdmi_6g_reg_settings,
-					sizeof(integrated_info->dp2_ext_hdmi_6g_reg_settings));
-			result = true;
-			break;
-
-		default:
-			break;
-		}
-
-		if (result == true) {
-			// Validate settings from bios integrated info table
-			if (settings->slv_addr == 0)
-				return false;
-			if (settings->reg_num > 9)
-				return false;
-			if (settings->reg_num_6g > 3)
-				return false;
-
-			for (i = 0; i < settings->reg_num; i++) {
-				if (settings->reg_settings[i].i2c_reg_index > 0x20)
-					return false;
-			}
-
-			for (i = 0; i < settings->reg_num_6g; i++) {
-				if (settings->reg_settings_6g[i].i2c_reg_index > 0x20)
-					return false;
-			}
-		}
-	}
-
-	return result;
-}
-
-static bool i2c_write(struct pipe_ctx *pipe_ctx,
-		uint8_t address, uint8_t *buffer, uint32_t length)
-{
-	struct i2c_command cmd = {0};
-	struct i2c_payload payload = {0};
-
-	memset(&payload, 0, sizeof(payload));
-	memset(&cmd, 0, sizeof(cmd));
-
-	cmd.number_of_payloads = 1;
-	cmd.engine = I2C_COMMAND_ENGINE_DEFAULT;
-	cmd.speed = pipe_ctx->stream->ctx->dc->caps.i2c_speed_in_khz;
-
-	payload.address = address;
-	payload.data = buffer;
-	payload.length = length;
-	payload.write = true;
-	cmd.payloads = &payload;
-
-	if (dc_submit_i2c(pipe_ctx->stream->ctx->dc,
-			pipe_ctx->stream->sink->link->link_index, &cmd))
-		return true;
-
-	return false;
-}
-
-static void write_i2c_retimer_setting(
-		struct pipe_ctx *pipe_ctx,
-		bool is_vga_mode,
-		bool is_over_340mhz,
-		struct ext_hdmi_settings *settings)
-{
-	uint8_t slave_address = (settings->slv_addr >> 1);
-	uint8_t buffer[2];
-	const uint8_t apply_rx_tx_change = 0x4;
-	uint8_t offset = 0xA;
-	uint8_t value = 0;
-	int i = 0;
-	bool i2c_success = false;
-
-	memset(&buffer, 0, sizeof(buffer));
-
-	/* Start Ext-Hdmi programming*/
-
-	for (i = 0; i < settings->reg_num; i++) {
-		/* Apply 3G settings */
-		if (settings->reg_settings[i].i2c_reg_index <= 0x20) {
-
-			buffer[0] = settings->reg_settings[i].i2c_reg_index;
-			buffer[1] = settings->reg_settings[i].i2c_reg_val;
-			i2c_success = i2c_write(pipe_ctx, slave_address,
-						buffer, sizeof(buffer));
-
-			if (!i2c_success)
-				/* Write failure */
-				ASSERT(i2c_success);
-
-			/* Based on DP159 specs, APPLY_RX_TX_CHANGE bit in 0x0A
-			 * needs to be set to 1 on every 0xA-0xC write.
-			 */
-			if (settings->reg_settings[i].i2c_reg_index == 0xA ||
-				settings->reg_settings[i].i2c_reg_index == 0xB ||
-				settings->reg_settings[i].i2c_reg_index == 0xC) {
-
-				/* Query current value from offset 0xA */
-				if (settings->reg_settings[i].i2c_reg_index == 0xA)
-					value = settings->reg_settings[i].i2c_reg_val;
-				else {
-					i2c_success =
-						dal_ddc_service_query_ddc_data(
-						pipe_ctx->stream->sink->link->ddc,
-						slave_address, &offset, 1, &value, 1);
-					if (!i2c_success)
-						/* Write failure */
-						ASSERT(i2c_success);
-				}
-
-				buffer[0] = offset;
-				/* Set APPLY_RX_TX_CHANGE bit to 1 */
-				buffer[1] = value | apply_rx_tx_change;
-				i2c_success = i2c_write(pipe_ctx, slave_address,
-						buffer, sizeof(buffer));
-				if (!i2c_success)
-					/* Write failure */
-					ASSERT(i2c_success);
-			}
-		}
-	}
-
-	/* Apply 3G settings */
-	if (is_over_340mhz) {
-		for (i = 0; i < settings->reg_num_6g; i++) {
-			/* Apply 3G settings */
-			if (settings->reg_settings[i].i2c_reg_index <= 0x20) {
-
-				buffer[0] = settings->reg_settings_6g[i].i2c_reg_index;
-				buffer[1] = settings->reg_settings_6g[i].i2c_reg_val;
-				i2c_success = i2c_write(pipe_ctx, slave_address,
-							buffer, sizeof(buffer));
-
-				if (!i2c_success)
-					/* Write failure */
-					ASSERT(i2c_success);
-
-				/* Based on DP159 specs, APPLY_RX_TX_CHANGE bit in 0x0A
-				 * needs to be set to 1 on every 0xA-0xC write.
-				 */
-				if (settings->reg_settings_6g[i].i2c_reg_index == 0xA ||
-					settings->reg_settings_6g[i].i2c_reg_index == 0xB ||
-					settings->reg_settings_6g[i].i2c_reg_index == 0xC) {
-
-					/* Query current value from offset 0xA */
-					if (settings->reg_settings_6g[i].i2c_reg_index == 0xA)
-						value = settings->reg_settings_6g[i].i2c_reg_val;
-					else {
-						i2c_success =
-								dal_ddc_service_query_ddc_data(
-								pipe_ctx->stream->sink->link->ddc,
-								slave_address, &offset, 1, &value, 1);
-						if (!i2c_success)
-							/* Write failure */
-							ASSERT(i2c_success);
-					}
-
-					buffer[0] = offset;
-					/* Set APPLY_RX_TX_CHANGE bit to 1 */
-					buffer[1] = value | apply_rx_tx_change;
-					i2c_success = i2c_write(pipe_ctx, slave_address,
-							buffer, sizeof(buffer));
-					if (!i2c_success)
-						/* Write failure */
-						ASSERT(i2c_success);
-				}
-			}
-		}
-	}
-
-	if (is_vga_mode) {
-		/* Program additional settings if using 640x480 resolution */
-
-		/* Write offset 0xFF to 0x01 */
-		buffer[0] = 0xff;
-		buffer[1] = 0x01;
-		i2c_success = i2c_write(pipe_ctx, slave_address,
-				buffer, sizeof(buffer));
-		if (!i2c_success)
-			/* Write failure */
-			ASSERT(i2c_success);
-
-		/* Write offset 0x00 to 0x23 */
-		buffer[0] = 0x00;
-		buffer[1] = 0x23;
-		i2c_success = i2c_write(pipe_ctx, slave_address,
-				buffer, sizeof(buffer));
-		if (!i2c_success)
-			/* Write failure */
-			ASSERT(i2c_success);
-
-		/* Write offset 0xff to 0x00 */
-		buffer[0] = 0xff;
-		buffer[1] = 0x00;
-		i2c_success = i2c_write(pipe_ctx, slave_address,
-				buffer, sizeof(buffer));
-		if (!i2c_success)
-			/* Write failure */
-			ASSERT(i2c_success);
-
-	}
-}
-
-static void write_i2c_default_retimer_setting(
-		struct pipe_ctx *pipe_ctx,
-		bool is_vga_mode,
-		bool is_over_340mhz)
-{
-	uint8_t slave_address = (0xBA >> 1);
-	uint8_t buffer[2];
-	bool i2c_success = false;
-
-	memset(&buffer, 0, sizeof(buffer));
-
-	/* Program Slave Address for tuning single integrity */
-	/* Write offset 0x0A to 0x13 */
-	buffer[0] = 0x0A;
-	buffer[1] = 0x13;
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-			buffer, sizeof(buffer));
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
-
-	/* Write offset 0x0A to 0x17 */
-	buffer[0] = 0x0A;
-	buffer[1] = 0x17;
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-			buffer, sizeof(buffer));
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
-
-	/* Write offset 0x0B to 0xDA or 0xD8 */
-	buffer[0] = 0x0B;
-	buffer[1] = is_over_340mhz ? 0xDA : 0xD8;
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-			buffer, sizeof(buffer));
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
-
-	/* Write offset 0x0A to 0x17 */
-	buffer[0] = 0x0A;
-	buffer[1] = 0x17;
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-			buffer, sizeof(buffer));
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
-
-	/* Write offset 0x0C to 0x1D or 0x91 */
-	buffer[0] = 0x0C;
-	buffer[1] = is_over_340mhz ? 0x1D : 0x91;
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-			buffer, sizeof(buffer));
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
-
-	/* Write offset 0x0A to 0x17 */
-	buffer[0] = 0x0A;
-	buffer[1] = 0x17;
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-			buffer, sizeof(buffer));
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
-
-
-	if (is_vga_mode) {
-		/* Program additional settings if using 640x480 resolution */
-
-		/* Write offset 0xFF to 0x01 */
-		buffer[0] = 0xff;
-		buffer[1] = 0x01;
-		i2c_success = i2c_write(pipe_ctx, slave_address,
-				buffer, sizeof(buffer));
-		if (!i2c_success)
-			/* Write failure */
-			ASSERT(i2c_success);
-
-		/* Write offset 0x00 to 0x23 */
-		buffer[0] = 0x00;
-		buffer[1] = 0x23;
-		i2c_success = i2c_write(pipe_ctx, slave_address,
-				buffer, sizeof(buffer));
-		if (!i2c_success)
-			/* Write failure */
-			ASSERT(i2c_success);
-
-		/* Write offset 0xff to 0x00 */
-		buffer[0] = 0xff;
-		buffer[1] = 0x00;
-		i2c_success = i2c_write(pipe_ctx, slave_address,
-				buffer, sizeof(buffer));
-		if (!i2c_success)
-			/* Write failure */
-			ASSERT(i2c_success);
-	}
-}
-
-static void write_i2c_redriver_setting(
-		struct pipe_ctx *pipe_ctx,
-		bool is_over_340mhz)
-{
-	uint8_t slave_address = (0xF0 >> 1);
-	uint8_t buffer[16];
-	bool i2c_success = false;
-
-	memset(&buffer, 0, sizeof(buffer));
-
-	// Program Slave Address for tuning single integrity
-	buffer[3] = 0x4E;
-	buffer[4] = 0x4E;
-	buffer[5] = 0x4E;
-	buffer[6] = is_over_340mhz ? 0x4E : 0x4A;
-
-	i2c_success = i2c_write(pipe_ctx, slave_address,
-					buffer, sizeof(buffer));
-
-	if (!i2c_success)
-		/* Write failure */
-		ASSERT(i2c_success);
+	return enable_link_dp(pipe_ctx);
 }
 
 static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
@@ -1660,32 +1269,6 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 	enum dc_color_depth display_color_depth;
-	enum engine_id eng_id;
-	struct ext_hdmi_settings settings = {0};
-	bool is_over_340mhz = false;
-	bool is_vga_mode = (stream->timing.h_addressable == 640)
-			&& (stream->timing.v_addressable == 480);
-
-	if (stream->phy_pix_clk > 340000)
-		is_over_340mhz = true;
-
-	if (dc_is_hdmi_signal(pipe_ctx->stream->signal)) {
-		if ((pipe_ctx->stream->sink->link->chip_caps >> 2) == 0x2) {
-			/* DP159, Retimer settings */
-			eng_id = pipe_ctx->stream_res.stream_enc->id;
-
-			if (get_ext_hdmi_settings(pipe_ctx, eng_id, &settings)) {
-				write_i2c_retimer_setting(pipe_ctx,
-						is_vga_mode, is_over_340mhz, &settings);
-			} else {
-				write_i2c_default_retimer_setting(pipe_ctx,
-						is_vga_mode, is_over_340mhz);
-			}
-		} else if ((pipe_ctx->stream->sink->link->chip_caps >> 2) == 0x1) {
-			/* PI3EQX1204, Redriver settings */
-			write_i2c_redriver_setting(pipe_ctx, is_over_340mhz);
-		}
-	}
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
 		dal_ddc_service_write_scdc_data(
@@ -1713,18 +1296,16 @@ static void enable_link_hdmi(struct pipe_ctx *pipe_ctx)
 }
 
 /****************************enable_link***********************************/
-static enum dc_status enable_link(
-		struct dc_state *state,
-		struct pipe_ctx *pipe_ctx)
+static enum dc_status enable_link(struct pipe_ctx *pipe_ctx)
 {
 	enum dc_status status = DC_ERROR_UNEXPECTED;
 	switch (pipe_ctx->stream->signal) {
 	case SIGNAL_TYPE_DISPLAY_PORT:
 	case SIGNAL_TYPE_EDP:
-		status = enable_link_dp(state, pipe_ctx);
+		status = enable_link_dp(pipe_ctx);
 		break;
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
-		status = enable_link_dp_mst(state, pipe_ctx);
+		status = enable_link_dp_mst(pipe_ctx);
 		msleep(200);
 		break;
 	case SIGNAL_TYPE_DVI_SINGLE_LINK:
@@ -1811,7 +1392,7 @@ enum dc_status dc_link_validate_mode_timing(
 bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
 		uint32_t frame_ramp, const struct dc_stream_state *stream)
 {
-	struct dc  *core_dc = link->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct abm *abm = core_dc->res_pool->abm;
 	unsigned int controller_id = 0;
 	int i;
@@ -1825,14 +1406,14 @@ bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
 	if (dc_is_embedded_signal(link->connector_signal)) {
 		if (stream != NULL) {
 			for (i = 0; i < MAX_PIPES; i++) {
-				if (core_dc->current_state->res_ctx.
+				if (core_dc->current_context->res_ctx.
 						pipe_ctx[i].stream
 						== stream)
 					/* DMCU -1 for all controller id values,
 					 * therefore +1 here
 					 */
 					controller_id =
-						core_dc->current_state->
+						core_dc->current_context->
 						res_ctx.pipe_ctx[i].stream_res.tg->inst +
 						1;
 			}
@@ -1850,7 +1431,7 @@ bool dc_link_set_backlight_level(const struct dc_link *link, uint32_t level,
 
 bool dc_link_set_abm_disable(const struct dc_link *link)
 {
-	struct dc  *core_dc = link->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct abm *abm = core_dc->res_pool->abm;
 
 	if ((abm == NULL) || (abm->funcs->set_backlight_level == NULL))
@@ -1862,20 +1443,20 @@ bool dc_link_set_abm_disable(const struct dc_link *link)
 }
 
 
-bool dc_link_set_psr_enable(const struct dc_link *link, bool enable, bool wait)
+bool dc_link_set_psr_enable(const struct dc_link *link, bool enable)
 {
-	struct dc  *core_dc = link->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 
 	if (dmcu != NULL && link->psr_enabled)
-		dmcu->funcs->set_psr_enable(dmcu, enable, wait);
+		dmcu->funcs->set_psr_enable(dmcu, enable);
 
 	return true;
 }
 
 bool dc_link_get_psr_state(const struct dc_link *link, uint32_t *psr_state)
 {
-	struct dc  *core_dc = link->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 
 	if (dmcu != NULL && link->psr_enabled)
@@ -1888,7 +1469,7 @@ bool dc_link_setup_psr(struct dc_link *link,
 		const struct dc_stream_state *stream, struct psr_config *psr_config,
 		struct psr_context *psr_context)
 {
-	struct dc  *core_dc = link->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(link->ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 	int i;
 
@@ -1932,13 +1513,13 @@ bool dc_link_setup_psr(struct dc_link *link,
 		psr_context->engineId = link->link_enc->preferred_engine;
 
 		for (i = 0; i < MAX_PIPES; i++) {
-			if (core_dc->current_state->res_ctx.pipe_ctx[i].stream
+			if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
 					== stream) {
 				/* dmcu -1 for all controller id values,
 				 * therefore +1 here
 				 */
 				psr_context->controllerId =
-					core_dc->current_state->res_ctx.
+					core_dc->current_context->res_ctx.
 					pipe_ctx[i].stream_res.tg->inst + 1;
 				break;
 			}
@@ -1983,7 +1564,7 @@ bool dc_link_setup_psr(struct dc_link *link,
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 		/*skip power down the single pipe since it blocks the cstate*/
 		if (ASIC_REV_IS_RAVEN(link->ctx->asic_id.hw_internal_rev))
-			psr_context->psr_level.bits.SKIP_CRTC_DISABLE = true;
+			psr_context->psr_level.bits.SKIP_SINGLE_OTG_DISABLE = true;
 #endif
 
 		/* SMU will perform additional powerdown sequence.
@@ -2291,13 +1872,11 @@ static enum dc_status deallocate_mst_payload(struct pipe_ctx *pipe_ctx)
 	return DC_OK;
 }
 
-void core_link_enable_stream(
-		struct dc_state *state,
-		struct pipe_ctx *pipe_ctx)
+void core_link_enable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct dc  *core_dc = pipe_ctx->stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(pipe_ctx->stream->ctx->dc);
 
-	enum dc_status status = enable_link(state, pipe_ctx);
+	enum dc_status status = enable_link(pipe_ctx);
 
 	if (status != DC_OK) {
 			dm_logger_write(pipe_ctx->stream->ctx->logger,
@@ -2328,7 +1907,7 @@ void core_link_enable_stream(
 
 void core_link_disable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct dc  *core_dc = pipe_ctx->stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(pipe_ctx->stream->ctx->dc);
 
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)
 		deallocate_mst_payload(pipe_ctx);
@@ -2340,7 +1919,7 @@ void core_link_disable_stream(struct pipe_ctx *pipe_ctx)
 
 void core_link_set_avmute(struct pipe_ctx *pipe_ctx, bool enable)
 {
-	struct dc  *core_dc = pipe_ctx->stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(pipe_ctx->stream->ctx->dc);
 
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_HDMI_TYPE_A)
 		return;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 527cc04..9d5fe65 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -10,6 +10,7 @@
 #include "core_status.h"
 #include "dpcd_defs.h"
 
+#include "core_dc.h"
 #include "resource.h"
 
 /* maximum pre emphasis level allowed for each voltage swing level*/
@@ -1302,6 +1303,8 @@ bool decide_fallback_link_setting(
 					current_link_setting->lane_count);
 		} else if (!reached_minimum_link_rate
 				(current_link_setting->link_rate)) {
+			current_link_setting->lane_count =
+				initial_link_settings.lane_count;
 			current_link_setting->link_rate =
 				reduce_link_rate(
 					current_link_setting->link_rate);
@@ -1457,14 +1460,6 @@ void decide_link_settings(struct dc_stream_state *stream,
 		return;
 	}
 
-	/* MST doesn't perform link training for now
-	 * TODO: add MST specific link training routine
-	 */
-	if (is_mst_supported(link)) {
-		*link_setting = link->verified_link_cap;
-		return;
-	}
-
     /* search for the minimum link setting that:
      * 1. is supported according to the link training result
      * 2. could support the b/w requested by the timing
@@ -1653,8 +1648,8 @@ static bool handle_hpd_irq_psr_sink(const struct dc_link *link)
 				sizeof(psr_error_status.raw));
 
 			/* PSR error, disable and re-enable PSR */
-			dc_link_set_psr_enable(link, false, true);
-			dc_link_set_psr_enable(link, true, true);
+			dc_link_set_psr_enable(link, false);
+			dc_link_set_psr_enable(link, true);
 
 			return true;
 		} else if (psr_sink_psr_status.bits.SINK_SELF_REFRESH_STATUS ==
@@ -1962,11 +1957,11 @@ bool dc_link_handle_hpd_rx_irq(struct dc_link *link, union hpd_irq_data *out_hpd
 	 * so do not handle as a normal sink status change interrupt.
 	 */
 
-	if (hpd_irq_dpcd_data.bytes.device_service_irq.bits.UP_REQ_MSG_RDY)
-		return true;
-
 	/* check if we have MST msg and return since we poll for it */
-	if (hpd_irq_dpcd_data.bytes.device_service_irq.bits.DOWN_REP_MSG_RDY)
+	if (hpd_irq_dpcd_data.bytes.device_service_irq.
+			bits.DOWN_REP_MSG_RDY ||
+		hpd_irq_dpcd_data.bytes.device_service_irq.
+			bits.UP_REQ_MSG_RDY)
 		return false;
 
 	/* For now we only handle 'Downstream port status' case.
@@ -2264,8 +2259,6 @@ static void retrieve_link_cap(struct dc_link *link)
 		DP_EDP_CONFIGURATION_CAP - DP_DPCD_REV];
 	link->dpcd_caps.panel_mode_edp =
 		edp_config_cap.bits.ALT_SCRAMBLER_RESET;
-	link->dpcd_caps.dpcd_display_control_capable =
-		edp_config_cap.bits.DPCD_DISPLAY_CONTROL_CAPABLE;
 
 	link->test_pattern_enabled = false;
 	link->compliance_test_state.raw = 0;
@@ -2406,7 +2399,7 @@ bool dc_link_dp_set_test_pattern(
 	const unsigned char *p_custom_pattern,
 	unsigned int cust_pattern_size)
 {
-	struct pipe_ctx *pipes = link->dc->current_state->res_ctx.pipe_ctx;
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
 	struct pipe_ctx *pipe_ctx = &pipes[0];
 	unsigned int lane;
 	unsigned int i;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 3427fb5..d19c663 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -3,7 +3,7 @@
 
 #include "dm_services.h"
 #include "dc.h"
-#include "inc/core_types.h"
+#include "inc/core_dc.h"
 #include "include/ddc_service_types.h"
 #include "include/i2caux_interface.h"
 #include "link_hwss.h"
@@ -62,7 +62,7 @@ void dp_enable_link_phy(
 	struct link_encoder *link_enc = link->link_enc;
 
 	struct pipe_ctx *pipes =
-			link->dc->current_state->res_ctx.pipe_ctx;
+			link->dc->current_context->res_ctx.pipe_ctx;
 	struct clock_source *dp_cs =
 			link->dc->res_pool->dp_clock_source;
 	unsigned int i;
@@ -110,28 +110,6 @@ void dp_enable_link_phy(
 	dp_receiver_power_ctrl(link, true);
 }
 
-bool edp_receiver_ready_T9(struct dc_link *link)
-{
-	unsigned int tries = 0;
-	unsigned char sinkstatus = 0;
-	unsigned char edpRev = 0;
-	enum dc_status result = DC_OK;
-	result = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));
-	if (edpRev < DP_EDP_12)
-		return true;
-	/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
-	do {
-		sinkstatus = 1;
-		result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
-		if (sinkstatus == 0)
-			break;
-		if (result != DC_OK)
-			break;
-		dm_delay_in_microseconds(link->ctx, 100); //MAx T9
-	} while (++tries < 50);
-	return result;
-}
-
 void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {
 	if (!link->wa_flags.dp_keep_receiver_powered)
@@ -139,7 +117,6 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->backlight_control(link->link_enc, false);
-		edp_receiver_ready_T9(link);
 		link->link_enc->funcs->disable_output(link->link_enc, signal);
 		link->link_enc->funcs->power_control(link->link_enc, false);
 	} else
@@ -262,7 +239,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 			bool skip_video_pattern)
 {
 	struct pipe_ctx *pipes =
-			&link->dc->current_state->res_ctx.pipe_ctx[0];
+			&link->dc->current_context->res_ctx.pipe_ctx[0];
 	unsigned int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -299,11 +276,10 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			dp_receiver_power_ctrl(link, true);
 
-			perform_link_training_with_retries(
+			dc_link_dp_perform_link_training(
 					link,
 					link_setting,
-					skip_video_pattern,
-					LINK_TRAINING_ATTEMPTS);
+					skip_video_pattern);
 
 			link->cur_link_settings = *link_setting;
 
@@ -311,20 +287,6 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			link->dc->hwss.unblank_stream(&pipes[i],
 					link_setting);
-
-			if (pipes[i].stream_res.audio) {
-				/* notify audio driver for
-				 * audio modes of monitor */
-				pipes[i].stream_res.audio->funcs->az_enable(
-						pipes[i].stream_res.audio);
-
-				/* un-mute audio */
-				/* TODO: audio should be per stream rather than
-				 * per link */
-				pipes[i].stream_res.stream_enc->funcs->
-				audio_mute_control(
-					pipes[i].stream_res.stream_enc, false);
-			}
 		}
 	}
 }
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 8e60e83..f010039 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -92,7 +92,7 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 }
 
 struct resource_pool *dc_create_resource_pool(
-				struct dc  *dc,
+				struct core_dc *dc,
 				int num_virtual_links,
 				enum dce_version dc_version,
 				struct hw_asic_id asic_id)
@@ -132,7 +132,7 @@ struct resource_pool *dc_create_resource_pool(
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case DCN_VERSION_1_0:
 		res_pool = dcn10_create_resource_pool(
-				num_virtual_links, dc);
+			num_virtual_links, dc);
 		break;
 #endif
 
@@ -153,7 +153,7 @@ struct resource_pool *dc_create_resource_pool(
 	return res_pool;
 }
 
-void dc_destroy_resource_pool(struct dc  *dc)
+void dc_destroy_resource_pool(struct core_dc *dc)
 {
 	if (dc) {
 		if (dc->res_pool)
@@ -169,14 +169,16 @@ static void update_num_audio(
 	unsigned int *num_audio,
 	struct audio_support *aud_support)
 {
-	aud_support->dp_audio = true;
-	aud_support->hdmi_audio_native = false;
-	aud_support->hdmi_audio_on_dongle = false;
-
 	if (straps->hdmi_disable == 0) {
+		aud_support->hdmi_audio_native = true;
+		aud_support->hdmi_audio_on_dongle = true;
+		aud_support->dp_audio = true;
+	} else {
 		if (straps->dc_pinstraps_audio & 0x2) {
 			aud_support->hdmi_audio_on_dongle = true;
-			aud_support->hdmi_audio_native = true;
+			aud_support->dp_audio = true;
+		} else {
+			aud_support->dp_audio = true;
 		}
 	}
 
@@ -193,7 +195,7 @@ static void update_num_audio(
 
 bool resource_construct(
 	unsigned int num_virtual_links,
-	struct dc  *dc,
+	struct core_dc *dc,
 	struct resource_pool *pool,
 	const struct resource_create_funcs *create_funcs)
 {
@@ -892,8 +894,8 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 
 enum dc_status resource_build_scaling_params_for_context(
-	const struct dc  *dc,
-	struct dc_state *context)
+	const struct core_dc *dc,
+	struct validate_context *context)
 {
 	int i;
 
@@ -938,7 +940,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				!res_ctx->pipe_ctx[i].top_pipe) {
+				res_ctx->pipe_ctx[i].stream_res.stream_enc) {
 			return &res_ctx->pipe_ctx[i];
 			break;
 		}
@@ -946,32 +948,12 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	return NULL;
 }
 
-static struct pipe_ctx *resource_get_tail_pipe_for_stream(
-		struct resource_context *res_ctx,
-		struct dc_stream_state *stream)
-{
-	struct pipe_ctx *head_pipe, *tail_pipe;
-	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
-
-	if (!head_pipe)
-		return NULL;
-
-	tail_pipe = head_pipe->bottom_pipe;
-
-	while (tail_pipe) {
-		head_pipe = tail_pipe;
-		tail_pipe = tail_pipe->bottom_pipe;
-	}
-
-	return head_pipe;
-}
-
 /*
  * A free_pipe for a stream is defined here as a pipe
  * that has no surface attached yet
  */
 static struct pipe_ctx *acquire_free_pipe_for_stream(
-		struct dc_state *context,
+		struct validate_context *context,
 		const struct resource_pool *pool,
 		struct dc_stream_state *stream)
 {
@@ -1010,6 +992,22 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 }
 
+static void release_free_pipes_for_stream(
+		struct resource_context *res_ctx,
+		struct dc_stream_state *stream)
+{
+	int i;
+
+	for (i = MAX_PIPES - 1; i >= 0; i--) {
+		/* never release the topmost pipe*/
+		if (res_ctx->pipe_ctx[i].stream == stream &&
+				res_ctx->pipe_ctx[i].top_pipe &&
+				!res_ctx->pipe_ctx[i].plane_state) {
+			memset(&res_ctx->pipe_ctx[i], 0, sizeof(struct pipe_ctx));
+		}
+	}
+}
+
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
@@ -1033,6 +1031,7 @@ static int acquire_first_split_pipe(
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -1043,236 +1042,97 @@ static int acquire_first_split_pipe(
 }
 #endif
 
-bool dc_add_plane_to_context(
-		const struct dc *dc,
+bool resource_attach_surfaces_to_context(
+		struct dc_plane_state * const *plane_states,
+		int surface_count,
 		struct dc_stream_state *stream,
-		struct dc_plane_state *plane_state,
-		struct dc_state *context)
+		struct validate_context *context,
+		const struct resource_pool *pool)
 {
 	int i;
-	struct resource_pool *pool = dc->res_pool;
-	struct pipe_ctx *head_pipe, *tail_pipe, *free_pipe;
+	struct pipe_ctx *tail_pipe;
 	struct dc_stream_status *stream_status = NULL;
 
-	for (i = 0; i < context->stream_count; i++)
-		if (context->streams[i] == stream) {
-			stream_status = &context->stream_status[i];
-			break;
-		}
-	if (stream_status == NULL) {
-		dm_error("Existing stream not found; failed to attach surface!\n");
-		return false;
-	}
-
-
-	if (stream_status->plane_count == MAX_SURFACE_NUM) {
-		dm_error("Surface: can not attach plane_state %p! Maximum is: %d\n",
-				plane_state, MAX_SURFACE_NUM);
-		return false;
-	}
-
-	head_pipe = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
 
-	if (!head_pipe) {
-		dm_error("Head pipe not found for stream_state %p !\n", stream);
-		return false;
-	}
-
-	/* retain new surfaces */
-	dc_plane_state_retain(plane_state);
-
-	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
-
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (!free_pipe) {
-		int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
-		if (pipe_idx >= 0)
-			free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
-	}
-#endif
-	if (!free_pipe) {
-		stream_status->plane_states[i] = NULL;
+	if (surface_count > MAX_SURFACE_NUM) {
+		dm_error("Surface: can not attach %d surfaces! Maximum is: %d\n",
+			surface_count, MAX_SURFACE_NUM);
 		return false;
 	}
 
-	free_pipe->plane_state = plane_state;
-
-	if (head_pipe != free_pipe) {
-
-		tail_pipe = resource_get_tail_pipe_for_stream(&context->res_ctx, stream);
-		ASSERT(tail_pipe);
-
-		free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
-		free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
-		free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
-		free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
-		free_pipe->clock_source = tail_pipe->clock_source;
-		free_pipe->top_pipe = tail_pipe;
-		tail_pipe->bottom_pipe = free_pipe;
-	}
-
-	/* assign new surfaces*/
-	stream_status->plane_states[stream_status->plane_count] = plane_state;
-
-	stream_status->plane_count++;
-
-	return true;
-}
-
-bool dc_remove_plane_from_context(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_plane_state *plane_state,
-		struct dc_state *context)
-{
-	int i;
-	struct dc_stream_status *stream_status = NULL;
-	struct resource_pool *pool = dc->res_pool;
-
 	for (i = 0; i < context->stream_count; i++)
 		if (context->streams[i] == stream) {
 			stream_status = &context->stream_status[i];
 			break;
 		}
-
 	if (stream_status == NULL) {
-		dm_error("Existing stream not found; failed to remove plane.\n");
+		dm_error("Existing stream not found; failed to attach surfaces\n");
 		return false;
 	}
 
-	/* release pipe for plane*/
-	for (i = pool->pipe_count - 1; i >= 0; i--) {
-		struct pipe_ctx *pipe_ctx;
-
-		if (context->res_ctx.pipe_ctx[i].plane_state == plane_state) {
-			pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-			if (pipe_ctx->top_pipe)
-				pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
-
-			/* Second condition is to avoid setting NULL to top pipe
-			 * of tail pipe making it look like head pipe in subsequent
-			 * deletes
-			 */
-			if (pipe_ctx->bottom_pipe && pipe_ctx->top_pipe)
-				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
-
-			/*
-			 * For head pipe detach surfaces from pipe for tail
-			 * pipe just zero it out
-			 */
-			if (!pipe_ctx->top_pipe) {
-				pipe_ctx->plane_state = NULL;
-				pipe_ctx->bottom_pipe = NULL;
-			} else  {
-				memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-			}
-		}
-	}
-
-
-	for (i = 0; i < stream_status->plane_count; i++) {
-		if (stream_status->plane_states[i] == plane_state) {
-
-			dc_plane_state_release(stream_status->plane_states[i]);
-			break;
+	/* retain new surfaces */
+	for (i = 0; i < surface_count; i++)
+		dc_plane_state_retain(plane_states[i]);
+
+	/* detach surfaces from pipes */
+	for (i = 0; i < pool->pipe_count; i++)
+		if (context->res_ctx.pipe_ctx[i].stream == stream) {
+			context->res_ctx.pipe_ctx[i].plane_state = NULL;
+			context->res_ctx.pipe_ctx[i].bottom_pipe = NULL;
 		}
-	}
-
-	if (i == stream_status->plane_count) {
-		dm_error("Existing plane_state not found; failed to detach it!\n");
-		return false;
-	}
-
-	stream_status->plane_count--;
 
-	/* Trim back arrays */
+	/* release existing surfaces*/
 	for (i = 0; i < stream_status->plane_count; i++)
-		stream_status->plane_states[i] = stream_status->plane_states[i + 1];
-
-	stream_status->plane_states[stream_status->plane_count] = NULL;
-
-	return true;
-}
+		dc_plane_state_release(stream_status->plane_states[i]);
 
-bool dc_rem_all_planes_for_stream(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_state *context)
-{
-	int i, old_plane_count;
-	struct dc_stream_status *stream_status = NULL;
-	struct dc_plane_state *del_planes[MAX_SURFACE_NUM] = { 0 };
-
-	for (i = 0; i < context->stream_count; i++)
-			if (context->streams[i] == stream) {
-				stream_status = &context->stream_status[i];
-				break;
-			}
-
-	if (stream_status == NULL) {
-		dm_error("Existing stream %p not found!\n", stream);
-		return false;
-	}
-
-	old_plane_count = stream_status->plane_count;
+	for (i = surface_count; i < stream_status->plane_count; i++)
+		stream_status->plane_states[i] = NULL;
 
-	for (i = 0; i < old_plane_count; i++)
-		del_planes[i] = stream_status->plane_states[i];
+	tail_pipe = NULL;
+	for (i = 0; i < surface_count; i++) {
+		struct dc_plane_state *plane_state = plane_states[i];
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
+				context, pool, stream);
 
-	for (i = 0; i < old_plane_count; i++)
-		if (!dc_remove_plane_from_context(dc, stream, del_planes[i], context))
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		if (!free_pipe) {
+			int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+			if (pipe_idx >= 0)
+				free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
+		}
+#endif
+		if (!free_pipe) {
+			stream_status->plane_states[i] = NULL;
 			return false;
+		}
 
-	return true;
-}
-
-static bool add_all_planes_for_stream(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		const struct dc_validation_set set[],
-		int set_count,
-		struct dc_state *context)
-{
-	int i, j;
+		free_pipe->plane_state = plane_state;
 
-	for (i = 0; i < set_count; i++)
-		if (set[i].stream == stream)
-			break;
+		if (tail_pipe) {
+			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
+			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
+			free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
+			free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
+			free_pipe->clock_source = tail_pipe->clock_source;
+			free_pipe->top_pipe = tail_pipe;
+			tail_pipe->bottom_pipe = free_pipe;
+		}
 
-	if (i == set_count) {
-		dm_error("Stream %p not found in set!\n", stream);
-		return false;
+		tail_pipe = free_pipe;
 	}
 
-	for (j = 0; j < set[i].plane_count; j++)
-		if (!dc_add_plane_to_context(dc, stream, set[i].plane_states[j], context))
-			return false;
-
-	return true;
-}
+	release_free_pipes_for_stream(&context->res_ctx, stream);
 
-bool dc_add_all_planes_for_stream(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_plane_state * const *plane_states,
-		int plane_count,
-		struct dc_state *context)
-{
-	struct dc_validation_set set;
-	int i;
-
-	set.stream = stream;
-	set.plane_count = plane_count;
+	/* assign new surfaces*/
+	for (i = 0; i < surface_count; i++)
+		stream_status->plane_states[i] = plane_states[i];
 
-	for (i = 0; i < plane_count; i++)
-		set.plane_states[i] = plane_states[i];
+	stream_status->plane_count = surface_count;
 
-	return add_all_planes_for_stream(dc, stream, &set, 1, context);
+	return true;
 }
 
 
-
 static bool is_timing_changed(struct dc_stream_state *cur_stream,
 		struct dc_stream_state *new_stream)
 {
@@ -1320,34 +1180,68 @@ bool dc_is_stream_unchanged(
 	return true;
 }
 
+bool resource_validate_attach_surfaces(
+		const struct dc_validation_set set[],
+		int set_count,
+		const struct validate_context *old_context,
+		struct validate_context *context,
+		const struct resource_pool *pool)
+{
+	int i, j;
+
+	for (i = 0; i < set_count; i++) {
+		for (j = 0; old_context && j < old_context->stream_count; j++)
+			if (dc_is_stream_unchanged(
+					old_context->streams[j],
+					context->streams[i])) {
+				if (!resource_attach_surfaces_to_context(
+						old_context->stream_status[j].plane_states,
+						old_context->stream_status[j].plane_count,
+						context->streams[i],
+						context, pool))
+					return false;
+				context->stream_status[i] = old_context->stream_status[j];
+			}
+		if (set[i].plane_count != 0)
+			if (!resource_attach_surfaces_to_context(
+					set[i].plane_states,
+					set[i].plane_count,
+					context->streams[i],
+					context, pool))
+				return false;
+
+	}
+
+	return true;
+}
+
 /* Maximum TMDS single link pixel clock 165MHz */
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
+#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
 
-static void update_stream_engine_usage(
+static void set_stream_engine_in_use(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct stream_encoder *stream_enc,
-		bool acquired)
+		struct stream_encoder *stream_enc)
 {
 	int i;
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] == stream_enc)
-			res_ctx->is_stream_enc_acquired[i] = acquired;
+			res_ctx->is_stream_enc_acquired[i] = true;
 	}
 }
 
 /* TODO: release audio object */
-static void update_audio_usage(
+static void set_audio_in_use(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct audio *audio,
-		bool acquired)
+		struct audio *audio)
 {
 	int i;
 	for (i = 0; i < pool->audio_count; i++) {
 		if (pool->audios[i] == audio)
-			res_ctx->is_audio_acquired[i] = acquired;
+			res_ctx->is_audio_acquired[i] = true;
 	}
 }
 
@@ -1367,6 +1261,7 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 
@@ -1431,110 +1326,41 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-bool resource_is_stream_unchanged(
-	struct dc_state *old_context, struct dc_stream_state *stream)
+static void update_stream_signal(struct dc_stream_state *stream)
 {
-	int i;
+	if (stream->output_signal == SIGNAL_TYPE_NONE) {
+		struct dc_sink *dc_sink = stream->sink;
 
-	for (i = 0; i < old_context->stream_count; i++) {
-		struct dc_stream_state *old_stream = old_context->streams[i];
-
-		if (are_stream_backends_same(old_stream, stream))
-				return true;
+		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
+			stream->signal = stream->sink->link->connector_signal;
+		else
+			stream->signal = dc_sink->sink_signal;
+	} else {
+		stream->signal = stream->output_signal;
 	}
 
-	return false;
-}
-
-bool dc_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *stream)
-{
-	struct dc_context *dc_ctx = dc->ctx;
-	enum dc_status res;
-
-	if (new_ctx->stream_count >= dc->res_pool->pipe_count) {
-		DC_ERROR("Max streams reached, can add stream %p !\n", stream);
-		return DC_ERROR_UNEXPECTED;
+	if (dc_is_dvi_signal(stream->signal)) {
+		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+		else
+			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
 	}
-
-	new_ctx->streams[new_ctx->stream_count] = stream;
-	dc_stream_retain(stream);
-	new_ctx->stream_count++;
-
-	res = dc->res_pool->funcs->add_stream_to_ctx(dc, new_ctx, stream);
-	if (res != DC_OK)
-		DC_ERROR("Adding stream %p to context failed with err %d!\n", stream, res);
-
-	return res == DC_OK;
 }
 
-bool dc_remove_stream_from_ctx(
-			struct dc *dc,
-			struct dc_state *new_ctx,
-			struct dc_stream_state *stream)
+bool resource_is_stream_unchanged(
+	struct validate_context *old_context, struct dc_stream_state *stream)
 {
 	int i;
-	struct dc_context *dc_ctx = dc->ctx;
-	struct pipe_ctx *del_pipe = NULL;
-
-	/* Release primary pipe */
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream &&
-				!new_ctx->res_ctx.pipe_ctx[i].top_pipe) {
-			del_pipe = &new_ctx->res_ctx.pipe_ctx[i];
-
-			ASSERT(del_pipe->stream_res.stream_enc);
-			update_stream_engine_usage(
-					&new_ctx->res_ctx,
-						dc->res_pool,
-					del_pipe->stream_res.stream_enc,
-					false);
-
-			if (del_pipe->stream_res.audio)
-				update_audio_usage(
-					&new_ctx->res_ctx,
-					dc->res_pool,
-					del_pipe->stream_res.audio,
-					false);
-
-			memset(del_pipe, 0, sizeof(*del_pipe));
-
-			break;
-		}
-	}
 
-	if (!del_pipe) {
-		DC_ERROR("Pipe not found for stream %p !\n", stream);
-		return DC_ERROR_UNEXPECTED;
-	}
-
-	for (i = 0; i < new_ctx->stream_count; i++)
-		if (new_ctx->streams[i] == stream)
-			break;
-
-	if (new_ctx->streams[i] != stream) {
-		DC_ERROR("Context doesn't have stream %p !\n", stream);
-		return DC_ERROR_UNEXPECTED;
-	}
-
-	dc_stream_release(new_ctx->streams[i]);
-	new_ctx->stream_count--;
+	for (i = 0; i < old_context->stream_count; i++) {
+		struct dc_stream_state *old_stream = old_context->streams[i];
 
-	/* Trim back arrays */
-	for (; i < new_ctx->stream_count; i++) {
-		new_ctx->streams[i] = new_ctx->streams[i + 1];
-		new_ctx->stream_status[i] = new_ctx->stream_status[i + 1];
+		if (are_stream_backends_same(old_stream, stream))
+				return true;
 	}
 
-	new_ctx->streams[new_ctx->stream_count] = NULL;
-	memset(
-			&new_ctx->stream_status[new_ctx->stream_count],
-			0,
-			sizeof(new_ctx->stream_status[0]));
-
-	return DC_OK;
+	return false;
 }
 
 static void copy_pipe_ctx(
@@ -1551,7 +1377,7 @@ static void copy_pipe_ctx(
 
 static struct dc_stream_state *find_pll_sharable_stream(
 		struct dc_stream_state *stream_needs_pll,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	int i;
 
@@ -1602,6 +1428,8 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 
 static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 {
+	update_stream_signal(stream);
+
 	/* update actual pixel clock on all streams */
 	if (dc_is_hdmi_signal(stream->signal))
 		stream->phy_pix_clk = get_norm_pix_clk(
@@ -1612,18 +1440,17 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 }
 
 enum dc_status resource_map_pool_resources(
-		const struct dc  *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	const struct resource_pool *pool = dc->res_pool;
-	int i;
-	struct dc_context *dc_ctx = dc->ctx;
-	struct pipe_ctx *pipe_ctx = NULL;
-	int pipe_idx = -1;
+	int i, j;
+
+	for (i = 0; old_context && i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
 
-	/* TODO Check if this is needed */
-	/*if (!resource_is_stream_unchanged(old_context, stream)) {
+		if (!resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
 				stream->bit_depth_params =
 						old_context->streams[i]->bit_depth_params;
@@ -1631,63 +1458,104 @@ enum dc_status resource_map_pool_resources(
 				continue;
 			}
 		}
-	*/
 
-	/* acquire new resources */
-	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
+		/* mark resources used for stream that is already active */
+		for (j = 0; j < pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
+			const struct pipe_ctx *old_pipe_ctx =
+					&old_context->res_ctx.pipe_ctx[j];
+
+			if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
+				continue;
+
+			if (old_pipe_ctx->top_pipe)
+				continue;
+
+			pipe_ctx->stream = stream;
+			copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
+
+			/* Split pipe resource, do not acquire back end */
+			if (!pipe_ctx->stream_res.stream_enc)
+				continue;
+
+			set_stream_engine_in_use(
+				&context->res_ctx, pool,
+				pipe_ctx->stream_res.stream_enc);
+
+			/* Switch to dp clock source only if there is
+			 * no non dp stream that shares the same timing
+			 * with the dp stream.
+			 */
+			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
+				!find_pll_sharable_stream(stream, context))
+				pipe_ctx->clock_source = pool->dp_clock_source;
 
+			resource_reference_clock_source(
+				&context->res_ctx, pool,
+				pipe_ctx->clock_source);
+
+			set_audio_in_use(&context->res_ctx, pool,
+					pipe_ctx->stream_res.audio);
+		}
+	}
+
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
+		struct pipe_ctx *pipe_ctx = NULL;
+		int pipe_idx = -1;
+
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
+		/* acquire new resources */
+		pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (pipe_idx < 0)
-		acquire_first_split_pipe(&context->res_ctx, pool, stream);
+		if (pipe_idx < 0)
+			acquire_first_split_pipe(&context->res_ctx, pool, stream);
 #endif
-	if (pipe_idx < 0)
-		return DC_NO_CONTROLLER_RESOURCE;
-
-	pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
-
-	pipe_ctx->stream_res.stream_enc =
-		find_first_free_match_stream_enc_for_link(
-			&context->res_ctx, pool, stream);
-
-	if (!pipe_ctx->stream_res.stream_enc)
-		return DC_NO_STREAM_ENG_RESOURCE;
-
-	update_stream_engine_usage(
-		&context->res_ctx, pool,
-		pipe_ctx->stream_res.stream_enc,
-		true);
-
-	/* TODO: Add check if ASIC support and EDID audio */
-	if (!stream->sink->converter_disable_audio &&
-	    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
-	    stream->audio_info.mode_count) {
-		pipe_ctx->stream_res.audio = find_first_free_audio(
-		&context->res_ctx, pool);
-
-		/*
-		 * Audio assigned in order first come first get.
-		 * There are asics which has number of audio
-		 * resources less then number of pipes
-		 */
-		if (pipe_ctx->stream_res.audio)
-			update_audio_usage(&context->res_ctx, pool,
-					   pipe_ctx->stream_res.audio, true);
-	}
+		if (pipe_idx < 0)
+			return DC_NO_CONTROLLER_RESOURCE;
 
-	for (i = 0; i < context->stream_count; i++)
-		if (context->streams[i] == stream) {
-			context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
-			context->stream_status[i].stream_enc_inst = pipe_ctx->stream_res.stream_enc->id;
-			return DC_OK;
+		pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
+
+		pipe_ctx->stream_res.stream_enc =
+			find_first_free_match_stream_enc_for_link(
+				&context->res_ctx, pool, stream);
+
+		if (!pipe_ctx->stream_res.stream_enc)
+			return DC_NO_STREAM_ENG_RESOURCE;
+
+		set_stream_engine_in_use(
+			&context->res_ctx, pool,
+			pipe_ctx->stream_res.stream_enc);
+
+		/* TODO: Add check if ASIC support and EDID audio */
+		if (!stream->sink->converter_disable_audio &&
+			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
+			stream->audio_info.mode_count) {
+			pipe_ctx->stream_res.audio = find_first_free_audio(
+				&context->res_ctx, pool);
+
+			/*
+			 * Audio assigned in order first come first get.
+			 * There are asics which has number of audio
+			 * resources less then number of pipes
+			 */
+			if (pipe_ctx->stream_res.audio)
+				set_audio_in_use(
+					&context->res_ctx, pool,
+					pipe_ctx->stream_res.audio);
 		}
 
-	DC_ERROR("Stream %p not found in new ctx!\n", stream);
-	return DC_ERROR_UNEXPECTED;
+		context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
+	}
+
+	return DC_OK;
 }
 
 /* first stream in the context is used to populate the rest */
 void validate_guaranteed_copy_streams(
-		struct dc_state *context,
+		struct validate_context *context,
 		int max_streams)
 {
 	int i;
@@ -1705,79 +1573,6 @@ void validate_guaranteed_copy_streams(
 	}
 }
 
-void dc_resource_state_copy_construct_current(
-		const struct dc *dc,
-		struct dc_state *dst_ctx)
-{
-	dc_resource_state_copy_construct(dc->current_state, dst_ctx);
-}
-
-
-void dc_resource_state_construct(
-		const struct dc *dc,
-		struct dc_state *dst_ctx)
-{
-	dst_ctx->dis_clk = dc->res_pool->display_clock;
-}
-
-bool dc_validate_global_state(
-		struct dc *dc,
-		struct dc_state *new_ctx)
-{
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	int i, j;
-
-	if (dc->res_pool->funcs->validate_global &&
-			dc->res_pool->funcs->validate_global(
-			dc, new_ctx) != DC_OK)
-		return false;
-
-	/* TODO without this SWDEV-114774 brakes */
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];
-
-		if (pipe_ctx->top_pipe)
-			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-	}
-
-	for (i = 0; new_ctx && i < new_ctx->stream_count; i++) {
-		struct dc_stream_state *stream = new_ctx->streams[i];
-
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[j];
-
-			if (pipe_ctx->stream != stream)
-				continue;
-
-			/* Switch to dp clock source only if there is
-			 * no non dp stream that shares the same timing
-			 * with the dp stream.
-			 */
-			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
-				!find_pll_sharable_stream(stream, new_ctx)) {
-
-				resource_unreference_clock_source(
-						&new_ctx->res_ctx,
-						dc->res_pool,
-						&pipe_ctx->clock_source);
-				pipe_ctx->clock_source = dc->res_pool->dp_clock_source;
-				resource_reference_clock_source(
-						&new_ctx->res_ctx,
-						dc->res_pool,
-						 pipe_ctx->clock_source);
-			}
-		}
-	}
-
-	result = resource_build_scaling_params_for_context(dc, new_ctx);
-
-	if (result == DC_OK)
-		if (!dc->res_pool->funcs->validate_bandwidth(dc, new_ctx))
-			result = DC_FAIL_BANDWIDTH_VALIDATE;
-
-	return result;
-}
-
 static void patch_gamut_packet_checksum(
 		struct encoder_info_packet *gamut_packet)
 {
@@ -2419,7 +2214,7 @@ static void set_vsc_info_packet(
 	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
 }
 
-void dc_resource_state_destruct(struct dc_state *context)
+void dc_resource_validate_ctx_destruct(struct validate_context *context)
 {
 	int i, j;
 
@@ -2438,12 +2233,12 @@ void dc_resource_state_destruct(struct dc_state *context)
  * Copy src_ctx into dst_ctx and retain all surfaces and streams referenced
  * by the src_ctx
  */
-void dc_resource_state_copy_construct(
-		const struct dc_state *src_ctx,
-		struct dc_state *dst_ctx)
+void dc_resource_validate_ctx_copy_construct(
+		const struct validate_context *src_ctx,
+		struct validate_context *dst_ctx)
 {
 	int i, j;
-	atomic_t ref_count = dst_ctx->ref_count;
+	int ref_count = dst_ctx->ref_count;
 
 	*dst_ctx = *src_ctx;
 
@@ -2523,42 +2318,56 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 }
 
 enum dc_status resource_map_clock_resources(
-		const struct dc  *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
-	/* acquire new resources */
+	int i, j;
 	const struct resource_pool *pool = dc->res_pool;
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(
-				&context->res_ctx, stream);
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+	/* acquire new resources */
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
 
-	if (dc_is_dp_signal(pipe_ctx->stream->signal)
-		|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
-		pipe_ctx->clock_source = pool->dp_clock_source;
-	else {
-		pipe_ctx->clock_source = NULL;
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
 
-		if (!dc->config.disable_disp_pll_sharing)
-			pipe_ctx->clock_source = resource_find_used_clk_src_for_sharing(
-				&context->res_ctx,
-				pipe_ctx);
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
 
-		if (pipe_ctx->clock_source == NULL)
-			pipe_ctx->clock_source =
-				dc_resource_find_first_free_pll(
-					&context->res_ctx,
-					pool);
-	}
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-	if (pipe_ctx->clock_source == NULL)
-		return DC_NO_CLOCK_SOURCE_RESOURCE;
+			if (dc_is_dp_signal(pipe_ctx->stream->signal)
+				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
+				pipe_ctx->clock_source = pool->dp_clock_source;
+			else {
+				pipe_ctx->clock_source = NULL;
+
+				if (!dc->public.config.disable_disp_pll_sharing)
+					resource_find_used_clk_src_for_sharing(
+						&context->res_ctx,
+						pipe_ctx);
+
+				if (pipe_ctx->clock_source == NULL)
+					pipe_ctx->clock_source =
+						dc_resource_find_first_free_pll(
+							&context->res_ctx,
+							pool);
+			}
+
+			if (pipe_ctx->clock_source == NULL)
+				return DC_NO_CLOCK_SOURCE_RESOURCE;
 
-	resource_reference_clock_source(
-		&context->res_ctx, pool,
-		pipe_ctx->clock_source);
+			resource_reference_clock_source(
+				&context->res_ctx, pool,
+				pipe_ctx->clock_source);
+
+			/* only one cs per stream regardless of mpo */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
@@ -2708,9 +2517,10 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
+bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream)
 {
-	struct dc  *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_context *dc_ctx = core_dc->ctx;
 	struct dc_link *link = stream->sink->link;
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
@@ -2732,12 +2542,16 @@ bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 		      link,
 		      &stream->timing);
 
+	if (res != DC_OK)
+		DC_ERROR("Failed validation for stream %p, err:%d, !\n",
+				stream, res);
+
 	return res == DC_OK;
 }
 
-bool dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state)
+bool dc_validate_plane(const struct dc *dc, const struct dc_plane_state *plane_state)
 {
-	struct dc *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
 	/* TODO For now validates pixel format only */
 	if (core_dc->res_pool->funcs->validate_plane)
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_sink.c b/drivers/gpu/drm/amd/display/dc/core/dc_sink.c
index 7717350..a83f124 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_sink.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_sink.c
@@ -63,16 +63,16 @@ static bool construct(struct dc_sink *sink, const struct dc_sink_init_data *init
 
 void dc_sink_retain(struct dc_sink *sink)
 {
-	ASSERT(atomic_read(&sink->ref_count) > 0);
-	atomic_inc(&sink->ref_count);
+	ASSERT(sink->ref_count > 0);
+	++sink->ref_count;
 }
 
 void dc_sink_release(struct dc_sink *sink)
 {
-	ASSERT(atomic_read(&sink->ref_count) > 0);
-	atomic_dec(&sink->ref_count);
+	ASSERT(sink->ref_count > 0);
+	--sink->ref_count;
 
-	if (atomic_read(&sink->ref_count) == 0) {
+	if (sink->ref_count == 0) {
 		destruct(sink);
 		dm_free(sink);
 	}
@@ -88,7 +88,7 @@ struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params)
 	if (false == construct(sink, init_params))
 		goto construct_fail;
 
-	atomic_inc(&sink->ref_count);
+	++sink->ref_count;
 
 	return sink;
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a421779..2de37fe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -33,28 +33,6 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
-static void update_stream_signal(struct dc_stream_state *stream)
-{
-	if (stream->output_signal == SIGNAL_TYPE_NONE) {
-		struct dc_sink *dc_sink = stream->sink;
-
-		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-			stream->signal = stream->sink->link->connector_signal;
-		else
-			stream->signal = dc_sink->sink_signal;
-	} else {
-		stream->signal = stream->output_signal;
-	}
-
-	if (dc_is_dvi_signal(stream->signal)) {
-		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
-			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
-			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
-		else
-			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
-	}
-}
 
 static bool construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
@@ -63,6 +41,7 @@ static bool construct(struct dc_stream_state *stream,
 
 	stream->sink = dc_sink_data;
 	stream->ctx = stream->sink->ctx;
+	stream->sink = dc_sink_data;
 
 	dc_sink_retain(dc_sink_data);
 
@@ -102,8 +81,6 @@ static bool construct(struct dc_stream_state *stream,
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
 	stream->status.link = stream->sink->link;
-
-	update_stream_signal(stream);
 	return true;
 }
 
@@ -119,17 +96,19 @@ static void destruct(struct dc_stream_state *stream)
 
 void dc_stream_retain(struct dc_stream_state *stream)
 {
-	ASSERT(atomic_read(&stream->ref_count) > 0);
-	atomic_inc(&stream->ref_count);
+
+	ASSERT(stream->ref_count > 0);
+	stream->ref_count++;
 }
 
 void dc_stream_release(struct dc_stream_state *stream)
 {
+
 	if (stream != NULL) {
-		ASSERT(atomic_read(&stream->ref_count) > 0);
-		atomic_dec(&stream->ref_count);
+		ASSERT(stream->ref_count > 0);
+		stream->ref_count--;
 
-		if (atomic_read(&stream->ref_count) == 0) {
+		if (stream->ref_count == 0) {
 			destruct(stream);
 			dm_free(stream);
 		}
@@ -152,7 +131,7 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	if (false == construct(stream, sink))
 			goto construct_fail;
 
-	atomic_inc(&stream->ref_count);
+	stream->ref_count++;
 
 	return stream;
 
@@ -167,11 +146,12 @@ struct dc_stream_status *dc_stream_get_status(
 	struct dc_stream_state *stream)
 {
 	uint8_t i;
-	struct dc  *dc = stream->ctx->dc;
+	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 
-	for (i = 0; i < dc->current_state->stream_count; i++) {
-		if (stream == dc->current_state->streams[i])
-			return &dc->current_state->stream_status[i];
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (stream == dc->current_context->streams[i]) {
+			return &dc->current_context->stream_status[i];
+		}
 	}
 
 	return NULL;
@@ -185,7 +165,7 @@ bool dc_stream_set_cursor_attributes(
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
-	struct dc  *core_dc;
+	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
 	if (NULL == stream) {
@@ -197,8 +177,8 @@ bool dc_stream_set_cursor_attributes(
 			return false;
 	}
 
-	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_state->res_ctx;
+	core_dc = DC_TO_CORE(stream->ctx->dc);
+	res_ctx = &core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -220,7 +200,7 @@ bool dc_stream_set_cursor_position(
 	const struct dc_cursor_position *position)
 {
 	int i;
-	struct dc  *core_dc;
+	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
 	if (NULL == stream) {
@@ -233,8 +213,8 @@ bool dc_stream_set_cursor_position(
 		return false;
 	}
 
-	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_state->res_ctx;
+	core_dc = DC_TO_CORE(stream->ctx->dc);
+	res_ctx = &core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -268,9 +248,9 @@ bool dc_stream_set_cursor_position(
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;
-	struct dc  *core_dc = stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
-		&core_dc->current_state->res_ctx;
+		&core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;
@@ -292,9 +272,9 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 {
 	uint8_t i;
 	bool ret = false;
-	struct dc  *core_dc = stream->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
-		&core_dc->current_state->res_ctx;
+		&core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index e96f63e..3bcca2d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -28,7 +28,7 @@
 #include "dc.h"
 
 /* DC core (private) */
-#include "core_types.h"
+#include "core_dc.h"
 #include "transform.h"
 
 /*******************************************************************************
@@ -64,9 +64,9 @@ void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_plane_state *dc_create_plane_state(struct dc *dc)
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc)
 {
-	struct dc *core_dc = dc;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
 	struct dc_plane_state *plane_state = dm_alloc(sizeof(*plane_state));
 
@@ -76,7 +76,7 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 	if (false == construct(core_dc->ctx, plane_state))
 		goto construct_fail;
 
-	atomic_inc(&plane_state->ref_count);
+	++plane_state->ref_count;
 
 	return plane_state;
 
@@ -91,7 +91,7 @@ const struct dc_plane_status *dc_plane_get_status(
 		const struct dc_plane_state *plane_state)
 {
 	const struct dc_plane_status *plane_status;
-	struct dc  *core_dc;
+	struct core_dc *core_dc;
 	int i;
 
 	if (!plane_state ||
@@ -102,14 +102,14 @@ const struct dc_plane_status *dc_plane_get_status(
 	}
 
 	plane_status = &plane_state->status;
-	core_dc = plane_state->ctx->dc;
+	core_dc = DC_TO_CORE(plane_state->ctx->dc);
 
-	if (core_dc->current_state == NULL)
+	if (core_dc->current_context == NULL)
 		return NULL;
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
-				&core_dc->current_state->res_ctx.pipe_ctx[i];
+				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->plane_state != plane_state)
 			continue;
@@ -122,16 +122,16 @@ const struct dc_plane_status *dc_plane_get_status(
 
 void dc_plane_state_retain(struct dc_plane_state *plane_state)
 {
-	ASSERT(atomic_read(&plane_state->ref_count) > 0);
-	atomic_inc(&plane_state->ref_count);
+	ASSERT(plane_state->ref_count > 0);
+	++plane_state->ref_count;
 }
 
 void dc_plane_state_release(struct dc_plane_state *plane_state)
 {
-	ASSERT(atomic_read(&plane_state->ref_count) > 0);
-	atomic_dec(&plane_state->ref_count);
+	ASSERT(plane_state->ref_count > 0);
+	--plane_state->ref_count;
 
-	if (atomic_read(&plane_state->ref_count) == 0) {
+	if (plane_state->ref_count == 0) {
 		destruct(plane_state);
 		dm_free(plane_state);
 	}
@@ -139,16 +139,16 @@ void dc_plane_state_release(struct dc_plane_state *plane_state)
 
 void dc_gamma_retain(struct dc_gamma *gamma)
 {
-	ASSERT(atomic_read(&gamma->ref_count) > 0);
-	atomic_inc(&gamma->ref_count);
+	ASSERT(gamma->ref_count > 0);
+	++gamma->ref_count;
 }
 
 void dc_gamma_release(struct dc_gamma **gamma)
 {
-	ASSERT(atomic_read(&(*gamma)->ref_count) > 0);
-	atomic_dec(&(*gamma)->ref_count);
+	ASSERT((*gamma)->ref_count > 0);
+	--(*gamma)->ref_count;
 
-	if (atomic_read(&(*gamma)->ref_count) == 0)
+	if ((*gamma)->ref_count == 0)
 		dm_free((*gamma));
 
 	*gamma = NULL;
@@ -161,7 +161,7 @@ struct dc_gamma *dc_create_gamma()
 	if (gamma == NULL)
 		goto alloc_fail;
 
-	atomic_inc(&gamma->ref_count);
+	++gamma->ref_count;
 
 	return gamma;
 
@@ -171,16 +171,16 @@ struct dc_gamma *dc_create_gamma()
 
 void dc_transfer_func_retain(struct dc_transfer_func *tf)
 {
-	ASSERT(atomic_read(&tf->ref_count) > 0);
-	atomic_inc(&tf->ref_count);
+	ASSERT(tf->ref_count > 0);
+	++tf->ref_count;
 }
 
 void dc_transfer_func_release(struct dc_transfer_func *tf)
 {
-	ASSERT(atomic_read(&tf->ref_count) > 0);
-	atomic_dec(&tf->ref_count);
+	ASSERT(tf->ref_count > 0);
+	--tf->ref_count;
 
-	if (atomic_read(&tf->ref_count) == 0)
+	if (tf->ref_count == 0)
 		dm_free(tf);
 }
 
@@ -191,7 +191,7 @@ struct dc_transfer_func *dc_create_transfer_func()
 	if (tf == NULL)
 		goto alloc_fail;
 
-	atomic_inc(&tf->ref_count);
+	++tf->ref_count;
 
 	return tf;
 
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 5fdb1b4..c81d3b5 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -34,20 +34,14 @@
 #include "grph_object_ctrl_defs.h"
 #include <inc/hw/opp.h>
 
-#include "inc/hw_sequencer.h"
-#include "inc/compressor.h"
-#include "dml/display_mode_lib.h"
-
-#define DC_VER "3.1.01"
-
 #define MAX_SURFACES 3
 #define MAX_STREAMS 6
 #define MAX_SINKS_PER_LINK 4
 
-
 /*******************************************************************************
  * Display Core Interfaces
  ******************************************************************************/
+
 struct dc_caps {
 	uint32_t max_streams;
 	uint32_t max_links;
@@ -99,7 +93,7 @@ struct dc_static_screen_events {
 /* Forward declaration*/
 struct dc;
 struct dc_plane_state;
-struct dc_state;
+struct validate_context;
 
 struct dc_cap_funcs {
 	bool (*get_dcc_compression_cap)(const struct dc *dc,
@@ -192,9 +186,7 @@ struct dc_debug {
 	bool disable_psr;
 	bool force_abm_enable;
 };
-struct dc_state;
-struct resource_pool;
-struct dce_hwseq;
+
 struct dc {
 	struct dc_caps caps;
 	struct dc_cap_funcs cap_funcs;
@@ -202,44 +194,6 @@ struct dc {
 	struct dc_link_funcs link_funcs;
 	struct dc_config config;
 	struct dc_debug debug;
-
-	struct dc_context *ctx;
-
-	uint8_t link_count;
-	struct dc_link *links[MAX_PIPES * 2];
-
-	struct dc_state *current_state;
-	struct resource_pool *res_pool;
-
-	/*Power State*/
-	enum dc_video_power_state previous_power_state;
-	enum dc_video_power_state current_power_state;
-
-	/* Display Engine Clock levels */
-	struct dm_pp_clock_levels sclk_lvls;
-
-	/* Inputs into BW and WM calculations. */
-	struct bw_calcs_dceip *bw_dceip;
-	struct bw_calcs_vbios *bw_vbios;
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	struct dcn_soc_bounding_box *dcn_soc;
-	struct dcn_ip_params *dcn_ip;
-	struct display_mode_lib dml;
-#endif
-
-	/* HW functions */
-	struct hw_sequencer_funcs hwss;
-	struct dce_hwseq *hwseq;
-
-	/* temp store of dm_pp_display_configuration
-	 * to compare to see if display config changed
-	 */
-	struct dm_pp_display_configuration prev_display_config;
-
-	/* FBC compressor */
-#ifdef ENABLE_FBC
-	struct compressor *fbc_compressor;
-#endif
 };
 
 enum frame_buffer_mode {
@@ -341,7 +295,7 @@ struct dc_transfer_func {
 	enum dc_transfer_func_type type;
 	enum dc_transfer_func_predefined tf;
 	struct dc_context *ctx;
-	atomic_t ref_count;
+	int ref_count;
 };
 
 /*
@@ -388,7 +342,7 @@ struct dc_plane_state {
 
 	/* private to dc_surface.c */
 	enum dc_irq_source irq_source;
-	atomic_t ref_count;
+	int ref_count;
 };
 
 struct dc_plane_info {
@@ -430,7 +384,7 @@ struct dc_surface_update {
 /*
  * Create a new surface with default parameters;
  */
-struct dc_plane_state *dc_create_plane_state(struct dc *dc);
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc);
 const struct dc_plane_status *dc_plane_get_status(
 		const struct dc_plane_state *plane_state);
 
@@ -526,7 +480,6 @@ enum surface_update_type {
 
 struct dc_stream_status {
 	int primary_otg_inst;
-	int stream_enc_inst;
 	int plane_count;
 	struct dc_plane_state *plane_states[MAX_SURFACE_NUM];
 
@@ -577,7 +530,7 @@ struct dc_stream_state {
 	struct dc_stream_status status;
 
 	/* from stream struct */
-	atomic_t ref_count;
+	int ref_count;
 };
 
 struct dc_stream_update {
@@ -617,8 +570,8 @@ void dc_stream_log(
 	struct dal_logger *dc_logger,
 	enum dc_log_type log_type);
 
-uint8_t dc_get_current_stream_count(struct dc *dc);
-struct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i);
+uint8_t dc_get_current_stream_count(const struct dc *dc);
+struct dc_stream_state *dc_get_stream_at_index(const struct dc *dc, uint8_t i);
 
 /*
  * Return the current frame counter.
@@ -635,41 +588,6 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 				  uint32_t *h_position,
 				  uint32_t *v_position);
 
-bool dc_add_stream_to_ctx(
-			struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *stream);
-
-bool dc_remove_stream_from_ctx(
-		struct dc *dc,
-			struct dc_state *new_ctx,
-			struct dc_stream_state *stream);
-
-
-bool dc_add_plane_to_context(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_plane_state *plane_state,
-		struct dc_state *context);
-
-bool dc_remove_plane_from_context(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_plane_state *plane_state,
-		struct dc_state *context);
-
-bool dc_rem_all_planes_for_stream(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_state *context);
-
-bool dc_add_all_planes_for_stream(
-		const struct dc *dc,
-		struct dc_stream_state *stream,
-		struct dc_plane_state * const *plane_states,
-		int plane_count,
-		struct dc_state *context);
-
 /*
  * Structure to store surface/stream associations for validation
  */
@@ -679,13 +597,24 @@ struct dc_validation_set {
 	uint8_t plane_count;
 };
 
-bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream);
+bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream);
 
-bool dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state);
+bool dc_validate_plane(const struct dc *dc, const struct dc_plane_state *plane_state);
+/*
+ * This function takes a set of resources and checks that they are cofunctional.
+ *
+ * After this call:
+ *   No hardware is programmed for call.  Only validation is done.
+ */
+struct validate_context *dc_get_validate_context(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count);
 
-bool dc_validate_global_state(
-		struct dc *dc,
-		struct dc_state *new_ctx);
+bool dc_validate_resources(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count);
 
 /*
  * This function takes a stream and checks if it is guaranteed to be supported.
@@ -695,20 +624,15 @@ bool dc_validate_global_state(
  *   No hardware is programmed for call.  Only validation is done.
  */
 
-
-void dc_resource_state_construct(
+bool dc_validate_guaranteed(
 		const struct dc *dc,
-		struct dc_state *dst_ctx);
-
-void dc_resource_state_copy_construct(
-		const struct dc_state *src_ctx,
-		struct dc_state *dst_ctx);
+		struct dc_stream_state *stream);
 
-void dc_resource_state_copy_construct_current(
-		const struct dc *dc,
-		struct dc_state *dst_ctx);
+void dc_resource_validate_ctx_copy_construct(
+		const struct validate_context *src_ctx,
+		struct validate_context *dst_ctx);
 
-void dc_resource_state_destruct(struct dc_state *context);
+void dc_resource_validate_ctx_destruct(struct validate_context *context);
 
 /*
  * TODO update to make it about validation sets
@@ -719,7 +643,7 @@ void dc_resource_state_destruct(struct dc_state *context);
  *   Phy, Encoder, Timing Generator are programmed and enabled.
  *   New streams are enabled with blank stream; no memory read.
  */
-bool dc_commit_state(struct dc *dc, struct dc_state *context);
+bool dc_commit_context(struct dc *dc, struct validate_context *context);
 
 /*
  * Set up streams and links associated to drive sinks
@@ -729,13 +653,17 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context);
  *   Phy, Encoder, Timing Generator are programmed and enabled.
  *   New streams are enabled with blank stream; no memory read.
  */
+bool dc_commit_streams(
+		struct dc *dc,
+		struct dc_stream_state *streams[],
+		uint8_t stream_count);
 /*
  * Enable stereo when commit_streams is not required,
  * for example, frame alternate.
  */
 bool dc_enable_stereo(
 	struct dc *dc,
-	struct dc_state *context,
+	struct validate_context *context,
 	struct dc_stream_state *streams[],
 	uint8_t stream_count);
 
@@ -758,8 +686,8 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		const struct dc_stream_status *stream_status);
 
 
-void dc_retain_state(struct dc_state *context);
-void dc_release_state(struct dc_state *context);
+void dc_retain_validate_context(struct validate_context *context);
+void dc_release_validate_context(struct validate_context *context);
 
 /*******************************************************************************
  * Link Interfaces
@@ -785,7 +713,6 @@ struct dpcd_caps {
 
 	bool allow_invalid_MSA_timing_param;
 	bool panel_mode_edp;
-	bool dpcd_display_control_capable;
 };
 
 struct dc_link_status {
@@ -849,7 +776,7 @@ struct dc_link {
 
 	/* Private to DC core */
 
-	const struct dc *dc;
+	const struct core_dc *dc;
 
 	struct dc_context *ctx;
 
@@ -858,8 +785,8 @@ struct dc_link {
 	union ddi_channel_mapping ddi_channel_mapping;
 	struct connector_device_tag_info device_tag;
 	struct dpcd_caps dpcd_caps;
-	unsigned short chip_caps;
 	unsigned int dpcd_sink_count;
+
 	enum edp_revision edp_revision;
 	bool psr_enabled;
 
@@ -880,13 +807,19 @@ const struct dc_link_status *dc_link_get_status(const struct dc_link *dc_link);
  * boot time.  They cannot be created or destroyed.
  * Use dc_get_caps() to get number of links.
  */
-struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index);
+struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index);
+
+/* Return id of physical connector represented by a dc_link at link_index.*/
+const struct graphics_object_id dc_get_link_id_at_index(
+		struct dc *dc, uint32_t link_index);
 
 /* Set backlight level of an embedded panel (eDP, LVDS). */
 bool dc_link_set_backlight_level(const struct dc_link *dc_link, uint32_t level,
 		uint32_t frame_ramp, const struct dc_stream_state *stream);
 
-bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable, bool wait);
+bool dc_link_set_abm_disable(const struct dc_link *dc_link);
+
+bool dc_link_set_psr_enable(const struct dc_link *dc_link, bool enable);
 
 bool dc_link_get_psr_state(const struct dc_link *dc_link, uint32_t *psr_state);
 
@@ -924,6 +857,7 @@ void dc_link_remove_remote_sink(
 	struct dc_sink *sink);
 
 /* Used by diagnostics for virtual link at the moment */
+void dc_link_set_sink(struct dc_link *link, struct dc_sink *sink);
 
 void dc_link_dp_set_drive_settings(
 	struct dc_link *link,
@@ -980,12 +914,14 @@ struct dc_sink {
 	struct dc_context *ctx;
 
 	/* private to dc_sink.c */
-	atomic_t ref_count;
+	int ref_count;
 };
 
 void dc_sink_retain(struct dc_sink *sink);
 void dc_sink_release(struct dc_sink *sink);
 
+const struct audio **dc_get_audios(struct dc *dc);
+
 struct dc_sink_init_data {
 	enum signal_type sink_signal;
 	struct dc_link *link;
@@ -994,6 +930,8 @@ struct dc_sink_init_data {
 };
 
 struct dc_sink *dc_sink_create(const struct dc_sink_init_data *init_params);
+bool dc_sink_get_container_id(struct dc_sink *dc_sink, struct dc_container_id *container_id);
+bool dc_sink_set_container_id(struct dc_sink *dc_sink, const struct dc_container_id *container_id);
 
 /*******************************************************************************
  * Cursor interfaces - To manages the cursor within a stream
@@ -1020,7 +958,7 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 		struct dc *dc,
 		uint32_t src_id,
 		uint32_t ext_id);
-void dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable);
+void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable);
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src);
 enum dc_irq_source dc_get_hpd_irq_source_at_index(
 		struct dc *dc, uint32_t link_index);
@@ -1033,12 +971,51 @@ void dc_set_power_state(
 		struct dc *dc,
 		enum dc_acpi_cm_power_state power_state,
 		enum dc_video_power_state video_power_state);
-void dc_resume(struct dc *dc);
+void dc_resume(const struct dc *dc);
 
 /*
  * DPCD access interfaces
  */
 
+bool dc_read_aux_dpcd(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size);
+
+bool dc_write_aux_dpcd(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		const uint8_t *data,
+		uint32_t size);
+
+bool dc_read_aux_i2c(
+		struct dc *dc,
+		uint32_t link_index,
+		enum i2c_mot_mode mot,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size);
+
+bool dc_write_aux_i2c(
+		struct dc *dc,
+		uint32_t link_index,
+		enum i2c_mot_mode mot,
+		uint32_t address,
+		const uint8_t *data,
+		uint32_t size);
+
+bool dc_query_ddc_data(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		uint8_t *write_buf,
+		uint32_t write_size,
+		uint8_t *read_buf,
+		uint32_t read_size);
+
 bool dc_submit_i2c(
 		struct dc *dc,
 		uint32_t link_index,
diff --git a/drivers/gpu/drm/amd/display/dc/dc_hw_types.h b/drivers/gpu/drm/amd/display/dc/dc_hw_types.h
index 94f83cd..8d15046 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_hw_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_hw_types.h
@@ -433,7 +433,7 @@ struct dc_gamma {
 	struct dc_context *ctx;
 
 	/* private to dc_surface.c */
-	atomic_t ref_count;
+	int ref_count;
 };
 
 /* Used by both ipp amd opp functions*/
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
index d3b61b9..88e266a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
@@ -602,90 +602,6 @@ static uint32_t dce110_get_pix_clk_dividers(
 	return pll_calc_error;
 }
 
-static uint32_t dce110_get_pll_pixel_rate_in_hz(
-	struct clock_source *cs,
-	struct pixel_clk_params *pix_clk_params,
-	struct pll_settings *pll_settings)
-{
-	uint32_t inst = pix_clk_params->controller_id - CONTROLLER_ID_D0;
-	struct dc *dc_core = cs->ctx->dc;
-	struct dc_state *context = dc_core->current_state;
-	struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[inst];
-
-	/* This function need separate to different DCE version, before separate, just use pixel clock */
-	return pipe_ctx->stream->phy_pix_clk;
-
-}
-
-static uint32_t dce110_get_dp_pixel_rate_from_combo_phy_pll(
-	struct clock_source *cs,
-	struct pixel_clk_params *pix_clk_params,
-	struct pll_settings *pll_settings)
-{
-	uint32_t inst = pix_clk_params->controller_id - CONTROLLER_ID_D0;
-	struct dc *dc_core = cs->ctx->dc;
-	struct dc_state *context = dc_core->current_state;
-	struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[inst];
-
-	/* This function need separate to different DCE version, before separate, just use pixel clock */
-	return pipe_ctx->stream->phy_pix_clk;
-}
-
-static uint32_t dce110_get_d_to_pixel_rate_in_hz(
-	struct clock_source *cs,
-	struct pixel_clk_params *pix_clk_params,
-	struct pll_settings *pll_settings)
-{
-	uint32_t inst = pix_clk_params->controller_id - CONTROLLER_ID_D0;
-	struct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(cs);
-	int dto_enabled = 0;
-	struct fixed31_32 pix_rate;
-
-	REG_GET(PIXEL_RATE_CNTL[inst], DP_DTO0_ENABLE, &dto_enabled);
-
-	if (dto_enabled) {
-		uint32_t phase = 0;
-		uint32_t modulo = 0;
-		REG_GET(PHASE[inst], DP_DTO0_PHASE, &phase);
-		REG_GET(MODULO[inst], DP_DTO0_MODULO, &modulo);
-
-		if (modulo == 0) {
-			return 0;
-		}
-
-		pix_rate = dal_fixed31_32_from_int(clk_src->ref_freq_khz);
-		pix_rate = dal_fixed31_32_mul_int(pix_rate, 1000);
-		pix_rate = dal_fixed31_32_mul_int(pix_rate, phase);
-		pix_rate = dal_fixed31_32_div_int(pix_rate, modulo);
-
-		return dal_fixed31_32_round(pix_rate);
-	} else {
-		return dce110_get_dp_pixel_rate_from_combo_phy_pll(cs, pix_clk_params, pll_settings);
-	}
-}
-
-static uint32_t dce110_get_pix_rate_in_hz(
-	struct clock_source *cs,
-	struct pixel_clk_params *pix_clk_params,
-	struct pll_settings *pll_settings)
-{
-	uint32_t pix_rate = 0;
-	switch (pix_clk_params->signal_type) {
-	case	SIGNAL_TYPE_DISPLAY_PORT:
-	case	SIGNAL_TYPE_DISPLAY_PORT_MST:
-	case	SIGNAL_TYPE_EDP:
-	case	SIGNAL_TYPE_VIRTUAL:
-		pix_rate = dce110_get_d_to_pixel_rate_in_hz(cs, pix_clk_params, pll_settings);
-		break;
-	case	SIGNAL_TYPE_HDMI_TYPE_A:
-	default:
-		pix_rate = dce110_get_pll_pixel_rate_in_hz(cs, pix_clk_params, pll_settings);
-		break;
-	}
-
-	return pix_rate;
-}
-
 static bool disable_spread_spectrum(struct dce110_clk_src *clk_src)
 {
 	enum bp_result result;
@@ -1046,8 +962,7 @@ static bool dce110_clock_source_power_down(
 static const struct clock_source_funcs dce110_clk_src_funcs = {
 	.cs_power_down = dce110_clock_source_power_down,
 	.program_pix_clk = dce110_program_pix_clk,
-	.get_pix_clk_dividers = dce110_get_pix_clk_dividers,
-	.get_pix_rate_in_hz = dce110_get_pix_rate_in_hz
+	.get_pix_clk_dividers = dce110_get_pix_clk_dividers
 };
 
 static void get_ss_info_from_atombios(
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.h b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.h
index c45e2f7..fc92388 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.h
@@ -55,8 +55,6 @@
 	CS_SF(PHYPLLA_PIXCLK_RESYNC_CNTL, PHYPLLA_DCCG_DEEP_COLOR_CNTL, mask_sh),\
 	CS_SF(PHYPLLA_PIXCLK_RESYNC_CNTL, PHYPLLA_PIXCLK_DOUBLE_RATE_ENABLE, mask_sh)
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-
 #define CS_COMMON_REG_LIST_DCN1_0(index, pllid) \
 		SRI(PIXCLK_RESYNC_CNTL, PHYPLL, pllid),\
 		SRII(PHASE, DP_DTO, 0),\
@@ -73,13 +71,9 @@
 		SRII(PIXEL_RATE_CNTL, OTG, 3)
 
 #define CS_COMMON_MASK_SH_LIST_DCN1_0(mask_sh)\
-	CS_SF(DP_DTO0_PHASE, DP_DTO0_PHASE, mask_sh),\
-	CS_SF(DP_DTO0_MODULO, DP_DTO0_MODULO, mask_sh),\
 	CS_SF(PHYPLLA_PIXCLK_RESYNC_CNTL, PHYPLLA_DCCG_DEEP_COLOR_CNTL, mask_sh),\
 	CS_SF(OTG0_PIXEL_RATE_CNTL, DP_DTO0_ENABLE, mask_sh)
 
-#endif
-
 #define CS_REG_FIELD_LIST(type) \
 	type PLL_REF_DIV_SRC; \
 	type DCCG_DEEP_COLOR_CNTL1; \
@@ -87,8 +81,6 @@
 	type PHYPLLA_PIXCLK_DOUBLE_RATE_ENABLE; \
 	type PLL_POST_DIV_PIXCLK; \
 	type PLL_REF_DIV; \
-	type DP_DTO0_PHASE; \
-	type DP_DTO0_MODULO; \
 	type DP_DTO0_ENABLE;
 
 struct dce110_clk_src_shift {
@@ -107,9 +99,9 @@ struct dce110_clk_src_regs {
 	/* below are for DTO.
 	 * todo: should probably use different struct to not waste space
 	 */
-	uint32_t PHASE[MAX_PIPES];
-	uint32_t MODULO[MAX_PIPES];
-	uint32_t PIXEL_RATE_CNTL[MAX_PIPES];
+	uint32_t PHASE[4];
+	uint32_t MODULO[4];
+	uint32_t PIXEL_RATE_CNTL[4];
 };
 
 struct dce110_clk_src {
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c b/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
index 06d9a3e..a73228b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
@@ -29,12 +29,14 @@
 #include "fixed32_32.h"
 #include "bios_parser_interface.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "dce_abm.h"
 #include "dmcu.h"
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "dcn_calcs.h"
+#include "core_dc.h"
 #endif
-#include "core_types.h"
+
 
 
 #define TO_DCE_CLOCKS(clocks)\
@@ -325,14 +327,13 @@ static bool dce_clock_set_min_clocks_state(
 	return true;
 }
 
-static int dce_set_clock(
+static void dce_set_clock(
 	struct display_clock *clk,
 	int requested_clk_khz)
 {
 	struct dce_disp_clk *clk_dce = TO_DCE_CLOCKS(clk);
 	struct bp_pixel_clock_parameters pxl_clk_params = { 0 };
 	struct dc_bios *bp = clk->ctx->dc_bios;
-	int actual_clock = requested_clk_khz;
 
 	/* Make sure requested clock isn't lower than minimum threshold*/
 	if (requested_clk_khz > 0)
@@ -350,43 +351,39 @@ static int dce_set_clock(
 		/* Cache the fixed display clock*/
 		clk_dce->dfs_bypass_disp_clk =
 			pxl_clk_params.dfs_bypass_display_clock;
-		actual_clock = pxl_clk_params.dfs_bypass_display_clock;
 	}
 
 	/* from power down, we need mark the clock state as ClocksStateNominal
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
 	if (requested_clk_khz == 0)
 		clk->cur_min_clks_state = DM_PP_CLOCKS_STATE_NOMINAL;
-	return actual_clock;
 }
 
-static int dce_psr_set_clock(
+static void dce_psr_set_clock(
 	struct display_clock *clk,
 	int requested_clk_khz)
 {
 	struct dce_disp_clk *clk_dce = TO_DCE_CLOCKS(clk);
 	struct dc_context *ctx = clk_dce->base.ctx;
-	struct dc *core_dc = ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(ctx->dc);
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
-	int actual_clk_khz = requested_clk_khz;
 
-	actual_clk_khz = dce_set_clock(clk, requested_clk_khz);
+	dce_set_clock(clk, requested_clk_khz);
 
-	dmcu->funcs->set_psr_wait_loop(dmcu, actual_clk_khz / 1000 / 7);
-	return actual_clk_khz;
+	dmcu->funcs->set_psr_wait_loop(dmcu, requested_clk_khz / 1000 / 7);
 }
 
-static int dce112_set_clock(
+static void dce112_set_clock(
 	struct display_clock *clk,
 	int requested_clk_khz)
 {
 	struct dce_disp_clk *clk_dce = TO_DCE_CLOCKS(clk);
 	struct bp_set_dce_clock_parameters dce_clk_params;
 	struct dc_bios *bp = clk->ctx->dc_bios;
-	struct dc *core_dc = clk->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(clk->ctx->dc);
 	struct abm *abm =  core_dc->res_pool->abm;
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
-	int actual_clock = requested_clk_khz;
+
 	/* Prepare to program display clock*/
 	memset(&dce_clk_params, 0, sizeof(dce_clk_params));
 
@@ -400,7 +397,6 @@ static int dce112_set_clock(
 	dce_clk_params.clock_type = DCECLOCK_TYPE_DISPLAY_CLOCK;
 
 	bp->funcs->set_dce_clock(bp, &dce_clk_params);
-	actual_clock = dce_clk_params.target_clock_frequency;
 
 	/* from power down, we need mark the clock state as ClocksStateNominal
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
@@ -417,11 +413,10 @@ static int dce112_set_clock(
 
 	bp->funcs->set_dce_clock(bp, &dce_clk_params);
 
-	if (abm->funcs->is_dmcu_initialized(abm) && clk_dce->dfs_bypass_disp_clk != actual_clock)
+	if (abm->funcs->is_dmcu_initialized(abm))
 		dmcu->funcs->set_psr_wait_loop(dmcu,
-				actual_clock / 1000 / 7);
-	clk_dce->dfs_bypass_disp_clk = actual_clock;
-	return actual_clock;
+				requested_clk_khz / 1000 / 7);
+
 }
 
 static void dce_clock_read_integrated_info(struct dce_disp_clk *clk_dce)
@@ -620,7 +615,7 @@ static bool dce_apply_clock_voltage_request(
 	if (send_request) {
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 		if (clk->ctx->dce_version >= DCN_VERSION_1_0) {
-			struct dc *core_dc = clk->ctx->dc;
+			struct core_dc *core_dc = DC_TO_CORE(clk->ctx->dc);
 			/*use dcfclk request voltage*/
 			clock_voltage_req.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
 			clock_voltage_req.clocks_in_khz =
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c b/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
index 313f61b..92902f0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_dmcu.c
@@ -103,7 +103,7 @@ static void dce_get_dmcu_psr_state(struct dmcu *dmcu, uint32_t *psr_state)
 	REG_UPDATE(DMCU_RAM_ACCESS_CTRL, IRAM_HOST_ACCESS_EN, 0);
 }
 
-static void dce_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)
+static void dce_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable)
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
 	unsigned int dmcu_max_retry_on_wait_reg_ready = 801;
@@ -127,18 +127,17 @@ static void dce_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)
 
 	/* notifyDMCUMsg */
 	REG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);
-	if (wait == true) {
-		for (retryCount = 0; retryCount <= 100; retryCount++) {
-			dce_get_dmcu_psr_state(dmcu, &psr_state);
-				if (enable) {
-					if (psr_state != 0)
-						break;
-				} else {
-					if (psr_state == 0)
-						break;
-				}
-				dm_delay_in_microseconds(dmcu->ctx, 10);
+
+	for (retryCount = 0; retryCount <= 100; retryCount++) {
+		dce_get_dmcu_psr_state(dmcu, &psr_state);
+		if (enable) {
+			if (psr_state != 0)
+				break;
+		} else {
+			if (psr_state == 0)
+				break;
 		}
+		dm_delay_in_microseconds(dmcu->ctx, 10);
 	}
 }
 
@@ -261,8 +260,6 @@ static void dce_psr_wait_loop(
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
 	union dce_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;
-	if (cached_wait_loop_number == wait_loop_number)
-		return;
 
 	/* waitDMCUReadyForCmd */
 	REG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);
@@ -339,7 +336,7 @@ static void dcn10_get_dmcu_psr_state(struct dmcu *dmcu, uint32_t *psr_state)
 	REG_UPDATE(DMCU_RAM_ACCESS_CTRL, IRAM_HOST_ACCESS_EN, 0);
 }
 
-static void dcn10_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)
+static void dcn10_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable)
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
 	unsigned int dmcu_max_retry_on_wait_reg_ready = 801;
@@ -368,7 +365,6 @@ static void dcn10_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)
 	 *  Exit PSR may need to wait 1-2 frames to power up. Timeout after at
 	 *  least a few frames. Should never hit the max retry assert below.
 	 */
-	if (wait == true) {
 	for (retryCount = 0; retryCount <= 1000; retryCount++) {
 		dcn10_get_dmcu_psr_state(dmcu, &psr_state);
 		if (enable) {
@@ -383,7 +379,6 @@ static void dcn10_dmcu_set_psr_enable(struct dmcu *dmcu, bool enable, bool wait)
 
 	/* assert if max retry hit */
 	ASSERT(retryCount <= 1000);
-	}
 }
 
 static void dcn10_dmcu_setup_psr(struct dmcu *dmcu,
@@ -505,7 +500,7 @@ static void dcn10_psr_wait_loop(
 {
 	struct dce_dmcu *dmcu_dce = TO_DCE_DMCU(dmcu);
 	union dce_dmcu_psr_config_data_wait_loop_reg1 masterCmdData1;
-	if (wait_loop_number != 0) {
+
 	/* waitDMCUReadyForCmd */
 	REG_WAIT(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 0, 1, 10000);
 
@@ -519,7 +514,6 @@ static void dcn10_psr_wait_loop(
 
 	/* notifyDMCUMsg */
 	REG_UPDATE(MASTER_COMM_CNTL_REG, MASTER_COMM_INTERRUPT, 1);
-	}
 }
 
 static void dcn10_get_psr_wait_loop(unsigned int *psr_wait_loop_number)
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
index d2e66b1..4894e17 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
@@ -26,7 +26,7 @@
 #include "dce_hwseq.h"
 #include "reg_helper.h"
 #include "hw_sequencer.h"
-#include "core_types.h"
+#include "core_dc.h"
 
 #define CTX \
 	hws->ctx
@@ -44,7 +44,7 @@ void dce_enable_fe_clock(struct dce_hwseq *hws,
 			DCFE_CLOCK_ENABLE, enable);
 }
 
-void dce_pipe_control_lock(struct dc *dc,
+void dce_pipe_control_lock(struct core_dc *dc,
 		struct pipe_ctx *pipe,
 		bool lock)
 {
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
index cae0606..9c703da 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
@@ -206,20 +206,7 @@
 	SR(D1VGA_CONTROL), \
 	SR(D2VGA_CONTROL), \
 	SR(D3VGA_CONTROL), \
-	SR(D4VGA_CONTROL), \
-	/* todo:  get these from GVM instead of reading registers ourselves */\
-	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32),\
-	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32),\
-	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32),\
-	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32),\
-	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32),\
-	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32),\
-	MMHUB_SR(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32),\
-	MMHUB_SR(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32),\
-	MMHUB_SR(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB),\
-	MMHUB_SR(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB),\
-	MMHUB_SR(MC_VM_SYSTEM_APERTURE_LOW_ADDR),\
-	MMHUB_SR(MC_VM_SYSTEM_APERTURE_HIGH_ADDR)
+	SR(D4VGA_CONTROL)
 
 #define HWSEQ_DCN1_REG_LIST()\
 	HWSEQ_DCN_REG_LIST(), \
@@ -325,19 +312,6 @@ struct dce_hwseq_registers {
 	uint32_t D2VGA_CONTROL;
 	uint32_t D3VGA_CONTROL;
 	uint32_t D4VGA_CONTROL;
-	/* MMHUB registers. read only. temporary hack */
-	uint32_t VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32;
-	uint32_t VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32;
-	uint32_t VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32;
-	uint32_t VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32;
-	uint32_t VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32;
-	uint32_t VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32;
-	uint32_t VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32;
-	uint32_t VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32;
-	uint32_t MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB;
-	uint32_t MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB;
-	uint32_t MC_VM_SYSTEM_APERTURE_LOW_ADDR;
-	uint32_t MC_VM_SYSTEM_APERTURE_HIGH_ADDR;
 };
  /* set field name */
 #define HWS_SF(blk_name, reg_name, field_name, post_fix)\
@@ -460,17 +434,7 @@ struct dce_hwseq_registers {
 	HWS_SF(, DCHUBBUB_SDPIF_AGP_BASE, SDPIF_AGP_BASE, mask_sh), \
 	HWS_SF(, DCHUBBUB_SDPIF_AGP_BOT, SDPIF_AGP_BOT, mask_sh), \
 	HWS_SF(, DCHUBBUB_SDPIF_AGP_TOP, SDPIF_AGP_TOP, mask_sh), \
-	HWS_SF(DPP_TOP0_, DPP_CONTROL, DPPCLK_RATE_CONTROL, mask_sh), \
-	/* todo:  get these from GVM instead of reading registers ourselves */\
-	HWS_SF(, VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32, PAGE_DIRECTORY_ENTRY_HI32, mask_sh),\
-	HWS_SF(, VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32, PAGE_DIRECTORY_ENTRY_LO32, mask_sh),\
-	HWS_SF(, VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32, LOGICAL_PAGE_NUMBER_HI4, mask_sh),\
-	HWS_SF(, VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32, LOGICAL_PAGE_NUMBER_LO32, mask_sh),\
-	HWS_SF(, VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32, PHYSICAL_PAGE_ADDR_HI4, mask_sh),\
-	HWS_SF(, VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32, PHYSICAL_PAGE_ADDR_LO32, mask_sh),\
-	HWS_SF(, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, PHYSICAL_PAGE_NUMBER_MSB, mask_sh),\
-	HWS_SF(, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, PHYSICAL_PAGE_NUMBER_LSB, mask_sh),\
-	HWS_SF(, MC_VM_SYSTEM_APERTURE_LOW_ADDR, LOGICAL_ADDR, mask_sh)
+	HWS_SF(DPP_TOP0_, DPP_CONTROL, DPPCLK_RATE_CONTROL, mask_sh)
 
 #define HWSEQ_REG_FIELD_LIST(type) \
 	type DCFE_CLOCK_ENABLE; \
@@ -489,18 +453,6 @@ struct dce_hwseq_registers {
 	type PIXEL_RATE_SOURCE; \
 	type PHYPLL_PIXEL_RATE_SOURCE; \
 	type PIXEL_RATE_PLL_SOURCE; \
-	/* todo:  get these from GVM instead of reading registers ourselves */\
-	type PAGE_DIRECTORY_ENTRY_HI32;\
-	type PAGE_DIRECTORY_ENTRY_LO32;\
-	type LOGICAL_PAGE_NUMBER_HI4;\
-	type LOGICAL_PAGE_NUMBER_LO32;\
-	type PHYSICAL_PAGE_ADDR_HI4;\
-	type PHYSICAL_PAGE_ADDR_LO32;\
-	type PHYSICAL_PAGE_NUMBER_MSB;\
-	type PHYSICAL_PAGE_NUMBER_LSB;\
-	type LOGICAL_ADDR; \
-	type ENABLE_L1_TLB;\
-	type SYSTEM_ACCESS_MODE;
 
 #define HWSEQ_DCN_REG_FIELD_LIST(type) \
 	type VUPDATE_NO_LOCK_EVENT_CLEAR; \
@@ -580,7 +532,7 @@ enum blnd_mode {
 void dce_enable_fe_clock(struct dce_hwseq *hwss,
 		unsigned int inst, bool enable);
 
-void dce_pipe_control_lock(struct dc *dc,
+void dce_pipe_control_lock(struct core_dc *dc,
 		struct pipe_ctx *pipe,
 		bool lock);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
index 0ce94ed..7e9afab8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
@@ -744,7 +744,7 @@ void dce110_link_encoder_edp_backlight_control(
 		return;
 	}
 
-	if (!enable && !is_panel_backlight_on(enc110)) {
+	if (!enable && !is_panel_powered_on(enc110)) {
 		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
 				"%s: panel already powered down. Do nothing.\n",
 				__func__);
@@ -887,9 +887,6 @@ static bool dce110_link_encoder_validate_hdmi_output(
 			crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
 		return false;
 
-	if (!enc110->base.features.flags.bits.HDMI_6GB_EN &&
-		adjusted_pix_clk_khz >= 300000)
-		return false;
 	return true;
 }
 
@@ -1011,7 +1008,6 @@ bool dce110_link_encoder_construct(
 				bp_cap_info.DP_HBR2_EN;
 		enc110->base.features.flags.bits.IS_HBR3_CAPABLE =
 				bp_cap_info.DP_HBR3_EN;
-		enc110->base.features.flags.bits.HDMI_6GB_EN = bp_cap_info.HDMI_6GB_EN;
 	}
 
 	return true;
@@ -1292,8 +1288,6 @@ void dce110_link_encoder_disable_output(
 		/* OF_SKIP_POWER_DOWN_INACTIVE_ENCODER */
 		return;
 	}
-	if (enc110->base.connector.id == CONNECTOR_ID_EDP)
-		dce110_link_encoder_edp_backlight_control(enc, false);
 	/* Power-down RX and disable GPU PHY should be paired.
 	 * Disabling PHY without powering down RX may cause
 	 * symbol lock loss, on which we will get DP Sink interrupt. */
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 83d9caa..6276697 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -686,8 +686,6 @@ void dce_mem_input_construct(
 	dce_mi->shifts = mi_shift;
 	dce_mi->masks = mi_mask;
 
-	dce_mi->base.mpcc_id = 0xf;
-	dce_mi->base.opp_id = 0xf;
 }
 
 void dce112_mem_input_construct(
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h b/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h
index 45e6c5b..8632d8f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_transform.h
@@ -78,10 +78,6 @@
 	SRI(SCL_UPDATE, SCL, id), \
 	SRI(SCL_F_SHARP_CONTROL, SCL, id)
 
-#define XFM_COMMON_REG_LIST_DCE80(id) \
-	XFM_COMMON_REG_LIST_DCE_BASE(id), \
-	SRI(DCFE_MEM_LIGHT_SLEEP_CNTL, CRTC, id)
-
 #define XFM_COMMON_REG_LIST_DCE100(id) \
 	XFM_COMMON_REG_LIST_DCE_BASE(id), \
 	SRI(DCFE_MEM_PWR_CTRL, CRTC, id), \
@@ -161,12 +157,6 @@
 	XFM_SF(SCL_UPDATE, SCL_COEF_UPDATE_COMPLETE, mask_sh), \
 	XFM_SF(LB_DATA_FORMAT, ALPHA_EN, mask_sh)
 
-#define XFM_COMMON_MASK_SH_LIST_DCE80(mask_sh) \
-	XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(mask_sh), \
-	OPP_SF(DCFE_MEM_LIGHT_SLEEP_CNTL, REGAMMA_LUT_LIGHT_SLEEP_DIS, mask_sh),\
-	OPP_SF(DCFE_MEM_LIGHT_SLEEP_CNTL, DCP_LUT_LIGHT_SLEEP_DIS, mask_sh),\
-	OPP_SF(DCFE_MEM_LIGHT_SLEEP_CNTL, REGAMMA_LUT_MEM_PWR_STATE, mask_sh)
-
 #define XFM_COMMON_MASK_SH_LIST_DCE110(mask_sh) \
 	XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(mask_sh), \
 	XFM_SF(DCFE_MEM_PWR_CTRL, SCL_COEFF_MEM_PWR_DIS, mask_sh), \
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
index 492ea60..c638f47 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.c
@@ -24,6 +24,7 @@
  */
 #include "dm_services.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "core_types.h"
 #include "hw_sequencer.h"
 #include "dce100_hw_sequencer.h"
@@ -70,7 +71,7 @@ static const struct dce100_hw_seq_reg_offsets reg_offsets[] = {
 /***************************PIPE_CONTROL***********************************/
 
 static bool dce100_enable_display_power_gating(
-	struct dc *dc,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -106,8 +107,8 @@ static bool dce100_enable_display_power_gating(
 }
 
 static void dce100_pplib_apply_display_requirements(
-	struct dc *dc,
-	struct dc_state *context)
+	struct core_dc *dc,
+	struct validate_context *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
@@ -126,15 +127,15 @@ static void dce100_pplib_apply_display_requirements(
 }
 
 void dce100_set_bandwidth(
-		struct dc *dc,
-		struct dc_state *context,
+		struct core_dc *dc,
+		struct validate_context *context,
 		bool decrease_allowed)
 {
-	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_state->bw.dce.dispclk_khz) {
+	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_context->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dce.dispclk_khz * 115 / 100);
-		dc->current_state->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
+		dc->current_context->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
 	}
 	dce100_pplib_apply_display_requirements(dc, context);
 }
@@ -142,7 +143,7 @@ void dce100_set_bandwidth(
 
 /**************************************************************************/
 
-bool dce100_hw_sequencer_construct(struct dc *dc)
+bool dce100_hw_sequencer_construct(struct core_dc *dc)
 {
 	dce110_hw_sequencer_construct(dc);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.h
index 770b5bb..24433f0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_hw_sequencer.h
@@ -28,14 +28,14 @@
 
 #include "core_types.h"
 
-struct dc;
-struct dc_state;
+struct core_dc;
+struct validate_context;
 
-bool dce100_hw_sequencer_construct(struct dc *dc);
+bool dce100_hw_sequencer_construct(struct core_dc *dc);
 
 void dce100_set_bandwidth(
-		struct dc *dc,
-		struct dc_state *context,
+		struct core_dc *dc,
+		struct validate_context *context,
 		bool decrease_allowed);
 
 #endif /* __DC_HWSS_DCE100_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
index ca6c7c2..46f0c71 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c
@@ -652,29 +652,44 @@ static void destruct(struct dce110_resource_pool *pool)
 }
 
 static enum dc_status build_mapped_resource(
-		const struct dc  *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	enum dc_status status = DC_OK;
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
+	uint8_t i, j;
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
+
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
+
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
 
-	status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-	if (status != DC_OK)
-		return status;
+			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-	resource_build_info_frame(pipe_ctx);
+			if (status != DC_OK)
+				return status;
+
+			resource_build_info_frame(pipe_ctx);
+
+			/* do not need to validate non root pipes */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
 
 bool dce100_validate_bandwidth(
-	struct dc  *dc,
-	struct dc_state *context)
+	const struct core_dc *dc,
+	struct validate_context *context)
 {
 	/* TODO implement when needed but for now hardcode max value*/
 	context->bw.dce.dispclk_khz = 681000;
@@ -684,18 +699,19 @@ bool dce100_validate_bandwidth(
 }
 
 static bool dce100_validate_surface_sets(
-		struct dc_state *context)
+		const struct dc_validation_set set[],
+		int set_count)
 {
 	int i;
 
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->stream_status[i].plane_count == 0)
+	for (i = 0; i < set_count; i++) {
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (context->stream_status[i].plane_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (context->stream_status[i].plane_states[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -703,38 +719,54 @@ static bool dce100_validate_surface_sets(
 	return true;
 }
 
-enum dc_status dce100_validate_global(
-		struct dc  *dc,
-		struct dc_state *context)
+enum dc_status dce100_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
-	if (!dce100_validate_surface_sets(context))
+	struct dc_context *dc_ctx = dc->ctx;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
+
+	if (!dce100_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	return DC_OK;
-}
+	for (i = 0; i < set_count; i++) {
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
+		context->stream_count++;
+	}
 
-enum dc_status dce100_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *dc_stream)
-{
-	enum dc_status result = DC_ERROR_UNEXPECTED;
+	result = resource_map_pool_resources(dc, context, old_context);
+
+	if (result == DC_OK)
+		result = resource_map_clock_resources(dc, context, old_context);
 
-	result = resource_map_pool_resources(dc, new_ctx, dc_stream);
+	if (!resource_validate_attach_surfaces(set, set_count,
+			old_context, context, dc->res_pool)) {
+		DC_ERROR("Failed to attach surface to stream!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
+	if (result == DC_OK)
+		result = build_mapped_resource(dc, context, old_context);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, new_ctx, dc_stream);
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, new_ctx, dc_stream);
+		if (!dce100_validate_bandwidth(dc, context))
+			result = DC_FAIL_BANDWIDTH_VALIDATE;
 
 	return result;
 }
 
 enum dc_status dce100_validate_guaranteed(
-		struct dc  *dc,
+		const struct core_dc *dc,
 		struct dc_stream_state *dc_stream,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
@@ -742,17 +774,17 @@ enum dc_status dce100_validate_guaranteed(
 	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context, dc_stream);
+	result = resource_map_pool_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context, dc_stream);
+		result = resource_map_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, dc_stream);
+		result = build_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
-				context, dc->caps.max_streams);
+				context, dc->public.caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
@@ -784,16 +816,15 @@ enum dc_status dce100_validate_plane(const struct dc_plane_state *plane_state)
 static const struct resource_funcs dce100_res_pool_funcs = {
 	.destroy = dce100_destroy_resource_pool,
 	.link_enc_create = dce100_link_encoder_create,
+	.validate_with_context = dce100_validate_with_context,
 	.validate_guaranteed = dce100_validate_guaranteed,
 	.validate_bandwidth = dce100_validate_bandwidth,
 	.validate_plane = dce100_validate_plane,
-	.add_stream_to_ctx = dce100_add_stream_to_ctx,
-	.validate_global = dce100_validate_global
 };
 
 static bool construct(
 	uint8_t num_virtual_links,
-	struct dc  *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -878,9 +909,9 @@ static bool construct(
 	*************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap.num_timing_generator;
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 40;
-	dc->caps.max_cursor_size = 128;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
 
 	for (i = 0; i < pool->base.pipe_count; i++) {
 		pool->base.timing_generators[i] =
@@ -927,7 +958,7 @@ static bool construct(
 		}
 	}
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -947,7 +978,7 @@ static bool construct(
 
 struct resource_pool *dce100_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc  *dc)
+	struct core_dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
diff --git a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.h b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.h
index f52cae2..edc50ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.h
@@ -8,19 +8,14 @@
 #ifndef DCE100_RESOURCE_H_
 #define DCE100_RESOURCE_H_
 
-struct dc;
+struct core_dc;
 struct resource_pool;
 struct dc_validation_set;
 
 struct resource_pool *dce100_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc);
+	struct core_dc *dc);
 
 enum dc_status dce100_validate_plane(const struct dc_plane_state *plane_state);
 
-enum dc_status dce100_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *dc_stream);
-
 #endif /* DCE100_RESOURCE_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index f82c269..9759d8e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -115,7 +115,7 @@ static void wait_for_fbc_state_changed(
 			FBC_STATUS,
 			FBC_ENABLE_STATUS) == enabled)
 			break;
-		msleep(10);
+		udelay(10);
 		counter++;
 	}
 
@@ -124,13 +124,7 @@ static void wait_for_fbc_state_changed(
 			cp110->base.ctx->logger, LOG_WARNING,
 			"%s: wait counter exceeded, changes to HW not applied",
 			__func__);
-	} else {
-		dm_logger_write(
-			cp110->base.ctx->logger, LOG_SYNC,
-			"FBC status changed to %d", enabled);
 	}
-
-
 }
 
 void dce110_compressor_power_up_fbc(struct compressor *compressor)
@@ -189,7 +183,7 @@ void dce110_compressor_enable_fbc(
 		(!dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL))) {
 
 		uint32_t addr;
-		uint32_t value, misc_value;
+		uint32_t value;
 
 
 		addr = mmFBC_CNTL;
@@ -206,23 +200,9 @@ void dce110_compressor_enable_fbc(
 		compressor->attached_inst = params->inst;
 		cp110->offsets = reg_offsets[params->inst];
 
-		/* Toggle it as there is bug in HW */
+		/*Toggle it as there is bug in HW */
 		set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
 		dm_write_reg(compressor->ctx, addr, value);
-
-		/* FBC usage with scatter & gather for dce110 */
-		misc_value = dm_read_reg(compressor->ctx, mmFBC_MISC);
-
-		set_reg_field_value(misc_value, 1,
-				FBC_MISC, FBC_INVALIDATE_ON_ERROR);
-		set_reg_field_value(misc_value, 1,
-				FBC_MISC, FBC_DECOMPRESS_ERROR_CLEAR);
-		set_reg_field_value(misc_value, 0x14,
-				FBC_MISC, FBC_SLOW_REQ_INTERVAL);
-
-		dm_write_reg(compressor->ctx, mmFBC_MISC, misc_value);
-
-		/* Enable FBC */
 		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
 		dm_write_reg(compressor->ctx, addr, value);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 20054fc..8a3e992 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -164,7 +164,7 @@ static void enable_display_pipe_clock_gating(
 }
 
 static bool dce110_enable_display_power_gating(
-	struct dc *dc,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -758,6 +758,8 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
 
+		pipe_ctx->stream_res.audio = NULL;
+
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */
 		/* dal_audio_disable_azalia_audio_jack_presence(stream->audio,
@@ -778,11 +780,9 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 
 
 	/* blank at encoder level */
-	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
-		if (pipe_ctx->stream->sink->link->connector_signal == SIGNAL_TYPE_EDP)
-			link->link_enc->funcs->backlight_control(link->link_enc, false);
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
-	}
+
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,
 			pipe_ctx->stream_res.stream_enc->id,
@@ -794,15 +794,12 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 		struct dc_link_settings *link_settings)
 {
 	struct encoder_unblank_param params = { { 0 } };
-	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
 		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
-	if (link->connector_signal == SIGNAL_TYPE_EDP)
-			link->link_enc->funcs->backlight_control(link->link_enc, true);
 }
 
 
@@ -833,7 +830,6 @@ static enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)
 }
 
 static void build_audio_output(
-	struct dc_state *state,
 	const struct pipe_ctx *pipe_ctx,
 	struct audio_output *audio_output)
 {
@@ -895,8 +891,8 @@ static void build_audio_output(
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
 			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =
-				state->dis_clk->funcs->get_dp_ref_clk_frequency(
-						state->dis_clk);
+				pipe_ctx->dis_clk->funcs->get_dp_ref_clk_frequency(
+						pipe_ctx->dis_clk);
 	}
 
 	audio_output->pll_info.feed_back_divider =
@@ -948,7 +944,7 @@ static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void program_scaler(const struct dc *dc,
+static void program_scaler(const struct core_dc *dc,
 		const struct pipe_ctx *pipe_ctx)
 {
 	struct tg_color color = {0};
@@ -959,7 +955,7 @@ static void program_scaler(const struct dc *dc,
 		return;
 #endif
 
-	if (dc->debug.surface_visual_confirm)
+	if (dc->public.debug.surface_visual_confirm)
 		get_surface_visual_confirm_color(pipe_ctx, &color);
 	else
 		color_space_to_black_color(dc,
@@ -982,11 +978,11 @@ static void program_scaler(const struct dc *dc,
 
 static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
-		struct dc_state *context,
-		struct dc *dc)
+		struct validate_context *context,
+		struct core_dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
+	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
 
@@ -1038,11 +1034,11 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 static enum dc_status apply_single_controller_ctx_to_hw(
 		struct pipe_ctx *pipe_ctx,
-		struct dc_state *context,
-		struct dc *dc)
+		struct validate_context *context,
+		struct core_dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
+	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
 	/*  */
@@ -1087,14 +1083,11 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 
 /*vbios crtc_source_selection and encoder_setup will override fmt_C*/
-	if (pipe_ctx->stream->signal != SIGNAL_TYPE_EDP &&
-		pipe_ctx->stream->signal != SIGNAL_TYPE_LVDS) {
-	/*for embedded panel, don't override VBIOS's setting*/
-		pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 			pipe_ctx->stream_res.opp,
 			&stream->bit_depth_params,
 			&stream->clamping);
-	}
+
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_set_stream_attribute(
 			pipe_ctx->stream_res.stream_enc,
@@ -1118,7 +1111,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	resource_build_info_frame(pipe_ctx);
 	dce110_update_info_frame(pipe_ctx);
 	if (!pipe_ctx_old->stream) {
-		core_link_enable_stream(context, pipe_ctx);
+		core_link_enable_stream(pipe_ctx);
 
 
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
@@ -1153,25 +1146,17 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 /******************************************************************************/
 
-static void power_down_encoders(struct dc *dc)
+static void power_down_encoders(struct core_dc *dc)
 {
 	int i;
-	enum connector_id connector_id;
-	for (i = 0; i < dc->link_count; i++) {
-		connector_id = dal_graphics_object_id_get_connector_id(dc->links[i]->link_id);
-		if ((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||
-			(connector_id == CONNECTOR_ID_EDP)) {
-
-			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
-				dp_receiver_power_ctrl(dc->links[i], false);
-		}
 
+	for (i = 0; i < dc->link_count; i++) {
 		dc->links[i]->link_enc->funcs->disable_output(
 				dc->links[i]->link_enc, SIGNAL_TYPE_NONE);
 	}
 }
 
-static void power_down_controllers(struct dc *dc)
+static void power_down_controllers(struct core_dc *dc)
 {
 	int i;
 
@@ -1181,7 +1166,7 @@ static void power_down_controllers(struct dc *dc)
 	}
 }
 
-static void power_down_clock_sources(struct dc *dc)
+static void power_down_clock_sources(struct core_dc *dc)
 {
 	int i;
 
@@ -1196,7 +1181,7 @@ static void power_down_clock_sources(struct dc *dc)
 	}
 }
 
-static void power_down_all_hw_blocks(struct dc *dc)
+static void power_down_all_hw_blocks(struct core_dc *dc)
 {
 	power_down_encoders(dc);
 
@@ -1211,7 +1196,7 @@ static void power_down_all_hw_blocks(struct dc *dc)
 }
 
 static void disable_vga_and_power_gate_all_controllers(
-		struct dc *dc)
+		struct core_dc *dc)
 {
 	int i;
 	struct timing_generator *tg;
@@ -1239,7 +1224,7 @@ static void disable_vga_and_power_gate_all_controllers(
  *  3. Enable power gating for controller
  *  4. Set acc_mode_change bit (VBIOS will clear this bit when going to FSDOS)
  */
-void dce110_enable_accelerated_mode(struct dc *dc)
+void dce110_enable_accelerated_mode(struct core_dc *dc)
 {
 	power_down_all_hw_blocks(dc);
 
@@ -1265,8 +1250,8 @@ static uint32_t compute_pstate_blackout_duration(
 }
 
 void dce110_set_displaymarks(
-	const struct dc *dc,
-	struct dc_state *context)
+	const struct core_dc *dc,
+	struct validate_context *context)
 {
 	uint8_t i, num_pipes;
 	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
@@ -1279,7 +1264,7 @@ void dce110_set_displaymarks(
 			continue;
 
 		total_dest_line_time_ns = compute_pstate_blackout_duration(
-			dc->bw_vbios->blackout_duration, pipe_ctx->stream);
+			dc->bw_vbios.blackout_duration, pipe_ctx->stream);
 		pipe_ctx->plane_res.mi->funcs->mem_input_program_display_marks(
 			pipe_ctx->plane_res.mi,
 			context->bw.dce.nbp_state_change_wm_ns[num_pipes],
@@ -1331,7 +1316,7 @@ static void set_safe_displaymarks(
 }
 
 static void switch_dp_clock_sources(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	struct resource_context *res_ctx)
 {
 	uint8_t i;
@@ -1423,8 +1408,8 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
  * may read PLL register to get pixel clock
  */
 static uint32_t get_max_pixel_clock_for_all_paths(
-	struct dc *dc,
-	struct dc_state *context,
+	struct core_dc *dc,
+	struct validate_context *context,
 	bool pre_mode_set)
 {
 	uint32_t max_pix_clk = 0;
@@ -1464,40 +1449,48 @@ static uint32_t get_max_pixel_clock_for_all_paths(
  * etc support for dcn1.0
  */
 static void apply_min_clocks(
-	struct dc *dc,
-	struct dc_state *context,
+	struct core_dc *dc,
+	struct validate_context *context,
 	enum dm_pp_clocks_state *clocks_state,
 	bool pre_mode_set)
 {
 	struct state_dependent_clocks req_clocks = {0};
+	struct pipe_ctx *pipe_ctx;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		if (pipe_ctx->dis_clk != NULL)
+			break;
+	}
 
 	if (!pre_mode_set) {
 		/* set clock_state without verification */
-		if (context->dis_clk->funcs->set_min_clocks_state) {
-			context->dis_clk->funcs->set_min_clocks_state(
-						context->dis_clk, *clocks_state);
+		if (pipe_ctx->dis_clk->funcs->set_min_clocks_state) {
+			pipe_ctx->dis_clk->funcs->set_min_clocks_state(
+						pipe_ctx->dis_clk, *clocks_state);
 			return;
 		}
 
 		/* TODO: This is incorrect. Figure out how to fix. */
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
-				context->dis_clk->cur_clocks_value.dispclk_in_khz,
+				pipe_ctx->dis_clk->cur_clocks_value.dispclk_in_khz,
 				pre_mode_set,
 				false);
 
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_PIXELCLK,
-				context->dis_clk->cur_clocks_value.max_pixelclk_in_khz,
+				pipe_ctx->dis_clk->cur_clocks_value.max_pixelclk_in_khz,
 				pre_mode_set,
 				false);
 
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
-				context->dis_clk->cur_clocks_value.max_non_dp_phyclk_in_khz,
+				pipe_ctx->dis_clk->cur_clocks_value.max_non_dp_phyclk_in_khz,
 				pre_mode_set,
 				false);
 		return;
@@ -1511,28 +1504,28 @@ static void apply_min_clocks(
 	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
 			dc, context, true);
 
-	if (context->dis_clk->funcs->get_required_clocks_state) {
-		*clocks_state = context->dis_clk->funcs->get_required_clocks_state(
-				context->dis_clk, &req_clocks);
-		context->dis_clk->funcs->set_min_clocks_state(
-			context->dis_clk, *clocks_state);
+	if (pipe_ctx->dis_clk->funcs->get_required_clocks_state) {
+		*clocks_state = pipe_ctx->dis_clk->funcs->get_required_clocks_state(
+				pipe_ctx->dis_clk, &req_clocks);
+		pipe_ctx->dis_clk->funcs->set_min_clocks_state(
+			pipe_ctx->dis_clk, *clocks_state);
 	} else {
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
 				req_clocks.display_clk_khz,
 				pre_mode_set,
 				false);
 
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_PIXELCLK,
 				req_clocks.pixel_clk_khz,
 				pre_mode_set,
 				false);
 
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
 				req_clocks.pixel_clk_khz,
 				pre_mode_set,
@@ -1545,8 +1538,8 @@ static void apply_min_clocks(
 /*
  *  Check if FBC can be enabled
  */
-static enum dc_status validate_fbc(struct dc *dc,
-		struct dc_state *context)
+static enum dc_status validate_fbc(struct core_dc *dc,
+		struct validate_context *context)
 {
 	struct pipe_ctx *pipe_ctx =
 			      &context->res_ctx.pipe_ctx[0];
@@ -1575,8 +1568,8 @@ static enum dc_status validate_fbc(struct dc *dc,
 /*
  *  Enable FBC
  */
-static enum dc_status enable_fbc(struct dc *dc,
-		struct dc_state *context)
+static enum dc_status enable_fbc(struct core_dc *dc,
+		struct validate_context *context)
 {
 	enum dc_status status = validate_fbc(dc, context);
 
@@ -1604,15 +1597,15 @@ static enum dc_status enable_fbc(struct dc *dc,
 #endif
 
 static enum dc_status apply_ctx_to_hw_fpga(
-		struct dc *dc,
-		struct dc_state *context)
+		struct core_dc *dc,
+		struct validate_context *context)
 {
 	enum dc_status status = DC_ERROR_UNEXPECTED;
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-				&dc->current_state->res_ctx.pipe_ctx[i];
+				&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
@@ -1634,8 +1627,8 @@ static enum dc_status apply_ctx_to_hw_fpga(
 }
 
 static void dce110_reset_hw_ctx_wrap(
-		struct dc *dc,
-		struct dc_state *context)
+		struct core_dc *dc,
+		struct validate_context *context)
 {
 	int i;
 
@@ -1643,7 +1636,7 @@ static void dce110_reset_hw_ctx_wrap(
 	/* look up the targets that have been removed since last commit */
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_state->res_ctx.pipe_ctx[i];
+			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		/* Note: We need to disable output if clock sources change,
@@ -1665,9 +1658,9 @@ static void dce110_reset_hw_ctx_wrap(
 			}
 			pipe_ctx_old->stream_res.tg->funcs->disable_crtc(pipe_ctx_old->stream_res.tg);
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
-					pipe_ctx_old->plane_res.mi, dc->current_state->stream_count);
+					pipe_ctx_old->plane_res.mi, dc->current_context->stream_count);
 			resource_unreference_clock_source(
-					&dc->current_state->res_ctx, dc->res_pool,
+					&dc->current_context->res_ctx, dc->res_pool,
 					&pipe_ctx_old->clock_source);
 
 			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
@@ -1679,8 +1672,8 @@ static void dce110_reset_hw_ctx_wrap(
 
 
 enum dc_status dce110_apply_ctx_to_hw(
-		struct dc *dc,
-		struct dc_state *context)
+		struct core_dc *dc,
+		struct validate_context *context)
 {
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status status;
@@ -1706,7 +1699,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	/* below is for real asic only */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-					&dc->current_state->res_ctx.pipe_ctx[i];
+					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL || pipe_ctx->top_pipe)
@@ -1736,31 +1729,31 @@ enum dc_status dce110_apply_ctx_to_hw(
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	if (dc->ctx->dce_version >= DCN_VERSION_1_0) {
 		if (context->bw.dcn.calc_clk.fclk_khz
-				> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
+				> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
 			struct dm_pp_clock_for_voltage_req clock;
 
 			clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
 			clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
 			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-			dc->current_state->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
+			dc->current_context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
 			context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
 		}
 		if (context->bw.dcn.calc_clk.dcfclk_khz
-				> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
+				> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
 			struct dm_pp_clock_for_voltage_req clock;
 
 			clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
 			clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
 			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-			dc->current_state->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+			dc->current_context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
 			context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
 		}
 		if (context->bw.dcn.calc_clk.dispclk_khz
-				> dc->current_state->bw.dcn.cur_clk.dispclk_khz) {
+				> dc->current_context->bw.dcn.cur_clk.dispclk_khz) {
 			dc->res_pool->display_clock->funcs->set_clock(
 					dc->res_pool->display_clock,
 					context->bw.dcn.calc_clk.dispclk_khz);
-			dc->current_state->bw.dcn.cur_clk.dispclk_khz =
+			dc->current_context->bw.dcn.cur_clk.dispclk_khz =
 					context->bw.dcn.calc_clk.dispclk_khz;
 			context->bw.dcn.cur_clk.dispclk_khz =
 					context->bw.dcn.calc_clk.dispclk_khz;
@@ -1768,7 +1761,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	} else
 #endif
 	if (context->bw.dce.dispclk_khz
-			> dc->current_state->bw.dce.dispclk_khz) {
+			> dc->current_context->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dce.dispclk_khz * 115 / 100);
@@ -1807,7 +1800,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->stream_res.audio != NULL) {
 			struct audio_output audio_output;
 
-			build_audio_output(context, pipe_ctx, &audio_output);
+			build_audio_output(pipe_ctx, &audio_output);
 
 			pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
 				pipe_ctx->stream_res.audio,
@@ -1835,7 +1828,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 			if (pipe_ctx->stream_res.audio != NULL) {
 				struct audio_output audio_output;
 
-				build_audio_output(context, pipe_ctx, &audio_output);
+				build_audio_output(pipe_ctx, &audio_output);
 
 				pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
 					pipe_ctx->stream_res.audio,
@@ -1849,7 +1842,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-					&dc->current_state->res_ctx.pipe_ctx[i];
+					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
@@ -1869,7 +1862,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 			struct audio_output audio_output;
 
-			build_audio_output(context, pipe_ctx, &audio_output);
+			build_audio_output(pipe_ctx, &audio_output);
 
 			if (dc_is_dp_signal(pipe_ctx->stream->signal))
 				pipe_ctx->stream_res.stream_enc->funcs->dp_audio_setup(
@@ -1972,7 +1965,7 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
  * -------------------------------------------------|
  *
  ******************************************************************************/
-static void program_surface_visibility(const struct dc *dc,
+static void program_surface_visibility(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	enum blnd_mode blender_mode = BLND_MODE_CURRENT_PIPE;
@@ -2045,7 +2038,7 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
  * TODO REMOVE, USE UPDATE INSTEAD
  */
 static void set_plane_config(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct resource_context *res_ctx)
 {
@@ -2124,7 +2117,7 @@ static void set_plane_config(
 	if (mi->funcs->set_blank)
 		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
-	if (dc->config.gpu_vm_support)
+	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
@@ -2132,7 +2125,7 @@ static void set_plane_config(
 				plane_state->rotation);
 }
 
-static void update_plane_addr(const struct dc *dc,
+static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -2170,7 +2163,7 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-void dce110_power_down(struct dc *dc)
+void dce110_power_down(struct core_dc *dc)
 {
 	power_down_all_hw_blocks(dc);
 	disable_vga_and_power_gate_all_controllers(dc);
@@ -2215,7 +2208,7 @@ static bool wait_for_reset_trigger_to_occur(
 
 /* Enable timing synchronization for a group of Timing Generators. */
 static void dce110_enable_timing_synchronization(
-		struct dc *dc,
+		struct core_dc *dc,
 		int group_index,
 		int group_size,
 		struct pipe_ctx *grouped_pipes[])
@@ -2264,7 +2257,7 @@ static void dce110_enable_timing_synchronization(
 	DC_SYNC_INFO("GSL: Set-up complete.\n");
 }
 
-static void init_hw(struct dc *dc)
+static void init_hw(struct core_dc *dc)
 {
 	int i;
 	struct dc_bios *bp;
@@ -2328,7 +2321,7 @@ static void init_hw(struct dc *dc)
 }
 
 void dce110_fill_display_configs(
-	const struct dc_state *context,
+	const struct validate_context *context,
 	struct dm_pp_display_configuration *pp_display_cfg)
 {
 	int j;
@@ -2376,7 +2369,7 @@ void dce110_fill_display_configs(
 	pp_display_cfg->display_count = num_cfgs;
 }
 
-uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)
+uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 {
 	uint8_t j;
 	uint32_t min_vertical_blank_time = -1;
@@ -2401,7 +2394,7 @@ uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)
 }
 
 static int determine_sclk_from_bounding_box(
-		const struct dc *dc,
+		const struct core_dc *dc,
 		int required_sclk)
 {
 	int i;
@@ -2427,8 +2420,8 @@ static int determine_sclk_from_bounding_box(
 }
 
 static void pplib_apply_display_requirements(
-	struct dc *dc,
-	struct dc_state *context)
+	struct core_dc *dc,
+	struct validate_context *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
@@ -2481,24 +2474,24 @@ static void pplib_apply_display_requirements(
 }
 
 static void dce110_set_bandwidth(
-		struct dc *dc,
-		struct dc_state *context,
+		struct core_dc *dc,
+		struct validate_context *context,
 		bool decrease_allowed)
 {
 	dce110_set_displaymarks(dc, context);
 
-	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_state->bw.dce.dispclk_khz) {
+	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_context->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dce.dispclk_khz * 115 / 100);
-		dc->current_state->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
+		dc->current_context->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
 	}
 
 	pplib_apply_display_requirements(dc, context);
 }
 
 static void dce110_program_front_end_for_pipe(
-		struct dc *dc, struct pipe_ctx *pipe_ctx)
+		struct core_dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
 	struct pipe_ctx *old_pipe = NULL;
@@ -2509,8 +2502,8 @@ static void dce110_program_front_end_for_pipe(
 
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
-	if (dc->current_state)
-		old_pipe = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+	if (dc->current_context)
+		old_pipe = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
@@ -2579,7 +2572,7 @@ static void dce110_program_front_end_for_pipe(
 	if (mi->funcs->set_blank)
 		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
-	if (dc->config.gpu_vm_support)
+	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
@@ -2625,10 +2618,10 @@ static void dce110_program_front_end_for_pipe(
 }
 
 static void dce110_apply_ctx_for_surface(
-		struct dc *dc,
+		struct core_dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	int i, be_idx;
 
@@ -2655,10 +2648,10 @@ static void dce110_apply_ctx_for_surface(
 	}
 }
 
-static void dce110_power_down_fe(struct dc *dc, int fe_idx)
+static void dce110_power_down_fe(struct core_dc *dc, int fe_idx)
 {
 	/* Do not power down fe when stream is active on dce*/
-	if (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)
+	if (dc->current_context->res_ctx.pipe_ctx[fe_idx].stream)
 		return;
 
 	dc->hwss.enable_display_power_gating(
@@ -2669,7 +2662,7 @@ static void dce110_power_down_fe(struct dc *dc, int fe_idx)
 }
 
 static void dce110_wait_for_mpcc_disconnect(
-		struct dc *dc,
+		struct core_dc *dc,
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
 {
@@ -2698,10 +2691,6 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void ready_shared_resources(struct dc *dc) {}
-
-static void optimize_shared_resources(struct dc *dc) {}
-
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -2732,13 +2721,10 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
-	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
-	.ready_shared_resources = ready_shared_resources,
-	.optimize_shared_resources = optimize_shared_resources,
-
+	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect
 };
 
-bool dce110_hw_sequencer_construct(struct dc *dc)
+bool dce110_hw_sequencer_construct(struct core_dc *dc)
 {
 	dc->hwss = dce110_funcs;
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.h
index baa20c1..89782ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.h
@@ -29,21 +29,21 @@
 #include "core_types.h"
 
 #define GAMMA_HW_POINTS_NUM 256
-struct dc;
-struct dc_state;
+struct core_dc;
+struct validate_context;
 struct dm_pp_display_configuration;
 
-bool dce110_hw_sequencer_construct(struct dc *dc);
+bool dce110_hw_sequencer_construct(struct core_dc *dc);
 
 enum dc_status dce110_apply_ctx_to_hw(
-		struct dc *dc,
-		struct dc_state *context);
+		struct core_dc *dc,
+		struct validate_context *context);
 
-void dce110_set_display_clock(struct dc_state *context);
+void dce110_set_display_clock(struct validate_context *context);
 
 void dce110_set_displaymarks(
-	const struct dc *dc,
-	struct dc_state *context);
+	const struct core_dc *dc,
+	struct validate_context *context);
 
 void dce110_enable_stream(struct pipe_ctx *pipe_ctx);
 
@@ -55,18 +55,17 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 void dce110_update_info_frame(struct pipe_ctx *pipe_ctx);
 
 void dce110_set_avmute(struct pipe_ctx *pipe_ctx, bool enable);
-void dce110_enable_accelerated_mode(struct dc *dc);
+void dce110_enable_accelerated_mode(struct core_dc *dc);
 
-void dce110_power_down(struct dc *dc);
+void dce110_power_down(struct core_dc *dc);
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx);
 
 void dce110_fill_display_configs(
-	const struct dc_state *context,
+	const struct validate_context *context,
 	struct dm_pp_display_configuration *pp_display_cfg);
 
-uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context);
+uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context);
 
-void dp_receiver_power_ctrl(struct dc_link *link, bool on);
 #endif /* __DC_HWSS_DCE110_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 41bfddf..a7f30dc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -772,35 +772,50 @@ static bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigne
 }
 
 static enum dc_status build_mapped_resource(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	enum dc_status status = DC_OK;
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
+	uint8_t i, j;
+
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
 
-	if (!is_surface_pixel_format_supported(pipe_ctx,
-			dc->res_pool->underlay_pipe_index))
-		return DC_SURFACE_PIXEL_FORMAT_UNSUPPORTED;
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
 
-	status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-	if (status != DC_OK)
-		return status;
+			if (!is_surface_pixel_format_supported(pipe_ctx,
+					dc->res_pool->underlay_pipe_index))
+				return DC_SURFACE_PIXEL_FORMAT_UNSUPPORTED;
 
-	/* TODO: validate audio ASIC caps, encoder */
+			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-	resource_build_info_frame(pipe_ctx);
+			if (status != DC_OK)
+				return status;
+
+			/* TODO: validate audio ASIC caps, encoder */
+
+			resource_build_info_frame(pipe_ctx);
+
+			/* do not need to validate non root pipes */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
 
 static bool dce110_validate_bandwidth(
-	struct dc *dc,
-	struct dc_state *context)
+	const struct core_dc *dc,
+	struct validate_context *context)
 {
 	bool result = false;
 
@@ -811,8 +826,8 @@ static bool dce110_validate_bandwidth(
 
 	if (bw_calcs(
 			dc->ctx,
-			dc->bw_dceip,
-			dc->bw_vbios,
+			&dc->bw_dceip,
+			&dc->bw_vbios,
 			context->res_ctx.pipe_ctx,
 			dc->res_pool->pipe_count,
 			&context->bw.dce))
@@ -826,7 +841,7 @@ static bool dce110_validate_bandwidth(
 			context->streams[0]->timing.v_addressable,
 			context->streams[0]->timing.pix_clk_khz);
 
-	if (memcmp(&dc->current_state->bw.dce,
+	if (memcmp(&dc->current_context->bw.dce,
 			&context->bw.dce, sizeof(context->bw.dce))) {
 		struct log_entry log_entry;
 		dm_logger_open(
@@ -880,30 +895,31 @@ static bool dce110_validate_bandwidth(
 }
 
 static bool dce110_validate_surface_sets(
-		struct dc_state *context)
+		const struct dc_validation_set set[],
+		int set_count)
 {
 	int i;
 
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->stream_status[i].plane_count == 0)
+	for (i = 0; i < set_count; i++) {
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (context->stream_status[i].plane_count > 2)
+		if (set[i].plane_count > 2)
 			return false;
 
-		if (context->stream_status[i].plane_states[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 
-		if (context->stream_status[i].plane_count == 2) {
-			if (context->stream_status[i].plane_states[1]->format
+		if (set[i].plane_count == 2) {
+			if (set[i].plane_states[1]->format
 					< SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 				return false;
-			if (context->stream_status[i].plane_states[1]->src_rect.width > 1920
-					|| context->stream_status[i].plane_states[1]->src_rect.height > 1080)
+			if (set[i].plane_states[1]->src_rect.width > 1920
+					|| set[i].plane_states[1]->src_rect.height > 1080)
 				return false;
 
-			if (context->streams[i]->timing.pixel_encoding != PIXEL_ENCODING_RGB)
+			if (set[i].stream->timing.pixel_encoding != PIXEL_ENCODING_RGB)
 				return false;
 		}
 	}
@@ -911,39 +927,54 @@ static bool dce110_validate_surface_sets(
 	return true;
 }
 
-enum dc_status dce110_validate_global(
-		struct dc *dc,
-		struct dc_state *context)
+static enum dc_status dce110_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
-	if (!dce110_validate_surface_sets(context))
+	struct dc_context *dc_ctx = dc->ctx;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
+
+	if (!dce110_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	return DC_OK;
-}
+	for (i = 0; i < set_count; i++) {
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
+		context->stream_count++;
+	}
 
-static enum dc_status dce110_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *dc_stream)
-{
-	enum dc_status result = DC_ERROR_UNEXPECTED;
+	result = resource_map_pool_resources(dc, context, old_context);
+
+	if (result == DC_OK)
+		result = resource_map_clock_resources(dc, context, old_context);
 
-	result = resource_map_pool_resources(dc, new_ctx, dc_stream);
+	if (!resource_validate_attach_surfaces(set, set_count,
+			old_context, context, dc->res_pool)) {
+		DC_ERROR("Failed to attach surface to stream!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, new_ctx, dc_stream);
+		result = build_mapped_resource(dc, context, old_context);
 
+	if (result == DC_OK)
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, new_ctx, dc_stream);
+		if (!dce110_validate_bandwidth(dc, context))
+			result = DC_FAIL_BANDWIDTH_VALIDATE;
 
 	return result;
 }
 
 static enum dc_status dce110_validate_guaranteed(
-		struct dc *dc,
+		const struct core_dc *dc,
 		struct dc_stream_state *dc_stream,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
@@ -951,17 +982,17 @@ static enum dc_status dce110_validate_guaranteed(
 	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context, dc_stream);
+	result = resource_map_pool_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context, dc_stream);
+		result = resource_map_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, dc_stream);
+		result = build_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
-				context, dc->caps.max_streams);
+				context, dc->public.caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
@@ -973,11 +1004,11 @@ static enum dc_status dce110_validate_guaranteed(
 }
 
 static struct pipe_ctx *dce110_acquire_underlay(
-		struct dc_state *context,
+		struct validate_context *context,
 		const struct resource_pool *pool,
 		struct dc_stream_state *stream)
 {
-	struct dc *dc = stream->ctx->dc;
+	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx = &context->res_ctx;
 	unsigned int underlay_idx = pool->underlay_pipe_index;
 	struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[underlay_idx];
@@ -990,11 +1021,12 @@ static struct pipe_ctx *dce110_acquire_underlay(
 	/*pipe_ctx->plane_res.ipp = res_ctx->pool->ipps[underlay_idx];*/
 	pipe_ctx->plane_res.xfm = pool->transforms[underlay_idx];
 	pipe_ctx->stream_res.opp = pool->opps[underlay_idx];
+	pipe_ctx->dis_clk = pool->display_clock;
 	pipe_ctx->pipe_idx = underlay_idx;
 
 	pipe_ctx->stream = stream;
 
-	if (!dc->current_state->res_ctx.pipe_ctx[underlay_idx].stream) {
+	if (!dc->current_context->res_ctx.pipe_ctx[underlay_idx].stream) {
 		struct tg_color black_color = {0};
 		struct dc_bios *dcb = dc->ctx->dc_bios;
 
@@ -1046,11 +1078,10 @@ static void dce110_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce110_res_pool_funcs = {
 	.destroy = dce110_destroy_resource_pool,
 	.link_enc_create = dce110_link_encoder_create,
+	.validate_with_context = dce110_validate_with_context,
 	.validate_guaranteed = dce110_validate_guaranteed,
 	.validate_bandwidth = dce110_validate_bandwidth,
 	.acquire_idle_pipe_for_layer = dce110_acquire_underlay,
-	.add_stream_to_ctx = dce110_add_stream_to_ctx,
-	.validate_global = dce110_validate_global
 };
 
 static bool underlay_create(struct dc_context *ctx, struct resource_pool *pool)
@@ -1086,7 +1117,7 @@ static bool underlay_create(struct dc_context *ctx, struct resource_pool *pool)
 	return true;
 }
 
-static void bw_calcs_data_update_from_pplib(struct dc *dc)
+static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 {
 	struct dm_pp_clock_levels clks = {0};
 
@@ -1096,21 +1127,21 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 			DM_PP_CLOCK_TYPE_ENGINE_CLK,
 			&clks);
 	/* convert all the clock fro kHz to fix point mHz */
-	dc->bw_vbios->high_sclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_sclk = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels-1], 1000);
-	dc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid1_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels/8], 1000);
-	dc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid2_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels*2/8], 1000);
-	dc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid3_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels*3/8], 1000);
-	dc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid4_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels*4/8], 1000);
-	dc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid5_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels*5/8], 1000);
-	dc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid6_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels*6/8], 1000);
-	dc->bw_vbios->low_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.low_sclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[0], 1000);
 	dc->sclk_lvls = clks;
 
@@ -1119,11 +1150,11 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 			dc->ctx,
 			DM_PP_CLOCK_TYPE_DISPLAY_CLK,
 			&clks);
-	dc->bw_vbios->high_voltage_max_dispclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_voltage_max_dispclk = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels-1], 1000);
-	dc->bw_vbios->mid_voltage_max_dispclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid_voltage_max_dispclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels>>1], 1000);
-	dc->bw_vbios->low_voltage_max_dispclk  = bw_frc_to_fixed(
+	dc->bw_vbios.low_voltage_max_dispclk  = bw_frc_to_fixed(
 			clks.clocks_in_khz[0], 1000);
 
 	/*do memory clock*/
@@ -1132,12 +1163,12 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 			DM_PP_CLOCK_TYPE_MEMORY_CLK,
 			&clks);
 
-	dc->bw_vbios->low_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.low_yclk = bw_frc_to_fixed(
 		clks.clocks_in_khz[0] * MEMORY_TYPE_MULTIPLIER, 1000);
-	dc->bw_vbios->mid_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.mid_yclk = bw_frc_to_fixed(
 		clks.clocks_in_khz[clks.num_levels>>1] * MEMORY_TYPE_MULTIPLIER,
 		1000);
-	dc->bw_vbios->high_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_yclk = bw_frc_to_fixed(
 		clks.clocks_in_khz[clks.num_levels-1] * MEMORY_TYPE_MULTIPLIER,
 		1000);
 }
@@ -1153,7 +1184,7 @@ const struct resource_caps *dce110_resource_cap(
 
 static bool construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool,
 	struct hw_asic_id asic_id)
 {
@@ -1175,9 +1206,9 @@ static bool construct(
 	pool->base.pipe_count = pool->base.res_cap->num_timing_generator;
 	pool->base.underlay_pipe_index = pool->base.pipe_count;
 
-	dc->caps.max_downscale_ratio = 150;
-	dc->caps.i2c_speed_in_khz = 100;
-	dc->caps.max_cursor_size = 128;
+	dc->public.caps.max_downscale_ratio = 150;
+	dc->public.caps.i2c_speed_in_khz = 100;
+	dc->public.caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1320,9 +1351,9 @@ static bool construct(
 	if (!dce110_hw_sequencer_construct(dc))
 		goto res_create_fail;
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
-	bw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);
+	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
 	bw_calcs_data_update_from_pplib(dc);
 
@@ -1335,7 +1366,7 @@ static bool construct(
 
 struct resource_pool *dce110_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct hw_asic_id asic_id)
 {
 	struct dce110_resource_pool *pool =
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.h b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.h
index 5bb692d..8e2e85d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.h
@@ -28,7 +28,7 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 struct resource_pool;
 
 #define TO_DCE110_RES_POOL(pool)\
@@ -42,7 +42,7 @@ enum dc_status dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx);
 
 struct resource_pool *dce110_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct hw_asic_id asic_id);
 
 #endif /* __DC_RESOURCE_DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.c
index 8816e09..204f613 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.c
@@ -25,6 +25,7 @@
 
 #include "dm_services.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "core_types.h"
 #include "dce112_hw_sequencer.h"
 
@@ -111,7 +112,7 @@ static void dce112_init_pte(struct dc_context *ctx)
 }
 
 static bool dce112_enable_display_power_gating(
-	struct dc *dc,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -152,7 +153,7 @@ static bool dce112_enable_display_power_gating(
 		return false;
 }
 
-bool dce112_hw_sequencer_construct(struct dc *dc)
+bool dce112_hw_sequencer_construct(struct core_dc *dc)
 {
 	/* All registers used by dce11.2 match those in dce11 in offset and
 	 * structure
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.h
index 37bd60c..d96c582 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_hw_sequencer.h
@@ -28,9 +28,9 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 
-bool dce112_hw_sequencer_construct(struct dc *dc);
+bool dce112_hw_sequencer_construct(struct core_dc *dc);
 
 #endif /* __DC_HWSS_DCE112_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
index de6f71d..420434d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -723,29 +723,44 @@ static struct clock_source *find_matching_pll(
 }
 
 static enum dc_status build_mapped_resource(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	enum dc_status status = DC_OK;
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
+	uint8_t i, j;
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
+
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
+
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
+
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-	status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-	if (status != DC_OK)
-		return status;
+			if (status != DC_OK)
+				return status;
 
-	resource_build_info_frame(pipe_ctx);
+			resource_build_info_frame(pipe_ctx);
+
+			/* do not need to validate non root pipes */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
 
 bool dce112_validate_bandwidth(
-	struct dc *dc,
-	struct dc_state *context)
+	const struct core_dc *dc,
+	struct validate_context *context)
 {
 	bool result = false;
 
@@ -756,8 +771,8 @@ bool dce112_validate_bandwidth(
 
 	if (bw_calcs(
 			dc->ctx,
-			dc->bw_dceip,
-			dc->bw_vbios,
+			&dc->bw_dceip,
+			&dc->bw_vbios,
 			context->res_ctx.pipe_ctx,
 			dc->res_pool->pipe_count,
 			&context->bw.dce))
@@ -768,7 +783,7 @@ bool dce112_validate_bandwidth(
 			"%s: Bandwidth validation failed!",
 			__func__);
 
-	if (memcmp(&dc->current_state->bw.dce,
+	if (memcmp(&dc->current_context->bw.dce,
 			&context->bw.dce, sizeof(context->bw.dce))) {
 		struct log_entry log_entry;
 		dm_logger_open(
@@ -822,51 +837,65 @@ bool dce112_validate_bandwidth(
 }
 
 enum dc_status resource_map_phy_clock_resources(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
+	uint8_t i, j;
 
 	/* acquire new resources */
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(
-			&context->res_ctx, stream);
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
 
-	if (dc_is_dp_signal(pipe_ctx->stream->signal)
-		|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
-		pipe_ctx->clock_source =
-				dc->res_pool->dp_clock_source;
-	else
-		pipe_ctx->clock_source = find_matching_pll(
-			&context->res_ctx, dc->res_pool,
-			stream);
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
+
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-	if (pipe_ctx->clock_source == NULL)
-		return DC_NO_CLOCK_SOURCE_RESOURCE;
+			if (dc_is_dp_signal(pipe_ctx->stream->signal)
+				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
+				pipe_ctx->clock_source =
+						dc->res_pool->dp_clock_source;
+			else
+				pipe_ctx->clock_source = find_matching_pll(
+					&context->res_ctx, dc->res_pool,
+					stream);
 
-	resource_reference_clock_source(
-		&context->res_ctx,
-		dc->res_pool,
-		pipe_ctx->clock_source);
+			if (pipe_ctx->clock_source == NULL)
+				return DC_NO_CLOCK_SOURCE_RESOURCE;
+
+			resource_reference_clock_source(
+				&context->res_ctx,
+				dc->res_pool,
+				pipe_ctx->clock_source);
+
+			/* only one cs per stream regardless of mpo */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
 
 static bool dce112_validate_surface_sets(
-		struct dc_state *context)
+		const struct dc_validation_set set[],
+		int set_count)
 {
 	int i;
 
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->stream_status[i].plane_count == 0)
+	for (i = 0; i < set_count; i++) {
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (context->stream_status[i].plane_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (context->stream_status[i].plane_states[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -874,29 +903,54 @@ static bool dce112_validate_surface_sets(
 	return true;
 }
 
-enum dc_status dce112_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *dc_stream)
+enum dc_status dce112_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
+	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
 
-	result = resource_map_pool_resources(dc, new_ctx, dc_stream);
+	if (!dce112_validate_surface_sets(set, set_count))
+		return DC_FAIL_SURFACE_VALIDATE;
+
+	for (i = 0; i < set_count; i++) {
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
+		context->stream_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context, old_context);
 
 	if (result == DC_OK)
-		result = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);
+		result = resource_map_phy_clock_resources(dc, context, old_context);
 
+	if (!resource_validate_attach_surfaces(set, set_count,
+			old_context, context, dc->res_pool)) {
+		DC_ERROR("Failed to attach surface to stream!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
+	if (result == DC_OK)
+		result = build_mapped_resource(dc, context, old_context);
+
+	if (result == DC_OK)
+		result = resource_build_scaling_params_for_context(dc, context);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, new_ctx, dc_stream);
+		if (!dce112_validate_bandwidth(dc, context))
+			result = DC_FAIL_BANDWIDTH_VALIDATE;
 
 	return result;
 }
 
 enum dc_status dce112_validate_guaranteed(
-		struct dc *dc,
+		const struct core_dc *dc,
 		struct dc_stream_state *stream,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
@@ -904,17 +958,17 @@ enum dc_status dce112_validate_guaranteed(
 	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context, stream);
+	result = resource_map_pool_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = resource_map_phy_clock_resources(dc, context, stream);
+		result = resource_map_phy_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, stream);
+		result = build_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
-				context, dc->caps.max_streams);
+				context, dc->public.caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
@@ -925,16 +979,6 @@ enum dc_status dce112_validate_guaranteed(
 	return result;
 }
 
-enum dc_status dce112_validate_global(
-		struct dc *dc,
-		struct dc_state *context)
-{
-	if (!dce112_validate_surface_sets(context))
-		return DC_FAIL_SURFACE_VALIDATE;
-
-	return DC_OK;
-}
-
 static void dce112_destroy_resource_pool(struct resource_pool **pool)
 {
 	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
@@ -947,14 +991,13 @@ static void dce112_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce112_res_pool_funcs = {
 	.destroy = dce112_destroy_resource_pool,
 	.link_enc_create = dce112_link_encoder_create,
+	.validate_with_context = dce112_validate_with_context,
 	.validate_guaranteed = dce112_validate_guaranteed,
 	.validate_bandwidth = dce112_validate_bandwidth,
-	.validate_plane = dce100_validate_plane,
-	.add_stream_to_ctx = dce112_add_stream_to_ctx,
-	.validate_global = dce112_validate_global
+	.validate_plane = dce100_validate_plane
 };
 
-static void bw_calcs_data_update_from_pplib(struct dc *dc)
+static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 {
 	struct dm_pp_clock_levels_with_latency eng_clks = {0};
 	struct dm_pp_clock_levels_with_latency mem_clks = {0};
@@ -975,21 +1018,21 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 				DM_PP_CLOCK_TYPE_ENGINE_CLK,
 				&clks);
 		/* convert all the clock fro kHz to fix point mHz */
-		dc->bw_vbios->high_sclk = bw_frc_to_fixed(
+		dc->bw_vbios.high_sclk = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels-1], 1000);
-		dc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.mid1_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels/8], 1000);
-		dc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.mid2_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels*2/8], 1000);
-		dc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.mid3_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels*3/8], 1000);
-		dc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.mid4_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels*4/8], 1000);
-		dc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.mid5_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels*5/8], 1000);
-		dc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.mid6_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[clks.num_levels*6/8], 1000);
-		dc->bw_vbios->low_sclk  = bw_frc_to_fixed(
+		dc->bw_vbios.low_sclk  = bw_frc_to_fixed(
 				clks.clocks_in_khz[0], 1000);
 
 		/*do memory clock*/
@@ -998,12 +1041,12 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 				DM_PP_CLOCK_TYPE_MEMORY_CLK,
 				&clks);
 
-		dc->bw_vbios->low_yclk = bw_frc_to_fixed(
+		dc->bw_vbios.low_yclk = bw_frc_to_fixed(
 			clks.clocks_in_khz[0] * MEMORY_TYPE_MULTIPLIER, 1000);
-		dc->bw_vbios->mid_yclk = bw_frc_to_fixed(
+		dc->bw_vbios.mid_yclk = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels>>1] * MEMORY_TYPE_MULTIPLIER,
 			1000);
-		dc->bw_vbios->high_yclk = bw_frc_to_fixed(
+		dc->bw_vbios.high_yclk = bw_frc_to_fixed(
 			clks.clocks_in_khz[clks.num_levels-1] * MEMORY_TYPE_MULTIPLIER,
 			1000);
 
@@ -1011,21 +1054,21 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 	}
 
 	/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */
-	dc->bw_vbios->high_sclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_sclk = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);
-	dc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid1_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid2_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid3_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid4_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid5_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid6_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);
-	dc->bw_vbios->low_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.low_sclk  = bw_frc_to_fixed(
 			eng_clks.data[0].clocks_in_khz, 1000);
 
 	/*do memory clock*/
@@ -1039,12 +1082,12 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 	 * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):
 	 * YCLK = UMACLK*m_memoryTypeMultiplier
 	 */
-	dc->bw_vbios->low_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.low_yclk = bw_frc_to_fixed(
 		mem_clks.data[0].clocks_in_khz * MEMORY_TYPE_MULTIPLIER, 1000);
-	dc->bw_vbios->mid_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.mid_yclk = bw_frc_to_fixed(
 		mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
-	dc->bw_vbios->high_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_yclk = bw_frc_to_fixed(
 		mem_clks.data[mem_clks.num_levels-1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
 
@@ -1110,7 +1153,7 @@ const struct resource_caps *dce112_resource_cap(
 
 static bool construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -1127,9 +1170,9 @@ static bool construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = pool->base.res_cap->num_timing_generator;
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 100;
-	dc->caps.max_cursor_size = 128;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 100;
+	dc->public.caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1276,13 +1319,13 @@ static bool construct(
 			  &res_create_funcs))
 		goto res_create_fail;
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	/* Create hardware sequencer */
 	if (!dce112_hw_sequencer_construct(dc))
 		goto res_create_fail;
 
-	bw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);
+	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
 	bw_calcs_data_update_from_pplib(dc);
 
@@ -1295,7 +1338,7 @@ static bool construct(
 
 struct resource_pool *dce112_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc)
+	struct core_dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
diff --git a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
index d5c19d3..feef559 100644
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.h
@@ -28,33 +28,28 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 struct resource_pool;
 
 struct resource_pool *dce112_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc);
+	struct core_dc *dc);
 
 enum dc_status dce112_validate_with_context(
-		struct dc *dc,
+		const struct core_dc *dc,
 		const struct dc_validation_set set[],
 		int set_count,
-		struct dc_state *context,
-		struct dc_state *old_context);
+		struct validate_context *context,
+		struct validate_context *old_context);
 
 enum dc_status dce112_validate_guaranteed(
-		struct dc *dc,
+		const struct core_dc *dc,
 		struct dc_stream_state *dc_stream,
-		struct dc_state *context);
+		struct validate_context *context);
 
 bool dce112_validate_bandwidth(
-	struct dc *dc,
-	struct dc_state *context);
-
-enum dc_status dce112_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *dc_stream);
+	const struct core_dc *dc,
+	struct validate_context *context);
 
 
 #endif /* __DC_RESOURCE_DCE112_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.c
index 56e3b12..91301b4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.c
@@ -25,12 +25,14 @@
 
 #include "dm_services.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "core_types.h"
 #include "dce120_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
 
 #include "dce110/dce110_hw_sequencer.h"
 
+/* include DCE12.0 register header files */
 #include "vega10/DC/dce_12_0_offset.h"
 #include "vega10/DC/dce_12_0_sh_mask.h"
 #include "vega10/soc15ip.h"
@@ -147,7 +149,7 @@ static void dce120_init_pte(struct dc_context *ctx, uint8_t controller_id)
 #endif
 
 static bool dce120_enable_display_power_gating(
-	struct dc *dc,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -245,7 +247,7 @@ static void dce120_update_dchub(
 
 
 
-bool dce120_hw_sequencer_construct(struct dc *dc)
+bool dce120_hw_sequencer_construct(struct core_dc *dc)
 {
 	/* All registers used by dce11.2 match those in dce11 in offset and
 	 * structure
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.h
index 6448a17..3402413 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_hw_sequencer.h
@@ -28,9 +28,9 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 
-bool dce120_hw_sequencer_construct(struct dc *dc);
+bool dce120_hw_sequencer_construct(struct core_dc *dc);
 
 #endif /* __DC_HWSS_DCE112_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
index e5d2d98..d4e9627 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c
@@ -410,7 +410,7 @@ void dce120_clock_source_destroy(struct clock_source **clk_src)
 }
 
 
-bool dce120_hw_sequencer_create(struct dc *dc)
+bool dce120_hw_sequencer_create(struct core_dc *dc)
 {
 	/* All registers used by dce11.2 match those in dce11 in offset and
 	 * structure
@@ -698,13 +698,13 @@ static void dce120_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce120_res_pool_funcs = {
 	.destroy = dce120_destroy_resource_pool,
 	.link_enc_create = dce120_link_encoder_create,
+	.validate_with_context = dce112_validate_with_context,
 	.validate_guaranteed = dce112_validate_guaranteed,
 	.validate_bandwidth = dce112_validate_bandwidth,
-	.validate_plane = dce100_validate_plane,
-	.add_stream_to_ctx = dce112_add_stream_to_ctx
+	.validate_plane = dce100_validate_plane
 };
 
-static void bw_calcs_data_update_from_pplib(struct dc *dc)
+static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 {
 	struct dm_pp_clock_levels_with_latency eng_clks = {0};
 	struct dm_pp_clock_levels_with_latency mem_clks = {0};
@@ -729,21 +729,21 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 	}
 
 	/* convert all the clock fro kHz to fix point mHz  TODO: wloop data */
-	dc->bw_vbios->high_sclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_sclk = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels-1].clocks_in_khz, 1000);
-	dc->bw_vbios->mid1_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid1_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid2_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid2_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*2/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid3_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid3_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid4_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid4_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*4/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid5_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid5_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*5/8].clocks_in_khz, 1000);
-	dc->bw_vbios->mid6_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.mid6_sclk  = bw_frc_to_fixed(
 		eng_clks.data[eng_clks.num_levels*6/8].clocks_in_khz, 1000);
-	dc->bw_vbios->low_sclk  = bw_frc_to_fixed(
+	dc->bw_vbios.low_sclk  = bw_frc_to_fixed(
 			eng_clks.data[0].clocks_in_khz, 1000);
 
 	/*do memory clock*/
@@ -770,12 +770,12 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 	 * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):
 	 * YCLK = UMACLK*m_memoryTypeMultiplier
 	 */
-	dc->bw_vbios->low_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.low_yclk = bw_frc_to_fixed(
 		mem_clks.data[0].clocks_in_khz * MEMORY_TYPE_MULTIPLIER, 1000);
-	dc->bw_vbios->mid_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.mid_yclk = bw_frc_to_fixed(
 		mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
-	dc->bw_vbios->high_yclk = bw_frc_to_fixed(
+	dc->bw_vbios.high_yclk = bw_frc_to_fixed(
 		mem_clks.data[mem_clks.num_levels-1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
 
@@ -831,7 +831,7 @@ static void bw_calcs_data_update_from_pplib(struct dc *dc)
 
 static bool construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -847,10 +847,10 @@ static bool construct(
 	pool->base.pipe_count = res_cap.num_timing_generator;
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 100;
-	dc->caps.max_cursor_size = 128;
-	dc->debug = debug_defaults;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 100;
+	dc->public.caps.max_cursor_size = 128;
+	dc->public.debug = debug_defaults;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -982,9 +982,9 @@ static bool construct(
 	if (!dce120_hw_sequencer_create(dc))
 		goto controller_create_fail;
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
-	bw_calcs_init(dc->bw_dceip, dc->bw_vbios, dc->ctx->asic_id);
+	bw_calcs_init(&dc->bw_dceip, &dc->bw_vbios, dc->ctx->asic_id);
 
 	bw_calcs_data_update_from_pplib(dc);
 
@@ -1003,7 +1003,7 @@ static bool construct(
 
 struct resource_pool *dce120_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc)
+	struct core_dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
diff --git a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.h b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.h
index 3d1f3cf0..038c78d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.h
@@ -28,12 +28,12 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 struct resource_pool;
 
 struct resource_pool *dce120_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc);
+	struct core_dc *dc);
 
 #endif /* __DC_RESOURCE_DCE120_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.c
index 28fe382..4cba80f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.c
@@ -25,6 +25,7 @@
 
 #include "dm_services.h"
 #include "dc.h"
+#include "core_dc.h"
 #include "core_types.h"
 #include "dce80_hw_sequencer.h"
 
@@ -71,7 +72,7 @@ static const struct dce80_hw_seq_reg_offsets reg_offsets[] = {
 /***************************PIPE_CONTROL***********************************/
 
 static bool dce80_enable_display_power_gating(
-	struct dc *dc,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -106,7 +107,7 @@ static bool dce80_enable_display_power_gating(
 		return false;
 }
 
-bool dce80_hw_sequencer_construct(struct dc *dc)
+bool dce80_hw_sequencer_construct(struct core_dc *dc)
 {
 	dce110_hw_sequencer_construct(dc);
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.h
index 9d6dd05..7cc203f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_hw_sequencer.h
@@ -28,9 +28,9 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 
-bool dce80_hw_sequencer_construct(struct dc *dc);
+bool dce80_hw_sequencer_construct(struct core_dc *dc);
 
 #endif /* __DC_HWSS_DCE80_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5453f02..132117e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -187,7 +187,7 @@ static const struct dce_ipp_mask ipp_mask = {
 
 #define transform_regs(id)\
 [id] = {\
-		XFM_COMMON_REG_LIST_DCE80(id)\
+		XFM_COMMON_REG_LIST_DCE_BASE(id)\
 }
 
 static const struct dce_transform_registers xfm_regs[] = {
@@ -200,11 +200,11 @@ static const struct dce_transform_registers xfm_regs[] = {
 };
 
 static const struct dce_transform_shift xfm_shift = {
-		XFM_COMMON_MASK_SH_LIST_DCE80(__SHIFT)
+		XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
 static const struct dce_transform_mask xfm_mask = {
-		XFM_COMMON_MASK_SH_LIST_DCE80(_MASK)
+		XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
 #define aux_regs(id)\
@@ -684,29 +684,44 @@ static void destruct(struct dce110_resource_pool *pool)
 }
 
 static enum dc_status build_mapped_resource(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	enum dc_status status = DC_OK;
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
+	uint8_t i, j;
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
+
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
+			continue;
+
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
 
-	status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-	if (status != DC_OK)
-		return status;
+			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-	resource_build_info_frame(pipe_ctx);
+			if (status != DC_OK)
+				return status;
+
+			resource_build_info_frame(pipe_ctx);
+
+			/* do not need to validate non root pipes */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
 
 bool dce80_validate_bandwidth(
-	struct dc *dc,
-	struct dc_state *context)
+	const struct core_dc *dc,
+	struct validate_context *context)
 {
 	/* TODO implement when needed but for now hardcode max value*/
 	context->bw.dce.dispclk_khz = 681000;
@@ -716,18 +731,19 @@ bool dce80_validate_bandwidth(
 }
 
 static bool dce80_validate_surface_sets(
-		struct dc_state *context)
+		const struct dc_validation_set set[],
+		int set_count)
 {
 	int i;
 
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->stream_status[i].plane_count == 0)
+	for (i = 0; i < set_count; i++) {
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (context->stream_status[i].plane_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (context->stream_status[i].plane_states[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -735,20 +751,53 @@ static bool dce80_validate_surface_sets(
 	return true;
 }
 
-enum dc_status dce80_validate_global(
-		struct dc *dc,
-		struct dc_state *context)
+enum dc_status dce80_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
-	if (!dce80_validate_surface_sets(context))
+	struct dc_context *dc_ctx = dc->ctx;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
+
+	if (!dce80_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	return DC_OK;
+	for (i = 0; i < set_count; i++) {
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
+		context->stream_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context, old_context);
+
+	if (result == DC_OK)
+		result = resource_map_clock_resources(dc, context, old_context);
+
+	if (!resource_validate_attach_surfaces(set, set_count,
+			old_context, context, dc->res_pool)) {
+		DC_ERROR("Failed to attach surface to stream!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
+	if (result == DC_OK)
+		result = build_mapped_resource(dc, context, old_context);
+
+	if (result == DC_OK)
+		result = resource_build_scaling_params_for_context(dc, context);
+
+	if (result == DC_OK)
+		result = dce80_validate_bandwidth(dc, context);
+
+	return result;
 }
 
 enum dc_status dce80_validate_guaranteed(
-		struct dc *dc,
+		const struct core_dc *dc,
 		struct dc_stream_state *dc_stream,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
@@ -756,17 +805,17 @@ enum dc_status dce80_validate_guaranteed(
 	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context, dc_stream);
+	result = resource_map_pool_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context, dc_stream);
+		result = resource_map_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, dc_stream);
+		result = build_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
-				context, dc->caps.max_streams);
+				context, dc->public.caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
@@ -788,16 +837,15 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce80_res_pool_funcs = {
 	.destroy = dce80_destroy_resource_pool,
 	.link_enc_create = dce80_link_encoder_create,
+	.validate_with_context = dce80_validate_with_context,
 	.validate_guaranteed = dce80_validate_guaranteed,
 	.validate_bandwidth = dce80_validate_bandwidth,
-	.validate_plane = dce100_validate_plane,
-	.add_stream_to_ctx = dce100_add_stream_to_ctx,
-	.validate_global = dce80_validate_global
+	.validate_plane = dce100_validate_plane
 };
 
 static bool dce80_construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -817,9 +865,9 @@ static bool dce80_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap.num_timing_generator;
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 40;
-	dc->caps.max_cursor_size = 128;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -926,7 +974,7 @@ static bool dce80_construct(
 		}
 	}
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -945,7 +993,7 @@ static bool dce80_construct(
 
 struct resource_pool *dce80_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc)
+	struct core_dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
@@ -962,7 +1010,7 @@ struct resource_pool *dce80_create_resource_pool(
 
 static bool dce81_construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -982,9 +1030,9 @@ static bool dce81_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap_81.num_timing_generator;
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 40;
-	dc->caps.max_cursor_size = 128;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1091,7 +1139,7 @@ static bool dce81_construct(
 		}
 	}
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -1110,7 +1158,7 @@ static bool dce81_construct(
 
 struct resource_pool *dce81_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc)
+	struct core_dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
@@ -1127,7 +1175,7 @@ struct resource_pool *dce81_create_resource_pool(
 
 static bool dce83_construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -1147,9 +1195,9 @@ static bool dce83_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap_83.num_timing_generator;
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 40;
-	dc->caps.max_cursor_size = 128;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1252,7 +1300,7 @@ static bool dce83_construct(
 		}
 	}
 
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -1271,7 +1319,7 @@ static bool dce83_construct(
 
 struct resource_pool *dce83_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc)
+	struct core_dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.h b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.h
index eff31ab8..04f0cfe 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.h
@@ -28,20 +28,20 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 struct resource_pool;
 
 struct resource_pool *dce80_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc);
+	struct core_dc *dc);
 
 struct resource_pool *dce81_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc);
+	struct core_dc *dc);
 
 struct resource_pool *dce83_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct dc *dc);
+	struct core_dc *dc);
 
 #endif /* __DC_RESOURCE_DCE80_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/Makefile b/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
index 52b56d1..9ba1bfc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/Makefile
@@ -3,8 +3,7 @@
 
 DCN10 = dcn10_resource.o dcn10_ipp.o dcn10_hw_sequencer.o \
 		dcn10_dpp.o dcn10_opp.o dcn10_timing_generator.o \
-		dcn10_mem_input.o dcn10_mpc.o dcn10_dwb.o \
-		dcn10_dpp_dscl.o dcn10_dpp_cm.o
+		dcn10_mem_input.o dcn10_mpc.o
 
 AMD_DAL_DCN10 = $(addprefix $(AMDDALPATH)/dc/dcn10/,$(DCN10))
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 99caafb..e52e1f4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -27,6 +27,10 @@
 
 #include "core_types.h"
 
+#include "include/grph_object_id.h"
+#include "include/fixed31_32.h"
+#include "include/logger_interface.h"
+
 #include "reg_helper.h"
 #include "dcn10_dpp.h"
 #include "basics/conversion.h"
@@ -48,12 +52,6 @@
 #define FN(reg_name, field_name) \
 	xfm->tf_shift->field_name, xfm->tf_mask->field_name
 
-enum pixel_format_description {
-	PIXEL_FORMAT_FIXED = 0,
-	PIXEL_FORMAT_FIXED16,
-	PIXEL_FORMAT_FLOAT
-
-};
 
 enum dcn10_coef_filter_type_sel {
 	SCL_COEF_LUMA_VERT_FILTER = 0,
@@ -64,6 +62,22 @@ enum dcn10_coef_filter_type_sel {
 	SCL_COEF_ALPHA_HORZ_FILTER = 5
 };
 
+enum lb_memory_config {
+	/* Enable all 3 pieces of memory */
+	LB_MEMORY_CONFIG_0 = 0,
+
+	/* Enable only the first piece of memory */
+	LB_MEMORY_CONFIG_1 = 1,
+
+	/* Enable only the second piece of memory */
+	LB_MEMORY_CONFIG_2 = 2,
+
+	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
+	 * last piece of chroma memory used for the luma storage
+	 */
+	LB_MEMORY_CONFIG_3 = 3
+};
+
 enum dscl_autocal_mode {
 	AUTOCAL_MODE_OFF = 0,
 
@@ -98,6 +112,514 @@ enum gamut_remap_select {
 	GAMUT_REMAP_COMB_COEFF
 };
 
+static void dpp_set_overscan(
+	struct dcn10_dpp *xfm,
+	const struct scaler_data *data)
+{
+	uint32_t left = data->recout.x;
+	uint32_t top = data->recout.y;
+
+	int right = data->h_active - data->recout.x - data->recout.width;
+	int bottom = data->v_active - data->recout.y - data->recout.height;
+
+	if (right < 0) {
+		BREAK_TO_DEBUGGER();
+		right = 0;
+	}
+	if (bottom < 0) {
+		BREAK_TO_DEBUGGER();
+		bottom = 0;
+	}
+
+	REG_SET_2(DSCL_EXT_OVERSCAN_LEFT_RIGHT, 0,
+		EXT_OVERSCAN_LEFT, left,
+		EXT_OVERSCAN_RIGHT, right);
+
+	REG_SET_2(DSCL_EXT_OVERSCAN_TOP_BOTTOM, 0,
+		EXT_OVERSCAN_BOTTOM, bottom,
+		EXT_OVERSCAN_TOP, top);
+}
+
+static void dpp_set_otg_blank(
+		struct dcn10_dpp *xfm, const struct scaler_data *data)
+{
+	uint32_t h_blank_start = data->h_active;
+	uint32_t h_blank_end = 0;
+	uint32_t v_blank_start = data->v_active;
+	uint32_t v_blank_end = 0;
+
+	REG_SET_2(OTG_H_BLANK, 0,
+			OTG_H_BLANK_START, h_blank_start,
+			OTG_H_BLANK_END, h_blank_end);
+
+	REG_SET_2(OTG_V_BLANK, 0,
+			OTG_V_BLANK_START, v_blank_start,
+			OTG_V_BLANK_END, v_blank_end);
+}
+
+static enum dscl_mode_sel get_dscl_mode(
+		const struct scaler_data *data, bool dbg_always_scale)
+{
+	const long long one = dal_fixed31_32_one.value;
+	bool ycbcr = false;
+	bool format420 = false;
+
+	if (data->format == PIXEL_FORMAT_FP16)
+		return DSCL_MODE_DSCL_BYPASS;
+
+	if (data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+			&& data->format <= PIXEL_FORMAT_VIDEO_END)
+		ycbcr = true;
+
+	if (data->format == PIXEL_FORMAT_420BPP8 ||
+			data->format == PIXEL_FORMAT_420BPP10)
+		format420 = true;
+
+	if (data->ratios.horz.value == one
+			&& data->ratios.vert.value == one
+			&& data->ratios.horz_c.value == one
+			&& data->ratios.vert_c.value == one
+			&& !dbg_always_scale)
+		return DSCL_MODE_SCALING_444_BYPASS;
+
+	if (!format420) {
+		if (ycbcr)
+			return DSCL_MODE_SCALING_444_YCBCR_ENABLE;
+		else
+			return DSCL_MODE_SCALING_444_RGB_ENABLE;
+	}
+	if (data->ratios.horz.value == one && data->ratios.vert.value == one)
+		return DSCL_MODE_SCALING_420_LUMA_BYPASS;
+	if (data->ratios.horz_c.value == one && data->ratios.vert_c.value == one)
+		return DSCL_MODE_SCALING_420_CHROMA_BYPASS;
+
+	return DSCL_MODE_SCALING_420_YCBCR_ENABLE;
+}
+
+static int get_pixel_depth_val(enum lb_pixel_depth depth)
+{
+	if (depth == LB_PIXEL_DEPTH_30BPP)
+		return 0; /* 10 bpc */
+	else if (depth == LB_PIXEL_DEPTH_24BPP)
+		return 1; /* 8 bpc */
+	else if (depth == LB_PIXEL_DEPTH_18BPP)
+		return 2; /* 6 bpc */
+	else if (depth == LB_PIXEL_DEPTH_36BPP)
+		return 3; /* 12 bpc */
+	else {
+		ASSERT(0);
+		return -1; /* Unsupported */
+	}
+}
+
+static void dpp_set_lb(
+	struct dcn10_dpp *xfm,
+	const struct line_buffer_params *lb_params,
+	enum lb_memory_config mem_size_config)
+{
+	uint32_t pixel_depth = get_pixel_depth_val(lb_params->depth);
+	uint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;
+	REG_SET_7(LB_DATA_FORMAT, 0,
+		PIXEL_DEPTH, pixel_depth, /* Pixel depth stored in LB */
+		PIXEL_EXPAN_MODE, lb_params->pixel_expan_mode, /* Pixel expansion mode */
+		PIXEL_REDUCE_MODE, 1, /* Pixel reduction mode: Rounding */
+		DYNAMIC_PIXEL_DEPTH, dyn_pix_depth, /* Dynamic expansion pixel depth */
+		DITHER_EN, 0, /* Dithering enable: Disabled */
+		INTERLEAVE_EN, lb_params->interleave_en, /* Interleave source enable */
+		ALPHA_EN, lb_params->alpha_en); /* Alpha enable */
+
+	REG_SET_2(LB_MEMORY_CTRL, 0,
+		MEMORY_CONFIG, mem_size_config,
+		LB_MAX_PARTITIONS, 63);
+}
+
+static void dpp_set_scaler_filter(
+		struct dcn10_dpp *xfm,
+		uint32_t taps,
+		enum dcn10_coef_filter_type_sel filter_type,
+		const uint16_t *filter)
+{
+	const int tap_pairs = (taps + 1) / 2;
+	int phase;
+	int pair;
+	uint16_t odd_coef, even_coef;
+
+	REG_SET_3(SCL_COEF_RAM_TAP_SELECT, 0,
+		SCL_COEF_RAM_TAP_PAIR_IDX, 0,
+		SCL_COEF_RAM_PHASE, 0,
+		SCL_COEF_RAM_FILTER_TYPE, filter_type);
+
+	for (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {
+		for (pair = 0; pair < tap_pairs; pair++) {
+			even_coef = filter[phase * taps + 2 * pair];
+			if ((pair * 2 + 1) < taps)
+				odd_coef = filter[phase * taps + 2 * pair + 1];
+			else
+				odd_coef = 0;
+
+			REG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,
+				/* Even tap coefficient (bits 1:0 fixed to 0) */
+				SCL_COEF_RAM_EVEN_TAP_COEF, even_coef,
+				/* Write/read control for even coefficient */
+				SCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,
+				/* Odd tap coefficient (bits 1:0 fixed to 0) */
+				SCL_COEF_RAM_ODD_TAP_COEF, odd_coef,
+				/* Write/read control for odd coefficient */
+				SCL_COEF_RAM_ODD_TAP_COEF_EN, 1);
+		}
+	}
+
+}
+
+#if 0
+bool dpp_set_pixel_storage_depth(
+	struct dpp *xfm,
+	enum lb_pixel_depth depth,
+	const struct bit_depth_reduction_params *bit_depth_params)
+{
+	struct dcn10_dpp *xfm110 = TO_DCN10_DPP(xfm);
+	bool ret = true;
+	uint32_t value;
+	enum dc_color_depth color_depth;
+
+	value = dm_read_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT));
+	switch (depth) {
+	case LB_PIXEL_DEPTH_18BPP:
+		color_depth = COLOR_DEPTH_666;
+		set_reg_field_value(value, 2, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_24BPP:
+		color_depth = COLOR_DEPTH_888;
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_30BPP:
+		color_depth = COLOR_DEPTH_101010;
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_36BPP:
+		color_depth = COLOR_DEPTH_121212;
+		set_reg_field_value(value, 3, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	if (ret == true) {
+		set_denormalization(xfm110, color_depth);
+		ret = program_bit_depth_reduction(xfm110, color_depth,
+				bit_depth_params);
+
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, ALPHA_EN);
+		dm_write_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT), value);
+		if (!(xfm110->lb_pixel_depth_supported & depth)) {
+			/* We should use unsupported capabilities
+			 * unless it is required by w/a
+			 */
+			dm_logger_write(xfm->ctx->logger, LOG_WARNING,
+				"%s: Capability not supported",
+				__func__);
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)
+{
+	if (taps == 8)
+		return get_filter_8tap_64p(ratio);
+	else if (taps == 7)
+		return get_filter_7tap_64p(ratio);
+	else if (taps == 6)
+		return get_filter_6tap_64p(ratio);
+	else if (taps == 5)
+		return get_filter_5tap_64p(ratio);
+	else if (taps == 4)
+		return get_filter_4tap_64p(ratio);
+	else if (taps == 3)
+		return get_filter_3tap_64p(ratio);
+	else if (taps == 2)
+		return filter_2tap_64p;
+	else if (taps == 1)
+		return NULL;
+	else {
+		/* should never happen, bug */
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+}
+
+static void dpp_set_scl_filter(
+		struct dcn10_dpp *xfm,
+		const struct scaler_data *scl_data,
+		bool chroma_coef_mode)
+{
+	bool h_2tap_hardcode_coef_en = false;
+	bool v_2tap_hardcode_coef_en = false;
+	bool h_2tap_sharp_en = false;
+	bool v_2tap_sharp_en = false;
+	uint32_t h_2tap_sharp_factor = scl_data->sharpness.horz;
+	uint32_t v_2tap_sharp_factor = scl_data->sharpness.vert;
+	bool coef_ram_current;
+	const uint16_t *filter_h = NULL;
+	const uint16_t *filter_v = NULL;
+	const uint16_t *filter_h_c = NULL;
+	const uint16_t *filter_v_c = NULL;
+
+	h_2tap_hardcode_coef_en = scl_data->taps.h_taps < 3
+					&& scl_data->taps.h_taps_c < 3
+		&& (scl_data->taps.h_taps > 1 || scl_data->taps.h_taps_c > 1);
+	v_2tap_hardcode_coef_en = scl_data->taps.v_taps < 3
+					&& scl_data->taps.v_taps_c < 3
+		&& (scl_data->taps.v_taps > 1 || scl_data->taps.v_taps_c > 1);
+
+	h_2tap_sharp_en = h_2tap_hardcode_coef_en && h_2tap_sharp_factor != 0;
+	v_2tap_sharp_en = v_2tap_hardcode_coef_en && v_2tap_sharp_factor != 0;
+
+	REG_UPDATE_6(DSCL_2TAP_CONTROL,
+		SCL_H_2TAP_HARDCODE_COEF_EN, h_2tap_hardcode_coef_en,
+		SCL_H_2TAP_SHARP_EN, h_2tap_sharp_en,
+		SCL_H_2TAP_SHARP_FACTOR, h_2tap_sharp_factor,
+		SCL_V_2TAP_HARDCODE_COEF_EN, v_2tap_hardcode_coef_en,
+		SCL_V_2TAP_SHARP_EN, v_2tap_sharp_en,
+		SCL_V_2TAP_SHARP_FACTOR, v_2tap_sharp_factor);
+
+	if (!v_2tap_hardcode_coef_en || !h_2tap_hardcode_coef_en) {
+		bool filter_updated = false;
+
+		filter_h = get_filter_coeffs_64p(
+				scl_data->taps.h_taps, scl_data->ratios.horz);
+		filter_v = get_filter_coeffs_64p(
+				scl_data->taps.v_taps, scl_data->ratios.vert);
+
+		filter_updated = (filter_h && (filter_h != xfm->filter_h))
+				|| (filter_v && (filter_v != xfm->filter_v));
+
+		if (chroma_coef_mode) {
+			filter_h_c = get_filter_coeffs_64p(
+					scl_data->taps.h_taps_c, scl_data->ratios.horz_c);
+			filter_v_c = get_filter_coeffs_64p(
+					scl_data->taps.v_taps_c, scl_data->ratios.vert_c);
+			filter_updated = filter_updated || (filter_h_c && (filter_h_c != xfm->filter_h_c))
+							|| (filter_v_c && (filter_v_c != xfm->filter_v_c));
+		}
+
+		if (filter_updated) {
+			uint32_t scl_mode = REG_READ(SCL_MODE);
+
+			if (!h_2tap_hardcode_coef_en && filter_h) {
+				dpp_set_scaler_filter(
+					xfm, scl_data->taps.h_taps,
+					SCL_COEF_LUMA_HORZ_FILTER, filter_h);
+			}
+			xfm->filter_h = filter_h;
+			if (!v_2tap_hardcode_coef_en && filter_v) {
+				dpp_set_scaler_filter(
+					xfm, scl_data->taps.v_taps,
+					SCL_COEF_LUMA_VERT_FILTER, filter_v);
+			}
+			xfm->filter_v = filter_v;
+			if (chroma_coef_mode) {
+				if (!h_2tap_hardcode_coef_en && filter_h_c) {
+					dpp_set_scaler_filter(
+						xfm, scl_data->taps.h_taps_c,
+						SCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);
+				}
+				if (!v_2tap_hardcode_coef_en && filter_v_c) {
+					dpp_set_scaler_filter(
+						xfm, scl_data->taps.v_taps_c,
+						SCL_COEF_CHROMA_VERT_FILTER, filter_v_c);
+				}
+			}
+			xfm->filter_h_c = filter_h_c;
+			xfm->filter_v_c = filter_v_c;
+
+			coef_ram_current = get_reg_field_value_ex(
+				scl_mode, xfm->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
+				xfm->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
+
+			/* Swap coefficient RAM and set chroma coefficient mode */
+			REG_SET_2(SCL_MODE, scl_mode,
+					SCL_COEF_RAM_SELECT, !coef_ram_current,
+					SCL_CHROMA_COEF_MODE, chroma_coef_mode);
+		}
+	}
+}
+
+
+static int get_lb_depth_bpc(enum lb_pixel_depth depth)
+{
+	if (depth == LB_PIXEL_DEPTH_30BPP)
+		return 10;
+	else if (depth == LB_PIXEL_DEPTH_24BPP)
+		return 8;
+	else if (depth == LB_PIXEL_DEPTH_18BPP)
+		return 6;
+	else if (depth == LB_PIXEL_DEPTH_36BPP)
+		return 12;
+	else {
+		BREAK_TO_DEBUGGER();
+		return -1; /* Unsupported */
+	}
+}
+
+static void calc_lb_num_partitions(
+		const struct scaler_data *scl_data,
+		enum lb_memory_config lb_config,
+		int *num_part_y,
+		int *num_part_c)
+{
+	int line_size = scl_data->viewport.width < scl_data->recout.width ?
+			scl_data->viewport.width : scl_data->recout.width;
+	int line_size_c = scl_data->viewport_c.width < scl_data->recout.width ?
+			scl_data->viewport_c.width : scl_data->recout.width;
+	int lb_bpc = get_lb_depth_bpc(scl_data->lb_params.depth);
+	int memory_line_size_y = (line_size * lb_bpc + 71) / 72; /* +71 to ceil */
+	int memory_line_size_c = (line_size_c * lb_bpc + 71) / 72; /* +71 to ceil */
+	int memory_line_size_a = (line_size + 5) / 6; /* +5 to ceil */
+	int lb_memory_size, lb_memory_size_c, lb_memory_size_a, num_partitions_a;
+
+	if (lb_config == LB_MEMORY_CONFIG_1) {
+		lb_memory_size = 816;
+		lb_memory_size_c = 816;
+		lb_memory_size_a = 984;
+	} else if (lb_config == LB_MEMORY_CONFIG_2) {
+		lb_memory_size = 1088;
+		lb_memory_size_c = 1088;
+		lb_memory_size_a = 1312;
+	} else if (lb_config == LB_MEMORY_CONFIG_3) {
+		lb_memory_size = 816 + 1088 + 848 + 848 + 848;
+		lb_memory_size_c = 816 + 1088;
+		lb_memory_size_a = 984 + 1312 + 456;
+	} else {
+		lb_memory_size = 816 + 1088 + 848;
+		lb_memory_size_c = 816 + 1088 + 848;
+		lb_memory_size_a = 984 + 1312 + 456;
+	}
+	*num_part_y = lb_memory_size / memory_line_size_y;
+	*num_part_c = lb_memory_size_c / memory_line_size_c;
+	num_partitions_a = lb_memory_size_a / memory_line_size_a;
+
+	if (scl_data->lb_params.alpha_en
+			&& (num_partitions_a < *num_part_y))
+		*num_part_y = num_partitions_a;
+
+	if (*num_part_y > 64)
+		*num_part_y = 64;
+	if (*num_part_c > 64)
+		*num_part_c = 64;
+
+}
+
+static bool is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)
+{
+	if (ceil_vratio > 2)
+		return vtaps <= (num_partitions - ceil_vratio + 2);
+	else
+		return vtaps <= num_partitions;
+}
+
+/*find first match configuration which meets the min required lb size*/
+static enum lb_memory_config find_lb_memory_config(const struct scaler_data *scl_data)
+{
+	int num_part_y, num_part_c;
+	int vtaps = scl_data->taps.v_taps;
+	int vtaps_c = scl_data->taps.v_taps_c;
+	int ceil_vratio = dal_fixed31_32_ceil(scl_data->ratios.vert);
+	int ceil_vratio_c = dal_fixed31_32_ceil(scl_data->ratios.vert_c);
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_1, &num_part_y, &num_part_c);
+
+	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+		return LB_MEMORY_CONFIG_1;
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_2, &num_part_y, &num_part_c);
+
+	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+		return LB_MEMORY_CONFIG_2;
+
+	if (scl_data->format == PIXEL_FORMAT_420BPP8
+			|| scl_data->format == PIXEL_FORMAT_420BPP10) {
+		calc_lb_num_partitions(
+				scl_data, LB_MEMORY_CONFIG_3, &num_part_y, &num_part_c);
+
+		if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+				&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+			return LB_MEMORY_CONFIG_3;
+	}
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_0, &num_part_y, &num_part_c);
+
+	/*Ensure we can support the requested number of vtaps*/
+	ASSERT(is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c));
+
+	return LB_MEMORY_CONFIG_0;
+}
+
+void dpp_set_scaler_auto_scale(
+	struct transform *xfm_base,
+	const struct scaler_data *scl_data)
+{
+	enum lb_memory_config lb_config;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	enum dscl_mode_sel dscl_mode = get_dscl_mode(
+			scl_data, xfm_base->ctx->dc->debug.always_scale);
+	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
+
+	dpp_set_overscan(xfm, scl_data);
+
+	dpp_set_otg_blank(xfm, scl_data);
+
+	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
+
+	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
+		return;
+
+	lb_config =  find_lb_memory_config(scl_data);
+	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
+
+	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
+		return;
+
+	/* TODO: v_min */
+	REG_SET_3(DSCL_AUTOCAL, 0,
+		AUTOCAL_MODE, AUTOCAL_MODE_AUTOSCALE,
+		AUTOCAL_NUM_PIPE, 0,
+		AUTOCAL_PIPE_ID, 0);
+
+	/* Black offsets */
+	if (ycbcr)
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
+	else
+
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
+
+	REG_SET_4(SCL_TAP_CONTROL, 0,
+		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
+		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
+		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
+		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
+
+	dpp_set_scl_filter(xfm, scl_data, ycbcr);
+}
+
 /* Program gamut remap in bypass mode */
 void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 {
@@ -106,10 +628,150 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 	/* Gamut remap in bypass */
 }
 
+static void dpp_set_recout(
+			struct dcn10_dpp *xfm, const struct rect *recout)
+{
+	REG_SET_2(RECOUT_START, 0,
+		/* First pixel of RECOUT */
+			 RECOUT_START_X, recout->x,
+		/* First line of RECOUT */
+			 RECOUT_START_Y, recout->y);
+
+	REG_SET_2(RECOUT_SIZE, 0,
+		/* Number of RECOUT horizontal pixels */
+			 RECOUT_WIDTH, recout->width,
+		/* Number of RECOUT vertical lines */
+			 RECOUT_HEIGHT, recout->height
+			 - xfm->base.ctx->dc->debug.surface_visual_confirm * 4 *
+			 (xfm->base.inst + 1));
+}
+
+static void dpp_set_manual_ratio_init(
+		struct dcn10_dpp *xfm, const struct scaler_data *data)
+{
+	uint32_t init_frac = 0;
+	uint32_t init_int = 0;
+
+	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,
+			SCL_H_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.horz) << 5);
+
+	REG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,
+			SCL_V_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.vert) << 5);
+
+	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO_C, 0,
+			SCL_H_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.horz_c) << 5);
+
+	REG_SET(SCL_VERT_FILTER_SCALE_RATIO_C, 0,
+			SCL_V_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.vert_c) << 5);
+
+	/*
+	 * 0.24 format for fraction, first five bits zeroed
+	 */
+	init_frac = dal_fixed31_32_u0d19(data->inits.h) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.h);
+	REG_SET_2(SCL_HORZ_FILTER_INIT, 0,
+		SCL_H_INIT_FRAC, init_frac,
+		SCL_H_INIT_INT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.h_c) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.h_c);
+	REG_SET_2(SCL_HORZ_FILTER_INIT_C, 0,
+		SCL_H_INIT_FRAC_C, init_frac,
+		SCL_H_INIT_INT_C, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v);
+	REG_SET_2(SCL_VERT_FILTER_INIT, 0,
+		SCL_V_INIT_FRAC, init_frac,
+		SCL_V_INIT_INT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_bot) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_bot);
+	REG_SET_2(SCL_VERT_FILTER_INIT_BOT, 0,
+		SCL_V_INIT_FRAC_BOT, init_frac,
+		SCL_V_INIT_INT_BOT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_c) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_c);
+	REG_SET_2(SCL_VERT_FILTER_INIT_C, 0,
+		SCL_V_INIT_FRAC_C, init_frac,
+		SCL_V_INIT_INT_C, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_c_bot) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_c_bot);
+	REG_SET_2(SCL_VERT_FILTER_INIT_BOT_C, 0,
+		SCL_V_INIT_FRAC_BOT_C, init_frac,
+		SCL_V_INIT_INT_BOT_C, init_int);
+}
+
+/* Main function to program scaler and line buffer in manual scaling mode */
+static void dpp_set_scaler_manual_scale(
+	struct transform *xfm_base,
+	const struct scaler_data *scl_data)
+{
+	enum lb_memory_config lb_config;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	enum dscl_mode_sel dscl_mode = get_dscl_mode(
+			scl_data, xfm_base->ctx->dc->debug.always_scale);
+	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
+
+	/* Recout */
+	dpp_set_recout(xfm, &scl_data->recout);
+
+	/* MPC Size */
+	REG_SET_2(MPC_SIZE, 0,
+		/* Number of horizontal pixels of MPC */
+			 MPC_WIDTH, scl_data->h_active,
+		/* Number of vertical lines of MPC */
+			 MPC_HEIGHT, scl_data->v_active);
+
+	/* SCL mode */
+	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
+
+	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
+		return;
+	/* LB */
+	lb_config =  find_lb_memory_config(scl_data);
+	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
+
+	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
+		return;
+
+	/* Autocal off */
+	REG_SET_3(DSCL_AUTOCAL, 0,
+		AUTOCAL_MODE, AUTOCAL_MODE_OFF,
+		AUTOCAL_NUM_PIPE, 0,
+		AUTOCAL_PIPE_ID, 0);
+
+	/* Black offsets */
+	if (ycbcr)
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
+	else
+
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
+
+	/* Manually calculate scale ratio and init values */
+	dpp_set_manual_ratio_init(xfm, scl_data);
+
+	/* HTaps/VTaps */
+	REG_SET_4(SCL_TAP_CONTROL, 0,
+		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
+		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
+		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
+		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
+
+	dpp_set_scl_filter(xfm, scl_data, ycbcr);
+}
+
 #define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
 
 
-bool dpp_get_optimal_number_of_taps(
+static bool dpp_get_optimal_number_of_taps(
 		struct transform *xfm,
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)
@@ -168,7 +830,7 @@ bool dpp_get_optimal_number_of_taps(
 	return true;
 }
 
-void dpp_reset(struct transform *xfm_base)
+static void dpp_reset(struct transform *xfm_base)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
 
@@ -181,28 +843,690 @@ void dpp_reset(struct transform *xfm_base)
 	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
 }
 
+static void program_gamut_remap(
+		struct dcn10_dpp *xfm,
+		const uint16_t *regval,
+		enum gamut_remap_select select)
+{
+	 uint16_t selection = 0;
 
+	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
+		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
+				CM_GAMUT_REMAP_MODE, 0);
+		return;
+	}
+	switch (select) {
+	case GAMUT_REMAP_COEFF:
+		selection = 1;
+		break;
+	case GAMUT_REMAP_COMA_COEFF:
+		selection = 2;
+		break;
+	case GAMUT_REMAP_COMB_COEFF:
+		selection = 3;
+		break;
+	default:
+		break;
+	}
 
-static bool dcn10_dpp_cm_set_regamma_pwl(
+
+	if (select == GAMUT_REMAP_COEFF) {
+
+		REG_SET_2(CM_GAMUT_REMAP_C11_C12, 0,
+				CM_GAMUT_REMAP_C11, regval[0],
+				CM_GAMUT_REMAP_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C13_C14, 0,
+				CM_GAMUT_REMAP_C13, regval[0],
+				CM_GAMUT_REMAP_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C21_C22, 0,
+				CM_GAMUT_REMAP_C21, regval[0],
+				CM_GAMUT_REMAP_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C23_C24, 0,
+				CM_GAMUT_REMAP_C23, regval[0],
+				CM_GAMUT_REMAP_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C31_C32, 0,
+				CM_GAMUT_REMAP_C31, regval[0],
+				CM_GAMUT_REMAP_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C33_C34, 0,
+				CM_GAMUT_REMAP_C33, regval[0],
+				CM_GAMUT_REMAP_C34, regval[1]);
+
+	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
+		REG_SET_2(CM_COMA_C11_C12, 0,
+				CM_COMA_C11, regval[0],
+				CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+				CM_COMA_C13, regval[0],
+				CM_COMA_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+				CM_COMA_C21, regval[0],
+				CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+				CM_COMA_C23, regval[0],
+				CM_COMA_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+				CM_COMA_C31, regval[0],
+				CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+				CM_COMA_C33, regval[0],
+				CM_COMA_C34, regval[1]);
+
+	} else {
+		REG_SET_2(CM_COMB_C11_C12, 0,
+				CM_COMB_C11, regval[0],
+				CM_COMB_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C13_C14, 0,
+				CM_COMB_C13, regval[0],
+				CM_COMB_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C21_C22, 0,
+				CM_COMB_C21, regval[0],
+				CM_COMB_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C23_C24, 0,
+				CM_COMB_C23, regval[0],
+				CM_COMB_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C31_C32, 0,
+				CM_COMB_C31, regval[0],
+				CM_COMB_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C33_C34, 0,
+				CM_COMB_C33, regval[0],
+				CM_COMB_C34, regval[1]);
+	}
+
+	REG_SET(
+			CM_GAMUT_REMAP_CONTROL, 0,
+			CM_GAMUT_REMAP_MODE, selection);
+
+}
+
+static void dcn_dpp_set_gamut_remap(
+	struct transform *xfm,
+	const struct xfm_grph_csc_adjustment *adjust)
+{
+	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
+
+	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
+		/* Bypass if type is bypass or hw */
+		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
+	else {
+		struct fixed31_32 arr_matrix[12];
+		uint16_t arr_reg_val[12];
+
+		arr_matrix[0] = adjust->temperature_matrix[0];
+		arr_matrix[1] = adjust->temperature_matrix[1];
+		arr_matrix[2] = adjust->temperature_matrix[2];
+		arr_matrix[3] = dal_fixed31_32_zero;
+
+		arr_matrix[4] = adjust->temperature_matrix[3];
+		arr_matrix[5] = adjust->temperature_matrix[4];
+		arr_matrix[6] = adjust->temperature_matrix[5];
+		arr_matrix[7] = dal_fixed31_32_zero;
+
+		arr_matrix[8] = adjust->temperature_matrix[6];
+		arr_matrix[9] = adjust->temperature_matrix[7];
+		arr_matrix[10] = adjust->temperature_matrix[8];
+		arr_matrix[11] = dal_fixed31_32_zero;
+
+		convert_float_matrix(
+			arr_reg_val, arr_matrix, 12);
+
+		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
+	}
+}
+
+static void oppn10_set_output_csc_default(
+		struct transform *xfm_base,
+		const struct default_adjustment *default_adjust)
+{
+
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	uint32_t ocsc_mode = 0;
+
+	if (default_adjust != NULL) {
+		switch (default_adjust->out_color_space) {
+		case COLOR_SPACE_SRGB:
+		case COLOR_SPACE_2020_RGB_FULLRANGE:
+			ocsc_mode = 0;
+			break;
+		case COLOR_SPACE_SRGB_LIMITED:
+		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+			ocsc_mode = 1;
+			break;
+		case COLOR_SPACE_YCBCR601:
+		case COLOR_SPACE_YCBCR601_LIMITED:
+			ocsc_mode = 2;
+			break;
+		case COLOR_SPACE_YCBCR709:
+		case COLOR_SPACE_YCBCR709_LIMITED:
+		case COLOR_SPACE_2020_YCBCR:
+			ocsc_mode = 3;
+			break;
+		case COLOR_SPACE_UNKNOWN:
+		default:
+			break;
+		}
+	}
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+
+}
+
+static void oppn10_program_color_matrix(
+		struct dcn10_dpp *xfm,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	uint32_t mode;
+
+	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
+
+	if (tbl_entry == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (mode == 4) {
+		/*R*/
+		REG_SET_2(CM_OCSC_C11_C12, 0,
+			CM_OCSC_C11, tbl_entry->regval[0],
+			CM_OCSC_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_OCSC_C13_C14, 0,
+			CM_OCSC_C13, tbl_entry->regval[2],
+			CM_OCSC_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_OCSC_C21_C22, 0,
+			CM_OCSC_C21, tbl_entry->regval[4],
+			CM_OCSC_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_OCSC_C23_C24, 0,
+			CM_OCSC_C23, tbl_entry->regval[6],
+			CM_OCSC_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_OCSC_C31_C32, 0,
+			CM_OCSC_C31, tbl_entry->regval[8],
+			CM_OCSC_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_OCSC_C33_C34, 0,
+			CM_OCSC_C33, tbl_entry->regval[10],
+			CM_OCSC_C34, tbl_entry->regval[11]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMB_C11_C12, 0,
+			CM_COMB_C11, tbl_entry->regval[0],
+			CM_COMB_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_COMB_C13_C14, 0,
+			CM_COMB_C13, tbl_entry->regval[2],
+			CM_COMB_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_COMB_C21_C22, 0,
+			CM_COMB_C21, tbl_entry->regval[4],
+			CM_COMB_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_COMB_C23_C24, 0,
+			CM_COMB_C23, tbl_entry->regval[6],
+			CM_COMB_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_COMB_C31_C32, 0,
+			CM_COMB_C31, tbl_entry->regval[8],
+			CM_COMB_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_COMB_C33_C34, 0,
+			CM_COMB_C33, tbl_entry->regval[10],
+			CM_COMB_C34, tbl_entry->regval[11]);
+	}
+}
+
+static void oppn10_set_output_csc_adjustment(
+		struct transform *xfm_base,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
+	uint32_t ocsc_mode = 4;
+
+	/**
+	*if (tbl_entry != NULL) {
+	*	switch (tbl_entry->color_space) {
+	*	case COLOR_SPACE_SRGB:
+	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
+	*		ocsc_mode = 0;
+	*		break;
+	*	case COLOR_SPACE_SRGB_LIMITED:
+	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+	*		ocsc_mode = 1;
+	*		break;
+	*	case COLOR_SPACE_YCBCR601:
+	*	case COLOR_SPACE_YCBCR601_LIMITED:
+	*		ocsc_mode = 2;
+	*		break;
+	*	case COLOR_SPACE_YCBCR709:
+	*	case COLOR_SPACE_YCBCR709_LIMITED:
+	*	case COLOR_SPACE_2020_YCBCR:
+	*		ocsc_mode = 3;
+	*		break;
+	*	case COLOR_SPACE_UNKNOWN:
+	*	default:
+	*		break;
+	*	}
+	*}
+	*/
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+	oppn10_program_color_matrix(xfm, tbl_entry);
+}
+
+static void oppn10_power_on_regamma_lut(
+	struct transform *xfm_base,
+	bool power_on)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
+
+}
+
+static void opp_program_regamma_lut(
+		struct transform *xfm_base,
+		const struct pwl_result_data *rgb,
+		uint32_t num)
+{
+	uint32_t i;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
+
+	}
+
+}
+
+static void opp_configure_regamma_lut(
+		struct transform *xfm_base,
+		bool is_ram_a)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
+	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
+}
+
+/*program re gamma RAM A*/
+static void opp_program_regamma_luta_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
+		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
+		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
+		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
+		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
+		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
+		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
+		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
+		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
+		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
+		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
+		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
+		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
+		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
+		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
+		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
+		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
+		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+/*program re gamma RAM B*/
+static void opp_program_regamma_lutb_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
+		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
+		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
+		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
+		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
+		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
+		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
+		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
+		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
+		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
+		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
+		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
+		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
+		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
+		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
+		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
+		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
+		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+
+}
+
+static bool oppn10_set_regamma_pwl(
 	struct transform *xfm_base, const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
 
-	dcn10_dpp_cm_power_on_regamma_lut(xfm_base, true);
-	dcn10_dpp_cm_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
+	oppn10_power_on_regamma_lut(xfm_base, true);
+	opp_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
 
 	if (xfm->is_write_to_ram_a_safe)
-		dcn10_dpp_cm_program_regamma_luta_settings(xfm_base, params);
+		opp_program_regamma_luta_settings(xfm_base, params);
 	else
-		dcn10_dpp_cm_program_regamma_lutb_settings(xfm_base, params);
+		opp_program_regamma_lutb_settings(xfm_base, params);
 
-	dcn10_dpp_cm_program_regamma_lut(
+	opp_program_regamma_lut(
 			xfm_base, params->rgb_resulted, params->hw_points_num);
 
 	return true;
 }
 
-static void dcn10_dpp_cm_set_regamma_mode(
+static void oppn10_set_regamma_mode(
 	struct transform *xfm_base,
 	enum opp_regamma mode)
 {
@@ -235,167 +1559,22 @@ static void dcn10_dpp_cm_set_regamma_mode(
 			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
 }
 
-static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
-						enum pixel_format_description *fmt)
-{
-
-	if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F ||
-		input_format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F)
-		*fmt = PIXEL_FORMAT_FLOAT;
-	else if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)
-		*fmt = PIXEL_FORMAT_FIXED16;
-	else
-		*fmt = PIXEL_FORMAT_FIXED;
-}
-
-static void ippn10_set_degamma_format_float(
-		struct transform *xfm_base,
-		bool is_float)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	if (is_float) {
-		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);
-		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 1);
-	} else {
-		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 2);
-		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 0);
-	}
-}
-
-void ippn10_cnv_setup (
-		struct transform *xfm_base,
-		enum surface_pixel_format input_format,
-		enum expansion_mode mode,
-		enum ipp_output_format cnv_out_format)
-{
-	uint32_t pixel_format;
-	uint32_t alpha_en;
-	enum pixel_format_description fmt ;
-	enum dc_color_space color_space;
-	enum dcn10_input_csc_select select;
-	bool is_float;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	bool force_disable_cursor = false;
-
-	ippn10_setup_format_flags(input_format, &fmt);
-	alpha_en = 1;
-	pixel_format = 0;
-	color_space = COLOR_SPACE_SRGB;
-	select = INPUT_CSC_SELECT_BYPASS;
-	is_float = false;
-
-	switch (fmt) {
-	case PIXEL_FORMAT_FIXED:
-	case PIXEL_FORMAT_FIXED16:
-	/*when output is float then FORMAT_CONTROL__OUTPUT_FP=1*/
-		REG_SET_3(FORMAT_CONTROL, 0,
-			CNVC_BYPASS, 0,
-			FORMAT_EXPANSION_MODE, mode,
-			OUTPUT_FP, 0);
-		break;
-	case PIXEL_FORMAT_FLOAT:
-		REG_SET_3(FORMAT_CONTROL, 0,
-			CNVC_BYPASS, 0,
-			FORMAT_EXPANSION_MODE, mode,
-			OUTPUT_FP, 1);
-		is_float = true;
-		break;
-	default:
-
-		break;
-	}
-
-	ippn10_set_degamma_format_float(xfm_base, is_float);
-
-	switch (input_format) {
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
-		pixel_format = 1;
-		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
-		pixel_format = 3;
-		alpha_en = 0;
-		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
-		pixel_format = 8;
-		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
-		pixel_format = 10;
-		break;
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
-		force_disable_cursor = false;
-		pixel_format = 65;
-		color_space = COLOR_SPACE_YCBCR709;
-		select = INPUT_CSC_SELECT_ICSC;
-		break;
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
-		force_disable_cursor = true;
-		pixel_format = 64;
-		color_space = COLOR_SPACE_YCBCR709;
-		select = INPUT_CSC_SELECT_ICSC;
-		break;
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
-		force_disable_cursor = true;
-		pixel_format = 67;
-		color_space = COLOR_SPACE_YCBCR709;
-		select = INPUT_CSC_SELECT_ICSC;
-		break;
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
-		force_disable_cursor = true;
-		pixel_format = 66;
-		color_space = COLOR_SPACE_YCBCR709;
-		select = INPUT_CSC_SELECT_ICSC;
-		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
-		pixel_format = 22;
-		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
-		pixel_format = 24;
-		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
-		pixel_format = 25;
-		break;
-	default:
-		break;
-	}
-	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
-			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
-	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
-
-	ippn10_program_input_csc(xfm_base, color_space, select);
-
-	if (force_disable_cursor) {
-		REG_UPDATE(CURSOR_CONTROL,
-				CURSOR_ENABLE, 0);
-		REG_UPDATE(CURSOR0_CONTROL,
-				CUR0_ENABLE, 0);
-	}
-}
-
 static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
-		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
+		.transform_set_scaler = dpp_set_scaler_manual_scale,
 		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
-		.transform_set_gamut_remap = dcn10_dpp_cm_set_gamut_remap,
-		.opp_set_csc_adjustment = dcn10_dpp_cm_set_output_csc_adjustment,
-		.opp_set_csc_default = dcn10_dpp_cm_set_output_csc_default,
-		.opp_power_on_regamma_lut = dcn10_dpp_cm_power_on_regamma_lut,
-		.opp_program_regamma_lut = dcn10_dpp_cm_program_regamma_lut,
-		.opp_configure_regamma_lut = dcn10_dpp_cm_configure_regamma_lut,
-		.opp_program_regamma_lutb_settings = dcn10_dpp_cm_program_regamma_lutb_settings,
-		.opp_program_regamma_luta_settings = dcn10_dpp_cm_program_regamma_luta_settings,
-		.opp_program_regamma_pwl = dcn10_dpp_cm_set_regamma_pwl,
-		.opp_set_regamma_mode = dcn10_dpp_cm_set_regamma_mode,
-		.ipp_set_degamma = ippn10_set_degamma,
-		.ipp_program_input_lut		= ippn10_program_input_lut,
-		.ipp_program_degamma_pwl	= ippn10_set_degamma_pwl,
-		.ipp_setup			= ippn10_cnv_setup,
-		.ipp_full_bypass		= ippn10_full_bypass,
+		.transform_set_gamut_remap = dcn_dpp_set_gamut_remap,
+		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,
+		.opp_set_csc_default = oppn10_set_output_csc_default,
+		.opp_power_on_regamma_lut = oppn10_power_on_regamma_lut,
+		.opp_program_regamma_lut = opp_program_regamma_lut,
+		.opp_configure_regamma_lut = opp_configure_regamma_lut,
+		.opp_program_regamma_lutb_settings = opp_program_regamma_lutb_settings,
+		.opp_program_regamma_luta_settings = opp_program_regamma_luta_settings,
+		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
+		.opp_set_regamma_mode = oppn10_set_regamma_mode,
 };
 
-
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
index 4bbd3b4..1c9d332 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
@@ -37,13 +37,13 @@
 #define TF_SF(reg_name, field_name, post_fix)\
 	.field_name = reg_name ## __ ## field_name ## post_fix
 
-//Used to resolve corner case
-#define TF2_SF(reg_name, field_name, post_fix)\
-	.field_name = reg_name ## _ ## field_name ## post_fix
-
 #define TF_REG_LIST_DCN(id) \
 	SRI(CM_GAMUT_REMAP_CONTROL, CM, id),\
 	SRI(CM_GAMUT_REMAP_C11_C12, CM, id),\
+	SRI(CM_GAMUT_REMAP_C13_C14, CM, id),\
+	SRI(CM_GAMUT_REMAP_C21_C22, CM, id),\
+	SRI(CM_GAMUT_REMAP_C23_C24, CM, id),\
+	SRI(CM_GAMUT_REMAP_C31_C32, CM, id),\
 	SRI(CM_GAMUT_REMAP_C33_C34, CM, id),\
 	SRI(DSCL_EXT_OVERSCAN_LEFT_RIGHT, DSCL, id), \
 	SRI(DSCL_EXT_OVERSCAN_TOP_BOTTOM, DSCL, id), \
@@ -72,58 +72,28 @@
 	SRI(SCL_VERT_FILTER_INIT_BOT_C, DSCL, id), \
 	SRI(RECOUT_START, DSCL, id), \
 	SRI(RECOUT_SIZE, DSCL, id), \
-	SRI(OBUF_CONTROL, DSCL, id), \
-	SRI(CM_ICSC_CONTROL, CM, id), \
-	SRI(CM_ICSC_C11_C12, CM, id), \
-	SRI(CM_ICSC_C33_C34, CM, id), \
-	SRI(CM_DGAM_RAMB_START_CNTL_B, CM, id), \
-	SRI(CM_DGAM_RAMB_START_CNTL_G, CM, id), \
-	SRI(CM_DGAM_RAMB_START_CNTL_R, CM, id), \
-	SRI(CM_DGAM_RAMB_SLOPE_CNTL_B, CM, id), \
-	SRI(CM_DGAM_RAMB_SLOPE_CNTL_G, CM, id), \
-	SRI(CM_DGAM_RAMB_SLOPE_CNTL_R, CM, id), \
-	SRI(CM_DGAM_RAMB_END_CNTL1_B, CM, id), \
-	SRI(CM_DGAM_RAMB_END_CNTL2_B, CM, id), \
-	SRI(CM_DGAM_RAMB_END_CNTL1_G, CM, id), \
-	SRI(CM_DGAM_RAMB_END_CNTL2_G, CM, id), \
-	SRI(CM_DGAM_RAMB_END_CNTL1_R, CM, id), \
-	SRI(CM_DGAM_RAMB_END_CNTL2_R, CM, id), \
-	SRI(CM_DGAM_RAMB_REGION_0_1, CM, id), \
-	SRI(CM_DGAM_RAMB_REGION_14_15, CM, id), \
-	SRI(CM_DGAM_RAMA_START_CNTL_B, CM, id), \
-	SRI(CM_DGAM_RAMA_START_CNTL_G, CM, id), \
-	SRI(CM_DGAM_RAMA_START_CNTL_R, CM, id), \
-	SRI(CM_DGAM_RAMA_SLOPE_CNTL_B, CM, id), \
-	SRI(CM_DGAM_RAMA_SLOPE_CNTL_G, CM, id), \
-	SRI(CM_DGAM_RAMA_SLOPE_CNTL_R, CM, id), \
-	SRI(CM_DGAM_RAMA_END_CNTL1_B, CM, id), \
-	SRI(CM_DGAM_RAMA_END_CNTL2_B, CM, id), \
-	SRI(CM_DGAM_RAMA_END_CNTL1_G, CM, id), \
-	SRI(CM_DGAM_RAMA_END_CNTL2_G, CM, id), \
-	SRI(CM_DGAM_RAMA_END_CNTL1_R, CM, id), \
-	SRI(CM_DGAM_RAMA_END_CNTL2_R, CM, id), \
-	SRI(CM_DGAM_RAMA_REGION_0_1, CM, id), \
-	SRI(CM_DGAM_RAMA_REGION_14_15, CM, id), \
-	SRI(CM_MEM_PWR_CTRL, CM, id), \
-	SRI(CM_DGAM_LUT_WRITE_EN_MASK, CM, id), \
-	SRI(CM_DGAM_LUT_INDEX, CM, id), \
-	SRI(CM_DGAM_LUT_DATA, CM, id), \
-	SRI(CM_CONTROL, CM, id), \
-	SRI(CM_DGAM_CONTROL, CM, id), \
-	SRI(FORMAT_CONTROL, CNVC_CFG, id), \
-	SRI(CNVC_SURFACE_PIXEL_FORMAT, CNVC_CFG, id), \
-	SRI(CURSOR0_CONTROL, CNVC_CUR, id)
-
-
+	SRI(OBUF_CONTROL, DSCL, id)
 
 #define TF_REG_LIST_DCN10(id) \
 	TF_REG_LIST_DCN(id), \
 	SRI(CM_COMA_C11_C12, CM, id),\
+	SRI(CM_COMA_C13_C14, CM, id),\
+	SRI(CM_COMA_C21_C22, CM, id),\
+	SRI(CM_COMA_C23_C24, CM, id),\
+	SRI(CM_COMA_C31_C32, CM, id),\
 	SRI(CM_COMA_C33_C34, CM, id),\
 	SRI(CM_COMB_C11_C12, CM, id),\
+	SRI(CM_COMB_C13_C14, CM, id),\
+	SRI(CM_COMB_C21_C22, CM, id),\
+	SRI(CM_COMB_C23_C24, CM, id),\
+	SRI(CM_COMB_C31_C32, CM, id),\
 	SRI(CM_COMB_C33_C34, CM, id),\
 	SRI(CM_OCSC_CONTROL, CM, id), \
 	SRI(CM_OCSC_C11_C12, CM, id), \
+	SRI(CM_OCSC_C13_C14, CM, id), \
+	SRI(CM_OCSC_C21_C22, CM, id), \
+	SRI(CM_OCSC_C23_C24, CM, id), \
+	SRI(CM_OCSC_C31_C32, CM, id), \
 	SRI(CM_OCSC_C33_C34, CM, id), \
 	SRI(CM_MEM_PWR_CTRL, CM, id), \
 	SRI(CM_RGAM_LUT_DATA, CM, id), \
@@ -142,6 +112,21 @@
 	SRI(CM_RGAM_RAMB_END_CNTL1_R, CM, id), \
 	SRI(CM_RGAM_RAMB_END_CNTL2_R, CM, id), \
 	SRI(CM_RGAM_RAMB_REGION_0_1, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_2_3, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_4_5, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_6_7, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_8_9, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_10_11, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_12_13, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_14_15, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_16_17, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_18_19, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_20_21, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_22_23, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_24_25, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_26_27, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_28_29, CM, id), \
+	SRI(CM_RGAM_RAMB_REGION_30_31, CM, id), \
 	SRI(CM_RGAM_RAMB_REGION_32_33, CM, id), \
 	SRI(CM_RGAM_RAMA_START_CNTL_B, CM, id), \
 	SRI(CM_RGAM_RAMA_START_CNTL_G, CM, id), \
@@ -156,19 +141,37 @@
 	SRI(CM_RGAM_RAMA_END_CNTL1_R, CM, id), \
 	SRI(CM_RGAM_RAMA_END_CNTL2_R, CM, id), \
 	SRI(CM_RGAM_RAMA_REGION_0_1, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_2_3, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_4_5, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_6_7, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_8_9, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_10_11, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_12_13, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_14_15, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_16_17, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_18_19, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_20_21, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_22_23, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_24_25, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_26_27, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_28_29, CM, id), \
+	SRI(CM_RGAM_RAMA_REGION_30_31, CM, id), \
 	SRI(CM_RGAM_RAMA_REGION_32_33, CM, id), \
-	SRI(CM_RGAM_CONTROL, CM, id), \
-	SRI(CM_IGAM_CONTROL, CM, id), \
-	SRI(CM_IGAM_LUT_RW_CONTROL, CM, id), \
-	SRI(CM_IGAM_LUT_RW_INDEX, CM, id), \
-	SRI(CM_IGAM_LUT_SEQ_COLOR, CM, id), \
-	SRI(CURSOR_CONTROL, CURSOR, id)
+	SRI(CM_RGAM_CONTROL, CM, id)
 
 
 #define TF_REG_LIST_SH_MASK_DCN(mask_sh)\
 	TF_SF(CM0_CM_GAMUT_REMAP_CONTROL, CM_GAMUT_REMAP_MODE, mask_sh),\
 	TF_SF(CM0_CM_GAMUT_REMAP_C11_C12, CM_GAMUT_REMAP_C11, mask_sh),\
 	TF_SF(CM0_CM_GAMUT_REMAP_C11_C12, CM_GAMUT_REMAP_C12, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C13_C14, CM_GAMUT_REMAP_C13, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C13_C14, CM_GAMUT_REMAP_C14, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C21_C22, CM_GAMUT_REMAP_C21, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C21_C22, CM_GAMUT_REMAP_C22, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C23_C24, CM_GAMUT_REMAP_C23, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C23_C24, CM_GAMUT_REMAP_C24, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C31_C32, CM_GAMUT_REMAP_C31, mask_sh),\
+	TF_SF(CM0_CM_GAMUT_REMAP_C31_C32, CM_GAMUT_REMAP_C32, mask_sh),\
 	TF_SF(CM0_CM_GAMUT_REMAP_C33_C34, CM_GAMUT_REMAP_C33, mask_sh),\
 	TF_SF(CM0_CM_GAMUT_REMAP_C33_C34, CM_GAMUT_REMAP_C34, mask_sh),\
 	TF_SF(DSCL0_DSCL_EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT, mask_sh),\
@@ -180,7 +183,7 @@
 	TF_SF(DSCL0_OTG_V_BLANK, OTG_V_BLANK_START, mask_sh),\
 	TF_SF(DSCL0_OTG_V_BLANK, OTG_V_BLANK_END, mask_sh),\
 	TF_SF(DSCL0_LB_DATA_FORMAT, INTERLEAVE_EN, mask_sh),\
-	TF2_SF(DSCL0, LB_DATA_FORMAT__ALPHA_EN, mask_sh),\
+	TF_SF(DSCL0_LB_DATA_FORMAT, ALPHA_EN, mask_sh),\
 	TF_SF(DSCL0_LB_MEMORY_CTRL, MEMORY_CONFIG, mask_sh),\
 	TF_SF(DSCL0_LB_MEMORY_CTRL, LB_MAX_PARTITIONS, mask_sh),\
 	TF_SF(DSCL0_DSCL_AUTOCAL, AUTOCAL_MODE, mask_sh),\
@@ -232,77 +235,7 @@
 	TF_SF(DSCL0_SCL_VERT_FILTER_INIT_BOT_C, SCL_V_INIT_INT_BOT_C, mask_sh),\
 	TF_SF(DSCL0_SCL_MODE, SCL_CHROMA_COEF_MODE, mask_sh),\
 	TF_SF(DSCL0_SCL_MODE, SCL_COEF_RAM_SELECT_CURRENT, mask_sh), \
-	TF_SF(DSCL0_OBUF_CONTROL, OBUF_BYPASS, mask_sh), \
-	TF_SF(CM0_CM_ICSC_CONTROL, CM_ICSC_MODE, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C11, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C12, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C33, mask_sh), \
-	TF_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C34, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_R, CM_DGAM_RAMB_EXP_REGION_START_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_START_CNTL_R, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_B, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_G, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_R, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL1_B, CM_DGAM_RAMB_EXP_REGION_END_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL2_B, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL2_B, CM_DGAM_RAMB_EXP_REGION_END_BASE_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL1_G, CM_DGAM_RAMB_EXP_REGION_END_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL2_G, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL2_G, CM_DGAM_RAMB_EXP_REGION_END_BASE_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL1_R, CM_DGAM_RAMB_EXP_REGION_END_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL2_R, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_END_CNTL2_R, CM_DGAM_RAMB_EXP_REGION_END_BASE_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_START_CNTL_B, CM_DGAM_RAMA_EXP_REGION_START_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_START_CNTL_B, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_START_CNTL_G, CM_DGAM_RAMA_EXP_REGION_START_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_START_CNTL_G, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_START_CNTL_R, CM_DGAM_RAMA_EXP_REGION_START_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_START_CNTL_R, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_B, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_G, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_R, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL1_B, CM_DGAM_RAMA_EXP_REGION_END_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL2_B, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL2_B, CM_DGAM_RAMA_EXP_REGION_END_BASE_B, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL1_G, CM_DGAM_RAMA_EXP_REGION_END_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL2_G, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL2_G, CM_DGAM_RAMA_EXP_REGION_END_BASE_G, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL1_R, CM_DGAM_RAMA_EXP_REGION_END_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL2_R, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_END_CNTL2_R, CM_DGAM_RAMA_EXP_REGION_END_BASE_R, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, mask_sh), \
-	TF_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
-	TF_SF(CM0_CM_MEM_PWR_CTRL, SHARED_MEM_PWR_DIS, mask_sh), \
-	TF_SF(CM0_CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_EN_MASK, mask_sh), \
-	TF_SF(CM0_CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL, mask_sh), \
-	TF_SF(CM0_CM_DGAM_LUT_INDEX, CM_DGAM_LUT_INDEX, mask_sh), \
-	TF_SF(CM0_CM_DGAM_LUT_DATA, CM_DGAM_LUT_DATA, mask_sh), \
-	TF_SF(CM0_CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, mask_sh), \
-	TF_SF(CNVC_CFG0_FORMAT_CONTROL, CNVC_BYPASS, mask_sh), \
-	TF2_SF(CNVC_CFG0, FORMAT_CONTROL__ALPHA_EN, mask_sh), \
-	TF_SF(CNVC_CFG0_FORMAT_CONTROL, FORMAT_EXPANSION_MODE, mask_sh), \
-	TF_SF(CNVC_CFG0_CNVC_SURFACE_PIXEL_FORMAT, CNVC_SURFACE_PIXEL_FORMAT, mask_sh), \
-	TF_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_MODE, mask_sh), \
-	TF_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_EXPANSION_MODE, mask_sh), \
-	TF_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_ENABLE, mask_sh)
+	TF_SF(DSCL0_OBUF_CONTROL, OBUF_BYPASS, mask_sh)
 
 #define TF_REG_LIST_SH_MASK_DCN10(mask_sh)\
 	TF_REG_LIST_SH_MASK_DCN(mask_sh),\
@@ -313,15 +246,39 @@
 	TF_SF(DSCL0_LB_DATA_FORMAT, DITHER_EN, mask_sh),\
 	TF_SF(CM0_CM_COMA_C11_C12, CM_COMA_C11, mask_sh),\
 	TF_SF(CM0_CM_COMA_C11_C12, CM_COMA_C12, mask_sh),\
+	TF_SF(CM0_CM_COMA_C13_C14, CM_COMA_C13, mask_sh),\
+	TF_SF(CM0_CM_COMA_C13_C14, CM_COMA_C14, mask_sh),\
+	TF_SF(CM0_CM_COMA_C21_C22, CM_COMA_C21, mask_sh),\
+	TF_SF(CM0_CM_COMA_C21_C22, CM_COMA_C22, mask_sh),\
+	TF_SF(CM0_CM_COMA_C23_C24, CM_COMA_C23, mask_sh),\
+	TF_SF(CM0_CM_COMA_C23_C24, CM_COMA_C24, mask_sh),\
+	TF_SF(CM0_CM_COMA_C31_C32, CM_COMA_C31, mask_sh),\
+	TF_SF(CM0_CM_COMA_C31_C32, CM_COMA_C32, mask_sh),\
 	TF_SF(CM0_CM_COMA_C33_C34, CM_COMA_C33, mask_sh),\
 	TF_SF(CM0_CM_COMA_C33_C34, CM_COMA_C34, mask_sh),\
 	TF_SF(CM0_CM_COMB_C11_C12, CM_COMB_C11, mask_sh),\
 	TF_SF(CM0_CM_COMB_C11_C12, CM_COMB_C12, mask_sh),\
+	TF_SF(CM0_CM_COMB_C13_C14, CM_COMB_C13, mask_sh),\
+	TF_SF(CM0_CM_COMB_C13_C14, CM_COMB_C14, mask_sh),\
+	TF_SF(CM0_CM_COMB_C21_C22, CM_COMB_C21, mask_sh),\
+	TF_SF(CM0_CM_COMB_C21_C22, CM_COMB_C22, mask_sh),\
+	TF_SF(CM0_CM_COMB_C23_C24, CM_COMB_C23, mask_sh),\
+	TF_SF(CM0_CM_COMB_C23_C24, CM_COMB_C24, mask_sh),\
+	TF_SF(CM0_CM_COMB_C31_C32, CM_COMB_C31, mask_sh),\
 	TF_SF(CM0_CM_COMB_C33_C34, CM_COMB_C33, mask_sh),\
+	TF_SF(CM0_CM_COMB_C31_C32, CM_COMB_C32, mask_sh),\
 	TF_SF(CM0_CM_COMB_C33_C34, CM_COMB_C34, mask_sh),\
 	TF_SF(CM0_CM_OCSC_CONTROL, CM_OCSC_MODE, mask_sh), \
 	TF_SF(CM0_CM_OCSC_C11_C12, CM_OCSC_C11, mask_sh), \
 	TF_SF(CM0_CM_OCSC_C11_C12, CM_OCSC_C12, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C13_C14, CM_OCSC_C13, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C13_C14, CM_OCSC_C14, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C21_C22, CM_OCSC_C21, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C21_C22, CM_OCSC_C22, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C23_C24, CM_OCSC_C23, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C23_C24, CM_OCSC_C24, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C31_C32, CM_OCSC_C31, mask_sh), \
+	TF_SF(CM0_CM_OCSC_C31_C32, CM_OCSC_C32, mask_sh), \
 	TF_SF(CM0_CM_OCSC_C33_C34, CM_OCSC_C33, mask_sh), \
 	TF_SF(CM0_CM_OCSC_C33_C34, CM_OCSC_C34, mask_sh), \
 	TF_SF(CM0_CM_MEM_PWR_CTRL, RGAM_MEM_PWR_FORCE, mask_sh), \
@@ -351,6 +308,66 @@
 	TF_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMB_REGION_0_1, CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_2_3, CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_4_5, CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_6_7, CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_8_9, CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_10_11, CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_12_13, CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_14_15, CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_16_17, CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_18_19, CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_20_21, CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_22_23, CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_24_25, CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_26_27, CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_28_29, CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMB_REGION_30_31, CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMB_REGION_32_33, CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, mask_sh), \
@@ -377,30 +394,73 @@
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_0_1, CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_2_3, CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_4_5, CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_6_7, CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_8_9, CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_10_11, CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_12_13, CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_14_15, CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_16_17, CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_18_19, CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_20_21, CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_22_23, CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_24_25, CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_26_27, CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_28_29, CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, mask_sh), \
+	TF_SF(CM0_CM_RGAM_RAMA_REGION_30_31, CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, mask_sh), \
 	TF_SF(CM0_CM_RGAM_RAMA_REGION_32_33, CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, mask_sh), \
 	TF_SF(CM0_CM_RGAM_CONTROL, CM_RGAM_LUT_MODE, mask_sh), \
-	TF_SF(DSCL0_OBUF_CONTROL, OBUF_H_2X_UPSCALE_EN, mask_sh), \
-	TF_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, mask_sh), \
-	TF_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_FORMAT_R, mask_sh), \
-	TF_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_FORMAT_G, mask_sh), \
-	TF_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_FORMAT_B, mask_sh), \
-	TF_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_RW_MODE, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_WRITE_EN_MASK, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, mask_sh), \
-	TF_SF(CM0_CM_CONTROL, CM_BYPASS_EN, mask_sh), \
-	TF_SF(CM0_CM_IGAM_LUT_SEQ_COLOR, CM_IGAM_LUT_SEQ_COLOR, mask_sh), \
-	TF_SF(CNVC_CFG0_FORMAT_CONTROL, OUTPUT_FP, mask_sh), \
-	TF_SF(CURSOR0_CURSOR_CONTROL, CURSOR_MODE, mask_sh), \
-	TF_SF(CURSOR0_CURSOR_CONTROL, CURSOR_PITCH, mask_sh), \
-	TF_SF(CURSOR0_CURSOR_CONTROL, CURSOR_LINES_PER_CHUNK, mask_sh), \
-	TF_SF(CURSOR0_CURSOR_CONTROL, CURSOR_ENABLE, mask_sh)
+	TF_SF(DSCL0_OBUF_CONTROL, OBUF_H_2X_UPSCALE_EN, mask_sh)
+
 
 #define TF_REG_FIELD_LIST(type) \
 	type EXT_OVERSCAN_LEFT; \
@@ -417,7 +477,7 @@
 	type DYNAMIC_PIXEL_DEPTH; \
 	type DITHER_EN; \
 	type INTERLEAVE_EN; \
-	type LB_DATA_FORMAT__ALPHA_EN; \
+	type ALPHA_EN; \
 	type MEMORY_CONFIG; \
 	type LB_MAX_PARTITIONS; \
 	type AUTOCAL_MODE; \
@@ -472,19 +532,51 @@
 	type CM_GAMUT_REMAP_MODE; \
 	type CM_GAMUT_REMAP_C11; \
 	type CM_GAMUT_REMAP_C12; \
+	type CM_GAMUT_REMAP_C13; \
+	type CM_GAMUT_REMAP_C14; \
+	type CM_GAMUT_REMAP_C21; \
+	type CM_GAMUT_REMAP_C22; \
+	type CM_GAMUT_REMAP_C23; \
+	type CM_GAMUT_REMAP_C24; \
+	type CM_GAMUT_REMAP_C31; \
+	type CM_GAMUT_REMAP_C32; \
 	type CM_GAMUT_REMAP_C33; \
 	type CM_GAMUT_REMAP_C34; \
 	type CM_COMA_C11; \
 	type CM_COMA_C12; \
+	type CM_COMA_C13; \
+	type CM_COMA_C14; \
+	type CM_COMA_C21; \
+	type CM_COMA_C22; \
+	type CM_COMA_C23; \
+	type CM_COMA_C24; \
+	type CM_COMA_C31; \
+	type CM_COMA_C32; \
 	type CM_COMA_C33; \
 	type CM_COMA_C34; \
 	type CM_COMB_C11; \
 	type CM_COMB_C12; \
+	type CM_COMB_C13; \
+	type CM_COMB_C14; \
+	type CM_COMB_C21; \
+	type CM_COMB_C22; \
+	type CM_COMB_C23; \
+	type CM_COMB_C24; \
+	type CM_COMB_C31; \
+	type CM_COMB_C32; \
 	type CM_COMB_C33; \
 	type CM_COMB_C34; \
 	type CM_OCSC_MODE; \
 	type CM_OCSC_C11; \
 	type CM_OCSC_C12; \
+	type CM_OCSC_C13; \
+	type CM_OCSC_C14; \
+	type CM_OCSC_C21; \
+	type CM_OCSC_C22; \
+	type CM_OCSC_C23; \
+	type CM_OCSC_C24; \
+	type CM_OCSC_C31; \
+	type CM_OCSC_C32; \
 	type CM_OCSC_C33; \
 	type CM_OCSC_C34; \
 	type RGAM_MEM_PWR_FORCE; \
@@ -514,6 +606,66 @@
 	type CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS; \
 	type CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET; \
 	type CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS; \
+	type CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET; \
+	type CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS; \
 	type CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET; \
 	type CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS; \
 	type CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET; \
@@ -540,6 +692,66 @@
 	type CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS; \
 	type CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET; \
 	type CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS; \
+	type CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET; \
+	type CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS; \
 	type CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET; \
 	type CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS; \
 	type CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET; \
@@ -911,98 +1123,7 @@
 	type CM_SHAPER_LUT_WRITE_EN_MASK; \
 	type CM_SHAPER_LUT_WRITE_SEL; \
 	type CM_SHAPER_LUT_INDEX; \
-	type CM_SHAPER_LUT_DATA; \
-	type CM_DGAM_CONFIG_STATUS; \
-	type CM_ICSC_MODE; \
-	type CM_ICSC_C11; \
-	type CM_ICSC_C12; \
-	type CM_ICSC_C33; \
-	type CM_ICSC_C34; \
-	type CM_DGAM_RAMB_EXP_REGION_START_B; \
-	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B; \
-	type CM_DGAM_RAMB_EXP_REGION_START_G; \
-	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G; \
-	type CM_DGAM_RAMB_EXP_REGION_START_R; \
-	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R; \
-	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B; \
-	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G; \
-	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R; \
-	type CM_DGAM_RAMB_EXP_REGION_END_B; \
-	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B; \
-	type CM_DGAM_RAMB_EXP_REGION_END_BASE_B; \
-	type CM_DGAM_RAMB_EXP_REGION_END_G; \
-	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G; \
-	type CM_DGAM_RAMB_EXP_REGION_END_BASE_G; \
-	type CM_DGAM_RAMB_EXP_REGION_END_R; \
-	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R; \
-	type CM_DGAM_RAMB_EXP_REGION_END_BASE_R; \
-	type CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET; \
-	type CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS; \
-	type CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET; \
-	type CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS; \
-	type CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET; \
-	type CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS; \
-	type CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET; \
-	type CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS; \
-	type CM_DGAM_RAMA_EXP_REGION_START_B; \
-	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B; \
-	type CM_DGAM_RAMA_EXP_REGION_START_G; \
-	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G; \
-	type CM_DGAM_RAMA_EXP_REGION_START_R; \
-	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R; \
-	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B; \
-	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G; \
-	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R; \
-	type CM_DGAM_RAMA_EXP_REGION_END_B; \
-	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B; \
-	type CM_DGAM_RAMA_EXP_REGION_END_BASE_B; \
-	type CM_DGAM_RAMA_EXP_REGION_END_G; \
-	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G; \
-	type CM_DGAM_RAMA_EXP_REGION_END_BASE_G; \
-	type CM_DGAM_RAMA_EXP_REGION_END_R; \
-	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R; \
-	type CM_DGAM_RAMA_EXP_REGION_END_BASE_R; \
-	type CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET; \
-	type CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS; \
-	type CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET; \
-	type CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS; \
-	type CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET; \
-	type CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS; \
-	type CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET; \
-	type CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS; \
-	type SHARED_MEM_PWR_DIS; \
-	type CM_IGAM_LUT_FORMAT_R; \
-	type CM_IGAM_LUT_FORMAT_G; \
-	type CM_IGAM_LUT_FORMAT_B; \
-	type CM_IGAM_LUT_HOST_EN; \
-	type CM_IGAM_LUT_RW_MODE; \
-	type CM_IGAM_LUT_WRITE_EN_MASK; \
-	type CM_IGAM_LUT_SEL; \
-	type CM_IGAM_LUT_SEQ_COLOR; \
-	type CM_IGAM_DGAM_CONFIG_STATUS; \
-	type CM_DGAM_LUT_WRITE_EN_MASK; \
-	type CM_DGAM_LUT_WRITE_SEL; \
-	type CM_DGAM_LUT_INDEX; \
-	type CM_DGAM_LUT_DATA; \
-	type CM_DGAM_LUT_MODE; \
-	type CM_IGAM_LUT_MODE; \
-	type CM_IGAM_INPUT_FORMAT; \
-	type CM_IGAM_LUT_RW_INDEX; \
-	type CM_BYPASS_EN; \
-	type FORMAT_EXPANSION_MODE; \
-	type CNVC_BYPASS; \
-	type OUTPUT_FP; \
-	type CNVC_SURFACE_PIXEL_FORMAT; \
-	type CURSOR_MODE; \
-	type CURSOR_PITCH; \
-	type CURSOR_LINES_PER_CHUNK; \
-	type CURSOR_ENABLE; \
-	type CUR0_MODE; \
-	type CUR0_EXPANSION_MODE; \
-	type CUR0_ENABLE; \
-	type CM_BYPASS; \
-	type FORMAT_CONTROL__ALPHA_EN
-
+	type CM_SHAPER_LUT_DATA
 
 
 struct dcn_dpp_shift {
@@ -1046,13 +1167,29 @@ struct dcn_dpp_registers {
 	uint32_t RECOUT_SIZE;
 	uint32_t CM_GAMUT_REMAP_CONTROL;
 	uint32_t CM_GAMUT_REMAP_C11_C12;
+	uint32_t CM_GAMUT_REMAP_C13_C14;
+	uint32_t CM_GAMUT_REMAP_C21_C22;
+	uint32_t CM_GAMUT_REMAP_C23_C24;
+	uint32_t CM_GAMUT_REMAP_C31_C32;
 	uint32_t CM_GAMUT_REMAP_C33_C34;
 	uint32_t CM_COMA_C11_C12;
+	uint32_t CM_COMA_C13_C14;
+	uint32_t CM_COMA_C21_C22;
+	uint32_t CM_COMA_C23_C24;
+	uint32_t CM_COMA_C31_C32;
 	uint32_t CM_COMA_C33_C34;
 	uint32_t CM_COMB_C11_C12;
+	uint32_t CM_COMB_C13_C14;
+	uint32_t CM_COMB_C21_C22;
+	uint32_t CM_COMB_C23_C24;
+	uint32_t CM_COMB_C31_C32;
 	uint32_t CM_COMB_C33_C34;
 	uint32_t CM_OCSC_CONTROL;
 	uint32_t CM_OCSC_C11_C12;
+	uint32_t CM_OCSC_C13_C14;
+	uint32_t CM_OCSC_C21_C22;
+	uint32_t CM_OCSC_C23_C24;
+	uint32_t CM_OCSC_C31_C32;
 	uint32_t CM_OCSC_C33_C34;
 	uint32_t CM_MEM_PWR_CTRL;
 	uint32_t CM_RGAM_LUT_DATA;
@@ -1071,6 +1208,21 @@ struct dcn_dpp_registers {
 	uint32_t CM_RGAM_RAMB_END_CNTL1_R;
 	uint32_t CM_RGAM_RAMB_END_CNTL2_R;
 	uint32_t CM_RGAM_RAMB_REGION_0_1;
+	uint32_t CM_RGAM_RAMB_REGION_2_3;
+	uint32_t CM_RGAM_RAMB_REGION_4_5;
+	uint32_t CM_RGAM_RAMB_REGION_6_7;
+	uint32_t CM_RGAM_RAMB_REGION_8_9;
+	uint32_t CM_RGAM_RAMB_REGION_10_11;
+	uint32_t CM_RGAM_RAMB_REGION_12_13;
+	uint32_t CM_RGAM_RAMB_REGION_14_15;
+	uint32_t CM_RGAM_RAMB_REGION_16_17;
+	uint32_t CM_RGAM_RAMB_REGION_18_19;
+	uint32_t CM_RGAM_RAMB_REGION_20_21;
+	uint32_t CM_RGAM_RAMB_REGION_22_23;
+	uint32_t CM_RGAM_RAMB_REGION_24_25;
+	uint32_t CM_RGAM_RAMB_REGION_26_27;
+	uint32_t CM_RGAM_RAMB_REGION_28_29;
+	uint32_t CM_RGAM_RAMB_REGION_30_31;
 	uint32_t CM_RGAM_RAMB_REGION_32_33;
 	uint32_t CM_RGAM_RAMA_START_CNTL_B;
 	uint32_t CM_RGAM_RAMA_START_CNTL_G;
@@ -1085,6 +1237,21 @@ struct dcn_dpp_registers {
 	uint32_t CM_RGAM_RAMA_END_CNTL1_R;
 	uint32_t CM_RGAM_RAMA_END_CNTL2_R;
 	uint32_t CM_RGAM_RAMA_REGION_0_1;
+	uint32_t CM_RGAM_RAMA_REGION_2_3;
+	uint32_t CM_RGAM_RAMA_REGION_4_5;
+	uint32_t CM_RGAM_RAMA_REGION_6_7;
+	uint32_t CM_RGAM_RAMA_REGION_8_9;
+	uint32_t CM_RGAM_RAMA_REGION_10_11;
+	uint32_t CM_RGAM_RAMA_REGION_12_13;
+	uint32_t CM_RGAM_RAMA_REGION_14_15;
+	uint32_t CM_RGAM_RAMA_REGION_16_17;
+	uint32_t CM_RGAM_RAMA_REGION_18_19;
+	uint32_t CM_RGAM_RAMA_REGION_20_21;
+	uint32_t CM_RGAM_RAMA_REGION_22_23;
+	uint32_t CM_RGAM_RAMA_REGION_24_25;
+	uint32_t CM_RGAM_RAMA_REGION_26_27;
+	uint32_t CM_RGAM_RAMA_REGION_28_29;
+	uint32_t CM_RGAM_RAMA_REGION_30_31;
 	uint32_t CM_RGAM_RAMA_REGION_32_33;
 	uint32_t CM_RGAM_CONTROL;
 	uint32_t OBUF_CONTROL;
@@ -1199,50 +1366,8 @@ struct dcn_dpp_registers {
 	uint32_t CM_SHAPER_RAMA_REGION_32_33;
 	uint32_t CM_SHAPER_LUT_INDEX;
 	uint32_t CM_SHAPER_LUT_DATA;
-	uint32_t CM_ICSC_CONTROL;
-	uint32_t CM_ICSC_C11_C12;
-	uint32_t CM_ICSC_C33_C34;
-	uint32_t CM_DGAM_RAMB_START_CNTL_B;
-	uint32_t CM_DGAM_RAMB_START_CNTL_G;
-	uint32_t CM_DGAM_RAMB_START_CNTL_R;
-	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_B;
-	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_G;
-	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_R;
-	uint32_t CM_DGAM_RAMB_END_CNTL1_B;
-	uint32_t CM_DGAM_RAMB_END_CNTL2_B;
-	uint32_t CM_DGAM_RAMB_END_CNTL1_G;
-	uint32_t CM_DGAM_RAMB_END_CNTL2_G;
-	uint32_t CM_DGAM_RAMB_END_CNTL1_R;
-	uint32_t CM_DGAM_RAMB_END_CNTL2_R;
-	uint32_t CM_DGAM_RAMB_REGION_0_1;
-	uint32_t CM_DGAM_RAMB_REGION_14_15;
-	uint32_t CM_DGAM_RAMA_START_CNTL_B;
-	uint32_t CM_DGAM_RAMA_START_CNTL_G;
-	uint32_t CM_DGAM_RAMA_START_CNTL_R;
-	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_B;
-	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_G;
-	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_R;
-	uint32_t CM_DGAM_RAMA_END_CNTL1_B;
-	uint32_t CM_DGAM_RAMA_END_CNTL2_B;
-	uint32_t CM_DGAM_RAMA_END_CNTL1_G;
-	uint32_t CM_DGAM_RAMA_END_CNTL2_G;
-	uint32_t CM_DGAM_RAMA_END_CNTL1_R;
-	uint32_t CM_DGAM_RAMA_END_CNTL2_R;
-	uint32_t CM_DGAM_RAMA_REGION_0_1;
-	uint32_t CM_DGAM_RAMA_REGION_14_15;
-	uint32_t CM_DGAM_LUT_WRITE_EN_MASK;
-	uint32_t CM_DGAM_LUT_INDEX;
-	uint32_t CM_DGAM_LUT_DATA;
-	uint32_t CM_CONTROL;
-	uint32_t CM_DGAM_CONTROL;
-	uint32_t CM_IGAM_CONTROL;
-	uint32_t CM_IGAM_LUT_RW_CONTROL;
-	uint32_t CM_IGAM_LUT_RW_INDEX;
-	uint32_t CM_IGAM_LUT_SEQ_COLOR;
-	uint32_t FORMAT_CONTROL;
-	uint32_t CNVC_SURFACE_PIXEL_FORMAT;
-	uint32_t CURSOR_CONTROL;
-	uint32_t CURSOR0_CONTROL;
+
+
 };
 
 struct dcn10_dpp {
@@ -1261,106 +1386,6 @@ struct dcn10_dpp {
 	int lb_bits_per_entry;
 	bool is_write_to_ram_a_safe;
 };
-
-enum dcn10_input_csc_select {
-	INPUT_CSC_SELECT_BYPASS = 0,
-	INPUT_CSC_SELECT_ICSC,
-	INPUT_CSC_SELECT_COMA
-};
-
-void ippn10_degamma_ram_select(
-		struct transform *xfm_base,
-							bool use_ram_a);
-
-void ippn10_program_degamma_luta_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params);
-
-void ippn10_program_degamma_lutb_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params);
-
-void ippn10_program_degamma_lut(
-		struct transform *xfm_base,
-		const struct pwl_result_data *rgb,
-		uint32_t num,
-		bool is_ram_a);
-
-void ippn10_power_on_degamma_lut(
-		struct transform *xfm_base,
-	bool power_on);
-
-void ippn10_program_input_csc(
-		struct transform *xfm_base,
-		enum dc_color_space color_space,
-		enum dcn10_input_csc_select select);
-
-void ippn10_program_input_lut(
-		struct transform *xfm_base,
-		const struct dc_gamma *gamma);
-
-void ippn10_full_bypass(struct transform *xfm_base);
-
-void ippn10_set_degamma(
-		struct transform *xfm_base,
-		enum ipp_degamma_mode mode);
-
-void ippn10_set_degamma_pwl(struct transform *xfm_base,
-								 const struct pwl_params *params);
-
-bool dpp_get_optimal_number_of_taps(
-		struct transform *xfm,
-		struct scaler_data *scl_data,
-		const struct scaling_taps *in_taps);
-
-void dpp_reset(struct transform *xfm_base);
-
-void dcn10_dpp_cm_program_regamma_lut(
-		struct transform *xfm_base,
-		const struct pwl_result_data *rgb,
-		uint32_t num);
-
-void dcn10_dpp_cm_power_on_regamma_lut(
-	struct transform *xfm_base,
-	bool power_on);
-
-void dcn10_dpp_cm_configure_regamma_lut(
-		struct transform *xfm_base,
-		bool is_ram_a);
-
-/*program re gamma RAM A*/
-void dcn10_dpp_cm_program_regamma_luta_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params);
-
-/*program re gamma RAM B*/
-void dcn10_dpp_cm_program_regamma_lutb_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params);
-void dcn10_dpp_cm_set_output_csc_adjustment(
-		struct transform *xfm_base,
-		const struct out_csc_color_matrix *tbl_entry);
-
-void dcn10_dpp_cm_set_output_csc_default(
-		struct transform *xfm_base,
-		const struct default_adjustment *default_adjust);
-
-void dcn10_dpp_cm_set_gamut_remap(
-	struct transform *xfm,
-	const struct xfm_grph_csc_adjustment *adjust);
-
-void dcn10_dpp_dscl_set_scaler_manual_scale(
-	struct transform *xfm_base,
-	const struct scaler_data *scl_data);
-
-void ippn10_cnv_setup (
-		struct transform *xfm_base,
-		enum surface_pixel_format input_format,
-		enum expansion_mode mode,
-		enum ipp_output_format cnv_out_format);
-
-void ippn10_full_bypass(struct transform *xfm_base);
-
 bool dcn10_dpp_construct(struct dcn10_dpp *xfm110,
 	struct dc_context *ctx,
 	uint32_t inst,
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
deleted file mode 100644
index d698fcc..0000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ /dev/null
@@ -1,864 +0,0 @@
-/*
- * Copyright 2016 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "core_types.h"
-
-#include "reg_helper.h"
-#include "dcn10_dpp.h"
-#include "basics/conversion.h"
-
-#define NUM_PHASES    64
-#define HORZ_MAX_TAPS 8
-#define VERT_MAX_TAPS 8
-
-#define BLACK_OFFSET_RGB_Y 0x0
-#define BLACK_OFFSET_CBCR  0x8000
-
-#define REG(reg)\
-	xfm->tf_regs->reg
-
-#define CTX \
-	xfm->base.ctx
-
-#undef FN
-#define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
-
-struct dcn10_input_csc_matrix {
-	enum dc_color_space color_space;
-	uint16_t regval[12];
-};
-
-enum dcn10_coef_filter_type_sel {
-	SCL_COEF_LUMA_VERT_FILTER = 0,
-	SCL_COEF_LUMA_HORZ_FILTER = 1,
-	SCL_COEF_CHROMA_VERT_FILTER = 2,
-	SCL_COEF_CHROMA_HORZ_FILTER = 3,
-	SCL_COEF_ALPHA_VERT_FILTER = 4,
-	SCL_COEF_ALPHA_HORZ_FILTER = 5
-};
-
-enum dscl_autocal_mode {
-	AUTOCAL_MODE_OFF = 0,
-
-	/* Autocal calculate the scaling ratio and initial phase and the
-	 * DSCL_MODE_SEL must be set to 1
-	 */
-	AUTOCAL_MODE_AUTOSCALE = 1,
-	/* Autocal perform auto centering without replication and the
-	 * DSCL_MODE_SEL must be set to 0
-	 */
-	AUTOCAL_MODE_AUTOCENTER = 2,
-	/* Autocal perform auto centering and auto replication and the
-	 * DSCL_MODE_SEL must be set to 0
-	 */
-	AUTOCAL_MODE_AUTOREPLICATE = 3
-};
-
-enum dscl_mode_sel {
-	DSCL_MODE_SCALING_444_BYPASS = 0,
-	DSCL_MODE_SCALING_444_RGB_ENABLE = 1,
-	DSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
-	DSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
-	DSCL_MODE_SCALING_420_LUMA_BYPASS = 4,
-	DSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
-	DSCL_MODE_DSCL_BYPASS = 6
-};
-
-enum gamut_remap_select {
-	GAMUT_REMAP_BYPASS = 0,
-	GAMUT_REMAP_COEFF,
-	GAMUT_REMAP_COMA_COEFF,
-	GAMUT_REMAP_COMB_COEFF
-};
-
-static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
-	{COLOR_SPACE_SRGB,
-		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-	{COLOR_SPACE_SRGB_LIMITED,
-		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-	{COLOR_SPACE_YCBCR601,
-		{0x2cdd, 0x2000, 0, 0xe991, 0xe926, 0x2000, 0xf4fd, 0x10ef,
-						0, 0x2000, 0x38b4, 0xe3a6} },
-	{COLOR_SPACE_YCBCR601_LIMITED,
-		{0x3353, 0x2568, 0, 0xe400, 0xe5dc, 0x2568, 0xf367, 0x1108,
-						0, 0x2568, 0x40de, 0xdd3a} },
-	{COLOR_SPACE_YCBCR709,
-		{0x3265, 0x2000, 0, 0xe6ce, 0xf105, 0x2000, 0xfa01, 0xa7d, 0,
-						0x2000, 0x3b61, 0xe24f} },
-
-	{COLOR_SPACE_YCBCR709_LIMITED,
-		{0x39a6, 0x2568, 0, 0xe0d6, 0xeedd, 0x2568, 0xf925, 0x9a8, 0,
-						0x2568, 0x43ee, 0xdbb2} }
-};
-
-static void dpp_cm_program_color_registers(
-		struct dcn10_dpp *xfm,
-		const uint16_t *regval,
-		uint32_t cm_reg_start,
-		uint32_t cm_reg_end)
-{
-	uint32_t reg_region_cur;
-	unsigned int i = 0;
-
-#undef REG
-#define REG(reg) reg
-
-	for (reg_region_cur = cm_reg_start;
-			reg_region_cur <= cm_reg_end;
-			reg_region_cur++) {
-
-		const uint16_t *regval0 = &(regval[2 * i]);
-		const uint16_t *regval1 = &(regval[(2 * i) + 1]);
-
-		REG_SET_2(reg_region_cur, 0,
-				CM_GAMUT_REMAP_C11, *regval0,
-				CM_GAMUT_REMAP_C12, *regval1);
-
-		i++;
-	}
-
-#undef REG
-#define REG(reg)\
-	xfm->tf_regs->reg
-
-}
-
-static void program_gamut_remap(
-		struct dcn10_dpp *xfm,
-		const uint16_t *regval,
-		enum gamut_remap_select select)
-{
-	 uint16_t selection = 0;
-
-	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
-		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
-				CM_GAMUT_REMAP_MODE, 0);
-		return;
-	}
-	switch (select) {
-	case GAMUT_REMAP_COEFF:
-		selection = 1;
-		break;
-	case GAMUT_REMAP_COMA_COEFF:
-		selection = 2;
-		break;
-	case GAMUT_REMAP_COMB_COEFF:
-		selection = 3;
-		break;
-	default:
-		break;
-	}
-
-
-	if (select == GAMUT_REMAP_COEFF) {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				regval,
-				REG(CM_GAMUT_REMAP_C11_C12),
-				REG(CM_GAMUT_REMAP_C33_C34));
-
-	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				regval,
-				REG(CM_COMA_C11_C12),
-				REG(CM_COMA_C33_C34));
-
-	} else {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				regval,
-				REG(CM_COMB_C11_C12),
-				REG(CM_COMB_C33_C34));
-	}
-
-	REG_SET(
-			CM_GAMUT_REMAP_CONTROL, 0,
-			CM_GAMUT_REMAP_MODE, selection);
-
-}
-
-void dcn10_dpp_cm_set_gamut_remap(
-	struct transform *xfm,
-	const struct xfm_grph_csc_adjustment *adjust)
-{
-	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
-
-	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
-		/* Bypass if type is bypass or hw */
-		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
-	else {
-		struct fixed31_32 arr_matrix[12];
-		uint16_t arr_reg_val[12];
-
-		arr_matrix[0] = adjust->temperature_matrix[0];
-		arr_matrix[1] = adjust->temperature_matrix[1];
-		arr_matrix[2] = adjust->temperature_matrix[2];
-		arr_matrix[3] = dal_fixed31_32_zero;
-
-		arr_matrix[4] = adjust->temperature_matrix[3];
-		arr_matrix[5] = adjust->temperature_matrix[4];
-		arr_matrix[6] = adjust->temperature_matrix[5];
-		arr_matrix[7] = dal_fixed31_32_zero;
-
-		arr_matrix[8] = adjust->temperature_matrix[6];
-		arr_matrix[9] = adjust->temperature_matrix[7];
-		arr_matrix[10] = adjust->temperature_matrix[8];
-		arr_matrix[11] = dal_fixed31_32_zero;
-
-		convert_float_matrix(
-			arr_reg_val, arr_matrix, 12);
-
-		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
-	}
-}
-
-void dcn10_dpp_cm_set_output_csc_default(
-		struct transform *xfm_base,
-		const struct default_adjustment *default_adjust)
-{
-
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	uint32_t ocsc_mode = 0;
-
-	if (default_adjust != NULL) {
-		switch (default_adjust->out_color_space) {
-		case COLOR_SPACE_SRGB:
-		case COLOR_SPACE_2020_RGB_FULLRANGE:
-			ocsc_mode = 0;
-			break;
-		case COLOR_SPACE_SRGB_LIMITED:
-		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-			ocsc_mode = 1;
-			break;
-		case COLOR_SPACE_YCBCR601:
-		case COLOR_SPACE_YCBCR601_LIMITED:
-			ocsc_mode = 2;
-			break;
-		case COLOR_SPACE_YCBCR709:
-		case COLOR_SPACE_YCBCR709_LIMITED:
-		case COLOR_SPACE_2020_YCBCR:
-			ocsc_mode = 3;
-			break;
-		case COLOR_SPACE_UNKNOWN:
-		default:
-			break;
-		}
-	}
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-
-}
-
-static void dcn10_dpp_cm_program_color_matrix(
-		struct dcn10_dpp *xfm,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-	uint32_t mode;
-
-	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
-
-	if (tbl_entry == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	if (mode == 4) {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				tbl_entry->regval,
-				REG(CM_OCSC_C11_C12),
-				REG(CM_OCSC_C33_C34));
-
-	} else {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				tbl_entry->regval,
-				REG(CM_COMB_C11_C12),
-				REG(CM_COMB_C33_C34));
-	}
-}
-
-void dcn10_dpp_cm_set_output_csc_adjustment(
-		struct transform *xfm_base,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
-	uint32_t ocsc_mode = 4;
-
-	/**
-	*if (tbl_entry != NULL) {
-	*	switch (tbl_entry->color_space) {
-	*	case COLOR_SPACE_SRGB:
-	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
-	*		ocsc_mode = 0;
-	*		break;
-	*	case COLOR_SPACE_SRGB_LIMITED:
-	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-	*		ocsc_mode = 1;
-	*		break;
-	*	case COLOR_SPACE_YCBCR601:
-	*	case COLOR_SPACE_YCBCR601_LIMITED:
-	*		ocsc_mode = 2;
-	*		break;
-	*	case COLOR_SPACE_YCBCR709:
-	*	case COLOR_SPACE_YCBCR709_LIMITED:
-	*	case COLOR_SPACE_2020_YCBCR:
-	*		ocsc_mode = 3;
-	*		break;
-	*	case COLOR_SPACE_UNKNOWN:
-	*	default:
-	*		break;
-	*	}
-	*}
-	*/
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	dcn10_dpp_cm_program_color_matrix(xfm, tbl_entry);
-}
-
-void dcn10_dpp_cm_power_on_regamma_lut(
-	struct transform *xfm_base,
-	bool power_on)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	REG_SET(CM_MEM_PWR_CTRL, 0,
-			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
-
-}
-
-void dcn10_dpp_cm_program_regamma_lut(
-		struct transform *xfm_base,
-		const struct pwl_result_data *rgb,
-		uint32_t num)
-{
-	uint32_t i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	for (i = 0 ; i < num; i++) {
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
-
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
-
-	}
-
-}
-
-void dcn10_dpp_cm_configure_regamma_lut(
-		struct transform *xfm_base,
-		bool is_ram_a)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
-			CM_RGAM_LUT_WRITE_EN_MASK, 7);
-	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
-			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
-	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
-}
-
-struct cm_gam_ram_reg {
-	uint32_t start_cntl_b;
-	uint32_t start_cntl_g;
-	uint32_t start_cntl_r;
-	uint32_t start_slope_cntl_b;
-	uint32_t start_slope_cntl_g;
-	uint32_t start_slope_cntl_r;
-	uint32_t start_end_cntl1_b;
-	uint32_t start_end_cntl2_b;
-	uint32_t start_end_cntl1_g;
-	uint32_t start_end_cntl2_g;
-	uint32_t start_end_cntl1_r;
-	uint32_t start_end_cntl2_r;
-	uint32_t region_start;
-	uint32_t region_end;
-};
-
-static void dpp_cm_program_region_lut(
-		struct transform *xfm_base,
-		const struct pwl_params *params,
-		const struct cm_gam_ram_reg *reg)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	uint32_t reg_region_cur;
-	unsigned int i = 0;
-
-#undef REG
-#define REG(reg) reg
-
-	REG_SET_2(reg->start_cntl_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(reg->start_cntl_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(reg->start_cntl_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(reg->start_slope_cntl_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(reg->start_slope_cntl_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(reg->start_slope_cntl_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(reg->start_end_cntl1_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(reg->start_end_cntl2_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(reg->start_end_cntl1_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(reg->start_end_cntl2_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(reg->start_end_cntl1_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(reg->start_end_cntl2_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	for (reg_region_cur = reg->region_start;
-			reg_region_cur <= reg->region_end;
-			reg_region_cur++) {
-
-		const struct gamma_curve *curve0 = &(params->arr_curve_points[2 * i]);
-		const struct gamma_curve *curve1 = &(params->arr_curve_points[(2 * i) + 1]);
-
-		REG_SET_4(reg_region_cur, 0,
-			CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve0->offset,
-			CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve0->segments_num,
-			CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve1->offset,
-			CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve1->segments_num);
-
-		i++;
-	}
-
-#undef REG
-#define REG(reg)\
-	xfm->tf_regs->reg
-
-}
-
-
-
-/*program re gamma RAM A*/
-void dcn10_dpp_cm_program_regamma_luta_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
-
-	gam_regs.start_cntl_b = REG(CM_RGAM_RAMA_START_CNTL_B);
-	gam_regs.start_cntl_g = REG(CM_RGAM_RAMA_START_CNTL_G);
-	gam_regs.start_cntl_r = REG(CM_RGAM_RAMA_START_CNTL_R);
-	gam_regs.start_slope_cntl_b = REG(CM_RGAM_RAMA_SLOPE_CNTL_B);
-	gam_regs.start_slope_cntl_g = REG(CM_RGAM_RAMA_SLOPE_CNTL_G);
-	gam_regs.start_slope_cntl_r = REG(CM_RGAM_RAMA_SLOPE_CNTL_R);
-	gam_regs.start_end_cntl1_b = REG(CM_RGAM_RAMA_END_CNTL1_B);
-	gam_regs.start_end_cntl2_b = REG(CM_RGAM_RAMA_END_CNTL2_B);
-	gam_regs.start_end_cntl1_g = REG(CM_RGAM_RAMA_END_CNTL1_G);
-	gam_regs.start_end_cntl2_g = REG(CM_RGAM_RAMA_END_CNTL2_G);
-	gam_regs.start_end_cntl1_r = REG(CM_RGAM_RAMA_END_CNTL1_R);
-	gam_regs.start_end_cntl2_r = REG(CM_RGAM_RAMA_END_CNTL2_R);
-	gam_regs.region_start = REG(CM_RGAM_RAMA_REGION_0_1);
-	gam_regs.region_end = REG(CM_RGAM_RAMA_REGION_32_33);
-
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
-
-}
-
-/*program re gamma RAM B*/
-void dcn10_dpp_cm_program_regamma_lutb_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
-
-	gam_regs.start_cntl_b = REG(CM_RGAM_RAMB_START_CNTL_B);
-	gam_regs.start_cntl_g = REG(CM_RGAM_RAMB_START_CNTL_G);
-	gam_regs.start_cntl_r = REG(CM_RGAM_RAMB_START_CNTL_R);
-	gam_regs.start_slope_cntl_b = REG(CM_RGAM_RAMB_SLOPE_CNTL_B);
-	gam_regs.start_slope_cntl_g = REG(CM_RGAM_RAMB_SLOPE_CNTL_G);
-	gam_regs.start_slope_cntl_r = REG(CM_RGAM_RAMB_SLOPE_CNTL_R);
-	gam_regs.start_end_cntl1_b = REG(CM_RGAM_RAMB_END_CNTL1_B);
-	gam_regs.start_end_cntl2_b = REG(CM_RGAM_RAMB_END_CNTL2_B);
-	gam_regs.start_end_cntl1_g = REG(CM_RGAM_RAMB_END_CNTL1_G);
-	gam_regs.start_end_cntl2_g = REG(CM_RGAM_RAMB_END_CNTL2_G);
-	gam_regs.start_end_cntl1_r = REG(CM_RGAM_RAMB_END_CNTL1_R);
-	gam_regs.start_end_cntl2_r = REG(CM_RGAM_RAMB_END_CNTL2_R);
-	gam_regs.region_start = REG(CM_RGAM_RAMB_REGION_0_1);
-	gam_regs.region_end = REG(CM_RGAM_RAMB_REGION_32_33);
-
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
-}
-
-void ippn10_program_input_csc(
-		struct transform *xfm_base,
-		enum dc_color_space color_space,
-		enum dcn10_input_csc_select select)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	int i;
-	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
-	const uint16_t *regval = NULL;
-	uint32_t selection = 1;
-
-	if (select == INPUT_CSC_SELECT_BYPASS) {
-		REG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);
-		return;
-	}
-
-	for (i = 0; i < arr_size; i++)
-		if (dcn10_input_csc_matrix[i].color_space == color_space) {
-			regval = dcn10_input_csc_matrix[i].regval;
-			break;
-		}
-
-	if (regval == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	if (select == INPUT_CSC_SELECT_COMA)
-		selection = 2;
-	REG_SET(CM_ICSC_CONTROL, 0,
-			CM_ICSC_MODE, selection);
-
-	if (select == INPUT_CSC_SELECT_ICSC) {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				regval,
-				REG(CM_ICSC_C11_C12),
-				REG(CM_ICSC_C33_C34));
-	} else {
-
-		dpp_cm_program_color_registers(
-				xfm,
-				regval,
-				REG(CM_COMA_C11_C12),
-				REG(CM_COMA_C33_C34));
-	}
-}
-
-/*program de gamma RAM B*/
-void ippn10_program_degamma_lutb_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
-
-	gam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);
-	gam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);
-	gam_regs.start_cntl_r = REG(CM_DGAM_RAMB_START_CNTL_R);
-	gam_regs.start_slope_cntl_b = REG(CM_DGAM_RAMB_SLOPE_CNTL_B);
-	gam_regs.start_slope_cntl_g = REG(CM_DGAM_RAMB_SLOPE_CNTL_G);
-	gam_regs.start_slope_cntl_r = REG(CM_DGAM_RAMB_SLOPE_CNTL_R);
-	gam_regs.start_end_cntl1_b = REG(CM_DGAM_RAMB_END_CNTL1_B);
-	gam_regs.start_end_cntl2_b = REG(CM_DGAM_RAMB_END_CNTL2_B);
-	gam_regs.start_end_cntl1_g = REG(CM_DGAM_RAMB_END_CNTL1_G);
-	gam_regs.start_end_cntl2_g = REG(CM_DGAM_RAMB_END_CNTL2_G);
-	gam_regs.start_end_cntl1_r = REG(CM_DGAM_RAMB_END_CNTL1_R);
-	gam_regs.start_end_cntl2_r = REG(CM_DGAM_RAMB_END_CNTL2_R);
-	gam_regs.region_start = REG(CM_DGAM_RAMB_REGION_0_1);
-	gam_regs.region_end = REG(CM_DGAM_RAMB_REGION_14_15);
-
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
-}
-
-/*program de gamma RAM A*/
-void ippn10_program_degamma_luta_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
-
-	gam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);
-	gam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);
-	gam_regs.start_cntl_r = REG(CM_DGAM_RAMA_START_CNTL_R);
-	gam_regs.start_slope_cntl_b = REG(CM_DGAM_RAMA_SLOPE_CNTL_B);
-	gam_regs.start_slope_cntl_g = REG(CM_DGAM_RAMA_SLOPE_CNTL_G);
-	gam_regs.start_slope_cntl_r = REG(CM_DGAM_RAMA_SLOPE_CNTL_R);
-	gam_regs.start_end_cntl1_b = REG(CM_DGAM_RAMA_END_CNTL1_B);
-	gam_regs.start_end_cntl2_b = REG(CM_DGAM_RAMA_END_CNTL2_B);
-	gam_regs.start_end_cntl1_g = REG(CM_DGAM_RAMA_END_CNTL1_G);
-	gam_regs.start_end_cntl2_g = REG(CM_DGAM_RAMA_END_CNTL2_G);
-	gam_regs.start_end_cntl1_r = REG(CM_DGAM_RAMA_END_CNTL1_R);
-	gam_regs.start_end_cntl2_r = REG(CM_DGAM_RAMA_END_CNTL2_R);
-	gam_regs.region_start = REG(CM_DGAM_RAMA_REGION_0_1);
-	gam_regs.region_end = REG(CM_DGAM_RAMA_REGION_14_15);
-
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
-}
-
-void ippn10_power_on_degamma_lut(
-		struct transform *xfm_base,
-	bool power_on)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_SET(CM_MEM_PWR_CTRL, 0,
-			SHARED_MEM_PWR_DIS, power_on == true ? 0:1);
-
-}
-
-static void ippn10_enable_cm_block(
-		struct transform *xfm_base)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
-}
-
-void ippn10_set_degamma(
-		struct transform *xfm_base,
-		enum ipp_degamma_mode mode)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	ippn10_enable_cm_block(xfm_base);
-
-	switch (mode) {
-	case IPP_DEGAMMA_MODE_BYPASS:
-		/* Setting de gamma bypass for now */
-		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 0);
-		break;
-	case IPP_DEGAMMA_MODE_HW_sRGB:
-		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 1);
-		break;
-	case IPP_DEGAMMA_MODE_HW_xvYCC:
-		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);
-			break;
-	default:
-		BREAK_TO_DEBUGGER();
-		break;
-	}
-}
-
-void ippn10_degamma_ram_select(
-		struct transform *xfm_base,
-							bool use_ram_a)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	if (use_ram_a)
-		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
-	else
-		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 4);
-
-}
-
-static bool ippn10_degamma_ram_inuse(
-		struct transform *xfm_base,
-							bool *ram_a_inuse)
-{
-	bool ret = false;
-	uint32_t status_reg = 0;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
-			&status_reg);
-
-	if (status_reg == 9) {
-		*ram_a_inuse = true;
-		ret = true;
-	} else if (status_reg == 10) {
-		*ram_a_inuse = false;
-		ret = true;
-	}
-	return ret;
-}
-
-void ippn10_program_degamma_lut(
-		struct transform *xfm_base,
-		const struct pwl_result_data *rgb,
-		uint32_t num,
-		bool is_ram_a)
-{
-	uint32_t i;
-
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);
-	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,
-				   CM_DGAM_LUT_WRITE_EN_MASK, 7);
-	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL,
-					is_ram_a == true ? 0:1);
-
-	REG_SET(CM_DGAM_LUT_INDEX, 0, CM_DGAM_LUT_INDEX, 0);
-	for (i = 0 ; i < num; i++) {
-		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].red_reg);
-		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].green_reg);
-		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].blue_reg);
-
-		REG_SET(CM_DGAM_LUT_DATA, 0,
-				CM_DGAM_LUT_DATA, rgb[i].delta_red_reg);
-		REG_SET(CM_DGAM_LUT_DATA, 0,
-				CM_DGAM_LUT_DATA, rgb[i].delta_green_reg);
-		REG_SET(CM_DGAM_LUT_DATA, 0,
-				CM_DGAM_LUT_DATA, rgb[i].delta_blue_reg);
-	}
-}
-
-void ippn10_set_degamma_pwl(struct transform *xfm_base,
-								 const struct pwl_params *params)
-{
-	bool is_ram_a = true;
-
-	ippn10_power_on_degamma_lut(xfm_base, true);
-	ippn10_enable_cm_block(xfm_base);
-	ippn10_degamma_ram_inuse(xfm_base, &is_ram_a);
-	if (is_ram_a == true)
-		ippn10_program_degamma_lutb_settings(xfm_base, params);
-	else
-		ippn10_program_degamma_luta_settings(xfm_base, params);
-
-	ippn10_program_degamma_lut(xfm_base, params->rgb_resulted,
-							params->hw_points_num, !is_ram_a);
-	ippn10_degamma_ram_select(xfm_base, !is_ram_a);
-}
-
-void ippn10_full_bypass(struct transform *xfm_base)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	/* Input pixel format: ARGB8888 */
-	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
-			CNVC_SURFACE_PIXEL_FORMAT, 0x8);
-
-	/* Zero expansion */
-	REG_SET_3(FORMAT_CONTROL, 0,
-			CNVC_BYPASS, 0,
-			FORMAT_CONTROL__ALPHA_EN, 0,
-			FORMAT_EXPANSION_MODE, 0);
-
-	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
-	REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
-
-	/* Setting degamma bypass for now */
-	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
-	REG_SET(CM_IGAM_CONTROL, 0, CM_IGAM_LUT_MODE, 0);
-}
-
-static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,
-							bool *ram_a_inuse)
-{
-	bool in_use = false;
-	uint32_t status_reg = 0;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
-				&status_reg);
-
-	// 1 => IGAM_RAMA, 3 => IGAM_RAMA & DGAM_ROMA, 4 => IGAM_RAMA & DGAM_ROMB
-	if (status_reg == 1 || status_reg == 3 || status_reg == 4) {
-		*ram_a_inuse = true;
-		in_use = true;
-	// 2 => IGAM_RAMB, 5 => IGAM_RAMB & DGAM_ROMA, 6 => IGAM_RAMB & DGAM_ROMB
-	} else if (status_reg == 2 || status_reg == 5 || status_reg == 6) {
-		*ram_a_inuse = false;
-		in_use = true;
-	}
-	return in_use;
-}
-
-/*
- * Input gamma LUT currently supports 256 values only. This means input color
- * can have a maximum of 8 bits per channel (= 256 possible values) in order to
- * have a one-to-one mapping with the LUT. Truncation will occur with color
- * values greater than 8 bits.
- *
- * In the future, this function should support additional input gamma methods,
- * such as piecewise linear mapping, and input gamma bypass.
- */
-void ippn10_program_input_lut(
-		struct transform *xfm_base,
-		const struct dc_gamma *gamma)
-{
-	int i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	bool rama_occupied = false;
-	uint32_t ram_num;
-	// Power on LUT memory.
-	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 1);
-	ippn10_enable_cm_block(xfm_base);
-	// Determine whether to use RAM A or RAM B
-	ippn10_ingamma_ram_inuse(xfm_base, &rama_occupied);
-	if (!rama_occupied)
-		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 0);
-	else
-		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 1);
-	// RW mode is 256-entry LUT
-	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_RW_MODE, 0);
-	// IGAM Input format should be 8 bits per channel.
-	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 0);
-	// Do not mask any R,G,B values
-	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_WRITE_EN_MASK, 7);
-	// LUT-256, unsigned, integer, new u0.12 format
-	REG_UPDATE_3(
-		CM_IGAM_CONTROL,
-		CM_IGAM_LUT_FORMAT_R, 3,
-		CM_IGAM_LUT_FORMAT_G, 3,
-		CM_IGAM_LUT_FORMAT_B, 3);
-	// Start at index 0 of IGAM LUT
-	REG_UPDATE(CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, 0);
-	for (i = 0; i < gamma->num_entries; i++) {
-		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
-				dal_fixed31_32_round(
-					gamma->entries.red[i]));
-		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
-				dal_fixed31_32_round(
-					gamma->entries.green[i]));
-		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
-				dal_fixed31_32_round(
-					gamma->entries.blue[i]));
-	}
-	// Power off LUT memory
-	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 0);
-	// Enable IGAM LUT on ram we just wrote to. 2 => RAMA, 3 => RAMB
-	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, rama_occupied ? 3 : 2);
-	REG_GET(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, &ram_num);
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c
deleted file mode 100644
index b62cb38..0000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_dscl.c
+++ /dev/null
@@ -1,710 +0,0 @@
-/*
- * Copyright 2016 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#include "dm_services.h"
-
-#include "core_types.h"
-
-#include "reg_helper.h"
-#include "dcn10_dpp.h"
-#include "basics/conversion.h"
-
-#define NUM_PHASES    64
-#define HORZ_MAX_TAPS 8
-#define VERT_MAX_TAPS 8
-
-#define BLACK_OFFSET_RGB_Y 0x0
-#define BLACK_OFFSET_CBCR  0x8000
-
-#define REG(reg)\
-	xfm->tf_regs->reg
-
-#define CTX \
-	xfm->base.ctx
-
-#undef FN
-#define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
-
-enum dcn10_coef_filter_type_sel {
-	SCL_COEF_LUMA_VERT_FILTER = 0,
-	SCL_COEF_LUMA_HORZ_FILTER = 1,
-	SCL_COEF_CHROMA_VERT_FILTER = 2,
-	SCL_COEF_CHROMA_HORZ_FILTER = 3,
-	SCL_COEF_ALPHA_VERT_FILTER = 4,
-	SCL_COEF_ALPHA_HORZ_FILTER = 5
-};
-
-enum lb_memory_config {
-	/* Enable all 3 pieces of memory */
-	LB_MEMORY_CONFIG_0 = 0,
-
-	/* Enable only the first piece of memory */
-	LB_MEMORY_CONFIG_1 = 1,
-
-	/* Enable only the second piece of memory */
-	LB_MEMORY_CONFIG_2 = 2,
-
-	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
-	 * last piece of chroma memory used for the luma storage
-	 */
-	LB_MEMORY_CONFIG_3 = 3
-};
-
-enum dscl_autocal_mode {
-	AUTOCAL_MODE_OFF = 0,
-
-	/* Autocal calculate the scaling ratio and initial phase and the
-	 * DSCL_MODE_SEL must be set to 1
-	 */
-	AUTOCAL_MODE_AUTOSCALE = 1,
-	/* Autocal perform auto centering without replication and the
-	 * DSCL_MODE_SEL must be set to 0
-	 */
-	AUTOCAL_MODE_AUTOCENTER = 2,
-	/* Autocal perform auto centering and auto replication and the
-	 * DSCL_MODE_SEL must be set to 0
-	 */
-	AUTOCAL_MODE_AUTOREPLICATE = 3
-};
-
-enum dscl_mode_sel {
-	DSCL_MODE_SCALING_444_BYPASS = 0,
-	DSCL_MODE_SCALING_444_RGB_ENABLE = 1,
-	DSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
-	DSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
-	DSCL_MODE_SCALING_420_LUMA_BYPASS = 4,
-	DSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
-	DSCL_MODE_DSCL_BYPASS = 6
-};
-
-static void dpp_set_overscan(
-	struct dcn10_dpp *xfm,
-	const struct scaler_data *data)
-{
-	uint32_t left = data->recout.x;
-	uint32_t top = data->recout.y;
-
-	int right = data->h_active - data->recout.x - data->recout.width;
-	int bottom = data->v_active - data->recout.y - data->recout.height;
-
-	if (right < 0) {
-		BREAK_TO_DEBUGGER();
-		right = 0;
-	}
-	if (bottom < 0) {
-		BREAK_TO_DEBUGGER();
-		bottom = 0;
-	}
-
-	REG_SET_2(DSCL_EXT_OVERSCAN_LEFT_RIGHT, 0,
-		EXT_OVERSCAN_LEFT, left,
-		EXT_OVERSCAN_RIGHT, right);
-
-	REG_SET_2(DSCL_EXT_OVERSCAN_TOP_BOTTOM, 0,
-		EXT_OVERSCAN_BOTTOM, bottom,
-		EXT_OVERSCAN_TOP, top);
-}
-
-static void dpp_set_otg_blank(
-		struct dcn10_dpp *xfm, const struct scaler_data *data)
-{
-	uint32_t h_blank_start = data->h_active;
-	uint32_t h_blank_end = 0;
-	uint32_t v_blank_start = data->v_active;
-	uint32_t v_blank_end = 0;
-
-	REG_SET_2(OTG_H_BLANK, 0,
-			OTG_H_BLANK_START, h_blank_start,
-			OTG_H_BLANK_END, h_blank_end);
-
-	REG_SET_2(OTG_V_BLANK, 0,
-			OTG_V_BLANK_START, v_blank_start,
-			OTG_V_BLANK_END, v_blank_end);
-}
-
-static int get_pixel_depth_val(enum lb_pixel_depth depth)
-{
-	if (depth == LB_PIXEL_DEPTH_30BPP)
-		return 0; /* 10 bpc */
-	else if (depth == LB_PIXEL_DEPTH_24BPP)
-		return 1; /* 8 bpc */
-	else if (depth == LB_PIXEL_DEPTH_18BPP)
-		return 2; /* 6 bpc */
-	else if (depth == LB_PIXEL_DEPTH_36BPP)
-		return 3; /* 12 bpc */
-	else {
-		ASSERT(0);
-		return -1; /* Unsupported */
-	}
-}
-
-static enum dscl_mode_sel get_dscl_mode(
-		const struct scaler_data *data, bool dbg_always_scale)
-{
-	const long long one = dal_fixed31_32_one.value;
-	bool ycbcr = false;
-	bool format420 = false;
-
-	if (data->format == PIXEL_FORMAT_FP16)
-		return DSCL_MODE_DSCL_BYPASS;
-
-	if (data->format >= PIXEL_FORMAT_VIDEO_BEGIN
-			&& data->format <= PIXEL_FORMAT_VIDEO_END)
-		ycbcr = true;
-
-	if (data->format == PIXEL_FORMAT_420BPP8 ||
-			data->format == PIXEL_FORMAT_420BPP10)
-		format420 = true;
-
-	if (data->ratios.horz.value == one
-			&& data->ratios.vert.value == one
-			&& data->ratios.horz_c.value == one
-			&& data->ratios.vert_c.value == one
-			&& !dbg_always_scale)
-		return DSCL_MODE_SCALING_444_BYPASS;
-
-	if (!format420) {
-		if (ycbcr)
-			return DSCL_MODE_SCALING_444_YCBCR_ENABLE;
-		else
-			return DSCL_MODE_SCALING_444_RGB_ENABLE;
-	}
-	if (data->ratios.horz.value == one && data->ratios.vert.value == one)
-		return DSCL_MODE_SCALING_420_LUMA_BYPASS;
-	if (data->ratios.horz_c.value == one && data->ratios.vert_c.value == one)
-		return DSCL_MODE_SCALING_420_CHROMA_BYPASS;
-
-	return DSCL_MODE_SCALING_420_YCBCR_ENABLE;
-}
-
-static void dpp_set_lb(
-	struct dcn10_dpp *xfm,
-	const struct line_buffer_params *lb_params,
-	enum lb_memory_config mem_size_config)
-{
-	uint32_t pixel_depth = get_pixel_depth_val(lb_params->depth);
-	uint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;
-
-	/* LB */
-	if (xfm->tf_mask->PIXEL_DEPTH) {
-		REG_SET_7(LB_DATA_FORMAT, 0,
-			PIXEL_DEPTH, pixel_depth, /* Pixel depth stored in LB */
-			PIXEL_EXPAN_MODE, lb_params->pixel_expan_mode, /* Pixel expansion mode */
-			PIXEL_REDUCE_MODE, 1, /* Pixel reduction mode: Rounding */
-			DYNAMIC_PIXEL_DEPTH, dyn_pix_depth, /* Dynamic expansion pixel depth */
-			DITHER_EN, 0, /* Dithering enable: Disabled */
-			INTERLEAVE_EN, lb_params->interleave_en, /* Interleave source enable */
-			LB_DATA_FORMAT__ALPHA_EN, lb_params->alpha_en); /* Alpha enable */
-	}
-
-	REG_SET_2(LB_MEMORY_CTRL, 0,
-		MEMORY_CONFIG, mem_size_config,
-		LB_MAX_PARTITIONS, 63);
-}
-
-static const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)
-{
-	if (taps == 8)
-		return get_filter_8tap_64p(ratio);
-	else if (taps == 7)
-		return get_filter_7tap_64p(ratio);
-	else if (taps == 6)
-		return get_filter_6tap_64p(ratio);
-	else if (taps == 5)
-		return get_filter_5tap_64p(ratio);
-	else if (taps == 4)
-		return get_filter_4tap_64p(ratio);
-	else if (taps == 3)
-		return get_filter_3tap_64p(ratio);
-	else if (taps == 2)
-		return filter_2tap_64p;
-	else if (taps == 1)
-		return NULL;
-	else {
-		/* should never happen, bug */
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-}
-
-static void dpp_set_scaler_filter(
-		struct dcn10_dpp *xfm,
-		uint32_t taps,
-		enum dcn10_coef_filter_type_sel filter_type,
-		const uint16_t *filter)
-{
-	const int tap_pairs = (taps + 1) / 2;
-	int phase;
-	int pair;
-	uint16_t odd_coef, even_coef;
-
-	REG_SET_3(SCL_COEF_RAM_TAP_SELECT, 0,
-		SCL_COEF_RAM_TAP_PAIR_IDX, 0,
-		SCL_COEF_RAM_PHASE, 0,
-		SCL_COEF_RAM_FILTER_TYPE, filter_type);
-
-	for (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {
-		for (pair = 0; pair < tap_pairs; pair++) {
-			even_coef = filter[phase * taps + 2 * pair];
-			if ((pair * 2 + 1) < taps)
-				odd_coef = filter[phase * taps + 2 * pair + 1];
-			else
-				odd_coef = 0;
-
-			REG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,
-				/* Even tap coefficient (bits 1:0 fixed to 0) */
-				SCL_COEF_RAM_EVEN_TAP_COEF, even_coef,
-				/* Write/read control for even coefficient */
-				SCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,
-				/* Odd tap coefficient (bits 1:0 fixed to 0) */
-				SCL_COEF_RAM_ODD_TAP_COEF, odd_coef,
-				/* Write/read control for odd coefficient */
-				SCL_COEF_RAM_ODD_TAP_COEF_EN, 1);
-		}
-	}
-
-}
-
-static void dpp_set_scl_filter(
-		struct dcn10_dpp *xfm,
-		const struct scaler_data *scl_data,
-		bool chroma_coef_mode)
-{
-	bool h_2tap_hardcode_coef_en = false;
-	bool v_2tap_hardcode_coef_en = false;
-	bool h_2tap_sharp_en = false;
-	bool v_2tap_sharp_en = false;
-	uint32_t h_2tap_sharp_factor = scl_data->sharpness.horz;
-	uint32_t v_2tap_sharp_factor = scl_data->sharpness.vert;
-	bool coef_ram_current;
-	const uint16_t *filter_h = NULL;
-	const uint16_t *filter_v = NULL;
-	const uint16_t *filter_h_c = NULL;
-	const uint16_t *filter_v_c = NULL;
-
-	h_2tap_hardcode_coef_en = scl_data->taps.h_taps < 3
-					&& scl_data->taps.h_taps_c < 3
-		&& (scl_data->taps.h_taps > 1 || scl_data->taps.h_taps_c > 1);
-	v_2tap_hardcode_coef_en = scl_data->taps.v_taps < 3
-					&& scl_data->taps.v_taps_c < 3
-		&& (scl_data->taps.v_taps > 1 || scl_data->taps.v_taps_c > 1);
-
-	h_2tap_sharp_en = h_2tap_hardcode_coef_en && h_2tap_sharp_factor != 0;
-	v_2tap_sharp_en = v_2tap_hardcode_coef_en && v_2tap_sharp_factor != 0;
-
-	REG_UPDATE_6(DSCL_2TAP_CONTROL,
-		SCL_H_2TAP_HARDCODE_COEF_EN, h_2tap_hardcode_coef_en,
-		SCL_H_2TAP_SHARP_EN, h_2tap_sharp_en,
-		SCL_H_2TAP_SHARP_FACTOR, h_2tap_sharp_factor,
-		SCL_V_2TAP_HARDCODE_COEF_EN, v_2tap_hardcode_coef_en,
-		SCL_V_2TAP_SHARP_EN, v_2tap_sharp_en,
-		SCL_V_2TAP_SHARP_FACTOR, v_2tap_sharp_factor);
-
-	if (!v_2tap_hardcode_coef_en || !h_2tap_hardcode_coef_en) {
-		bool filter_updated = false;
-
-		filter_h = get_filter_coeffs_64p(
-				scl_data->taps.h_taps, scl_data->ratios.horz);
-		filter_v = get_filter_coeffs_64p(
-				scl_data->taps.v_taps, scl_data->ratios.vert);
-
-		filter_updated = (filter_h && (filter_h != xfm->filter_h))
-				|| (filter_v && (filter_v != xfm->filter_v));
-
-		if (chroma_coef_mode) {
-			filter_h_c = get_filter_coeffs_64p(
-					scl_data->taps.h_taps_c, scl_data->ratios.horz_c);
-			filter_v_c = get_filter_coeffs_64p(
-					scl_data->taps.v_taps_c, scl_data->ratios.vert_c);
-			filter_updated = filter_updated || (filter_h_c && (filter_h_c != xfm->filter_h_c))
-							|| (filter_v_c && (filter_v_c != xfm->filter_v_c));
-		}
-
-		if (filter_updated) {
-			uint32_t scl_mode = REG_READ(SCL_MODE);
-
-			if (!h_2tap_hardcode_coef_en && filter_h) {
-				dpp_set_scaler_filter(
-					xfm, scl_data->taps.h_taps,
-					SCL_COEF_LUMA_HORZ_FILTER, filter_h);
-			}
-			xfm->filter_h = filter_h;
-			if (!v_2tap_hardcode_coef_en && filter_v) {
-				dpp_set_scaler_filter(
-					xfm, scl_data->taps.v_taps,
-					SCL_COEF_LUMA_VERT_FILTER, filter_v);
-			}
-			xfm->filter_v = filter_v;
-			if (chroma_coef_mode) {
-				if (!h_2tap_hardcode_coef_en && filter_h_c) {
-					dpp_set_scaler_filter(
-						xfm, scl_data->taps.h_taps_c,
-						SCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);
-				}
-				if (!v_2tap_hardcode_coef_en && filter_v_c) {
-					dpp_set_scaler_filter(
-						xfm, scl_data->taps.v_taps_c,
-						SCL_COEF_CHROMA_VERT_FILTER, filter_v_c);
-				}
-			}
-			xfm->filter_h_c = filter_h_c;
-			xfm->filter_v_c = filter_v_c;
-
-			coef_ram_current = get_reg_field_value_ex(
-				scl_mode, xfm->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
-				xfm->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
-
-			/* Swap coefficient RAM and set chroma coefficient mode */
-			REG_SET_2(SCL_MODE, scl_mode,
-					SCL_COEF_RAM_SELECT, !coef_ram_current,
-					SCL_CHROMA_COEF_MODE, chroma_coef_mode);
-		}
-	}
-}
-
-static int get_lb_depth_bpc(enum lb_pixel_depth depth)
-{
-	if (depth == LB_PIXEL_DEPTH_30BPP)
-		return 10;
-	else if (depth == LB_PIXEL_DEPTH_24BPP)
-		return 8;
-	else if (depth == LB_PIXEL_DEPTH_18BPP)
-		return 6;
-	else if (depth == LB_PIXEL_DEPTH_36BPP)
-		return 12;
-	else {
-		BREAK_TO_DEBUGGER();
-		return -1; /* Unsupported */
-	}
-}
-
-static void calc_lb_num_partitions(
-		const struct scaler_data *scl_data,
-		enum lb_memory_config lb_config,
-		int *num_part_y,
-		int *num_part_c)
-{
-	int line_size = scl_data->viewport.width < scl_data->recout.width ?
-			scl_data->viewport.width : scl_data->recout.width;
-	int line_size_c = scl_data->viewport_c.width < scl_data->recout.width ?
-			scl_data->viewport_c.width : scl_data->recout.width;
-	int lb_bpc = get_lb_depth_bpc(scl_data->lb_params.depth);
-	int memory_line_size_y = (line_size * lb_bpc + 71) / 72; /* +71 to ceil */
-	int memory_line_size_c = (line_size_c * lb_bpc + 71) / 72; /* +71 to ceil */
-	int memory_line_size_a = (line_size + 5) / 6; /* +5 to ceil */
-	int lb_memory_size, lb_memory_size_c, lb_memory_size_a, num_partitions_a;
-
-	if (lb_config == LB_MEMORY_CONFIG_1) {
-		lb_memory_size = 816;
-		lb_memory_size_c = 816;
-		lb_memory_size_a = 984;
-	} else if (lb_config == LB_MEMORY_CONFIG_2) {
-		lb_memory_size = 1088;
-		lb_memory_size_c = 1088;
-		lb_memory_size_a = 1312;
-	} else if (lb_config == LB_MEMORY_CONFIG_3) {
-		lb_memory_size = 816 + 1088 + 848 + 848 + 848;
-		lb_memory_size_c = 816 + 1088;
-		lb_memory_size_a = 984 + 1312 + 456;
-	} else {
-		lb_memory_size = 816 + 1088 + 848;
-		lb_memory_size_c = 816 + 1088 + 848;
-		lb_memory_size_a = 984 + 1312 + 456;
-	}
-	*num_part_y = lb_memory_size / memory_line_size_y;
-	*num_part_c = lb_memory_size_c / memory_line_size_c;
-	num_partitions_a = lb_memory_size_a / memory_line_size_a;
-
-	if (scl_data->lb_params.alpha_en
-			&& (num_partitions_a < *num_part_y))
-		*num_part_y = num_partitions_a;
-
-	if (*num_part_y > 64)
-		*num_part_y = 64;
-	if (*num_part_c > 64)
-		*num_part_c = 64;
-
-}
-
-static bool is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)
-{
-	if (ceil_vratio > 2)
-		return vtaps <= (num_partitions - ceil_vratio + 2);
-	else
-		return vtaps <= num_partitions;
-}
-
-/*find first match configuration which meets the min required lb size*/
-static enum lb_memory_config dpp10_find_lb_memory_config(
-		const struct scaler_data *scl_data)
-{
-	int num_part_y, num_part_c;
-	int vtaps = scl_data->taps.v_taps;
-	int vtaps_c = scl_data->taps.v_taps_c;
-	int ceil_vratio = dal_fixed31_32_ceil(scl_data->ratios.vert);
-	int ceil_vratio_c = dal_fixed31_32_ceil(scl_data->ratios.vert_c);
-
-	calc_lb_num_partitions(
-			scl_data, LB_MEMORY_CONFIG_1, &num_part_y, &num_part_c);
-
-	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
-		return LB_MEMORY_CONFIG_1;
-
-	calc_lb_num_partitions(
-			scl_data, LB_MEMORY_CONFIG_2, &num_part_y, &num_part_c);
-
-	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
-		return LB_MEMORY_CONFIG_2;
-
-	if (scl_data->format == PIXEL_FORMAT_420BPP8
-			|| scl_data->format == PIXEL_FORMAT_420BPP10) {
-		calc_lb_num_partitions(
-				scl_data, LB_MEMORY_CONFIG_3, &num_part_y, &num_part_c);
-
-		if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-				&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
-			return LB_MEMORY_CONFIG_3;
-	}
-
-	calc_lb_num_partitions(
-			scl_data, LB_MEMORY_CONFIG_0, &num_part_y, &num_part_c);
-
-	/*Ensure we can support the requested number of vtaps*/
-	ASSERT(is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c));
-
-	return LB_MEMORY_CONFIG_0;
-}
-
-/*find first match configuration which meets the min required lb size*/
-static enum lb_memory_config find_lb_memory_config(struct dcn10_dpp *xfm,
-		const struct scaler_data *scl_data)
-{
-	enum lb_memory_config mem_cfg = LB_MEMORY_CONFIG_0;
-
-	if (xfm->tf_mask->PIXEL_DEPTH) {
-		mem_cfg = dpp10_find_lb_memory_config(scl_data);
-	}
-	return mem_cfg;
-}
-
-void dpp_set_scaler_auto_scale(
-	struct transform *xfm_base,
-	const struct scaler_data *scl_data)
-{
-	enum lb_memory_config lb_config;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	enum dscl_mode_sel dscl_mode = get_dscl_mode(
-			scl_data, xfm_base->ctx->dc->debug.always_scale);
-	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
-				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
-
-	dpp_set_overscan(xfm, scl_data);
-
-	dpp_set_otg_blank(xfm, scl_data);
-
-	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
-
-	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
-		return;
-
-	lb_config =  find_lb_memory_config(xfm, scl_data);
-	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
-
-	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
-		return;
-
-	/* TODO: v_min */
-	REG_SET_3(DSCL_AUTOCAL, 0,
-		AUTOCAL_MODE, AUTOCAL_MODE_AUTOSCALE,
-		AUTOCAL_NUM_PIPE, 0,
-		AUTOCAL_PIPE_ID, 0);
-
-	/* Black offsets */
-	if (ycbcr)
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
-	else
-
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
-
-	REG_SET_4(SCL_TAP_CONTROL, 0,
-		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
-		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
-		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
-		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
-
-	dpp_set_scl_filter(xfm, scl_data, ycbcr);
-}
-
-
-static void dpp_set_manual_ratio_init(
-		struct dcn10_dpp *xfm, const struct scaler_data *data)
-{
-	uint32_t init_frac = 0;
-	uint32_t init_int = 0;
-
-	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,
-			SCL_H_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.horz) << 5);
-
-	REG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,
-			SCL_V_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.vert) << 5);
-
-	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO_C, 0,
-			SCL_H_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.horz_c) << 5);
-
-	REG_SET(SCL_VERT_FILTER_SCALE_RATIO_C, 0,
-			SCL_V_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.vert_c) << 5);
-
-	/*
-	 * 0.24 format for fraction, first five bits zeroed
-	 */
-	init_frac = dal_fixed31_32_u0d19(data->inits.h) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.h);
-	REG_SET_2(SCL_HORZ_FILTER_INIT, 0,
-		SCL_H_INIT_FRAC, init_frac,
-		SCL_H_INIT_INT, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.h_c) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.h_c);
-	REG_SET_2(SCL_HORZ_FILTER_INIT_C, 0,
-		SCL_H_INIT_FRAC_C, init_frac,
-		SCL_H_INIT_INT_C, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v);
-	REG_SET_2(SCL_VERT_FILTER_INIT, 0,
-		SCL_V_INIT_FRAC, init_frac,
-		SCL_V_INIT_INT, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v_bot) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v_bot);
-	REG_SET_2(SCL_VERT_FILTER_INIT_BOT, 0,
-		SCL_V_INIT_FRAC_BOT, init_frac,
-		SCL_V_INIT_INT_BOT, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v_c) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v_c);
-	REG_SET_2(SCL_VERT_FILTER_INIT_C, 0,
-		SCL_V_INIT_FRAC_C, init_frac,
-		SCL_V_INIT_INT_C, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v_c_bot) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v_c_bot);
-	REG_SET_2(SCL_VERT_FILTER_INIT_BOT_C, 0,
-		SCL_V_INIT_FRAC_BOT_C, init_frac,
-		SCL_V_INIT_INT_BOT_C, init_int);
-}
-
-
-
-static void dpp_set_recout(
-			struct dcn10_dpp *xfm, const struct rect *recout)
-{
-	REG_SET_2(RECOUT_START, 0,
-		/* First pixel of RECOUT */
-			 RECOUT_START_X, recout->x,
-		/* First line of RECOUT */
-			 RECOUT_START_Y, recout->y);
-
-	REG_SET_2(RECOUT_SIZE, 0,
-		/* Number of RECOUT horizontal pixels */
-			 RECOUT_WIDTH, recout->width,
-		/* Number of RECOUT vertical lines */
-			 RECOUT_HEIGHT, recout->height
-			 - xfm->base.ctx->dc->debug.surface_visual_confirm * 4 *
-			 (xfm->base.inst + 1));
-}
-
-/* Main function to program scaler and line buffer in manual scaling mode */
-void dcn10_dpp_dscl_set_scaler_manual_scale(
-	struct transform *xfm_base,
-	const struct scaler_data *scl_data)
-{
-	enum lb_memory_config lb_config;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	enum dscl_mode_sel dscl_mode = get_dscl_mode(
-			scl_data, xfm_base->ctx->dc->debug.always_scale);
-	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
-				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
-
-	/* Recout */
-	dpp_set_recout(xfm, &scl_data->recout);
-
-	/* MPC Size */
-	REG_SET_2(MPC_SIZE, 0,
-		/* Number of horizontal pixels of MPC */
-			 MPC_WIDTH, scl_data->h_active,
-		/* Number of vertical lines of MPC */
-			 MPC_HEIGHT, scl_data->v_active);
-
-	/* SCL mode */
-	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
-
-	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
-		return;
-
-	/* LB */
-	lb_config =  find_lb_memory_config(xfm, scl_data);
-	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
-
-	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
-		return;
-
-	/* Autocal off */
-	REG_SET_3(DSCL_AUTOCAL, 0,
-		AUTOCAL_MODE, AUTOCAL_MODE_OFF,
-		AUTOCAL_NUM_PIPE, 0,
-		AUTOCAL_PIPE_ID, 0);
-
-	/* Black offsets */
-	if (ycbcr)
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
-	else
-
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
-
-	/* Manually calculate scale ratio and init values */
-	dpp_set_manual_ratio_init(xfm, scl_data);
-
-	/* HTaps/VTaps */
-	REG_SET_4(SCL_TAP_CONTROL, 0,
-		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
-		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
-		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
-		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
-
-	dpp_set_scl_filter(xfm, scl_data, ycbcr);
-}
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.c
deleted file mode 100644
index 684241c..0000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.c
+++ /dev/null
@@ -1,651 +0,0 @@
-/*
- * Copyright 2012-17 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-
-#include "reg_helper.h"
-#include "resource.h"
-#include "dwb.h"
-#include "dcn10_dwb.h"
-#include "vega10/soc15ip.h"
-#include "raven1/DCN/dcn_1_0_offset.h"
-#include "raven1/DCN/dcn_1_0_sh_mask.h"
-
-/* DCN */
-#define BASE_INNER(seg) \
-	DCE_BASE__INST0_SEG ## seg
-
-#define BASE(seg) \
-	BASE_INNER(seg)
-
-#define SR(reg_name)\
-		.reg_name = BASE(mm ## reg_name ## _BASE_IDX) +  \
-					mm ## reg_name
-
-#define SRI(reg_name, block, id)\
-	.reg_name = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \
-					mm ## block ## id ## _ ## reg_name
-
-
-#define SRII(reg_name, block, id)\
-	.reg_name[id] = BASE(mm ## block ## id ## _ ## reg_name ## _BASE_IDX) + \
-					mm ## block ## id ## _ ## reg_name
-
-#define SF(reg_name, field_name, post_fix)\
-	.field_name = reg_name ## __ ## field_name ## post_fix
-
-#define REG(reg)\
-	dwbc10->dwbc_regs->reg
-
-#define CTX \
-	dwbc10->base.ctx
-
-#undef FN
-#define FN(reg_name, field_name) \
-	dwbc10->dwbc_shift->field_name, dwbc10->dwbc_mask->field_name
-
-#define TO_DCN10_DWBC(dwbc_base) \
-	container_of(dwbc_base, struct dcn10_dwbc, base)
-
-#define DWBC_COMMON_REG_LIST_DCN1_0(inst) \
-	SRI(WB_ENABLE, CNV, inst),\
-	SRI(WB_EC_CONFIG, CNV, inst),\
-	SRI(CNV_MODE, CNV, inst),\
-	SRI(WB_SOFT_RESET, CNV, inst),\
-	SRI(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_PITCH, MCIF_WB, inst),\
-	SRI(MCIF_WB_ARBITRATION_CONTROL, MCIF_WB, inst),\
-	SRI(MCIF_WB_SCLK_CHANGE, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_1_ADDR_Y, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_1_ADDR_Y_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_1_ADDR_C, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_1_ADDR_C_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_2_ADDR_Y, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_2_ADDR_Y_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_2_ADDR_C, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_2_ADDR_C_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_3_ADDR_Y, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_3_ADDR_Y_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_3_ADDR_C, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_3_ADDR_C_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_4_ADDR_Y, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_4_ADDR_Y_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_4_ADDR_C, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_4_ADDR_C_OFFSET, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB, inst),\
-	SRI(MCIF_WB_NB_PSTATE_LATENCY_WATERMARK, MCIF_WB, inst),\
-	SRI(MCIF_WB_NB_PSTATE_CONTROL, MCIF_WB, inst),\
-	SRI(MCIF_WB_WATERMARK, MCIF_WB, inst),\
-	SRI(MCIF_WB_WARM_UP_CNTL, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_LUMA_SIZE, MCIF_WB, inst),\
-	SRI(MCIF_WB_BUF_CHROMA_SIZE, MCIF_WB, inst),\
-	.DWB_SOURCE_SELECT = mmDWB_SOURCE_SELECT\
-
-#define DWBC_COMMON_MASK_SH_LIST_DCN1_0(mask_sh) \
-	SF(CNV0_WB_ENABLE, WB_ENABLE, mask_sh),\
-	SF(CNV0_WB_EC_CONFIG, DISPCLK_R_WB_GATE_DIS, mask_sh),\
-	SF(CNV0_WB_EC_CONFIG, DISPCLK_G_WB_GATE_DIS, mask_sh),\
-	SF(CNV0_WB_EC_CONFIG, DISPCLK_G_WBSCL_GATE_DIS, mask_sh),\
-	SF(CNV0_WB_EC_CONFIG, WB_LB_LS_DIS, mask_sh),\
-	SF(CNV0_WB_EC_CONFIG, WB_LUT_LS_DIS, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_WINDOW_CROP_EN, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_STEREO_TYPE, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_INTERLACED_MODE, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_EYE_SELECTION, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_STEREO_POLARITY, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_INTERLACED_FIELD_ORDER, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_STEREO_SPLIT, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_NEW_CONTENT, mask_sh),\
-	SF(CNV0_CNV_MODE, CNV_FRAME_CAPTURE_EN, mask_sh),\
-	SF(CNV0_WB_SOFT_RESET, WB_SOFT_RESET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_ENABLE, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUF_DUALSIZE_REQ, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_INT_EN, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_INT_ACK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_SLICE_INT_EN, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_OVERRUN_INT_EN, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_LOCK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_P_VMID, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUF_ADDR_FENCE_EN, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_PITCH, MCIF_WB_BUF_LUMA_PITCH, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_PITCH, MCIF_WB_BUF_CHROMA_PITCH, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_ARBITRATION_CONTROL, MCIF_WB_CLIENT_ARBITRATION_SLICE, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_ARBITRATION_CONTROL, MCIF_WB_TIME_PER_PIXEL, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_SCLK_CHANGE, WM_CHANGE_ACK_FORCE_ON, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_SCLK_CHANGE, MCIF_WB_CLI_WATERMARK_MASK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_1_ADDR_Y, MCIF_WB_BUF_1_ADDR_Y, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_1_ADDR_Y_OFFSET, MCIF_WB_BUF_1_ADDR_Y_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_1_ADDR_C, MCIF_WB_BUF_1_ADDR_C, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_1_ADDR_C_OFFSET, MCIF_WB_BUF_1_ADDR_C_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_2_ADDR_Y, MCIF_WB_BUF_2_ADDR_Y, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_2_ADDR_Y_OFFSET, MCIF_WB_BUF_2_ADDR_Y_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_2_ADDR_C, MCIF_WB_BUF_2_ADDR_C, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_2_ADDR_C_OFFSET, MCIF_WB_BUF_2_ADDR_C_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_3_ADDR_Y, MCIF_WB_BUF_3_ADDR_Y, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_3_ADDR_Y_OFFSET, MCIF_WB_BUF_3_ADDR_Y_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_3_ADDR_C, MCIF_WB_BUF_3_ADDR_C, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_3_ADDR_C_OFFSET, MCIF_WB_BUF_3_ADDR_C_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_4_ADDR_Y, MCIF_WB_BUF_4_ADDR_Y, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_4_ADDR_Y_OFFSET, MCIF_WB_BUF_4_ADDR_Y_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_4_ADDR_C, MCIF_WB_BUF_4_ADDR_C, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_4_ADDR_C_OFFSET, MCIF_WB_BUF_4_ADDR_C_OFFSET, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_LOCK_IGNORE, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_INT_EN, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_INT_ACK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_SLICE_INT_EN, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_LOCK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_SLICE_SIZE, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_NB_PSTATE_LATENCY_WATERMARK, NB_PSTATE_CHANGE_REFRESH_WATERMARK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_URGENT_DURING_REQUEST, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_FORCE_ON, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_ALLOW_FOR_URGENT, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_WATERMARK_MASK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_WATERMARK, MCIF_WB_CLI_WATERMARK, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_WARM_UP_CNTL, MCIF_WB_PITCH_SIZE_WARMUP, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_LUMA_SIZE, MCIF_WB_BUF_LUMA_SIZE, mask_sh),\
-	SF(MCIF_WB0_MCIF_WB_BUF_CHROMA_SIZE, MCIF_WB_BUF_CHROMA_SIZE, mask_sh),\
-	SF(DWB_SOURCE_SELECT, OPTC_DWB0_SOURCE_SELECT, mask_sh),\
-	SF(DWB_SOURCE_SELECT, OPTC_DWB1_SOURCE_SELECT, mask_sh)
-
-#define DWBC_REG_FIELD_LIST(type) \
-	type WB_ENABLE;\
-	type DISPCLK_R_WB_GATE_DIS;\
-	type DISPCLK_G_WB_GATE_DIS;\
-	type DISPCLK_G_WBSCL_GATE_DIS;\
-	type WB_LB_LS_DIS;\
-	type WB_LB_SD_DIS;\
-	type WB_LUT_LS_DIS;\
-	type CNV_WINDOW_CROP_EN;\
-	type CNV_STEREO_TYPE;\
-	type CNV_INTERLACED_MODE;\
-	type CNV_EYE_SELECTION;\
-	type CNV_STEREO_POLARITY;\
-	type CNV_INTERLACED_FIELD_ORDER;\
-	type CNV_STEREO_SPLIT;\
-	type CNV_NEW_CONTENT;\
-	type CNV_FRAME_CAPTURE_EN;\
-	type WB_SOFT_RESET;\
-	type MCIF_WB_BUFMGR_ENABLE;\
-	type MCIF_WB_BUF_DUALSIZE_REQ;\
-	type MCIF_WB_BUFMGR_SW_INT_EN;\
-	type MCIF_WB_BUFMGR_SW_INT_ACK;\
-	type MCIF_WB_BUFMGR_SW_SLICE_INT_EN;\
-	type MCIF_WB_BUFMGR_SW_OVERRUN_INT_EN;\
-	type MCIF_WB_BUFMGR_SW_LOCK;\
-	type MCIF_WB_P_VMID;\
-	type MCIF_WB_BUF_ADDR_FENCE_EN;\
-	type MCIF_WB_BUF_LUMA_PITCH;\
-	type MCIF_WB_BUF_CHROMA_PITCH;\
-	type MCIF_WB_CLIENT_ARBITRATION_SLICE;\
-	type MCIF_WB_TIME_PER_PIXEL;\
-	type WM_CHANGE_ACK_FORCE_ON;\
-	type MCIF_WB_CLI_WATERMARK_MASK;\
-	type MCIF_WB_BUF_1_ADDR_Y;\
-	type MCIF_WB_BUF_1_ADDR_Y_OFFSET;\
-	type MCIF_WB_BUF_1_ADDR_C;\
-	type MCIF_WB_BUF_1_ADDR_C_OFFSET;\
-	type MCIF_WB_BUF_2_ADDR_Y;\
-	type MCIF_WB_BUF_2_ADDR_Y_OFFSET;\
-	type MCIF_WB_BUF_2_ADDR_C;\
-	type MCIF_WB_BUF_2_ADDR_C_OFFSET;\
-	type MCIF_WB_BUF_3_ADDR_Y;\
-	type MCIF_WB_BUF_3_ADDR_Y_OFFSET;\
-	type MCIF_WB_BUF_3_ADDR_C;\
-	type MCIF_WB_BUF_3_ADDR_C_OFFSET;\
-	type MCIF_WB_BUF_4_ADDR_Y;\
-	type MCIF_WB_BUF_4_ADDR_Y_OFFSET;\
-	type MCIF_WB_BUF_4_ADDR_C;\
-	type MCIF_WB_BUF_4_ADDR_C_OFFSET;\
-	type MCIF_WB_BUFMGR_VCE_LOCK_IGNORE;\
-	type MCIF_WB_BUFMGR_VCE_INT_EN;\
-	type MCIF_WB_BUFMGR_VCE_INT_ACK;\
-	type MCIF_WB_BUFMGR_VCE_SLICE_INT_EN;\
-	type MCIF_WB_BUFMGR_VCE_LOCK;\
-	type MCIF_WB_BUFMGR_SLICE_SIZE;\
-	type NB_PSTATE_CHANGE_REFRESH_WATERMARK;\
-	type NB_PSTATE_CHANGE_URGENT_DURING_REQUEST;\
-	type NB_PSTATE_CHANGE_FORCE_ON;\
-	type NB_PSTATE_ALLOW_FOR_URGENT;\
-	type NB_PSTATE_CHANGE_WATERMARK_MASK;\
-	type MCIF_WB_CLI_WATERMARK;\
-	type MCIF_WB_CLI_CLOCK_GATER_OVERRIDE;\
-	type MCIF_WB_PITCH_SIZE_WARMUP;\
-	type MCIF_WB_BUF_LUMA_SIZE;\
-	type MCIF_WB_BUF_CHROMA_SIZE;\
-	type OPTC_DWB0_SOURCE_SELECT;\
-	type OPTC_DWB1_SOURCE_SELECT;\
-
-struct dcn10_dwbc_registers {
-	uint32_t WB_ENABLE;
-	uint32_t WB_EC_CONFIG;
-	uint32_t CNV_MODE;
-	uint32_t WB_SOFT_RESET;
-	uint32_t MCIF_WB_BUFMGR_SW_CONTROL;
-	uint32_t MCIF_WB_BUF_PITCH;
-	uint32_t MCIF_WB_ARBITRATION_CONTROL;
-	uint32_t MCIF_WB_SCLK_CHANGE;
-	uint32_t MCIF_WB_BUF_1_ADDR_Y;
-	uint32_t MCIF_WB_BUF_1_ADDR_Y_OFFSET;
-	uint32_t MCIF_WB_BUF_1_ADDR_C;
-	uint32_t MCIF_WB_BUF_1_ADDR_C_OFFSET;
-	uint32_t MCIF_WB_BUF_2_ADDR_Y;
-	uint32_t MCIF_WB_BUF_2_ADDR_Y_OFFSET;
-	uint32_t MCIF_WB_BUF_2_ADDR_C;
-	uint32_t MCIF_WB_BUF_2_ADDR_C_OFFSET;
-	uint32_t MCIF_WB_BUF_3_ADDR_Y;
-	uint32_t MCIF_WB_BUF_3_ADDR_Y_OFFSET;
-	uint32_t MCIF_WB_BUF_3_ADDR_C;
-	uint32_t MCIF_WB_BUF_3_ADDR_C_OFFSET;
-	uint32_t MCIF_WB_BUF_4_ADDR_Y;
-	uint32_t MCIF_WB_BUF_4_ADDR_Y_OFFSET;
-	uint32_t MCIF_WB_BUF_4_ADDR_C;
-	uint32_t MCIF_WB_BUF_4_ADDR_C_OFFSET;
-	uint32_t MCIF_WB_BUFMGR_VCE_CONTROL;
-	uint32_t MCIF_WB_NB_PSTATE_LATENCY_WATERMARK;
-	uint32_t MCIF_WB_NB_PSTATE_CONTROL;
-	uint32_t MCIF_WB_WATERMARK;
-	uint32_t MCIF_WB_WARM_UP_CNTL;
-	uint32_t MCIF_WB_BUF_LUMA_SIZE;
-	uint32_t MCIF_WB_BUF_CHROMA_SIZE;
-	uint32_t DWB_SOURCE_SELECT;
-};
-struct dcn10_dwbc_mask {
-	DWBC_REG_FIELD_LIST(uint32_t)
-};
-struct dcn10_dwbc_shift {
-	DWBC_REG_FIELD_LIST(uint8_t)
-};
-struct dcn10_dwbc {
-	struct dwbc base;
-	const struct dcn10_dwbc_registers *dwbc_regs;
-	const struct dcn10_dwbc_shift *dwbc_shift;
-	const struct dcn10_dwbc_mask *dwbc_mask;
-};
-
-#define dwbc_regs(id)\
-[id] = {\
-	DWBC_COMMON_REG_LIST_DCN1_0(id),\
-}
-
-static const struct dcn10_dwbc_registers dwbc10_regs[] = {
-	dwbc_regs(0),
-	dwbc_regs(1),
-};
-
-static const struct dcn10_dwbc_shift dwbc10_shift = {
-	DWBC_COMMON_MASK_SH_LIST_DCN1_0(__SHIFT)
-};
-
-static const struct dcn10_dwbc_mask dwbc10_mask = {
-	DWBC_COMMON_MASK_SH_LIST_DCN1_0(_MASK)
-};
-
-
-static bool get_caps(struct dwbc *dwbc, struct dwb_caps *caps)
-{
-	if (caps) {
-		caps->adapter_id = 0;	/* we only support 1 adapter currently */
-		caps->hw_version = DCN_VERSION_1_0;
-		caps->num_pipes = 2;
-		memset(&caps->reserved, 0, sizeof(caps->reserved));
-		memset(&caps->reserved2, 0, sizeof(caps->reserved2));
-		caps->sw_version = dwb_ver_1_0;
-		caps->caps.support_dwb = true;
-		caps->caps.support_ogam = false;
-		caps->caps.support_wbscl = true;
-		caps->caps.support_ocsc = false;
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool enable(struct dwbc *dwbc)
-{
-	struct dcn10_dwbc *dwbc10 = TO_DCN10_DWBC(dwbc);
-
-	/* disable first. */
-	dwbc->funcs->disable(dwbc);
-
-	/* disable power gating */
-	REG_UPDATE_5(WB_EC_CONFIG, DISPCLK_R_WB_GATE_DIS, 1,
-				 DISPCLK_G_WB_GATE_DIS, 1, DISPCLK_G_WBSCL_GATE_DIS, 1,
-				 WB_LB_LS_DIS, 1, WB_LUT_LS_DIS, 1);
-
-	REG_UPDATE(WB_ENABLE, WB_ENABLE, 1);
-
-	/* lock buffer0~buffer3 */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_LOCK, 0xf);
-
-	/* buffer address for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_1_ADDR_Y, MCIF_WB_BUF_1_ADDR_Y, (dwbc->config.basic_settings.luma_address[0] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_1_ADDR_Y_HIGH, MCIF_WB_BUF_1_ADDR_Y_HIGH, (dwbc->config.basic_settings.luma_address[0] >> 32)); */
-	/* right eye sub-buffer address offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_1_ADDR_Y_OFFSET, MCIF_WB_BUF_1_ADDR_Y_OFFSET, 0);
-
-	/* buffer address for Chroma in planar mode (unused in packing mode) */
-	REG_UPDATE(MCIF_WB_BUF_1_ADDR_C, MCIF_WB_BUF_1_ADDR_C, (dwbc->config.basic_settings.chroma_address[0] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_1_ADDR_C_HIGH, MCIF_WB_BUF_1_ADDR_C_HIGH, (dwbc->config.basic_settings.chroma_address[0] >> 32)); */
-	/* right eye offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_1_ADDR_C_OFFSET, MCIF_WB_BUF_1_ADDR_C_OFFSET, 0);
-
-	/* buffer address for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_2_ADDR_Y, MCIF_WB_BUF_2_ADDR_Y, (dwbc->config.basic_settings.luma_address[1] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_2_ADDR_Y_HIGH, MCIF_WB_BUF_2_ADDR_Y_HIGH, (dwbc->config.basic_settings.luma_address[1] >> 32)); */
-	/* right eye sub-buffer address offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_2_ADDR_Y_OFFSET, MCIF_WB_BUF_2_ADDR_Y_OFFSET, 0);
-
-	/* buffer address for Chroma in planar mode (unused in packing mode) */
-	REG_UPDATE(MCIF_WB_BUF_2_ADDR_C, MCIF_WB_BUF_2_ADDR_C, (dwbc->config.basic_settings.chroma_address[1] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_2_ADDR_C_HIGH, MCIF_WB_BUF_2_ADDR_C_HIGH, (dwbc->config.basic_settings.chroma_address[1] >> 32)); */
-	/* right eye offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_2_ADDR_C_OFFSET, MCIF_WB_BUF_2_ADDR_C_OFFSET, 0);
-
-	/* buffer address for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_3_ADDR_Y, MCIF_WB_BUF_3_ADDR_Y, (dwbc->config.basic_settings.luma_address[2] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_3_ADDR_Y_HIGH, MCIF_WB_BUF_3_ADDR_Y_HIGH, (dwbc->config.basic_settings.luma_address[2] >> 32)); */
-	/* right eye sub-buffer address offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_3_ADDR_Y_OFFSET, MCIF_WB_BUF_3_ADDR_Y_OFFSET, 0);
-
-	/* buffer address for Chroma in planar mode (unused in packing mode) */
-	REG_UPDATE(MCIF_WB_BUF_3_ADDR_C, MCIF_WB_BUF_3_ADDR_C, (dwbc->config.basic_settings.chroma_address[2] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_3_ADDR_C_HIGH, MCIF_WB_BUF_3_ADDR_C_HIGH, (dwbc->config.basic_settings.chroma_address[2] >> 32)); */
-	/* right eye offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_3_ADDR_C_OFFSET, MCIF_WB_BUF_3_ADDR_C_OFFSET, 0);
-
-	/* buffer address for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_4_ADDR_Y, MCIF_WB_BUF_4_ADDR_Y, (dwbc->config.basic_settings.luma_address[3] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_4_ADDR_Y_HIGH, MCIF_WB_BUF_4_ADDR_Y_HIGH, (dwbc->config.basic_settings.luma_address[3] >> 32)); */
-	/* right eye sub-buffer address offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_4_ADDR_Y_OFFSET, MCIF_WB_BUF_4_ADDR_Y_OFFSET, 0);
-
-	/* buffer address for Chroma in planar mode (unused in packing mode) */
-	REG_UPDATE(MCIF_WB_BUF_4_ADDR_C, MCIF_WB_BUF_4_ADDR_C, (dwbc->config.basic_settings.chroma_address[3] & 0xffffffff));
-/* 	REG_UPDATE(MCIF_WB_BUF_4_ADDR_C_HIGH, MCIF_WB_BUF_4_ADDR_C_HIGH, (dwbc->config.basic_settings.chroma_address[3] >> 32)); */
-	/* right eye offset for packing mode or Luma in planar mode */
-	REG_UPDATE(MCIF_WB_BUF_4_ADDR_C_OFFSET, MCIF_WB_BUF_4_ADDR_C_OFFSET, 0);
-
-	/* setup luma & chroma size */
-	REG_UPDATE(MCIF_WB_BUF_LUMA_SIZE, MCIF_WB_BUF_LUMA_SIZE, dwbc->config.basic_settings.luma_pitch * dwbc->config.basic_settings.dest_height);	/* should be enough to contain a whole frame Luma data, same for stereo mode */
-	REG_UPDATE(MCIF_WB_BUF_CHROMA_SIZE, MCIF_WB_BUF_CHROMA_SIZE, dwbc->config.basic_settings.chroma_pitch * dwbc->config.basic_settings.dest_height);	/* should be enough to contain a whole frame Luma data, same for stereo mode */
-
-	/* enable address fence */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUF_ADDR_FENCE_EN, 1);
-
-	/* setup pitch */
-	REG_UPDATE_2(MCIF_WB_BUF_PITCH, MCIF_WB_BUF_LUMA_PITCH, dwbc->config.basic_settings.luma_pitch,
-				 MCIF_WB_BUF_CHROMA_PITCH, dwbc->config.basic_settings.chroma_pitch);
-
-	/* Set pitch for MC cache warm up mode */
-	/* Pitch is 256 bytes aligned. The default pitch is 4K */
-	REG_UPDATE(MCIF_WB_WARM_UP_CNTL, MCIF_WB_PITCH_SIZE_WARMUP, 0x10);	/* default is 0x10 */
-
-	/* Programmed by the video driver based on the CRTC timing (for DWB) */
-	REG_UPDATE(MCIF_WB_ARBITRATION_CONTROL, MCIF_WB_TIME_PER_PIXEL, 0);
-
-	/* Programming dwb watermark */
-	/* Watermark to generate urgent in MCIF_WB_CLI, value is determined by MCIF_WB_CLI_WATERMARK_MASK. */
-	/* Program in ns. A formula will be provided in the pseudo code to calculate the value. */
-	REG_UPDATE(MCIF_WB_SCLK_CHANGE, MCIF_WB_CLI_WATERMARK_MASK, 0x0);
-	REG_UPDATE(MCIF_WB_WATERMARK, MCIF_WB_CLI_WATERMARK, 0xffff);	/* urgent_watermarkA */
-	REG_UPDATE(MCIF_WB_SCLK_CHANGE, MCIF_WB_CLI_WATERMARK_MASK, 0x1);
-	REG_UPDATE(MCIF_WB_WATERMARK, MCIF_WB_CLI_WATERMARK, 0xffff);	/* urgent_watermarkB */
-	REG_UPDATE(MCIF_WB_SCLK_CHANGE, MCIF_WB_CLI_WATERMARK_MASK, 0x2);
-	REG_UPDATE(MCIF_WB_WATERMARK, MCIF_WB_CLI_WATERMARK, 0xffff);	/* urgent_watermarkC */
-	REG_UPDATE(MCIF_WB_SCLK_CHANGE, MCIF_WB_CLI_WATERMARK_MASK, 0x3);
-	REG_UPDATE(MCIF_WB_WATERMARK, MCIF_WB_CLI_WATERMARK, 0xffff);	/* urgent_watermarkD */
-
-	/* Programming nb pstate watermark */
-	REG_UPDATE(MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_WATERMARK_MASK, 0x0);
-	REG_UPDATE(MCIF_WB_NB_PSTATE_LATENCY_WATERMARK, NB_PSTATE_CHANGE_REFRESH_WATERMARK, 0xffff);	/* nbp_state_change_watermarkA */
-	REG_UPDATE(MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_WATERMARK_MASK, 0x1);
-	REG_UPDATE(MCIF_WB_NB_PSTATE_LATENCY_WATERMARK, NB_PSTATE_CHANGE_REFRESH_WATERMARK, 0xffff);	/* nbp_state_change_watermarkB */
-	REG_UPDATE(MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_WATERMARK_MASK, 0x2);
-	REG_UPDATE(MCIF_WB_NB_PSTATE_LATENCY_WATERMARK, NB_PSTATE_CHANGE_REFRESH_WATERMARK, 0xffff);	/* nbp_state_change_watermarkC */
-	REG_UPDATE(MCIF_WB_NB_PSTATE_CONTROL, NB_PSTATE_CHANGE_WATERMARK_MASK, 0x3);
-	REG_UPDATE(MCIF_WB_NB_PSTATE_LATENCY_WATERMARK, NB_PSTATE_CHANGE_REFRESH_WATERMARK, 0xffff);	/* nbp_state_change_watermarkD */
-
-	/* buf_lh_capability = (buffer_size / byte_per_pixel)*time_per_pixel;   //client buffer latency hiding capability */
-	/* if (MCIF_WB_CLI_WATERMARK * 2 < buf_lh_capability)  //factor '2' can be adjusted if better value is identified during bringup/debug */
-	/* 	MULTI_LEVEL_QOS_CTRL.MAX_SCALED_TIME_TO_URGENT = MCIF_WB_CLI_WATERMARK * 2; */
-	/* else */
-	/* 	MULTI_LEVEL_QOS_CTRL.MAX_SCALED_TIME_TO_URGENT = buf_lh_capability;   //ensure QoS can be fully mapped to [0:15] region in any scenario */
-
-	REG_UPDATE(MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_SLICE_SIZE, 31);
-
-	/* Set arbitration unit for Luma/Chroma */
-	/* arb_unit=2 should be chosen for more efficiency */
-	REG_UPDATE(MCIF_WB_ARBITRATION_CONTROL, MCIF_WB_CLIENT_ARBITRATION_SLICE, 2);	/* Arbitration size, 0: 512 bytes 1: 1024 bytes 2: 2048 Bytes */
-
-	/* Program VMID, don't support virtual mode, won't set VMID */
-	/* REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_P_VMID, pVmid); */
-
-	if (dwbc->config.basic_settings.input_pipe_select == dwb_pipe0) {
-		REG_UPDATE(DWB_SOURCE_SELECT, OPTC_DWB0_SOURCE_SELECT, dwbc->config.basic_settings.input_src_select - dwb_src_otg0);
-	} else if (dwbc->config.basic_settings.input_pipe_select == dwb_pipe1) {
-		REG_UPDATE(DWB_SOURCE_SELECT, OPTC_DWB1_SOURCE_SELECT, dwbc->config.basic_settings.input_src_select - dwb_src_otg0);
-	}
-
-	/* Set interrupt mask */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_INT_EN, 0);   /* Disable interrupt to SW. (the default value is 0.) */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_SLICE_INT_EN, 0);   /* Disable slice complete interrupt to SW.(the default value is 0.) */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_OVERRUN_INT_EN, 0);   /* Disable frame buffer overrun interrupt to SW. (the default value is 0.) */
-
-	REG_UPDATE(MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_INT_EN, 1);   /* Enable interrupt to VCE */
-	REG_UPDATE(MCIF_WB_BUFMGR_VCE_CONTROL, MCIF_WB_BUFMGR_VCE_SLICE_INT_EN, 0);   /* Disable slice complete interrupt to VCE. */
-
-	/* ////////////////// */
-	/* Enable Mcifwb */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_ENABLE, 1);			  /* Start working */
-
-	/* unlock sw lock. */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_LOCK, 0);
-
-	dwbc->status.enabled = true;
-
-	return true;
-}
-
-static bool disable(struct dwbc *dwbc)
-{
-	struct dcn10_dwbc *dwbc10 = TO_DCN10_DWBC(dwbc);
-
-	/* disable CNV */
-	REG_UPDATE(CNV_MODE, CNV_FRAME_CAPTURE_EN, 0);
-
-	/* disable WB */
-	REG_UPDATE(WB_ENABLE, WB_ENABLE, 0);
-
-	/* soft reset */
-	REG_UPDATE(WB_SOFT_RESET, WB_SOFT_RESET, 1);
-	REG_UPDATE(WB_SOFT_RESET, WB_SOFT_RESET, 0);
-
-	/* enable power gating */
-	REG_UPDATE_5(WB_EC_CONFIG, DISPCLK_R_WB_GATE_DIS, 0,
-				 DISPCLK_G_WB_GATE_DIS, 0, DISPCLK_G_WBSCL_GATE_DIS, 0,
-				 WB_LB_LS_DIS, 0, WB_LUT_LS_DIS, 0);
-
-	/* disable buffer manager */
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_ENABLE, 0);
-
-	dwbc->status.enabled = false;
-
-	return true;
-}
-
-static bool get_status(struct dwbc *dwbc, struct dwb_status *status)
-{
-	if (status) {
-		memcpy(status, &dwbc->status, sizeof(struct dwb_status));
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool dump_frame(struct dwbc *dwbc, struct dwb_frame_info *frame_info,
-					   unsigned char *luma_buffer, unsigned char *chroma_buffer,
-					   unsigned char *dest_luma_buffer, unsigned char *dest_chroma_buffer)
-{
-	struct dcn10_dwbc *dwbc10 = TO_DCN10_DWBC(dwbc);
-
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_LOCK, 0xf);
-
-	memcpy(dest_luma_buffer, luma_buffer, dwbc->config.basic_settings.luma_pitch * dwbc->config.basic_settings.dest_height);
-	memcpy(dest_chroma_buffer, chroma_buffer, dwbc->config.basic_settings.chroma_pitch * dwbc->config.basic_settings.dest_height / 2);
-
-	REG_UPDATE(MCIF_WB_BUFMGR_SW_CONTROL, MCIF_WB_BUFMGR_SW_LOCK, 0x0);
-
-	frame_info->format = dwbc->config.advanced_settings.out_format;
-	frame_info->width = dwbc->config.basic_settings.dest_width;
-	frame_info->height = dwbc->config.basic_settings.dest_height;
-	frame_info->luma_pitch = dwbc->config.basic_settings.luma_pitch;
-	frame_info->chroma_pitch = dwbc->config.basic_settings.chroma_pitch;
-	frame_info->size = dwbc->config.basic_settings.dest_height * (dwbc->config.basic_settings.luma_pitch + dwbc->config.basic_settings.chroma_pitch);
-
-	return true;
-}
-
-static bool set_basic_settings(struct dwbc *dwbc,
-							   const struct dwb_basic_settings *basic_settings)
-{
-	if (basic_settings) {
-		memcpy(&dwbc->config.basic_settings, basic_settings, sizeof(struct dwb_basic_settings));
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool get_basic_settings(struct dwbc *dwbc,
-							   struct dwb_basic_settings *basic_settings)
-{
-	if (basic_settings) {
-		memcpy(basic_settings, &dwbc->config.basic_settings, sizeof(struct dwb_basic_settings));
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool set_advanced_settings(struct dwbc *dwbc,
-								  const struct dwb_advanced_settings *advanced_settings)
-{
-	if (advanced_settings) {
-		if (advanced_settings->uFlag & sf_output_format) {
-			dwbc->config.advanced_settings.uFlag |= sf_output_format;
-			dwbc->config.advanced_settings.out_format = advanced_settings->out_format;
-		}
-
-		if (advanced_settings->uFlag & sf_capture_rate) {
-			dwbc->config.advanced_settings.uFlag |= sf_capture_rate;
-			dwbc->config.advanced_settings.capture_rate = advanced_settings->capture_rate;
-		}
-
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool get_advanced_settings(struct dwbc *dwbc,
-								  struct dwb_advanced_settings *advanced_settings)
-{
-	if (advanced_settings) {
-		memcpy(advanced_settings, &dwbc->config.advanced_settings, sizeof(struct dwb_advanced_settings));
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static bool reset_advanced_settings(struct dwbc *dwbc)
-{
-	dwbc->config.advanced_settings.uFlag = 0;
-	dwbc->config.advanced_settings.out_format = dwb_scaler_mode_bypass444;
-	dwbc->config.advanced_settings.capture_rate = dwb_capture_rate_0;
-
-	return true;
-}
-
-const struct dwbc_funcs dcn10_dwbc_funcs = {
-	.get_caps = get_caps,
-	.enable = enable,
-	.disable = disable,
-	.get_status = get_status,
-	.dump_frame = dump_frame,
-	.set_basic_settings = set_basic_settings,
-	.get_basic_settings = get_basic_settings,
-	.set_advanced_settings = set_advanced_settings,
-	.get_advanced_settings = get_advanced_settings,
-	.reset_advanced_settings = reset_advanced_settings,
-};
-
-static void dcn10_dwbc_construct(struct dcn10_dwbc *dwbc10,
-						  struct dc_context *ctx,
-						  const struct dcn10_dwbc_registers *dwbc_regs,
-						  const struct dcn10_dwbc_shift *dwbc_shift,
-						  const struct dcn10_dwbc_mask *dwbc_mask,
-						  int inst)
-{
-	dwbc10->base.ctx = ctx;
-
-	dwbc10->base.inst = inst;
-	dwbc10->base.funcs = &dcn10_dwbc_funcs;
-
-	dwbc10->dwbc_regs = dwbc_regs;
-	dwbc10->dwbc_shift = dwbc_shift;
-	dwbc10->dwbc_mask = dwbc_mask;
-}
-
-bool dcn10_dwbc_create(struct dc_context *ctx, struct resource_pool *pool)
-{
-	int i;
-	uint32_t pipe_count = pool->res_cap->num_dwb;
-
-	ASSERT(pipe_count > 0);
-
-	for (i = 0; i < pipe_count; i++) {
-		struct dcn10_dwbc *dwbc10 = dm_alloc(sizeof(struct dcn10_dwbc));
-
-		if (!dwbc10)
-			return false;
-
-		dcn10_dwbc_construct(dwbc10, ctx,
-				&dwbc10_regs[i],
-				&dwbc10_shift,
-				&dwbc10_mask,
-				i);
-
-		pool->dwbc[i] = &dwbc10->base;
-		if (pool->dwbc[i] == NULL) {
-			BREAK_TO_DEBUGGER();
-			dm_error("DC: failed to create dwbc10!\n");
-			return false;
-		}
-	}
-	return true;
-}
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.h
deleted file mode 100644
index cf530ae..0000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dwb.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Copyright 2012-17 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-#ifndef __DC_DWBC_DCN10_H__
-#define __DC_DWBC_DCN10_H__
-
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-
-bool dcn10_dwbc_create(struct dc_context *ctx, struct resource_pool *pool);
-#endif
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e4163ae..f5c7398 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -32,13 +32,15 @@
 #include "dce/dce_hwseq.h"
 #include "abm.h"
 #include "dcn10/dcn10_mem_input.h"
-#include "dcn10/dcn10_timing_generator.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_mpc.h"
 #include "timing_generator.h"
 #include "opp.h"
 #include "ipp.h"
 #include "mpc.h"
+#include "raven1/DCN/dcn_1_0_offset.h"
+#include "raven1/DCN/dcn_1_0_sh_mask.h"
+#include "vega10/soc15ip.h"
 #include "reg_helper.h"
 
 #define CTX \
@@ -50,7 +52,7 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
-static void log_mpc_crc(struct dc *dc)
+static void log_mpc_crc(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -128,7 +130,7 @@ static void dcn10_hubbub_wm_read_state(struct dce_hwseq *hws,
 	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D);
 }
 
-static void dcn10_log_hubbub_state(struct dc *dc)
+static void dcn10_log_hubbub_state(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dcn_hubbub_wm wm;
@@ -155,7 +157,7 @@ static void dcn10_log_hubbub_state(struct dc *dc)
 	DTN_INFO("\n");
 }
 
-static void dcn10_log_hw_state(struct dc *dc)
+static void dcn10_log_hw_state(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct resource_pool *pool = dc->res_pool;
@@ -198,38 +200,6 @@ static void dcn10_log_hw_state(struct dc *dc)
 	}
 	DTN_INFO("\n");
 
-	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
-			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct timing_generator *tg = pool->timing_generators[i];
-		struct dcn_otg_state s;
-
-		tgn10_read_otg_state(DCN10TG_FROM_TG(tg), &s);
-
-		DTN_INFO("[%d]:\t %d \t %d \t %d \t %d \t "
-				"%d \t %d \t %d \t %d \t %d \t %d \t "
-				"%d \t %d \t %d \t %d \t %d \t ",
-				i,
-				s.v_blank_start,
-				s.v_blank_end,
-				s.v_sync_a_start,
-				s.v_sync_a_end,
-				s.v_sync_a_pol,
-				s.v_total_max,
-				s.v_total_min,
-				s.h_blank_start,
-				s.h_blank_end,
-				s.h_sync_a_start,
-				s.h_sync_a_end,
-				s.h_sync_a_pol,
-				s.h_total,
-				s.v_total,
-				s.underflow_occurred_status);
-		DTN_INFO("\n");
-	}
-	DTN_INFO("\n");
-
 	log_mpc_crc(dc);
 
 	DTN_INFO_END();
@@ -317,7 +287,7 @@ static void verify_allow_pstate_change_high(
 	forced_pstate_allow = true;
 
 	if (should_log_hw_state) {
-		dcn10_log_hw_state(hws->ctx->dc);
+		dcn10_log_hw_state(DC_TO_CORE(hws->ctx->dc));
 	}
 
 	dm_logger_write(hws->ctx->logger, LOG_WARNING,
@@ -789,61 +759,11 @@ static void power_on_plane(
 	hubp_pg_control(hws, plane_id, true);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(hws->ctx->logger, LOG_DEBUG,
+	dm_logger_write(hws->ctx->logger, LOG_DC,
 			"Un-gated front end for pipe %d\n", plane_id);
 }
 
-static void undo_DEGVIDCN10_253_wa(struct dc *dc)
-{
-	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[0];
-	int pwr_status = 0;
-
-	REG_GET(DOMAIN0_PG_STATUS, DOMAIN0_PGFSM_PWR_STATUS, &pwr_status);
-	/* Don't need to blank if hubp is power gated*/
-	if (pwr_status == 2)
-		return;
-
-	mi->funcs->set_blank(mi, true);
-
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 1);
-
-	hubp_pg_control(hws, 0, false);
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 0);
-}
-
-static void ready_shared_resources(struct dc *dc)
-{
-	if (dc->current_state->stream_count == 0 &&
-			!dc->debug.disable_stutter)
-		undo_DEGVIDCN10_253_wa(dc);
-}
-
-static void apply_DEGVIDCN10_253_wa(struct dc *dc)
-{
-	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[0];
-
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 1);
-
-	hubp_pg_control(hws, 0, true);
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 0);
-
-	mi->funcs->set_hubp_blank_en(mi, false);
-}
-
-static void optimize_shared_resources(struct dc *dc)
-{
-	if (dc->current_state->stream_count == 0 &&
-			!dc->debug.disable_stutter)
-		apply_DEGVIDCN10_253_wa(dc);
-}
-
-static void bios_golden_init(struct dc *dc)
+static void bios_golden_init(struct core_dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
 	int i;
@@ -859,7 +779,7 @@ static void bios_golden_init(struct dc *dc)
 	}
 }
 
-static void dcn10_init_hw(struct dc *dc)
+static void dcn10_init_hw(struct core_dc *dc)
 {
 	int i;
 	struct abm *abm = dc->res_pool->abm;
@@ -870,7 +790,7 @@ static void dcn10_init_hw(struct dc *dc)
 		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
 		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
-		if (!dc->debug.disable_clock_gate) {
+		if (!dc->public.debug.disable_clock_gate) {
 			/* enable all DCN clock gating */
 			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
 
@@ -927,7 +847,7 @@ static void dcn10_init_hw(struct dc *dc)
 	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
 	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
-	if (!dc->debug.disable_clock_gate) {
+	if (!dc->public.debug.disable_clock_gate) {
 		/* enable all DCN clock gating */
 		REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
 
@@ -941,8 +861,8 @@ static void dcn10_init_hw(struct dc *dc)
 
 static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
-		struct dc_state *context,
-		struct dc *dc)
+		struct validate_context *context,
+		struct core_dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
@@ -1029,9 +949,9 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 }
 
 static void reset_back_end_for_pipe(
-		struct dc *dc,
+		struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	int i;
 
@@ -1063,20 +983,20 @@ static void reset_back_end_for_pipe(
 			&pipe_ctx->clock_source);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
-		if (&dc->current_state->res_ctx.pipe_ctx[i] == pipe_ctx)
+		if (&dc->current_context->res_ctx.pipe_ctx[i] == pipe_ctx)
 			break;
 
 	if (i == dc->res_pool->pipe_count)
 		return;
 
 	pipe_ctx->stream = NULL;
-	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+	dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset back end for pipe %d, tg:%d\n",
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
 /* trigger HW to start disconnect plane from stream on the next vsync */
-static void plane_atomic_disconnect(struct dc *dc,
+static void plane_atomic_disconnect(struct core_dc *dc,
 		int fe_idx)
 {
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
@@ -1101,10 +1021,10 @@ static void plane_atomic_disconnect(struct dc *dc,
 	if (opp_id == dc->res_pool->pipe_count)
 		return;
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 	mi->funcs->dcc_control(mi, false, false);
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	mpc->funcs->remove(mpc, dc->res_pool->opps[opp_id], fe_idx);
@@ -1112,7 +1032,7 @@ static void plane_atomic_disconnect(struct dc *dc,
 
 /* disable HW used by plane.
  * note:  cannot disable until disconnect is complete */
-static void plane_atomic_disable(struct dc *dc,
+static void plane_atomic_disable(struct core_dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -1130,8 +1050,11 @@ static void plane_atomic_disable(struct dc *dc,
 			fe_idx);*/
 
 	mi->funcs->set_blank(mi, true);
+	/*todo: unhack this*/
+	mi->opp_id = 0xf;
+	mi->mpcc_id = 0xf;
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
@@ -1143,7 +1066,7 @@ static void plane_atomic_disable(struct dc *dc,
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
@@ -1151,7 +1074,7 @@ static void plane_atomic_disable(struct dc *dc,
  * kill power to plane hw
  * note: cannot power down until plane is disable
  */
-static void plane_atomic_power_down(struct dc *dc, int fe_idx)
+static void plane_atomic_power_down(struct core_dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
@@ -1163,16 +1086,16 @@ static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 	xfm->funcs->transform_reset(xfm);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Power gated front end %d\n", fe_idx);
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 
 static void reset_front_end(
-		struct dc *dc,
+		struct core_dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -1191,7 +1114,7 @@ static void reset_front_end(
 	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
 	tg->funcs->unlock(tg);
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(hws);
 
 	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
@@ -1206,7 +1129,7 @@ static void reset_front_end(
 					fe_idx);
 }
 
-static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
+static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
@@ -1220,23 +1143,23 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 	xfm->funcs->transform_reset(xfm);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Power gated front end %d\n", fe_idx);
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void reset_hw_ctx_wrap(
-		struct dc *dc,
-		struct dc_state *context)
+		struct core_dc *dc,
+		struct validate_context *context)
 {
 	int i;
 
 	/* Reset Front End*/
 	/* Lock*/
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
 		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
 
 		if (cur_pipe_ctx->stream)
@@ -1245,7 +1168,7 @@ static void reset_hw_ctx_wrap(
 	/* Disconnect*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_state->res_ctx.pipe_ctx[i];
+			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->stream ||
@@ -1257,7 +1180,7 @@ static void reset_hw_ctx_wrap(
 	}
 	/* Unlock*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
 		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
 
 		if (cur_pipe_ctx->stream)
@@ -1267,7 +1190,7 @@ static void reset_hw_ctx_wrap(
 	/* Disable and Powerdown*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_state->res_ctx.pipe_ctx[i];
+			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		/*if (!pipe_ctx_old->stream)
@@ -1286,7 +1209,7 @@ static void reset_hw_ctx_wrap(
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_state->res_ctx.pipe_ctx[i];
+			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx_old->stream)
@@ -1294,7 +1217,7 @@ static void reset_hw_ctx_wrap(
 
 		if (!pipe_ctx->stream ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
-			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
+			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_context);
 	}
 }
 
@@ -1340,7 +1263,7 @@ static void toggle_watermark_change_req(struct dce_hwseq *hws)
 			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, watermark_change_req);
 }
 
-static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)
+static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
@@ -1361,34 +1284,34 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 static bool dcn10_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
-	struct transform *xfm_base = pipe_ctx->plane_res.xfm;
+	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	const struct dc_transfer_func *tf = NULL;
 	bool result = true;
 
-	if (xfm_base == NULL)
+	if (ipp == NULL)
 		return false;
 
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction && dce_use_lut(plane_state))
-		xfm_base->funcs->ipp_program_input_lut(xfm_base,
+		ipp->funcs->ipp_program_input_lut(ipp,
 				plane_state->gamma_correction);
 
 	if (tf == NULL)
-		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			ipp->funcs->ipp_set_degamma(ipp,
 					IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			ipp->funcs->ipp_set_degamma(ipp,
 					IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			ipp->funcs->ipp_set_degamma(ipp,
 					IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
@@ -1399,7 +1322,7 @@ static bool dcn10_set_input_transfer_func(
 			break;
 		}
 	} else if (tf->type == TF_TYPE_BYPASS) {
-		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS*/
 		result = false;
@@ -1751,7 +1674,7 @@ static bool dcn10_set_output_transfer_func(
 }
 
 static void dcn10_pipe_control_lock(
-	struct dc *dc,
+	struct core_dc *dc,
 	struct pipe_ctx *pipe,
 	bool lock)
 {
@@ -1763,7 +1686,7 @@ static void dcn10_pipe_control_lock(
 	if (pipe->top_pipe)
 		return;
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	if (lock)
@@ -1771,7 +1694,7 @@ static void dcn10_pipe_control_lock(
 	else
 		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
@@ -1813,7 +1736,7 @@ static bool wait_for_reset_trigger_to_occur(
 }
 
 static void dcn10_enable_timing_synchronization(
-	struct dc *dc,
+	struct core_dc *dc,
 	int group_index,
 	int group_size,
 	struct pipe_ctx *grouped_pipes[])
@@ -1842,7 +1765,7 @@ static void dcn10_enable_timing_synchronization(
 }
 
 static void print_rq_dlg_ttu(
-		struct dc *core_dc,
+		struct core_dc *core_dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
@@ -1964,14 +1887,14 @@ static void print_rq_dlg_ttu(
 }
 
 static void dcn10_power_on_fe(
-	struct dc *dc,
+	struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
-	struct dc_state *context)
+	struct validate_context *context)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -1988,7 +1911,7 @@ static void dcn10_power_on_fe(
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
 	if (plane_state) {
-		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
@@ -2006,7 +1929,7 @@ static void dcn10_power_on_fe(
 				plane_state->dst_rect.width,
 				plane_state->dst_rect.height);
 
-		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+		dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
 				"Pipe %d: width, height, x, y\n"
 				"viewport:%d, %d, %d, %d\n"
 				"recout:  %d, %d, %d, %d\n",
@@ -2022,7 +1945,7 @@ static void dcn10_power_on_fe(
 		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 }
@@ -2177,101 +2100,14 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
-static void mmhub_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
-		struct vm_system_aperture_param *apt,
-		struct dce_hwseq *hws)
-{
-	PHYSICAL_ADDRESS_LOC physical_page_number;
-	uint32_t logical_addr_low;
-	uint32_t logical_addr_high;
-
-	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,
-			PHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);
-	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,
-			PHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);
-
-	REG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,
-			LOGICAL_ADDR, &logical_addr_low);
-
-	REG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,
-			LOGICAL_ADDR, &logical_addr_high);
-
-	apt->sys_default.quad_part =  physical_page_number.quad_part << 12;
-	apt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;
-	apt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;
-}
-
-/* Temporary read settings, future will get values from kmd directly */
-static void mmhub_read_vm_context0_settings(struct dcn10_mem_input *mi,
-		struct vm_context0_param *vm0,
-		struct dce_hwseq *hws)
-{
-	PHYSICAL_ADDRESS_LOC fb_base;
-	PHYSICAL_ADDRESS_LOC fb_offset;
-	uint32_t fb_base_value;
-	uint32_t fb_offset_value;
-
-	REG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);
-	REG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);
-
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,
-			PAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,
-			PAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);
-
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,
-			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,
-			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);
-
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,
-			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,
-			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);
-
-	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,
-			PHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);
-	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,
-			PHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);
-
-	/*
-	 * The values in VM_CONTEXT0_PAGE_TABLE_BASE_ADDR is in UMA space.
-	 * Therefore we need to do
-	 * DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
-	 * - DCHUBBUB_SDPIF_FB_OFFSET + DCHUBBUB_SDPIF_FB_BASE
-	 */
-	fb_base.quad_part = (uint64_t)fb_base_value << 24;
-	fb_offset.quad_part = (uint64_t)fb_offset_value << 24;
-	vm0->pte_base.quad_part += fb_base.quad_part;
-	vm0->pte_base.quad_part -= fb_offset.quad_part;
-}
-
-static void dcn10_program_pte_vm(struct mem_input *mem_input,
-		enum surface_pixel_format format,
-		union dc_tiling_info *tiling_info,
-		enum dc_rotation_angle rotation,
-		struct dce_hwseq *hws)
-{
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
-	struct vm_system_aperture_param apt = { {{ 0 } } };
-	struct vm_context0_param vm0 = { { { 0 } } };
-
-
-	mmhub_read_vm_system_aperture_settings(mi, &apt, hws);
-	mmhub_read_vm_context0_settings(mi, &vm0, hws);
-
-	mem_input->funcs->mem_input_set_vm_system_aperture_settings(mem_input, &apt);
-	mem_input->funcs->mem_input_set_vm_context0_settings(mem_input, &vm0);
-}
-
 static void update_dchubp_dpp(
-	struct dc *dc,
+	struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
-	struct dc_state *context)
+	struct validate_context *context)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
-	struct transform *xfm = pipe_ctx->plane_res.xfm;
+	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
 	struct default_adjustment ocsc = {0};
@@ -2286,7 +2122,7 @@ static void update_dchubp_dpp(
 		pipe_ctx->pipe_idx,
 		pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
 		context->bw.dcn.calc_clk.dppclk_div);
-	dc->current_state->bw.dcn.cur_clk.dppclk_div =
+	dc->current_context->bw.dcn.cur_clk.dppclk_div =
 			context->bw.dcn.calc_clk.dppclk_div;
 	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
 
@@ -2296,7 +2132,7 @@ static void update_dchubp_dpp(
 	 */
 	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
 
-	dc->hwss.update_plane_addr(dc, pipe_ctx);
+	update_plane_addr(dc, pipe_ctx);
 
 	mi->funcs->mem_input_setup(
 		mi,
@@ -2307,16 +2143,14 @@ static void update_dchubp_dpp(
 
 	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 
-	if (dc->config.gpu_vm_support)
-		dcn10_program_pte_vm(
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
 				&plane_state->tiling_info,
-				plane_state->rotation,
-				hws
-				);
+				plane_state->rotation);
 
-	xfm->funcs->ipp_setup(xfm,
+	ipp->funcs->ipp_setup(ipp,
 			plane_state->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
@@ -2325,7 +2159,7 @@ static void update_dchubp_dpp(
 	mpcc_cfg.opp = pipe_ctx->stream_res.opp;
 	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
 		mpcc_cfg.z_index++;
-	if (dc->debug.surface_visual_confirm)
+	if (dc->public.debug.surface_visual_confirm)
 		dcn10_get_surface_visual_confirm_color(
 				pipe_ctx, &mpcc_cfg.black_color);
 	else
@@ -2365,15 +2199,14 @@ static void update_dchubp_dpp(
 		&plane_state->dcc,
 		plane_state->horizontal_mirror);
 
-	if (is_pipe_tree_visible(pipe_ctx))
-		mi->funcs->set_blank(mi, false);
+	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
 
 
 static void program_all_pipe_in_tree(
-		struct dc *dc,
+		struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 
@@ -2385,7 +2218,7 @@ static void program_all_pipe_in_tree(
 		/* watermark is for all pipes */
 		program_watermarks(dc->hwseq, &context->bw.dcn.watermarks, ref_clk_mhz);
 
-		if (dc->debug.sanity_checks) {
+		if (dc->public.debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
 			verify_allow_pstate_change_high(dc->hwseq);
 		}
@@ -2420,18 +2253,18 @@ static void program_all_pipe_in_tree(
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		/* pstate stuck check after each pipe is programmed */
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
-	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
+	if (pipe_ctx->bottom_pipe != NULL)
 		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
 }
 
 static void dcn10_pplib_apply_display_requirements(
-	struct dc *dc,
-	struct dc_state *context)
+	struct core_dc *dc,
+	struct validate_context *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
@@ -2457,14 +2290,14 @@ static void dcn10_pplib_apply_display_requirements(
 }
 
 static void dcn10_apply_ctx_for_surface(
-		struct dc *dc,
+		struct core_dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	int i, be_idx;
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	be_idx = -1;
@@ -2480,12 +2313,10 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes == 0) {
 		for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 			struct pipe_ctx *old_pipe_ctx =
-							&dc->current_state->res_ctx.pipe_ctx[i];
+							&dc->current_context->res_ctx.pipe_ctx[i];
 
-			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx) {
-				old_pipe_ctx->stream_res.tg->funcs->set_blank(old_pipe_ctx->stream_res.tg, true);
+			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx)
 				dcn10_power_down_fe(dc, old_pipe_ctx->pipe_idx);
-			}
 		}
 		return;
 	}
@@ -2494,7 +2325,7 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
-				&dc->current_state->res_ctx.pipe_ctx[i];
+				&dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
@@ -2537,7 +2368,7 @@ static void dcn10_apply_ctx_for_surface(
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
 					old_pipe_ctx->mpcc->inst);*/
 
-			if (dc->debug.sanity_checks)
+			if (dc->public.debug.sanity_checks)
 				verify_allow_pstate_change_high(dc->hwseq);
 
 			old_pipe_ctx->top_pipe = NULL;
@@ -2608,21 +2439,18 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
 			);
 
-	if (dc->debug.sanity_checks)
+	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void dcn10_set_bandwidth(
-		struct dc *dc,
-		struct dc_state *context,
+		struct core_dc *dc,
+		struct validate_context *context,
 		bool decrease_allowed)
 {
-	struct pp_smu_display_requirement_rv *smu_req_cur =
-			&dc->res_pool->pp_smu_req;
-	struct pp_smu_display_requirement_rv smu_req = *smu_req_cur;
-	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
+	struct dm_pp_clock_for_voltage_req clock;
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -2630,55 +2458,54 @@ static void dcn10_set_bandwidth(
 		return;
 
 	if (decrease_allowed || context->bw.dcn.calc_clk.dispclk_khz
-			> dc->current_state->bw.dcn.cur_clk.dispclk_khz) {
+			> dc->current_context->bw.dcn.cur_clk.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dcn.calc_clk.dispclk_khz);
-		dc->current_state->bw.dcn.cur_clk.dispclk_khz =
+		dc->current_context->bw.dcn.cur_clk.dispclk_khz =
 				context->bw.dcn.calc_clk.dispclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz
-			> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
-		smu_req.hard_min_dcefclk_khz =
-				context->bw.dcn.calc_clk.dcfclk_khz;
+			> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
+		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
+		clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+		context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz
-			> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
-		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
+			> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
+		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
+		clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->bw.dcn.calc_clk.fclk_khz = clock.clocks_in_khz;
+		context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz
-			> dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
-		dc->current_state->bw.dcn.calc_clk.dcfclk_deep_sleep_khz =
+			> dc->current_context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
+		dc->current_context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 	}
-
-	smu_req.display_count = context->stream_count;
-
-	if (pp_smu->set_display_requirement)
-		pp_smu->set_display_requirement(&pp_smu->pp_smu, &smu_req);
-
-	*smu_req_cur = smu_req;
-
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
 	if (decrease_allowed || context->bw.dcn.calc_clk.dram_ccm_us
-			< dc->current_state->bw.dcn.cur_clk.dram_ccm_us) {
-		dc->current_state->bw.dcn.calc_clk.dram_ccm_us =
+			< dc->current_context->bw.dcn.cur_clk.dram_ccm_us) {
+		dc->current_context->bw.dcn.calc_clk.dram_ccm_us =
 				context->bw.dcn.calc_clk.dram_ccm_us;
 		context->bw.dcn.cur_clk.dram_ccm_us =
 				context->bw.dcn.calc_clk.dram_ccm_us;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.min_active_dram_ccm_us
-			< dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) {
-		dc->current_state->bw.dcn.calc_clk.min_active_dram_ccm_us =
+			< dc->current_context->bw.dcn.cur_clk.min_active_dram_ccm_us) {
+		dc->current_context->bw.dcn.calc_clk.min_active_dram_ccm_us =
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 		context->bw.dcn.cur_clk.min_active_dram_ccm_us =
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 	}
 	dcn10_pplib_apply_display_requirements(dc, context);
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -2731,7 +2558,7 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 }
 
 static void set_plane_config(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct resource_context *res_ctx)
 {
@@ -2776,7 +2603,7 @@ static void dcn10_config_stereo_parameters(
 	return;
 }
 
-static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
+static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -2797,13 +2624,13 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
 }
 
 static void dcn10_wait_for_mpcc_disconnect(
-		struct dc *dc,
+		struct core_dc *dc,
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
 {
 	int i;
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -2821,14 +2648,14 @@ static void dcn10_wait_for_mpcc_disconnect(
 		}
 	}
 
-	if (dc->debug.sanity_checks) {
+	if (dc->public.debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
 }
 
 static bool dcn10_dummy_display_power_gating(
-	struct dc *dc,
+	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -2842,7 +2669,7 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
 	if (plane_state->ctx->dc->debug.sanity_checks) {
-		struct dc *dc = plane_state->ctx->dc;
+		struct core_dc *dc = DC_TO_CORE(plane_state->ctx->dc);
 
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
@@ -2854,6 +2681,14 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->plane_res.mi);
 
+	/* DCN we read INUSE address in MI, do we still need this wa? */
+	if (plane_state->status.is_flip_pending &&
+			!plane_state->visible) {
+		pipe_ctx->plane_res.mi->current_address =
+				pipe_ctx->plane_res.mi->request_address;
+		BREAK_TO_DEBUGGER();
+	}
+
 	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
 	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
@@ -2862,8 +2697,6 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-
-
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -2871,7 +2704,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
-	.update_plane_addr = dcn10_update_plane_addr,
+	.update_plane_addr = update_plane_addr,
 	.update_dchub = dcn10_update_dchub,
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
@@ -2896,13 +2729,11 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
 	.log_hw_state = dcn10_log_hw_state,
-	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
-	.ready_shared_resources = ready_shared_resources,
-	.optimize_shared_resources = optimize_shared_resources,
+	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect
 };
 
 
-void dcn10_hw_sequencer_construct(struct dc *dc)
+void dcn10_hw_sequencer_construct(struct core_dc *dc)
 {
 	dc->hwss = dcn10_funcs;
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
index ca53dc1..28218dc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
@@ -28,11 +28,11 @@
 
 #include "core_types.h"
 
-struct dc;
+struct core_dc;
 
-void dcn10_hw_sequencer_construct(struct dc *dc);
+void dcn10_hw_sequencer_construct(struct core_dc *dc);
 extern void fill_display_configs(
-	const struct dc_state *context,
+	const struct validate_context *context,
 	struct dm_pp_display_configuration *pp_display_cfg);
 
 #endif /* __DC_HWSS_DCN10_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c
index 5edc4b7..8ee8305 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.c
@@ -37,6 +37,436 @@
 #define CTX \
 	ippn10->base.ctx
 
+
+struct dcn10_input_csc_matrix {
+	enum dc_color_space color_space;
+	uint32_t regval[12];
+};
+
+static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
+	{COLOR_SPACE_SRGB,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_SRGB_LIMITED,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_YCBCR601,
+		{0x2cdd, 0x2000, 0, 0xe991, 0xe926, 0x2000, 0xf4fd, 0x10ef,
+						0, 0x2000, 0x38b4, 0xe3a6} },
+	{COLOR_SPACE_YCBCR601_LIMITED,
+		{0x3353, 0x2568, 0, 0xe400, 0xe5dc, 0x2568, 0xf367, 0x1108,
+						0, 0x2568, 0x40de, 0xdd3a} },
+	{COLOR_SPACE_YCBCR709,
+		{0x3265, 0x2000, 0, 0xe6ce, 0xf105, 0x2000, 0xfa01, 0xa7d, 0,
+						0x2000, 0x3b61, 0xe24f} },
+
+	{COLOR_SPACE_YCBCR709_LIMITED,
+		{0x39a6, 0x2568, 0, 0xe0d6, 0xeedd, 0x2568, 0xf925, 0x9a8, 0,
+						0x2568, 0x43ee, 0xdbb2} }
+};
+
+enum dcn10_input_csc_select {
+	INPUT_CSC_SELECT_BYPASS = 0,
+	INPUT_CSC_SELECT_ICSC,
+	INPUT_CSC_SELECT_COMA
+};
+
+static void ippn10_program_input_csc(
+		struct input_pixel_processor *ipp,
+		enum dc_color_space color_space,
+		enum dcn10_input_csc_select select)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	int i;
+	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
+	const uint32_t *regval = NULL;
+	uint32_t selection = 1;
+
+	if (select == INPUT_CSC_SELECT_BYPASS) {
+		REG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);
+		return;
+	}
+
+	for (i = 0; i < arr_size; i++)
+		if (dcn10_input_csc_matrix[i].color_space == color_space) {
+			regval = dcn10_input_csc_matrix[i].regval;
+			break;
+		}
+
+	if (regval == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (select == INPUT_CSC_SELECT_COMA)
+		selection = 2;
+	REG_SET(CM_ICSC_CONTROL, 0,
+			CM_ICSC_MODE, selection);
+
+	if (select == INPUT_CSC_SELECT_ICSC) {
+		/*R*/
+		REG_SET_2(CM_ICSC_C11_C12, 0,
+			CM_ICSC_C11, regval[0],
+			CM_ICSC_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C13_C14, 0,
+			CM_ICSC_C13, regval[0],
+			CM_ICSC_C14, regval[1]);
+		/*G*/
+		regval += 2;
+		REG_SET_2(CM_ICSC_C21_C22, 0,
+			CM_ICSC_C21, regval[0],
+			CM_ICSC_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C23_C24, 0,
+			CM_ICSC_C23, regval[0],
+			CM_ICSC_C24, regval[1]);
+		/*B*/
+		regval += 2;
+		REG_SET_2(CM_ICSC_C31_C32, 0,
+			CM_ICSC_C31, regval[0],
+			CM_ICSC_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C33_C34, 0,
+			CM_ICSC_C33, regval[0],
+			CM_ICSC_C34, regval[1]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMA_C11_C12, 0,
+			CM_COMA_C11, regval[0],
+			CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+			CM_COMA_C13, regval[0],
+			CM_COMA_C14, regval[1]);
+		/*G*/
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+			CM_COMA_C21, regval[0],
+			CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+			CM_COMA_C23, regval[0],
+			CM_COMA_C24, regval[1]);
+		/*B*/
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+			CM_COMA_C31, regval[0],
+			CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+			CM_COMA_C33, regval[0],
+			CM_COMA_C34, regval[1]);
+	}
+}
+
+/*program de gamma RAM B*/
+static void ippn10_program_degamma_lutb_settings(
+		struct input_pixel_processor *ipp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_DGAM_RAMB_REGION_0_1, 0,
+		CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, 	curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_2_3, 0,
+		CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_4_5, 0,
+		CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_6_7, 0,
+		CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_8_9, 0,
+		CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_10_11, 0,
+		CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_12_13, 0,
+		CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_14_15, 0,
+		CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+/*program de gamma RAM A*/
+static void ippn10_program_degamma_luta_settings(
+		struct input_pixel_processor *ipp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_DGAM_RAMA_REGION_0_1, 0,
+		CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_2_3, 0,
+		CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_4_5, 0,
+		CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_6_7, 0,
+		CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_8_9, 0,
+		CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_10_11, 0,
+		CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_12_13, 0,
+		CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_14_15, 0,
+		CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+static void ippn10_power_on_degamma_lut(
+	struct input_pixel_processor *ipp,
+	bool power_on)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			SHARED_MEM_PWR_DIS, power_on == true ? 0:1);
+
+}
+
+static void ippn10_program_degamma_lut(
+		struct input_pixel_processor *ipp,
+		const struct pwl_result_data *rgb,
+		uint32_t num,
+		bool is_ram_a)
+{
+	uint32_t i;
+
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);
+	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,
+				   CM_DGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL,
+					is_ram_a == true ? 0:1);
+
+	REG_SET(CM_DGAM_LUT_INDEX, 0, CM_DGAM_LUT_INDEX, 0);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_blue_reg);
+	}
+}
+
+static void ippn10_enable_cm_block(
+		struct input_pixel_processor *ipp)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
+}
+
+static void ippn10_full_bypass(struct input_pixel_processor *ipp)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	/* Input pixel format: ARGB8888 */
+	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
+			CNVC_SURFACE_PIXEL_FORMAT, 0x8);
+
+	/* Zero expansion */
+	REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			ALPHA_EN, 0,
+			FORMAT_EXPANSION_MODE, 0);
+
+	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
+	REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
+
+	/* Setting degamma bypass for now */
+	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
+	REG_SET(CM_IGAM_CONTROL, 0, CM_IGAM_LUT_MODE, 0);
+}
+
+static void ippn10_set_degamma(
+		struct input_pixel_processor *ipp,
+		enum ipp_degamma_mode mode)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	ippn10_enable_cm_block(ipp);
+
+	switch (mode) {
+	case IPP_DEGAMMA_MODE_BYPASS:
+		/* Setting de gamma bypass for now */
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 0);
+		break;
+	case IPP_DEGAMMA_MODE_HW_sRGB:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 1);
+		break;
+	case IPP_DEGAMMA_MODE_HW_xvYCC:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);
+			break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
 static bool ippn10_cursor_program_control(
 		struct dcn10_ipp *ippn10,
 		bool pixel_data_invert,
@@ -221,6 +651,283 @@ static void ippn10_cursor_set_position(
 	/* TODO Handle surface pixel formats other than 4:4:4 */
 }
 
+enum pixel_format_description {
+	PIXEL_FORMAT_FIXED = 0,
+	PIXEL_FORMAT_FIXED16,
+	PIXEL_FORMAT_FLOAT
+
+};
+
+static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
+						enum pixel_format_description *fmt)
+{
+
+	if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F ||
+		input_format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F)
+		*fmt = PIXEL_FORMAT_FLOAT;
+	else if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)
+		*fmt = PIXEL_FORMAT_FIXED16;
+	else
+		*fmt = PIXEL_FORMAT_FIXED;
+}
+
+static void ippn10_set_degamma_format_float(struct input_pixel_processor *ipp,
+		bool is_float)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	if (is_float) {
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 1);
+	} else {
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 2);
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 0);
+	}
+}
+
+
+static void ippn10_cnv_setup (
+		struct input_pixel_processor *ipp,
+		enum surface_pixel_format input_format,
+		enum expansion_mode mode,
+		enum ipp_output_format cnv_out_format)
+{
+	uint32_t pixel_format;
+	uint32_t alpha_en;
+	enum pixel_format_description fmt ;
+	enum dc_color_space color_space;
+	enum dcn10_input_csc_select select;
+	bool is_float;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	bool force_disable_cursor = false;
+
+	ippn10_setup_format_flags(input_format, &fmt);
+	alpha_en = 1;
+	pixel_format = 0;
+	color_space = COLOR_SPACE_SRGB;
+	select = INPUT_CSC_SELECT_BYPASS;
+	is_float = false;
+
+	switch (fmt) {
+	case PIXEL_FORMAT_FIXED:
+	case PIXEL_FORMAT_FIXED16:
+	/*when output is float then FORMAT_CONTROL__OUTPUT_FP=1*/
+		REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_EXPANSION_MODE, mode,
+			OUTPUT_FP, 0);
+		break;
+	case PIXEL_FORMAT_FLOAT:
+		REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_EXPANSION_MODE, mode,
+			OUTPUT_FP, 1);
+		is_float = true;
+		break;
+	default:
+
+		break;
+	}
+
+	ippn10_set_degamma_format_float(ipp, is_float);
+
+	switch (input_format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+		pixel_format = 1;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		pixel_format = 3;
+		alpha_en = 0;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+		pixel_format = 8;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		pixel_format = 10;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+		force_disable_cursor = false;
+		pixel_format = 65;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		force_disable_cursor = true;
+		pixel_format = 64;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+		force_disable_cursor = true;
+		pixel_format = 67;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		force_disable_cursor = true;
+		pixel_format = 66;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+		pixel_format = 22;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+		pixel_format = 24;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		pixel_format = 25;
+		break;
+	default:
+		break;
+	}
+	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
+			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
+	REG_UPDATE(FORMAT_CONTROL, ALPHA_EN, alpha_en);
+
+	ippn10_program_input_csc(ipp, color_space, select);
+
+	if (force_disable_cursor) {
+		REG_UPDATE(CURSOR_CONTROL,
+				CURSOR_ENABLE, 0);
+		REG_UPDATE(CURSOR0_CONTROL,
+				CUR0_ENABLE, 0);
+	}
+}
+
+
+static bool ippn10_degamma_ram_inuse(struct input_pixel_processor *ipp,
+							bool *ram_a_inuse)
+{
+	bool ret = false;
+	uint32_t status_reg = 0;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
+			&status_reg);
+
+	if (status_reg == 9) {
+		*ram_a_inuse = true;
+		ret = true;
+	} else if (status_reg == 10) {
+		*ram_a_inuse = false;
+		ret = true;
+	}
+	return ret;
+}
+
+static bool ippn10_ingamma_ram_inuse(struct input_pixel_processor *ipp,
+							bool *ram_a_inuse)
+{
+	bool in_use = false;
+	uint32_t status_reg = 0;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
+				&status_reg);
+
+	// 1 => IGAM_RAMA, 3 => IGAM_RAMA & DGAM_ROMA, 4 => IGAM_RAMA & DGAM_ROMB
+	if (status_reg == 1 || status_reg == 3 || status_reg == 4) {
+		*ram_a_inuse = true;
+		in_use = true;
+	// 2 => IGAM_RAMB, 5 => IGAM_RAMB & DGAM_ROMA, 6 => IGAM_RAMB & DGAM_ROMB
+	} else if (status_reg == 2 || status_reg == 5 || status_reg == 6) {
+		*ram_a_inuse = false;
+		in_use = true;
+	}
+	return in_use;
+}
+
+static void ippn10_degamma_ram_select(struct input_pixel_processor *ipp,
+							bool use_ram_a)
+{
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+
+	if (use_ram_a)
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
+	else
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 4);
+
+}
+
+static void ippn10_set_degamma_pwl(struct input_pixel_processor *ipp,
+								 const struct pwl_params *params)
+{
+	bool is_ram_a = true;
+
+	ippn10_power_on_degamma_lut(ipp, true);
+	ippn10_enable_cm_block(ipp);
+	ippn10_degamma_ram_inuse(ipp, &is_ram_a);
+	if (is_ram_a == true)
+		ippn10_program_degamma_lutb_settings(ipp, params);
+	else
+		ippn10_program_degamma_luta_settings(ipp, params);
+
+	ippn10_program_degamma_lut(ipp, params->rgb_resulted,
+							params->hw_points_num, !is_ram_a);
+	ippn10_degamma_ram_select(ipp, !is_ram_a);
+}
+
+/*
+ * Input gamma LUT currently supports 256 values only. This means input color
+ * can have a maximum of 8 bits per channel (= 256 possible values) in order to
+ * have a one-to-one mapping with the LUT. Truncation will occur with color
+ * values greater than 8 bits.
+ *
+ * In the future, this function should support additional input gamma methods,
+ * such as piecewise linear mapping, and input gamma bypass.
+ */
+static void ippn10_program_input_lut(
+		struct input_pixel_processor *ipp,
+		const struct dc_gamma *gamma)
+{
+	int i;
+	struct dcn10_ipp *ippn10 = TO_DCN10_IPP(ipp);
+	bool rama_occupied = false;
+	uint32_t ram_num;
+	// Power on LUT memory.
+	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 1);
+	ippn10_enable_cm_block(ipp);
+	// Determine whether to use RAM A or RAM B
+	ippn10_ingamma_ram_inuse(ipp, &rama_occupied);
+	if (!rama_occupied)
+		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 0);
+	else
+		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 1);
+	// RW mode is 256-entry LUT
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_RW_MODE, 0);
+	// IGAM Input format should be 8 bits per channel.
+	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 0);
+	// Do not mask any R,G,B values
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_WRITE_EN_MASK, 7);
+	// LUT-256, unsigned, integer, new u0.12 format
+	REG_UPDATE_3(
+		CM_IGAM_CONTROL,
+		CM_IGAM_LUT_FORMAT_R, 3,
+		CM_IGAM_LUT_FORMAT_G, 3,
+		CM_IGAM_LUT_FORMAT_B, 3);
+	// Start at index 0 of IGAM LUT
+	REG_UPDATE(CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, 0);
+	for (i = 0; i < gamma->num_entries; i++) {
+		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
+				dal_fixed31_32_round(
+					gamma->entries.red[i]));
+		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
+				dal_fixed31_32_round(
+					gamma->entries.green[i]));
+		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
+				dal_fixed31_32_round(
+					gamma->entries.blue[i]));
+	}
+	// Power off LUT memory
+	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 0);
+	// Enable IGAM LUT on ram we just wrote to. 2 => RAMA, 3 => RAMB
+	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, rama_occupied ? 3 : 2);
+	REG_GET(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, &ram_num);
+}
+
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
@@ -234,11 +941,11 @@ static void dcn10_ipp_destroy(struct input_pixel_processor **ipp)
 static const struct ipp_funcs dcn10_ipp_funcs = {
 	.ipp_cursor_set_attributes	= ippn10_cursor_set_attributes,
 	.ipp_cursor_set_position	= ippn10_cursor_set_position,
-	.ipp_set_degamma		= NULL,
-	.ipp_program_input_lut		= NULL,
-	.ipp_full_bypass		= NULL,
-	.ipp_setup			= NULL,
-	.ipp_program_degamma_pwl	= NULL,
+	.ipp_set_degamma		= ippn10_set_degamma,
+	.ipp_program_input_lut		= ippn10_program_input_lut,
+	.ipp_full_bypass		= ippn10_full_bypass,
+	.ipp_setup			= ippn10_cnv_setup,
+	.ipp_program_degamma_pwl	= ippn10_set_degamma_pwl,
 	.ipp_destroy			= dcn10_ipp_destroy
 };
 
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h
index e4f2928..69db441 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_ipp.h
@@ -32,6 +32,59 @@
 	container_of(ipp, struct dcn10_ipp, base)
 
 #define IPP_REG_LIST_DCN(id) \
+	SRI(CM_ICSC_CONTROL, CM, id), \
+	SRI(CM_ICSC_C11_C12, CM, id), \
+	SRI(CM_ICSC_C13_C14, CM, id), \
+	SRI(CM_ICSC_C21_C22, CM, id), \
+	SRI(CM_ICSC_C23_C24, CM, id), \
+	SRI(CM_ICSC_C31_C32, CM, id), \
+	SRI(CM_ICSC_C33_C34, CM, id), \
+	SRI(CM_DGAM_RAMB_START_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMB_START_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMB_START_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMB_SLOPE_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMB_SLOPE_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMB_SLOPE_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL1_B, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL2_B, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL1_G, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL2_G, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL1_R, CM, id), \
+	SRI(CM_DGAM_RAMB_END_CNTL2_R, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_0_1, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_2_3, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_4_5, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_6_7, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_8_9, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_10_11, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_12_13, CM, id), \
+	SRI(CM_DGAM_RAMB_REGION_14_15, CM, id), \
+	SRI(CM_DGAM_RAMA_START_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMA_START_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMA_START_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMA_SLOPE_CNTL_B, CM, id), \
+	SRI(CM_DGAM_RAMA_SLOPE_CNTL_G, CM, id), \
+	SRI(CM_DGAM_RAMA_SLOPE_CNTL_R, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL1_B, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL2_B, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL1_G, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL2_G, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL1_R, CM, id), \
+	SRI(CM_DGAM_RAMA_END_CNTL2_R, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_0_1, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_2_3, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_4_5, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_6_7, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_8_9, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_10_11, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_12_13, CM, id), \
+	SRI(CM_DGAM_RAMA_REGION_14_15, CM, id), \
+	SRI(CM_MEM_PWR_CTRL, CM, id), \
+	SRI(CM_DGAM_LUT_WRITE_EN_MASK, CM, id), \
+	SRI(CM_DGAM_LUT_INDEX, CM, id), \
+	SRI(CM_DGAM_LUT_DATA, CM, id), \
+	SRI(CM_CONTROL, CM, id), \
+	SRI(CM_DGAM_CONTROL, CM, id), \
 	SRI(FORMAT_CONTROL, CNVC_CFG, id), \
 	SRI(DPP_CONTROL, DPP_TOP, id), \
 	SRI(CNVC_SURFACE_PIXEL_FORMAT, CNVC_CFG, id), \
@@ -42,6 +95,16 @@
 #define IPP_REG_LIST_DCN10(id) \
 	IPP_REG_LIST_DCN(id), \
 	SRI(CURSOR_SETTINS, HUBPREQ, id), \
+	SRI(CM_IGAM_CONTROL, CM, id), \
+	SRI(CM_COMA_C11_C12, CM, id), \
+	SRI(CM_COMA_C13_C14, CM, id), \
+	SRI(CM_COMA_C21_C22, CM, id), \
+	SRI(CM_COMA_C23_C24, CM, id), \
+	SRI(CM_COMA_C31_C32, CM, id), \
+	SRI(CM_COMA_C33_C34, CM, id), \
+	SRI(CM_IGAM_LUT_RW_CONTROL, CM, id), \
+	SRI(CM_IGAM_LUT_RW_INDEX, CM, id), \
+	SRI(CM_IGAM_LUT_SEQ_COLOR, CM, id), \
 	SRI(CURSOR_SURFACE_ADDRESS_HIGH, CURSOR, id), \
 	SRI(CURSOR_SURFACE_ADDRESS, CURSOR, id), \
 	SRI(CURSOR_SIZE, CURSOR, id), \
@@ -54,10 +117,129 @@
 	.field_name = reg_name ## __ ## field_name ## post_fix
 
 #define IPP_MASK_SH_LIST_DCN(mask_sh) \
+	IPP_SF(CM0_CM_ICSC_CONTROL, CM_ICSC_MODE, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C11, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C11_C12, CM_ICSC_C12, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C13_C14, CM_ICSC_C13, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C13_C14, CM_ICSC_C14, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C21_C22, CM_ICSC_C21, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C21_C22, CM_ICSC_C22, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C23_C24, CM_ICSC_C23, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C23_C24, CM_ICSC_C24, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C31_C32, CM_ICSC_C31, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C31_C32, CM_ICSC_C32, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C33, mask_sh), \
+	IPP_SF(CM0_CM_ICSC_C33_C34, CM_ICSC_C34, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_B, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_G, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_R, CM_DGAM_RAMB_EXP_REGION_START_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_START_CNTL_R, CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_B, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_G, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_SLOPE_CNTL_R, CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL1_B, CM_DGAM_RAMB_EXP_REGION_END_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_B, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_B, CM_DGAM_RAMB_EXP_REGION_END_BASE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL1_G, CM_DGAM_RAMB_EXP_REGION_END_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_G, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_G, CM_DGAM_RAMB_EXP_REGION_END_BASE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL1_R, CM_DGAM_RAMB_EXP_REGION_END_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_R, CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_END_CNTL2_R, CM_DGAM_RAMB_EXP_REGION_END_BASE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_0_1, CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_2_3, CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_4_5, CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_6_7, CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_8_9, CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_10_11, CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_12_13, CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMB_REGION_14_15, CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_B, CM_DGAM_RAMA_EXP_REGION_START_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_B, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_G, CM_DGAM_RAMA_EXP_REGION_START_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_G, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_R, CM_DGAM_RAMA_EXP_REGION_START_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_START_CNTL_R, CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_B, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_G, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_SLOPE_CNTL_R, CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL1_B, CM_DGAM_RAMA_EXP_REGION_END_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_B, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_B, CM_DGAM_RAMA_EXP_REGION_END_BASE_B, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL1_G, CM_DGAM_RAMA_EXP_REGION_END_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_G, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_G, CM_DGAM_RAMA_EXP_REGION_END_BASE_G, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL1_R, CM_DGAM_RAMA_EXP_REGION_END_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_R, CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_END_CNTL2_R, CM_DGAM_RAMA_EXP_REGION_END_BASE_R, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_0_1, CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_2_3, CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_4_5, CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_6_7, CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_8_9, CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_10_11, CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_12_13, CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_RAMA_REGION_14_15, CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, mask_sh), \
+	IPP_SF(CM0_CM_MEM_PWR_CTRL, SHARED_MEM_PWR_DIS, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_EN_MASK, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_INDEX, CM_DGAM_LUT_INDEX, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_LUT_DATA, CM_DGAM_LUT_DATA, mask_sh), \
 	IPP_SF(CNVC_CFG0_CNVC_SURFACE_PIXEL_FORMAT, CNVC_SURFACE_PIXEL_FORMAT, mask_sh), \
 	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, CNVC_BYPASS, mask_sh), \
 	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, ALPHA_EN, mask_sh), \
 	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, FORMAT_EXPANSION_MODE, mask_sh), \
+	IPP_SF(CM0_CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, mask_sh), \
 	IPP_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_MODE, mask_sh), \
 	IPP_SF(CNVC_CUR0_CURSOR0_COLOR0, CUR0_COLOR0, mask_sh), \
 	IPP_SF(CNVC_CUR0_CURSOR0_COLOR1, CUR0_COLOR1, mask_sh), \
@@ -68,6 +250,26 @@
 	IPP_MASK_SH_LIST_DCN(mask_sh),\
 	IPP_SF(HUBPREQ0_CURSOR_SETTINS, CURSOR0_DST_Y_OFFSET, mask_sh), \
 	IPP_SF(HUBPREQ0_CURSOR_SETTINS, CURSOR0_CHUNK_HDL_ADJUST, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C11_C12, CM_COMA_C11, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C11_C12, CM_COMA_C12, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C13_C14, CM_COMA_C13, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C13_C14, CM_COMA_C14, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C21_C22, CM_COMA_C21, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C21_C22, CM_COMA_C22, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C23_C24, CM_COMA_C23, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C23_C24, CM_COMA_C24, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C31_C32, CM_COMA_C31, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C31_C32, CM_COMA_C32, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C33_C34, CM_COMA_C33, mask_sh), \
+	IPP_SF(CM0_CM_COMA_C33_C34, CM_COMA_C34, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_RW_MODE, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_WRITE_EN_MASK, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_LUT_SEQ_COLOR, CM_IGAM_LUT_SEQ_COLOR, mask_sh), \
+	IPP_SF(CM0_CM_CONTROL, CM_BYPASS_EN, mask_sh), \
 	IPP_SF(CURSOR0_CURSOR_SURFACE_ADDRESS_HIGH, CURSOR_SURFACE_ADDRESS_HIGH, mask_sh), \
 	IPP_SF(CURSOR0_CURSOR_SURFACE_ADDRESS, CURSOR_SURFACE_ADDRESS, mask_sh), \
 	IPP_SF(CURSOR0_CURSOR_SIZE, CURSOR_WIDTH, mask_sh), \
@@ -81,13 +283,163 @@
 	IPP_SF(CURSOR0_CURSOR_HOT_SPOT, CURSOR_HOT_SPOT_X, mask_sh), \
 	IPP_SF(CURSOR0_CURSOR_HOT_SPOT, CURSOR_HOT_SPOT_Y, mask_sh), \
 	IPP_SF(CURSOR0_CURSOR_DST_OFFSET, CURSOR_DST_X_OFFSET, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_FORMAT_R, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_FORMAT_G, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_LUT_FORMAT_B, mask_sh), \
+	IPP_SF(CM0_CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, mask_sh), \
 	IPP_SF(CNVC_CFG0_FORMAT_CONTROL, OUTPUT_FP, mask_sh)
 
 #define IPP_DCN10_REG_FIELD_LIST(type) \
+	type CM_DGAM_CONFIG_STATUS; \
+	type CM_ICSC_MODE; \
+	type CM_ICSC_C11; \
+	type CM_ICSC_C12; \
+	type CM_ICSC_C13; \
+	type CM_ICSC_C14; \
+	type CM_ICSC_C21; \
+	type CM_ICSC_C22; \
+	type CM_ICSC_C23; \
+	type CM_ICSC_C24; \
+	type CM_ICSC_C31; \
+	type CM_ICSC_C32; \
+	type CM_ICSC_C33; \
+	type CM_ICSC_C34; \
+	type CM_COMA_C11; \
+	type CM_COMA_C12; \
+	type CM_COMA_C13; \
+	type CM_COMA_C14; \
+	type CM_COMA_C21; \
+	type CM_COMA_C22; \
+	type CM_COMA_C23; \
+	type CM_COMA_C24; \
+	type CM_COMA_C31; \
+	type CM_COMA_C32; \
+	type CM_COMA_C33; \
+	type CM_COMA_C34; \
+	type CM_DGAM_RAMB_EXP_REGION_START_B; \
+	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B; \
+	type CM_DGAM_RAMB_EXP_REGION_START_G; \
+	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G; \
+	type CM_DGAM_RAMB_EXP_REGION_START_R; \
+	type CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R; \
+	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B; \
+	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G; \
+	type CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R; \
+	type CM_DGAM_RAMB_EXP_REGION_END_B; \
+	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B; \
+	type CM_DGAM_RAMB_EXP_REGION_END_BASE_B; \
+	type CM_DGAM_RAMB_EXP_REGION_END_G; \
+	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G; \
+	type CM_DGAM_RAMB_EXP_REGION_END_BASE_G; \
+	type CM_DGAM_RAMB_EXP_REGION_END_R; \
+	type CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R; \
+	type CM_DGAM_RAMB_EXP_REGION_END_BASE_R; \
+	type CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET; \
+	type CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION_START_B; \
+	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B; \
+	type CM_DGAM_RAMA_EXP_REGION_START_G; \
+	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G; \
+	type CM_DGAM_RAMA_EXP_REGION_START_R; \
+	type CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R; \
+	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B; \
+	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G; \
+	type CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R; \
+	type CM_DGAM_RAMA_EXP_REGION_END_B; \
+	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B; \
+	type CM_DGAM_RAMA_EXP_REGION_END_BASE_B; \
+	type CM_DGAM_RAMA_EXP_REGION_END_G; \
+	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G; \
+	type CM_DGAM_RAMA_EXP_REGION_END_BASE_G; \
+	type CM_DGAM_RAMA_EXP_REGION_END_R; \
+	type CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R; \
+	type CM_DGAM_RAMA_EXP_REGION_END_BASE_R; \
+	type CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS; \
+	type CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET; \
+	type CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS; \
+	type SHARED_MEM_PWR_DIS; \
+	type CM_IGAM_LUT_FORMAT_R; \
+	type CM_IGAM_LUT_FORMAT_G; \
+	type CM_IGAM_LUT_FORMAT_B; \
+	type CM_IGAM_LUT_HOST_EN; \
+	type CM_IGAM_LUT_RW_INDEX; \
+	type CM_IGAM_LUT_RW_MODE; \
+	type CM_IGAM_LUT_WRITE_EN_MASK; \
+	type CM_IGAM_LUT_SEL; \
+	type CM_IGAM_LUT_SEQ_COLOR; \
+	type CM_IGAM_DGAM_CONFIG_STATUS; \
+	type CM_DGAM_LUT_WRITE_EN_MASK; \
+	type CM_DGAM_LUT_WRITE_SEL; \
+	type CM_DGAM_LUT_INDEX; \
+	type CM_DGAM_LUT_DATA; \
+	type CM_BYPASS_EN; \
+	type CM_BYPASS; \
 	type CNVC_SURFACE_PIXEL_FORMAT; \
 	type CNVC_BYPASS; \
 	type ALPHA_EN; \
 	type FORMAT_EXPANSION_MODE; \
+	type CM_DGAM_LUT_MODE; \
+	type CM_IGAM_LUT_MODE; \
 	type CURSOR0_DST_Y_OFFSET; \
 	type CURSOR0_CHUNK_HDL_ADJUST; \
 	type CUR0_MODE; \
@@ -108,6 +460,7 @@
 	type CURSOR_HOT_SPOT_X; \
 	type CURSOR_HOT_SPOT_Y; \
 	type CURSOR_DST_X_OFFSET; \
+	type CM_IGAM_INPUT_FORMAT; \
 	type OUTPUT_FP
 
 struct dcn10_ipp_shift {
@@ -119,6 +472,69 @@ struct dcn10_ipp_mask {
 };
 
 struct dcn10_ipp_registers {
+	uint32_t CM_ICSC_CONTROL;
+	uint32_t CM_ICSC_C11_C12;
+	uint32_t CM_ICSC_C13_C14;
+	uint32_t CM_ICSC_C21_C22;
+	uint32_t CM_ICSC_C23_C24;
+	uint32_t CM_ICSC_C31_C32;
+	uint32_t CM_ICSC_C33_C34;
+	uint32_t CM_COMA_C11_C12;
+	uint32_t CM_COMA_C13_C14;
+	uint32_t CM_COMA_C21_C22;
+	uint32_t CM_COMA_C23_C24;
+	uint32_t CM_COMA_C31_C32;
+	uint32_t CM_COMA_C33_C34;
+	uint32_t CM_DGAM_RAMB_START_CNTL_B;
+	uint32_t CM_DGAM_RAMB_START_CNTL_G;
+	uint32_t CM_DGAM_RAMB_START_CNTL_R;
+	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_B;
+	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_G;
+	uint32_t CM_DGAM_RAMB_SLOPE_CNTL_R;
+	uint32_t CM_DGAM_RAMB_END_CNTL1_B;
+	uint32_t CM_DGAM_RAMB_END_CNTL2_B;
+	uint32_t CM_DGAM_RAMB_END_CNTL1_G;
+	uint32_t CM_DGAM_RAMB_END_CNTL2_G;
+	uint32_t CM_DGAM_RAMB_END_CNTL1_R;
+	uint32_t CM_DGAM_RAMB_END_CNTL2_R;
+	uint32_t CM_DGAM_RAMB_REGION_0_1;
+	uint32_t CM_DGAM_RAMB_REGION_2_3;
+	uint32_t CM_DGAM_RAMB_REGION_4_5;
+	uint32_t CM_DGAM_RAMB_REGION_6_7;
+	uint32_t CM_DGAM_RAMB_REGION_8_9;
+	uint32_t CM_DGAM_RAMB_REGION_10_11;
+	uint32_t CM_DGAM_RAMB_REGION_12_13;
+	uint32_t CM_DGAM_RAMB_REGION_14_15;
+	uint32_t CM_DGAM_RAMA_START_CNTL_B;
+	uint32_t CM_DGAM_RAMA_START_CNTL_G;
+	uint32_t CM_DGAM_RAMA_START_CNTL_R;
+	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_B;
+	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_G;
+	uint32_t CM_DGAM_RAMA_SLOPE_CNTL_R;
+	uint32_t CM_DGAM_RAMA_END_CNTL1_B;
+	uint32_t CM_DGAM_RAMA_END_CNTL2_B;
+	uint32_t CM_DGAM_RAMA_END_CNTL1_G;
+	uint32_t CM_DGAM_RAMA_END_CNTL2_G;
+	uint32_t CM_DGAM_RAMA_END_CNTL1_R;
+	uint32_t CM_DGAM_RAMA_END_CNTL2_R;
+	uint32_t CM_DGAM_RAMA_REGION_0_1;
+	uint32_t CM_DGAM_RAMA_REGION_2_3;
+	uint32_t CM_DGAM_RAMA_REGION_4_5;
+	uint32_t CM_DGAM_RAMA_REGION_6_7;
+	uint32_t CM_DGAM_RAMA_REGION_8_9;
+	uint32_t CM_DGAM_RAMA_REGION_10_11;
+	uint32_t CM_DGAM_RAMA_REGION_12_13;
+	uint32_t CM_DGAM_RAMA_REGION_14_15;
+	uint32_t CM_MEM_PWR_CTRL;
+	uint32_t CM_IGAM_LUT_RW_CONTROL;
+	uint32_t CM_IGAM_LUT_RW_INDEX;
+	uint32_t CM_IGAM_LUT_SEQ_COLOR;
+	uint32_t CM_DGAM_LUT_WRITE_EN_MASK;
+	uint32_t CM_DGAM_LUT_INDEX;
+	uint32_t CM_DGAM_LUT_DATA;
+	uint32_t CM_CONTROL;
+	uint32_t CM_DGAM_CONTROL;
+	uint32_t CM_IGAM_CONTROL;
 	uint32_t DPP_CONTROL;
 	uint32_t CURSOR_SETTINS;
 	uint32_t CURSOR_SETTINGS;
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
index 9008cd0..f36585d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.c
@@ -51,19 +51,12 @@ static void min10_set_blank(struct mem_input *mem_input, bool blank)
 		REG_WAIT(DCHUBP_CNTL,
 				HUBP_NO_OUTSTANDING_REQ, 1,
 				1, 200);
+		/*todo: unhack this
 		mem_input->mpcc_id = 0xf;
-		mem_input->opp_id = 0xf;
+		mem_input->opp_id = 0xf;*/
 	}
 }
 
-static void min10_set_hubp_blank_en(struct mem_input *mem_input, bool blank)
-{
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
-	uint32_t blank_en = blank ? 1 : 0;
-
-	REG_UPDATE(DCHUBP_CNTL, HUBP_BLANK_EN, blank_en);
-}
-
 static void min10_vready_workaround(struct mem_input *mem_input,
 		struct _vcs_dpi_display_pipe_dest_params_st *pipe_dest)
 {
@@ -632,10 +625,38 @@ static bool min10_is_flip_pending(struct mem_input *mem_input)
 	return false;
 }
 
-static void min10_set_vm_system_aperture_settings(struct mem_input *mem_input,
+struct vm_system_aperture_param {
+	PHYSICAL_ADDRESS_LOC sys_default;
+	PHYSICAL_ADDRESS_LOC sys_low;
+	PHYSICAL_ADDRESS_LOC sys_high;
+};
+
+static void min10_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
+		struct vm_system_aperture_param *apt)
+{
+	PHYSICAL_ADDRESS_LOC physical_page_number;
+	uint32_t logical_addr_low;
+	uint32_t logical_addr_high;
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,
+			PHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,
+			PHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,
+			LOGICAL_ADDR, &logical_addr_low);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,
+			LOGICAL_ADDR, &logical_addr_high);
+
+	apt->sys_default.quad_part =  physical_page_number.quad_part << 12;
+	apt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;
+	apt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;
+}
+
+static void min10_set_vm_system_aperture_settings(struct dcn10_mem_input *mi,
 		struct vm_system_aperture_param *apt)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
 	PHYSICAL_ADDRESS_LOC mc_vm_apt_default;
 	PHYSICAL_ADDRESS_LOC mc_vm_apt_low;
 	PHYSICAL_ADDRESS_LOC mc_vm_apt_high;
@@ -661,10 +682,60 @@ static void min10_set_vm_system_aperture_settings(struct mem_input *mem_input,
 			MC_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, mc_vm_apt_high.low_part);
 }
 
-static void min10_set_vm_context0_settings(struct mem_input *mem_input,
+struct vm_context0_param {
+	PHYSICAL_ADDRESS_LOC pte_base;
+	PHYSICAL_ADDRESS_LOC pte_start;
+	PHYSICAL_ADDRESS_LOC pte_end;
+	PHYSICAL_ADDRESS_LOC fault_default;
+};
+
+/* Temporary read settings, future will get values from kmd directly */
+static void min10_read_vm_context0_settings(struct dcn10_mem_input *mi,
+		struct vm_context0_param *vm0)
+{
+	PHYSICAL_ADDRESS_LOC fb_base;
+	PHYSICAL_ADDRESS_LOC fb_offset;
+	uint32_t fb_base_value;
+	uint32_t fb_offset_value;
+
+	REG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);
+	REG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,
+			PAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,
+			PAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);
+
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,
+			PHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,
+			PHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);
+
+	/*
+	 * The values in VM_CONTEXT0_PAGE_TABLE_BASE_ADDR is in UMA space.
+	 * Therefore we need to do
+	 * DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
+	 * - DCHUBBUB_SDPIF_FB_OFFSET + DCHUBBUB_SDPIF_FB_BASE
+	 */
+	fb_base.quad_part = (uint64_t)fb_base_value << 24;
+	fb_offset.quad_part = (uint64_t)fb_offset_value << 24;
+	vm0->pte_base.quad_part += fb_base.quad_part;
+	vm0->pte_base.quad_part -= fb_offset.quad_part;
+}
+
+static void min10_set_vm_context0_settings(struct dcn10_mem_input *mi,
 		const struct vm_context0_param *vm0)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
 	/* pte base */
 	REG_SET(DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, 0,
 			VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_MSB, vm0->pte_base.high_part);
@@ -689,6 +760,23 @@ static void min10_set_vm_context0_settings(struct mem_input *mem_input,
 	/* VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_SYSTEM, 0 */
 	REG_SET(DCN_VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, 0,
 			VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR_LSB, vm0->fault_default.low_part);
+}
+
+static void min10_program_pte_vm(struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct vm_system_aperture_param apt = { {{ 0 } } };
+	struct vm_context0_param vm0 = { { { 0 } } };
+
+
+	min10_read_vm_system_aperture_settings(mi, &apt);
+	min10_read_vm_context0_settings(mi, &vm0);
+
+	min10_set_vm_system_aperture_settings(mi, &apt);
+	min10_set_vm_context0_settings(mi, &vm0);
 
 	/* control: enable VM PTE*/
 	REG_SET_2(DCN_VM_MX_L1_TLB_CNTL, 0,
@@ -774,12 +862,10 @@ static struct mem_input_funcs dcn10_mem_input_funcs = {
 			min10_program_surface_config,
 	.mem_input_is_flip_pending = min10_is_flip_pending,
 	.mem_input_setup = min10_setup,
-	.mem_input_set_vm_system_aperture_settings = min10_set_vm_system_aperture_settings,
-	.mem_input_set_vm_context0_settings = min10_set_vm_context0_settings,
+	.mem_input_program_pte_vm = min10_program_pte_vm,
 	.set_blank = min10_set_blank,
 	.dcc_control = min10_dcc_control,
 	.mem_program_viewport = min_set_viewport,
-	.set_hubp_blank_en = min10_set_hubp_blank_en,
 };
 
 /*****************************************/
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
index acee051..b3ec16c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mem_input.h
@@ -97,7 +97,20 @@
 	SRI(DCN_SURF0_TTU_CNTL1, HUBPREQ, id),\
 	SRI(DCN_SURF1_TTU_CNTL0, HUBPREQ, id),\
 	SRI(DCN_SURF1_TTU_CNTL1, HUBPREQ, id),\
-	SRI(DCN_VM_MX_L1_TLB_CNTL, HUBPREQ, id)
+	SRI(DCN_VM_MX_L1_TLB_CNTL, HUBPREQ, id),\
+	/* todo:  get these from GVM instead of reading registers ourselves */\
+	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32),\
+	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32),\
+	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32),\
+	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32),\
+	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32),\
+	MMHUB_SR(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32),\
+	MMHUB_SR(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32),\
+	MMHUB_SR(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32),\
+	MMHUB_SR(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB),\
+	MMHUB_SR(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB),\
+	MMHUB_SR(MC_VM_SYSTEM_APERTURE_LOW_ADDR),\
+	MMHUB_SR(MC_VM_SYSTEM_APERTURE_HIGH_ADDR)
 
 #define MI_REG_LIST_DCN10(id)\
 	MI_REG_LIST_DCN(id),\
@@ -215,6 +228,20 @@ struct dcn_mi_registers {
 	uint32_t DCN_VM_AGP_BASE;
 	uint32_t DCN_VM_AGP_BOT;
 	uint32_t DCN_VM_AGP_TOP;
+
+	/* GC registers. read only. temporary hack */
+	uint32_t VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32;
+	uint32_t VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32;
+	uint32_t VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32;
+	uint32_t VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32;
+	uint32_t MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB;
+	uint32_t MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB;
+	uint32_t MC_VM_SYSTEM_APERTURE_LOW_ADDR;
+	uint32_t MC_VM_SYSTEM_APERTURE_HIGH_ADDR;
 };
 
 #define MI_SF(reg_name, field_name, post_fix)\
@@ -360,7 +387,17 @@ struct dcn_mi_registers {
 	MI_SF(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, mask_sh),\
 	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, MC_VM_SYSTEM_APERTURE_DEFAULT_SYSTEM, mask_sh),\
 	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, mask_sh),\
-	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, mask_sh)
+	MI_SF(HUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, mask_sh),\
+	/* todo:  get these from GVM instead of reading registers ourselves */\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32, PAGE_DIRECTORY_ENTRY_HI32, mask_sh),\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32, PAGE_DIRECTORY_ENTRY_LO32, mask_sh),\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32, LOGICAL_PAGE_NUMBER_HI4, mask_sh),\
+	MI_SF(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32, LOGICAL_PAGE_NUMBER_LO32, mask_sh),\
+	MI_SF(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32, PHYSICAL_PAGE_ADDR_HI4, mask_sh),\
+	MI_SF(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32, PHYSICAL_PAGE_ADDR_LO32, mask_sh),\
+	MI_SF(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, PHYSICAL_PAGE_NUMBER_MSB, mask_sh),\
+	MI_SF(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, PHYSICAL_PAGE_NUMBER_LSB, mask_sh),\
+	MI_SF(MC_VM_SYSTEM_APERTURE_LOW_ADDR, LOGICAL_ADDR, mask_sh)
 
 #define DCN_MI_REG_FIELD_LIST(type) \
 	type HUBP_BLANK_EN;\
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 082b39a..52f2f2d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -127,18 +127,10 @@ static void mpc10_mpcc_remove(
 	for (z_idx = 0; z_idx < opp->mpc_tree.num_pipes; z_idx++)
 		if (opp->mpc_tree.dpp[z_idx] == dpp_id)
 			break;
-
 	if (z_idx == opp->mpc_tree.num_pipes) {
-		/* In case of resume from S3/S4, remove mpcc from bios left over */
-		REG_SET(MPCC_OPP_ID[dpp_id], 0,
-				MPCC_OPP_ID, 0xf);
-		REG_SET(MPCC_TOP_SEL[dpp_id], 0,
-				MPCC_TOP_SEL, 0xf);
-		REG_SET(MPCC_BOT_SEL[dpp_id], 0,
-				MPCC_BOT_SEL, 0xf);
+		ASSERT(0);
 		return;
 	}
-
 	mpcc_id = opp->mpc_tree.mpcc[z_idx];
 
 	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
@@ -237,9 +229,9 @@ static void mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 	mpc10_set_bg_color(mpc10, &cfg->black_color, mpcc_id);
 
 	mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
-	for (z_idx = cfg->opp->mpc_tree.num_pipes; z_idx > cfg->z_index; z_idx--) {
-		cfg->opp->mpc_tree.dpp[z_idx] = cfg->opp->mpc_tree.dpp[z_idx - 1];
-		cfg->opp->mpc_tree.mpcc[z_idx] = cfg->opp->mpc_tree.mpcc[z_idx - 1];
+	for (z_idx = cfg->z_index; z_idx < cfg->opp->mpc_tree.num_pipes; z_idx++) {
+		cfg->opp->mpc_tree.dpp[z_idx + 1] = cfg->opp->mpc_tree.dpp[z_idx];
+		cfg->opp->mpc_tree.mpcc[z_idx + 1] = cfg->opp->mpc_tree.mpcc[z_idx];
 	}
 	cfg->opp->mpc_tree.dpp[cfg->z_index] = cfg->mi->inst;
 	cfg->opp->mpc_tree.mpcc[cfg->z_index] = mpcc_id;
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
index fff86ad..6006fb4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c
@@ -32,7 +32,6 @@
 
 #include "dcn10/dcn10_ipp.h"
 #include "dcn10/dcn10_mpc.h"
-#include "dcn10/dcn10_dwb.h"
 #include "irq/dcn10/irq_service_dcn10.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_timing_generator.h"
@@ -48,7 +47,6 @@
 #include "dce/dce_hwseq.h"
 #include "../virtual/virtual_stream_encoder.h"
 #include "dce110/dce110_resource.h"
-#include "dce112/dce112_resource.h"
 
 #include "vega10/soc15ip.h"
 
@@ -412,7 +410,6 @@ static const struct resource_caps res_cap = {
 		.num_audio = 4,
 		.num_stream_encoder = 4,
 		.num_pll = 4,
-		.num_dwb = 2,
 };
 
 static const struct dc_debug debug_defaults_drv = {
@@ -422,10 +419,6 @@ static const struct dc_debug debug_defaults_drv = {
 		.force_abm_enable = false,
 		.timing_trace = false,
 		.clock_trace = true,
-		/* spread sheet doesn't handle taps_c is one properly,
-		 * need to enable scaler for video surface to pass
-		 * bandwidth validation.*/
-		.always_scale = true,
 		.disable_pplib_clock_request = true,
 		.disable_pplib_wm_range = false,
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -439,7 +432,6 @@ static const struct dc_debug debug_defaults_diags = {
 		.force_abm_enable = false,
 		.timing_trace = true,
 		.clock_trace = true,
-		.disable_stutter = true,
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 		.disable_pplib_clock_request = true,
 		.disable_pplib_wm_range = true,
@@ -684,17 +676,6 @@ void dcn10_clock_source_destroy(struct clock_source **clk_src)
 	*clk_src = NULL;
 }
 
-static struct pp_smu_funcs_rv *dcn10_pp_smu_create(struct dc_context *ctx)
-{
-	struct pp_smu_funcs_rv *pp_smu = dm_alloc(sizeof(*pp_smu));
-
-	if (!pp_smu)
-		return pp_smu;
-
-	dm_pp_get_funcs_rv(ctx, pp_smu);
-	return pp_smu;
-}
-
 static void destruct(struct dcn10_resource_pool *pool)
 {
 	unsigned int i;
@@ -748,11 +729,6 @@ static void destruct(struct dcn10_resource_pool *pool)
 			dce_aud_destroy(&pool->base.audios[i]);
 	}
 
-	for (i = 0; i < pool->base.res_cap->num_dwb; i++) {
-		dm_free(pool->base.dwbc[i]);
-		pool->base.dwbc[i] = NULL;
-	}
-
 	for (i = 0; i < pool->base.clk_src_count; i++) {
 		if (pool->base.clock_sources[i] != NULL) {
 			dcn10_clock_source_destroy(&pool->base.clock_sources[i]);
@@ -773,8 +749,6 @@ static void destruct(struct dcn10_resource_pool *pool)
 
 	if (pool->base.display_clock != NULL)
 		dce_disp_clk_destroy(&pool->base.display_clock);
-
-	dm_free(pool->base.pp_smu);
 }
 
 static struct mem_input *dcn10_mem_input_create(
@@ -849,17 +823,19 @@ static enum dc_status build_pipe_hw_param(struct pipe_ctx *pipe_ctx)
 }
 
 static enum dc_status build_mapped_resource(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	enum dc_status status = DC_OK;
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
+	uint8_t i, j;
+
+	for (i = 0; i < context->stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
 
-	/*TODO Seems unneeded anymore */
-	/*	if (old_context && resource_is_stream_unchanged(old_context, stream)) {
+		if (old_context && resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
-				 todo: shouldn't have to copy missing parameter here
+				/* todo: shouldn't have to copy missing parameter here */
 				resource_build_bit_depth_reduction_params(stream,
 						&stream->bit_depth_params);
 				stream->clamping.pixel_encoding =
@@ -872,42 +848,76 @@ static enum dc_status build_mapped_resource(
 				continue;
 			}
 		}
-	*/
 
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
+		for (j = 0; j < dc->res_pool->pipe_count ; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
+
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
+
+			status = build_pipe_hw_param(pipe_ctx);
 
-	status = build_pipe_hw_param(pipe_ctx);
+			if (status != DC_OK)
+				return status;
 
-	if (status != DC_OK)
-		return status;
+			/* do not need to validate non root pipes */
+			break;
+		}
+	}
 
 	return DC_OK;
 }
 
-enum dc_status dcn10_add_stream_to_ctx(
-		struct dc *dc,
-		struct dc_state *new_ctx,
-		struct dc_stream_state *dc_stream)
+enum dc_status dcn10_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
-	enum dc_status result = DC_ERROR_UNEXPECTED;
+	enum dc_status result = DC_OK;
+	int i;
 
-	result = resource_map_pool_resources(dc, new_ctx, dc_stream);
+	if (set_count == 0)
+		return result;
 
-	if (result == DC_OK)
-		result = resource_map_phy_clock_resources(dc, new_ctx, dc_stream);
+	for (i = 0; i < set_count; i++) {
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
+		context->stream_count++;
+	}
 
+	result = resource_map_pool_resources(dc, context, old_context);
+	if (result != DC_OK)
+		return result;
 
-	if (result == DC_OK)
-		result = build_mapped_resource(dc, new_ctx, dc_stream);
+	result = resource_map_phy_clock_resources(dc, context, old_context);
+	if (result != DC_OK)
+		return result;
+
+	result = build_mapped_resource(dc, context, old_context);
+	if (result != DC_OK)
+		return result;
+
+	if (!resource_validate_attach_surfaces(set, set_count,
+			old_context, context, dc->res_pool))
+		return DC_FAIL_ATTACH_SURFACES;
+
+	result = resource_build_scaling_params_for_context(dc, context);
+	if (result != DC_OK)
+		return result;
+
+	if (!dcn_validate_bandwidth(dc, context))
+		return DC_FAIL_BANDWIDTH_VALIDATE;
 
 	return result;
 }
 
 enum dc_status dcn10_validate_guaranteed(
-		struct dc *dc,
+		const struct core_dc *dc,
 		struct dc_stream_state *dc_stream,
-		struct dc_state *context)
+		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
@@ -915,17 +925,17 @@ enum dc_status dcn10_validate_guaranteed(
 	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context, dc_stream);
+	result = resource_map_pool_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = resource_map_phy_clock_resources(dc, context, dc_stream);
+		result = resource_map_phy_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, dc_stream);
+		result = build_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
-				context, dc->caps.max_streams);
+				context, dc->public.caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 	if (result == DC_OK && !dcn_validate_bandwidth(dc, context))
@@ -935,7 +945,7 @@ enum dc_status dcn10_validate_guaranteed(
 }
 
 static struct pipe_ctx *dcn10_acquire_idle_pipe_for_layer(
-		struct dc_state *context,
+		struct validate_context *context,
 		const struct resource_pool *pool,
 		struct dc_stream_state *stream)
 {
@@ -1201,15 +1211,15 @@ static struct dc_cap_funcs cap_funcs = {
 static struct resource_funcs dcn10_res_pool_funcs = {
 	.destroy = dcn10_destroy_resource_pool,
 	.link_enc_create = dcn10_link_encoder_create,
+	.validate_with_context = dcn10_validate_with_context,
 	.validate_guaranteed = dcn10_validate_guaranteed,
 	.validate_bandwidth = dcn_validate_bandwidth,
 	.acquire_idle_pipe_for_layer = dcn10_acquire_idle_pipe_for_layer,
-	.add_stream_to_ctx = dcn10_add_stream_to_ctx
 };
 
 static bool construct(
 	uint8_t num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct dcn10_resource_pool *pool)
 {
 	int i;
@@ -1232,16 +1242,16 @@ static bool construct(
 
 	/* TODO: Hardcode to correct number of functional controllers */
 	pool->base.pipe_count = 4;
-	dc->caps.max_downscale_ratio = 200;
-	dc->caps.i2c_speed_in_khz = 100;
-	dc->caps.max_cursor_size = 256;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 100;
+	dc->public.caps.max_cursor_size = 256;
 
-	dc->caps.max_slave_planes = 1;
+	dc->public.caps.max_slave_planes = 1;
 
 	if (dc->ctx->dce_environment == DCE_ENV_PRODUCTION_DRV)
-		dc->debug = debug_defaults_drv;
+		dc->public.debug = debug_defaults_drv;
 	else
-		dc->debug = debug_defaults_diags;
+		dc->public.debug = debug_defaults_diags;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1310,40 +1320,36 @@ static bool construct(
 	}
 
 	dml_init_instance(&dc->dml, DML_PROJECT_RAVEN1);
-	memcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults));
-	memcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults));
+	dc->dcn_ip = dcn10_ip_defaults;
+	dc->dcn_soc = dcn10_soc_defaults;
 
 	if (ASICREV_IS_RV1_F0(dc->ctx->asic_id.hw_internal_rev)) {
-		dc->dcn_soc->urgent_latency = 3;
-		dc->debug.disable_dmcu = true;
-		dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 41.60f;
+		dc->dcn_soc.urgent_latency = 3;
+		dc->public.debug.disable_dmcu = true;
+		dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9 = 41.60f;
 	}
 
 
-	dc->dcn_soc->number_of_channels = dc->ctx->asic_id.vram_width / ddr4_dram_width;
-	ASSERT(dc->dcn_soc->number_of_channels < 3);
-	if (dc->dcn_soc->number_of_channels == 0)/*old sbios bug*/
-		dc->dcn_soc->number_of_channels = 2;
+	dc->dcn_soc.number_of_channels = dc->ctx->asic_id.vram_width / ddr4_dram_width;
+	ASSERT(dc->dcn_soc.number_of_channels < 3);
+	if (dc->dcn_soc.number_of_channels == 0)/*old sbios bug*/
+		dc->dcn_soc.number_of_channels = 2;
 
-	if (dc->dcn_soc->number_of_channels == 1) {
-		dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 19.2f;
-		dc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 = 17.066f;
-		dc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 = 14.933f;
-		dc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 = 12.8f;
+	if (dc->dcn_soc.number_of_channels == 1) {
+		dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9 = 19.2f;
+		dc->dcn_soc.fabric_and_dram_bandwidth_vnom0p8 = 17.066f;
+		dc->dcn_soc.fabric_and_dram_bandwidth_vmid0p72 = 14.933f;
+		dc->dcn_soc.fabric_and_dram_bandwidth_vmin0p65 = 12.8f;
 		if (ASICREV_IS_RV1_F0(dc->ctx->asic_id.hw_internal_rev)) {
-			dc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 = 20.80f;
+			dc->dcn_soc.fabric_and_dram_bandwidth_vmax0p9 = 20.80f;
 		}
 	}
 
-	pool->base.pp_smu = dcn10_pp_smu_create(ctx);
-
-	if (!dc->debug.disable_pplib_clock_request)
+	if (!dc->public.debug.disable_pplib_clock_request)
 		dcn_bw_update_from_pplib(dc);
 	dcn_bw_sync_calcs_and_dml(dc);
-	if (!dc->debug.disable_pplib_wm_range) {
-		dc->res_pool = &pool->base;
+	if (!dc->public.debug.disable_pplib_wm_range)
 		dcn_bw_notify_pplib_of_wm_ranges(dc);
-	}
 
 	{
 	#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -1404,21 +1410,15 @@ static bool construct(
 		goto mpc_create_fail;
 	}
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (!dcn10_dwbc_create(ctx, &pool->base)) {
-		goto dwbc_create_fail;
-	}
-#endif
-
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			(!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment) ?
 			&res_create_funcs : &res_create_maximus_funcs)))
 			goto res_create_fail;
 
 	dcn10_hw_sequencer_construct(dc);
-	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
-	dc->cap_funcs = cap_funcs;
+	dc->public.cap_funcs = cap_funcs;
 
 	return true;
 
@@ -1432,7 +1432,6 @@ static bool construct(
 irqs_create_fail:
 res_create_fail:
 clock_source_create_fail:
-dwbc_create_fail:
 
 	destruct(pool);
 
@@ -1441,7 +1440,7 @@ static bool construct(
 
 struct resource_pool *dcn10_create_resource_pool(
 		uint8_t num_virtual_links,
-		struct dc *dc)
+		struct core_dc *dc)
 {
 	struct dcn10_resource_pool *pool =
 		dm_alloc(sizeof(struct dcn10_resource_pool));
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h
index 8f71225..5f84dbd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.h
@@ -31,7 +31,7 @@
 #define TO_DCN10_RES_POOL(pool)\
 	container_of(pool, struct dcn10_resource_pool, base)
 
-struct dc;
+struct core_dc;
 struct resource_pool;
 struct _vcs_dpi_display_pipe_params_st;
 
@@ -40,7 +40,7 @@ struct dcn10_resource_pool {
 };
 struct resource_pool *dcn10_create_resource_pool(
 		uint8_t num_virtual_links,
-		struct dc *dc);
+		struct core_dc *dc);
 
 
 #endif /* __DC_RESOURCE_DCN10_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c
index 15f1f44..941e012 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.c
@@ -118,7 +118,6 @@ static void tgn10_program_timing(
 	uint32_t start_point = 0;
 	uint32_t field_num = 0;
 	uint32_t h_div_2;
-	uint32_t vertial_line_start;
 
 	struct dcn10_timing_generator *tgn10 = DCN10TG_FROM_TG(tg);
 
@@ -213,12 +212,6 @@ static void tgn10_program_timing(
 			OTG_V_BLANK_START, asic_blank_start,
 			OTG_V_BLANK_END, asic_blank_end);
 
-	/* Use OTG_VERTICAL_INTERRUPT2 replace VUPDATE interrupt,
-	 * program the reg for interrupt postition.
-	 */
-	vertial_line_start = asic_blank_end - tg->dlg_otg_param.vstartup_start + 1;
-	REG_SET(OTG_VERTICAL_INTERRUPT2_POSITION, 0,
-			OTG_VERTICAL_INTERRUPT2_LINE_START, vertial_line_start);
 
 	/* v_sync polarity */
 	v_sync_polarity = patched_crtc_timing.flags.VSYNC_POSITIVE_POLARITY ?
@@ -1097,48 +1090,6 @@ static bool tgn10_is_stereo_left_eye(struct timing_generator *tg)
 	return ret;
 }
 
-void tgn10_read_otg_state(struct dcn10_timing_generator *tgn10,
-		struct dcn_otg_state *s)
-{
-	REG_GET_2(OTG_V_BLANK_START_END,
-			OTG_V_BLANK_START, &s->v_blank_start,
-			OTG_V_BLANK_END, &s->v_blank_end);
-
-	REG_GET(OTG_V_SYNC_A_CNTL,
-			OTG_V_SYNC_A_POL, &s->v_sync_a_pol);
-
-	REG_GET(OTG_V_TOTAL,
-			OTG_V_TOTAL, &s->v_total);
-
-	REG_GET(OTG_V_TOTAL_MAX,
-			OTG_V_TOTAL_MAX, &s->v_total_max);
-
-	REG_GET(OTG_V_TOTAL_MIN,
-			OTG_V_TOTAL_MIN, &s->v_total_min);
-
-	REG_GET_2(OTG_V_SYNC_A,
-			OTG_V_SYNC_A_START, &s->v_sync_a_start,
-			OTG_V_SYNC_A_END, &s->v_sync_a_end);
-
-	REG_GET_2(OTG_H_BLANK_START_END,
-			OTG_H_BLANK_START, &s->h_blank_start,
-			OTG_H_BLANK_END, &s->h_blank_end);
-
-	REG_GET_2(OTG_H_SYNC_A,
-			OTG_H_SYNC_A_START, &s->h_sync_a_start,
-			OTG_H_SYNC_A_END, &s->h_sync_a_end);
-
-	REG_GET(OTG_H_SYNC_A_CNTL,
-			OTG_H_SYNC_A_POL, &s->h_sync_a_pol);
-
-	REG_GET(OTG_H_TOTAL,
-			OTG_H_TOTAL, &s->h_total);
-
-	REG_GET(OPTC_INPUT_GLOBAL_CONTROL,
-			OPTC_UNDERFLOW_OCCURRED_STATUS, &s->underflow_occurred_status);
-}
-
-
 static struct timing_generator_funcs dcn10_tg_funcs = {
 		.validate_timing = tgn10_validate_timing,
 		.program_timing = tgn10_program_timing,
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h
index 38d3dcf..747e821 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_timing_generator.h
@@ -65,10 +65,8 @@
 	SRI(OTG_NOM_VERT_POSITION, OTG, inst),\
 	SRI(OTG_BLACK_COLOR, OTG, inst),\
 	SRI(OTG_CLOCK_CONTROL, OTG, inst),\
-	SRI(OTG_VERTICAL_INTERRUPT2_POSITION, OTG, inst),\
 	SRI(OPTC_INPUT_CLOCK_CONTROL, ODM, inst),\
 	SRI(OPTC_DATA_SOURCE_SELECT, ODM, inst),\
-	SRI(OPTC_INPUT_GLOBAL_CONTROL, ODM, inst),\
 	SRI(OPPBUF_CONTROL, OPPBUF, inst),\
 	SRI(OPPBUF_3D_PARAMETERS_0, OPPBUF, inst),\
 	SRI(CONTROL, VTG, inst),\
@@ -121,10 +119,8 @@ struct dcn_tg_registers {
 	uint32_t OTG_TEST_PATTERN_CONTROL;
 	uint32_t OTG_TEST_PATTERN_COLOR;
 	uint32_t OTG_CLOCK_CONTROL;
-	uint32_t OTG_VERTICAL_INTERRUPT2_POSITION;
 	uint32_t OPTC_INPUT_CLOCK_CONTROL;
 	uint32_t OPTC_DATA_SOURCE_SELECT;
-	uint32_t OPTC_INPUT_GLOBAL_CONTROL;
 	uint32_t OPPBUF_CONTROL;
 	uint32_t OPPBUF_3D_PARAMETERS_0;
 	uint32_t CONTROL;
@@ -205,11 +201,9 @@ struct dcn_tg_registers {
 	SF(OTG0_OTG_CLOCK_CONTROL, OTG_CLOCK_EN, mask_sh),\
 	SF(OTG0_OTG_CLOCK_CONTROL, OTG_CLOCK_ON, mask_sh),\
 	SF(OTG0_OTG_CLOCK_CONTROL, OTG_CLOCK_GATE_DIS, mask_sh),\
-	SF(OTG0_OTG_VERTICAL_INTERRUPT2_POSITION, OTG_VERTICAL_INTERRUPT2_LINE_START, mask_sh),\
 	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_EN, mask_sh),\
 	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_ON, mask_sh),\
 	SF(ODM0_OPTC_INPUT_CLOCK_CONTROL, OPTC_INPUT_CLK_GATE_DIS, mask_sh),\
-	SF(ODM0_OPTC_INPUT_GLOBAL_CONTROL, OPTC_UNDERFLOW_OCCURRED_STATUS, mask_sh),\
 	SF(OPPBUF0_OPPBUF_CONTROL, OPPBUF_ACTIVE_WIDTH, mask_sh),\
 	SF(OPPBUF0_OPPBUF_3D_PARAMETERS_0, OPPBUF_3D_VACT_SPACE1_SIZE, mask_sh),\
 	SF(VTG0_CONTROL, VTG0_ENABLE, mask_sh),\
@@ -311,13 +305,11 @@ struct dcn_tg_registers {
 	type OTG_CLOCK_EN;\
 	type OTG_CLOCK_ON;\
 	type OTG_CLOCK_GATE_DIS;\
-	type OTG_VERTICAL_INTERRUPT2_LINE_START;\
 	type OPTC_INPUT_CLK_EN;\
 	type OPTC_INPUT_CLK_ON;\
 	type OPTC_INPUT_CLK_GATE_DIS;\
 	type OPTC_SRC_SEL;\
 	type OPTC_SEG0_SRC_SEL;\
-	type OPTC_UNDERFLOW_OCCURRED_STATUS;\
 	type OPPBUF_ACTIVE_WIDTH;\
 	type OPPBUF_3D_VACT_SPACE1_SIZE;\
 	type VTG0_ENABLE;\
@@ -354,25 +346,4 @@ struct dcn10_timing_generator {
 
 void dcn10_timing_generator_init(struct dcn10_timing_generator *tg);
 
-struct dcn_otg_state {
-	uint32_t v_blank_start;
-	uint32_t v_blank_end;
-	uint32_t v_sync_a_pol;
-	uint32_t v_total;
-	uint32_t v_total_max;
-	uint32_t v_total_min;
-	uint32_t v_sync_a_start;
-	uint32_t v_sync_a_end;
-	uint32_t h_blank_start;
-	uint32_t h_blank_end;
-	uint32_t h_sync_a_start;
-	uint32_t h_sync_a_end;
-	uint32_t h_sync_a_pol;
-	uint32_t h_total;
-	uint32_t underflow_occurred_status;
-};
-
-void tgn10_read_otg_state(struct dcn10_timing_generator *tgn10,
-		struct dcn_otg_state *s);
-
 #endif /* __DC_TIMING_GENERATOR_DCN10_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/dm_helpers.h b/drivers/gpu/drm/amd/display/dc/dm_helpers.h
index ab88f07..3901032 100644
--- a/drivers/gpu/drm/amd/display/dc/dm_helpers.h
+++ b/drivers/gpu/drm/amd/display/dc/dm_helpers.h
@@ -96,6 +96,11 @@ bool dm_helpers_submit_i2c(
 		const struct dc_link *link,
 		struct i2c_command *cmd);
 
+
+
+
+
+
 enum dc_edid_status dm_helpers_read_local_edid(
 		struct dc_context *ctx,
 		struct dc_link *link,
diff --git a/drivers/gpu/drm/amd/display/dc/dm_pp_smu.h b/drivers/gpu/drm/amd/display/dc/dm_pp_smu.h
deleted file mode 100644
index bbfa832..0000000
--- a/drivers/gpu/drm/amd/display/dc/dm_pp_smu.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright 2017 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef DM_PP_SMU_IF__H
-#define DM_PP_SMU_IF__H
-
-/*
- * interface to PPLIB/SMU to setup clocks and pstate requirements on SoC
- */
-
-
-struct pp_smu {
-	struct dc_context *ctx;
-};
-
-enum wm_set_id {
-	WM_A,
-	WM_B,
-	WM_C,
-	WM_D,
-	WM_COUNT,
-};
-
-struct pp_smu_wm_set_range {
-	enum wm_set_id wm_inst;
-	uint32_t min_fill_clk_khz;
-	uint32_t max_fill_clk_khz;
-	uint32_t min_drain_clk_khz;
-	uint32_t max_drain_clk_khz;
-};
-
-struct pp_smu_wm_range_sets {
-	uint32_t num_reader_wm_sets;
-	struct pp_smu_wm_set_range reader_wm_sets[WM_COUNT];
-
-	uint32_t num_writer_wm_sets;
-	struct pp_smu_wm_set_range writer_wm_sets[WM_COUNT];
-};
-
-struct pp_smu_display_requirement_rv {
-	/* PPSMC_MSG_SetDisplayCount: count
-	 *  0 triggers S0i2 optimization
-	 */
-	unsigned int display_count;
-
-	/* PPSMC_MSG_SetHardMinFclkByFreq: khz
-	 *  FCLK will vary with DPM, but never below requested hard min
-	 */
-	unsigned int hard_min_fclk_khz;
-
-	/* PPSMC_MSG_SetHardMinDcefclkByFreq: khz
-	 *  fixed clock at requested freq, either from FCH bypass or DFS
-	 */
-	unsigned int hard_min_dcefclk_khz;
-
-	/* PPSMC_MSG_SetMinDeepSleepDcefclk: mhz
-	 *  when DF is in cstate, dcf clock is further divided down
-	 *  to just above given frequency
-	 */
-	unsigned int min_deep_sleep_dcefclk_mhz;
-};
-
-struct pp_smu_funcs_rv {
-	struct pp_smu pp_smu;
-
-	void (*set_display_requirement)(struct pp_smu *pp,
-			struct pp_smu_display_requirement_rv *req);
-
-	/* which SMU message?  are reader and writer WM separate SMU msg? */
-	void (*set_wm_ranges)(struct pp_smu *pp,
-			struct pp_smu_wm_range_sets *ranges);
-
-};
-
-#if 0
-struct pp_smu_funcs_rv {
-
-	/* PPSMC_MSG_SetDisplayCount
-	 *  0 triggers S0i2 optimization
-	 */
-	void (*set_display_count)(struct pp_smu *pp, int count);
-
-	/* PPSMC_MSG_SetHardMinFclkByFreq
-	 *  FCLK will vary with DPM, but never below requested hard min
-	 */
-	void (*set_hard_min_fclk_by_freq)(struct pp_smu *pp, int khz);
-
-	/* PPSMC_MSG_SetHardMinDcefclkByFreq
-	 *  fixed clock at requested freq, either from FCH bypass or DFS
-	 */
-	void (*set_hard_min_dcefclk_by_freq)(struct pp_smu *pp, int khz);
-
-	/* PPSMC_MSG_SetMinDeepSleepDcefclk
-	 *  when DF is in cstate, dcf clock is further divided down
-	 *  to just above given frequency
-	 */
-	void (*set_min_deep_sleep_dcefclk)(struct pp_smu *pp, int mhz);
-
-	/* todo: aesthetic
-	 * watermark range table
-	 */
-
-	/* todo: functional/feature
-	 * PPSMC_MSG_SetHardMinSocclkByFreq: required to support DWB
-	 */
-};
-#endif
-
-#endif /* DM_PP_SMU_IF__H */
diff --git a/drivers/gpu/drm/amd/display/dc/dm_services.h b/drivers/gpu/drm/amd/display/dc/dm_services.h
index 8ab0af6..a7d661d 100644
--- a/drivers/gpu/drm/amd/display/dc/dm_services.h
+++ b/drivers/gpu/drm/amd/display/dc/dm_services.h
@@ -75,9 +75,7 @@
 	BREAK_TO_DEBUGGER(); \
 } while (0)
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include <asm/fpu/api.h>
-#endif
 
 #define dm_alloc(size) kzalloc(size, GFP_KERNEL)
 #define dm_realloc(ptr, size) krealloc(ptr, size, GFP_KERNEL)
@@ -339,8 +337,9 @@ bool dm_pp_notify_wm_clock_changes(
 	const struct dc_context *ctx,
 	struct dm_pp_wm_sets_with_clock_ranges *wm_with_clock_ranges);
 
-void dm_pp_get_funcs_rv(struct dc_context *ctx,
-		struct pp_smu_funcs_rv *funcs);
+bool dm_pp_notify_wm_clock_changes_soc15(
+	const struct dc_context *ctx,
+	struct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges);
 
 /* DAL calls this function to notify PP about completion of Mode Set.
  * For PP it means that current DCE clocks are those which were returned
diff --git a/drivers/gpu/drm/amd/display/dc/dm_services_types.h b/drivers/gpu/drm/amd/display/dc/dm_services_types.h
index fa26cf4..4c04ec5 100644
--- a/drivers/gpu/drm/amd/display/dc/dm_services_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dm_services_types.h
@@ -29,8 +29,6 @@
 #include "os_types.h"
 #include "dc_types.h"
 
-#include "dm_pp_smu.h"
-
 struct dm_pp_clock_range {
 	int min_khz;
 	int max_khz;
diff --git a/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c b/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c
index 3c9608c..667660f 100644
--- a/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c
+++ b/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c
@@ -69,12 +69,6 @@ bool dal_aux_engine_acquire(
 	struct aux_engine *aux_engine = FROM_ENGINE(engine);
 
 	enum gpio_result result;
-	if (aux_engine->funcs->is_engine_available) {
-		/*check whether SW could use the engine*/
-		if (!aux_engine->funcs->is_engine_available(aux_engine)) {
-			return false;
-		}
-	}
 
 	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
 		GPIO_DDC_CONFIG_TYPE_MODE_AUX);
diff --git a/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.h b/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.h
index 40b2028..b5d6c79 100644
--- a/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.h
+++ b/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.h
@@ -86,8 +86,6 @@ struct aux_engine_funcs {
 	enum aux_channel_operation_result (*get_channel_status)(
 		struct aux_engine *engine,
 		uint8_t *returned_bytes);
-	bool (*is_engine_available) (
-		struct aux_engine *engine);
 };
 
 struct aux_engine {
diff --git a/drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c b/drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
index 98ce0fe..f49fd1a 100644
--- a/drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
+++ b/drivers/gpu/drm/amd/display/dc/i2caux/dce110/aux_engine_dce110.c
@@ -93,36 +93,15 @@ static void destroy(
 }
 
 #define SW_CAN_ACCESS_AUX 1
-#define DMCU_CAN_ACCESS_AUX 2
 
-static bool is_engine_available(
-	struct aux_engine *engine)
-{
-	struct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);
-
-	uint32_t value = REG_READ(AUX_ARB_CONTROL);
-	uint32_t field = get_reg_field_value(
-			value,
-			AUX_ARB_CONTROL,
-			AUX_REG_RW_CNTL_STATUS);
-
-	return (field != DMCU_CAN_ACCESS_AUX);
-}
 static bool acquire_engine(
 	struct aux_engine *engine)
 {
 	struct aux_engine_dce110 *aux110 = FROM_AUX_ENGINE(engine);
 
-	uint32_t value = REG_READ(AUX_ARB_CONTROL);
-	uint32_t field = get_reg_field_value(
-			value,
-			AUX_ARB_CONTROL,
-			AUX_REG_RW_CNTL_STATUS);
-	if (field == DMCU_CAN_ACCESS_AUX)
-	 return false;
 	/* enable AUX before request SW to access AUX */
-	value = REG_READ(AUX_CONTROL);
-	field = get_reg_field_value(value,
+	uint32_t value = REG_READ(AUX_CONTROL);
+	uint32_t field = get_reg_field_value(value,
 				AUX_CONTROL,
 				AUX_EN);
 
@@ -416,7 +395,6 @@ static const struct aux_engine_funcs aux_engine_funcs = {
 	.submit_channel_request = submit_channel_request,
 	.process_channel_reply = process_channel_reply,
 	.get_channel_status = get_channel_status,
-	.is_engine_available = is_engine_available,
 };
 
 static const struct engine_funcs engine_funcs = {
@@ -447,10 +425,6 @@ static bool construct(
 static void destruct(
 	struct aux_engine_dce110 *engine)
 {
-	struct aux_engine_dce110 *aux110 = engine;
-/*temp w/a, to do*/
-	REG_UPDATE(AUX_ARB_CONTROL, AUX_DMCU_DONE_USING_AUX_REG, 1);
-	REG_UPDATE(AUX_ARB_CONTROL, AUX_SW_DONE_USING_AUX_REG, 1);
 	dal_aux_engine_destruct(&engine->base);
 }
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/clock_source.h b/drivers/gpu/drm/amd/display/dc/inc/clock_source.h
index ebcf67b..47ef904 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/clock_source.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/clock_source.h
@@ -166,10 +166,6 @@ struct clock_source_funcs {
 			struct clock_source *,
 			struct pixel_clk_params *,
 			struct pll_settings *);
-	uint32_t (*get_pix_rate_in_hz)(
-			struct clock_source *,
-			struct pixel_clk_params *,
-			struct pll_settings *);
 };
 
 struct clock_source {
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_dc.h b/drivers/gpu/drm/amd/display/dc/inc/core_dc.h
new file mode 100644
index 0000000..408ed3a
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_dc.h
@@ -0,0 +1,59 @@
+/*
+ * core_dc.h
+ *
+ *  Created on: Nov 13, 2015
+ *      Author: yonsun
+ */
+
+#ifndef __CORE_DC_H__
+#define __CORE_DC_H__
+
+#include "core_types.h"
+#include "hw_sequencer.h"
+#include "compressor.h"
+
+#define DC_TO_CORE(dc)\
+	container_of(dc, struct core_dc, public)
+
+struct core_dc {
+	struct dc public;
+	struct dc_context *ctx;
+
+	uint8_t link_count;
+	struct dc_link *links[MAX_PIPES * 2];
+
+	struct validate_context *current_context;
+	struct resource_pool *res_pool;
+
+	/*Power State*/
+	enum dc_video_power_state previous_power_state;
+	enum dc_video_power_state current_power_state;
+
+	/* Display Engine Clock levels */
+	struct dm_pp_clock_levels sclk_lvls;
+
+	/* Inputs into BW and WM calculations. */
+	struct bw_calcs_dceip bw_dceip;
+	struct bw_calcs_vbios bw_vbios;
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+	struct dcn_soc_bounding_box dcn_soc;
+	struct dcn_ip_params dcn_ip;
+	struct display_mode_lib dml;
+#endif
+
+	/* HW functions */
+	struct hw_sequencer_funcs hwss;
+	struct dce_hwseq *hwseq;
+
+	/* temp store of dm_pp_display_configuration
+	 * to compare to see if display config changed
+	 */
+	struct dm_pp_display_configuration prev_display_config;
+
+	/* FBC compressor */
+#ifdef ENABLE_FBC
+	struct compressor *fbc_compressor;
+#endif
+};
+
+#endif /* __CORE_DC_H__ */
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index 915d5c1..b300562 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -32,10 +32,7 @@
 #include "ddc_service_types.h"
 #include "dc_bios_types.h"
 #include "mem_input.h"
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "mpc.h"
-#endif
-#include "dwb.h"
 
 #define MAX_CLOCK_SOURCES 7
 
@@ -48,12 +45,11 @@ void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 #include "clock_source.h"
 #include "audio.h"
 #include "hw_sequencer_types.h"
-#include "dm_pp_smu.h"
 
 
 /************ link *****************/
 struct link_init_data {
-	const struct dc *dc;
+	const struct core_dc *dc;
 	struct dc_context *ctx; /* TODO: remove 'dal' when DC is complete. */
 	uint32_t connector_index; /* this will be mapped to the HPD pins */
 	uint32_t link_index; /* this is mapped to DAL display_index
@@ -70,9 +66,7 @@ enum dc_status dc_link_validate_mode_timing(
 
 void core_link_resume(struct dc_link *link);
 
-void core_link_enable_stream(
-		struct dc_state *state,
-		struct pipe_ctx *pipe_ctx);
+void core_link_enable_stream(struct pipe_ctx *pipe_ctx);
 
 void core_link_disable_stream(struct pipe_ctx *pipe_ctx);
 
@@ -82,38 +76,34 @@ void core_link_set_avmute(struct pipe_ctx *pipe_ctx, bool enable);
 #include "transform.h"
 
 struct resource_pool;
-struct dc_state;
+struct validate_context;
 struct resource_context;
 
 struct resource_funcs {
 	void (*destroy)(struct resource_pool **pool);
 	struct link_encoder *(*link_enc_create)(
 			const struct encoder_init_data *init);
+	enum dc_status (*validate_with_context)(
+					const struct core_dc *dc,
+					const struct dc_validation_set set[],
+					int set_count,
+					struct validate_context *context,
+					struct validate_context *old_context);
 
 	enum dc_status (*validate_guaranteed)(
-					struct dc *dc,
+					const struct core_dc *dc,
 					struct dc_stream_state *stream,
-					struct dc_state *context);
+					struct validate_context *context);
 
 	bool (*validate_bandwidth)(
-					struct dc *dc,
-					struct dc_state *context);
-
-	enum dc_status (*validate_global)(
-		struct dc *dc,
-		struct dc_state *context);
+					const struct core_dc *dc,
+					struct validate_context *context);
 
 	struct pipe_ctx *(*acquire_idle_pipe_for_layer)(
-			struct dc_state *context,
+			struct validate_context *context,
 			const struct resource_pool *pool,
 			struct dc_stream_state *stream);
-
 	enum dc_status (*validate_plane)(const struct dc_plane_state *plane_state);
-
-	enum dc_status (*add_stream_to_ctx)(
-			struct dc *dc,
-			struct dc_state *new_ctx,
-			struct dc_stream_state *dc_stream);
 };
 
 struct audio_support{
@@ -131,12 +121,9 @@ struct resource_pool {
 	struct output_pixel_processor *opps[MAX_PIPES];
 	struct timing_generator *timing_generators[MAX_PIPES];
 	struct stream_encoder *stream_enc[MAX_PIPES * 2];
-
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	struct mpc *mpc;
-	struct pp_smu_funcs_rv *pp_smu;
-	struct pp_smu_display_requirement_rv pp_smu_req;
-
-	struct dwbc *dwbc[MAX_DWB_PIPES];
+#endif
 
 	unsigned int pipe_count;
 	unsigned int underlay_pipe_index;
@@ -190,6 +177,7 @@ struct pipe_ctx {
 	struct plane_resource plane_res;
 	struct stream_resource stream_res;
 
+	struct display_clock *dis_clk;
 	struct clock_source *clock_source;
 
 	struct pll_settings pll_settings;
@@ -205,7 +193,6 @@ struct pipe_ctx {
 	struct _vcs_dpi_display_rq_regs_st rq_regs;
 	struct _vcs_dpi_display_pipe_dest_params_st pipe_dlg_param;
 #endif
-	struct dwbc *dwbc;
 };
 
 struct resource_context {
@@ -232,6 +219,7 @@ struct dce_bw_output {
 	int blackout_recovery_time_us;
 };
 
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 struct dcn_bw_clocks {
 	int dispclk_khz;
 	bool dppclk_div;
@@ -247,13 +235,16 @@ struct dcn_bw_output {
 	struct dcn_bw_clocks calc_clk;
 	struct dcn_watermark_set watermarks;
 };
+#endif
 
 union bw_context {
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	struct dcn_bw_output dcn;
+#endif
 	struct dce_bw_output dce;
 };
 
-struct dc_state {
+struct validate_context {
 	struct dc_stream_state *streams[MAX_PIPES];
 	struct dc_stream_status stream_status[MAX_PIPES];
 	uint8_t stream_count;
@@ -269,9 +260,7 @@ struct dc_state {
 	struct dcn_bw_internal_vars dcn_bw_vars;
 #endif
 
-	struct display_clock *dis_clk;
-
-	atomic_t ref_count;
+	int ref_count;
 };
 
 #endif /* _CORE_TYPES_H_ */
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dce_calcs.h b/drivers/gpu/drm/amd/display/dc/inc/dce_calcs.h
index ae2399f..36c48f7 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dce_calcs.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dce_calcs.h
@@ -33,8 +33,8 @@
 #include "bw_fixed.h"
 
 struct pipe_ctx;
-struct dc;
-struct dc_state;
+struct core_dc;
+struct validate_context;
 struct dce_bw_output;
 
 enum bw_calcs_version {
diff --git a/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h b/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h
index 1e231f6..7e8abcd 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/dcn_calcs.h
@@ -34,8 +34,8 @@
 #include "display_clock.h"
 #include "../dml/display_mode_lib.h"
 
-struct dc;
-struct dc_state;
+struct core_dc;
+struct validate_context;
 
 /*******************************************************************************
  * DCN data structures.
@@ -620,16 +620,16 @@ struct dcn_ip_params {
 extern const struct dcn_ip_params dcn10_ip_defaults;
 
 bool dcn_validate_bandwidth(
-		struct dc *dc,
-		struct dc_state *context);
+		const struct core_dc *dc,
+		struct validate_context *context);
 
 unsigned int dcn_find_dcfclk_suits_all(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	struct clocks_value *clocks);
 
-void dcn_bw_update_from_pplib(struct dc *dc);
-void dcn_bw_notify_pplib_of_wm_ranges(struct dc *dc);
-void dcn_bw_sync_calcs_and_dml(struct dc *dc);
+void dcn_bw_update_from_pplib(struct core_dc *dc);
+void dcn_bw_notify_pplib_of_wm_ranges(struct core_dc *dc);
+void dcn_bw_sync_calcs_and_dml(struct core_dc *dc);
 
 #endif /* __DCN_CALCS_H__ */
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/display_clock.h b/drivers/gpu/drm/amd/display/dc/inc/hw/display_clock.h
index f5f69cd..879c3db 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/display_clock.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/display_clock.h
@@ -62,7 +62,7 @@ struct display_clock {
 };
 
 struct display_clock_funcs {
-	int (*set_clock)(struct display_clock *disp_clk,
+	void (*set_clock)(struct display_clock *disp_clk,
 		int requested_clock_khz);
 
 	enum dm_pp_clocks_state (*get_required_clocks_state)(
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h
index 0574c29..e34b259 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dmcu.h
@@ -37,7 +37,7 @@ struct dmcu_funcs {
 			unsigned int start_offset,
 			const char *src,
 			unsigned int bytes);
-	void (*set_psr_enable)(struct dmcu *dmcu, bool enable, bool wait);
+	void (*set_psr_enable)(struct dmcu *dmcu, bool enable);
 	void (*setup_psr)(struct dmcu *dmcu,
 			struct dc_link *link,
 			struct psr_context *psr_context);
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/dwb.h b/drivers/gpu/drm/amd/display/dc/inc/hw/dwb.h
deleted file mode 100644
index 82347ba..0000000
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dwb.h
+++ /dev/null
@@ -1,193 +0,0 @@
-/* Copyright 2012-17 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DC_DWBC_H__
-#define __DC_DWBC_H__
-
-#include "dc_hw_types.h"
-
-#define MAX_DWB_PIPES	3
-
-enum dce_version;
-
-enum dwb_sw_version {
-	dwb_ver_1_0 = 1,
-};
-
-enum dwb_source {
-	dwb_src_scl = 0,	/* for DCE7x/9x, DCN won't support. */
-	dwb_src_blnd,		/* for DCE7x/9x */
-	dwb_src_fmt,		/* for DCE7x/9x */
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	dwb_src_otg0 = 0x100,	/* for DCN1.x, register: mmDWB_SOURCE_SELECT */
-	dwb_src_otg1,		/* for DCN1.x */
-	dwb_src_otg2,		/* for DCN1.x */
-	dwb_src_otg3,		/* for DCN1.x */
-#endif
-};
-
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-/* DCN1.x supports 2 pipes */
-#endif
-enum dwb_pipe {
-	dwb_pipe0 = 0,
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	dwb_pipe1,
-#endif
-	dwb_pipe_max_num,
-};
-
-enum setting_flags {
-	sf_pipe				= 0x00000001,
-	sf_output_format	= 0x00000002,
-	sf_capture_rate		= 0x00000004,
-	sf_all				 = 0xffffffff,
-};
-
-enum dwb_capture_rate {
-
-	dwb_capture_rate_0 = 0,	/* Every frame is captured. */
-	dwb_capture_rate_1 = 1,	/* Every other frame is captured. */
-	dwb_capture_rate_2 = 2,	/* Every 3rd frame is captured. */
-	dwb_capture_rate_3 = 3,	/* Every 4th frame is captured. */
-};
-
-enum dwb_scaler_mode {
-	dwb_scaler_mode_bypass444 = 0,
-	dwb_scaler_mode_rgb444 = 1,
-	dwb_scaler_mode_yuv444 = 2,
-	dwb_scaler_mode_yuv420 = 3
-};
-
-struct dwb_caps {
-	enum dce_version hw_version;	/* DCN engine version. */
-	enum dwb_sw_version sw_version;	/* DWB sw implementation version. */
-	unsigned int	reserved[6];	/* Reserved for future use, MUST BE 0. */
-	unsigned int	adapter_id;
-	unsigned int	num_pipes;		/* number of DWB pipes */
-	struct {
-		unsigned int support_dwb					 :1;
-		unsigned int support_ogam					:1;
-		unsigned int support_wbscl					:1;
-		unsigned int support_ocsc					:1;
-	} caps;
-	unsigned int	 reserved2[10];	/* Reserved for future use, MUST BE 0. */
-};
-
-struct dwb_status {
-	bool			enabled;
-	/* Reserved ========================================================================= */
-	unsigned int	reserved[8];	/* Reserved fields */
-};
-
-struct dwb_basic_settings {
-	/* General DWB related input parameters ============================================= */
-	enum dwb_source	input_src_select;	 /* Select input source: (DCE) 0: SCL; 1: BLND; 2: FMT; (DCN) OTG* or MPC* */
-	enum dwb_pipe	input_pipe_select;	/* Select input pipe: 0: PIPE0; 1: PIPE1; 2: PIPE2 */
-
-	/* CNV: WND Related parameters ====================================================== */
-	unsigned int	capture_rate; /* Captures once every (capture_rate+1) frames */
-
-	/* CNV: CSC Related parameters ====================================================== */
-	unsigned int	start_x;	/* Horizontal window start position */
-	unsigned int	start_y;	/* Vertical window start position */
-	unsigned int	src_width;	/* Width of window captured within source window */
-	unsigned int	src_height;	/* Height of window captured within source window */
-
-	/* SISCL Related parameters ========================================================= */
-	unsigned int	dest_width; /* Destination width */
-	unsigned int	dest_height; /* Destination height */
-
-	/* MCIF bufer parameters	========================================================= */
-	unsigned long long luma_address[4];
-	unsigned long long chroma_address[4];
-	unsigned int	luma_pitch;
-	unsigned int	chroma_pitch;
-	unsigned int	slice_lines;
-
-	/* Reserved ========================================================================= */
-	unsigned int	reserved[8];	/* Reserved fields */
-
-};
-
-struct dwb_advanced_settings {
-	enum setting_flags		uFlag;
-	enum dwb_pipe			pipe;		/* default = DWB_PIPE_ALL */
-	enum dwb_scaler_mode	out_format;	/* default = DWBScalerMode_YUV420 */
-	enum dwb_capture_rate	capture_rate; /* default = Every frame is captured */
-	unsigned int			reserved[64]; /* reserved for future use, must be 0 */
-};
-
-/* / - dwb_frame_info is the info of the dumping data */
-struct dwb_frame_info {
-	unsigned int				 size;
-	unsigned int				 width;
-	unsigned int				 height;
-	unsigned int				 luma_pitch;
-	unsigned int				 chroma_pitch;
-	enum dwb_scaler_mode		 format;
-};
-
-struct dwbc_cfg {
-	struct	dwb_basic_settings basic_settings;
-	struct	dwb_advanced_settings advanced_settings;
-};
-
-struct dwbc {
-	const struct dwbc_funcs *funcs;
-	struct dc_context *ctx;
-	struct dwbc_cfg config;
-	struct dwb_status status;
-	int inst;
-};
-
-struct dwbc_funcs {
-	bool (*get_caps)(struct dwbc *dwbc, struct dwb_caps *caps);
-
-	bool (*enable)(struct dwbc *dwbc);
-
-	bool (*disable)(struct dwbc *dwbc);
-
-	bool (*get_status)(struct dwbc *dwbc, struct dwb_status *status);
-
-	bool (*dump_frame)(struct dwbc *dwbc, struct dwb_frame_info *frame_info,
-		unsigned char *luma_buffer, unsigned char *chroma_buffer,
-		unsigned char *dest_luma_buffer, unsigned char *dest_chroma_buffer);
-
-	bool (*set_basic_settings)(struct dwbc *dwbc,
-		const struct dwb_basic_settings *basic_settings);
-
-	bool (*get_basic_settings)(struct dwbc *dwbc,
-		struct dwb_basic_settings *basic_settings);
-
-	bool (*set_advanced_settings)(struct dwbc *dwbc,
-		const struct dwb_advanced_settings *advanced_settings);
-
-	bool (*get_advanced_settings)(struct dwbc *dwbc,
-		struct dwb_advanced_settings *advanced_settings);
-
-	bool (*reset_advanced_settings)(struct dwbc *dwbc);
-};
-
-#endif
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h b/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
index 9602f26..589bdda 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/hw_shared.h
@@ -98,24 +98,6 @@ enum graphics_csc_adjust_type {
 	GRAPHICS_CSC_ADJUST_TYPE_SW  /*use adjustments */
 };
 
-enum ipp_degamma_mode {
-	IPP_DEGAMMA_MODE_BYPASS,
-	IPP_DEGAMMA_MODE_HW_sRGB,
-	IPP_DEGAMMA_MODE_HW_xvYCC,
-	IPP_DEGAMMA_MODE_USER_PWL
-};
-
-enum ipp_output_format {
-	IPP_OUTPUT_FORMAT_12_BIT_FIX,
-	IPP_OUTPUT_FORMAT_16_BIT_BYPASS,
-	IPP_OUTPUT_FORMAT_FLOAT
-};
-
-enum expansion_mode {
-	EXPANSION_MODE_DYNAMIC,
-	EXPANSION_MODE_ZERO
-};
-
 struct default_adjustment {
 	enum lb_pixel_depth lb_color_depth;
 	enum dc_color_space out_color_space;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h b/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
index 7ebfdc1..0f952e5 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/ipp.h
@@ -54,7 +54,12 @@ struct ipp_prescale_params {
 	uint16_t scale;
 };
 
-
+enum ipp_degamma_mode {
+	IPP_DEGAMMA_MODE_BYPASS,
+	IPP_DEGAMMA_MODE_HW_sRGB,
+	IPP_DEGAMMA_MODE_HW_xvYCC,
+	IPP_DEGAMMA_MODE_USER_PWL
+};
 
 enum ovl_color_space {
 	OVL_COLOR_SPACE_UNKNOWN = 0,
@@ -63,6 +68,16 @@ enum ovl_color_space {
 	OVL_COLOR_SPACE_YUV709
 };
 
+enum expansion_mode {
+	EXPANSION_MODE_DYNAMIC,
+	EXPANSION_MODE_ZERO
+};
+
+enum ipp_output_format {
+	IPP_OUTPUT_FORMAT_12_BIT_FIX,
+	IPP_OUTPUT_FORMAT_16_BIT_BYPASS,
+	IPP_OUTPUT_FORMAT_FLOAT
+};
 
 struct ipp_funcs {
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
index 961bbcc..38e4070 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/link_encoder.h
@@ -37,7 +37,6 @@ struct encoder_feature_support {
 			uint32_t IS_TPS3_CAPABLE:1;
 			uint32_t IS_TPS4_CAPABLE:1;
 			uint32_t IS_YCBCR_CAPABLE:1;
-			uint32_t HDMI_6GB_EN:1;
 		} bits;
 		uint32_t raw;
 	} flags;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h b/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
index 6cef9ad..a02f18a 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/mem_input.h
@@ -30,7 +30,6 @@
 
 #include "dml/display_mode_structs.h"
 
-struct dchub_init_data;
 struct cstate_pstate_watermarks_st {
 	uint32_t cstate_exit_ns;
 	uint32_t cstate_enter_plus_exit_ns;
@@ -74,19 +73,6 @@ struct mem_input {
 	struct stutter_modes stutter_mode;
 };
 
-struct vm_system_aperture_param {
-	PHYSICAL_ADDRESS_LOC sys_default;
-	PHYSICAL_ADDRESS_LOC sys_low;
-	PHYSICAL_ADDRESS_LOC sys_high;
-};
-
-struct vm_context0_param {
-	PHYSICAL_ADDRESS_LOC pte_base;
-	PHYSICAL_ADDRESS_LOC pte_start;
-	PHYSICAL_ADDRESS_LOC pte_end;
-	PHYSICAL_ADDRESS_LOC fault_default;
-};
-
 struct mem_input_funcs {
 	void (*mem_input_setup)(
 			struct mem_input *mem_input,
@@ -138,14 +124,6 @@ struct mem_input_funcs {
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation);
 
-	void (*mem_input_set_vm_system_aperture_settings)(
-			struct mem_input *mem_input,
-			struct vm_system_aperture_param *apt);
-
-	void (*mem_input_set_vm_context0_settings)(
-			struct mem_input *mem_input,
-			const struct vm_context0_param *vm0);
-
 	void (*mem_input_program_surface_config)(
 		struct mem_input *mem_input,
 		enum surface_pixel_format format,
@@ -161,8 +139,6 @@ struct mem_input_funcs {
 				struct dchub_init_data *dh_data);
 
 	void (*set_blank)(struct mem_input *mi, bool blank);
-	void (*set_hubp_blank_en)(struct mem_input *mi, bool blank);
-
 };
 
 #endif
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h b/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
index 623042d..f3d6675 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/transform.h
@@ -219,26 +219,6 @@ struct transform_funcs {
 	void (*opp_set_regamma_mode)(
 			struct transform *xfm_base,
 			enum opp_regamma mode);
-
-	void (*ipp_set_degamma)(
-			struct transform *xfm_base,
-			enum ipp_degamma_mode mode);
-
-	void (*ipp_program_input_lut)(
-			struct transform *xfm_base,
-			const struct dc_gamma *gamma);
-
-	void (*ipp_program_degamma_pwl)(struct transform *xfm_base,
-									 const struct pwl_params *params);
-
-	void (*ipp_setup)(
-			struct transform *xfm_base,
-			enum surface_pixel_format input_format,
-			enum expansion_mode mode,
-			enum ipp_output_format cnv_out_format);
-
-	void (*ipp_full_bypass)(struct transform *xfm_base);
-
 };
 
 extern const uint16_t filter_2tap_16p[18];
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
index aae7629..7689e37 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
@@ -25,10 +25,8 @@
 
 #ifndef __DC_HW_SEQUENCER_H__
 #define __DC_HW_SEQUENCER_H__
-#include "dc_types.h"
-#include "clock_source.h"
-#include "inc/hw/timing_generator.h"
-#include "core_status.h"
+#include "core_types.h"
+#include "timing_generator.h"
 
 enum pipe_gating_control {
 	PIPE_GATING_CONTROL_DISABLE = 0,
@@ -48,31 +46,25 @@ struct dce_hwseq {
 	struct dce_hwseq_wa wa;
 };
 
-struct pipe_ctx;
-struct dc_state;
-struct dchub_init_data;
-struct dc_static_screen_events;
-struct resource_pool;
-struct resource_context;
 
 struct hw_sequencer_funcs {
 
-	void (*init_hw)(struct dc *dc);
+	void (*init_hw)(struct core_dc *dc);
 
 	enum dc_status (*apply_ctx_to_hw)(
-			struct dc *dc, struct dc_state *context);
+			struct core_dc *dc, struct validate_context *context);
 
 	void (*reset_hw_ctx_wrap)(
-			struct dc *dc, struct dc_state *context);
+			struct core_dc *dc, struct validate_context *context);
 
 	void (*apply_ctx_for_surface)(
-			struct dc *dc,
+			struct core_dc *dc,
 			const struct dc_stream_state *stream,
 			int num_planes,
-			struct dc_state *context);
+			struct validate_context *context);
 
 	void (*set_plane_config)(
-			const struct dc *dc,
+			const struct core_dc *dc,
 			struct pipe_ctx *pipe_ctx,
 			struct resource_context *res_ctx);
 
@@ -85,7 +77,7 @@ struct hw_sequencer_funcs {
 			uint16_t *matrix);
 
 	void (*update_plane_addr)(
-		const struct dc *dc,
+		const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx);
 
 	void (*update_dchub)(
@@ -103,12 +95,12 @@ struct hw_sequencer_funcs {
 				struct pipe_ctx *pipe_ctx,
 				const struct dc_stream_state *stream);
 
-	void (*power_down)(struct dc *dc);
+	void (*power_down)(struct core_dc *dc);
 
-	void (*enable_accelerated_mode)(struct dc *dc);
+	void (*enable_accelerated_mode)(struct core_dc *dc);
 
 	void (*enable_timing_synchronization)(
-			struct dc *dc,
+			struct core_dc *dc,
 			int group_index,
 			int group_size,
 			struct pipe_ctx *grouped_pipes[]);
@@ -118,16 +110,16 @@ struct hw_sequencer_funcs {
 					bool clock_gating);
 
 	bool (*enable_display_power_gating)(
-					struct dc *dc,
+					struct core_dc *dc,
 					uint8_t controller_id,
 					struct dc_bios *dcb,
 					enum pipe_gating_control power_gating);
 
-	void (*power_down_front_end)(struct dc *dc, int fe_idx);
+	void (*power_down_front_end)(struct core_dc *dc, int fe_idx);
 
-	void (*power_on_front_end)(struct dc *dc,
+	void (*power_on_front_end)(struct core_dc *dc,
 			struct pipe_ctx *pipe,
-			struct dc_state *context);
+			struct validate_context *context);
 
 	void (*update_info_frame)(struct pipe_ctx *pipe_ctx);
 
@@ -139,13 +131,13 @@ struct hw_sequencer_funcs {
 			struct dc_link_settings *link_settings);
 
 	void (*pipe_control_lock)(
-				struct dc *dc,
+				struct core_dc *dc,
 				struct pipe_ctx *pipe,
 				bool lock);
 
 	void (*set_bandwidth)(
-			struct dc *dc,
-			struct dc_state *context,
+			struct core_dc *dc,
+			struct validate_context *context,
 			bool decrease_allowed);
 
 	void (*set_drr)(struct pipe_ctx **pipe_ctx, int num_pipes,
@@ -159,27 +151,24 @@ struct hw_sequencer_funcs {
 
 	enum dc_status (*prog_pixclk_crtc_otg)(
 			struct pipe_ctx *pipe_ctx,
-			struct dc_state *context,
-			struct dc *dc);
+			struct validate_context *context,
+			struct core_dc *dc);
 
 	void (*setup_stereo)(
 			struct pipe_ctx *pipe_ctx,
-			struct dc *dc);
+			struct core_dc *dc);
 
 	void (*set_avmute)(struct pipe_ctx *pipe_ctx, bool enable);
 
-	void (*log_hw_state)(struct dc *dc);
+	void (*log_hw_state)(struct core_dc *dc);
 
-	void (*wait_for_mpcc_disconnect)(struct dc *dc,
+	void (*wait_for_mpcc_disconnect)(struct core_dc *dc,
 			struct resource_pool *res_pool,
 			struct pipe_ctx *pipe_ctx);
-
-	void (*ready_shared_resources)(struct dc *dc);
-	void (*optimize_shared_resources)(struct dc *dc);
 };
 
 void color_space_to_black_color(
-	const struct dc *dc,
+	const struct core_dc *dc,
 	enum dc_color_space colorspace,
 	struct tg_color *black_color);
 
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index 41437da..7f30d99 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -27,8 +27,8 @@
 
 #include "core_types.h"
 #include "core_status.h"
+#include "core_dc.h"
 #include "dal_asic_id.h"
-#include "dm_pp_smu.h"
 
 /* TODO unhardcode, 4 for CZ*/
 #define MEMORY_TYPE_MULTIPLIER 4
@@ -67,28 +67,28 @@ struct resource_create_funcs {
 
 bool resource_construct(
 	unsigned int num_virtual_links,
-	struct dc *dc,
+	struct core_dc *dc,
 	struct resource_pool *pool,
 	const struct resource_create_funcs *create_funcs);
 
 struct resource_pool *dc_create_resource_pool(
-				struct dc *dc,
+				struct core_dc *dc,
 				int num_virtual_links,
 				enum dce_version dc_version,
 				struct hw_asic_id asic_id);
 
-void dc_destroy_resource_pool(struct dc *dc);
+void dc_destroy_resource_pool(struct core_dc *dc);
 
 enum dc_status resource_map_pool_resources(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream);
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context);
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx);
 
 enum dc_status resource_build_scaling_params_for_context(
-		const struct dc *dc,
-		struct dc_state *context);
+		const struct core_dc *dc,
+		struct validate_context *context);
 
 void resource_build_info_frame(struct pipe_ctx *pipe_ctx);
 
@@ -122,7 +122,7 @@ bool resource_attach_surfaces_to_context(
 		struct dc_plane_state *const *plane_state,
 		int surface_count,
 		struct dc_stream_state *dc_stream,
-		struct dc_state *context,
+		struct validate_context *context,
 		const struct resource_pool *pool);
 
 struct pipe_ctx *find_idle_secondary_pipe(
@@ -130,32 +130,32 @@ struct pipe_ctx *find_idle_secondary_pipe(
 		const struct resource_pool *pool);
 
 bool resource_is_stream_unchanged(
-	struct dc_state *old_context, struct dc_stream_state *stream);
+	struct validate_context *old_context, struct dc_stream_state *stream);
 
 bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
 		int set_count,
-		const struct dc_state *old_context,
-		struct dc_state *context,
+		const struct validate_context *old_context,
+		struct validate_context *context,
 		const struct resource_pool *pool);
 
 void validate_guaranteed_copy_streams(
-		struct dc_state *context,
+		struct validate_context *context,
 		int max_streams);
 
 void resource_validate_ctx_update_pointer_after_copy(
-		const struct dc_state *src_ctx,
-		struct dc_state *dst_ctx);
+		const struct validate_context *src_ctx,
+		struct validate_context *dst_ctx);
 
 enum dc_status resource_map_clock_resources(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream);
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context);
 
 enum dc_status resource_map_phy_clock_resources(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream);
+		const struct core_dc *dc,
+		struct validate_context *context,
+		struct validate_context *old_context);
 
 bool pipe_need_reprogram(
 		struct pipe_ctx *pipe_ctx_old,
diff --git a/drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c b/drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c
index 7cce284..24e47eb 100644
--- a/drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c
+++ b/drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c
@@ -34,8 +34,8 @@
 
 #include "ivsrcid/ivsrcid_vislands30.h"
 
-#include "dc.h"
-#include "core_types.h"
+#include "core_dc.h"
+
 static bool hpd_ack(
 	struct irq_service *irq_service,
 	const struct irq_source_info *info)
@@ -206,7 +206,7 @@ bool dce110_vblank_set(
 		bool enable)
 {
 	struct dc_context *dc_ctx = irq_service->ctx;
-	struct dc *core_dc = irq_service->ctx->dc;
+	struct core_dc *core_dc = DC_TO_CORE(irq_service->ctx->dc);
 	enum dc_irq_source dal_irq_src = dc_interrupt_to_irq_source(
 										irq_service->ctx->dc,
 										info->src_id,
@@ -214,7 +214,7 @@ bool dce110_vblank_set(
 	uint8_t pipe_offset = dal_irq_src - IRQ_TYPE_VBLANK;
 
 	struct timing_generator *tg =
-			core_dc->current_state->res_ctx.pipe_ctx[pipe_offset].stream_res.tg;
+			core_dc->current_context->res_ctx.pipe_ctx[pipe_offset].stream_res.tg;
 
 	if (enable) {
 		if (!tg->funcs->arm_vert_intr(tg, 2)) {
diff --git a/drivers/gpu/drm/amd/display/dc/irq/dce80/irq_service_dce80.c b/drivers/gpu/drm/amd/display/dc/irq/dce80/irq_service_dce80.c
index f458ef8..7e8cb22 100644
--- a/drivers/gpu/drm/amd/display/dc/irq/dce80/irq_service_dce80.c
+++ b/drivers/gpu/drm/amd/display/dc/irq/dce80/irq_service_dce80.c
@@ -36,6 +36,7 @@
 #include "ivsrcid/ivsrcid_vislands30.h"
 
 #include "dc_types.h"
+#include "inc/core_dc.h"
 
 static bool hpd_ack(
 	struct irq_service *irq_service,
diff --git a/drivers/gpu/drm/amd/display/include/grph_object_ctrl_defs.h b/drivers/gpu/drm/amd/display/include/grph_object_ctrl_defs.h
index 92fe00f..6cdbf84 100644
--- a/drivers/gpu/drm/amd/display/include/grph_object_ctrl_defs.h
+++ b/drivers/gpu/drm/amd/display/include/grph_object_ctrl_defs.h
@@ -65,7 +65,6 @@ enum dal_device_type {
 struct device_id {
 	enum dal_device_type device_type:16;
 	uint32_t enum_id:16;	/* 1 based enum */
-	uint16_t raw_device_tag;
 };
 
 struct graphics_object_i2c_info {
@@ -265,20 +264,6 @@ struct transmitter_configuration {
 #define NUMBER_OF_DISP_CLK_VOLTAGE 4
 #define NUMBER_OF_AVAILABLE_SCLK 5
 
-struct i2c_reg_info {
-    unsigned char       i2c_reg_index;
-    unsigned char       i2c_reg_val;
-};
-
-struct ext_hdmi_settings {
-    unsigned char   slv_addr;
-    unsigned char   reg_num;
-    struct i2c_reg_info      reg_settings[9];
-    unsigned char   reg_num_6g;
-    struct i2c_reg_info      reg_settings_6g[3];
-};
-
-
 /* V6 */
 struct integrated_info {
 	struct clock_voltage_caps {
@@ -306,8 +291,6 @@ struct integrated_info {
 			struct graphics_object_id ext_encoder_obj_id;
 			/* XBAR mapping of the PHY channels */
 			union ddi_channel_mapping channel_mapping;
-
-			unsigned short caps;
 		} path[MAX_NUMBER_OF_EXT_DISPLAY_PATH];
 
 		uint8_t gu_id[NUMBER_OF_UCHAR_FOR_GUID];
@@ -374,27 +357,6 @@ struct integrated_info {
 	uint32_t lvds_pwr_off_seq_blon_to_vary_bl_in_4ms;
 	uint32_t lvds_reserved1;
 	uint32_t lvds_bit_depth_control_val;
-	//Start from V9
-	unsigned char dp0_ext_hdmi_slv_addr;
-	unsigned char dp0_ext_hdmi_reg_num;
-	struct i2c_reg_info dp0_ext_hdmi_reg_settings[9];
-	unsigned char dp0_ext_hdmi_6g_reg_num;
-	struct i2c_reg_info dp0_ext_hdmi_6g_reg_settings[3];
-	unsigned char dp1_ext_hdmi_slv_addr;
-	unsigned char dp1_ext_hdmi_reg_num;
-	struct i2c_reg_info dp1_ext_hdmi_reg_settings[9];
-	unsigned char dp1_ext_hdmi_6g_reg_num;
-	struct i2c_reg_info dp1_ext_hdmi_6g_reg_settings[3];
-	unsigned char dp2_ext_hdmi_slv_addr;
-	unsigned char dp2_ext_hdmi_reg_num;
-	struct i2c_reg_info dp2_ext_hdmi_reg_settings[9];
-	unsigned char dp2_ext_hdmi_6g_reg_num;
-	struct i2c_reg_info dp2_ext_hdmi_6g_reg_settings[3];
-	unsigned char dp3_ext_hdmi_slv_addr;
-	unsigned char dp3_ext_hdmi_reg_num;
-	struct i2c_reg_info dp3_ext_hdmi_reg_settings[9];
-	unsigned char dp3_ext_hdmi_6g_reg_num;
-	struct i2c_reg_info dp3_ext_hdmi_6g_reg_settings[3];
 };
 
 /**
diff --git a/drivers/gpu/drm/amd/display/include/logger_interface.h b/drivers/gpu/drm/amd/display/include/logger_interface.h
index 6641e80..beb7909 100644
--- a/drivers/gpu/drm/amd/display/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/display/include/logger_interface.h
@@ -32,7 +32,7 @@ struct dc_context;
 struct dc_link;
 struct dc_surface_update;
 struct resource_context;
-struct dc_state;
+struct validate_context;
 
 /*
  *
@@ -76,24 +76,24 @@ void logger_write(struct dal_logger *logger,
 		void *paralist);
 
 void pre_surface_trace(
-		struct dc *dc,
+		const struct dc *dc,
 		const struct dc_plane_state *const *plane_states,
 		int surface_count);
 
 void update_surface_trace(
-		struct dc *dc,
+		const struct dc *dc,
 		const struct dc_surface_update *updates,
 		int surface_count);
 
-void post_surface_trace(struct dc *dc);
+void post_surface_trace(const struct dc *dc);
 
 void context_timing_trace(
-		struct dc *dc,
+		const struct dc *dc,
 		struct resource_context *res_ctx);
 
 void context_clock_trace(
-		struct dc *dc,
-		struct dc_state *context);
+		const struct dc *dc,
+		struct validate_context *context);
 
 /* Any function which is empty or have incomplete implementation should be
  * marked by this macro.
diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 52350d0..f0a3e43 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -27,6 +27,7 @@
 #include "dc.h"
 #include "mod_freesync.h"
 #include "core_types.h"
+#include "core_dc.h"
 
 #define MOD_FREESYNC_MAX_CONCURRENT_STREAMS  32
 
@@ -145,6 +146,7 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	struct core_freesync *core_freesync =
 			dm_alloc(sizeof(struct core_freesync));
 
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
 	struct persistent_data_flag flag;
 
@@ -175,19 +177,19 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	/* Create initial module folder in registry for freesync enable data */
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
-	dm_write_persistent_data(dc->ctx, NULL, FREESYNC_REGISTRY_NAME,
+	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME,
 			NULL, NULL, 0, &flag);
 	flag.save_per_edid = false;
 	flag.save_per_link = false;
 
-	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
+	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
 			FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY,
 			&data, sizeof(data), &flag)) {
 		core_freesync->opts.drr_internal_supported =
 			(data & 1) ? false : true;
 	}
 
-	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
+	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
 			FREESYNC_NO_STATIC_FOR_EXTERNAL_DP_REGKEY,
 			&data, sizeof(data), &flag)) {
 		core_freesync->opts.drr_external_supported =
@@ -244,7 +246,7 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		struct dc_stream_state *stream, struct mod_freesync_caps *caps)
 {
-	struct dc  *dc = NULL;
+	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
@@ -255,7 +257,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	dc = core_freesync->dc;
+	core_dc = DC_TO_CORE(core_freesync->dc);
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -286,7 +288,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 			static_ramp.ramp_is_active = false;
 
 		/* get persistent data from registry */
-		if (dm_read_persistent_data(dc->ctx, stream->sink,
+		if (dm_read_persistent_data(core_dc->ctx, stream->sink,
 					FREESYNC_REGISTRY_NAME,
 					"userenable", &persistent_freesync_enable,
 					sizeof(int), &flag)) {
@@ -969,14 +971,14 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 	unsigned int stream_index, map_index;
 	int persistent_data = 0;
 	struct persistent_data_flag flag;
-	struct dc  *dc = NULL;
+	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 
 	if (mod_freesync == NULL)
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	dc = core_freesync->dc;
+	core_dc = DC_TO_CORE(core_freesync->dc);
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -1000,7 +1002,7 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 				enable_for_video)
 			persistent_data = persistent_data | 4;
 
-		dm_write_persistent_data(dc->ctx,
+		dm_write_persistent_data(core_dc->ctx,
 					streams[stream_index]->sink,
 					FREESYNC_REGISTRY_NAME,
 					"userenable",
-- 
2.7.4

