From 9ee248c2c14e16abc8ace199903fd21483345cc0 Mon Sep 17 00:00:00 2001
From: Kalyan Alle <kalyan.alle@amd.com>
Date: Sat, 13 May 2017 17:56:39 +0530
Subject: [PATCH 2953/3082] drm/amd/amdgpu: Resolving the build issues between
 commits

realted to the amdgpu driver

Handling the after-effects of Refactored atomic commit implementation
code, without causing build conflicts with the other vendors code like
intel , nouveau etc.

Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 arch/x86/include/asm/io.h                          |   6 +
 arch/x86/mm/pat.c                                  |  14 +
 drivers/gpu/drm/Makefile                           |   5 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h                |   3 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c   |   3 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c        |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c             |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_display.c        | 222 ++++----
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c            |  10 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h           |   5 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_object.h         |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c            |   7 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.h            |  16 +-
 drivers/gpu/drm/amd/amdgpu/dce_v10_0.c             |  18 +-
 drivers/gpu/drm/amd/amdgpu/dce_v11_0.c             |  18 +-
 drivers/gpu/drm/amd/amdgpu/dce_v6_0.c              |   2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c              |   2 +-
 drivers/gpu/drm/amd/amdgpu/dce_virtual.c           |   4 +-
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c  |   7 +-
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.c    | 602 +++++++++++++--------
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.h    |   6 +-
 drivers/gpu/drm/drm_crtc.c                         |  48 ++
 include/drm/drm_atomic_helper.h                    |   5 +
 include/drm/drm_crtc.h                             |  36 ++
 include/drm/drm_fb_helper.h                        |  11 +
 include/uapi/drm/amdgpu_drm.h                      | 101 +++-
 include/uapi/drm/drm_mode.h                        |  10 +
 27 files changed, 780 insertions(+), 387 deletions(-)

diff --git a/arch/x86/include/asm/io.h b/arch/x86/include/asm/io.h
index de25aad..d34bd37 100644
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@ -351,4 +351,10 @@ extern void arch_phys_wc_del(int handle);
 #define arch_phys_wc_add arch_phys_wc_add
 #endif
 
+#ifdef CONFIG_X86_PAT
+extern int arch_io_reserve_memtype_wc(resource_size_t start, resource_size_t size);
+extern void arch_io_free_memtype_wc(resource_size_t start, resource_size_t size);
+#define arch_io_reserve_memtype_wc arch_io_reserve_memtype_wc
+#endif
+
 #endif /* _ASM_X86_IO_H */
diff --git a/arch/x86/mm/pat.c b/arch/x86/mm/pat.c
index 188e3e0..baec5ea 100644
--- a/arch/x86/mm/pat.c
+++ b/arch/x86/mm/pat.c
@@ -686,6 +686,20 @@ void io_free_memtype(resource_size_t start, resource_size_t end)
 	free_memtype(start, end);
 }
 
+int arch_io_reserve_memtype_wc(resource_size_t start, resource_size_t size)
+{
+        enum page_cache_mode type = _PAGE_CACHE_MODE_WC;
+
+        return io_reserve_memtype(start, start + size, &type);
+}
+EXPORT_SYMBOL(arch_io_reserve_memtype_wc);
+
+void arch_io_free_memtype_wc(resource_size_t start, resource_size_t size)
+{
+        io_free_memtype(start, start + size);
+}
+EXPORT_SYMBOL(arch_io_free_memtype_wc);
+
 pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
 				unsigned long size, pgprot_t vma_prot)
 {
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 1e9ff4c..c7f18e6 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -24,7 +24,10 @@ drm-$(CONFIG_AGP) += drm_agpsupport.o
 drm-y += $(drm-m)
 
 drm_kms_helper-y := drm_crtc_helper.o drm_dp_helper.o drm_probe_helper.o \
-		drm_plane_helper.o drm_dp_mst_topology.o drm_atomic_helper.o
+                drm_plane_helper.o drm_dp_mst_topology.o drm_atomic_helper.o \
+                drm_kms_helper_common.o drm_dp_dual_mode_helper.o \
+                drm_simple_kms_helper.o drm_modeset_helper.o
+
 drm_kms_helper-$(CONFIG_DRM_LOAD_EDID_FIRMWARE) += drm_edid_load.o
 drm_kms_helper-$(CONFIG_DRM_FBDEV_EMULATION) += drm_fb_helper.o
 drm_kms_helper-$(CONFIG_DRM_KMS_CMA_HELPER) += drm_fb_cma_helper.o
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 4e87542..3168a03 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -422,6 +422,7 @@ struct amdgpu_bo {
 	 */
 	struct list_head		va;
 	/* Constant after initialization */
+	struct drm_gem_object           gem_base;
 	struct amdgpu_bo		*parent;
 	struct amdgpu_bo		*shadow;
 
@@ -732,7 +733,7 @@ void amdgpu_doorbell_get_kfd_info(struct amdgpu_device *adev,
  */
 
 struct amdgpu_flip_work {
-	struct delayed_work		flip_work;
+	struct work_struct              flip_work;
 	struct work_struct		unpin_work;
 	struct amdgpu_device		*adev;
 	int				crtc_id;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c
index c13c51a..5b7a588 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c
@@ -601,14 +601,13 @@ static bool amdgpu_atpx_detect(void)
 void amdgpu_register_atpx_handler(void)
 {
 	bool r;
-	enum vga_switcheroo_handler_flags_t handler_flags = 0;
 
 	/* detect if we have any ATPX + 2 VGA in the system */
 	r = amdgpu_atpx_detect();
 	if (!r)
 		return;
 
-	vga_switcheroo_register_handler(&amdgpu_atpx_handler, handler_flags);
+	vga_switcheroo_register_handler(&amdgpu_atpx_handler);
 }
 
 /**
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c
index 9bdd5d6..29f463e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c
@@ -107,7 +107,7 @@ static int amdgpu_bo_list_set(struct amdgpu_device *adev,
 		struct amdgpu_bo *bo;
 		struct mm_struct *usermm;
 
-		gobj = drm_gem_object_lookup(filp, info[i].bo_handle);
+		gobj = drm_gem_object_lookup(adev->ddev, filp, info[i].bo_handle);
 		if (!gobj) {
 			r = -ENOENT;
 			goto error_free;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index 699f5fe..71122ba 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
@@ -109,7 +109,7 @@ static int amdgpu_cs_user_fence_chunk(struct amdgpu_cs_parser *p,
 	struct drm_gem_object *gobj;
 	unsigned long size;
 
-	gobj = drm_gem_object_lookup(p->filp, data->handle);
+	gobj = drm_gem_object_lookup(p->adev->ddev, p->filp, data->handle);
 	if (gobj == NULL)
 		return -EINVAL;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c
index af64448..8158ae8 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c
@@ -41,7 +41,7 @@ static void amdgpu_flip_callback(struct fence *f, struct fence_cb *cb)
 		container_of(cb, struct amdgpu_flip_work, cb);
 
 	fence_put(f);
-	schedule_work(&work->flip_work.work);
+	schedule_work(&work->flip_work);
 }
 
 static bool amdgpu_flip_handle_fence(struct amdgpu_flip_work *work,
@@ -138,118 +138,126 @@ static void amdgpu_unpin_work_func(struct work_struct *__work)
 	kfree(work);
 }
 
-int amdgpu_crtc_page_flip_target(struct drm_crtc *crtc,
-				 struct drm_framebuffer *fb,
-				 struct drm_pending_vblank_event *event,
-				 uint32_t page_flip_flags, uint32_t target)
+int amdgpu_crtc_page_flip(struct drm_crtc *crtc,
+                          struct drm_framebuffer *fb,
+                          struct drm_pending_vblank_event *event,
+                          uint32_t page_flip_flags)
 {
-	struct drm_device *dev = crtc->dev;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);
-	struct amdgpu_framebuffer *old_amdgpu_fb;
-	struct amdgpu_framebuffer *new_amdgpu_fb;
-	struct drm_gem_object *obj;
-	struct amdgpu_flip_work *work;
-	struct amdgpu_bo *new_abo;
-	unsigned long flags;
-	u64 tiling_flags;
-	u64 base;
-	int i, r;
-
-	work = kzalloc(sizeof *work, GFP_KERNEL);
-	if (work == NULL)
-		return -ENOMEM;
-
-	INIT_DELAYED_WORK(&work->flip_work, amdgpu_flip_work_func);
-	INIT_WORK(&work->unpin_work, amdgpu_unpin_work_func);
-
-	work->event = event;
-	work->adev = adev;
-	work->crtc_id = amdgpu_crtc->crtc_id;
-	work->async = (page_flip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;
-
-	/* schedule unpin of the old buffer */
-	old_amdgpu_fb = to_amdgpu_framebuffer(crtc->primary->fb);
-	obj = old_amdgpu_fb->obj;
-
-	/* take a reference to the old object */
-	work->old_abo = gem_to_amdgpu_bo(obj);
-	amdgpu_bo_ref(work->old_abo);
-
-	new_amdgpu_fb = to_amdgpu_framebuffer(fb);
-	obj = new_amdgpu_fb->obj;
-	new_abo = gem_to_amdgpu_bo(obj);
-
-	/* pin the new buffer */
-	r = amdgpu_bo_reserve(new_abo, false);
-	if (unlikely(r != 0)) {
-		DRM_ERROR("failed to reserve new abo buffer before flip\n");
-		goto cleanup;
-	}
-
-	r = amdgpu_bo_pin(new_abo, AMDGPU_GEM_DOMAIN_VRAM, &base);
-	if (unlikely(r != 0)) {
-		DRM_ERROR("failed to pin new abo buffer before flip\n");
-		goto unreserve;
-	}
-
-	r = reservation_object_get_fences_rcu(new_abo->tbo.resv, &work->excl,
-					      &work->shared_count,
-					      &work->shared);
-	if (unlikely(r != 0)) {
-		DRM_ERROR("failed to get fences for buffer\n");
-		goto unpin;
-	}
-
-	amdgpu_bo_get_tiling_flags(new_abo, &tiling_flags);
-	amdgpu_bo_unreserve(new_abo);
-
-	work->base = base;
-	work->target_vblank = target - drm_crtc_vblank_count(crtc) +
-		amdgpu_get_vblank_counter_kms(dev, work->crtc_id);
-
-	/* we borrow the event spin lock for protecting flip_wrok */
-	spin_lock_irqsave(&crtc->dev->event_lock, flags);
-	if (amdgpu_crtc->pflip_status != AMDGPU_FLIP_NONE) {
-		DRM_DEBUG_DRIVER("flip queue: crtc already busy\n");
-		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-		r = -EBUSY;
-		goto pflip_cleanup;
-	}
-
-	amdgpu_crtc->pflip_status = AMDGPU_FLIP_PENDING;
-	amdgpu_crtc->pflip_works = work;
-
-
-	DRM_DEBUG_DRIVER("crtc:%d[%p], pflip_stat:AMDGPU_FLIP_PENDING, work: %p,\n",
-			 amdgpu_crtc->crtc_id, amdgpu_crtc, work);
-	/* update crtc fb */
-	crtc->primary->fb = fb;
-	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-	amdgpu_flip_work_func(&work->flip_work.work);
-	return 0;
+        struct drm_device *dev = crtc->dev;
+        struct amdgpu_device *adev = dev->dev_private;
+        struct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);
+        struct amdgpu_framebuffer *old_amdgpu_fb;
+        struct amdgpu_framebuffer *new_amdgpu_fb;
+        struct drm_gem_object *obj;
+        struct amdgpu_flip_work *work;
+        struct amdgpu_bo *new_abo;
+        unsigned long flags;
+        u64 tiling_flags;
+        u64 base;
+        int i, r;
+
+        work = kzalloc(sizeof *work, GFP_KERNEL);
+        if (work == NULL)
+                return -ENOMEM;
+
+        INIT_WORK(&work->flip_work, amdgpu_flip_work_func);
+        INIT_WORK(&work->unpin_work, amdgpu_unpin_work_func);
+
+        work->event = event;
+        work->adev = adev;
+        work->crtc_id = amdgpu_crtc->crtc_id;
+        work->async = (page_flip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;
+
+        /* schedule unpin of the old buffer */
+        old_amdgpu_fb = to_amdgpu_framebuffer(crtc->primary->fb);
+        obj = old_amdgpu_fb->obj;
+
+        /* take a reference to the old object */
+        work->old_abo = gem_to_amdgpu_bo(obj);
+        amdgpu_bo_ref(work->old_abo);
+
+        new_amdgpu_fb = to_amdgpu_framebuffer(fb);
+        obj = new_amdgpu_fb->obj;
+        new_abo = gem_to_amdgpu_bo(obj);
+
+        /* pin the new buffer */
+        r = amdgpu_bo_reserve(new_abo, false);
+        if (unlikely(r != 0)) {
+                DRM_ERROR("failed to reserve new abo buffer before flip\n");
+                goto cleanup;
+        }
+
+        r = amdgpu_bo_pin(new_abo, AMDGPU_GEM_DOMAIN_VRAM, &base);
+        if (unlikely(r != 0)) {
+                r = -EINVAL;
+                DRM_ERROR("failed to pin new abo buffer before flip\n");
+                goto unreserve;
+        }
+
+        r = reservation_object_get_fences_rcu(new_abo->tbo.resv, &work->excl,
+                                              &work->shared_count,
+                                              &work->shared);
+        if (unlikely(r != 0)) {
+                DRM_ERROR("failed to get fences for buffer\n");
+                goto unpin;
+        }
+
+        amdgpu_bo_get_tiling_flags(new_abo, &tiling_flags);
+        amdgpu_bo_unreserve(new_abo);
+
+        work->base = base;
+
+        r = drm_crtc_vblank_get(crtc);
+        if (r) {
+                DRM_ERROR("failed to get vblank before flip\n");
+                goto pflip_cleanup;
+        }
+
+        /* we borrow the event spin lock for protecting flip_wrok */
+        spin_lock_irqsave(&crtc->dev->event_lock, flags);
+        if (amdgpu_crtc->pflip_status != AMDGPU_FLIP_NONE) {
+                DRM_DEBUG_DRIVER("flip queue: crtc already busy\n");
+                spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+                r = -EBUSY;
+                goto vblank_cleanup;
+        }
+
+        amdgpu_crtc->pflip_status = AMDGPU_FLIP_PENDING;
+        amdgpu_crtc->pflip_works = work;
+
+
+        DRM_DEBUG_DRIVER("crtc:%d[%p], pflip_stat:AMDGPU_FLIP_PENDING, work: %p,\n",
+                                         amdgpu_crtc->crtc_id, amdgpu_crtc, work);
+        /* update crtc fb */
+        crtc->primary->fb = fb;
+        spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+        amdgpu_flip_work_func(&work->flip_work);
+        return 0;
+
+vblank_cleanup:
+        drm_crtc_vblank_put(crtc);
 
 pflip_cleanup:
-	if (unlikely(amdgpu_bo_reserve(new_abo, true) != 0)) {
-		DRM_ERROR("failed to reserve new abo in error path\n");
-		goto cleanup;
-	}
+        if (unlikely(amdgpu_bo_reserve(new_abo, false) != 0)) {
+                DRM_ERROR("failed to reserve new abo in error path\n");
+                goto cleanup;
+        }
 unpin:
-	if (unlikely(amdgpu_bo_unpin(new_abo) != 0)) {
-		DRM_ERROR("failed to unpin new abo in error path\n");
-	}
+        if (unlikely(amdgpu_bo_unpin(new_abo) != 0)) {
+                DRM_ERROR("failed to unpin new abo in error path\n");
+        }
 unreserve:
-	amdgpu_bo_unreserve(new_abo);
+        amdgpu_bo_unreserve(new_abo);
 
 cleanup:
-	amdgpu_bo_unref(&work->old_abo);
-	fence_put(work->excl);
-	for (i = 0; i < work->shared_count; ++i)
-		fence_put(work->shared[i]);
-	kfree(work->shared);
-	kfree(work);
-
-	return r;
+        amdgpu_bo_unref(&work->old_abo);
+        fence_put(work->excl);
+        for (i = 0; i < work->shared_count; ++i)
+                fence_put(work->shared[i]);
+        kfree(work->shared);
+        kfree(work);
+
+        return r;
 }
 
 int amdgpu_crtc_set_config(struct drm_mode_set *set)
@@ -525,7 +533,7 @@ amdgpu_user_framebuffer_create(struct drm_device *dev,
 	struct amdgpu_framebuffer *amdgpu_fb;
 	int ret;
 
-	obj = drm_gem_object_lookup(file_priv, mode_cmd->handles[0]);
+	obj = drm_gem_object_lookup(dev, file_priv, mode_cmd->handles[0]);
 	if (obj ==  NULL) {
 		dev_err(&dev->pdev->dev, "No GEM object associated to handle 0x%08X, "
 			"can't create framebuffer\n", mode_cmd->handles[0]);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 6778ea5..0825d17 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
@@ -379,7 +379,7 @@ int amdgpu_mode_dumb_mmap(struct drm_file *filp,
 	struct drm_gem_object *gobj;
 	struct amdgpu_bo *robj;
 
-	gobj = drm_gem_object_lookup(filp, handle);
+	gobj = drm_gem_object_lookup(dev, filp, handle);
 	if (gobj == NULL) {
 		return -ENOENT;
 	}
@@ -442,7 +442,7 @@ int amdgpu_gem_wait_idle_ioctl(struct drm_device *dev, void *data,
 	int r = 0;
 	long ret;
 
-	gobj = drm_gem_object_lookup(filp, handle);
+	gobj = drm_gem_object_lookup(dev, filp, handle);
 	if (gobj == NULL) {
 		return -ENOENT;
 	}
@@ -475,7 +475,7 @@ int amdgpu_gem_metadata_ioctl(struct drm_device *dev, void *data,
 	int r = -1;
 
 	DRM_DEBUG("%d \n", args->handle);
-	gobj = drm_gem_object_lookup(filp, args->handle);
+	gobj = drm_gem_object_lookup(dev, filp, args->handle);
 	if (gobj == NULL)
 		return -ENOENT;
 	robj = gem_to_amdgpu_bo(gobj);
@@ -603,7 +603,7 @@ int amdgpu_gem_va_ioctl(struct drm_device *dev, void *data,
 	INIT_LIST_HEAD(&list);
 	if ((args->operation != AMDGPU_VA_OP_CLEAR) &&
 	    !(args->flags & AMDGPU_VM_PAGE_PRT)) {
-		gobj = drm_gem_object_lookup(filp, args->handle);
+		gobj = drm_gem_object_lookup(dev, filp, args->handle);
 		if (gobj == NULL)
 			return -ENOENT;
 		abo = gem_to_amdgpu_bo(gobj);
@@ -688,7 +688,7 @@ int amdgpu_gem_op_ioctl(struct drm_device *dev, void *data,
 	struct amdgpu_bo *robj;
 	int r;
 
-	gobj = drm_gem_object_lookup(filp, args->handle);
+	gobj = drm_gem_object_lookup(dev, filp, args->handle);
 	if (gobj == NULL) {
 		return -ENOENT;
 	}
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index 9362a04..8316076 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
@@ -702,6 +702,11 @@ int amdgpu_crtc_page_flip_target(struct drm_crtc *crtc,
 				 struct drm_framebuffer *fb,
 				 struct drm_pending_vblank_event *event,
 				 uint32_t page_flip_flags, uint32_t target);
+int amdgpu_crtc_page_flip(struct drm_crtc *crtc,
+                          struct drm_framebuffer *fb,
+                          struct drm_pending_vblank_event *event,
+                          uint32_t page_flip_flags);
+
 extern const struct drm_mode_config_funcs amdgpu_mode_funcs;
 
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
index d8bc255..67bf897 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
@@ -74,7 +74,7 @@ static inline int amdgpu_bo_reserve(struct amdgpu_bo *bo, bool no_intr)
 	struct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);
 	int r;
 
-	r = ttm_bo_reserve(&bo->tbo, !no_intr, false, NULL);
+	r = ttm_bo_reserve(&bo->tbo, !no_intr, false, false, NULL);
 	if (unlikely(r != 0)) {
 		if (r != -ERESTARTSYS)
 			dev_err(adev->dev, "%p reserve failed\n", bo);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
index 278f55b..744dc9b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
@@ -353,7 +353,8 @@ static int amdgpu_move_blit(struct ttm_buffer_object *bo,
 		}
 	}
 
-	r = ttm_bo_pipeline_move(bo, fence, evict, new_mem);
+ 	r = ttm_bo_move_accel_cleanup(bo, fence,
+					evict, no_wait_gpu, new_mem);
 	fence_put(fence);
 	return r;
 
@@ -585,6 +586,7 @@ int amdgpu_ttm_tt_get_user_pages(struct ttm_tt *ttm, struct page **pages)
 {
 	struct amdgpu_ttm_tt *gtt = (void *)ttm;
 	unsigned int flags = 0;
+ 	int write = !(gtt->userflags & AMDGPU_GEM_USERPTR_READONLY);
 	unsigned pinned = 0;
 	int r;
 
@@ -613,7 +615,8 @@ int amdgpu_ttm_tt_get_user_pages(struct ttm_tt *ttm, struct page **pages)
 		list_add(&guptask.list, &gtt->guptasks);
 		spin_unlock(&gtt->guptasklock);
 
-		r = get_user_pages(userptr, num_pages, flags, p, NULL);
+                r = get_user_pages(current, current->mm, userptr, num_pages,
+					write, 0, p, NULL);
 
 		spin_lock(&gtt->guptasklock);
 		list_del(&guptask.list);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.h
index 0eabbb2..b811021 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.h
@@ -26,13 +26,17 @@
 
 #include "gpu_scheduler.h"
 
-#define AMDGPU_PL_GDS		(TTM_PL_PRIV + 0)
-#define AMDGPU_PL_GWS		(TTM_PL_PRIV + 1)
-#define AMDGPU_PL_OA		(TTM_PL_PRIV + 2)
+#define AMDGPU_PL_GDS		(TTM_PL_PRIV0 + 0)
+#define AMDGPU_PL_GWS		(TTM_PL_PRIV0 + 1)
+#define AMDGPU_PL_OA		(TTM_PL_PRIV0 + 2)
+#define AMDGPU_PL_DGMA         (TTM_PL_PRIV0 + 3)
+#define AMDGPU_PL_DGMA_IMPORT  (TTM_PL_PRIV0 + 4)
 
-#define AMDGPU_PL_FLAG_GDS		(TTM_PL_FLAG_PRIV << 0)
-#define AMDGPU_PL_FLAG_GWS		(TTM_PL_FLAG_PRIV << 1)
-#define AMDGPU_PL_FLAG_OA		(TTM_PL_FLAG_PRIV << 2)
+#define AMDGPU_PL_FLAG_GDS		(TTM_PL_FLAG_PRIV0 << 0)
+#define AMDGPU_PL_FLAG_GWS		(TTM_PL_FLAG_PRIV0 << 1)
+#define AMDGPU_PL_FLAG_OA		(TTM_PL_FLAG_PRIV0 << 2)
+#define AMDGPU_PL_FLAG_DGMA            (TTM_PL_FLAG_PRIV0 << 3)
+#define AMDGPU_PL_FLAG_DGMA_IMPORT     (TTM_PL_FLAG_PRIV0 << 4)
 
 struct amdgpu_mman {
 	struct ttm_bo_global_ref        bo_global_ref;
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
index d618f92..21f8764 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
@@ -2544,7 +2544,7 @@ static int dce_v10_0_crtc_cursor_set2(struct drm_crtc *crtc,
 		return -EINVAL;
 	}
 
-	obj = drm_gem_object_lookup(file_priv, handle);
+	obj = drm_gem_object_lookup(crtc->dev, file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, amdgpu_crtc->crtc_id);
 		return -ENOENT;
@@ -2649,7 +2649,7 @@ static const struct drm_crtc_funcs dce_v10_0_crtc_funcs = {
 	.gamma_set = dce_v10_0_crtc_gamma_set,
 	.set_config = amdgpu_crtc_set_config,
 	.destroy = dce_v10_0_crtc_destroy,
-	.page_flip_target = amdgpu_crtc_page_flip_target,
+        .page_flip = amdgpu_crtc_page_flip,
 };
 
 static void dce_v10_0_crtc_dpms(struct drm_crtc *crtc, int mode)
@@ -3684,7 +3684,7 @@ static void dce_v10_0_encoder_add(struct amdgpu_device *adev,
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
 		drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+				 DRM_MODE_ENCODER_DAC);
 		drm_encoder_helper_add(encoder, &dce_v10_0_dac_helper_funcs);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
@@ -3695,15 +3695,15 @@ static void dce_v10_0_encoder_add(struct amdgpu_device *adev,
 		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 			amdgpu_encoder->rmx_type = RMX_FULL;
 			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
 			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_lcd_info(amdgpu_encoder);
 		} else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
 			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
 			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
 		} else {
 			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
 			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
 		}
 		drm_encoder_helper_add(encoder, &dce_v10_0_dig_helper_funcs);
@@ -3721,13 +3721,13 @@ static void dce_v10_0_encoder_add(struct amdgpu_device *adev,
 		amdgpu_encoder->is_ext_encoder = true;
 		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
 			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
 		else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
 			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
 		else
 			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
 		drm_encoder_helper_add(encoder, &dce_v10_0_ext_helper_funcs);
 		break;
 	}
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
index ea63415..4c19df5 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
@@ -2564,7 +2564,7 @@ static int dce_v11_0_crtc_cursor_set2(struct drm_crtc *crtc,
 		return -EINVAL;
 	}
 
-	obj = drm_gem_object_lookup(file_priv, handle);
+	obj = drm_gem_object_lookup(crtc->dev, file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, amdgpu_crtc->crtc_id);
 		return -ENOENT;
@@ -2669,7 +2669,7 @@ static const struct drm_crtc_funcs dce_v11_0_crtc_funcs = {
 	.gamma_set = dce_v11_0_crtc_gamma_set,
 	.set_config = amdgpu_crtc_set_config,
 	.destroy = dce_v11_0_crtc_destroy,
-	.page_flip_target = amdgpu_crtc_page_flip_target,
+	.page_flip = amdgpu_crtc_page_flip,
 };
 
 static void dce_v11_0_crtc_dpms(struct drm_crtc *crtc, int mode)
@@ -3753,7 +3753,7 @@ static void dce_v11_0_encoder_add(struct amdgpu_device *adev,
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
 		drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+				 DRM_MODE_ENCODER_DAC);
 		drm_encoder_helper_add(encoder, &dce_v11_0_dac_helper_funcs);
 		break;
 	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
@@ -3764,15 +3764,15 @@ static void dce_v11_0_encoder_add(struct amdgpu_device *adev,
 		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 			amdgpu_encoder->rmx_type = RMX_FULL;
 			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
 			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_lcd_info(amdgpu_encoder);
 		} else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
 			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
 			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
 		} else {
 			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
 			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
 		}
 		drm_encoder_helper_add(encoder, &dce_v11_0_dig_helper_funcs);
@@ -3790,13 +3790,13 @@ static void dce_v11_0_encoder_add(struct amdgpu_device *adev,
 		amdgpu_encoder->is_ext_encoder = true;
 		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
 			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
 		else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
 			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
 		else
 			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
 		drm_encoder_helper_add(encoder, &dce_v11_0_ext_helper_funcs);
 		break;
 	}
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
index d68c1ea..a15fd40 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
@@ -2525,7 +2525,7 @@ static const struct drm_crtc_funcs dce_v6_0_crtc_funcs = {
 	.gamma_set = dce_v6_0_crtc_gamma_set,
 	.set_config = amdgpu_crtc_set_config,
 	.destroy = dce_v6_0_crtc_destroy,
-	.page_flip_target = amdgpu_crtc_page_flip_target,
+	.page_flip = amdgpu_crtc_page_flip,
 };
 
 static void dce_v6_0_crtc_dpms(struct drm_crtc *crtc, int mode)
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index 1e6c40e..7956ffd 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -2500,7 +2500,7 @@ static const struct drm_crtc_funcs dce_v8_0_crtc_funcs = {
 	.gamma_set = dce_v8_0_crtc_gamma_set,
 	.set_config = amdgpu_crtc_set_config,
 	.destroy = dce_v8_0_crtc_destroy,
-	.page_flip_target = amdgpu_crtc_page_flip_target,
+	.page_flip = amdgpu_crtc_page_flip,
 };
 
 static void dce_v8_0_crtc_dpms(struct drm_crtc *crtc, int mode)
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
index 0845183..f9061944 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
@@ -194,7 +194,7 @@ static const struct drm_crtc_funcs dce_virtual_crtc_funcs = {
 	.gamma_set = dce_virtual_crtc_gamma_set,
 	.set_config = amdgpu_crtc_set_config,
 	.destroy = dce_virtual_crtc_destroy,
-	.page_flip_target = amdgpu_crtc_page_flip_target,
+	.page_flip = amdgpu_crtc_page_flip,
 };
 
 static void dce_virtual_crtc_dpms(struct drm_crtc *crtc, int mode)
@@ -658,7 +658,7 @@ static int dce_virtual_connector_encoder_init(struct amdgpu_device *adev,
 		return -ENOMEM;
 	encoder->possible_crtcs = 1 << index;
 	drm_encoder_init(adev->ddev, encoder, &dce_virtual_encoder_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
+			 DRM_MODE_ENCODER_VIRTUAL);
 	drm_encoder_helper_add(encoder, &dce_virtual_encoder_helper_funcs);
 
 	connector = kzalloc(sizeof(struct drm_connector), GFP_KERNEL);
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index cdb5168..7b41b7f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -641,11 +641,7 @@ static struct drm_mode_config_funcs amdgpu_dm_mode_funcs = {
 	.fb_create = amdgpu_user_framebuffer_create,
 	.output_poll_changed = amdgpu_output_poll_changed,
 	.atomic_check = amdgpu_dm_atomic_check,
-	.atomic_commit = drm_atomic_helper_commit
-};
-
-static struct drm_mode_config_helper_funcs amdgpu_dm_mode_config_helperfuncs = {
-	.atomic_commit_tail = amdgpu_dm_atomic_commit_tail
+	.atomic_commit = amdgpu_dm_atomic_commit
 };
 
 void amdgpu_dm_update_connector_after_detect(
@@ -1021,7 +1017,6 @@ static int amdgpu_dm_mode_config_init(struct amdgpu_device *adev)
 	adev->mode_info.mode_config_initialized = true;
 
 	adev->ddev->mode_config.funcs = (void *)&amdgpu_dm_mode_funcs;
-	adev->ddev->mode_config.helper_private = &amdgpu_dm_mode_config_helperfuncs;
 
 	adev->ddev->mode_config.max_width = 16384;
 	adev->ddev->mode_config.max_height = 16384;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
index af03ded..4155ecc 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
@@ -729,6 +729,56 @@ static void update_stream_scaling_settings(
 
 }
 
+static void dm_dc_surface_commit(
+                struct dc *dc,
+                struct drm_crtc *crtc)
+{
+        struct dc_surface *dc_surface;
+        const struct dc_surface *dc_surfaces[1];
+        const struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+        const struct dc_stream *dc_stream = acrtc->stream;
+
+        if (!dc_stream) {
+                dm_error(
+                        "%s: Failed to obtain stream on crtc (%d)!\n",
+                        __func__,
+                        acrtc->crtc_id);
+                goto fail;
+        }
+
+        dc_surface = dc_create_surface(dc);
+
+        if (!dc_surface) {
+                dm_error(
+                        "%s: Failed to create a surface!\n",
+                        __func__);
+                goto fail;
+        }
+
+        /* Surface programming */
+        fill_plane_attributes(
+                        crtc->dev->dev_private,
+                        dc_surface,
+                        crtc->primary->state,
+                        true);
+
+        dc_surfaces[0] = dc_surface;
+
+        if (false == dc_commit_surfaces_to_stream(
+                        dc,
+                        dc_surfaces,
+                        1,
+                        dc_stream)) {
+                dm_error(
+                        "%s: Failed to attach surface!\n",
+                        __func__);
+        }
+
+        dc_surface_release(dc_surface);
+fail:
+        return;
+}
+
 static void add_surface(struct dc *dc,
 			struct drm_crtc *crtc,
 			struct drm_plane *plane,
@@ -1674,7 +1724,7 @@ static void dm_drm_plane_destroy_state(struct drm_plane *plane,
 {
         struct amdgpu_drm_plane_state *old_amdgpu_state =
                                         to_amdgpu_plane_state(old_state);
-        __drm_atomic_helper_plane_destroy_state(old_state);
+        __drm_atomic_helper_plane_destroy_state(plane, old_state);
         kfree(old_amdgpu_state);
 }
 
@@ -1701,7 +1751,6 @@ static void clear_unrelated_fields(struct drm_plane_state *state)
 static bool page_flip_needed(
 	const struct drm_plane_state *new_state,
 	const struct drm_plane_state *old_state,
-	struct drm_pending_vblank_event *event,
 	bool commit_surface_required)
 {
 	struct drm_plane_state old_state_tmp;
@@ -1731,9 +1780,9 @@ static bool page_flip_needed(
 	old_state_tmp = *old_state;
 	new_state_tmp = *new_state;
 
-	if (!event)
-		return false;
-
+        if (!new_state->crtc->state->event)
+                return false;
+	
 	amdgpu_fb_old = to_amdgpu_framebuffer(old_state->fb);
 	amdgpu_fb_new = to_amdgpu_framebuffer(new_state->fb);
 
@@ -1911,7 +1960,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
                                 &dm_plane_funcs,
                                 rgb_formats,
                                 ARRAY_SIZE(rgb_formats),
-                                aplane->plane_type, NULL);
+	                        aplane->plane_type);
                 break;
         case DRM_PLANE_TYPE_OVERLAY:
                 res = drm_universal_plane_init(
@@ -1921,7 +1970,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
                                 &dm_plane_funcs,
                                 yuv_formats,
                                 ARRAY_SIZE(yuv_formats),
-                                aplane->plane_type, NULL);
+                                aplane->plane_type);
                 break;
         case DRM_PLANE_TYPE_CURSOR:
                 DRM_ERROR("KMS: Cursor plane not implemented.");
@@ -1934,7 +1983,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
 }
 
 int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
-			struct amdgpu_crtc *acrtc,
+                        struct drm_plane *plane,
 			uint32_t crtc_index)
 {
         struct amdgpu_crtc *acrtc;
@@ -1949,7 +1998,7 @@ int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
                         &acrtc->base,
                         plane,
                         NULL,
-                        &amdgpu_dm_crtc_funcs, NULL);
+                        &amdgpu_dm_crtc_funcs);
 
         if (res)
                 goto fail;
@@ -2447,6 +2496,45 @@ static enum dm_commit_action get_dm_commit_action(struct drm_crtc_state *state)
 	}
 }
 
+typedef bool (*predicate)(struct amdgpu_crtc *acrtc);
+
+static void wait_while_pflip_status(struct amdgpu_device *adev,
+                struct amdgpu_crtc *acrtc, predicate f) {
+        int count = 0;
+        while (f(acrtc)) {
+                /* Spin Wait*/
+                msleep(1);
+                count++;
+                if (count == 1000) {
+                        DRM_ERROR("%s - crtc:%d[%p], pflip_stat:%d, probable hang!\n",
+                                                                                __func__, acrtc->crtc_id,
+                                                                                acrtc,
+                                                                                acrtc->pflip_status);
+
+                        /* we do not expect to hit this case except on Polaris with PHY PLL
+                         * 1. DP to HDMI passive dongle connected
+                         * 2. unplug (headless)
+                         * 3. plug in DP
+                         * 3a. on plug in, DP will try verify link by training, and training
+                         * would disable PHY PLL which HDMI rely on to drive TG
+                         * 3b. this will cause flip interrupt cannot be generated, and we
+                         * exit when timeout expired.  however we do not have code to clean
+                         * up flip, flip clean up will happen when the address is written
+                         * with the restore mode change
+                         */
+                        WARN_ON(1);
+                        break;
+                }
+        }
+
+        DRM_DEBUG_DRIVER("%s - Finished waiting for:%d msec, crtc:%d[%p], pflip_stat:%d \n",
+                                                                                        __func__,
+                                                                                        count,
+                                                                                        acrtc->crtc_id,
+                                                                                        acrtc,
+                                                                                        acrtc->pflip_status);
+}
+
 static void manage_dm_interrupts(
 	struct amdgpu_device *adev,
 	struct amdgpu_crtc *acrtc,
@@ -2477,6 +2565,11 @@ static void manage_dm_interrupts(
 	}
 }
 
+static bool pflip_pending_predicate(struct amdgpu_crtc *acrtc)
+{
+        return acrtc->pflip_status == AMDGPU_FLIP_PENDING;
+}
+
 static bool is_scaling_state_different(
 		const struct dm_connector_state *dm_state,
 		const struct dm_connector_state *old_dm_state)
@@ -2666,262 +2759,313 @@ void dc_commit_surfaces(struct drm_atomic_state *state,
 	}
 }
 
-void amdgpu_dm_atomic_commit_tail(
-	struct drm_atomic_state *state)
+int amdgpu_dm_atomic_commit(
+        struct drm_device *dev,
+        struct drm_atomic_state *state,
+        bool nonblock)
 {
-	struct drm_device *dev = state->dev;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct amdgpu_display_manager *dm = &adev->dm;
-	struct drm_plane *plane;
-	struct drm_plane_state *old_plane_state;
-	uint32_t i, j;
-	uint32_t commit_streams_count = 0;
-	uint32_t new_crtcs_count = 0;
-	struct drm_crtc *crtc, *pcrtc;
-	struct drm_crtc_state *old_crtc_state;
-	const struct dc_stream *commit_streams[MAX_STREAMS];
-	struct amdgpu_crtc *new_crtcs[MAX_STREAMS];
-	const struct dc_stream *new_stream;
-	unsigned long flags;
-	bool wait_for_vblank = true;
-
-
-	drm_atomic_helper_update_legacy_modeset_state(dev, state);
-
-	/* update changed items */
-	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
-		struct amdgpu_crtc *acrtc;
-		struct amdgpu_connector *aconnector = NULL;
-		enum dm_commit_action action;
-		struct drm_crtc_state *new_state = crtc->state;
-
-		acrtc = to_amdgpu_crtc(crtc);
+        struct amdgpu_device *adev = dev->dev_private;
+        struct amdgpu_display_manager *dm = &adev->dm;
+        struct drm_plane *plane;
+        struct drm_plane_state *old_plane_state;
+        uint32_t i;
+        int32_t ret = 0;
+        uint32_t commit_streams_count = 0;
+        uint32_t new_crtcs_count = 0;
+        struct drm_crtc *crtc;
+        struct drm_crtc_state *old_crtc_state;
 
-		aconnector =
-			amdgpu_dm_find_first_crct_matching_connector(
-				state,
-				crtc,
-				false);
+        const struct dc_stream *commit_streams[MAX_STREAMS];
+        struct amdgpu_crtc *new_crtcs[MAX_STREAMS];
+        const struct dc_stream *new_stream;
 
-		/* handles headless hotplug case, updating new_state and
-		 * aconnector as needed
-		 */
-
-		action = get_dm_commit_action(new_state);
-
-		switch (action) {
-		case DM_COMMIT_ACTION_DPMS_ON:
-		case DM_COMMIT_ACTION_SET: {
-			struct dm_connector_state *dm_state = NULL;
-			new_stream = NULL;
-
-			if (aconnector)
-				dm_state = to_dm_connector_state(aconnector->base.state);
-
-			new_stream = create_stream_for_sink(
-					aconnector,
-					&crtc->state->mode,
-					dm_state);
+        /* In this step all new fb would be pinned */
 
-			DRM_INFO("Atomic commit: SET crtc id %d: [%p]\n", acrtc->crtc_id, acrtc);
-
-			if (!new_stream) {
-				/*
-				 * this could happen because of issues with
-				 * userspace notifications delivery.
-				 * In this case userspace tries to set mode on
-				 * display which is disconnect in fact.
-				 * dc_sink in NULL in this case on aconnector.
-				 * We expect reset mode will come soon.
-				 *
-				 * This can also happen when unplug is done
-				 * during resume sequence ended
-				 *
-				 * In this case, we want to pretend we still
-				 * have a sink to keep the pipe running so that
-				 * hw state is consistent with the sw state
-				 */
-				DRM_DEBUG_KMS("%s: Failed to create new stream for crtc %d\n",
-						__func__, acrtc->base.base.id);
-				break;
-			}
-
-			if (acrtc->stream)
-				remove_stream(adev, acrtc);
-
-			/*
-			 * this loop saves set mode crtcs
-			 * we needed to enable vblanks once all
-			 * resources acquired in dc after dc_commit_streams
-			 */
-			new_crtcs[new_crtcs_count] = acrtc;
-			new_crtcs_count++;
-
-			acrtc->stream = new_stream;
-			acrtc->enabled = true;
-			acrtc->hw_mode = crtc->state->mode;
-			crtc->hwmode = crtc->state->mode;
+        /*
+         * TODO: Revisit when we support true asynchronous commit.
+         * Right now we receive async commit only from pageflip, in which case
+         * we should not pin/unpin the fb here, it should be done in
+         * amdgpu_crtc_flip and from the vblank irq handler.
+         */
+        if (!nonblock) {
+                ret = drm_atomic_helper_prepare_planes(dev, state);
+                if (ret)
+                        return ret;
+        }
 
-			break;
-		}
+        /*
+         * This is the point of no return - everything below never fails except
+         * when the hw goes bonghits. Which means we can commit the new state on
+         * the software side now.
+         */
+        drm_atomic_helper_swap_state(dev, state);
 
-		case DM_COMMIT_ACTION_NOTHING: {
-			struct dm_connector_state *dm_state = NULL;
+        /*
+         * From this point state become old state really. New state is
+         * initialized to appropriate objects and could be accessed from there
+         */
 
-			if (!aconnector)
-				break;
+        /*
+         * there is no fences usage yet in state. We can skip the following line
+         * wait_for_fences(dev, state);
+         */
 
-			dm_state = to_dm_connector_state(aconnector->base.state);
+        drm_atomic_helper_update_legacy_modeset_state(dev, state);
 
-			/* Scaling update */
-			update_stream_scaling_settings(&crtc->state->mode,
-					dm_state, acrtc->stream);
+        /* update changed items */
+        for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
+                struct amdgpu_crtc *acrtc;
+                struct amdgpu_connector *aconnector = NULL;
+                enum dm_commit_action action;
+                struct drm_crtc_state *new_state = crtc->state;
+
+                acrtc = to_amdgpu_crtc(crtc);
+
+                aconnector =
+                        amdgpu_dm_find_first_crct_matching_connector(
+                                state,
+                                crtc,
+                                false);
+
+                /* handles headless hotplug case, updating new_state and
+                 * aconnector as needed
+                 */
+
+                action = get_dm_commit_action(new_state);
+
+                switch (action) {
+                case DM_COMMIT_ACTION_DPMS_ON:
+                case DM_COMMIT_ACTION_SET: {
+                        struct dm_connector_state *dm_state = NULL;
+                        new_stream = NULL;
+
+                        if (aconnector)
+                                dm_state = to_dm_connector_state(aconnector->base.state);
+
+                        new_stream = create_stream_for_sink(
+                                        aconnector,
+                                        &crtc->state->mode,
+                                        dm_state);
+
+                        DRM_INFO("Atomic commit: SET crtc id %d: [%p]\n", acrtc->crtc_id, acrtc);
+
+                        if (!new_stream) {
+                                /*
+                                 * this could happen because of issues with
+                                 * userspace notifications delivery.
+                                 * In this case userspace tries to set mode on
+                                 * display which is disconnect in fact.
+                                 * dc_sink in NULL in this case on aconnector.
+                                 * We expect reset mode will come soon.
+                                 *
+                                 * This can also happen when unplug is done
+                                 * during resume sequence ended
+                                 *
+                                 * In this case, we want to pretend we still
+                                 * have a sink to keep the pipe running so that
+                                 * hw state is consistent with the sw state
+                                 */
+                                DRM_DEBUG_KMS("%s: Failed to create new stream for crtc %d\n",
+                                                __func__, acrtc->base.base.id);
+                                break;
+                        }
+
+                        if (acrtc->stream)
+                                remove_stream(adev, acrtc);
+
+                        /*
+                         * this loop saves set mode crtcs
+                         * we needed to enable vblanks once all
+                         * resources acquired in dc after dc_commit_streams
+                         */
+                        new_crtcs[new_crtcs_count] = acrtc;
+                        new_crtcs_count++;
+
+                        acrtc->stream = new_stream;
+                        acrtc->enabled = true;
+                        acrtc->hw_mode = crtc->state->mode;
+                        crtc->hwmode = crtc->state->mode;
+
+                        break;
+                }
 
-			break;
-		}
-		case DM_COMMIT_ACTION_DPMS_OFF:
-		case DM_COMMIT_ACTION_RESET:
-			DRM_INFO("Atomic commit: RESET. crtc id %d:[%p]\n", acrtc->crtc_id, acrtc);
-			/* i.e. reset mode */
-			if (acrtc->stream)
-				remove_stream(adev, acrtc);
-			break;
-		} /* switch() */
-	} /* for_each_crtc_in_state() */
+                case DM_COMMIT_ACTION_NOTHING: {
+                        struct dm_connector_state *dm_state = NULL;
 
-	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+                        if (!aconnector)
+                                break;
 
-		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+                        dm_state = to_dm_connector_state(aconnector->base.state);
 
-		if (acrtc->stream) {
-			commit_streams[commit_streams_count] = acrtc->stream;
-			++commit_streams_count;
-		}
-	}
+                        /* Scaling update */
+                        update_stream_scaling_settings(&crtc->state->mode,
+                                        dm_state, acrtc->stream);
 
-	/*
-	 * Add streams after required streams from new and replaced streams
-	 * are removed from freesync module
-	 */
-	if (adev->dm.freesync_module) {
-		for (i = 0; i < new_crtcs_count; i++) {
-			struct amdgpu_connector *aconnector = NULL;
-			new_stream = new_crtcs[i]->stream;
-			aconnector =
-				amdgpu_dm_find_first_crct_matching_connector(
-					state,
-					&new_crtcs[i]->base,
-					false);
-			if (!aconnector) {
-				DRM_INFO(
-						"Atomic commit: Failed to find connector for acrtc id:%d "
-						"skipping freesync init\n",
-						new_crtcs[i]->crtc_id);
-				continue;
-			}
+                        break;
+                }
+                case DM_COMMIT_ACTION_DPMS_OFF:
+                case DM_COMMIT_ACTION_RESET:
+                        DRM_INFO("Atomic commit: RESET. crtc id %d:[%p]\n", acrtc->crtc_id, acrtc);
+                        /* i.e. reset mode */
+                        if (acrtc->stream)
+                                remove_stream(adev, acrtc);
+                        break;
+                } /* switch() */
+        } /* for_each_crtc_in_state() */
+
+        list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 
-			mod_freesync_add_stream(adev->dm.freesync_module,
-						new_stream, &aconnector->caps);
-		}
-	}
+                struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
 
-	/* DC is optimized not to do anything if 'streams' didn't change. */
-	WARN_ON(!dc_commit_streams(dm->dc, commit_streams, commit_streams_count));
+                if (acrtc->stream) {
+                        commit_streams[commit_streams_count] = acrtc->stream;
+                        ++commit_streams_count;
+                }
+        }
 
-	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
-		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+        /*
+         * Add streams after required streams from new and replaced streams
+         * are removed from freesync module
+         */
+        if (adev->dm.freesync_module) {
+                for (i = 0; i < new_crtcs_count; i++) {
+                        struct amdgpu_connector *aconnector = NULL;
+                        new_stream = new_crtcs[i]->stream;
+                        aconnector =
+                                amdgpu_dm_find_first_crct_matching_connector(
+                                        state,
+                                        &new_crtcs[i]->base,
+                                        false);
+                        if (!aconnector) {
+                                DRM_INFO(
+                                                "Atomic commit: Failed to find connector for acrtc id:%d "
+                                                "skipping freesync init\n",
+                                                new_crtcs[i]->crtc_id);
+                                continue;
+                        }
+
+                        mod_freesync_add_stream(adev->dm.freesync_module,
+                                                new_stream, &aconnector->caps);
+                }
+        }
 
-		if (acrtc->stream != NULL)
-			acrtc->otg_inst =
-				dc_stream_get_status(acrtc->stream)->primary_otg_inst;
-	}
+        /* DC is optimized not to do anything if 'streams' didn't change. */
+        WARN_ON(!dc_commit_streams(dm->dc, commit_streams, commit_streams_count));
 
-        /* update planes when needed per crtc*/
-        for_each_crtc_in_state(state, pcrtc, old_crtc_state, j)
-                dc_commit_surfaces(state, dev, dm, pcrtc);
+        list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+                struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
 
-	for (i = 0; i < new_crtcs_count; i++) {
-		/*
-		 * loop to enable interrupts on newly arrived crtc
-		 */
-		struct amdgpu_crtc *acrtc = new_crtcs[i];
+                if (acrtc->stream != NULL)
+                        acrtc->otg_inst =
+                                dc_stream_get_status(acrtc->stream)->primary_otg_inst;
+        }
 
-		if (adev->dm.freesync_module)
-			mod_freesync_notify_mode_change(
-				adev->dm.freesync_module, &acrtc->stream, 1);
+        /* update planes when needed */
+        for_each_plane_in_state(state, plane, old_plane_state, i) {
+                struct drm_plane_state *plane_state = plane->state;
+                struct drm_crtc *crtc = plane_state->crtc;
+                struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+                struct drm_framebuffer *fb = plane_state->fb;
+                struct drm_connector *connector;
+                struct dm_connector_state *dm_state = NULL;
+                enum dm_commit_action action;
 
-		manage_dm_interrupts(adev, acrtc, true);
-		dm_crtc_cursor_reset(&acrtc->base);
+                if (!fb || !crtc || !crtc->state->active)
+                        continue;
 
-	}
+                action = get_dm_commit_action(crtc->state);
 
-	for_each_plane_in_state(state, plane, old_plane_state, i) {
-		struct drm_plane_state *plane_state = plane->state;
-		struct drm_crtc *crtc = plane_state->crtc;
-		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
-		struct drm_framebuffer *fb = plane_state->fb;
-                bool pflip_needed;
+                /* Surfaces are created under two scenarios:
+                 * 1. This commit is not a page flip.
+                 * 2. This commit is a page flip, and streams are created.
+                 */
+                if (!page_flip_needed(plane_state, old_plane_state, true) ||
+                                action == DM_COMMIT_ACTION_DPMS_ON ||
+                                action == DM_COMMIT_ACTION_SET) {
+                        list_for_each_entry(connector,
+                                &dev->mode_config.connector_list, head) {
+                                if (connector->state->crtc == crtc) {
+                                        dm_state = to_dm_connector_state(
+                                                connector->state);
+                                        break;
+                                }
+                        }
+
+                        /*
+                         * This situation happens in the following case:
+                         * we are about to get set mode for connector who's only
+                         * possible crtc (in encoder crtc mask) is used by
+                         * another connector, that is why it will try to
+                         * re-assing crtcs in order to make configuration
+                         * supported. For our implementation we need to make all
+                         * encoders support all crtcs, then this issue will
+                         * never arise again. But to guard code from this issue
+                         * check is left.
+                         *
+                         * Also it should be needed when used with actual
+                         * drm_atomic_commit ioctl in future
+                         */
+                        if (!dm_state)
+                                continue;
+                        /*
+                         * if flip is pending (ie, still waiting for fence to return
+                         * before address is submitted) here, we cannot commit_surface
+                         * as commit_surface will pre-maturely write out the future
+                         * address. wait until flip is submitted before proceeding.
+                         */
+                        wait_while_pflip_status(adev, acrtc, pflip_pending_predicate);
+
+                        dm_dc_surface_commit(dm->dc, crtc);
+                }
+        }
 
-		if (!fb || !crtc || !crtc->state->planes_changed ||
-			!crtc->state->active)
-			continue;
- 
-	         pflip_needed = !state->allow_modeset; 
-                 if (pflip_needed) {
-                         wait_for_vblank =
-                                 acrtc->flip_flags & DRM_MODE_PAGE_FLIP_ASYNC ?
-                                 false : true;
- 
-                         amdgpu_dm_do_flip(
-                                 crtc,
-                                 fb,
-                                 drm_crtc_vblank_count(crtc) + wait_for_vblank);
- 
-			/*clean up the flags for next usage*/
-			acrtc->flip_flags = 0;
-		}
-	}
+        for (i = 0; i < new_crtcs_count; i++) {
+                /*
+                 * loop to enable interrupts on newly arrived crtc
+                 */
+                struct amdgpu_crtc *acrtc = new_crtcs[i];
 
+                if (adev->dm.freesync_module)
+                        mod_freesync_notify_mode_change(
+                                adev->dm.freesync_module, &acrtc->stream, 1);
 
-        /*TODO mark consumed event on all crtc assigned event
-         * in drm_atomic_helper_setup_commit just to signal completion
-         */
-        spin_lock_irqsave(&adev->ddev->event_lock, flags);
-        for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
-                struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
+                manage_dm_interrupts(adev, acrtc, true);
+                dm_crtc_cursor_reset(&acrtc->base);
 
-                if (acrtc->base.state->event &&
-                                acrtc->base.state->event->event.base.type != DRM_EVENT_FLIP_COMPLETE) {
-                        acrtc->event = acrtc->base.state->event;
-                        acrtc->base.state->event = NULL;
-                }
         }
-        spin_unlock_irqrestore(&adev->ddev->event_lock, flags);
-
-        /* Signal HW programming completion */
-        drm_atomic_helper_commit_hw_done(state);
-
-        if (wait_for_vblank)
-                drm_atomic_helper_wait_for_vblanks(dev, state);
 
-        /*TODO send vblank event on all crtc assigned event
-         * in drm_atomic_helper_setup_commit just to signal completion
-         */
-        spin_lock_irqsave(&adev->ddev->event_lock, flags);
-        for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
+        /* Page flip if needed */
+        for_each_plane_in_state(state, plane, old_plane_state, i) {
+                struct drm_plane_state *plane_state = plane->state;
+                struct drm_crtc *crtc = plane_state->crtc;
                 struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
-
-                if (acrtc->event &&
-                        acrtc->event->event.base.type != DRM_EVENT_FLIP_COMPLETE) {
-                        drm_send_event_locked(dev, &acrtc->event->base);
-                        acrtc->event = NULL;
+                struct drm_framebuffer *fb = plane_state->fb;
+
+                if (!fb || !crtc || !crtc->state->planes_changed ||
+                        !crtc->state->active)
+                        continue;
+                if (page_flip_needed(plane_state, old_plane_state, false)) {
+                        ret = amdgpu_crtc_page_flip(crtc,
+                                                    fb,
+                                                    crtc->state->event,
+                                                    acrtc->flip_flags);
+
+                        /*clean up the flags for next usage*/
+                        acrtc->flip_flags = 0;
+                        if (ret)
+                                return ret;
                 }
         }
-        spin_unlock_irqrestore(&adev->ddev->event_lock, flags);
+
+        /* In this state all old framebuffers would be unpinned */
 
         /*TODO Is it to early if actual flip haven't happened yet ?*/
         /* Release old FB */
         drm_atomic_helper_cleanup_planes(dev, state);
+
+        drm_atomic_state_free(state);
+
+        return ret;
 }
 
 static int dm_force_atomic_commit(struct drm_connector *connector)
@@ -3276,7 +3420,7 @@ int amdgpu_dm_atomic_check(struct drm_device *dev,
 			crtc_state = drm_atomic_get_crtc_state(state, crtc);
                         pflip_needed = !state->allow_modeset &&
                                         page_flip_needed(plane_state, old_plane_state,
-                                        crtc_state->event, true);
+					true);
                         if (!pflip_needed ||
                                 action == DM_COMMIT_ACTION_DPMS_ON ||
                                 action == DM_COMMIT_ACTION_SET) {
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
index ab6d51d..e71ace8 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.h
@@ -55,8 +55,10 @@ void amdgpu_dm_encoder_destroy(struct drm_encoder *encoder);
 
 int amdgpu_dm_connector_get_modes(struct drm_connector *connector);
 
-void amdgpu_dm_atomic_commit_tail(
-	struct drm_atomic_state *state);
+int amdgpu_dm_atomic_commit(
+        struct drm_device *dev,
+        struct drm_atomic_state *state,
+        bool async);
 
 int amdgpu_dm_atomic_check(struct drm_device *dev,
 				struct drm_atomic_state *state);
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 24c5434..8a8e38f 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -647,6 +647,54 @@ void drm_framebuffer_remove(struct drm_framebuffer *fb)
 }
 EXPORT_SYMBOL(drm_framebuffer_remove);
 
+/*
+ * Optional properties
+ */
+/**
+ * drm_crtc_force_disable - Forcibly turn off a CRTC
+ * @crtc: CRTC to turn off
+ *
+ * Returns:
+ * Zero on success, error code on failure.
+ */
+int drm_crtc_force_disable(struct drm_crtc *crtc)
+{
+        struct drm_mode_set set = {
+                .crtc = crtc,
+        };
+
+        return drm_mode_set_config_internal(&set);
+}
+EXPORT_SYMBOL(drm_crtc_force_disable);
+
+/**
+ * drm_crtc_force_disable_all - Forcibly turn off all enabled CRTCs
+ * @dev: DRM device whose CRTCs to turn off
+ *
+ * Drivers may want to call this on unload to ensure that all displays are
+ * unlit and the GPU is in a consistent, low power state. Takes modeset locks.
+ *
+ * Returns:
+ * Zero on success, error code on failure.
+ */
+int drm_crtc_force_disable_all(struct drm_device *dev)
+{
+        struct drm_crtc *crtc;
+        int ret = 0;
+
+        drm_modeset_lock_all(dev);
+        drm_for_each_crtc(crtc, dev)
+                if (crtc->enabled) {
+                        ret = drm_crtc_force_disable(crtc);
+                        if (ret)
+                                goto out;
+                }
+out:
+        drm_modeset_unlock_all(dev);
+        return ret;
+}
+EXPORT_SYMBOL(drm_crtc_force_disable_all);
+
 DEFINE_WW_CLASS(crtc_ww_class);
 
 /**
diff --git a/include/drm/drm_atomic_helper.h b/include/drm/drm_atomic_helper.h
index d70b295..e9ee826 100644
--- a/include/drm/drm_atomic_helper.h
+++ b/include/drm/drm_atomic_helper.h
@@ -136,6 +136,11 @@ __drm_atomic_helper_connector_destroy_state(struct drm_connector *connector,
 					    struct drm_connector_state *state);
 void drm_atomic_helper_connector_destroy_state(struct drm_connector *connector,
 					  struct drm_connector_state *state);
+int drm_atomic_helper_legacy_gamma_set(struct drm_crtc *crtc,
+                                       u16 *red, u16 *green, u16 *blue,
+                                       uint32_t size);
+
+
 
 /**
  * drm_atomic_crtc_for_each_plane - iterate over planes currently attached to CRTC
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index de4ed81..42f6456 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -329,6 +329,11 @@ struct drm_crtc_state {
 	/* blob property to expose current mode to atomic userspace */
 	struct drm_property_blob *mode_blob;
 
+        /* blob property to expose color management to userspace */
+        struct drm_property_blob *degamma_lut;
+        struct drm_property_blob *ctm;
+        struct drm_property_blob *gamma_lut;
+
 	struct drm_pending_vblank_event *event;
 
 	struct drm_atomic_state *state;
@@ -1239,6 +1244,34 @@ struct drm_mode_config {
 	/* Optional properties */
 	struct drm_property *scaling_mode_property;
 	struct drm_property *aspect_ratio_property;
+        /**
+         * @degamma_lut_property: Optional CRTC property to set the LUT used to
+         * convert the framebuffer's colors to linear gamma.
+         */
+        struct drm_property *degamma_lut_property;
+        /**
+         * @degamma_lut_size_property: Optional CRTC property for the size of
+         * the degamma LUT as supported by the driver (read-only).
+         */
+        struct drm_property *degamma_lut_size_property;
+        /**
+         * @ctm_property: Optional CRTC property to set the
+         * matrix used to convert colors after the lookup in the
+         * degamma LUT.
+         */
+        struct drm_property *ctm_property;
+         /**
+          * @gamma_lut_property: Optional CRTC property to set the LUT used to
+          * convert the colors, after the CTM matrix, to the gamma space of the
+          * connected screen.
+          */
+        struct drm_property *gamma_lut_property;
+         /**
+          * @gamma_lut_size_property: Optional CRTC property for the size of the
+          * gamma LUT as supported by the driver (read-only).
+          */
+        struct drm_property *gamma_lut_size_property;
+ 
 	struct drm_property *dirty_info_property;
 
 	/* properties for virtual machine layout */
@@ -1373,6 +1406,9 @@ extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
 extern void drm_plane_force_disable(struct drm_plane *plane);
 extern int drm_plane_check_pixel_format(const struct drm_plane *plane,
 					u32 format);
+extern int drm_crtc_force_disable(struct drm_crtc *crtc);
+extern int drm_crtc_force_disable_all(struct drm_device *dev);
+
 extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
 				   int *hdisplay, int *vdisplay);
 extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
diff --git a/include/drm/drm_fb_helper.h b/include/drm/drm_fb_helper.h
index 87b090c..b8be29e 100644
--- a/include/drm/drm_fb_helper.h
+++ b/include/drm/drm_fb_helper.h
@@ -395,4 +395,15 @@ drm_fb_helper_remove_one_connector(struct drm_fb_helper *fb_helper,
 	return 0;
 }
 #endif
+static inline int
+drm_fb_helper_remove_conflicting_framebuffers(struct apertures_struct *a,
+                                               const char *name, bool primary)
+{
+#if IS_REACHABLE(CONFIG_FB)
+        return remove_conflicting_framebuffers(a, name, primary);
+#else
+        return 0;
+#endif
+}
+
 #endif
diff --git a/include/uapi/drm/amdgpu_drm.h b/include/uapi/drm/amdgpu_drm.h
index d890419..a29167a 100644
--- a/include/uapi/drm/amdgpu_drm.h
+++ b/include/uapi/drm/amdgpu_drm.h
@@ -47,6 +47,7 @@
 #define DRM_AMDGPU_GEM_OP		0x10
 #define DRM_AMDGPU_GEM_USERPTR		0x11
 #define DRM_AMDGPU_WAIT_FENCES          0x12
+#define DRM_AMDGPU_VM                   0x13
 #define DRM_AMDGPU_FREESYNC             0x14
 
 #define DRM_IOCTL_AMDGPU_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_CREATE, union drm_amdgpu_gem_create)
@@ -62,6 +63,7 @@
 #define DRM_IOCTL_AMDGPU_GEM_OP		DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_OP, struct drm_amdgpu_gem_op)
 #define DRM_IOCTL_AMDGPU_GEM_USERPTR	DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_GEM_USERPTR, struct drm_amdgpu_gem_userptr)
 #define DRM_IOCTL_AMDGPU_WAIT_FENCES    DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_WAIT_FENCES, union drm_amdgpu_wait_fences)
+#define DRM_IOCTL_AMDGPU_VM             DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_VM, union drm_amdgpu_vm)
 #define DRM_IOCTL_AMDGPU_FREESYNC       DRM_IOWR(DRM_COMMAND_BASE + DRM_AMDGPU_FREESYNC, struct drm_amdgpu_freesync)
 
 #define AMDGPU_GEM_DOMAIN_CPU		0x1
@@ -188,6 +190,26 @@ union drm_amdgpu_ctx {
 	union drm_amdgpu_ctx_out out;
 };
 
+/* vm ioctl */
+#define AMDGPU_VM_OP_RESERVE_VMID       1
+#define AMDGPU_VM_OP_UNRESERVE_VMID     2
+
+struct drm_amdgpu_vm_in {
+        /** AMDGPU_VM_OP_* */
+        __u32   op;
+        __u32   flags;
+};
+
+struct drm_amdgpu_vm_out {
+        /** For future use, no flags defined so far */
+        __u64   flags;
+};
+
+union drm_amdgpu_vm {
+        struct drm_amdgpu_vm_in in;
+        struct drm_amdgpu_vm_out out;
+};
+
 /*
  * This is not a reliable API and you should expect it to fail for any
  * number of reasons and have fallback path that do not use userptr to
@@ -225,6 +247,10 @@ struct drm_amdgpu_gem_userptr {
 #define AMDGPU_TILING_NUM_BANKS_SHIFT			21
 #define AMDGPU_TILING_NUM_BANKS_MASK			0x3
 
+/* GFX9 and later: */
+#define AMDGPU_TILING_SWIZZLE_MODE_SHIFT                0
+#define AMDGPU_TILING_SWIZZLE_MODE_MASK                 0x1f
+
 #define AMDGPU_TILING_SET(field, value) \
 	(((value) & AMDGPU_TILING_##field##_MASK) << AMDGPU_TILING_##field##_SHIFT)
 #define AMDGPU_TILING_GET(value, field) \
@@ -348,6 +374,8 @@ struct drm_amdgpu_gem_op {
 
 #define AMDGPU_VA_OP_MAP			1
 #define AMDGPU_VA_OP_UNMAP			2
+#define AMDGPU_VA_OP_CLEAR                      3
+#define AMDGPU_VA_OP_REPLACE                    4
 
 /* Delay the page table update till the next CS */
 #define AMDGPU_VM_DELAY_UPDATE		(1 << 0)
@@ -359,6 +387,20 @@ struct drm_amdgpu_gem_op {
 #define AMDGPU_VM_PAGE_WRITEABLE	(1 << 2)
 /* executable mapping, new for VI */
 #define AMDGPU_VM_PAGE_EXECUTABLE	(1 << 3)
+/* partially resident texture */
+#define AMDGPU_VM_PAGE_PRT              (1 << 4)
+/* MTYPE flags use bit 5 to 8 */
+#define AMDGPU_VM_MTYPE_MASK            (0xf << 5)
+/* Default MTYPE. Pre-AI must use this.  Recommended for newer ASICs. */
+#define AMDGPU_VM_MTYPE_DEFAULT         (0 << 5)
+/* Use NC MTYPE instead of default MTYPE */
+#define AMDGPU_VM_MTYPE_NC              (1 << 5)
+/* Use WC MTYPE instead of default MTYPE */
+#define AMDGPU_VM_MTYPE_WC              (2 << 5)
+/* Use CC MTYPE instead of default MTYPE */
+#define AMDGPU_VM_MTYPE_CC              (3 << 5)
+/* Use UC MTYPE instead of default MTYPE */
+#define AMDGPU_VM_MTYPE_UC              (4 << 5)
 
 struct drm_amdgpu_gem_va {
 	/** GEM object handle */
@@ -381,7 +423,8 @@ struct drm_amdgpu_gem_va {
 #define AMDGPU_HW_IP_DMA          2
 #define AMDGPU_HW_IP_UVD          3
 #define AMDGPU_HW_IP_VCE          4
-#define AMDGPU_HW_IP_NUM          5
+#define AMDGPU_HW_IP_UVD_ENC      5
+#define AMDGPU_HW_IP_NUM          6
 
 #define AMDGPU_HW_IP_INSTANCE_MAX_COUNT 1
 
@@ -422,6 +465,8 @@ union drm_amdgpu_cs {
 
 /* CE Preamble */
 #define AMDGPU_IB_FLAG_PREAMBLE (1<<1)
+/* Preempt flag, IB should set Pre_enb bit if PREEMPT flag detected */
+#define AMDGPU_IB_FLAG_PREEMPT (1<<2)
 
 struct drm_amdgpu_cs_chunk_ib {
 	uint32_t _pad;
@@ -498,6 +543,10 @@ struct drm_amdgpu_cs_chunk_data {
 	#define AMDGPU_INFO_FW_SMC		0x0a
 	/* Subquery id: Query SDMA firmware version */
 	#define AMDGPU_INFO_FW_SDMA		0x0b
+        /* Subquery id: Query PSP SOS firmware version */
+        #define AMDGPU_INFO_FW_SOS              0x0c
+        /* Subquery id: Query PSP ASD firmware version */
+        #define AMDGPU_INFO_FW_ASD              0x0d
 /* number of bytes moved for TTM migration */
 #define AMDGPU_INFO_NUM_BYTES_MOVED		0x0f
 /* the used VRAM size */
@@ -528,6 +577,22 @@ struct drm_amdgpu_cs_chunk_data {
         #define AMDGPU_INFO_VBIOS_IMAGE         0x2
 /* Query UVD handles */
 #define AMDGPU_INFO_NUM_HANDLES                 0x1C
+/* Query sensor related information */
+#define AMDGPU_INFO_SENSOR                      0x1D
+        /* Subquery id: Query GPU shader clock */
+        #define AMDGPU_INFO_SENSOR_GFX_SCLK             0x1
+        /* Subquery id: Query GPU memory clock */
+        #define AMDGPU_INFO_SENSOR_GFX_MCLK             0x2
+        /* Subquery id: Query GPU temperature */
+        #define AMDGPU_INFO_SENSOR_GPU_TEMP             0x3
+        /* Subquery id: Query GPU load */
+        #define AMDGPU_INFO_SENSOR_GPU_LOAD             0x4
+        /* Subquery id: Query average GPU power */
+        #define AMDGPU_INFO_SENSOR_GPU_AVG_POWER        0x5
+        /* Subquery id: Query northbridge voltage */
+        #define AMDGPU_INFO_SENSOR_VDDNB                0x6
+        /* Subquery id: Query graphics voltage */
+        #define AMDGPU_INFO_SENSOR_VDDGFX               0x7
 
 #define AMDGPU_INFO_MMR_SE_INDEX_SHIFT	0
 #define AMDGPU_INFO_MMR_SE_INDEX_MASK	0xff
@@ -591,6 +656,10 @@ struct drm_amdgpu_info {
                         __u32 type;
                         __u32 offset;
 		} vbios_info;
+                
+		struct {
+                        __u32 type;
+                } sensor_info;
         };
 };
 
@@ -705,6 +774,35 @@ struct drm_amdgpu_info_device {
 	uint32_t vram_bit_width;
 	/* vce harvesting instance */
 	uint32_t vce_harvest_config;
+        /* gfx double offchip LDS buffers */
+        uint32_t gc_double_offchip_lds_buf;
+        /* NGG Primitive Buffer */
+        uint64_t prim_buf_gpu_addr;
+        /* NGG Position Buffer */
+        uint64_t pos_buf_gpu_addr;
+        /* NGG Control Sideband */
+        uint64_t cntl_sb_buf_gpu_addr;
+        /* NGG Parameter Cache */
+        uint64_t param_buf_gpu_addr;
+        uint32_t prim_buf_size;
+        uint32_t pos_buf_size;
+        uint32_t cntl_sb_buf_size;
+        uint32_t param_buf_size;
+        /* wavefront size*/
+        uint32_t wave_front_size;
+        /* shader visible vgprs*/
+        uint32_t num_shader_visible_vgprs;
+        /* CU per shader array*/
+        uint32_t num_cu_per_sh;
+        /* number of tcc blocks*/
+        uint32_t num_tcc_blocks;
+        /* gs vgt table depth*/
+        uint32_t gs_vgt_table_depth;
+        /* gs primitive buffer depth*/
+        uint32_t gs_prim_buffer_depth;
+        /* max gs wavefront per vgt*/
+        uint32_t max_gs_waves_per_vgt;
+        uint32_t _pad1;
 };
 
 struct drm_amdgpu_info_num_handles {
@@ -755,6 +853,7 @@ struct drm_amdgpu_info_vce_clock_table {
 #define AMDGPU_FAMILY_KV			125 /* Kaveri, Kabini, Mullins */
 #define AMDGPU_FAMILY_VI			130 /* Iceland, Tonga */
 #define AMDGPU_FAMILY_CZ			135 /* Carrizo, Stoney */
+#define AMDGPU_FAMILY_AI                        141 /* Vega10 */
 
 /*
  * Definition of free sync enter and exit signals
diff --git a/include/uapi/drm/drm_mode.h b/include/uapi/drm/drm_mode.h
index 6c11ca4..767bf1f 100644
--- a/include/uapi/drm/drm_mode.h
+++ b/include/uapi/drm/drm_mode.h
@@ -487,6 +487,16 @@ struct drm_mode_crtc_lut {
 	__u64 blue;
 };
 
+struct drm_color_lut {
+         /*
+          * Data is U0.16 fixed point format.
+          */
+         __u16 red;
+         __u16 green;
+         __u16 blue;
+         __u16 reserved;
+};
+
 #define DRM_MODE_PAGE_FLIP_EVENT 0x01
 #define DRM_MODE_PAGE_FLIP_ASYNC 0x02
 #define DRM_MODE_PAGE_FLIP_FLAGS (DRM_MODE_PAGE_FLIP_EVENT|DRM_MODE_PAGE_FLIP_ASYNC)
-- 
2.7.4

