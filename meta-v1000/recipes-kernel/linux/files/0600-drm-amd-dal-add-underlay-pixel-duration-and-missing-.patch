From 40005fc1336ff2486d7893774c993de790449167 Mon Sep 17 00:00:00 2001
From: Eric Yang <eric.yang2@amd.com>
Date: Thu, 30 Jun 2016 18:18:44 -0400
Subject: [PATCH 0600/1722] drm/amd/dal: add underlay pixel duration and
 missing crtc programming

This fixes hang when blnd_mode is toggled. Underflow still occurs.

Change-Id: I53bf41c3b4ee48d244830d434d15591ae71f0a54
Signed-off-by: Eric Yang <eric.yang2@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    | 30 +++++------
 .../gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c | 33 ++++++++++++
 .../amd/dal/dc/dce110/dce110_timing_generator_v.c  | 61 ++++++++++++++++++++++
 3 files changed, 108 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 48cb5d1..7db254f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1445,20 +1445,11 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	int i;
-	const struct dc_crtc_timing *crtc_timing =
-				&pipe_ctx->stream->public.timing;
 	struct mem_input *mi = pipe_ctx->mi;
-	struct timing_generator *tg = pipe_ctx->tg;
 	struct dc_context *ctx = pipe_ctx->stream->ctx;
 	struct core_surface *surface = pipe_ctx->surface;
 	enum blender_mode blender_mode = BLENDER_MODE_CURRENT_PIPE;
 
-	tg->funcs->program_timing(tg, crtc_timing, false);
-	tg->funcs->enable_advanced_request(
-			tg,
-			true,
-			&pipe_ctx->stream->public.timing);
-
 	dc->hwss.enable_fe_clock(ctx, pipe_ctx->pipe_idx, true);
 
 	set_default_colors(pipe_ctx);
@@ -1723,14 +1714,21 @@ static void dce110_power_on_pipe_if_needed(
 				dc->ctx,
 				pipe_ctx->pipe_idx,
 				dcb, PIPE_GATING_CONTROL_DISABLE);
-		if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
-			dm_error("DC: failed to blank crtc!\n");
-			BREAK_TO_DEBUGGER();
-		}
 
-		if (!pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
-			BREAK_TO_DEBUGGER();
-		}
+		pipe_ctx->tg->funcs->program_timing(pipe_ctx->tg,
+				&pipe_ctx->stream->public.timing,
+				false);
+
+		pipe_ctx->tg->funcs->enable_advanced_request(
+				pipe_ctx->tg,
+				true,
+				&pipe_ctx->stream->public.timing);
+
+		pipe_ctx->mi->funcs->allocate_mem_input(pipe_ctx->mi,
+				pipe_ctx->stream->public.timing.h_total,
+				pipe_ctx->stream->public.timing.v_total,
+				pipe_ctx->stream->public.timing.pix_clk_khz,
+				context->target_count);
 
 		pipe_ctx->tg->funcs->set_blank_color(
 				pipe_ctx->tg,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
index f8cb11f..f2c5659 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_mem_input_v.c
@@ -993,6 +993,39 @@ void dce110_allocate_mem_input_v(
 	uint32_t pix_clk_khz,/* for current stream */
 	uint32_t total_stream_num)
 {
+	uint32_t addr;
+	uint32_t value;
+	uint32_t pix_dur;
+	if (pix_clk_khz != 0) {
+		addr = mmDPGV0_PIPE_ARBITRATION_CONTROL1;
+		value = dm_read_reg(mi->ctx, addr);
+		pix_dur = 1000000000ULL / pix_clk_khz;
+		set_reg_field_value(
+			value,
+			pix_dur,
+			DPGV0_PIPE_ARBITRATION_CONTROL1,
+			PIXEL_DURATION);
+		dm_write_reg(mi->ctx, addr, value);
+
+		addr = mmDPGV1_PIPE_ARBITRATION_CONTROL1;
+		value = dm_read_reg(mi->ctx, addr);
+		pix_dur = 1000000000ULL / pix_clk_khz;
+		set_reg_field_value(
+			value,
+			pix_dur,
+			DPGV1_PIPE_ARBITRATION_CONTROL1,
+			PIXEL_DURATION);
+		dm_write_reg(mi->ctx, addr, value);
+
+		addr = mmDPGV0_PIPE_ARBITRATION_CONTROL2;
+		value = 0x4000800;
+		dm_write_reg(mi->ctx, addr, value);
+
+		addr = mmDPGV1_PIPE_ARBITRATION_CONTROL2;
+		value = 0x4000800;
+		dm_write_reg(mi->ctx, addr, value);
+	}
+
 }
 
 void dce110_free_mem_input_v(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
index b959506..ad7ceb4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator_v.c
@@ -324,6 +324,67 @@ static void dce110_timing_generator_v_program_blanking(
 		CRTC_V_BLANK_START);
 
 	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_H_SYNC_A;
+	value = 0;
+	set_reg_field_value(
+		value,
+		timing->h_sync_width,
+		CRTCV_H_SYNC_A,
+		CRTC_H_SYNC_A_END);
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_H_SYNC_A_CNTL;
+	value = dm_read_reg(ctx, addr);
+	if (timing->flags.HSYNC_POSITIVE_POLARITY) {
+		set_reg_field_value(
+			value,
+			0,
+			CRTCV_H_SYNC_A_CNTL,
+			CRTC_H_SYNC_A_POL);
+	} else {
+		set_reg_field_value(
+			value,
+			1,
+			CRTCV_H_SYNC_A_CNTL,
+			CRTC_H_SYNC_A_POL);
+	}
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_V_SYNC_A;
+	value = 0;
+	set_reg_field_value(
+		value,
+		timing->v_sync_width,
+		CRTCV_V_SYNC_A,
+		CRTC_V_SYNC_A_END);
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_V_SYNC_A_CNTL;
+	value = dm_read_reg(ctx, addr);
+	if (timing->flags.VSYNC_POSITIVE_POLARITY) {
+		set_reg_field_value(
+			value,
+			0,
+			CRTCV_V_SYNC_A_CNTL,
+			CRTC_V_SYNC_A_POL);
+	} else {
+		set_reg_field_value(
+			value,
+			1,
+			CRTCV_V_SYNC_A_CNTL,
+			CRTC_V_SYNC_A_POL);
+	}
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_INTERLACE_CONTROL;
+	value = dm_read_reg(ctx, addr);
+	set_reg_field_value(
+		value,
+		timing->flags.INTERLACE,
+		CRTCV_INTERLACE_CONTROL,
+		CRTC_INTERLACE_ENABLE);
+	dm_write_reg(ctx, addr, value);
 }
 
 static void dce110_timing_generator_v_enable_advanced_request(
-- 
2.7.4

