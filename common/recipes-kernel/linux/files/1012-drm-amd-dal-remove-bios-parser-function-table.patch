From 1c9dcbf65903c09af8c5b0df8ae1450375280445 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Mon, 11 Apr 2016 16:56:03 +1000
Subject: [PATCH 1012/1110] drm/amd/dal: remove bios parser function table.

This table serves no great purpose, direct calling the APIs
in the code works just as well.

before:
1096306	 141169	   1532	1239007	 12e7df	drivers/gpu/drm/amd/amdgpu/amdgpu.ko
after:
1094986	 141169	   1532	1237687	 12e2b7	drivers/gpu/drm/amd/amdgpu/amdgpu.ko

Signed-off-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 .../gpu/drm/amd/dal/dc/adapter/adapter_service.c   |  63 ++-
 .../drm/amd/dal/dc/adapter/wireless_data_source.c  |   2 +-
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c      | 423 ++++++---------------
 drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h      |   3 +-
 .../dal/dc/bios/dce112/bios_parser_helper_dce112.c | 178 +--------
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |   6 +-
 drivers/gpu/drm/amd/dal/dc/dc_bios_types.h         | 412 +++++++++-----------
 .../drm/amd/dal/dc/dce100/dce100_hw_sequencer.c    |   3 +-
 .../drm/amd/dal/dc/dce110/dce110_clock_source.c    |  49 +--
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  11 +-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |   2 +-
 .../drm/amd/dal/dc/dce110/dce110_stream_encoder.c  |   6 +-
 .../amd/dal/dc/dce110/dce110_timing_generator.c    |   6 +-
 .../drm/amd/dal/dc/dce112/dce112_clock_source.c    |   6 +-
 .../drm/amd/dal/dc/dce112/dce112_hw_sequencer.c    |   2 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c  |   2 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c  |   2 +-
 .../drm/amd/dal/dc/dce80/dce80_stream_encoder.c    |   6 +-
 .../amd/dal/dc/gpu/dce110/display_clock_dce110.c   |   2 +-
 .../amd/dal/dc/gpu/dce112/display_clock_dce112.c   |   4 +-
 .../drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c |   2 +-
 21 files changed, 386 insertions(+), 804 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
index 308d456..810776b 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/adapter_service.c
@@ -234,8 +234,8 @@ static void initialize_backlight_caps(
 			return;
 	}
 
-	if (dcb->funcs->get_firmware_info(dcb, &fw_info) != BP_RESULT_OK ||
-		dcb->funcs->get_embedded_panel_info(dcb, &panel_info) != BP_RESULT_OK)
+	if (dc_bios_get_firmware_info(dcb, &fw_info) != BP_RESULT_OK ||
+		dc_bios_get_embedded_panel_info(dcb, &panel_info) != BP_RESULT_OK)
 		return;
 
 	params.data = &caps;
@@ -540,7 +540,7 @@ static bool get_hpd_info(struct adapter_service *as,
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return BP_RESULT_OK == dcb->funcs->get_hpd_info(dcb, id, info);
+	return BP_RESULT_OK == dc_bios_get_hpd_info(dcb, id, info);
 }
 
 /*
@@ -693,7 +693,7 @@ static void adapter_service_destruct(
 	dal_gpio_service_destroy(&as->gpio_service);
 	dal_asic_capability_destroy(&as->asic_cap);
 
-	dcb->funcs->destroy_integrated_info(dcb, &as->integrated_info);
+	dc_bios_destroy_integrated_info(dcb, &as->integrated_info);
 
 	if (as->dcb_internal) {
 		/* We are responsible only for destruction of Internal BIOS.
@@ -802,9 +802,9 @@ static bool adapter_service_construct(
 	/* Avoid wireless encoder creation in upstream branch. */
 
 	/* Integrated info is not provided on discrete ASIC. NULL is allowed */
-	as->integrated_info = dcb->funcs->create_integrated_info(dcb);
+	as->integrated_info = dc_bios_create_integrated_info(dcb);
 
-	dcb->funcs->post_init(dcb);
+	dc_bios_post_init(dcb);
 
 	/* Generate backlight translation table and initializes
 			  other brightness properties */
@@ -965,7 +965,7 @@ uint8_t dal_adapter_service_get_connectors_num(
 
 	dcb = dal_adapter_service_get_bios_parser(as);
 
-	vbios_connectors_num = dcb->funcs->get_connectors_number(dcb);
+	vbios_connectors_num = dc_bios_get_connectors_number(dcb);
 
 	wireless_connectors_num = wireless_get_connectors_num(as);
 
@@ -1002,7 +1002,7 @@ uint32_t dal_adapter_service_get_src_num(
 	if (is_wireless_object(id))
 		return wireless_get_srcs_num(as, id);
 	else
-		return dcb->funcs->get_src_number(dcb, id);
+		return dc_bios_get_src_number(dcb, id);
 }
 
 /**
@@ -1027,7 +1027,7 @@ struct graphics_object_id dal_adapter_service_get_src_obj(
 	if (is_wireless_object(id))
 		src_object_id = wireless_get_src_obj_id(as, id, index);
 	else {
-		if (BP_RESULT_OK != dcb->funcs->get_src_obj(dcb, id, index,
+		if (BP_RESULT_OK != dc_bios_get_src_obj(dcb, id, index,
 				&src_object_id)) {
 			src_object_id =
 				dal_graphics_object_id_init(
@@ -1058,12 +1058,12 @@ struct graphics_object_id dal_adapter_service_get_connector_obj_id(
 
 	dcb = dal_adapter_service_get_bios_parser(as);
 
-	bios_connectors_num = dcb->funcs->get_connectors_number(dcb);
+	bios_connectors_num = dc_bios_get_connectors_number(dcb);
 
 	if (connector_index >= bios_connectors_num)
 		return wireless_get_connector_id(as, connector_index);
 	else
-		return dcb->funcs->get_connector_id(dcb, connector_index);
+		return dc_bios_get_connector_id(dcb, connector_index);
 }
 
 bool dal_adapter_service_get_device_tag(
@@ -1074,8 +1074,8 @@ bool dal_adapter_service_get_device_tag(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	if (BP_RESULT_OK == dcb->funcs->get_device_tag(dcb,
-			connector_object_id, device_tag_index, info))
+	if (BP_RESULT_OK == dc_bios_get_device_tag(dcb,
+						   connector_object_id, device_tag_index, info))
 		return true;
 	else
 		return false;
@@ -1087,7 +1087,7 @@ bool dal_adapter_service_is_device_id_supported(struct adapter_service *as,
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dcb->funcs->is_device_id_supported(dcb, id);
+	return dc_bios_is_device_id_supported(dcb, id);
 }
 
 bool dal_adapter_service_is_meet_underscan_req(struct adapter_service *as)
@@ -1130,7 +1130,7 @@ uint8_t dal_adapter_service_get_clock_sources_num(
 	 * Check is system supports the use of the External clock source
 	 * as a clock source for DP
 	 */
-	enum bp_result bp_result = dcb->funcs->get_firmware_info(dcb, &fw_info);
+	enum bp_result bp_result = dc_bios_get_firmware_info(dcb, &fw_info);
 
 	if (BP_RESULT_OK == bp_result &&
 			fw_info.external_clock_source_frequency_for_dp != 0)
@@ -1249,7 +1249,7 @@ bool dal_adapter_service_get_i2c_info(
 		return false;
 	}
 
-	return BP_RESULT_OK == dcb->funcs->get_i2c_info(dcb, id, i2c_info);
+	return BP_RESULT_OK == dc_bios_get_i2c_info(dcb, id, i2c_info);
 }
 
 /*
@@ -1306,7 +1306,7 @@ struct irq *dal_adapter_service_obtain_hpd_irq(
 	if (!get_hpd_info(as, id, &hpd_info))
 		return NULL;
 
-	bp_result = dcb->funcs->get_gpio_pin_info(dcb,
+	bp_result = dc_bios_get_gpio_pin_info(dcb,
 		hpd_info.hpd_int_gpio_uid, &pin_info);
 
 	if (bp_result != BP_RESULT_OK) {
@@ -1343,7 +1343,7 @@ uint32_t dal_adapter_service_get_ss_info_num(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dcb->funcs->get_ss_entry_number(dcb, signal);
+	return dc_bios_get_ss_entry_number(dcb, signal);
 }
 
 /*
@@ -1359,8 +1359,8 @@ bool dal_adapter_service_get_ss_info(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	enum bp_result bp_result = dcb->funcs->get_spread_spectrum_info(dcb,
-			signal, idx, info);
+	enum bp_result bp_result = dc_bios_get_spread_spectrum_info(dcb,
+								   signal, idx, info);
 
 	return BP_RESULT_OK == bp_result;
 }
@@ -1571,12 +1571,11 @@ struct gpio *dal_adapter_service_obtain_stereo_gpio(
 		/* Get GPIO record for this object.
 		 * Stereo GPIO record should have exactly one entry
 		 * where active state defines stereosync polarity */
-		if (1 != dcb->funcs->get_gpio_record(
-						dcb, id, &cntl_info,
-						1)) {
+		if (1 != dc_bios_get_gpio_record(dcb, id, &cntl_info,
+						 1)) {
 			return NULL;
 		} else if (BP_RESULT_OK
-				!= dcb->funcs->get_gpio_pin_info(
+				!= dc_bios_get_gpio_pin_info(
 						dcb, cntl_info.id,
 						&pin_info)) {
 			/*ASSERT_CRITICAL(false);*/
@@ -1612,7 +1611,7 @@ bool dal_adapter_service_get_firmware_info(
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dcb->funcs->get_firmware_info(dcb, info) == BP_RESULT_OK;
+	return dc_bios_get_firmware_info(dcb, info) == BP_RESULT_OK;
 }
 
 /*
@@ -1803,7 +1802,7 @@ bool dal_adapter_service_get_embedded_panel_info(
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
 
-	result = dcb->funcs->get_embedded_panel_info(dcb, info);
+	result = dc_bios_get_embedded_panel_info(dcb, info);
 
 	return result == BP_RESULT_OK;
 }
@@ -1820,7 +1819,7 @@ bool dal_adapter_service_enum_embedded_panel_patch_mode(
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
 
-	result = dcb->funcs->enum_embedded_panel_patch_mode(dcb, index, mode);
+	result = dc_bios_enum_embedded_panel_patch_mode(dcb, index, mode);
 
 	return result == BP_RESULT_OK;
 }
@@ -1832,7 +1831,7 @@ bool dal_adapter_service_get_faked_edid_len(
 	enum bp_result result;
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	result = dcb->funcs->get_faked_edid_len(dcb, len);
+	result = dc_bios_get_faked_edid_len(dcb, len);
 
 	return result == BP_RESULT_OK;
 }
@@ -1845,7 +1844,7 @@ bool dal_adapter_service_get_faked_edid_buf(
 	enum bp_result result;
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	result = dcb->funcs->get_faked_edid_buf(dcb, buf, len);
+	result = dc_bios_get_faked_edid_buf(dcb, buf, len);
 
 	return result == BP_RESULT_OK;
 
@@ -1935,7 +1934,7 @@ bool dal_adapter_service_is_in_accelerated_mode(struct adapter_service *as)
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	return dcb->funcs->is_accelerated_mode(dcb);
+	return dc_bios_is_accelerated_mode(dcb);
 }
 
 struct ddc *dal_adapter_service_obtain_ddc_from_i2c_info(
@@ -1981,7 +1980,7 @@ bool dal_adapter_service_is_lid_open(struct adapter_service *as)
 		return is_lid_open;
 
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
-	return dcb->funcs->is_lid_open(dcb);
+	return dc_bios_is_lid_open(dcb);
 #else
 	return false;
 #endif
@@ -2068,7 +2067,7 @@ bool dal_adapter_service_get_encoder_cap_info(
 	 * - dpHbr2Cap: indicates supported/not supported by HW Encoder
 	 * - dpHbr2En : indicates DP spec compliant/not compliant
 	 */
-	result = dcb->funcs->get_encoder_cap_info(dcb, id, &bp_cap_info);
+	result = dc_bios_get_encoder_cap_info(dcb, id, &bp_cap_info);
 
 	/* Set dp_hbr2_validated flag (it's equal to Enable) */
 	info->dp_hbr2_validated = bp_cap_info.DP_HBR2_EN;
diff --git a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
index 0b1151e..1b6deb9 100644
--- a/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/adapter/wireless_data_source.c
@@ -66,7 +66,7 @@ bool wireless_data_init(struct wireless_data *data,
 		 * Check if SBIOS sets remote display enable, exposed
 		 * through VBIOS. This is only valid for APU, not dGPU
 		 */
-		dcb->funcs->get_firmware_info(dcb, &info);
+		dc_bios_get_firmware_info(dcb, &info);
 
 		if ((REMOTE_DISPLAY_ENABLE == info.remote_display_config) &&
 				init_data->fusion) {
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
index a43da0c..8bb5454 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.c
@@ -105,12 +105,8 @@ static bool bios_parser_construct(
 	struct bp_init_data *init,
 	struct adapter_service *as);
 
-static uint8_t bios_parser_get_connectors_number(
-	struct dc_bios *dcb);
-
-static enum bp_result bios_parser_get_embedded_panel_info(
-	struct dc_bios *dcb,
-	struct embedded_panel_info *info);
+enum bp_result dc_bios_get_embedded_panel_info(struct dc_bios *dcb,
+					       struct embedded_panel_info *info);
 
 /*****************************************************************************/
 
@@ -124,7 +120,7 @@ struct dc_bios *dal_bios_parser_create(
 		return NULL;
 
 	if (bios_parser_construct(bp, init, as))
-		return &bp->base;
+		return (struct dc_bios *)bp;
 
 	dm_free(bp);
 	BREAK_TO_DEBUGGER();
@@ -152,7 +148,7 @@ void dal_bios_parser_destroy(struct dc_bios **dcb)
 	*dcb = NULL;
 }
 
-static void bios_parser_power_down(struct dc_bios *dcb)
+void dc_bios_power_down(struct dc_bios *dcb)
 {
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
@@ -161,7 +157,7 @@ static void bios_parser_power_down(struct dc_bios *dcb)
 #endif
 }
 
-static void bios_parser_power_up(struct dc_bios *dcb)
+void dc_bios_power_up(struct dc_bios *dcb)
 {
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
@@ -185,7 +181,7 @@ static uint8_t get_number_of_objects(struct bios_parser *bp, uint32_t offset)
 		return table->ucNumberOfObjects;
 }
 
-static uint8_t bios_parser_get_encoders_number(struct dc_bios *dcb)
+uint8_t dc_bios_get_encoders_number(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -193,7 +189,7 @@ static uint8_t bios_parser_get_encoders_number(struct dc_bios *dcb)
 		le16_to_cpu(bp->object_info_tbl.v1_1->usEncoderObjectTableOffset));
 }
 
-static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)
+uint8_t dc_bios_get_connectors_number(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -201,7 +197,7 @@ static uint8_t bios_parser_get_connectors_number(struct dc_bios *dcb)
 		le16_to_cpu(bp->object_info_tbl.v1_1->usConnectorObjectTableOffset));
 }
 
-static uint32_t bios_parser_get_oem_ddc_lines_number(struct dc_bios *dcb)
+uint32_t dc_bios_get_oem_ddc_lines_number(struct dc_bios *dcb)
 {
 	uint32_t number = 0;
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
@@ -225,9 +221,8 @@ static uint32_t bios_parser_get_oem_ddc_lines_number(struct dc_bios *dcb)
 	return number;
 }
 
-static struct graphics_object_id bios_parser_get_encoder_id(
-	struct dc_bios *dcb,
-	uint32_t i)
+struct graphics_object_id dc_bios_get_encoder_id(struct dc_bios *dcb,
+						 uint32_t i)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct graphics_object_id object_id = dal_graphics_object_id_init(
@@ -248,9 +243,8 @@ static struct graphics_object_id bios_parser_get_encoder_id(
 	return object_id;
 }
 
-static struct graphics_object_id bios_parser_get_connector_id(
-	struct dc_bios *dcb,
-	uint8_t i)
+struct graphics_object_id dc_bios_get_connector_id(struct dc_bios *dcb,
+						   uint8_t i)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct graphics_object_id object_id = dal_graphics_object_id_init(
@@ -271,8 +265,8 @@ static struct graphics_object_id bios_parser_get_connector_id(
 	return object_id;
 }
 
-static uint32_t bios_parser_get_src_number(struct dc_bios *dcb,
-	struct graphics_object_id id)
+uint32_t dc_bios_get_src_number(struct dc_bios *dcb,
+				struct graphics_object_id id)
 {
 	uint32_t offset;
 	uint8_t *number;
@@ -296,8 +290,8 @@ static uint32_t bios_parser_get_src_number(struct dc_bios *dcb,
 	return *number;
 }
 
-static uint32_t bios_parser_get_dst_number(struct dc_bios *dcb,
-	struct graphics_object_id id)
+uint32_t dc_bios_get_dst_number(struct dc_bios *dcb,
+				struct graphics_object_id id)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object = get_bios_object(bp, id);
@@ -305,9 +299,10 @@ static uint32_t bios_parser_get_dst_number(struct dc_bios *dcb,
 	return get_dst_number_from_object(bp, object);
 }
 
-static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
-	struct graphics_object_id object_id, uint32_t index,
-	struct graphics_object_id *src_object_id)
+enum bp_result dc_bios_get_src_obj(struct dc_bios *dcb,
+				   struct graphics_object_id object_id,
+				   uint32_t index,
+				   struct graphics_object_id *src_object_id)
 {
 	uint32_t number;
 	uint16_t *id;
@@ -334,9 +329,10 @@ static enum bp_result bios_parser_get_src_obj(struct dc_bios *dcb,
 	return BP_RESULT_OK;
 }
 
-static enum bp_result bios_parser_get_dst_obj(struct dc_bios *dcb,
-	struct graphics_object_id object_id, uint32_t index,
-	struct graphics_object_id *dest_object_id)
+enum bp_result dc_bios_get_dst_obj(struct dc_bios *dcb,
+				   struct graphics_object_id object_id,
+				   uint32_t index,
+				   struct graphics_object_id *dest_object_id)
 {
 	uint32_t number;
 	uint16_t *id;
@@ -358,9 +354,9 @@ static enum bp_result bios_parser_get_dst_obj(struct dc_bios *dcb,
 	return BP_RESULT_OK;
 }
 
-static enum bp_result bios_parser_get_oem_ddc_info(struct dc_bios *dcb,
-	uint32_t index,
-	struct graphics_object_i2c_info *info)
+enum bp_result dc_bios_get_oem_ddc_info(struct dc_bios *dcb,
+					uint32_t index,
+					struct graphics_object_i2c_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -395,9 +391,9 @@ static enum bp_result bios_parser_get_oem_ddc_info(struct dc_bios *dcb,
 	return BP_RESULT_NORECORD;
 }
 
-static enum bp_result bios_parser_get_i2c_info(struct dc_bios *dcb,
-	struct graphics_object_id id,
-	struct graphics_object_i2c_info *info)
+enum bp_result dc_bios_get_i2c_info(struct dc_bios *dcb,
+				    struct graphics_object_id id,
+				    struct graphics_object_i2c_info *info)
 {
 	uint32_t offset;
 	ATOM_OBJECT *object;
@@ -501,10 +497,9 @@ static enum bp_result get_voltage_ddc_info_v3(uint8_t *i2c_line,
 	return result;
 }
 
-static enum bp_result bios_parser_get_thermal_ddc_info(
-	struct dc_bios *dcb,
-	uint32_t i2c_channel_id,
-	struct graphics_object_i2c_info *info)
+enum bp_result dc_bios_get_thermal_ddc_info(struct dc_bios *dcb,
+					    uint32_t i2c_channel_id,
+					    struct graphics_object_i2c_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_I2C_ID_CONFIG_ACCESS *config;
@@ -522,9 +517,9 @@ static enum bp_result bios_parser_get_thermal_ddc_info(
 	return get_gpio_i2c_info(bp, &record, info);
 }
 
-static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
-	uint32_t index,
-	struct graphics_object_i2c_info *info)
+enum bp_result dc_bios_get_voltage_ddc_info(struct dc_bios *dcb,
+					    uint32_t index,
+					    struct graphics_object_i2c_info *info)
 {
 	uint8_t i2c_line = 0;
 	enum bp_result result = BP_RESULT_NORECORD;
@@ -559,8 +554,8 @@ static enum bp_result bios_parser_get_voltage_ddc_info(struct dc_bios *dcb,
 	}
 
 	if (result == BP_RESULT_OK)
-		result = bios_parser_get_thermal_ddc_info(dcb,
-			i2c_line, info);
+		result = dc_bios_get_thermal_ddc_info(dcb,
+						      i2c_line, info);
 
 	return result;
 }
@@ -629,9 +624,9 @@ enum bp_result bios_parser_get_ddc_info_for_i2c_line(struct bios_parser *bp,
 	return BP_RESULT_NORECORD;
 }
 
-static enum bp_result bios_parser_get_hpd_info(struct dc_bios *dcb,
-	struct graphics_object_id id,
-	struct graphics_object_hpd_info *info)
+enum bp_result dc_bios_get_hpd_info(struct dc_bios *dcb,
+				    struct graphics_object_id id,
+				    struct graphics_object_hpd_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
@@ -656,11 +651,10 @@ static enum bp_result bios_parser_get_hpd_info(struct dc_bios *dcb,
 	return BP_RESULT_NORECORD;
 }
 
-static uint32_t bios_parser_get_gpio_record(
-	struct dc_bios *dcb,
-	struct graphics_object_id id,
-	struct bp_gpio_cntl_info *gpio_record,
-	uint32_t record_size)
+uint32_t dc_bios_get_gpio_record(struct dc_bios *dcb,
+				 struct graphics_object_id id,
+				 struct bp_gpio_cntl_info *gpio_record,
+				 uint32_t record_size)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_COMMON_RECORD_HEADER *header = NULL;
@@ -767,11 +761,10 @@ enum bp_result bios_parser_get_device_tag_record(
 	return BP_RESULT_NORECORD;
 }
 
-static enum bp_result bios_parser_get_device_tag(
-	struct dc_bios *dcb,
-	struct graphics_object_id connector_object_id,
-	uint32_t device_tag_index,
-	struct connector_device_tag_info *info)
+enum bp_result dc_bios_get_device_tag(struct dc_bios *dcb,
+				      struct graphics_object_id connector_object_id,
+				      uint32_t device_tag_index,
+				      struct connector_device_tag_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
@@ -815,7 +808,7 @@ static enum bp_result get_firmware_info_v2_2(
 	struct bios_parser *bp,
 	struct firmware_info *info);
 
-static enum bp_result bios_parser_get_firmware_info(
+enum bp_result dc_bios_get_firmware_info(
 	struct dc_bios *dcb,
 	struct firmware_info *info)
 {
@@ -1166,9 +1159,8 @@ static enum bp_result get_ss_info_v3_1(
 	return BP_RESULT_NORECORD;
 }
 
-static enum bp_result bios_parser_transmitter_control(
-	struct dc_bios *dcb,
-	struct bp_transmitter_control *cntl)
+enum bp_result dc_bios_transmitter_control(struct dc_bios *dcb,
+					   struct bp_transmitter_control *cntl)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1178,9 +1170,8 @@ static enum bp_result bios_parser_transmitter_control(
 	return bp->cmd_tbl.transmitter_control(bp, cntl);
 }
 
-static enum bp_result bios_parser_encoder_control(
-	struct dc_bios *dcb,
-	struct bp_encoder_control *cntl)
+enum bp_result dc_bios_encoder_control(struct dc_bios *dcb,
+					   struct bp_encoder_control *cntl)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1190,9 +1181,8 @@ static enum bp_result bios_parser_encoder_control(
 	return bp->cmd_tbl.dig_encoder_control(bp, cntl);
 }
 
-static enum bp_result bios_parser_adjust_pixel_clock(
-	struct dc_bios *dcb,
-	struct bp_adjust_pixel_clock_parameters *bp_params)
+enum bp_result dc_bios_adjust_pixel_clock(struct dc_bios *dcb,
+					  struct bp_adjust_pixel_clock_parameters *bp_params)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1202,9 +1192,8 @@ static enum bp_result bios_parser_adjust_pixel_clock(
 	return bp->cmd_tbl.adjust_display_pll(bp, bp_params);
 }
 
-static enum bp_result bios_parser_set_pixel_clock(
-	struct dc_bios *dcb,
-	struct bp_pixel_clock_parameters *bp_params)
+enum bp_result dc_bios_set_pixel_clock(struct dc_bios *dcb,
+				       struct bp_pixel_clock_parameters *bp_params)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1214,9 +1203,8 @@ static enum bp_result bios_parser_set_pixel_clock(
 	return bp->cmd_tbl.set_pixel_clock(bp, bp_params);
 }
 
-static enum bp_result bios_parser_set_dce_clock(
-	struct dc_bios *dcb,
-	struct bp_set_dce_clock_parameters *bp_params)
+enum bp_result dc_bios_set_dce_clock(struct dc_bios *dcb,
+					 struct bp_set_dce_clock_parameters *bp_params)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1226,7 +1214,7 @@ static enum bp_result bios_parser_set_dce_clock(
 	return bp->cmd_tbl.set_dce_clock(bp, bp_params);
 }
 
-static enum bp_result bios_parser_enable_spread_spectrum_on_ppll(
+enum bp_result dc_bios_enable_spread_spectrum_on_ppll(
 	struct dc_bios *dcb,
 	struct bp_spread_spectrum_parameters *bp_params,
 	bool enable)
@@ -1241,7 +1229,7 @@ static enum bp_result bios_parser_enable_spread_spectrum_on_ppll(
 
 }
 
-static enum bp_result bios_parser_program_crtc_timing(
+enum bp_result dc_bios_program_crtc_timing(
 	struct dc_bios *dcb,
 	struct bp_hw_crtc_timing_parameters *bp_params)
 {
@@ -1253,7 +1241,7 @@ static enum bp_result bios_parser_program_crtc_timing(
 	return bp->cmd_tbl.set_crtc_timing(bp, bp_params);
 }
 
-static enum bp_result bios_parser_program_display_engine_pll(
+enum bp_result dc_bios_program_display_engine_pll(
 	struct dc_bios *dcb,
 	struct bp_pixel_clock_parameters *bp_params)
 {
@@ -1266,11 +1254,10 @@ static enum bp_result bios_parser_program_display_engine_pll(
 
 }
 
-static enum signal_type bios_parser_dac_load_detect(
-	struct dc_bios *dcb,
-	struct graphics_object_id encoder,
-	struct graphics_object_id connector,
-	enum signal_type display_signal)
+enum signal_type dc_bios_dac_load_detect(struct dc_bios *dcb,
+					 struct graphics_object_id encoder,
+					 struct graphics_object_id connector,
+					 enum signal_type display_signal)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1281,7 +1268,7 @@ static enum signal_type bios_parser_dac_load_detect(
 		display_signal);
 }
 
-static enum bp_result bios_parser_get_divider_for_target_display_clock(
+enum bp_result dc_bios_get_divider_for_target_display_clock(
 	struct dc_bios *dcb,
 	struct bp_display_clock_parameters *bp_params)
 {
@@ -1293,7 +1280,7 @@ static enum bp_result bios_parser_get_divider_for_target_display_clock(
 	return bp->cmd_tbl.compute_memore_engine_pll(bp, bp_params);
 }
 
-static enum bp_result bios_parser_enable_crtc(
+enum bp_result dc_bios_enable_crtc(
 	struct dc_bios *dcb,
 	enum controller_id id,
 	bool enable)
@@ -1306,7 +1293,7 @@ static enum bp_result bios_parser_enable_crtc(
 	return bp->cmd_tbl.enable_crtc(bp, id, enable);
 }
 
-static enum bp_result bios_parser_blank_crtc(
+enum bp_result dc_bios_blank_crtc(
 	struct dc_bios *dcb,
 	struct bp_blank_crtc_parameters *bp_params,
 	bool blank)
@@ -1319,7 +1306,7 @@ static enum bp_result bios_parser_blank_crtc(
 	return bp->cmd_tbl.blank_crtc(bp, bp_params, blank);
 }
 
-static enum bp_result bios_parser_crtc_source_select(
+enum bp_result dc_bios_crtc_source_select(
 	struct dc_bios *dcb,
 	struct bp_crtc_source_select *bp_params)
 {
@@ -1331,7 +1318,7 @@ static enum bp_result bios_parser_crtc_source_select(
 	return bp->cmd_tbl.select_crtc_source(bp, bp_params);
 }
 
-static enum bp_result bios_parser_set_overscan(
+enum bp_result dc_bios_set_overscan(
 	struct dc_bios *dcb,
 	struct bp_hw_crtc_overscan_parameters *bp_params)
 {
@@ -1343,7 +1330,7 @@ static enum bp_result bios_parser_set_overscan(
 	return bp->cmd_tbl.set_crtc_overscan(bp, bp_params);
 }
 
-static enum bp_result bios_parser_enable_memory_requests(
+enum bp_result dc_bios_enable_memory_requests(
 	struct dc_bios *dcb,
 	enum controller_id controller_id,
 	bool enable)
@@ -1356,7 +1343,7 @@ static enum bp_result bios_parser_enable_memory_requests(
 	return bp->cmd_tbl.enable_crtc_mem_req(bp, controller_id, enable);
 }
 
-static enum bp_result bios_parser_external_encoder_control(
+enum bp_result dc_bios_external_encoder_control(
 	struct dc_bios *dcb,
 	struct bp_external_encoder_control *cntl)
 {
@@ -1368,7 +1355,7 @@ static enum bp_result bios_parser_external_encoder_control(
 	return bp->cmd_tbl.external_encoder_control(bp, cntl);
 }
 
-static enum bp_result bios_parser_enable_disp_power_gating(
+enum bp_result dc_bios_enable_disp_power_gating(
 	struct dc_bios *dcb,
 	enum controller_id controller_id,
 	enum bp_pipe_control_action action)
@@ -1382,9 +1369,8 @@ static enum bp_result bios_parser_enable_disp_power_gating(
 		action);
 }
 
-static bool bios_parser_is_device_id_supported(
-	struct dc_bios *dcb,
-	struct device_id id)
+bool dc_bios_is_device_id_supported(struct dc_bios *dcb,
+				    struct device_id id)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -1393,7 +1379,7 @@ static bool bios_parser_is_device_id_supported(
 	return (le16_to_cpu(bp->object_info_tbl.v1_1->usDeviceSupport) & mask) != 0;
 }
 
-static enum bp_result bios_parser_crt_control(
+enum bp_result dc_bios_crt_control(
 	struct dc_bios *dcb,
 	enum engine_id engine_id,
 	bool enable,
@@ -1535,7 +1521,7 @@ static enum bp_result get_ss_info_from_tbl(
 	uint32_t id,
 	struct spread_spectrum_info *ss_info);
 /**
- * bios_parser_get_spread_spectrum_info
+ * dc_bios_get_spread_spectrum_info
  * Get spread spectrum information from the ASIC_InternalSS_Info(ver 2.1 or
  * ver 3.1) or SS_Info table from the VBIOS. Currently ASIC_InternalSS_Info
  * ver 2.1 can co-exist with SS_Info table. Expect ASIC_InternalSS_Info ver 3.1,
@@ -1547,7 +1533,7 @@ static enum bp_result get_ss_info_from_tbl(
  * @param [out] ss_info, sprectrum information structure,
  * @return Bios parser result code
  */
-static enum bp_result bios_parser_get_spread_spectrum_info(
+enum bp_result dc_bios_get_spread_spectrum_info(
 	struct dc_bios *dcb,
 	enum as_signal_type signal,
 	uint32_t index,
@@ -1745,7 +1731,7 @@ static enum bp_result get_ss_info_from_ss_info_table(
 	{
 		struct embedded_panel_info panel_info;
 
-		if (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)
+		if (dc_bios_get_embedded_panel_info((struct dc_bios *)bp, &panel_info)
 				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
@@ -1801,7 +1787,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 	struct bios_parser *bp,
 	struct embedded_panel_info *info);
 
-static enum bp_result bios_parser_get_embedded_panel_info(
+enum bp_result dc_bios_get_embedded_panel_info(
 	struct dc_bios *dcb,
 	struct embedded_panel_info *info)
 {
@@ -2080,7 +2066,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 }
 
 /**
- * bios_parser_get_encoder_cap_info
+ * dc_bios_get_encoder_cap_info
  *
  * @brief
  *  Get encoder capability information of input object id
@@ -2091,10 +2077,9 @@ static enum bp_result get_embedded_panel_info_v1_3(
  * @return Bios parser result code
  *
  */
-static enum bp_result bios_parser_get_encoder_cap_info(
-	struct dc_bios *dcb,
-	struct graphics_object_id object_id,
-	struct bp_encoder_cap_info *info)
+enum bp_result dc_bios_get_encoder_cap_info(struct dc_bios *dcb,
+					    struct graphics_object_id object_id,
+					    struct bp_encoder_cap_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_OBJECT *object;
@@ -2168,7 +2153,7 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
 }
 
 /**
- * bios_parser_get_din_connector_info
+ * dc_bios_get_din_connector_info
  * @brief
  *   Get GPIO record for the DIN connector, this GPIO tells whether there is a
  *    CV dumb dongle
@@ -2179,10 +2164,9 @@ static ATOM_ENCODER_CAP_RECORD *get_encoder_cap_record(
  * @param info             - GPIO record infor
  * @return Bios parser result code
  */
-static enum bp_result bios_parser_get_din_connector_info(
-	struct dc_bios *dcb,
-	struct graphics_object_id id,
-	struct din_connector_info *info)
+enum bp_result dc_bios_get_din_connector_info(struct dc_bios *dcb,
+					      struct graphics_object_id id,
+					      struct din_connector_info *info)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_COMMON_RECORD_HEADER *header;
@@ -2265,9 +2249,8 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
  * @param[in] signal, ASSignalType to be converted to SSid
  * @return number of SS Entry that match the signal
  */
-static uint32_t bios_parser_get_ss_entry_number(
-	struct dc_bios *dcb,
-	enum as_signal_type signal)
+uint32_t dc_bios_get_ss_entry_number(struct dc_bios *dcb,
+				     enum as_signal_type signal)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	uint32_t ss_id = 0;
@@ -2352,7 +2335,7 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 	case ASIC_INTERNAL_SS_ON_LVDS: {
 		struct embedded_panel_info panel_info;
 
-		if (bios_parser_get_embedded_panel_info(&bp->base, &panel_info)
+		if (dc_bios_get_embedded_panel_info((struct dc_bios *)bp, &panel_info)
 				== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
 		break;
@@ -2514,9 +2497,8 @@ static ATOM_FAKE_EDID_PATCH_RECORD *get_faked_edid_record(
 	return (ATOM_FAKE_EDID_PATCH_RECORD *)record;
 }
 
-static enum bp_result bios_parser_get_faked_edid_len(
-	struct dc_bios *dcb,
-	uint32_t *len)
+enum bp_result dc_bios_get_faked_edid_len(struct dc_bios *dcb,
+					  uint32_t *len)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_FAKE_EDID_PATCH_RECORD *edid_record = get_faked_edid_record(bp);
@@ -2529,10 +2511,9 @@ static enum bp_result bios_parser_get_faked_edid_len(
 	return BP_RESULT_OK;
 }
 
-static enum bp_result bios_parser_get_faked_edid_buf(
-	struct dc_bios *dcb,
-	uint8_t *buff,
-	uint32_t len)
+enum bp_result dc_bios_get_faked_edid_buf(struct dc_bios *dcb,
+					  uint8_t *buff,
+					  uint32_t len)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	ATOM_FAKE_EDID_PATCH_RECORD *edid_record = get_faked_edid_record(bp);
@@ -2564,7 +2545,7 @@ static enum bp_result bios_parser_get_faked_edid_buf(
  *  2. in DATA_TABLE.GPIO_Pin_LUT, search all records, to get the registerA
  *  offset/mask
  */
-static enum bp_result bios_parser_get_gpio_pin_info(
+enum bp_result dc_bios_get_gpio_pin_info(
 	struct dc_bios *dcb,
 	uint32_t gpio_id,
 	struct gpio_pin_info *info)
@@ -2621,10 +2602,9 @@ static enum bp_result bios_parser_get_gpio_pin_info(
  * @param info, embedded panel patch mode structure
  * @return Bios parser result code
  */
-static enum bp_result bios_parser_enum_embedded_panel_patch_mode(
-	struct dc_bios *dcb,
-	uint32_t index,
-	struct embedded_panel_patch_mode *mode)
+enum bp_result dc_bios_enum_embedded_panel_patch_mode(struct dc_bios *dcb,
+						      uint32_t index,
+						      struct embedded_panel_patch_mode *mode)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	uint32_t record_size;
@@ -4134,15 +4114,14 @@ static void process_ext_display_connection_info(struct bios_parser *bp)
 	}
 }
 
-static void bios_parser_post_init(struct dc_bios *dcb)
+void dc_bios_post_init(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
 	process_ext_display_connection_info(bp);
 }
 
-static bool bios_parser_is_accelerated_mode(
-	struct dc_bios *dcb)
+bool dc_bios_is_accelerated_mode(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -4169,7 +4148,7 @@ static bool bios_parser_is_accelerated_mode(
  *  bool - connection state
  *  const ConnectorDeviceTagInfo* - pointer to device type and enum ID
  */
-static void bios_parser_set_scratch_connected(
+void dc_bios_set_scratch_connected(
 	struct dc_bios *dcb,
 	struct graphics_object_id connector_id,
 	bool connected,
@@ -4198,7 +4177,7 @@ static void bios_parser_set_scratch_connected(
  * @param
  *  bool - to set or reset state
  */
-static void bios_parser_set_scratch_critical_state(
+void dc_bios_set_scratch_critical_state(
 	struct dc_bios *dcb,
 	bool state)
 {
@@ -4215,8 +4194,7 @@ static void bios_parser_set_scratch_critical_state(
 #endif
 }
 
-static void bios_parser_set_scratch_acc_mode_change(
-	struct dc_bios *dcb)
+void dc_bios_set_scratch_acc_mode_change(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -4243,11 +4221,10 @@ static void bios_parser_set_scratch_acc_mode_change(
  *  const struct connector_device_tag_info * - pointer to display type and
  *  enum Id
  */
-static void bios_parser_prepare_scratch_active_and_requested(
-	struct dc_bios *dcb,
-	enum controller_id controller_id,
-	enum signal_type signal,
-	const struct connector_device_tag_info *device_tag)
+void dc_bios_prepare_scratch_active_and_requested(struct dc_bios *dcb,
+						  enum controller_id controller_id,
+						  enum signal_type signal,
+						  const struct connector_device_tag_info *device_tag)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -4266,8 +4243,7 @@ static void bios_parser_prepare_scratch_active_and_requested(
 #endif
 }
 
-static void bios_parser_set_scratch_active_and_requested(
-	struct dc_bios *dcb)
+void dc_bios_set_scratch_active_and_requested(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 
@@ -4662,8 +4638,7 @@ static enum bp_result construct_integrated_info(
 	return result;
 }
 
-static struct integrated_info *bios_parser_create_integrated_info(
-	struct dc_bios *dcb)
+struct integrated_info *dc_bios_create_integrated_info(struct dc_bios *dcb)
 {
 	struct bios_parser *bp = BP_FROM_DCB(dcb);
 	struct integrated_info *info = NULL;
@@ -4683,9 +4658,8 @@ static struct integrated_info *bios_parser_create_integrated_info(
 	return NULL;
 }
 
-static void bios_parser_destroy_integrated_info(
-	struct dc_bios *dcb,
-	struct integrated_info **info)
+void dc_bios_destroy_integrated_info(struct dc_bios *dcb,
+				     struct integrated_info **info)
 {
 	if (info == NULL) {
 		ASSERT_CRITICAL(0);
@@ -4699,13 +4673,15 @@ static void bios_parser_destroy_integrated_info(
 }
 
 /******************************************************************************
+
  * Stub-functions */
-static bool is_lid_open(
+bool dc_bios_is_lid_open(
 	struct dc_bios *bios)
 {
 	BREAK_TO_DEBUGGER();
 	return false;
 }
+#if 0
 
 static bool is_lid_status_changed(
 	struct dc_bios *bios)
@@ -4735,38 +4711,37 @@ static enum lcd_scale get_scratch_lcd_scale(
 	return LCD_SCALE_NONE;
 }
 
-static void get_bios_event_info(
+void dc_bios_get_bios_event_info(
 	struct dc_bios *bios,
 	struct bios_event_info *info)
 {
 	BREAK_TO_DEBUGGER();
 }
 
-static void update_requested_backlight_level(
+void dc_bios_update_requested_backlight_level(
 	struct dc_bios *bios,
 	uint32_t backlight_8bit)
 {
 	BREAK_TO_DEBUGGER();
 }
 
-static uint32_t get_requested_backlight_level(
+uint32_t dc_bios_get_requested_backlight_level(
 	struct dc_bios *bios)
 {
 	BREAK_TO_DEBUGGER();
 	return 0;
 }
 
-static void take_backlight_control(
+void dc_bios_take_backlight_control(
 	struct dc_bios *bios,
 	bool cntl)
 {
 	BREAK_TO_DEBUGGER();
 }
 
-static bool is_active_display(
-	struct dc_bios *bios,
-	enum signal_type signal,
-	const struct connector_device_tag_info *device_tag)
+bool dc_bios_is_active_display(struct dc_bios *bios,
+			       enum signal_type signal,
+			       const struct connector_device_tag_info *device_tag)
 {
 	BREAK_TO_DEBUGGER();
 	return false;
@@ -4785,151 +4760,7 @@ static uint32_t get_embedded_display_refresh_rate(
 	BREAK_TO_DEBUGGER();
 	return 0;
 }
-
-/******************************************************************************/
-
-static const struct dc_vbios_funcs vbios_funcs = {
-	.get_connectors_number = bios_parser_get_connectors_number,
-
-	.power_down = bios_parser_power_down,
-
-	.power_up = bios_parser_power_up,
-
-	.get_encoders_number = bios_parser_get_encoders_number,
-
-	.get_oem_ddc_lines_number = bios_parser_get_oem_ddc_lines_number,
-
-	.get_encoder_id = bios_parser_get_encoder_id,
-
-	.get_connector_id = bios_parser_get_connector_id,
-
-	.get_src_number = bios_parser_get_src_number,
-
-	.get_dst_number = bios_parser_get_dst_number,
-
-	.get_gpio_record = bios_parser_get_gpio_record,
-
-	.get_src_obj = bios_parser_get_src_obj,
-
-	.get_dst_obj = bios_parser_get_dst_obj,
-
-	.get_i2c_info = bios_parser_get_i2c_info,
-
-	.get_oem_ddc_info = bios_parser_get_oem_ddc_info,
-
-	.get_voltage_ddc_info = bios_parser_get_voltage_ddc_info,
-
-	.get_thermal_ddc_info = bios_parser_get_thermal_ddc_info,
-
-	.get_hpd_info = bios_parser_get_hpd_info,
-
-	.get_device_tag = bios_parser_get_device_tag,
-
-	.get_firmware_info = bios_parser_get_firmware_info,
-
-	.get_spread_spectrum_info = bios_parser_get_spread_spectrum_info,
-
-	.get_ss_entry_number = bios_parser_get_ss_entry_number,
-
-	.get_embedded_panel_info = bios_parser_get_embedded_panel_info,
-
-	.enum_embedded_panel_patch_mode = bios_parser_enum_embedded_panel_patch_mode,
-
-	.get_gpio_pin_info = bios_parser_get_gpio_pin_info,
-
-	.get_embedded_panel_info = bios_parser_get_embedded_panel_info,
-
-	.get_gpio_pin_info = bios_parser_get_gpio_pin_info,
-
-	.get_faked_edid_len = bios_parser_get_faked_edid_len,
-
-	.get_faked_edid_buf = bios_parser_get_faked_edid_buf,
-
-	.get_encoder_cap_info = bios_parser_get_encoder_cap_info,
-
-	.get_din_connector_info = bios_parser_get_din_connector_info,
-
-	.is_lid_open = is_lid_open,
-
-	.is_lid_status_changed = is_lid_status_changed,
-
-	.is_display_config_changed = is_display_config_changed,
-
-	.is_accelerated_mode = bios_parser_is_accelerated_mode,
-
-	.set_scratch_lcd_scale = set_scratch_lcd_scale,
-
-	.get_scratch_lcd_scale = get_scratch_lcd_scale,
-
-	.get_bios_event_info = get_bios_event_info,
-
-	.update_requested_backlight_level = update_requested_backlight_level,
-
-	.get_requested_backlight_level = get_requested_backlight_level,
-
-	.take_backlight_control = take_backlight_control,
-
-	.is_active_display = is_active_display,
-
-	.get_embedded_display_controller_id = get_embedded_display_controller_id,
-
-	.get_embedded_display_refresh_rate = get_embedded_display_refresh_rate,
-
-	.set_scratch_connected = bios_parser_set_scratch_connected,
-
-	.prepare_scratch_active_and_requested = bios_parser_prepare_scratch_active_and_requested,
-
-	.set_scratch_active_and_requested = bios_parser_set_scratch_active_and_requested,
-
-	.set_scratch_critical_state = bios_parser_set_scratch_critical_state,
-
-	.set_scratch_acc_mode_change = bios_parser_set_scratch_acc_mode_change,
-
-	.is_device_id_supported = bios_parser_is_device_id_supported,
-
-	/* COMMANDS */
-	.encoder_control = bios_parser_encoder_control,
-
-	.transmitter_control = bios_parser_transmitter_control,
-
-	.crt_control = bios_parser_crt_control,
-
-	.enable_crtc = bios_parser_enable_crtc,
-
-	.adjust_pixel_clock = bios_parser_adjust_pixel_clock,
-
-	.set_pixel_clock = bios_parser_set_pixel_clock,
-
-	.set_dce_clock = bios_parser_set_dce_clock,
-
-	.enable_spread_spectrum_on_ppll = bios_parser_enable_spread_spectrum_on_ppll,
-
-	.program_crtc_timing = bios_parser_program_crtc_timing,
-
-	.blank_crtc = bios_parser_blank_crtc,
-
-	.set_overscan = bios_parser_set_overscan,
-
-	.crtc_source_select = bios_parser_crtc_source_select,
-
-	.program_display_engine_pll = bios_parser_program_display_engine_pll,
-
-	.get_divider_for_target_display_clock = bios_parser_get_divider_for_target_display_clock,
-
-	.dac_load_detect = bios_parser_dac_load_detect,
-
-	.enable_memory_requests = bios_parser_enable_memory_requests,
-
-	.external_encoder_control = bios_parser_external_encoder_control,
-
-	.enable_disp_power_gating = bios_parser_enable_disp_power_gating,
-
-	.post_init = bios_parser_post_init,
-
-	.create_integrated_info = bios_parser_create_integrated_info,
-
-	.destroy_integrated_info = bios_parser_destroy_integrated_info,
-};
+#endif
 
 static bool bios_parser_construct(
 	struct bios_parser *bp,
@@ -4950,8 +4781,6 @@ static bool bios_parser_construct(
 	if (!init->bios)
 		return false;
 
-	bp->base.funcs = &vbios_funcs;
-
 	dce_version = dal_adapter_service_get_dce_version(as);
 	bp->ctx = init->ctx;
 	bp->as = as;
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h
index f8fa108..2133a59 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h
+++ b/drivers/gpu/drm/amd/dal/dc/bios/bios_parser.h
@@ -51,7 +51,6 @@ enum spread_spectrum_id {
 };
 
 struct bios_parser {
-	struct dc_bios base;
 	struct dc_context *ctx;
 	struct adapter_service *as;
 
@@ -79,6 +78,6 @@ struct bios_parser {
 
 /* Bios Parser from DC Bios */
 #define BP_FROM_DCB(dc_bios) \
-	container_of(dc_bios, struct bios_parser, base)
+	(struct bios_parser *)(dc_bios)
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c b/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
index 1b0f816..46cc3aa 100644
--- a/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/bios/dce112/bios_parser_helper_dce112.c
@@ -59,57 +59,6 @@ static void set_scratch_acc_mode_change(
 	dm_write_reg(ctx, addr, value);
 }
 
-/*
- * set_scratch_active_and_requested
- *
- * @brief
- * Set VBIOS scratch pad registers about active and requested displays
- *
- * @param
- * struct dc_context *ctx - [in] DAL context for register accessing
- * struct vbios_helper_data *d - [in] values to write
- */
-static void set_scratch_active_and_requested(
-	struct dc_context *ctx,
-	struct vbios_helper_data *d)
-{
-	uint32_t addr = 0;
-	uint32_t value = 0;
-
-	/* mmBIOS_SCRATCH_3 = mmBIOS_SCRATCH_0 + ATOM_ACTIVE_INFO_DEF */
-	addr = mmBIOS_SCRATCH_3;
-
-	value = dm_read_reg(ctx, addr);
-
-	value &= ~ATOM_S3_DEVICE_ACTIVE_MASK;
-	value |= (d->active & ATOM_S3_DEVICE_ACTIVE_MASK);
-
-	dm_write_reg(ctx, addr, value);
-
-	/* mmBIOS_SCRATCH_6 =  mmBIOS_SCRATCH_0 + ATOM_ACC_CHANGE_INFO_DEF */
-	addr = mmBIOS_SCRATCH_6;
-
-	value = dm_read_reg(ctx, addr);
-
-	value &= ~ATOM_S6_ACC_REQ_MASK;
-	value |= (d->requested & ATOM_S6_ACC_REQ_MASK);
-
-	dm_write_reg(ctx, addr, value);
-
-	/* mmBIOS_SCRATCH_5 =  mmBIOS_SCRATCH_0 + ATOM_DOS_REQ_INFO_DEF */
-	addr = mmBIOS_SCRATCH_5;
-
-	value = dm_read_reg(ctx, addr);
-
-	value &= ~ATOM_S5_DOS_REQ_DEVICEw0;
-	value |= (d->active & ATOM_S5_DOS_REQ_DEVICEw0);
-
-	dm_write_reg(ctx, addr, value);
-
-	d->active = 0;
-	d->requested = 0;
-}
-
 /**
  * get LCD Scale Mode from VBIOS scratch register
  */
@@ -311,116 +260,6 @@ static enum signal_type detect_sink(
 	return SIGNAL_TYPE_NONE;
 }
 
-/**
- * set_scratch_connected
- *
- * @brief
- *    update BIOS_SCRATCH_0 register about connected displays
- *
- * @param
- * bool - update scratch register or just prepare info to be updated
- * bool - connection state
- * const struct connector_device_tag_info * - pointer to device type and enum ID
- */
-static void set_scratch_connected(
-	struct dc_context *ctx,
-	struct graphics_object_id id,
-	bool connected,
-	const struct connector_device_tag_info *device_tag)
-{
-	uint32_t addr = 0;
-	uint32_t value = 0;
-	uint32_t update = 0;
-
-	switch (device_tag->dev_id.device_type) {
-	case DEVICE_TYPE_LCD:
-		/* For LCD VBIOS will update LCD Panel connected bit always and
-		 * Lid state bit based on SBIOS info do not do anything here
-		 * for LCD
-		 */
-		break;
-	case DEVICE_TYPE_CRT:
-		/* CRT is not supported in DCE11 */
-		break;
-	case DEVICE_TYPE_DFP:
-		switch (device_tag->dev_id.enum_id) {
-		case 1:
-			update |= ATOM_S0_DFP1;
-			break;
-		case 2:
-			update |= ATOM_S0_DFP2;
-			break;
-		case 3:
-			update |= ATOM_S0_DFP3;
-			break;
-		case 4:
-			update |= ATOM_S0_DFP4;
-			break;
-		case 5:
-			update |= ATOM_S0_DFP5;
-			break;
-		case 6:
-			update |= ATOM_S0_DFP6;
-			break;
-		default:
-			break;
-		}
-		break;
-	case DEVICE_TYPE_CV:
-		/* DCE 8.0 does not support CV, so don't do anything */
-		break;
-
-	case DEVICE_TYPE_TV:
-		/* For TV VBIOS will update S-Video or
-		 * Composite scratch bits on DAL_LoadDetect
-		 * when called by driver, do not do anything
-		 * here for TV
-		 */
-		break;
-
-	default:
-		break;
-
-	}
-
-	/* update scratch register */
-	addr = mmBIOS_SCRATCH_0 + ATOM_DEVICE_CONNECT_INFO_DEF;
-
-	value = dm_read_reg(ctx, addr);
-
-	if (connected)
-		value |= update;
-	else
-		value &= ~update;
-
-	dm_write_reg(ctx, addr, value);
-}
-
-static void set_scratch_critical_state(
-	struct dc_context *ctx,
-	bool state)
-{
-	uint32_t addr = mmBIOS_SCRATCH_6;
-	uint32_t value = dm_read_reg(ctx, addr);
-
-	if (state)
-		value |= ATOM_S6_CRITICAL_STATE;
-	else
-		value &= ~ATOM_S6_CRITICAL_STATE;
-
-	dm_write_reg(ctx, addr, value);
-}
-
-static void set_scratch_lcd_scale(
-	struct dc_context *ctx,
-	enum lcd_scale lcd_scale_request)
-{
-	DAL_LOGGER_NOT_IMPL(
-		LOG_MINOR_COMPONENT_BIOS,
-		"Bios Parser:%s\n",
-		__func__);
-}
-
 static bool is_lid_open(struct dc_context *ctx)
 {
 	uint32_t bios_scratch6;
@@ -440,27 +279,12 @@ static bool is_lid_open(struct dc_context *ctx)
 /* function table */
 static const struct bios_parser_helper bios_parser_helper_funcs = {
 	.detect_sink = detect_sink,
-	.fmt_bit_depth_control = NULL,
-	.fmt_control = NULL,
-	.get_bios_event_info = NULL,
-	.get_embedded_display_controller_id = NULL,
-	.get_embedded_display_refresh_rate = NULL,
-	.get_requested_backlight_level = NULL,
 	.get_scratch_lcd_scale = get_scratch_lcd_scale,
 	.is_accelerated_mode = is_accelerated_mode,
-	.is_active_display = NULL,
-	.is_display_config_changed = NULL,
 	.is_lid_open = is_lid_open,
-	.is_lid_status_changed = NULL,
 	.prepare_scratch_active_and_requested =
 			prepare_scratch_active_and_requested,
-	.set_scratch_acc_mode_change = set_scratch_acc_mode_change,
-	.set_scratch_active_and_requested = set_scratch_active_and_requested,
-	.set_scratch_connected = set_scratch_connected,
-	.set_scratch_critical_state = set_scratch_critical_state,
-	.set_scratch_lcd_scale = set_scratch_lcd_scale,
-	.take_backlight_control = NULL,
-	.update_requested_backlight_level = NULL,
+	.set_scratch_acc_mode_change = set_scratch_acc_mode_change
 };
 
 /*
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index d49ab5e..a5f33d4 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -83,7 +83,7 @@ static bool create_links(
 
 	dcb = dc->ctx->dc_bios;
 
-	connectors_num = dcb->funcs->get_connectors_number(dcb);
+	connectors_num = dc_bios_get_connectors_number(dcb);
 
 	if (connectors_num > ENUM_ID_COUNT) {
 		dm_error(
@@ -759,7 +759,7 @@ bool dc_commit_targets(
 
 	pplib_apply_safe_state(core_dc);
 
-	if (!dcb->funcs->is_accelerated_mode(dcb)) {
+	if (!dc_bios_is_accelerated_mode(dcb)) {
 		core_dc->hwss.enable_accelerated_mode(core_dc);
 	}
 
@@ -837,7 +837,7 @@ bool dc_commit_surfaces_to_target(
 
 	target_status = &context->target_status[i];
 
-	if (!dcb->funcs->is_accelerated_mode(dcb)
+	if (!dc_bios_is_accelerated_mode(dcb)
 			|| i == context->target_count) {
 		BREAK_TO_DEBUGGER();
 		goto unexpected_fail;
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h b/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
index 7def8dd..f17702d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_bios_types.h
@@ -38,239 +38,183 @@
 
 #include "include/bios_parser_types.h"
 
-struct dc_vbios_funcs {
-	uint8_t (*get_connectors_number)(struct dc_bios *bios);
-
-	void (*power_down)(struct dc_bios *bios);
-	void (*power_up)(struct dc_bios *bios);
-
-	uint8_t (*get_encoders_number)(struct dc_bios *bios);
-	uint32_t (*get_oem_ddc_lines_number)(struct dc_bios *bios);
-
-	struct graphics_object_id (*get_encoder_id)(
-		struct dc_bios *bios,
-		uint32_t i);
-	struct graphics_object_id (*get_connector_id)(
-		struct dc_bios *bios,
-		uint8_t connector_index);
-	uint32_t (*get_src_number)(
-		struct dc_bios *bios,
-		struct graphics_object_id id);
-	uint32_t (*get_dst_number)(
-		struct dc_bios *bios,
-		struct graphics_object_id id);
-
-	uint32_t (*get_gpio_record)(
-		struct dc_bios *dcb,
-		struct graphics_object_id id,
-		struct bp_gpio_cntl_info *gpio_record,
-		uint32_t record_size);
-
-	enum bp_result (*get_src_obj)(
-		struct dc_bios *bios,
-		struct graphics_object_id object_id, uint32_t index,
-		struct graphics_object_id *src_object_id);
-	enum bp_result (*get_dst_obj)(
-		struct dc_bios *bios,
-		struct graphics_object_id object_id, uint32_t index,
-		struct graphics_object_id *dest_object_id);
-	enum bp_result (*get_oem_ddc_info)(
-		struct dc_bios *bios,
-		uint32_t index,
-		struct graphics_object_i2c_info *info);
-
-	enum bp_result (*get_i2c_info)(
-		struct dc_bios *dcb,
-		struct graphics_object_id id,
-		struct graphics_object_i2c_info *info);
-
-	enum bp_result (*get_voltage_ddc_info)(
-		struct dc_bios *bios,
-		uint32_t index,
-		struct graphics_object_i2c_info *info);
-	enum bp_result (*get_thermal_ddc_info)(
-		struct dc_bios *bios,
-		uint32_t i2c_channel_id,
-		struct graphics_object_i2c_info *info);
-	enum bp_result (*get_hpd_info)(
-		struct dc_bios *bios,
-		struct graphics_object_id id,
-		struct graphics_object_hpd_info *info);
-	enum bp_result (*get_device_tag)(
-		struct dc_bios *bios,
-		struct graphics_object_id connector_object_id,
-		uint32_t device_tag_index,
-		struct connector_device_tag_info *info);
-	enum bp_result (*get_firmware_info)(
-		struct dc_bios *bios,
-		struct firmware_info *info);
-	enum bp_result (*get_spread_spectrum_info)(
-		struct dc_bios *bios,
-		enum as_signal_type signal,
-		uint32_t index,
-		struct spread_spectrum_info *ss_info);
-	uint32_t (*get_ss_entry_number)(
-		struct dc_bios *bios,
-		enum as_signal_type signal);
-	enum bp_result (*get_embedded_panel_info)(
-		struct dc_bios *bios,
-		struct embedded_panel_info *info);
-	enum bp_result (*enum_embedded_panel_patch_mode)(
-		struct dc_bios *bios,
-		uint32_t index,
-		struct embedded_panel_patch_mode *mode);
-	enum bp_result (*get_gpio_pin_info)(
-		struct dc_bios *bios,
-		uint32_t gpio_id,
-		struct gpio_pin_info *info);
-	enum bp_result (*get_faked_edid_len)(
-		struct dc_bios *bios,
-		uint32_t *len);
-	enum bp_result (*get_faked_edid_buf)(
-		struct dc_bios *bios,
-		uint8_t *buff,
-		uint32_t len);
-	enum bp_result (*get_encoder_cap_info)(
-		struct dc_bios *bios,
-		struct graphics_object_id object_id,
-		struct bp_encoder_cap_info *info);
-	enum bp_result (*get_din_connector_info)(
-		struct dc_bios *bios,
-		struct graphics_object_id id,
-		struct din_connector_info *info);
-
-	bool (*is_lid_open)(
-		struct dc_bios *bios);
-	bool (*is_lid_status_changed)(
-		struct dc_bios *bios);
-	bool (*is_display_config_changed)(
-		struct dc_bios *bios);
-	bool (*is_accelerated_mode)(
-		struct dc_bios *bios);
-	void (*set_scratch_lcd_scale)(
-		struct dc_bios *bios,
-		enum lcd_scale scale);
-	enum lcd_scale  (*get_scratch_lcd_scale)(
-		struct dc_bios *bios);
-	void (*get_bios_event_info)(
-		struct dc_bios *bios,
-		struct bios_event_info *info);
-	void (*update_requested_backlight_level)(
-		struct dc_bios *bios,
-		uint32_t backlight_8bit);
-	uint32_t (*get_requested_backlight_level)(
-		struct dc_bios *bios);
-	void (*take_backlight_control)(
-		struct dc_bios *bios,
-		bool cntl);
-	bool (*is_active_display)(
-		struct dc_bios *bios,
-		enum signal_type signal,
-		const struct connector_device_tag_info *device_tag);
-	enum controller_id (*get_embedded_display_controller_id)(
-		struct dc_bios *bios);
-	uint32_t (*get_embedded_display_refresh_rate)(
-		struct dc_bios *bios);
-	void (*set_scratch_connected)(
-		struct dc_bios *bios,
-		struct graphics_object_id connector_id,
-		bool connected,
-		const struct connector_device_tag_info *device_tag);
-	void (*prepare_scratch_active_and_requested)(
-		struct dc_bios *bios,
-		enum controller_id controller_id,
-		enum signal_type signal,
-		const struct connector_device_tag_info *device_tag);
-	void (*set_scratch_active_and_requested)(
-		struct dc_bios *bios);
-	void (*set_scratch_critical_state)(
-		struct dc_bios *bios,
-		bool state);
-	void (*set_scratch_acc_mode_change)(
-		struct dc_bios *bios);
-
-	bool (*is_device_id_supported)(
-		struct dc_bios *bios,
-		struct device_id id);
-
-	/* COMMANDS */
-
-	enum bp_result (*encoder_control)(
-		struct dc_bios *bios,
-		struct bp_encoder_control *cntl);
-	enum bp_result (*transmitter_control)(
-		struct dc_bios *bios,
-		struct bp_transmitter_control *cntl);
-	enum bp_result (*crt_control)(
-		struct dc_bios *bios,
-		enum engine_id engine_id,
-		bool enable,
-		uint32_t pixel_clock);
-	enum bp_result (*enable_crtc)(
-		struct dc_bios *bios,
-		enum controller_id id,
-		bool enable);
-	enum bp_result (*adjust_pixel_clock)(
-		struct dc_bios *bios,
-		struct bp_adjust_pixel_clock_parameters *bp_params);
-	enum bp_result (*set_pixel_clock)(
-		struct dc_bios *bios,
-		struct bp_pixel_clock_parameters *bp_params);
-	enum bp_result (*set_dce_clock)(
-		struct dc_bios *bios,
-		struct bp_set_dce_clock_parameters *bp_params);
-	enum bp_result (*enable_spread_spectrum_on_ppll)(
-		struct dc_bios *bios,
-		struct bp_spread_spectrum_parameters *bp_params,
-		bool enable);
-	enum bp_result (*program_crtc_timing)(
-		struct dc_bios *bios,
-		struct bp_hw_crtc_timing_parameters *bp_params);
-	enum bp_result (*blank_crtc)(
-		struct dc_bios *bios,
-		struct bp_blank_crtc_parameters *bp_params,
-		bool blank);
-	enum bp_result (*set_overscan)(
-		struct dc_bios *bios,
-		struct bp_hw_crtc_overscan_parameters *bp_params);
-	enum bp_result (*crtc_source_select)(
-		struct dc_bios *bios,
-		struct bp_crtc_source_select *bp_params);
-	enum bp_result (*program_display_engine_pll)(
-		struct dc_bios *bios,
-		struct bp_pixel_clock_parameters *bp_params);
-	enum bp_result (*get_divider_for_target_display_clock)(
-		struct dc_bios *bios,
-		struct bp_display_clock_parameters *bp_params);
-	enum signal_type (*dac_load_detect)(
-		struct dc_bios *bios,
-		struct graphics_object_id encoder,
-		struct graphics_object_id connector,
-		enum signal_type display_signal);
-	enum bp_result (*enable_memory_requests)(
-		struct dc_bios *bios,
-		enum controller_id controller_id,
-		bool enable);
-	enum bp_result (*external_encoder_control)(
-		struct dc_bios *bios,
-		struct bp_external_encoder_control *cntl);
-	enum bp_result (*enable_disp_power_gating)(
-		struct dc_bios *bios,
-		enum controller_id controller_id,
-		enum bp_pipe_control_action action);
-
-	void (*post_init)(struct dc_bios *bios);
-
-	struct integrated_info *(*create_integrated_info)(
-		struct dc_bios *bios);
-
-	void (*destroy_integrated_info)(
-		struct dc_bios *dcb,
-		struct integrated_info **info);
-};
-
-struct dc_bios {
-	const struct dc_vbios_funcs *funcs;
-};
+uint8_t dc_bios_get_connectors_number(struct dc_bios *bios);
+
+void dc_bios_power_down(struct dc_bios *bios);
+void dc_bios_power_up(struct dc_bios *bios);
+
+uint8_t dc_bios_get_encoders_number(struct dc_bios *bios);
+uint32_t dc_bios_get_oem_ddc_lines_number(struct dc_bios *bios);
+
+struct graphics_object_id dc_bios_get_encoder_id(struct dc_bios *bios,
+						 uint32_t i);
+struct graphics_object_id dc_bios_get_connector_id(struct dc_bios *bios,
+						   uint8_t connector_index);
+uint32_t dc_bios_get_src_number(struct dc_bios *bios,
+				struct graphics_object_id id);
+uint32_t dc_bios_get_dst_number(struct dc_bios *bios,
+				struct graphics_object_id id);
+
+uint32_t dc_bios_get_gpio_record(struct dc_bios *dcb,
+				 struct graphics_object_id id,
+				 struct bp_gpio_cntl_info *gpio_record,
+				 uint32_t record_size);
+enum bp_result dc_bios_get_src_obj(struct dc_bios *bios,
+				    struct graphics_object_id object_id,
+				    uint32_t index,
+				    struct graphics_object_id *src_object_id);
+enum bp_result dc_bios_get_dst_obj(struct dc_bios *bios,
+				   struct graphics_object_id object_id,
+				   uint32_t index,
+				   struct graphics_object_id *dest_object_id);
+enum bp_result dc_bios_get_oem_ddc_info(struct dc_bios *bios,
+					uint32_t index,
+					struct graphics_object_i2c_info *info);
+enum bp_result dc_bios_get_i2c_info(struct dc_bios *dcb,
+				    struct graphics_object_id id,
+				    struct graphics_object_i2c_info *info);
+
+enum bp_result dc_bios_get_voltage_ddc_info(struct dc_bios *bios,
+					    uint32_t index,
+					    struct graphics_object_i2c_info *info);
+
+enum bp_result dc_bios_get_thermal_ddc_info(struct dc_bios *bios,
+					    uint32_t i2c_channel_id,
+					    struct graphics_object_i2c_info *info);
+enum bp_result dc_bios_get_hpd_info(struct dc_bios *bios,
+				    struct graphics_object_id id,
+				    struct graphics_object_hpd_info *info);
+enum bp_result dc_bios_get_device_tag(struct dc_bios *bios,
+				      struct graphics_object_id connector_object_id,
+				      uint32_t device_tag_index,
+				      struct connector_device_tag_info *info);
+
+enum bp_result dc_bios_get_firmware_info(struct dc_bios *bios,
+					 struct firmware_info *info);
+
+enum bp_result dc_bios_get_spread_spectrum_info(struct dc_bios *bios,
+						enum as_signal_type signal,
+						uint32_t index,
+						struct spread_spectrum_info *ss_info);
+uint32_t dc_bios_get_ss_entry_number(struct dc_bios *bios,
+				     enum as_signal_type signal);
+enum bp_result dc_bios_get_embedded_panel_info(struct dc_bios *bios,
+					       struct embedded_panel_info *info);
+enum bp_result dc_bios_enum_embedded_panel_patch_mode(struct dc_bios *bios,
+						      uint32_t index,
+						      struct embedded_panel_patch_mode *mode);
+
+enum bp_result dc_bios_get_gpio_pin_info(struct dc_bios *bios,
+					 uint32_t gpio_id,
+					 struct gpio_pin_info *info);
+
+enum bp_result dc_bios_get_faked_edid_len(struct dc_bios *bios,
+					  uint32_t *len);
+
+enum bp_result dc_bios_get_faked_edid_buf(struct dc_bios *bios,
+					  uint8_t *buff,
+					  uint32_t len);
+
+enum bp_result dc_bios_get_encoder_cap_info(struct dc_bios *bios,
+					    struct graphics_object_id object_id,
+					    struct bp_encoder_cap_info *info);
+enum bp_result dc_bios_get_din_connector_info(struct dc_bios *bios,
+					      struct graphics_object_id id,
+					      struct din_connector_info *info);
+bool dc_bios_is_device_id_supported(struct dc_bios *bios,
+				    struct device_id id);
+bool dc_bios_is_accelerated_mode(struct dc_bios *bios);
+bool dc_bios_is_lid_open(struct dc_bios *bios);
+#if 0 /* unused trap to debugger functions */
+
+bool dc_bios_is_lid_status_changed(struct dc_bios *bios);
+bool dc_bios_is_display_config_changed(struct dc_bios *bios);
+
+void dc_bios_set_scratch_lcd_scale(struct dc_bios *bios,
+				   enum lcd_scale scale);
+enum lcd_scale  dc_bios_get_scratch_lcd_scale(struct dc_bios *bios);
+void dc_bios_get_bios_event_info(struct dc_bios *bios,
+				 struct bios_event_info *info);
+void dc_bios_update_requested_backlight_level(struct dc_bios *bios,
+					      uint32_t backlight_8bit);
+uint32_t dc_bios_get_requested_backlight_level(struct dc_bios *bios);
+void dc_bios_take_backlight_control(struct dc_bios *bios,
+				    bool cntl);
+bool dc_bios_is_active_display(struct dc_bios *bios,
+			       enum signal_type signal,
+			       const struct connector_device_tag_info *device_tag);
+enum controller_id dc_bios_get_embedded_display_controller_id(struct dc_bios *bios);
+uint32_t dc_bios_get_embedded_display_refresh_rate(struct dc_bios *bios);
+#endif
+
+void dc_bios_set_scratch_connected(struct dc_bios *bios,
+				   struct graphics_object_id connector_id,
+				   bool connected,
+				   const struct connector_device_tag_info *device_tag);
+void dc_bios_prepare_scratch_active_and_requested(struct dc_bios *bios,
+						  enum controller_id controller_id,
+						  enum signal_type signal,
+						  const struct connector_device_tag_info *device_tag);
+void dc_bios_set_scratch_active_and_requested(struct dc_bios *bios);
+void dc_bios_set_scratch_critical_state(struct dc_bios *bios,
+					bool state);
+void dc_bios_set_scratch_acc_mode_change(struct dc_bios *bios);
+
+/* COMMANDS */
+enum bp_result dc_bios_encoder_control(struct dc_bios *bios,
+				       struct bp_encoder_control *cntl);
+enum bp_result dc_bios_transmitter_control(struct dc_bios *bios,
+					   struct bp_transmitter_control *cntl);
+enum bp_result dc_bios_crt_control(struct dc_bios *bios,
+				   enum engine_id engine_id,
+				   bool enable,
+				   uint32_t pixel_clock);
+enum bp_result dc_bios_enable_crtc(struct dc_bios *bios,
+				   enum controller_id id,
+				   bool enable);
+enum bp_result dc_bios_adjust_pixel_clock(struct dc_bios *bios,
+					  struct bp_adjust_pixel_clock_parameters *bp_params);
+enum bp_result dc_bios_set_pixel_clock(struct dc_bios *bios,
+				       struct bp_pixel_clock_parameters *bp_params);
+enum bp_result dc_bios_set_dce_clock(struct dc_bios *bios,
+				     struct bp_set_dce_clock_parameters *bp_params);
+enum bp_result dc_bios_enable_spread_spectrum_on_ppll(struct dc_bios *bios,
+						      struct bp_spread_spectrum_parameters *bp_params,
+						      bool enable);
+enum bp_result dc_bios_program_crtc_timing(struct dc_bios *bios,
+					   struct bp_hw_crtc_timing_parameters *bp_params);
+enum bp_result dc_bios_blank_crtc(struct dc_bios *bios,
+				  struct bp_blank_crtc_parameters *bp_params,
+				  bool blank);
+enum bp_result dc_bios_set_overscan(struct dc_bios *bios,
+				    struct bp_hw_crtc_overscan_parameters *bp_params);
+enum bp_result dc_bios_crtc_source_select(struct dc_bios *bios,
+					  struct bp_crtc_source_select *bp_params);
+enum bp_result dc_bios_program_display_engine_pll(struct dc_bios *bios,
+						  struct bp_pixel_clock_parameters *bp_params);
+enum bp_result dc_bios_get_divider_for_target_display_clock(struct dc_bios *bios,
+							    struct bp_display_clock_parameters *bp_params);
+enum signal_type dc_bios_dac_load_detect(struct dc_bios *bios,
+					 struct graphics_object_id encoder,
+					 struct graphics_object_id connector,
+					 enum signal_type display_signal);
+enum bp_result dc_bios_enable_memory_requests(struct dc_bios *bios,
+					      enum controller_id controller_id,
+					      bool enable);
+enum bp_result dc_bios_external_encoder_control(struct dc_bios *bios,
+						struct bp_external_encoder_control *cntl);
+enum bp_result dc_bios_enable_disp_power_gating(struct dc_bios *bios,
+						enum controller_id controller_id,
+						enum bp_pipe_control_action action);
+
+
+void dc_bios_post_init(struct dc_bios *bios);
+
+struct integrated_info *dc_bios_create_integrated_info(struct dc_bios *bios);
+
+void dc_bios_destroy_integrated_info(struct dc_bios *dcb,
+				     struct integrated_info **info);
+
+struct dc_bios;
 
 #endif /* DC_BIOS_TYPES_H */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
index a2a4f2a..ef1afd3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_hw_sequencer.c
@@ -221,8 +221,7 @@ static bool dce100_enable_display_power_gating(
 		cntl = ASIC_PIPE_DISABLE;
 
 	if (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0))
-		bp_result = dcb->funcs->enable_disp_power_gating(
-						dcb, controller_id + 1, cntl);
+		bp_result = dc_bios_enable_disp_power_gating(dcb, controller_id + 1, cntl);
 
 	if (bp_result == BP_RESULT_OK)
 		return true;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
index d9c1d86..d48e3df 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_clock_source.c
@@ -428,8 +428,8 @@ static bool pll_adjust_pix_clk(
 	bp_adjust_pixel_clock_params.signal_type = pix_clk_params->signal_type;
 	bp_adjust_pixel_clock_params.
 		ss_enable = pix_clk_params->flags.ENABLE_SS;
-	bp_result = clk_src->bios->funcs->adjust_pixel_clock(
-			clk_src->bios, &bp_adjust_pixel_clock_params);
+	bp_result = dc_bios_adjust_pixel_clock(clk_src->bios,
+					       &bp_adjust_pixel_clock_params);
 	if (bp_result == BP_RESULT_OK) {
 		pll_settings->actual_pix_clk = actual_pix_clk_khz;
 		pll_settings->adjusted_pix_clk =
@@ -552,10 +552,9 @@ static bool disable_spread_spectrum(struct dce110_clk_src *clk_src)
 	bp_ss_params.pll_id = clk_src->base.id;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	result = clk_src->bios->funcs->enable_spread_spectrum_on_ppll(
-			clk_src->bios,
-			&bp_ss_params,
-			false);
+	result = dc_bios_enable_spread_spectrum_on_ppll(clk_src->bios,
+							&bp_ss_params,
+							false);
 
 	return result == BP_RESULT_OK;
 }
@@ -659,11 +658,9 @@ static bool enable_spread_spectrum(
 				bp_params.flags.EXTERNAL_SS = 1;
 
 			if (BP_RESULT_OK !=
-				clk_src->bios->funcs->
-					enable_spread_spectrum_on_ppll(
-							clk_src->bios,
-							&bp_params,
-							true))
+			    dc_bios_enable_spread_spectrum_on_ppll(clk_src->bios,
+								   &bp_params,
+								   true))
 				return false;
 		} else
 			return false;
@@ -766,8 +763,8 @@ static bool dce110_program_pix_clk(
 	bp_pc_params.flags.SET_EXTERNAL_REF_DIV_SRC =
 					pll_settings->use_external_clk;
 
-	if (dce110_clk_src->bios->funcs->set_pixel_clock(
-			dce110_clk_src->bios, &bp_pc_params) != BP_RESULT_OK)
+	if (dc_bios_set_pixel_clock(dce110_clk_src->bios,
+				    &bp_pc_params) != BP_RESULT_OK)
 		return false;
 
 /* Enable SS
@@ -808,7 +805,7 @@ static bool dce110_clock_source_power_down(
 	bp_pixel_clock_params.flags.FORCE_PROGRAMMING_OF_PLL = 1;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	bp_result = dce110_clk_src->bios->funcs->set_pixel_clock(
+	bp_result = dc_bios_set_pixel_clock(
 			dce110_clk_src->bios,
 			&bp_pixel_clock_params);
 
@@ -855,9 +852,8 @@ static void get_ss_info_from_atombios(
 	spread_spectrum_data[0] = NULL;
 	*ss_entries_num = 0;
 
-	*ss_entries_num = clk_src->bios->funcs->get_ss_entry_number(
-			clk_src->bios,
-			as_signal);
+	*ss_entries_num = dc_bios_get_ss_entry_number(clk_src->bios,
+						      as_signal);
 
 	if (*ss_entries_num == 0)
 		return;
@@ -875,12 +871,11 @@ static void get_ss_info_from_atombios(
 		i < (*ss_entries_num);
 		++i, ++ss_info_cur) {
 
-		bp_result = clk_src->bios->funcs->get_spread_spectrum_info(
-				clk_src->bios,
-				as_signal,
-				i,
-				ss_info_cur);
-
+		bp_result = dc_bios_get_spread_spectrum_info(clk_src->bios,
+							     as_signal,
+							     i,
+							     ss_info_cur);
+		
 		if (bp_result != BP_RESULT_OK)
 			goto out_free_data;
 	}
@@ -982,9 +977,8 @@ static bool calc_pll_max_vco_construct(
 			init_data->bp == NULL)
 		return false;
 
-	if (init_data->bp->funcs->get_firmware_info(
-				init_data->bp,
-				&fw_info) != BP_RESULT_OK)
+	if (dc_bios_get_firmware_info(init_data->bp,
+				      &fw_info) != BP_RESULT_OK)
 		return false;
 
 	calc_pll_cs->ctx = init_data->ctx;
@@ -1103,8 +1097,7 @@ bool dce110_clk_src_construct(
 	clk_src->base.id = id;
 	clk_src->base.funcs = &dce110_clk_src_funcs;
 
-	if (clk_src->bios->funcs->get_firmware_info(
-			clk_src->bios, &fw_info) != BP_RESULT_OK) {
+	if (dc_bios_get_firmware_info(clk_src->bios, &fw_info) != BP_RESULT_OK) {
 		ASSERT_CRITICAL(false);
 		goto unexpected_failure;
 	}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 53da396..73c576e 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -377,8 +377,7 @@ static bool dce110_enable_display_power_gating(
 		controller_id = CONTROLLER_ID_UNDERLAY0 - 1;
 
 	if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0)
-		bp_result = dcb->funcs->enable_disp_power_gating(
-						dcb, controller_id + 1, cntl);
+		bp_result = dc_bios_enable_disp_power_gating(dcb, controller_id + 1, cntl);
 
 	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
 		dce110_init_pte(ctx);
@@ -486,7 +485,7 @@ static enum dc_status bios_parser_crtc_source_select(
 
 	dcb = dal_adapter_service_get_bios_parser(sink->link->adapter_srv);
 
-	if (BP_RESULT_OK != dcb->funcs->crtc_source_select(
+	if (BP_RESULT_OK != dc_bios_crtc_source_select(
 		dcb,
 		&crtc_source_select)) {
 		return DC_ERROR_UNEXPECTED;
@@ -520,7 +519,7 @@ static void update_bios_scratch_critical_state(struct adapter_service *as,
 {
 	struct dc_bios *dcb = dal_adapter_service_get_bios_parser(as);
 
-	dcb->funcs->set_scratch_critical_state(dcb, state);
+	dc_bios_set_scratch_critical_state(dcb, state);
 }
 
 static void update_info_frame(struct pipe_ctx *pipe_ctx)
@@ -882,7 +881,7 @@ static void enable_accelerated_mode(struct core_dc *dc)
 
 	disable_vga_and_power_gate_all_controllers(dc);
 
-	dcb->funcs->set_scratch_acc_mode_change(dcb);
+	dc_bios_set_scratch_acc_mode_change(dcb);
 }
 
 #if 0
@@ -1558,7 +1557,7 @@ static void init_hw(struct core_dc *dc)
 	}
 
 	dc->hwss.clock_gating_power_up(dc->ctx, false);
-	bp->funcs->power_up(bp);
+	dc_bios_power_up(bp);
 	/***************************************/
 
 	for (i = 0; i < dc->link_count; i++) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 8da3e4d..4487638 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -118,7 +118,7 @@ static enum bp_result link_transmitter_control(
 	struct dc_bios *bp = dal_adapter_service_get_bios_parser(
 					enc110->base.adapter_service);
 
-	result = bp->funcs->transmitter_control(bp, cntl);
+	result = dc_bios_transmitter_control(bp, cntl);
 
 	return result;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
index dcca860..0ff37da 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_stream_encoder.c
@@ -410,8 +410,7 @@ void dce110_stream_encoder_hdmi_set_stream_attribute(
 	cntl.lanes_number = LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (enc110->base.bp->funcs->encoder_control(
-			enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	addr = LINK_REG(DIG_FE_CNTL);
@@ -591,8 +590,7 @@ void dce110_stream_encoder_dvi_set_stream_attribute(
 				LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (enc110->base.bp->funcs->encoder_control(
-			enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	switch (crtc_timing->pixel_encoding) {
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index b17fb79..5572995 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -291,7 +291,7 @@ bool dce110_timing_generator_enable_crtc(struct timing_generator *tg)
 	value = 0;
 	dm_write_reg(tg->ctx, CRTC_REG(mmCRTC_MASTER_UPDATE_LOCK), value);
 
-	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, true);
+	result = dc_bios_enable_crtc(tg->bp, tg110->controller_id, true);
 
 	return result == BP_RESULT_OK;
 }
@@ -469,7 +469,7 @@ bool dce110_timing_generator_disable_crtc(struct timing_generator *tg)
 
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 
-	result = tg->bp->funcs->enable_crtc(tg->bp, tg110->controller_id, false);
+	result = dc_bios_enable_crtc(tg->bp, tg110->controller_id, false);
 
 	/* Need to make sure stereo is disabled according to the DCE5.0 spec */
 
@@ -574,7 +574,7 @@ bool dce110_timing_generator_program_timing_generator(
 	if (patched_crtc_timing.flags.HORZ_COUNT_BY_TWO == 1)
 		bp_params.flags.HORZ_COUNT_BY_TWO = 1;
 
-	result = tg->bp->funcs->program_crtc_timing(tg->bp, &bp_params);
+	result = dc_bios_program_crtc_timing(tg->bp, &bp_params);
 
 	program_horz_count_by_2(tg, &patched_crtc_timing);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
index 7ec9508..65ddb80 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_clock_source.c
@@ -188,7 +188,7 @@ static bool dce112_program_pix_clk(
 		bp_pc_params.flags.SUPPORT_YUV_420 = 0;
 	}
 
-	if (dce112_clk_src->bios->funcs->set_pixel_clock(
+	if (dc_bios_set_pixel_clock(
 			dce112_clk_src->bios, &bp_pc_params) != BP_RESULT_OK)
 		return false;
 
@@ -219,7 +219,7 @@ static bool dce112_clock_source_power_down(
 	bp_pixel_clock_params.flags.FORCE_PROGRAMMING_OF_PLL = 1;
 
 	/*Call ASICControl to process ATOMBIOS Exec table*/
-	bp_result = dce112_clk_src->bios->funcs->set_pixel_clock(
+	bp_result = dc_bios_set_pixel_clock(
 			dce112_clk_src->bios,
 			&bp_pixel_clock_params);
 
@@ -250,7 +250,7 @@ bool dce112_clk_src_construct(
 	clk_src->base.funcs = &dce112_clk_src_funcs;
 	clk_src->offsets = *reg_offsets;
 
-	if (clk_src->bios->funcs->get_firmware_info(
+	if (dc_bios_get_firmware_info(
 			clk_src->bios, &fw_info) != BP_RESULT_OK) {
 		ASSERT_CRITICAL(false);
 		goto unexpected_failure;
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
index 931e47e..437b4c3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_hw_sequencer.c
@@ -347,7 +347,7 @@ static bool dce112_enable_display_power_gating(
 		cntl = ASIC_PIPE_DISABLE;
 
 	if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0)
-		bp_result = dcb->funcs->enable_disp_power_gating(
+		bp_result = dc_bios_enable_disp_power_gating(
 						dcb, controller_id + 1, cntl);
 
 	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
index 68cf84d..e99d694 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_hw_sequencer.c
@@ -203,7 +203,7 @@ static bool dce80_enable_display_power_gating(
 		cntl = ASIC_PIPE_DISABLE;
 
 	if (!(power_gating == PIPE_GATING_CONTROL_INIT && controller_id != 0))
-		bp_result = dcb->funcs->enable_disp_power_gating(
+		bp_result = dc_bios_enable_disp_power_gating(
 						dcb, controller_id + 1, cntl);
 
 	if (bp_result == BP_RESULT_OK)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
index 4615c34..653983d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
@@ -79,7 +79,7 @@ static enum bp_result link_transmitter_control(
 	struct dc_bios *bp = dal_adapter_service_get_bios_parser(
 					enc110->base.adapter_service);
 
-	result = bp->funcs->transmitter_control(bp, cntl);
+	result = dc_bios_transmitter_control(bp, cntl);
 
 	return result;
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
index f0a7ee1..7f62b0d 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_stream_encoder.c
@@ -426,8 +426,7 @@ void dce80_stream_encoder_hdmi_set_stream_attribute(
 	cntl.lanes_number = LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (enc110->base.bp->funcs->encoder_control(
-			enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	switch (crtc_timing->pixel_encoding) {
@@ -567,8 +566,7 @@ void dce80_stream_encoder_dvi_set_stream_attribute(
 				LANE_COUNT_EIGHT : LANE_COUNT_FOUR;
 	cntl.color_depth = crtc_timing->display_color_depth;
 
-	if (enc110->base.bp->funcs->encoder_control(
-			enc110->base.bp, &cntl) != BP_RESULT_OK)
+	if (dc_bios_encoder_control(enc110->base.bp, &cntl) != BP_RESULT_OK)
 		return;
 
 	switch (crtc_timing->pixel_encoding) {
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
index ba9a1fa..3d0f8e1 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce110/display_clock_dce110.c
@@ -789,7 +789,7 @@ static void set_clock(
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = base->id;
 
-	bp->funcs->program_display_engine_pll(bp, &pxl_clk_params);
+	dc_bios_program_display_engine_pll(bp, &pxl_clk_params);
 
 	if (dc->dfs_bypass_enabled) {
 
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
index 875bf22..08a70db 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce112/display_clock_dce112.c
@@ -776,7 +776,7 @@ static void set_clock(
 	dce_clk_params.pll_id = dc->disp_clk_base.id;
 	dce_clk_params.clock_type = DCECLOCK_TYPE_DISPLAY_CLOCK;
 
-	bp->funcs->set_dce_clock(bp, &dce_clk_params);
+	dc_bios_set_dce_clock(bp, &dce_clk_params);
 
 	/* from power down, we need mark the clock state as ClocksStateNominal
 	 * from HWReset, so when resume we will call pplib voltage regulator.*/
@@ -790,7 +790,7 @@ static void set_clock(
 	dce_clk_params.flags.USE_GENLOCK_AS_SOURCE_FOR_DPREFCLK =
 			(dce_clk_params.pll_id == CLOCK_SOURCE_COMBO_DISPLAY_PLL0);
 
-	bp->funcs->set_dce_clock(bp, &dce_clk_params);
+	dc_bios_set_dce_clock(bp, &dce_clk_params);
 }
 
 static void set_clock_state(
diff --git a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
index 74d5b2e..313651c 100644
--- a/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
+++ b/drivers/gpu/drm/amd/dal/dc/gpu/dce80/display_clock_dce80.c
@@ -478,7 +478,7 @@ static void set_clock(
 	pxl_clk_params.target_pixel_clock = requested_clk_khz;
 	pxl_clk_params.pll_id = dc->id;
 
-	bp->funcs->program_display_engine_pll(bp, &pxl_clk_params);
+	dc_bios_program_display_engine_pll(bp, &pxl_clk_params);
 
 	if (disp_clk->dfs_bypass_enabled) {
 
-- 
2.7.4

