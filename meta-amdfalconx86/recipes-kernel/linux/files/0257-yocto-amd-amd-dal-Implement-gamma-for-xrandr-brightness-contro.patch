From 6c3443e0a5d14d50552006890c1a50b3273cfa42 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 24 Jul 2015 08:50:18 -0400
Subject: [PATCH 374/401] amd/dal: Implement gamma for xrandr brightness
 control

Reviewed-By: Vitaly Prosyak <Vitaly.Prosyak@amd.com>
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 .../amd/dal/controller/dce110/grph_gamma_dce110.c  |  10 +-
 drivers/gpu/drm/amd/dal/controller/grph_gamma.c    |   7 +-
 .../gpu/drm/amd/dal/controller/grph_gamma_types.h  |  10 +-
 .../gpu/drm/amd/dal/display_path/display_path.c    |   3 +-
 drivers/gpu/drm/amd/dal/display_service/Makefile   |   2 +-
 .../display_service/adjustment_types_internal.h    |  10 +
 .../gpu/drm/amd/dal/display_service/ds_dispatch.h  |   1 +
 .../dal/display_service/ds_dispatch_adjustment.c   | 136 ++++---
 .../dal/display_service/ds_dispatch_mode_setting.c |   2 +-
 .../drm/amd/dal/display_service/ds_translation.c   |  47 ++-
 .../drm/amd/dal/display_service/ds_translation.h   |  14 +-
 .../gpu/drm/amd/dal/display_service/gamma_lut.c    | 392 +++++++++++++++++++++
 .../gpu/drm/amd/dal/display_service/gamma_lut.h    |  89 +++++
 .../amd/dal/display_service/grph_colors_group.c    |   8 +-
 .../gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c    |  36 +-
 .../dal/hw_sequencer/hw_sequencer_adjustments.c    |  82 +++++
 .../gpu/drm/amd/dal/include/adjustment_interface.h |   2 +-
 drivers/gpu/drm/amd/dal/include/adjustment_types.h |  28 +-
 drivers/gpu/drm/amd/dal/include/dal_interface.h    |   5 +
 drivers/gpu/drm/amd/dal/include/dal_types.h        |   6 +
 .../drm/amd/dal/include/display_path_interface.h   |   2 +-
 .../gpu/drm/amd/dal/include/hw_adjustment_types.h  |  88 +++++
 .../drm/amd/dal/include/hw_sequencer_interface.h   |  12 +-
 drivers/gpu/drm/amd/dal/interface/dal.c            |  26 ++
 24 files changed, 918 insertions(+), 100 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/dal/display_service/gamma_lut.c
 create mode 100644 drivers/gpu/drm/amd/dal/display_service/gamma_lut.h

diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c
index be25699..8eb16fd 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c
@@ -908,8 +908,10 @@ static bool set_gamma_ramp(
 		dal_grph_gamma_scale_dx(gg, params->surface_pixel_format,
 			gamma_ramp->gamma_ramp_dxgi1.gamma_curve);
 
-	/* 2. Do degamma step : remove the given gamma value from FB. */
-	/*For FP16 or no degamma do by pass */
+	/*
+	 * 2. Do degamma step : remove the given gamma value from FB.
+	 * For FP16 or no degamma do by pass
+	 */
 	configure_degamma_mode(gg, params, false);
 
 	/* 3. Configure regamma curve without analysis (future task) */
@@ -963,7 +965,9 @@ static bool set_gamma_ramp(
 		program_pwl(gg, params);
 	}
 
-	/* 12. program regamma config */
+	/*
+	 * 12. program regamma config
+	 */
 	configure_regamma_mode(gg, params, false);
 
 	{
diff --git a/drivers/gpu/drm/amd/dal/controller/grph_gamma.c b/drivers/gpu/drm/amd/dal/controller/grph_gamma.c
index 4bdba7c..f41620a 100644
--- a/drivers/gpu/drm/amd/dal/controller/grph_gamma.c
+++ b/drivers/gpu/drm/amd/dal/controller/grph_gamma.c
@@ -1433,6 +1433,9 @@ bool dal_grph_gamma_build_hw_curve_configuration(
 			(i <= 1)) {
 			int32_t j = 0;
 
+			segments = curve_config->segments[region_number];
+			divisor = 1 << segments;
+
 			if (segments == -1) {
 				if (i > 0) {
 					region1 = dal_fixed31_32_shl(
@@ -1469,10 +1472,6 @@ bool dal_grph_gamma_build_hw_curve_configuration(
 					-(i + 1));
 			}
 
-			segments = curve_config->segments[region_number];
-
-			divisor = 1 << segments;
-
 			gamma_curve[region_number].offset = offset;
 			gamma_curve[region_number].segments_num = segments;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/grph_gamma_types.h b/drivers/gpu/drm/amd/dal/controller/grph_gamma_types.h
index b328400..c12d303 100644
--- a/drivers/gpu/drm/amd/dal/controller/grph_gamma_types.h
+++ b/drivers/gpu/drm/amd/dal/controller/grph_gamma_types.h
@@ -103,11 +103,11 @@ enum graphics_gamma_lut {
 
 union gamma_flag {
 	struct {
-		uint32_t CONFIG_IS_CHANGED:1;
-		uint32_t BOTH_PIPE_REQ:1;
-		uint32_t REGAMMA_UPDATE:1;
-		uint32_t GAMMA_UPDATE:1;
-		uint32_t RESERVED:28;
+		uint32_t config_is_changed:1;
+		uint32_t both_pipe_req:1;
+		uint32_t regamma_update:1;
+		uint32_t gamma_update:1;
+		uint32_t reserved:28;
 	} bits;
 	uint32_t u_all;
 };
diff --git a/drivers/gpu/drm/amd/dal/display_path/display_path.c b/drivers/gpu/drm/amd/dal/display_path/display_path.c
index 77c68b5..ca44675 100644
--- a/drivers/gpu/drm/amd/dal/display_path/display_path.c
+++ b/drivers/gpu/drm/amd/dal/display_path/display_path.c
@@ -551,7 +551,8 @@ struct link_service *dal_display_path_get_mst_link_service(
 /* This function is for backward compatibility only (called from many places).
  * (All callers are interested in the "root" controller)
  * TODO: remove it when Planes code is finalised. */
-struct controller *dal_display_path_get_controller(struct display_path *path)
+struct controller *dal_display_path_get_controller(
+		const struct display_path *path)
 {
 	struct display_path_plane *plane_zero =
 			dal_display_path_get_plane_at_index(path, 0);
diff --git a/drivers/gpu/drm/amd/dal/display_service/Makefile b/drivers/gpu/drm/amd/dal/display_service/Makefile
index 6484249..8482bdf 100644
--- a/drivers/gpu/drm/amd/dal/display_service/Makefile
+++ b/drivers/gpu/drm/amd/dal/display_service/Makefile
@@ -7,7 +7,7 @@ DS = display_service.o path_mode_set.o set_mode_params.o \
 	adjustment_container.o ds_dispatch_info_frame.o \
 	ds_dispatch_mode_setting.o ds_dispatch_planes.o ds_translation.o adjustment_api.o \
 	scaler_adj_group.o backlight_adj_group.o single_adj_group.o \
-	gamut_space.o color_temperature.o path_mode_set_with_data.o
+	gamut_space.o color_temperature.o path_mode_set_with_data.o gamma_lut.o
 
 AMD_DAL_DS = $(addprefix $(AMDDALPATH)/display_service/,$(DS))
 
diff --git a/drivers/gpu/drm/amd/dal/display_service/adjustment_types_internal.h b/drivers/gpu/drm/amd/dal/display_service/adjustment_types_internal.h
index 13aa9f5..f8bb5d1 100644
--- a/drivers/gpu/drm/amd/dal/display_service/adjustment_types_internal.h
+++ b/drivers/gpu/drm/amd/dal/display_service/adjustment_types_internal.h
@@ -118,6 +118,16 @@ struct ds_adjustment_scaler {
 	union ds_scaler_flags flags;
 };
 
+struct ds_adjustment_status {
+	uint32_t val;
+	struct {
+		uint32_t	SET_TO_DEFAULT:1;
+		uint32_t	SET_FROM_EXTERNAL:1;
+		uint32_t	SET_TO_HARDWARE:1;
+		uint32_t	RESERVED:29;
+	} bits;
+};
+
 enum ds_underscan_type {
 	DS_UNDERSCAN_TYPE_PERCENT,
 	DS_UNDERSCAN_TYPE_DIMENTIONS,
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch.h b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch.h
index fc1cf96..fb0d7bb 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch.h
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch.h
@@ -102,6 +102,7 @@ struct ds_dispatch {
 	struct backlight_adj_group *backlight_adj;
 	struct single_adj_group *single_adj;
 	struct grph_colors_group *grph_colors_adj;
+	struct grph_gamma_lut_group *grph_gamma_adj;
 };
 
 
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c
index 0cf4810..5a7df82 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c
@@ -42,40 +42,30 @@
 #include "single_adj_group.h"
 #include "grph_colors_group.h"
 #include "gamut_space.h"
+#include "gamma_lut.h"
 #include "path_mode_set_with_data.h"
 
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL( \
 	LOG_MINOR_COMPONENT_DISPLAY_SERVICE, "Display Service:%s\n", __func__);
 
-static const struct adj_global_info
-	adj_global_info_array[CURRENT_ADJUSTMENT_NUM] = {
-		{ADJ_ID_SATURATION, ADJ_RANGED, {0x140 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
-		{ADJ_ID_BIT_DEPTH_REDUCTION, ADJ_RANGED, {0x14A },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 0 } },
-		{ADJ_ID_UNDERSCAN, ADJ_RANGED, {0x145 },
-			{ 0, 0, 1, 1, 1, 1, 1, 0, 1 } },
-		{ADJ_ID_UNDERSCAN_TYPE, ADJ_RANGED, {0x101 },
-			{ 0, 0, 1, 0, 1, 0, 0, 0, 1 } },
-		{ADJ_ID_BACKLIGHT, ADJ_RANGED, {0x1a0 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 0 } },
-		{ADJ_ID_CONTRAST, ADJ_RANGED, {0x160 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
-		{ADJ_ID_BRIGHTNESS, ADJ_RANGED, {0x140 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
-		{ADJ_ID_HUE, ADJ_RANGED, {0x140 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
-		{ADJ_ID_TEMPERATURE, ADJ_RANGED, {0x140 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
-		{ADJ_ID_TEMPERATURE_SOURCE, ADJ_RANGED, {0x142 },
-			{ 1, 1, 1, 1, 0, 1, 1, 0, 1 } },
-		{ADJ_ID_NOMINAL_RANGE_RGB_LIMITED, ADJ_RANGED, {0x141 },
-			{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+/* NOTE make sure to update CURRENT_ADJUSTMENT_NUM when updating this array */
+static const struct adj_global_info adj_global_info_array[CURRENT_ADJUSTMENT_NUM] = {
+		{ ADJ_ID_SATURATION,			ADJ_RANGED,	{ 0x140 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_BIT_DEPTH_REDUCTION,		ADJ_RANGED,	{ 0x14A },	{ 1, 1, 1, 1, 1, 1, 1, 0, 0 } },
+		{ ADJ_ID_UNDERSCAN,			ADJ_RANGED,	{ 0x145 },	{ 0, 0, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_UNDERSCAN_TYPE,		ADJ_RANGED,	{ 0x101 },	{ 0, 0, 1, 0, 1, 0, 0, 0, 1 } },
+		{ ADJ_ID_BACKLIGHT,			ADJ_RANGED,	{ 0x1a0 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 0 } },
+		{ ADJ_ID_CONTRAST,			ADJ_RANGED,	{ 0x160 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_BRIGHTNESS,			ADJ_RANGED,	{ 0x140 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_HUE,				ADJ_RANGED,	{ 0x140 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_TEMPERATURE,			ADJ_RANGED,	{ 0x140 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_TEMPERATURE_SOURCE,		ADJ_RANGED,	{ 0x142 },	{ 1, 1, 1, 1, 0, 1, 1, 0, 1 } },
+		{ ADJ_ID_NOMINAL_RANGE_RGB_LIMITED,	ADJ_RANGED,	{ 0x141 },	{ 1, 1, 1, 1, 1, 1, 1, 0, 1 } },
+		{ ADJ_ID_GAMMA_RAMP,			ADJ_LUT,	{ 0x108 },	{ 1, 1, 1, 1, 1, 1, 1, 1, 1 } }
 };
 
-static void build_adj_container_for_path(
-	struct ds_dispatch *ds,
-	struct display_path *display_path);
+static void build_adj_container_for_path(struct ds_dispatch *ds,
+		struct display_path *display_path);
 
 static enum ds_signal_type get_ds_signal_from_display_path(
 	struct ds_dispatch *ds,
@@ -549,13 +539,16 @@ struct adj_container *dal_ds_dispatch_get_adj_container_for_path(
 	return NULL;
 }
 
-bool dal_ds_dispatch_initilize_adjustment(struct ds_dispatch *ds)
+bool dal_ds_dispatch_initialize_adjustment(struct ds_dispatch *ds)
 {
 	uint32_t i;
 	uint32_t num;
+
+	/* TODO unnecesary init_data. can just pass ds */
 	struct backlight_adj_group_init_data backlight_init_data;
 	struct single_adj_group_init_data single_init_data;
-	struct grph_colors_group_init_data grph_init_data;
+	struct grph_colors_group_init_data colors_init_data;
+	struct grph_gamma_lut_group_init_data gamma_init_data;
 
 	ds->disp_path_num = dal_tm_get_num_display_paths(ds->tm, false);
 	num = ds->disp_path_num;
@@ -605,16 +598,25 @@ bool dal_ds_dispatch_initilize_adjustment(struct ds_dispatch *ds)
 		dal_ds_dispatch_cleanup_adjustment(ds);
 		return false;
 	}
-	grph_init_data.ds = ds;
-	grph_init_data.hws = ds->hwss;
-	grph_init_data.dal_context = ds->dal_context;
+	colors_init_data.ds = ds;
+	colors_init_data.hws = ds->hwss;
+	colors_init_data.dal_context = ds->dal_context;
 	ds->grph_colors_adj =
-		dal_grph_colors_group_create(&grph_init_data);
+		dal_grph_colors_group_create(&colors_init_data);
 	if (!ds->grph_colors_adj) {
 		dal_ds_dispatch_cleanup_adjustment(ds);
 		return false;
 	}
 
+	gamma_init_data.ds = ds;
+	gamma_init_data.hws = ds->hwss;
+	gamma_init_data.dal_context = ds->dal_context;
+	ds->grph_gamma_adj = dal_gamma_adj_group_create(&gamma_init_data);
+	if (!ds->grph_gamma_adj) {
+		dal_ds_dispatch_cleanup_adjustment(ds);
+		return false;
+	}
+
 	return true;
 }
 
@@ -640,6 +642,9 @@ void dal_ds_dispatch_cleanup_adjustment(struct ds_dispatch *ds)
 	if (ds->grph_colors_adj != NULL)
 		dal_grph_colors_adj_group_destroy(&ds->grph_colors_adj);
 
+	if (ds->grph_gamma_adj != NULL)
+		dal_grph_gamma_adj_group_destroy(&ds->grph_gamma_adj);
+
 }
 
 bool dal_ds_dispatch_build_post_set_mode_adj(
@@ -776,6 +781,60 @@ enum ds_return dal_ds_dispatch_set_adjustment(
 	return result;
 }
 
+enum ds_return dal_ds_dispatch_set_gamma_adjustment(struct ds_dispatch *ds,
+		uint32_t display_index, enum adjustment_id adjust_id,
+		const struct raw_gamma_ramp *gamma) {
+	struct adj_container *adj_container = NULL;
+	const struct adjustment_info *cont_info = NULL;
+	const struct ds_regamma_lut *regumma_lut = NULL;
+	struct display_path *disp_path;
+	const struct path_mode *disp_path_mode;
+
+	if (ds == NULL)
+		return DS_ERROR;
+
+	disp_path = dal_tm_display_index_to_display_path(
+			ds->tm, display_index);
+
+	disp_path_mode = dal_pms_with_data_get_path_mode_for_display_index(
+				ds->set,
+				display_index);
+
+	if (disp_path == NULL || disp_path_mode == NULL)
+		return DS_ERROR;
+
+	adj_container = dal_ds_dispatch_get_adj_container_for_path(ds,
+			display_index);
+
+	if (adj_container == NULL)
+		return DS_ERROR;
+
+	cont_info = dal_adj_info_set_get_adj_info(&adj_container->adj_info_set,
+			adjust_id);
+
+	if (cont_info == NULL)
+		return DS_ERROR;
+
+	if (disp_path  == NULL || cont_info == NULL ||
+		!is_adjustment_supported(ds, disp_path, adjust_id))
+		return DS_ERROR;
+
+	if (!is_adjustment_supported(ds, disp_path, adjust_id))
+		return DS_ERROR;
+
+	regumma_lut = dal_adj_container_get_regamma(
+			adj_container);
+
+	if (regumma_lut == NULL)
+		return DS_ERROR;
+
+	if (dal_grph_gamma_lut_set_adjustment(ds, disp_path, disp_path_mode,
+			adjust_id, gamma, regumma_lut))
+		return DS_SUCCESS;
+
+	return DS_ERROR;
+}
+
 const struct raw_gamma_ramp *dal_ds_dispatch_get_current_gamma(
 	struct ds_dispatch *ds,
 	uint32_t display_index,
@@ -1043,17 +1102,6 @@ bool dal_ds_dispatch_build_color_control_adj(
 			set);
 }
 
-enum ds_return dal_ds_dispatch_set_gamma_adjustment(
-	struct ds_dispatch *ds,
-	uint32_t display_index,
-	enum adjustment_id ad_id,
-	const struct raw_gamma_ramp *gamma)
-{
-	struct dal_context *dal_context = ds->dal_context;
-	NOT_IMPLEMENTED();
-	return DS_ERROR;
-}
-
 void dal_ds_dispatch_update_adj_container_for_path_with_color_space(
 	struct ds_dispatch *ds,
 	uint32_t display_index,
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
index 384ebba..612067e 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
@@ -1322,7 +1322,7 @@ static bool ds_dispatch_construct(
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
-	if (!dal_ds_dispatch_initilize_adjustment(ds)) {
+	if (!dal_ds_dispatch_initialize_adjustment(ds)) {
 		dal_pms_with_data_destroy(&ds->set);
 		return false;
 	}
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_translation.c b/drivers/gpu/drm/amd/dal/display_service/ds_translation.c
index ed8a551..236337a 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_translation.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_translation.c
@@ -376,7 +376,7 @@ enum ds_color_space dal_ds_translation_color_space_from_hw_color_space(
 	return color_space;
 }
 
-bool dal_ds_traslation_regamma_to_external(
+bool dal_ds_translate_regamma_to_external(
 	const struct ds_regamma_lut *gamma_int,
 	struct ds_regamma_lut *gamma_ext)
 {
@@ -422,7 +422,7 @@ bool dal_ds_traslation_regamma_to_external(
 
 }
 
-bool dal_ds_traslation_regamma_to_internal(
+bool dal_ds_translate_regamma_to_internal(
 	const struct ds_regamma_lut *gamma_ext,
 	struct ds_regamma_lut *gamma_int)
 {
@@ -475,7 +475,46 @@ bool dal_ds_traslation_regamma_to_internal(
 	return true;
 }
 
-bool dal_ds_traslation_internal_gamut_to_external_parameter(
+bool dal_ds_translate_regamma_to_hw(
+		const struct ds_regamma_lut *regumma_lut,
+		struct hw_regamma_lut *regamma_lut_hw)
+{
+	bool ret = true;
+	uint32_t i = 0;
+
+	regamma_lut_hw->flags.bits.gamma_ramp_array =
+			regumma_lut->flags.bits.GAMMA_RAMP_ARRAY;
+	regamma_lut_hw->flags.bits.graphics_degamma_srgb =
+			regumma_lut->flags.bits.GRAPHICS_DEGAMMA_SRGB;
+	regamma_lut_hw->flags.bits.overlay_degamma_srgb  =
+			regumma_lut->flags.bits.OVERLAY_DEGAMMA_SRGB;
+
+	if (regumma_lut->flags.bits.GAMMA_RAMP_ARRAY == 1) {
+		regamma_lut_hw->flags.bits.apply_degamma =
+				regumma_lut->flags.bits.APPLY_DEGAMMA;
+
+		for (i = 0; i < 256 * 3; i++)
+			regamma_lut_hw->gamma.gamma[i] = regumma_lut->gamma.gamma[i];
+	} else {
+		regamma_lut_hw->flags.bits.apply_degamma = 0;
+
+		for (i = 0; i < 3; i++) {
+			regamma_lut_hw->coeff.a0[i] =
+					regumma_lut->coeff.coeff_a0[i];
+			regamma_lut_hw->coeff.a1[i] =
+					regumma_lut->coeff.coeff_a1[i];
+			regamma_lut_hw->coeff.a2[i] =
+					regumma_lut->coeff.coeff_a2[i];
+			regamma_lut_hw->coeff.a3[i] =
+					regumma_lut->coeff.coeff_a3[i];
+			regamma_lut_hw->coeff.gamma[i] =
+					regumma_lut->coeff.gamma[i];
+		}
+	}
+	return ret;
+}
+
+bool dal_ds_translate_internal_gamut_to_external_parameter(
 	const struct gamut_data *gamut,
 	struct ds_gamut_data *data)
 {
@@ -505,7 +544,7 @@ bool dal_ds_traslation_internal_gamut_to_external_parameter(
 	return true;
 }
 
-bool dal_ds_traslation_gamut_reference(
+bool dal_ds_translate_gamut_reference(
 	const struct ds_gamut_reference_data *ref,
 	enum adjustment_id *adj_id)
 {
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_translation.h b/drivers/gpu/drm/amd/dal/display_service/ds_translation.h
index 2d96d47..72fad66 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_translation.h
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_translation.h
@@ -58,7 +58,7 @@ void dal_ds_translation_setup_hw_stereo_mixer_params(
 	const struct crtc_timing *timing,
 	enum view_3d_format view_3d_format);
 
-/*enum hw_pixel_format dal_ds_traslation_hw_pixel_format_from_pixel_format(
+/*enum hw_pixel_format dal_ds_translate_hw_pixel_format_from_pixel_format(
 	const enum pixel_format pf);*/
 
 enum underscan_reason {
@@ -76,19 +76,23 @@ enum hw_color_space dal_ds_translation_hw_color_space_from_color_space(
 enum ds_color_space dal_ds_translation_color_space_from_hw_color_space(
 	enum hw_color_space hw_color_space);
 
-bool dal_ds_traslation_regamma_to_external(
+bool dal_ds_translate_regamma_to_external(
 	const struct ds_regamma_lut *gamma_int,
 	struct ds_regamma_lut *gamma_ext);
 
-bool dal_ds_traslation_regamma_to_internal(
+bool dal_ds_translate_regamma_to_internal(
 	const struct ds_regamma_lut *gamma_ext,
 	struct ds_regamma_lut *gamma_int);
 
-bool dal_ds_traslation_internal_gamut_to_external_parameter(
+bool dal_ds_translate_regamma_to_hw(
+		const struct ds_regamma_lut *regumma_lut,
+		struct hw_regamma_lut *regamma_lut_hw);
+
+bool dal_ds_translate_internal_gamut_to_external_parameter(
 	const struct gamut_data *gamut,
 	struct ds_gamut_data *data);
 
-bool dal_ds_traslation_gamut_reference(
+bool dal_ds_translate_gamut_reference(
 	const struct ds_gamut_reference_data *ref,
 	enum adjustment_id *adj_id);
 
diff --git a/drivers/gpu/drm/amd/dal/display_service/gamma_lut.c b/drivers/gpu/drm/amd/dal/display_service/gamma_lut.c
new file mode 100644
index 0000000..b5b0782
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/display_service/gamma_lut.c
@@ -0,0 +1,392 @@
+/*****************************************************************************\
+ *  Module Name:   GammaLUT.cpp
+ *  Project:       DAL 2012 Rearchitecture
+ *  Device:        EG and later
+ *
+ *  Description:   Implementation of GammaLUT class
+ *
+ *  Copyright (c) 2012 Advanced Micro Devices, Inc. (unpublished)
+ *
+ *  All rights reserved.  This notice is intended as a precaution against
+ *  inadvertent publication and does not imply publication or any waiver
+ *  of confidentiality.  The year included in the foregoing notice is the
+ *  year of creation of the work.
+ *
+ \*****************************************************************************/
+
+#include "dal_services.h"
+#include "display_service/ds_dispatch.h"
+#include "display_service/ds_translation.h"
+#include "display_service/grph_colors_group.h"
+#include "include/hw_sequencer_interface.h"
+#include "include/display_path_interface.h"
+#include "include/adjustment_interface.h"
+#include "gamma_lut.h"
+
+static bool grph_gamma_lut_group_construct(
+		struct grph_gamma_lut_group *grph_gamma_adj,
+		struct grph_gamma_lut_group_init_data *init_data) {
+	if (!init_data)
+		return false;
+
+	grph_gamma_adj->ds = init_data->ds;
+	grph_gamma_adj->hws = init_data->hws;
+	grph_gamma_adj->dal_context = init_data->dal_context;
+
+	return true;
+}
+
+struct grph_gamma_lut_group *dal_gamma_adj_group_create(
+		struct grph_gamma_lut_group_init_data *init_data) {
+	struct grph_gamma_lut_group *grph_gamma_adj = NULL;
+
+	grph_gamma_adj = dal_alloc(sizeof(*grph_gamma_adj));
+
+	if (!grph_gamma_adj)
+		return NULL;
+
+	if (grph_gamma_lut_group_construct(grph_gamma_adj, init_data))
+		return grph_gamma_adj;
+
+	dal_free(grph_gamma_adj);
+
+	return NULL;
+}
+
+static bool update_internal_status(
+		struct ds_dispatch *ds,
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma)
+{
+	bool ret = false;
+	struct ds_adjustment_status *status = NULL;
+
+	if (ds == NULL)
+		return ret;
+
+	switch (adj_id) {
+	case ADJ_ID_GAMMA_RAMP:
+		status = &ds->grph_gamma_adj->status_gamma_ramp;
+		break;
+	case ADJ_ID_DRIVER_REQUESTED_GAMMA:
+	default:
+		break;
+	}
+
+	if (status != NULL) {
+		status->bits.SET_TO_HARDWARE = 1;
+		ret = true;
+	}
+
+	return ret;
+}
+
+enum ds_return dal_grph_gamma_lut_set_adjustment(
+		struct ds_dispatch *ds,
+		const struct display_path *disp_path,
+		const struct path_mode *disp_path_mode,
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma,
+		const struct ds_regamma_lut *regumma_lut) {
+
+	enum ds_return ret = DS_ERROR;
+	struct hw_adjustment_gamma_ramp *hw_gamma_ramp = NULL;
+
+	if (gamma == NULL)
+		return ret;
+
+	if (ds == NULL)
+		return ret;
+
+	do {
+		/* TODO validate to compare if this gamma is already set! */
+		if (disp_path == NULL)
+			break;
+
+		if (!dal_gamma_lut_validate(adj_id, gamma, true))
+			break;
+
+		hw_gamma_ramp = dal_alloc(
+			sizeof(struct hw_adjustment_gamma_ramp));
+
+		if (hw_gamma_ramp == NULL)
+			break;
+
+		if (adj_id == ADJ_ID_GAMMA_RAMP)
+			dal_gamma_lut_set_current_gamma(
+				ds,
+				ADJ_ID_DRIVER_REQUESTED_GAMMA,
+				gamma);
+
+		dal_ds_translate_regamma_to_hw(
+				regumma_lut,
+				&hw_gamma_ramp->regamma);
+
+		if (!dal_gamma_lut_translate_to_hw(
+				ds, disp_path_mode,
+				disp_path,
+				gamma,
+				hw_gamma_ramp))
+			break;
+
+		hw_gamma_ramp->flag.uint = 0;
+		hw_gamma_ramp->flag.bits.config_is_changed = 0;
+
+		if (adj_id == ADJ_ID_GAMMA_RAMP_REGAMMA_UPDATE)
+			hw_gamma_ramp->flag.bits.regamma_update = 1;
+		else
+			hw_gamma_ramp->flag.bits.gamma_update = 1;
+
+		if (dal_hw_sequencer_set_gamma_ramp_adjustment(
+				ds->hwss,
+				disp_path,
+				hw_gamma_ramp) != HWSS_RESULT_OK)
+			break;
+
+		if (adj_id == ADJ_ID_GAMMA_RAMP) {
+			dal_gamma_lut_set_current_gamma(ds, adj_id, gamma);
+			update_internal_status(ds, adj_id, gamma);
+		}
+
+		ret = DS_SUCCESS;
+
+	} while (0);
+
+	dal_free(hw_gamma_ramp);
+	return ret;
+}
+
+bool dal_gamma_lut_validate(
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma,
+		bool validate_all) {
+	if (adj_id != ADJ_ID_DRIVER_REQUESTED_GAMMA
+			&& adj_id != ADJ_ID_GAMMA_RAMP
+			&& adj_id != ADJ_ID_GAMMA_RAMP_REGAMMA_UPDATE)
+		return false;
+
+	if (!validate_all)
+		return true;
+
+	if (gamma == NULL)
+		return false;
+
+	if (gamma->type != GAMMA_RAMP_TYPE_RGB256
+			&& gamma->type != GAMMA_RAMP_TYPE_FIXED_POINT)
+		return false;
+
+	if (gamma->type == GAMMA_RAMP_TYPE_RGB256
+			&& gamma->size != sizeof(gamma->rgb_256))
+		return false;
+
+	return true;
+}
+
+bool dal_gamma_lut_translate_to_hw(
+		struct ds_dispatch *ds,
+		const struct path_mode *disp_path_mode,
+		const struct display_path *disp_path,
+		const struct raw_gamma_ramp *gamma_in,
+		struct hw_adjustment_gamma_ramp *gamma_out) {
+	unsigned int i;
+	enum pixel_format pix_format = disp_path_mode->pixel_format;
+	enum ds_color_space color_space = DS_COLOR_SPACE_UNKNOWN;
+
+	uint32_t display_index;
+	struct adj_container *adj_container = NULL;
+
+	if (!disp_path)
+		return false;
+
+	display_index = dal_display_path_get_display_index(disp_path);
+
+	adj_container = dal_ds_dispatch_get_adj_container_for_path(ds,
+		display_index);
+
+	if (gamma_in == NULL)
+		return false;
+
+	/* translate the PixelFormat */
+	gamma_out->surface_pixel_format = pix_format;
+
+	if (gamma_in->type != GAMMA_RAMP_TYPE_RGB256)
+		return false;
+
+	gamma_out->type = HW_GAMMA_RAMP_RBG_256x3x16;
+	gamma_out->size = sizeof(gamma_out->gamma_ramp_rgb256x3x16);
+
+	/* copy the rgb */
+	for (i = 0; i < NUM_OF_RAW_GAMMA_RAMP_RGB_256; i++) {
+		gamma_out->gamma_ramp_rgb256x3x16.red[i] =
+				(unsigned short) (gamma_in->rgb_256[i].red);
+		gamma_out->gamma_ramp_rgb256x3x16.green[i] =
+				(unsigned short) (gamma_in->rgb_256[i].green);
+		gamma_out->gamma_ramp_rgb256x3x16.blue[i] =
+				(unsigned short) (gamma_in->rgb_256[i].blue);
+	}
+
+	/*
+	 * logic below builds the color space and it is used for color
+	 * adjustments also
+	 */
+	color_space = dal_grph_colors_group_get_color_space(
+			ds->grph_colors_adj,
+			&disp_path_mode->mode_timing->crtc_timing,
+			disp_path,
+			adj_container);
+
+	gamma_out->color_space =
+		dal_ds_translation_hw_color_space_from_color_space(color_space);
+
+	return true;
+}
+
+static bool get_parameters(
+		struct ds_dispatch *ds,
+		enum adjustment_id adj_id,
+		struct ds_adjustment_status **adjustment_status,
+		struct raw_gamma_ramp **gamma)
+{
+	struct ds_adjustment_status *status = NULL;
+	struct raw_gamma_ramp *ramp = NULL;
+
+	if (ds == NULL)
+		return false;
+
+	if (ds->grph_gamma_adj == NULL)
+		return false;
+
+	switch (adj_id) {
+	case ADJ_ID_GAMMA_RAMP:
+		status = &ds->grph_gamma_adj->status_gamma_ramp;
+		ramp = &ds->grph_gamma_adj->gamma_ramp;
+		break;
+	case ADJ_ID_DRIVER_REQUESTED_GAMMA:
+		status = &ds->grph_gamma_adj->status_original_ramp;
+		ramp = &ds->grph_gamma_adj->oroginal_ramp;
+		break;
+
+	default:
+		break;
+	}
+
+	if (status != NULL && gamma != NULL) {
+		if (adjustment_status != NULL)
+			*adjustment_status = status;
+
+		if (gamma != NULL)
+			*gamma = ramp;
+
+		return true;
+	}
+
+	return false;
+}
+
+static bool generated_default_gamma_ramp(
+		struct ds_dispatch *ds,
+		enum adjustment_id adj_id)
+{
+	bool ret = false;
+	unsigned int i;
+
+	struct raw_gamma_ramp_rgb *rgb256 = NULL;
+	struct ds_adjustment_status *status = NULL;
+	struct raw_gamma_ramp *gamma = NULL;
+
+	if (ds == NULL)
+		return false;
+
+	switch (adj_id) {
+	case ADJ_ID_GAMMA_RAMP:
+		gamma = &ds->grph_gamma_adj->gamma_ramp;
+		status = &ds->grph_gamma_adj->status_gamma_ramp;
+		rgb256 = ds->grph_gamma_adj->gamma_ramp.rgb_256;
+		ret = true;
+		break;
+	case ADJ_ID_DRIVER_REQUESTED_GAMMA:
+		gamma = &ds->grph_gamma_adj->oroginal_ramp;
+		status = &ds->grph_gamma_adj->status_original_ramp;
+		rgb256 = ds->grph_gamma_adj->oroginal_ramp.rgb_256;
+		ret = true;
+		break;
+	default:
+		break;
+	}
+
+	if (ret) {
+		for (i = 0; i < NUM_OF_RAW_GAMMA_RAMP_RGB_256; ++i) {
+			rgb256[i].red = i << 8;
+			rgb256[i].green = i << 8;
+			rgb256[i].blue = i << 8;
+		}
+		status->val = 0;
+		status->bits.SET_TO_DEFAULT = 1;
+		gamma->type = GAMMA_RAMP_TYPE_RGB256;
+		gamma->size = sizeof(struct raw_gamma_ramp_rgb)
+				* NUM_OF_RAW_GAMMA_RAMP_RGB_256;
+	}
+	return ret;
+}
+
+const struct raw_gamma_ramp *dal_gamma_lut_get_current_gamma(
+		struct ds_dispatch *ds,
+		enum adjustment_id adj_id) {
+	struct ds_adjustment_status *adjustment_status = NULL;
+	struct raw_gamma_ramp *gamma = NULL;
+
+	if (ds == NULL)
+		return NULL;
+
+	if (!dal_gamma_lut_validate(adj_id, gamma, false))
+		return NULL;
+
+	if (get_parameters(ds, adj_id, &adjustment_status, &gamma))
+		return gamma;
+
+	if (adjustment_status->bits.SET_FROM_EXTERNAL == 0)
+		if (generated_default_gamma_ramp(ds, adj_id))
+			return gamma;
+
+	return gamma;
+}
+
+bool dal_gamma_lut_set_current_gamma(struct ds_dispatch *ds,
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma)
+{
+	struct ds_adjustment_status *adjustment_status = NULL;
+	struct raw_gamma_ramp *ramp = NULL;
+
+	if (!dal_gamma_lut_validate(adj_id, gamma, true))
+		return false;
+
+	if (!get_parameters(ds, adj_id, &adjustment_status, &ramp))
+		return false;
+
+	dal_memmove(ramp, gamma, sizeof(struct raw_gamma_ramp));
+
+	/* new external gamma was set , reset to 0 default flag */
+	adjustment_status->bits.SET_TO_DEFAULT = 0;
+	/* new external gamma was set , raise this flag */
+	adjustment_status->bits.SET_FROM_EXTERNAL = 1;
+	/* new external gamma was set , raise this flag */
+	adjustment_status->bits.SET_TO_HARDWARE = 0;
+
+	return true;
+
+}
+static void destruct(struct grph_gamma_lut_group *gamma_adj)
+{
+}
+
+void dal_grph_gamma_adj_group_destroy(
+		struct grph_gamma_lut_group **grph_gamma_adj) {
+	if (grph_gamma_adj == NULL || *grph_gamma_adj == NULL)
+		return;
+
+	destruct(*grph_gamma_adj);
+	dal_free(*grph_gamma_adj);
+	*grph_gamma_adj = NULL;
+}
+
diff --git a/drivers/gpu/drm/amd/dal/display_service/gamma_lut.h b/drivers/gpu/drm/amd/dal/display_service/gamma_lut.h
new file mode 100644
index 0000000..2c050c9
--- /dev/null
+++ b/drivers/gpu/drm/amd/dal/display_service/gamma_lut.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2014 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DAL_GAMMA_LUT_H__
+#define __DAL_GAMMA_LUT_H__
+
+#include "adjustment_types_internal.h"
+#include "include/display_service_types.h"
+
+struct ds_dispatch;
+struct grph_colors_group;
+struct crtc_timing;
+struct display_path;
+struct adj_container;
+
+struct grph_gamma_lut_group {
+	struct ds_dispatch *ds;
+	struct hw_sequencer *hws;
+	struct dal_context *dal_context;
+	struct ds_adjustment_status status_gamma_ramp;
+	struct ds_adjustment_status status_original_ramp;
+	struct raw_gamma_ramp gamma_ramp;
+	struct raw_gamma_ramp oroginal_ramp;
+};
+
+struct grph_gamma_lut_group_init_data {
+	struct ds_dispatch *ds;
+	struct hw_sequencer *hws;
+	struct dal_context *dal_context;
+};
+
+struct grph_gamma_lut_group *dal_gamma_adj_group_create(
+	struct grph_gamma_lut_group_init_data *init_data);
+
+void dal_grph_gamma_adj_group_destroy(
+	struct grph_gamma_lut_group **grph_gamma_adj);
+
+
+enum ds_return dal_grph_gamma_lut_set_adjustment(
+		struct ds_dispatch *ds,
+		const struct display_path *disp_path,
+		const struct path_mode *disp_path_mode,
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma,
+		const struct ds_regamma_lut *regumma_lut);
+
+bool dal_gamma_lut_validate(
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma,
+		bool validate_all);
+
+bool dal_gamma_lut_translate_to_hw(
+		struct ds_dispatch *ds,
+		const struct path_mode *disp_path_mode,
+		const struct display_path *disp_path,
+		const struct raw_gamma_ramp *gamma_in,
+		struct hw_adjustment_gamma_ramp *gamma_out);
+
+const struct raw_gamma_ramp *dal_gamma_lut_get_current_gamma(
+		struct ds_dispatch *ds,
+		enum adjustment_id adj_id);
+
+bool dal_gamma_lut_set_current_gamma(struct ds_dispatch *ds,
+		enum adjustment_id adj_id,
+		const struct raw_gamma_ramp *gamma);
+
+#endif /* __DAL_GAMMA_LUT_H__ */
diff --git a/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c b/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c
index 754b9c8..7e39bcb 100644
--- a/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c
+++ b/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c
@@ -941,7 +941,7 @@ enum ds_return dal_grph_colors_group_get_color_gamut(
 		return DS_ERROR;
 
 	dal_memset(&gamut_data, 0, sizeof(gamut_data));
-	if (!dal_ds_traslation_gamut_reference(
+	if (!dal_ds_translate_gamut_reference(
 			ref, &adj_id))
 		return DS_ERROR;
 
@@ -1029,7 +1029,7 @@ enum ds_return dal_grph_colors_group_get_color_gamut(
 				adj_id,
 				&gamut_data))
 			return DS_ERROR;
-	if (!dal_ds_traslation_internal_gamut_to_external_parameter(
+	if (!dal_ds_translate_internal_gamut_to_external_parameter(
 			&gamut_data,
 			&data->gamut))
 		return DS_ERROR;
@@ -1085,7 +1085,7 @@ enum ds_return dal_grph_colors_group_get_regamma_lut(
 	if (!regamma)
 		return DS_ERROR;
 
-	dal_ds_traslation_regamma_to_external(regamma, data);
+	dal_ds_translate_regamma_to_external(regamma, data);
 	return DS_SUCCESS;
 }
 
@@ -1142,7 +1142,7 @@ enum ds_return dal_grph_colors_group_set_regamma_lut(
 
 	dal_memmove(regamma, old_regamma, sizeof(*regamma));
 
-	if (!dal_ds_traslation_regamma_to_internal(
+	if (!dal_ds_translate_regamma_to_internal(
 			data, regamma))
 		goto regamma_copy_fail;
 
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
index 024052a..f6e0d9b 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
@@ -1531,15 +1531,41 @@ enum hwss_result dal_hw_sequencer_validate_display_path_mode(
 	return HWSS_RESULT_OK;
 }
 
-
-
 enum hwss_result dal_hw_sequencer_set_gamma_ramp_adjustment(
 	struct hw_sequencer *hws,
-	struct display_path *display_path,
+	const struct display_path *display_path,
 	struct hw_adjustment_gamma_ramp *adjusment)
 {
-	/* TODO: add implementation */
-	return HWSS_RESULT_ERROR;
+	struct gamma_ramp *ramp = NULL;
+	struct gamma_parameters *gamma_param = NULL;
+	enum hwss_result result = HWSS_RESULT_OK;
+	struct controller *crtc;
+
+	crtc = dal_display_path_get_controller(display_path);
+
+	if (crtc == NULL)
+		return HWSS_RESULT_ERROR;
+
+	if (adjusment == NULL)
+		return HWSS_RESULT_ERROR;
+
+	ramp = dal_alloc(sizeof(struct gamma_ramp));
+	gamma_param = dal_alloc(sizeof(struct gamma_parameters));
+
+	if (ramp && gamma_param) {
+		dal_hw_sequencer_build_gamma_ramp_adj_params(
+				adjusment,
+				gamma_param,
+				ramp);
+
+		if (!dal_controller_set_gamma_ramp(crtc, ramp, gamma_param))
+			result = HWSS_RESULT_ERROR;
+	}
+
+	dal_free(ramp);
+	dal_free(gamma_param);
+
+	return HWSS_RESULT_OK;
 }
 
 enum hwss_result dal_hw_sequencer_set_color_control_adjustment(
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
index e85e2ae..0369ef3 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
@@ -471,3 +471,85 @@ enum hwss_result dal_hw_sequencer_build_csc_adjust(
 	return HWSS_RESULT_OK;
 
 }
+
+void dal_hw_sequencer_build_gamma_ramp_adj_params(
+		const struct hw_adjustment_gamma_ramp *adjustment,
+		struct gamma_parameters *gamma_param,
+		struct gamma_ramp *ramp) {
+	ramp->type = GAMMA_RAMP_DEFAULT;
+	ramp->size = adjustment->size;
+
+	switch (adjustment->type) {
+	case HW_GAMMA_RAMP_UNITIALIZED:
+		ramp->type = GAMMA_RAMP_UNINITIALIZED;
+		break;
+	case HW_GAMMA_RAMP_DEFAULT:
+		ramp->type = GAMMA_RAMP_DEFAULT;
+		break;
+	case HW_GAMMA_RAMP_RBG_256x3x16:
+		ramp->type = GAMMA_RAMP_RBG256X3X16;
+		dal_memmove(&ramp->gamma_ramp_rgb256x3x16,
+			&adjustment->gamma_ramp_rgb256x3x16,
+			adjustment->size);
+		break;
+	default:
+		break;
+	}
+	/* translate parameters */
+	gamma_param->surface_pixel_format = adjustment->surface_pixel_format;
+
+	translate_from_hw_to_controller_regamma(
+			&adjustment->regamma,
+			&gamma_param->regamma);
+
+	gamma_param->regamma_adjust_type = GRAPHICS_REGAMMA_ADJUST_SW;
+	gamma_param->degamma_adjust_type = GRAPHICS_REGAMMA_ADJUST_SW;
+
+	gamma_param->selected_gamma_lut = GRAPHICS_GAMMA_LUT_LEGACY;
+
+	/* TODO support non-legacy gamma */
+
+	gamma_param->disable_adjustments = false;
+	gamma_param->flag.bits.config_is_changed =
+			adjustment->flag.bits.config_is_changed;
+	gamma_param->flag.bits.regamma_update =
+			adjustment->flag.bits.regamma_update;
+	gamma_param->flag.bits.gamma_update =
+			adjustment->flag.bits.gamma_update;
+}
+
+void translate_from_hw_to_controller_regamma(
+		const struct hw_regamma_lut *hw_regamma,
+		struct regamma_lut *regamma)
+{
+	unsigned int i;
+
+	regamma->features.bits.GRAPHICS_DEGAMMA_SRGB =
+			hw_regamma->flags.bits.graphics_degamma_srgb;
+	regamma->features.bits.OVERLAY_DEGAMMA_SRGB =
+			hw_regamma->flags.bits.overlay_degamma_srgb;
+	regamma->features.bits.GAMMA_RAMP_ARRAY =
+			hw_regamma->flags.bits.gamma_ramp_array;
+
+	if (hw_regamma->flags.bits.gamma_ramp_array == 1) {
+		regamma->features.bits.APPLY_DEGAMMA =
+				hw_regamma->flags.bits.apply_degamma;
+
+		for (i = 0; i < 256 * 3; i++)
+			regamma->regamma_ramp.gamma[i] =
+					hw_regamma->gamma.gamma[i];
+
+	} else {
+		regamma->features.bits.APPLY_DEGAMMA = 0;
+
+		for (i = 0; i < 3; i++) {
+			regamma->gamma_coeff.a0[i] = hw_regamma->coeff.a0[i];
+			regamma->gamma_coeff.a1[i] = hw_regamma->coeff.a1[i];
+			regamma->gamma_coeff.a2[i] = hw_regamma->coeff.a2[i];
+			regamma->gamma_coeff.a3[i] = hw_regamma->coeff.a3[i];
+			regamma->gamma_coeff.gamma[i] =
+					hw_regamma->coeff.gamma[i];
+		}
+	}
+
+}
diff --git a/drivers/gpu/drm/amd/dal/include/adjustment_interface.h b/drivers/gpu/drm/amd/dal/include/adjustment_interface.h
index e32b2d2..7dabbb3 100644
--- a/drivers/gpu/drm/amd/dal/include/adjustment_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/adjustment_interface.h
@@ -165,7 +165,7 @@ enum ds_return dal_ds_dispatch_get_info_packets(
 	uint32_t display_index,
 	struct info_frame *info_frames);
 
-bool dal_ds_dispatch_initilize_adjustment(struct ds_dispatch *ds);
+bool dal_ds_dispatch_initialize_adjustment(struct ds_dispatch *ds);
 
 void dal_ds_dispatch_cleanup_adjustment(struct ds_dispatch *ds);
 
diff --git a/drivers/gpu/drm/amd/dal/include/adjustment_types.h b/drivers/gpu/drm/amd/dal/include/adjustment_types.h
index 67a5daf..54a18a2 100644
--- a/drivers/gpu/drm/amd/dal/include/adjustment_types.h
+++ b/drivers/gpu/drm/amd/dal/include/adjustment_types.h
@@ -26,7 +26,8 @@
 #ifndef __DAL_ADJUSTMENT_TYPES_H__
 #define __DAL_ADJUSTMENT_TYPES_H__
 
-#define CURRENT_ADJUSTMENT_NUM 11
+/* make sure to update this when updating adj_global_info_array */
+#define CURRENT_ADJUSTMENT_NUM 12
 #define MAX_ADJUSTMENT_NUM (ADJ_ID_END - ADJ_ID_BEGIN)
 #define REGAMMA_VALUE	256
 #define REGAMMA_RANGE	(REGAMMA_VALUE*3)
@@ -193,27 +194,10 @@ struct raw_gamma_ramp_rgb {
 	uint32_t blue;
 };
 
-/*struct raw_rgb_float {
-	float red;
-	float green;
-	float blue;
-};
-
-#define NUM_OF_RAW_GAMMA_RAMP_FLOAT_1025 = 1025;
-struct raw_gamma_ramp_float {
-	struct raw_rgb_float scale;
-	struct raw_rgb_float offset;
-	struct raw_rgb_float gamma_curve[NUM_OF_RAW_GAMMA_RAMP_FLOAT_1025];
-};
-*/
 #define NUM_OF_RAW_GAMMA_RAMP_RGB_256 256
 struct raw_gamma_ramp {
 	enum raw_gamma_ramp_type type;
-	union {
-		struct raw_gamma_ramp_rgb
-			rgb_256[NUM_OF_RAW_GAMMA_RAMP_RGB_256];
-		/*struct raw_rgb_float rgb_float;*/
-	};
+	struct raw_gamma_ramp_rgb rgb_256[NUM_OF_RAW_GAMMA_RAMP_RGB_256];
 	uint32_t size;
 };
 
@@ -372,10 +356,14 @@ union ds_regamma_flags {
 		uint32_t COEFF_FROM_USER:1;
 		/*coeff. A0-A3 from edid is in use only for Display Id 1.2*/
 		uint32_t COEFF_FROM_EDID:1;
+		/*which ROM to choose for graphics*/
+		uint32_t GRAPHICS_DEGAMMA_SRGB:1;
+		/*which ROM to choose for video overlay*/
+		uint32_t OVERLAY_DEGAMMA_SRGB:1;
 		/*apply degamma removal in driver*/
 		uint32_t APPLY_DEGAMMA:1;
 
-		uint32_t reserved:25;
+		uint32_t reserved:23;
 	} bits;
 };
 
diff --git a/drivers/gpu/drm/amd/dal/include/dal_interface.h b/drivers/gpu/drm/amd/dal/include/dal_interface.h
index a2253be..3521c6c 100644
--- a/drivers/gpu/drm/amd/dal/include/dal_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/dal_interface.h
@@ -149,6 +149,11 @@ void  dal_set_palette(
 	uint32_t start,
 	uint32_t length);
 
+bool  dal_set_gamma(
+	struct dal *dal,
+	uint32_t display_index,
+	struct raw_gamma_ramp *gamma);
+
 /* Active Stereo Interface */
 bool dal_control_stereo(struct dal *dal, uint32_t display_index, bool enable);
 
diff --git a/drivers/gpu/drm/amd/dal/include/dal_types.h b/drivers/gpu/drm/amd/dal/include/dal_types.h
index 4611872..c4c032b 100644
--- a/drivers/gpu/drm/amd/dal/include/dal_types.h
+++ b/drivers/gpu/drm/amd/dal/include/dal_types.h
@@ -176,6 +176,12 @@ struct dal_dev_c_lut {
 	uint8_t reserved;
 };
 
+struct dal_dev_gamma_lut {
+	uint16_t red;
+	uint16_t green;
+	uint16_t blue;
+};
+
 #if defined(BUILD_DAL_TEST)
 struct test_driver_context;
 #endif /* BUILD_DAL_TEST */
diff --git a/drivers/gpu/drm/amd/dal/include/display_path_interface.h b/drivers/gpu/drm/amd/dal/include/display_path_interface.h
index f0db352..73a984c 100644
--- a/drivers/gpu/drm/amd/dal/include/display_path_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/display_path_interface.h
@@ -165,7 +165,7 @@ void dal_display_path_set_controller(
 	struct controller *controller);
 
 struct controller *dal_display_path_get_controller(
-	struct display_path *path);
+	const struct display_path *path);
 
 void dal_display_path_set_clock_source(
 	struct display_path *path,
diff --git a/drivers/gpu/drm/amd/dal/include/hw_adjustment_types.h b/drivers/gpu/drm/amd/dal/include/hw_adjustment_types.h
index 98502b4..442566e 100644
--- a/drivers/gpu/drm/amd/dal/include/hw_adjustment_types.h
+++ b/drivers/gpu/drm/amd/dal/include/hw_adjustment_types.h
@@ -114,4 +114,92 @@ enum hw_surface_type {
 	HW_GRAPHIC_SURFACE
 };
 
+/* LUT type for GammaCorrection */
+struct hw_gamma_lut {
+	uint32_t red;
+	uint32_t green;
+	uint32_t blue;
+};
+
+struct hw_devc_lut {
+	uint8_t red;
+	uint8_t green;
+	uint8_t blue;
+	uint8_t reserved;
+};
+
+struct hw_adjustment_gamma_lut {
+	struct hw_gamma_lut *pGammaLut;
+	uint32_t size_in_elements;
+	enum pixel_format surface_pixel_format;
+};
+
+
+enum hw_gamma_ramp_type {
+	HW_GAMMA_RAMP_UNITIALIZED = 0,
+	HW_GAMMA_RAMP_DEFAULT,
+	HW_GAMMA_RAMP_RBG_256x3x16,
+	HW_GAMMA_RAMP_RBG_DXGI_1
+};
+
+#define HW_GAMMA_RAMP_RBG_256 256
+
+struct hw_gamma_ramp_rgb256x3x16 {
+	unsigned short red[HW_GAMMA_RAMP_RBG_256];
+	unsigned short green[HW_GAMMA_RAMP_RBG_256];
+	unsigned short blue[HW_GAMMA_RAMP_RBG_256];
+};
+
+union hw_gamma_flags {
+	uint32_t raw;
+	struct {
+		uint32_t gamma_ramp_array :1;
+		uint32_t graphics_degamma_srgb :1;
+		uint32_t overlay_degamma_srgb :1;
+		uint32_t apply_degamma :1;
+		uint32_t reserved :28;
+	} bits;
+};
+
+struct hw_regamma_coefficients {
+	int32_t gamma[3];
+	int32_t a0[3];
+	int32_t a1[3];
+	int32_t a2[3];
+	int32_t a3[3];
+};
+
+struct hw_regamma_ramp {
+	/* Gamma ramp packed as RGB */
+	unsigned short gamma[256 * 3];
+};
+
+struct hw_regamma_lut {
+	union hw_gamma_flags flags;
+	union {
+		struct hw_regamma_ramp gamma;
+		struct hw_regamma_coefficients coeff;
+	};
+};
+
+union hw_gamma_flag {
+	uint32_t uint;
+	struct {
+		uint32_t config_is_changed :1;
+		uint32_t regamma_update :1;
+		uint32_t gamma_update :1;
+		uint32_t reserved :29;
+	} bits;
+};
+
+struct hw_adjustment_gamma_ramp {
+	uint32_t size;
+	enum hw_gamma_ramp_type type;
+	enum pixel_format surface_pixel_format;
+	enum hw_color_space color_space;
+	struct hw_regamma_lut regamma;
+	union hw_gamma_flag flag;
+	struct hw_gamma_ramp_rgb256x3x16 gamma_ramp_rgb256x3x16;
+};
+
 #endif
diff --git a/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h b/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h
index 42dbd4b..1881654 100644
--- a/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h
@@ -32,6 +32,7 @@
 #include "include/display_clock_interface.h"
 #include "include/scaler_types.h"
 #include "include/grph_csc_types.h"
+#include "controller/grph_gamma_types.h"
 #include "plane_types.h"
 
 #include "adapter_service_interface.h"
@@ -179,7 +180,7 @@ struct hw_adjustment_gamma_ramp;
 
 enum hwss_result dal_hw_sequencer_set_gamma_ramp_adjustment(
 	struct hw_sequencer *hws,
-	struct display_path *display_path,
+	const struct display_path *display_path,
 	struct hw_adjustment_gamma_ramp *adjusment);
 
 enum hwss_result dal_hw_sequencer_set_color_control_adjustment(
@@ -346,6 +347,15 @@ enum hwss_result dal_hw_sequencer_build_csc_adjust(
 	struct hw_adjustment_color_control *color_control,
 	struct grph_csc_adjustment *adjust);
 
+void dal_hw_sequencer_build_gamma_ramp_adj_params(
+		const struct hw_adjustment_gamma_ramp *adjusment,
+		struct gamma_parameters *gamma_param,
+		struct gamma_ramp *ramp);
+
+void translate_from_hw_to_controller_regamma(
+		const struct hw_regamma_lut *hw_regamma,
+		struct regamma_lut *regamma);
+
 void dal_hw_sequencer_enable_wireless_idle_detection(
 		struct hw_sequencer *hws,
 		bool enable);
diff --git a/drivers/gpu/drm/amd/dal/interface/dal.c b/drivers/gpu/drm/amd/dal/interface/dal.c
index ac57ef0..8f89ed0 100644
--- a/drivers/gpu/drm/amd/dal/interface/dal.c
+++ b/drivers/gpu/drm/amd/dal/interface/dal.c
@@ -909,6 +909,32 @@ void dal_set_palette(struct dal *dal,
 	/* TODO */
 }
 
+bool dal_set_gamma(
+	struct dal *dal,
+	uint32_t display_index,
+	struct raw_gamma_ramp *gamma)
+{
+	enum ds_return result;
+	struct dal_context *dal_context = &dal->dal_context;
+	struct ds_dispatch *ds_dispatch =
+		dal_display_service_get_adjustment_interface(
+			dal->display_service);
+
+	if (NULL == ds_dispatch) {
+		DAL_IF_ERROR("%s: Display Service is NULL!\n",
+				__func__);
+		return false;
+	}
+
+	result = dal_ds_dispatch_set_gamma_adjustment(
+			ds_dispatch,
+			display_index,
+			ADJ_ID_GAMMA_RAMP,
+			gamma);
+
+	return result == DS_SUCCESS;
+}
+
 /* Active Stereo Interface */
 bool dal_control_stereo(struct dal *dal,
 		uint32_t display_index,
-- 
1.9.1

