From b2c842f0295823948f4049a5f7c6dd55a6da4ef7 Mon Sep 17 00:00:00 2001
From: Amy Zhang <Amy.Zhang@amd.com>
Date: Fri, 22 Jul 2016 14:25:17 -0400
Subject: [PATCH 0665/1722] drm/amd/dal: Brightness/contrast/hue/sat adjustment

- Implemented escape functions for Radeon Additional Settings
- Moved all matrix calculation into the color module
- Called opp functions to set csc matrix values

Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/dc.h                    |   1 +
 drivers/gpu/drm/amd/dal/dc/dc_types.h              |   5 +
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |  25 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h     |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c | 551 +------------
 .../gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c   | 493 +-----------
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.h   |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h       |   2 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c   | 550 +------------
 drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h            |   7 +-
 drivers/gpu/drm/amd/dal/modules/color/color.c      | 883 ++++++++++++++++++++-
 drivers/gpu/drm/amd/dal/modules/inc/mod_color.h    |  38 +
 12 files changed, 961 insertions(+), 1598 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 5636059..13b8a04 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -376,6 +376,7 @@ struct dc_stream {
 	/* TODO: dithering */
 	/* TODO: transfer function (CSC/regamma/gamut remap) */
 	struct colorspace_transform gamut_remap_matrix;
+	struct csc_transform csc_color_matrix;
 	/* TODO: custom INFO packets */
 	/* TODO: ABM info (DMCU) */
 	/* TODO: PSR info */
diff --git a/drivers/gpu/drm/amd/dal/dc/dc_types.h b/drivers/gpu/drm/amd/dal/dc/dc_types.h
index 8392e67..d84657f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc_types.h
@@ -532,4 +532,9 @@ struct colorspace_transform {
 	bool enable_remap;
 };
 
+struct csc_transform {
+	uint16_t matrix[12];
+	bool enable_adjustment;
+};
+
 #endif /* DC_TYPES_H_ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 85fda4e..28810c5 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -1537,16 +1537,34 @@ static void set_plane_config(
 	struct dc_context *ctx = pipe_ctx->stream->ctx;
 	struct core_surface *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
+	struct out_csc_color_matrix tbl_entry;
+	unsigned int i;
 
 	if (dc->current_context)
-		old_pipe = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+		old_pipe =
+			&dc->current_context->
+			res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 
 	memset(&adjust, 0, sizeof(adjust));
+	memset(&tbl_entry, 0, sizeof(tbl_entry));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
 	dc->hwss.enable_fe_clock(ctx, pipe_ctx->pipe_idx, true);
 
-	set_default_colors(pipe_ctx);
+	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+			== true) {
+		tbl_entry.color_space =
+			pipe_ctx->stream->public.output_color_space;
+
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] =
+			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+
+		pipe_ctx->opp->funcs->opp_set_csc_adjustment
+				(pipe_ctx->opp, &tbl_entry);
+	} else {
+		set_default_colors(pipe_ctx);
+	}
 
 	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
@@ -1606,7 +1624,8 @@ static void set_plane_config(
 				surface->public.rotation);
 }
 
-static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+static void update_plane_addr(const struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx)
 {
 	struct core_surface *surface = pipe_ctx->surface;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
index f388584..2fbb241 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp.h
@@ -116,7 +116,7 @@ void dce110_opp_set_regamma_mode(struct output_pixel_processor *opp,
 
 void dce110_opp_set_csc_adjustment(
 	struct output_pixel_processor *opp,
-	const struct opp_grph_csc_adjustment *adjust);
+	const struct out_csc_color_matrix *tbl_entry);
 
 void dce110_opp_set_csc_default(
 	struct output_pixel_processor *opp,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
index b16d9b0..b46db20 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc.c
@@ -38,11 +38,6 @@ enum {
 	OUTPUT_CSC_MATRIX_SIZE = 12
 };
 
-struct out_csc_color_matrix {
-	enum dc_color_space color_space;
-	uint16_t regval[OUTPUT_CSC_MATRIX_SIZE];
-};
-
 static const struct out_csc_color_matrix global_color_matrix[] = {
 { COLOR_SPACE_SRGB,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
@@ -185,520 +180,6 @@ static void program_color_matrix(
 	}
 }
 
-/*
- * initialize_color_float_adj_reference_values
- * This initialize display color adjust input from API to HW range for later
- * calculation use. This is shared by all the display color adjustment.
- * @param :
- * @return None
- */
-static void initialize_color_float_adj_reference_values(
-	const struct opp_grph_csc_adjustment *adjust,
-	struct fixed31_32 *grph_cont,
-	struct fixed31_32 *grph_sat,
-	struct fixed31_32 *grph_bright,
-	struct fixed31_32 *sin_grph_hue,
-	struct fixed31_32 *cos_grph_hue)
-{
-	/* Hue adjustment could be negative. -45 ~ +45 */
-	struct fixed31_32 hue =
-		dal_fixed31_32_mul(
-			dal_fixed31_32_from_fraction(adjust->grph_hue, 180),
-			dal_fixed31_32_pi);
-
-	*sin_grph_hue = dal_fixed31_32_sin(hue);
-	*cos_grph_hue = dal_fixed31_32_cos(hue);
-
-	if (adjust->adjust_divider) {
-		*grph_cont =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_cont,
-				adjust->adjust_divider);
-		*grph_sat =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_sat,
-				adjust->adjust_divider);
-		*grph_bright =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_bright,
-				adjust->adjust_divider);
-	} else {
-		*grph_cont = dal_fixed31_32_from_int(adjust->grph_cont);
-		*grph_sat = dal_fixed31_32_from_int(adjust->grph_sat);
-		*grph_bright = dal_fixed31_32_from_int(adjust->grph_bright);
-	}
-}
-
-static inline struct fixed31_32 fixed31_32_clamp(
-	struct fixed31_32 value,
-	int32_t min_numerator,
-	int32_t max_numerator,
-	int32_t denominator)
-{
-	return dal_fixed31_32_clamp(
-		value,
-		dal_fixed31_32_from_fraction(
-			min_numerator,
-			denominator),
-		dal_fixed31_32_from_fraction(
-			max_numerator,
-			denominator));
-}
-
-static void setup_reg_format(
-	struct fixed31_32 *coefficients,
-	uint16_t *reg_values)
-{
-	enum {
-		LENGTH = 12,
-		DENOMINATOR = 10000
-	};
-
-	static const int32_t min_numerator[] = {
-		-3 * DENOMINATOR,
-		-DENOMINATOR
-	};
-
-	static const int32_t max_numerator[] = {
-		DENOMINATOR,
-		DENOMINATOR
-	};
-
-	static const uint8_t integer_bits[] = { 2, 0 };
-
-	uint32_t i = 0;
-
-	do {
-		const uint32_t index = (i % 4) == 3;
-
-		reg_values[i] = fixed_point_to_int_frac(
-			fixed31_32_clamp(coefficients[(i + 8) % LENGTH],
-				min_numerator[index],
-				max_numerator[index],
-				DENOMINATOR),
-			integer_bits[index], 13);
-
-		++i;
-	} while (i != LENGTH);
-}
-
-/**
- *****************************************************************************
- *  Function: setup_adjustments
- *  @note prepare to setup the values
- *
- *  @see
- *
- *****************************************************************************
- */
-static void setup_adjustments(const struct opp_grph_csc_adjustment *adjust,
-	struct dc_csc_adjustments *adjustments)
-{
-	if (adjust->adjust_divider != 0) {
-		adjustments->brightness =
-			dal_fixed31_32_from_fraction(adjust->grph_bright,
-			adjust->adjust_divider);
-		adjustments->contrast =
-			dal_fixed31_32_from_fraction(adjust->grph_cont,
-			adjust->adjust_divider);
-		adjustments->saturation =
-			dal_fixed31_32_from_fraction(adjust->grph_sat,
-			adjust->adjust_divider);
-	} else {
-		adjustments->brightness =
-			dal_fixed31_32_from_fraction(adjust->grph_bright, 1);
-		adjustments->contrast =
-			dal_fixed31_32_from_fraction(adjust->grph_cont, 1);
-		adjustments->saturation =
-			dal_fixed31_32_from_fraction(adjust->grph_sat, 1);
-	}
-
-	/* convert degrees into radians */
-	adjustments->hue =
-		dal_fixed31_32_mul(
-			dal_fixed31_32_from_fraction(adjust->grph_hue, 180),
-			dal_fixed31_32_pi);
-}
-
-static void prepare_tv_rgb_ideal(
-	struct fixed31_32 *matrix)
-{
-	static const int32_t matrix_[] = {
-		85546875, 0, 0, 6250000,
-		0, 85546875, 0, 6250000,
-		0, 0, 85546875, 6250000
-	};
-
-	uint32_t i = 0;
-
-	do {
-		matrix[i] = dal_fixed31_32_from_fraction(
-			matrix_[i],
-			100000000);
-		++i;
-	} while (i != ARRAY_SIZE(matrix_));
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_rgb_adjustment_legacy
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for sRGB color space
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_rgb_adjustment_legacy(
-	struct dce110_opp *opp110,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	const struct fixed31_32 k1 =
-		dal_fixed31_32_from_fraction(701000, 1000000);
-	const struct fixed31_32 k2 =
-		dal_fixed31_32_from_fraction(236568, 1000000);
-	const struct fixed31_32 k3 =
-		dal_fixed31_32_from_fraction(-587000, 1000000);
-	const struct fixed31_32 k4 =
-		dal_fixed31_32_from_fraction(464432, 1000000);
-	const struct fixed31_32 k5 =
-		dal_fixed31_32_from_fraction(-114000, 1000000);
-	const struct fixed31_32 k6 =
-		dal_fixed31_32_from_fraction(-701000, 1000000);
-	const struct fixed31_32 k7 =
-		dal_fixed31_32_from_fraction(-299000, 1000000);
-	const struct fixed31_32 k8 =
-		dal_fixed31_32_from_fraction(-292569, 1000000);
-	const struct fixed31_32 k9 =
-		dal_fixed31_32_from_fraction(413000, 1000000);
-	const struct fixed31_32 k10 =
-		dal_fixed31_32_from_fraction(-92482, 1000000);
-	const struct fixed31_32 k11 =
-		dal_fixed31_32_from_fraction(-114000, 1000000);
-	const struct fixed31_32 k12 =
-		dal_fixed31_32_from_fraction(385051, 1000000);
-	const struct fixed31_32 k13 =
-		dal_fixed31_32_from_fraction(-299000, 1000000);
-	const struct fixed31_32 k14 =
-		dal_fixed31_32_from_fraction(886000, 1000000);
-	const struct fixed31_32 k15 =
-		dal_fixed31_32_from_fraction(-587000, 1000000);
-	const struct fixed31_32 k16 =
-		dal_fixed31_32_from_fraction(-741914, 1000000);
-	const struct fixed31_32 k17 =
-		dal_fixed31_32_from_fraction(886000, 1000000);
-	const struct fixed31_32 k18 =
-		dal_fixed31_32_from_fraction(-144086, 1000000);
-
-	const struct fixed31_32 luma_r =
-		dal_fixed31_32_from_fraction(299, 1000);
-	const struct fixed31_32 luma_g =
-		dal_fixed31_32_from_fraction(587, 1000);
-	const struct fixed31_32 luma_b =
-		dal_fixed31_32_from_fraction(114, 1000);
-
-	struct out_csc_color_matrix tbl_entry;
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-
-	struct fixed31_32 grph_cont;
-	struct fixed31_32 grph_sat;
-	struct fixed31_32 grph_bright;
-	struct fixed31_32 sin_grph_hue;
-	struct fixed31_32 cos_grph_hue;
-
-	initialize_color_float_adj_reference_values(
-		adjust, &grph_cont, &grph_sat,
-		&grph_bright, &sin_grph_hue, &cos_grph_hue);
-
-	/* COEF_1_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 +
-	 * Sin(GrphHue) * K2)) */
-	/* (Cos(GrphHue) * K1 + Sin(GrphHue) * K2) */
-	matrix[0] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k1),
-			dal_fixed31_32_mul(sin_grph_hue, k2));
-	/* GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2 */
-	matrix[0] = dal_fixed31_32_mul(grph_sat, matrix[0]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2)) */
-	matrix[0] = dal_fixed31_32_add(luma_r, matrix[0]);
-	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) *
-	 * K2)) */
-	matrix[0] = dal_fixed31_32_mul(grph_cont, matrix[0]);
-
-	/* COEF_1_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 +
-	 * Sin(GrphHue) * K4)) */
-	/* (Cos(GrphHue) * K3 + Sin(GrphHue) * K4) */
-	matrix[1] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k3),
-			dal_fixed31_32_mul(sin_grph_hue, k4));
-	/* GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4) */
-	matrix[1] = dal_fixed31_32_mul(grph_sat, matrix[1]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4)) */
-	matrix[1] = dal_fixed31_32_add(luma_g, matrix[1]);
-	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) *
-	 * K4)) */
-	matrix[1] = dal_fixed31_32_mul(grph_cont, matrix[1]);
-
-	/* COEF_1_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K5 +
-	 * Sin(GrphHue) * K6)) */
-	/* (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k5),
-			dal_fixed31_32_mul(sin_grph_hue, k6));
-	/* GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] = dal_fixed31_32_mul(grph_sat, matrix[2]);
-	/* LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] = dal_fixed31_32_add(luma_b, matrix[2]);
-	/* GrphCont  * (LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) *
-	 * K6)) */
-	matrix[2] = dal_fixed31_32_mul(grph_cont, matrix[2]);
-
-	/* COEF_1_4 = GrphBright */
-	matrix[3] = grph_bright;
-
-	/* COEF_2_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 +
-	 * Sin(GrphHue) * K8)) */
-	/* (Cos(GrphHue) * K7 + Sin(GrphHue) * K8) */
-	matrix[4] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k7),
-			dal_fixed31_32_mul(sin_grph_hue, k8));
-	/* GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8) */
-	matrix[4] = dal_fixed31_32_mul(grph_sat, matrix[4]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8)) */
-	matrix[4] = dal_fixed31_32_add(luma_r, matrix[4]);
-	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) *
-	 * K8)) */
-	matrix[4] = dal_fixed31_32_mul(grph_cont, matrix[4]);
-
-	/* COEF_2_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 +
-	 * Sin(GrphHue) * K10)) */
-	/* (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k9),
-			dal_fixed31_32_mul(sin_grph_hue, k10));
-	/* GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] = dal_fixed31_32_mul(grph_sat, matrix[5]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] = dal_fixed31_32_add(luma_g, matrix[5]);
-	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) *
-	 * K10)) */
-	matrix[5] = dal_fixed31_32_mul(grph_cont, matrix[5]);
-
-	/*  COEF_2_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 +
-	 * Sin(GrphHue) * K12)) */
-	/* (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k11),
-			dal_fixed31_32_mul(sin_grph_hue, k12));
-	/* GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] = dal_fixed31_32_mul(grph_sat, matrix[6]);
-	/*  (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] = dal_fixed31_32_add(luma_b, matrix[6]);
-	/* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) *
-	 * K12)) */
-	matrix[6] = dal_fixed31_32_mul(grph_cont, matrix[6]);
-
-	/* COEF_2_4 = GrphBright */
-	matrix[7] = grph_bright;
-
-	/* COEF_3_1 = GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 +
-	 * Sin(GrphHue) * K14)) */
-	/* (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k13),
-			dal_fixed31_32_mul(sin_grph_hue, k14));
-	/* GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] = dal_fixed31_32_mul(grph_sat, matrix[8]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] = dal_fixed31_32_add(luma_r, matrix[8]);
-	/* GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) *
-	 * K14)) */
-	matrix[8] = dal_fixed31_32_mul(grph_cont, matrix[8]);
-
-	/* COEF_3_2    = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 +
-	 * Sin(GrphHue) * K16)) */
-	/* GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16) */
-	matrix[9] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k15),
-			dal_fixed31_32_mul(sin_grph_hue, k16));
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
-	matrix[9] = dal_fixed31_32_mul(grph_sat, matrix[9]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
-	matrix[9] = dal_fixed31_32_add(luma_g, matrix[9]);
-	 /* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) *
-	  * K16)) */
-	matrix[9] = dal_fixed31_32_mul(grph_cont, matrix[9]);
-
-	/*  COEF_3_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 +
-	 * Sin(GrphHue) * K18)) */
-	/* (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k17),
-			dal_fixed31_32_mul(sin_grph_hue, k18));
-	/*  GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] = dal_fixed31_32_mul(grph_sat, matrix[10]);
-	/* (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] = dal_fixed31_32_add(luma_b, matrix[10]);
-	 /* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) *
-	  * K18)) */
-	matrix[10] = dal_fixed31_32_mul(grph_cont, matrix[10]);
-
-	/*  COEF_3_4    = GrphBright */
-	matrix[11] = grph_bright;
-
-	tbl_entry.color_space = adjust->c_space;
-
-	convert_float_matrix(tbl_entry.regval, matrix, OUTPUT_CSC_MATRIX_SIZE);
-
-	program_color_matrix(
-		opp110, &tbl_entry, adjust->color_adjust_option);
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_rgb_limited_range_adjustment
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for sRGB limited color space
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_rgb_limited_range_adjustment(
-	struct dce110_opp *opp110,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	struct out_csc_color_matrix reg_matrix;
-	struct fixed31_32 change_matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct dc_csc_adjustments adjustments;
-	struct fixed31_32 ideals[OUTPUT_CSC_MATRIX_SIZE];
-
-	prepare_tv_rgb_ideal(ideals);
-
-	setup_adjustments(adjust, &adjustments);
-
-	calculate_adjustments(ideals, &adjustments, matrix);
-
-	memmove(change_matrix, matrix, sizeof(matrix));
-
-	/* from 1 -> 3 */
-	matrix[8] = change_matrix[0];
-	matrix[9] = change_matrix[1];
-	matrix[10] = change_matrix[2];
-	matrix[11] = change_matrix[3];
-
-	/* from 2 -> 1 */
-	matrix[0] = change_matrix[4];
-	matrix[1] = change_matrix[5];
-	matrix[2] = change_matrix[6];
-	matrix[3] = change_matrix[7];
-
-	/* from 3 -> 2 */
-	matrix[4] = change_matrix[8];
-	matrix[5] = change_matrix[9];
-	matrix[6] = change_matrix[10];
-	matrix[7] = change_matrix[11];
-
-	memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
-
-	setup_reg_format(matrix, reg_matrix.regval);
-
-	program_color_matrix(opp110, &reg_matrix, GRPH_COLOR_MATRIX_SW);
-}
-
-static void prepare_yuv_ideal(
-	bool b601,
-	struct fixed31_32 *matrix)
-{
-	static const int32_t matrix_1[] = {
-		25578516, 50216016, 9752344, 6250000,
-		-14764391, -28985609, 43750000, 50000000,
-		43750000, -36635164, -7114836, 50000000
-	};
-
-	static const int32_t matrix_2[] = {
-		18187266, 61183125, 6176484, 6250000,
-		-10025059, -33724941, 43750000, 50000000,
-		43750000, -39738379, -4011621, 50000000
-	};
-
-	const int32_t *matrix_x = b601 ? matrix_1 : matrix_2;
-
-	uint32_t i = 0;
-
-	do {
-		matrix[i] = dal_fixed31_32_from_fraction(
-			matrix_x[i],
-			100000000);
-		++i;
-	} while (i != ARRAY_SIZE(matrix_1));
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_yuv_adjustment
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for YUV  color spaces
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_yuv_adjustment(
-	struct dce110_opp *opp110,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	bool b601 = (adjust->c_space == COLOR_SPACE_YPBPR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED);
-	struct out_csc_color_matrix reg_matrix;
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct dc_csc_adjustments adjustments;
-	struct fixed31_32 ideals[OUTPUT_CSC_MATRIX_SIZE];
-
-	prepare_yuv_ideal(b601, ideals);
-
-	setup_adjustments(adjust, &adjustments);
-
-	if ((adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR709_LIMITED))
-		calculate_adjustments_y_only(
-			ideals, &adjustments, matrix);
-	else
-		calculate_adjustments(
-			ideals, &adjustments, matrix);
-
-	memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
-
-	setup_reg_format(matrix, reg_matrix.regval);
-
-	program_color_matrix(opp110, &reg_matrix, GRPH_COLOR_MATRIX_SW);
-}
-
 static bool configure_graphics_mode(
 	struct dce110_opp *opp110,
 	enum csc_color_mode config,
@@ -823,40 +304,18 @@ static bool configure_graphics_mode(
 
 void dce110_opp_set_csc_adjustment(
 	struct output_pixel_processor *opp,
-	const struct opp_grph_csc_adjustment *adjust)
+	const struct out_csc_color_matrix *tbl_entry)
 {
 	struct dce110_opp *opp110 = TO_DCE110_OPP(opp);
 	enum csc_color_mode config =
 			CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
 
-	/* Apply color adjustments: brightness, saturation, hue, contrast and
-	 * CSC. No need for different color space routine, color space defines
-	 * the ideal values only, but keep original design to allow quick switch
-	 * to the old legacy routines */
-	switch (adjust->c_space) {
-	case COLOR_SPACE_SRGB:
-		set_rgb_adjustment_legacy(opp110, adjust);
-		break;
-	case COLOR_SPACE_SRGB_LIMITED:
-		set_rgb_limited_range_adjustment(
-			opp110, adjust);
-		break;
-	case COLOR_SPACE_YCBCR601:
-	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_LIMITED:
-	case COLOR_SPACE_YCBCR709_LIMITED:
-	case COLOR_SPACE_YPBPR601:
-	case COLOR_SPACE_YPBPR709:
-		set_yuv_adjustment(opp110, adjust);
-		break;
-	default:
-		set_rgb_adjustment_legacy(opp110, adjust);
-		break;
-	}
+	program_color_matrix(
+			opp110, tbl_entry, GRAPHICS_CSC_ADJUST_TYPE_SW);
 
 	/*  We did everything ,now program DxOUTPUT_CSC_CONTROL */
-	configure_graphics_mode(opp110, config, adjust->csc_adjust_type,
-		adjust->c_space);
+	configure_graphics_mode(opp110, config, GRAPHICS_CSC_ADJUST_TYPE_SW,
+			tbl_entry->color_space);
 }
 
 void dce110_opp_set_csc_default(
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c
index b369feb..975466f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_csc_v.c
@@ -74,11 +74,6 @@ enum {
 #define  UNDERLAY_BRIGHTNESS_STEP       1 /*  .01 */
 #define  UNDERLAY_BRIGHTNESS_DIVIDER  100
 
-struct out_csc_color_matrix {
-	enum dc_color_space color_space;
-	uint16_t regval[OUTPUT_CSC_MATRIX_SIZE];
-};
-
 static const struct out_csc_color_matrix global_color_matrix[] = {
 { COLOR_SPACE_SRGB,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
@@ -355,461 +350,6 @@ static void program_color_matrix_v(
 	dm_write_reg(ctx, mmCOL_MAN_OUTPUT_CSC_CONTROL, cntl_value);
 }
 
-/*
- * initialize_color_float_adj_reference_values
- * This initialize display color adjust input from API to HW range for later
- * calculation use. This is shared by all the display color adjustment.
- * @param :
- * @return None
- */
-static void initialize_color_float_adj_reference_values(
-	const struct opp_grph_csc_adjustment *adjust,
-	struct fixed31_32 *grph_cont,
-	struct fixed31_32 *grph_sat,
-	struct fixed31_32 *grph_bright,
-	struct fixed31_32 *sin_grph_hue,
-	struct fixed31_32 *cos_grph_hue)
-{
-	/* Hue adjustment could be negative. -45 ~ +45 */
-	struct fixed31_32 hue =
-		dal_fixed31_32_mul(
-			dal_fixed31_32_from_fraction(adjust->grph_hue, 180),
-			dal_fixed31_32_pi);
-
-	*sin_grph_hue = dal_fixed31_32_sin(hue);
-	*cos_grph_hue = dal_fixed31_32_cos(hue);
-
-	if (adjust->adjust_divider) {
-		*grph_cont =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_cont,
-				adjust->adjust_divider);
-		*grph_sat =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_sat,
-				adjust->adjust_divider);
-		*grph_bright =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_bright,
-				adjust->adjust_divider);
-	} else {
-		*grph_cont = dal_fixed31_32_from_int(adjust->grph_cont);
-		*grph_sat = dal_fixed31_32_from_int(adjust->grph_sat);
-		*grph_bright = dal_fixed31_32_from_int(adjust->grph_bright);
-	}
-}
-
-static inline struct fixed31_32 fixed31_32_clamp(
-	struct fixed31_32 value,
-	int32_t min_numerator,
-	int32_t max_numerator,
-	int32_t denominator)
-{
-	return dal_fixed31_32_clamp(
-		value,
-		dal_fixed31_32_from_fraction(
-			min_numerator,
-			denominator),
-		dal_fixed31_32_from_fraction(
-			max_numerator,
-			denominator));
-}
-
-static void setup_reg_format(
-	struct fixed31_32 *coefficients,
-	uint16_t *reg_values)
-{
-	enum {
-		LENGTH = 12,
-		DENOMINATOR = 10000
-	};
-
-	static const int32_t min_numerator[] = {
-		-3 * DENOMINATOR,
-		-DENOMINATOR
-	};
-
-	static const int32_t max_numerator[] = {
-		DENOMINATOR,
-		DENOMINATOR
-	};
-
-	static const uint8_t integer_bits[] = { 2, 0 };
-
-	uint32_t i = 0;
-
-	do {
-		const uint32_t index = (i % 4) == 3;
-
-		reg_values[i] = fixed_point_to_int_frac(
-			fixed31_32_clamp(coefficients[(i + 8) % LENGTH],
-				min_numerator[index],
-				max_numerator[index],
-				DENOMINATOR),
-			integer_bits[index], 13);
-
-		++i;
-	} while (i != LENGTH);
-}
-
-/**
- *****************************************************************************
- *  Function: setup_adjustments
- *  @note prepare to setup the values
- *
- *  @see
- *
- *****************************************************************************
- */
-static void setup_adjustments(const struct opp_grph_csc_adjustment *adjust,
-	struct dc_csc_adjustments *adjustments)
-{
-	if (adjust->adjust_divider != 0) {
-		adjustments->brightness =
-			dal_fixed31_32_from_fraction(adjust->grph_bright,
-			adjust->adjust_divider);
-		adjustments->contrast =
-			dal_fixed31_32_from_fraction(adjust->grph_cont,
-			adjust->adjust_divider);
-		adjustments->saturation =
-			dal_fixed31_32_from_fraction(adjust->grph_sat,
-			adjust->adjust_divider);
-	} else {
-		adjustments->brightness =
-			dal_fixed31_32_from_fraction(adjust->grph_bright, 1);
-		adjustments->contrast =
-			dal_fixed31_32_from_fraction(adjust->grph_cont, 1);
-		adjustments->saturation =
-			dal_fixed31_32_from_fraction(adjust->grph_sat, 1);
-	}
-
-	/* convert degrees into radians */
-	adjustments->hue =
-		dal_fixed31_32_mul(
-			dal_fixed31_32_from_fraction(adjust->grph_hue, 180),
-			dal_fixed31_32_pi);
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_rgb_adjustment_legacy
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for sRGB color space
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_rgb_adjustment_legacy(
-	struct dce110_opp *opp110,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	const struct fixed31_32 k1 =
-		dal_fixed31_32_from_fraction(701000, 1000000);
-	const struct fixed31_32 k2 =
-		dal_fixed31_32_from_fraction(236568, 1000000);
-	const struct fixed31_32 k3 =
-		dal_fixed31_32_from_fraction(-587000, 1000000);
-	const struct fixed31_32 k4 =
-		dal_fixed31_32_from_fraction(464432, 1000000);
-	const struct fixed31_32 k5 =
-		dal_fixed31_32_from_fraction(-114000, 1000000);
-	const struct fixed31_32 k6 =
-		dal_fixed31_32_from_fraction(-701000, 1000000);
-	const struct fixed31_32 k7 =
-		dal_fixed31_32_from_fraction(-299000, 1000000);
-	const struct fixed31_32 k8 =
-		dal_fixed31_32_from_fraction(-292569, 1000000);
-	const struct fixed31_32 k9 =
-		dal_fixed31_32_from_fraction(413000, 1000000);
-	const struct fixed31_32 k10 =
-		dal_fixed31_32_from_fraction(-92482, 1000000);
-	const struct fixed31_32 k11 =
-		dal_fixed31_32_from_fraction(-114000, 1000000);
-	const struct fixed31_32 k12 =
-		dal_fixed31_32_from_fraction(385051, 1000000);
-	const struct fixed31_32 k13 =
-		dal_fixed31_32_from_fraction(-299000, 1000000);
-	const struct fixed31_32 k14 =
-		dal_fixed31_32_from_fraction(886000, 1000000);
-	const struct fixed31_32 k15 =
-		dal_fixed31_32_from_fraction(-587000, 1000000);
-	const struct fixed31_32 k16 =
-		dal_fixed31_32_from_fraction(-741914, 1000000);
-	const struct fixed31_32 k17 =
-		dal_fixed31_32_from_fraction(886000, 1000000);
-	const struct fixed31_32 k18 =
-		dal_fixed31_32_from_fraction(-144086, 1000000);
-
-	const struct fixed31_32 luma_r =
-		dal_fixed31_32_from_fraction(299, 1000);
-	const struct fixed31_32 luma_g =
-		dal_fixed31_32_from_fraction(587, 1000);
-	const struct fixed31_32 luma_b =
-		dal_fixed31_32_from_fraction(114, 1000);
-
-	struct out_csc_color_matrix tbl_entry;
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-
-	struct fixed31_32 grph_cont;
-	struct fixed31_32 grph_sat;
-	struct fixed31_32 grph_bright;
-	struct fixed31_32 sin_grph_hue;
-	struct fixed31_32 cos_grph_hue;
-
-	initialize_color_float_adj_reference_values(
-		adjust, &grph_cont, &grph_sat,
-		&grph_bright, &sin_grph_hue, &cos_grph_hue);
-
-	/* COEF_1_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 +
-	 * Sin(GrphHue) * K2))
-	 * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2)
-	 */
-	matrix[0] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k1),
-			dal_fixed31_32_mul(sin_grph_hue, k2));
-	/* GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2 */
-	matrix[0] = dal_fixed31_32_mul(grph_sat, matrix[0]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2)) */
-	matrix[0] = dal_fixed31_32_add(luma_r, matrix[0]);
-	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) *
-	 * K2))
-	 */
-	matrix[0] = dal_fixed31_32_mul(grph_cont, matrix[0]);
-
-	/* COEF_1_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 +
-	 * Sin(GrphHue) * K4))
-	 * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4)
-	 */
-	matrix[1] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k3),
-			dal_fixed31_32_mul(sin_grph_hue, k4));
-	/* GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4) */
-	matrix[1] = dal_fixed31_32_mul(grph_sat, matrix[1]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4)) */
-	matrix[1] = dal_fixed31_32_add(luma_g, matrix[1]);
-	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) *
-	 * K4))
-	 */
-	matrix[1] = dal_fixed31_32_mul(grph_cont, matrix[1]);
-
-	/* COEF_1_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K5 +
-	 * Sin(GrphHue) * K6))
-	 * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6)
-	 */
-	matrix[2] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k5),
-			dal_fixed31_32_mul(sin_grph_hue, k6));
-	/* GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] = dal_fixed31_32_mul(grph_sat, matrix[2]);
-	/* LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] = dal_fixed31_32_add(luma_b, matrix[2]);
-	/* GrphCont  * (LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) *
-	 * K6))
-	 */
-	matrix[2] = dal_fixed31_32_mul(grph_cont, matrix[2]);
-
-	/* COEF_1_4 = GrphBright */
-	matrix[3] = grph_bright;
-
-	/* COEF_2_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 +
-	 * Sin(GrphHue) * K8))
-	 * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8)
-	 */
-	matrix[4] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k7),
-			dal_fixed31_32_mul(sin_grph_hue, k8));
-	/* GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8) */
-	matrix[4] = dal_fixed31_32_mul(grph_sat, matrix[4]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8)) */
-	matrix[4] = dal_fixed31_32_add(luma_r, matrix[4]);
-	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) *
-	 * K8))
-	 */
-	matrix[4] = dal_fixed31_32_mul(grph_cont, matrix[4]);
-
-	/* COEF_2_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 +
-	 * Sin(GrphHue) * K10))
-	 * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10))
-	 */
-	matrix[5] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k9),
-			dal_fixed31_32_mul(sin_grph_hue, k10));
-	/* GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] = dal_fixed31_32_mul(grph_sat, matrix[5]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] = dal_fixed31_32_add(luma_g, matrix[5]);
-	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) *
-	 * K10))
-	 */
-	matrix[5] = dal_fixed31_32_mul(grph_cont, matrix[5]);
-
-	/*  COEF_2_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 +
-	 * Sin(GrphHue) * K12))
-	 * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12))
-	 */
-	matrix[6] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k11),
-			dal_fixed31_32_mul(sin_grph_hue, k12));
-	/* GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] = dal_fixed31_32_mul(grph_sat, matrix[6]);
-	/*  (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] = dal_fixed31_32_add(luma_b, matrix[6]);
-	/* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) *
-	 * K12))
-	 */
-	matrix[6] = dal_fixed31_32_mul(grph_cont, matrix[6]);
-
-	/* COEF_2_4 = GrphBright */
-	matrix[7] = grph_bright;
-
-	/* COEF_3_1 = GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 +
-	 * Sin(GrphHue) * K14))
-	 * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14))
-	 */
-	matrix[8] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k13),
-			dal_fixed31_32_mul(sin_grph_hue, k14));
-	/* GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] = dal_fixed31_32_mul(grph_sat, matrix[8]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] = dal_fixed31_32_add(luma_r, matrix[8]);
-	/* GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) *
-	 * K14))
-	 */
-	matrix[8] = dal_fixed31_32_mul(grph_cont, matrix[8]);
-
-	/* COEF_3_2    = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 +
-	 * Sin(GrphHue) * K16))
-	 * GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)
-	 */
-	matrix[9] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k15),
-			dal_fixed31_32_mul(sin_grph_hue, k16));
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
-	matrix[9] = dal_fixed31_32_mul(grph_sat, matrix[9]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
-	matrix[9] = dal_fixed31_32_add(luma_g, matrix[9]);
-	 /* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) *
-	  * K16))
-	  */
-	matrix[9] = dal_fixed31_32_mul(grph_cont, matrix[9]);
-
-	/*  COEF_3_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 +
-	 * Sin(GrphHue) * K18))
-	 * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18))
-	 */
-	matrix[10] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k17),
-			dal_fixed31_32_mul(sin_grph_hue, k18));
-	/*  GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] = dal_fixed31_32_mul(grph_sat, matrix[10]);
-	/* (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] = dal_fixed31_32_add(luma_b, matrix[10]);
-	 /* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) *
-	  * K18))
-	  */
-	matrix[10] = dal_fixed31_32_mul(grph_cont, matrix[10]);
-
-	/*  COEF_3_4    = GrphBright */
-	matrix[11] = grph_bright;
-
-	tbl_entry.color_space = adjust->c_space;
-
-	convert_float_matrix(tbl_entry.regval, matrix, OUTPUT_CSC_MATRIX_SIZE);
-
-	program_color_matrix_v(
-		opp110, &tbl_entry, adjust->color_adjust_option);
-}
-
-static void prepare_yuv_ideal(
-	bool b601,
-	struct fixed31_32 *matrix)
-{
-	static const int32_t matrix_1[] = {
-		25578516, 50216016, 9752344, 6250000,
-		-14764391, -28985609, 43750000, 50000000,
-		43750000, -36635164, -7114836, 50000000
-	};
-
-	static const int32_t matrix_2[] = {
-		18187266, 61183125, 6176484, 6250000,
-		-10025059, -33724941, 43750000, 50000000,
-		43750000, -39738379, -4011621, 50000000
-	};
-
-	const int32_t *matrix_x = b601 ? matrix_1 : matrix_2;
-
-	uint32_t i = 0;
-
-	do {
-		matrix[i] = dal_fixed31_32_from_fraction(
-			matrix_x[i],
-			100000000);
-		++i;
-	} while (i != ARRAY_SIZE(matrix_1));
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_yuv_adjustment
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for YUV  color spaces
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_yuv_adjustment(
-	struct dce110_opp *opp110,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	bool b601 = (adjust->c_space == COLOR_SPACE_YPBPR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED);
-	struct out_csc_color_matrix reg_matrix;
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct dc_csc_adjustments adjustments;
-	struct fixed31_32 ideals[OUTPUT_CSC_MATRIX_SIZE];
-
-	prepare_yuv_ideal(b601, ideals);
-
-	setup_adjustments(adjust, &adjustments);
-
-	if ((adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR709_LIMITED))
-		calculate_adjustments_y_only(
-			ideals, &adjustments, matrix);
-	else
-		calculate_adjustments(
-			ideals, &adjustments, matrix);
-
-	memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
-
-	setup_reg_format(matrix, reg_matrix.regval);
-
-	program_color_matrix_v(opp110, &reg_matrix, GRPH_COLOR_MATRIX_SW);
-}
-
 static bool configure_graphics_mode_v(
 	struct dce110_opp *opp110,
 	enum csc_color_mode config,
@@ -918,6 +458,7 @@ static bool configure_graphics_mode_v(
 	return true;
 }
 
+/*TODO: color depth is not correct when this is called*/
 static void set_Denormalization(struct output_pixel_processor *opp,
 		enum dc_color_depth color_depth)
 {
@@ -1179,37 +720,19 @@ void dce110_opp_v_set_csc_default(
 
 void dce110_opp_v_set_csc_adjustment(
 	struct output_pixel_processor *opp,
-	const struct opp_grph_csc_adjustment *adjust)
+	const struct out_csc_color_matrix *tbl_entry)
 {
 	struct dce110_opp *opp110 = TO_DCE110_OPP(opp);
 	enum csc_color_mode config =
 			CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
 
-	/* Apply color adjustments: brightness, saturation, hue, contrast and
-	 * CSC. No need for different color space routine, color space defines
-	 * the ideal values only, but keep original design to allow quick switch
-	 * to the old legacy routines
-	 */
-	switch (adjust->c_space) {
-	case COLOR_SPACE_SRGB:
-		set_rgb_adjustment_legacy(opp110, adjust);
-		break;
-	case COLOR_SPACE_YCBCR601:
-	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_LIMITED:
-	case COLOR_SPACE_YCBCR709_LIMITED:
-	case COLOR_SPACE_YPBPR601:
-	case COLOR_SPACE_YPBPR709:
-		set_yuv_adjustment(opp110, adjust);
-		break;
-	default:
-		set_rgb_adjustment_legacy(opp110, adjust);
-		break;
-	}
+	program_color_matrix_v(
+			opp110, tbl_entry, GRAPHICS_CSC_ADJUST_TYPE_SW);
 
 	/*  We did everything ,now program DxOUTPUT_CSC_CONTROL */
-	configure_graphics_mode_v(opp110, config, adjust->csc_adjust_type,
-		adjust->c_space);
+	configure_graphics_mode_v(opp110, config, GRAPHICS_CSC_ADJUST_TYPE_SW,
+			tbl_entry->color_space);
 
-	set_Denormalization(opp, adjust->color_depth);
+	/*TODO: Check if denormalization is needed*/
+	/*set_Denormalization(opp, adjust->color_depth);*/
 }
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.h
index d8d6910..dcdbf86 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.h
@@ -43,7 +43,7 @@ void dce110_opp_v_set_csc_default(
 
 void dce110_opp_v_set_csc_adjustment(
 	struct output_pixel_processor *opp,
-	const struct opp_grph_csc_adjustment *adjust);
+	const struct out_csc_color_matrix *tbl_entry);
 
 bool dce110_opp_program_regamma_pwl_v(
 	struct output_pixel_processor *opp,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
index 6fe79872..965cce3 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp.h
@@ -106,7 +106,7 @@ void dce80_opp_set_regamma_mode(struct output_pixel_processor *opp,
 
 void dce80_opp_set_csc_adjustment(
 	struct output_pixel_processor *opp,
-	const struct opp_grph_csc_adjustment *adjust);
+	const struct out_csc_color_matrix *tbl_entry);
 
 void dce80_opp_set_csc_default(
 	struct output_pixel_processor *opp,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c
index b39930e..bdb9e0a 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_opp_csc.c
@@ -39,11 +39,6 @@ enum {
 	OUTPUT_CSC_MATRIX_SIZE = 12
 };
 
-struct out_csc_color_matrix {
-	enum dc_color_space color_space;
-	uint16_t regval[OUTPUT_CSC_MATRIX_SIZE];
-};
-
 static const struct out_csc_color_matrix global_color_matrix[] = {
 { COLOR_SPACE_SRGB,
 	{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
@@ -186,520 +181,6 @@ static void program_color_matrix(
 	}
 }
 
-/*
- * initialize_color_float_adj_reference_values
- * This initialize display color adjust input from API to HW range for later
- * calculation use. This is shared by all the display color adjustment.
- * @param :
- * @return None
- */
-static void initialize_color_float_adj_reference_values(
-	const struct opp_grph_csc_adjustment *adjust,
-	struct fixed31_32 *grph_cont,
-	struct fixed31_32 *grph_sat,
-	struct fixed31_32 *grph_bright,
-	struct fixed31_32 *sin_grph_hue,
-	struct fixed31_32 *cos_grph_hue)
-{
-	/* Hue adjustment could be negative. -45 ~ +45 */
-	struct fixed31_32 hue =
-		dal_fixed31_32_mul(
-			dal_fixed31_32_from_fraction(adjust->grph_hue, 180),
-			dal_fixed31_32_pi);
-
-	*sin_grph_hue = dal_fixed31_32_sin(hue);
-	*cos_grph_hue = dal_fixed31_32_cos(hue);
-
-	if (adjust->adjust_divider) {
-		*grph_cont =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_cont,
-				adjust->adjust_divider);
-		*grph_sat =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_sat,
-				adjust->adjust_divider);
-		*grph_bright =
-			dal_fixed31_32_from_fraction(
-				adjust->grph_bright,
-				adjust->adjust_divider);
-	} else {
-		*grph_cont = dal_fixed31_32_from_int(adjust->grph_cont);
-		*grph_sat = dal_fixed31_32_from_int(adjust->grph_sat);
-		*grph_bright = dal_fixed31_32_from_int(adjust->grph_bright);
-	}
-}
-
-static inline struct fixed31_32 fixed31_32_clamp(
-	struct fixed31_32 value,
-	int32_t min_numerator,
-	int32_t max_numerator,
-	int32_t denominator)
-{
-	return dal_fixed31_32_clamp(
-		value,
-		dal_fixed31_32_from_fraction(
-			min_numerator,
-			denominator),
-		dal_fixed31_32_from_fraction(
-			max_numerator,
-			denominator));
-}
-
-static void setup_reg_format(
-	struct fixed31_32 *coefficients,
-	uint16_t *reg_values)
-{
-	enum {
-		LENGTH = 12,
-		DENOMINATOR = 10000
-	};
-
-	static const int32_t min_numerator[] = {
-		-3 * DENOMINATOR,
-		-DENOMINATOR
-	};
-
-	static const int32_t max_numerator[] = {
-		DENOMINATOR,
-		DENOMINATOR
-	};
-
-	static const uint8_t integer_bits[] = { 2, 0 };
-
-	uint32_t i = 0;
-
-	do {
-		const uint32_t index = (i % 4) == 3;
-
-		reg_values[i] = fixed_point_to_int_frac(
-			fixed31_32_clamp(coefficients[(i + 8) % LENGTH],
-				min_numerator[index],
-				max_numerator[index],
-				DENOMINATOR),
-			integer_bits[index], 13);
-
-		++i;
-	} while (i != LENGTH);
-}
-
-/**
- *****************************************************************************
- *  Function: setup_adjustments
- *  @note prepare to setup the values
- *
- *  @see
- *
- *****************************************************************************
- */
-static void setup_adjustments(const struct opp_grph_csc_adjustment *adjust,
-	struct dc_csc_adjustments *adjustments)
-{
-	if (adjust->adjust_divider != 0) {
-		adjustments->brightness =
-			dal_fixed31_32_from_fraction(adjust->grph_bright,
-			adjust->adjust_divider);
-		adjustments->contrast =
-			dal_fixed31_32_from_fraction(adjust->grph_cont,
-			adjust->adjust_divider);
-		adjustments->saturation =
-			dal_fixed31_32_from_fraction(adjust->grph_sat,
-			adjust->adjust_divider);
-	} else {
-		adjustments->brightness =
-			dal_fixed31_32_from_fraction(adjust->grph_bright, 1);
-		adjustments->contrast =
-			dal_fixed31_32_from_fraction(adjust->grph_cont, 1);
-		adjustments->saturation =
-			dal_fixed31_32_from_fraction(adjust->grph_sat, 1);
-	}
-
-	/* convert degrees into radians */
-	adjustments->hue =
-		dal_fixed31_32_mul(
-			dal_fixed31_32_from_fraction(adjust->grph_hue, 180),
-			dal_fixed31_32_pi);
-}
-
-static void prepare_tv_rgb_ideal(
-	struct fixed31_32 *matrix)
-{
-	static const int32_t matrix_[] = {
-		85546875, 0, 0, 6250000,
-		0, 85546875, 0, 6250000,
-		0, 0, 85546875, 6250000
-	};
-
-	uint32_t i = 0;
-
-	do {
-		matrix[i] = dal_fixed31_32_from_fraction(
-			matrix_[i],
-			100000000);
-		++i;
-	} while (i != ARRAY_SIZE(matrix_));
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_rgb_adjustment_legacy
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for sRGB color space
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_rgb_adjustment_legacy(
-	struct dce80_opp *opp80,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	const struct fixed31_32 k1 =
-		dal_fixed31_32_from_fraction(701000, 1000000);
-	const struct fixed31_32 k2 =
-		dal_fixed31_32_from_fraction(236568, 1000000);
-	const struct fixed31_32 k3 =
-		dal_fixed31_32_from_fraction(-587000, 1000000);
-	const struct fixed31_32 k4 =
-		dal_fixed31_32_from_fraction(464432, 1000000);
-	const struct fixed31_32 k5 =
-		dal_fixed31_32_from_fraction(-114000, 1000000);
-	const struct fixed31_32 k6 =
-		dal_fixed31_32_from_fraction(-701000, 1000000);
-	const struct fixed31_32 k7 =
-		dal_fixed31_32_from_fraction(-299000, 1000000);
-	const struct fixed31_32 k8 =
-		dal_fixed31_32_from_fraction(-292569, 1000000);
-	const struct fixed31_32 k9 =
-		dal_fixed31_32_from_fraction(413000, 1000000);
-	const struct fixed31_32 k10 =
-		dal_fixed31_32_from_fraction(-92482, 1000000);
-	const struct fixed31_32 k11 =
-		dal_fixed31_32_from_fraction(-114000, 1000000);
-	const struct fixed31_32 k12 =
-		dal_fixed31_32_from_fraction(385051, 1000000);
-	const struct fixed31_32 k13 =
-		dal_fixed31_32_from_fraction(-299000, 1000000);
-	const struct fixed31_32 k14 =
-		dal_fixed31_32_from_fraction(886000, 1000000);
-	const struct fixed31_32 k15 =
-		dal_fixed31_32_from_fraction(-587000, 1000000);
-	const struct fixed31_32 k16 =
-		dal_fixed31_32_from_fraction(-741914, 1000000);
-	const struct fixed31_32 k17 =
-		dal_fixed31_32_from_fraction(886000, 1000000);
-	const struct fixed31_32 k18 =
-		dal_fixed31_32_from_fraction(-144086, 1000000);
-
-	const struct fixed31_32 luma_r =
-		dal_fixed31_32_from_fraction(299, 1000);
-	const struct fixed31_32 luma_g =
-		dal_fixed31_32_from_fraction(587, 1000);
-	const struct fixed31_32 luma_b =
-		dal_fixed31_32_from_fraction(114, 1000);
-
-	struct out_csc_color_matrix tbl_entry;
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-
-	struct fixed31_32 grph_cont;
-	struct fixed31_32 grph_sat;
-	struct fixed31_32 grph_bright;
-	struct fixed31_32 sin_grph_hue;
-	struct fixed31_32 cos_grph_hue;
-
-	initialize_color_float_adj_reference_values(
-		adjust, &grph_cont, &grph_sat,
-		&grph_bright, &sin_grph_hue, &cos_grph_hue);
-
-	/* COEF_1_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 +
-	 * Sin(GrphHue) * K2)) */
-	/* (Cos(GrphHue) * K1 + Sin(GrphHue) * K2) */
-	matrix[0] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k1),
-			dal_fixed31_32_mul(sin_grph_hue, k2));
-	/* GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2 */
-	matrix[0] = dal_fixed31_32_mul(grph_sat, matrix[0]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2)) */
-	matrix[0] = dal_fixed31_32_add(luma_r, matrix[0]);
-	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) *
-	 * K2)) */
-	matrix[0] = dal_fixed31_32_mul(grph_cont, matrix[0]);
-
-	/* COEF_1_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 +
-	 * Sin(GrphHue) * K4)) */
-	/* (Cos(GrphHue) * K3 + Sin(GrphHue) * K4) */
-	matrix[1] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k3),
-			dal_fixed31_32_mul(sin_grph_hue, k4));
-	/* GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4) */
-	matrix[1] = dal_fixed31_32_mul(grph_sat, matrix[1]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4)) */
-	matrix[1] = dal_fixed31_32_add(luma_g, matrix[1]);
-	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) *
-	 * K4)) */
-	matrix[1] = dal_fixed31_32_mul(grph_cont, matrix[1]);
-
-	/* COEF_1_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K5 +
-	 * Sin(GrphHue) * K6)) */
-	/* (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k5),
-			dal_fixed31_32_mul(sin_grph_hue, k6));
-	/* GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] = dal_fixed31_32_mul(grph_sat, matrix[2]);
-	/* LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6) */
-	matrix[2] = dal_fixed31_32_add(luma_b, matrix[2]);
-	/* GrphCont  * (LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) *
-	 * K6)) */
-	matrix[2] = dal_fixed31_32_mul(grph_cont, matrix[2]);
-
-	/* COEF_1_4 = GrphBright */
-	matrix[3] = grph_bright;
-
-	/* COEF_2_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 +
-	 * Sin(GrphHue) * K8)) */
-	/* (Cos(GrphHue) * K7 + Sin(GrphHue) * K8) */
-	matrix[4] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k7),
-			dal_fixed31_32_mul(sin_grph_hue, k8));
-	/* GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8) */
-	matrix[4] = dal_fixed31_32_mul(grph_sat, matrix[4]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8)) */
-	matrix[4] = dal_fixed31_32_add(luma_r, matrix[4]);
-	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) *
-	 * K8)) */
-	matrix[4] = dal_fixed31_32_mul(grph_cont, matrix[4]);
-
-	/* COEF_2_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 +
-	 * Sin(GrphHue) * K10)) */
-	/* (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k9),
-			dal_fixed31_32_mul(sin_grph_hue, k10));
-	/* GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] = dal_fixed31_32_mul(grph_sat, matrix[5]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10)) */
-	matrix[5] = dal_fixed31_32_add(luma_g, matrix[5]);
-	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) *
-	 * K10)) */
-	matrix[5] = dal_fixed31_32_mul(grph_cont, matrix[5]);
-
-	/*  COEF_2_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 +
-	 * Sin(GrphHue) * K12)) */
-	/* (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k11),
-			dal_fixed31_32_mul(sin_grph_hue, k12));
-	/* GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] = dal_fixed31_32_mul(grph_sat, matrix[6]);
-	/*  (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12)) */
-	matrix[6] = dal_fixed31_32_add(luma_b, matrix[6]);
-	/* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) *
-	 * K12)) */
-	matrix[6] = dal_fixed31_32_mul(grph_cont, matrix[6]);
-
-	/* COEF_2_4 = GrphBright */
-	matrix[7] = grph_bright;
-
-	/* COEF_3_1 = GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 +
-	 * Sin(GrphHue) * K14)) */
-	/* (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k13),
-			dal_fixed31_32_mul(sin_grph_hue, k14));
-	/* GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] = dal_fixed31_32_mul(grph_sat, matrix[8]);
-	/* (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
-	matrix[8] = dal_fixed31_32_add(luma_r, matrix[8]);
-	/* GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) *
-	 * K14)) */
-	matrix[8] = dal_fixed31_32_mul(grph_cont, matrix[8]);
-
-	/* COEF_3_2    = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 +
-	 * Sin(GrphHue) * K16)) */
-	/* GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16) */
-	matrix[9] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k15),
-			dal_fixed31_32_mul(sin_grph_hue, k16));
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
-	matrix[9] = dal_fixed31_32_mul(grph_sat, matrix[9]);
-	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
-	matrix[9] = dal_fixed31_32_add(luma_g, matrix[9]);
-	 /* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) *
-	  * K16)) */
-	matrix[9] = dal_fixed31_32_mul(grph_cont, matrix[9]);
-
-	/*  COEF_3_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 +
-	 * Sin(GrphHue) * K18)) */
-	/* (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] =
-		dal_fixed31_32_add(
-			dal_fixed31_32_mul(cos_grph_hue, k17),
-			dal_fixed31_32_mul(sin_grph_hue, k18));
-	/*  GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] = dal_fixed31_32_mul(grph_sat, matrix[10]);
-	/* (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
-	matrix[10] = dal_fixed31_32_add(luma_b, matrix[10]);
-	 /* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) *
-	  * K18)) */
-	matrix[10] = dal_fixed31_32_mul(grph_cont, matrix[10]);
-
-	/*  COEF_3_4    = GrphBright */
-	matrix[11] = grph_bright;
-
-	tbl_entry.color_space = adjust->c_space;
-
-	convert_float_matrix(tbl_entry.regval, matrix, OUTPUT_CSC_MATRIX_SIZE);
-
-	program_color_matrix(
-		opp80, &tbl_entry, adjust->color_adjust_option);
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_rgb_limited_range_adjustment
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for sRGB limited color space
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_rgb_limited_range_adjustment(
-	struct dce80_opp *opp80,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	struct out_csc_color_matrix reg_matrix;
-	struct fixed31_32 change_matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct dc_csc_adjustments adjustments;
-	struct fixed31_32 ideals[OUTPUT_CSC_MATRIX_SIZE];
-
-	prepare_tv_rgb_ideal(ideals);
-
-	setup_adjustments(adjust, &adjustments);
-
-	calculate_adjustments(ideals, &adjustments, matrix);
-
-	memmove(change_matrix, matrix, sizeof(matrix));
-
-	/* from 1 -> 3 */
-	matrix[8] = change_matrix[0];
-	matrix[9] = change_matrix[1];
-	matrix[10] = change_matrix[2];
-	matrix[11] = change_matrix[3];
-
-	/* from 2 -> 1 */
-	matrix[0] = change_matrix[4];
-	matrix[1] = change_matrix[5];
-	matrix[2] = change_matrix[6];
-	matrix[3] = change_matrix[7];
-
-	/* from 3 -> 2 */
-	matrix[4] = change_matrix[8];
-	matrix[5] = change_matrix[9];
-	matrix[6] = change_matrix[10];
-	matrix[7] = change_matrix[11];
-
-	memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
-
-	setup_reg_format(matrix, reg_matrix.regval);
-
-	program_color_matrix(opp80, &reg_matrix, GRPH_COLOR_MATRIX_SW);
-}
-
-static void prepare_yuv_ideal(
-	bool b601,
-	struct fixed31_32 *matrix)
-{
-	static const int32_t matrix_1[] = {
-		25578516, 50216016, 9752344, 6250000,
-		-14764391, -28985609, 43750000, 50000000,
-		43750000, -36635164, -7114836, 50000000
-	};
-
-	static const int32_t matrix_2[] = {
-		18187266, 61183125, 6176484, 6250000,
-		-10025059, -33724941, 43750000, 50000000,
-		43750000, -39738379, -4011621, 50000000
-	};
-
-	const int32_t *matrix_x = b601 ? matrix_1 : matrix_2;
-
-	uint32_t i = 0;
-
-	do {
-		matrix[i] = dal_fixed31_32_from_fraction(
-			matrix_x[i],
-			100000000);
-		++i;
-	} while (i != ARRAY_SIZE(matrix_1));
-}
-
-/**
- *****************************************************************************
- *  Function: dal_transform_wide_gamut_set_yuv_adjustment
- *
- *  @param [in] const struct opp_grph_csc_adjustment *adjust
- *
- *  @return
- *     void
- *
- *  @note calculate and program color adjustments for YUV  color spaces
- *
- *  @see
- *
- *****************************************************************************
- */
-static void set_yuv_adjustment(
-	struct dce80_opp *opp80,
-	const struct opp_grph_csc_adjustment *adjust)
-{
-	bool b601 = (adjust->c_space == COLOR_SPACE_YPBPR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED);
-	struct out_csc_color_matrix reg_matrix;
-	struct fixed31_32 matrix[OUTPUT_CSC_MATRIX_SIZE];
-	struct dc_csc_adjustments adjustments;
-	struct fixed31_32 ideals[OUTPUT_CSC_MATRIX_SIZE];
-
-	prepare_yuv_ideal(b601, ideals);
-
-	setup_adjustments(adjust, &adjustments);
-
-	if ((adjust->c_space == COLOR_SPACE_YCBCR601_LIMITED) ||
-		(adjust->c_space == COLOR_SPACE_YCBCR709_LIMITED))
-		calculate_adjustments_y_only(
-			ideals, &adjustments, matrix);
-	else
-		calculate_adjustments(
-			ideals, &adjustments, matrix);
-
-	memset(&reg_matrix, 0, sizeof(struct out_csc_color_matrix));
-
-	setup_reg_format(matrix, reg_matrix.regval);
-
-	program_color_matrix(opp80, &reg_matrix, GRPH_COLOR_MATRIX_SW);
-}
-
 static bool configure_graphics_mode(
 	struct dce80_opp *opp80,
 	enum csc_color_mode config,
@@ -824,40 +305,17 @@ static bool configure_graphics_mode(
 
 void dce80_opp_set_csc_adjustment(
 	struct output_pixel_processor *opp,
-	const struct opp_grph_csc_adjustment *adjust)
+	const struct out_csc_color_matrix *tbl_entry)
 {
 	struct dce80_opp *opp80 = TO_DCE80_OPP(opp);
 	enum csc_color_mode config =
 			CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
 
-	/* Apply color adjustments: brightness, saturation, hue, contrast and
-	 * CSC. No need for different color space routine, color space defines
-	 * the ideal values only, but keep original design to allow quick switch
-	 * to the old legacy routines */
-	switch (adjust->c_space) {
-	case COLOR_SPACE_SRGB:
-		set_rgb_adjustment_legacy(opp80, adjust);
-		break;
-	case COLOR_SPACE_SRGB_LIMITED:
-		set_rgb_limited_range_adjustment(
-			opp80, adjust);
-		break;
-	case COLOR_SPACE_YCBCR601:
-	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_LIMITED:
-	case COLOR_SPACE_YCBCR709_LIMITED:
-	case COLOR_SPACE_YPBPR601:
-	case COLOR_SPACE_YPBPR709:
-		set_yuv_adjustment(opp80, adjust);
-		break;
-	default:
-		set_rgb_adjustment_legacy(opp80, adjust);
-		break;
-	}
+	program_color_matrix(opp80, tbl_entry, GRAPHICS_CSC_ADJUST_TYPE_SW);
 
 	/*  We did everything ,now program DxOUTPUT_CSC_CONTROL */
-	configure_graphics_mode(opp80, config, adjust->csc_adjust_type,
-		adjust->c_space);
+	configure_graphics_mode(opp80, config, GRAPHICS_CSC_ADJUST_TYPE_SW,
+				tbl_entry->color_space);
 }
 
 void dce80_opp_set_csc_default(
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
index ebe966c..0bcaa0c 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
@@ -246,6 +246,11 @@ struct opp_grph_csc_adjustment {
 	int32_t grph_hue;
 };
 
+struct out_csc_color_matrix {
+	enum dc_color_space color_space;
+	uint16_t regval[12];
+};
+
 /* Underlay related types */
 
 struct hw_adjustment_range {
@@ -281,7 +286,7 @@ struct opp_funcs {
 
 	void (*opp_set_csc_adjustment)(
 		struct output_pixel_processor *opp,
-		const struct opp_grph_csc_adjustment *adjust);
+		const struct out_csc_color_matrix *tbl_entry);
 
 	void (*opp_set_csc_default)(
 		struct output_pixel_processor *opp,
diff --git a/drivers/gpu/drm/amd/dal/modules/color/color.c b/drivers/gpu/drm/amd/dal/modules/color/color.c
index a400fbf..f3a653b 100644
--- a/drivers/gpu/drm/amd/dal/modules/color/color.c
+++ b/drivers/gpu/drm/amd/dal/modules/color/color.c
@@ -30,13 +30,15 @@
 #include "fixed31_32.h"
 
 #define MOD_COLOR_MAX_CONCURRENT_SINKS 32
+#define DIVIDER 10000
+/* S2D13 value in [-3.00...0.9999] */
+#define S2D13_MIN (-3 * DIVIDER)
+#define S2D13_MAX (3 * DIVIDER)
 
 struct sink_caps {
 	const struct dc_sink *sink;
 };
 
-const unsigned int gamut_divider = 10000;
-
 struct gamut_calculation_matrix {
 	struct fixed31_32 MTransposed[9];
 	struct fixed31_32 XYZtoRGB_Custom[9];
@@ -60,6 +62,10 @@ struct color_state {
 	int custom_color_temperature;
 	struct color_space_coordinates source_gamut;
 	struct color_space_coordinates destination_gamut;
+	struct color_range contrast;
+	struct color_range saturation;
+	struct color_range brightness;
+	struct color_range hue;
 };
 
 struct core_color {
@@ -362,21 +368,21 @@ static bool build_gamut_remap_matrix
 		struct fixed31_32 *white_point_matrix)
 {
 	struct fixed31_32 fixed_blueX = dal_fixed31_32_from_fraction
-			(gamut_description.blueX, gamut_divider);
+			(gamut_description.blueX, DIVIDER);
 	struct fixed31_32 fixed_blueY = dal_fixed31_32_from_fraction
-			(gamut_description.blueY, gamut_divider);
+			(gamut_description.blueY, DIVIDER);
 	struct fixed31_32 fixed_greenX = dal_fixed31_32_from_fraction
-			(gamut_description.greenX, gamut_divider);
+			(gamut_description.greenX, DIVIDER);
 	struct fixed31_32 fixed_greenY = dal_fixed31_32_from_fraction
-			(gamut_description.greenY, gamut_divider);
+			(gamut_description.greenY, DIVIDER);
 	struct fixed31_32 fixed_redX = dal_fixed31_32_from_fraction
-			(gamut_description.redX, gamut_divider);
+			(gamut_description.redX, DIVIDER);
 	struct fixed31_32 fixed_redY = dal_fixed31_32_from_fraction
-			(gamut_description.redY, gamut_divider);
+			(gamut_description.redY, DIVIDER);
 	struct fixed31_32 fixed_whiteX = dal_fixed31_32_from_fraction
-			(gamut_description.whiteX, gamut_divider);
+			(gamut_description.whiteX, DIVIDER);
 	struct fixed31_32 fixed_whiteY = dal_fixed31_32_from_fraction
-			(gamut_description.whiteY, gamut_divider);
+			(gamut_description.whiteY, DIVIDER);
 
 	rgb_matrix[0] = dal_fixed31_32_div(fixed_redX, fixed_redY);
 	rgb_matrix[1] = dal_fixed31_32_one;
@@ -413,6 +419,156 @@ static bool check_dc_support(const struct dc *dc)
 	return true;
 }
 
+static uint16_t fixed_point_to_int_frac(
+	struct fixed31_32 arg,
+	uint8_t integer_bits,
+	uint8_t fractional_bits)
+{
+	int32_t numerator;
+	int32_t divisor = 1 << fractional_bits;
+
+	uint16_t result;
+
+	uint16_t d = (uint16_t)dal_fixed31_32_floor(
+		dal_fixed31_32_abs(
+			arg));
+
+	if (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor))
+		numerator = (uint16_t)dal_fixed31_32_floor(
+			dal_fixed31_32_mul_int(
+				arg,
+				divisor));
+	else {
+		numerator = dal_fixed31_32_floor(
+			dal_fixed31_32_sub(
+				dal_fixed31_32_from_int(
+					1LL << integer_bits),
+				dal_fixed31_32_recip(
+					dal_fixed31_32_from_int(
+						divisor))));
+	}
+
+	if (numerator >= 0)
+		result = (uint16_t)numerator;
+	else
+		result = (uint16_t)(
+		(1 << (integer_bits + fractional_bits + 1)) + numerator);
+
+	if ((result != 0) && dal_fixed31_32_lt(
+		arg, dal_fixed31_32_zero))
+		result |= 1 << (integer_bits + fractional_bits);
+
+	return result;
+}
+
+/**
+* convert_float_matrix
+* This converts a double into HW register spec defined format S2D13.
+* @param :
+* @return None
+*/
+static void convert_float_matrix(
+	uint16_t *matrix,
+	struct fixed31_32 *flt,
+	uint32_t buffer_size)
+{
+	const struct fixed31_32 min_2_13 =
+		dal_fixed31_32_from_fraction(S2D13_MIN, DIVIDER);
+	const struct fixed31_32 max_2_13 =
+		dal_fixed31_32_from_fraction(S2D13_MAX, DIVIDER);
+	uint32_t i;
+
+	for (i = 0; i < buffer_size; ++i) {
+		uint32_t reg_value =
+				fixed_point_to_int_frac(
+					dal_fixed31_32_clamp(
+						flt[i],
+						min_2_13,
+						max_2_13),
+						2,
+						13);
+
+		matrix[i] = (uint16_t)reg_value;
+	}
+}
+
+static int get_hw_value_from_sw_value(int swVal, int swMin,
+		int swMax, int hwMin, int hwMax)
+{
+	int dSW = swMax - swMin; /*software adjustment range size*/
+	int dHW = hwMax - hwMin; /*hardware adjustment range size*/
+	int hwVal; /*HW adjustment value*/
+
+	/* error case, I preserve the behavior from the predecessor
+	 *getHwStepFromSwHwMinMaxValue (removed in Feb 2013)
+	 *which was the FP version that only computed SCLF (i.e. dHW/dSW).
+	 *it would return 0 in this case so
+	 *hwVal = hwMin from the formula given in @brief
+	*/
+	if (dSW == 0)
+		return hwMin;
+
+	/*it's quite often that ranges match,
+	 *e.g. for overlay colors currently (Feb 2013)
+	 *only brightness has a different
+	 *HW range, and in this case no multiplication or division is needed,
+	 *and if minimums match, no calculation at all
+	*/
+	if (dSW != dHW) {
+		hwVal = (swVal - swMin)*dHW/dSW + hwMin;
+	} else {
+		hwVal = swVal;
+		if (swMin != hwMin)
+			hwVal += (hwMin - swMin);
+	}
+
+	return hwVal;
+}
+
+static void initialize_fix_point_color_values(
+	struct core_color *core_color,
+	unsigned int sink_index,
+	struct fixed31_32 *grph_cont,
+	struct fixed31_32 *grph_sat,
+	struct fixed31_32 *grph_bright,
+	struct fixed31_32 *sin_grph_hue,
+	struct fixed31_32 *cos_grph_hue)
+{
+	/* Hue adjustment could be negative. -45 ~ +45 */
+	struct fixed31_32 hue =
+		dal_fixed31_32_mul(
+			dal_fixed31_32_from_fraction
+			(get_hw_value_from_sw_value
+				(core_color->state[sink_index].hue.current,
+				core_color->state[sink_index].hue.min,
+				core_color->state[sink_index].hue.max,
+				-30, 30), 180),
+			dal_fixed31_32_pi);
+
+	*sin_grph_hue = dal_fixed31_32_sin(hue);
+	*cos_grph_hue = dal_fixed31_32_cos(hue);
+
+	*grph_cont =
+		dal_fixed31_32_from_fraction(get_hw_value_from_sw_value
+			(core_color->state[sink_index].contrast.current,
+			core_color->state[sink_index].contrast.min,
+			core_color->state[sink_index].contrast.max,
+			50, 150), 100);
+	*grph_sat =
+		dal_fixed31_32_from_fraction(get_hw_value_from_sw_value
+			(core_color->state[sink_index].saturation.current,
+			core_color->state[sink_index].saturation.min,
+			core_color->state[sink_index].saturation.max,
+			0, 200), 100);
+	*grph_bright =
+		dal_fixed31_32_from_fraction(get_hw_value_from_sw_value
+			(core_color->state[sink_index].brightness.current,
+			core_color->state[sink_index].brightness.min,
+			core_color->state[sink_index].brightness.max,
+			-25, 25), 100);
+}
+
+
 /* Given a specific dc_sink* this function finds its equivalent
  * on the dc_sink array and returns the corresponding index
  */
@@ -430,6 +586,479 @@ static unsigned int sink_index_from_sink(struct core_color *core_color,
 	return index;
 }
 
+static void calculate_rgb_matrix(struct core_color *core_color,
+		unsigned int sink_index,
+		struct fixed31_32 *rgb_matrix)
+{
+	const struct fixed31_32 k1 =
+		dal_fixed31_32_from_fraction(701000, 1000000);
+	const struct fixed31_32 k2 =
+		dal_fixed31_32_from_fraction(236568, 1000000);
+	const struct fixed31_32 k3 =
+		dal_fixed31_32_from_fraction(-587000, 1000000);
+	const struct fixed31_32 k4 =
+		dal_fixed31_32_from_fraction(464432, 1000000);
+	const struct fixed31_32 k5 =
+		dal_fixed31_32_from_fraction(-114000, 1000000);
+	const struct fixed31_32 k6 =
+		dal_fixed31_32_from_fraction(-701000, 1000000);
+	const struct fixed31_32 k7 =
+		dal_fixed31_32_from_fraction(-299000, 1000000);
+	const struct fixed31_32 k8 =
+		dal_fixed31_32_from_fraction(-292569, 1000000);
+	const struct fixed31_32 k9 =
+		dal_fixed31_32_from_fraction(413000, 1000000);
+	const struct fixed31_32 k10 =
+		dal_fixed31_32_from_fraction(-92482, 1000000);
+	const struct fixed31_32 k11 =
+		dal_fixed31_32_from_fraction(-114000, 1000000);
+	const struct fixed31_32 k12 =
+		dal_fixed31_32_from_fraction(385051, 1000000);
+	const struct fixed31_32 k13 =
+		dal_fixed31_32_from_fraction(-299000, 1000000);
+	const struct fixed31_32 k14 =
+		dal_fixed31_32_from_fraction(886000, 1000000);
+	const struct fixed31_32 k15 =
+		dal_fixed31_32_from_fraction(-587000, 1000000);
+	const struct fixed31_32 k16 =
+		dal_fixed31_32_from_fraction(-741914, 1000000);
+	const struct fixed31_32 k17 =
+		dal_fixed31_32_from_fraction(886000, 1000000);
+	const struct fixed31_32 k18 =
+		dal_fixed31_32_from_fraction(-144086, 1000000);
+
+	const struct fixed31_32 luma_r =
+		dal_fixed31_32_from_fraction(299, 1000);
+	const struct fixed31_32 luma_g =
+		dal_fixed31_32_from_fraction(587, 1000);
+	const struct fixed31_32 luma_b =
+		dal_fixed31_32_from_fraction(114, 1000);
+
+	struct fixed31_32 grph_cont;
+	struct fixed31_32 grph_sat;
+	struct fixed31_32 grph_bright;
+	struct fixed31_32 sin_grph_hue;
+	struct fixed31_32 cos_grph_hue;
+
+	initialize_fix_point_color_values(
+		core_color, sink_index, &grph_cont, &grph_sat,
+		&grph_bright, &sin_grph_hue, &cos_grph_hue);
+
+	/* COEF_1_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 +*/
+	/* Sin(GrphHue) * K2))*/
+	/* (Cos(GrphHue) * K1 + Sin(GrphHue) * K2)*/
+	rgb_matrix[0] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k1),
+			dal_fixed31_32_mul(sin_grph_hue, k2));
+	/* GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2 */
+	rgb_matrix[0] = dal_fixed31_32_mul(grph_sat, rgb_matrix[0]);
+	/* (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue) * K2))*/
+	rgb_matrix[0] = dal_fixed31_32_add(luma_r, rgb_matrix[0]);
+	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K1 + Sin(GrphHue)**/
+	/* K2))*/
+	rgb_matrix[0] = dal_fixed31_32_mul(grph_cont, rgb_matrix[0]);
+
+	/* COEF_1_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 +*/
+	/* Sin(GrphHue) * K4))*/
+	/* (Cos(GrphHue) * K3 + Sin(GrphHue) * K4)*/
+	rgb_matrix[1] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k3),
+			dal_fixed31_32_mul(sin_grph_hue, k4));
+	/* GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4)*/
+	rgb_matrix[1] = dal_fixed31_32_mul(grph_sat, rgb_matrix[1]);
+	/* (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue) * K4))*/
+	rgb_matrix[1] = dal_fixed31_32_add(luma_g, rgb_matrix[1]);
+	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K3 + Sin(GrphHue)**/
+	/* K4))*/
+	rgb_matrix[1] = dal_fixed31_32_mul(grph_cont, rgb_matrix[1]);
+
+	/* COEF_1_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K5 +*/
+	/* Sin(GrphHue) * K6))*/
+	/* (Cos(GrphHue) * K5 + Sin(GrphHue) * K6)*/
+	rgb_matrix[2] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k5),
+			dal_fixed31_32_mul(sin_grph_hue, k6));
+	/* GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6)*/
+	rgb_matrix[2] = dal_fixed31_32_mul(grph_sat, rgb_matrix[2]);
+	/* LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue) * K6)*/
+	rgb_matrix[2] = dal_fixed31_32_add(luma_b, rgb_matrix[2]);
+	/* GrphCont  * (LumaB + GrphSat * (Cos(GrphHue) * K5 + Sin(GrphHue)**/
+	/* K6))*/
+	rgb_matrix[2] = dal_fixed31_32_mul(grph_cont, rgb_matrix[2]);
+
+	/* COEF_1_4 = GrphBright*/
+	rgb_matrix[3] = grph_bright;
+
+	/* COEF_2_1 = GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 +*/
+	/* Sin(GrphHue) * K8))*/
+	/* (Cos(GrphHue) * K7 + Sin(GrphHue) * K8)*/
+	rgb_matrix[4] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k7),
+			dal_fixed31_32_mul(sin_grph_hue, k8));
+	/* GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8)*/
+	rgb_matrix[4] = dal_fixed31_32_mul(grph_sat, rgb_matrix[4]);
+	/* (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue) * K8))*/
+	rgb_matrix[4] = dal_fixed31_32_add(luma_r, rgb_matrix[4]);
+	/* GrphCont * (LumaR + GrphSat * (Cos(GrphHue) * K7 + Sin(GrphHue)**/
+	/* K8))*/
+	rgb_matrix[4] = dal_fixed31_32_mul(grph_cont, rgb_matrix[4]);
+
+	/* COEF_2_2 = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 +*/
+	/* Sin(GrphHue) * K10))*/
+	/* (Cos(GrphHue) * K9 + Sin(GrphHue) * K10))*/
+	rgb_matrix[5] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k9),
+			dal_fixed31_32_mul(sin_grph_hue, k10));
+	/* GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10))*/
+	rgb_matrix[5] = dal_fixed31_32_mul(grph_sat, rgb_matrix[5]);
+	/* (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue) * K10))*/
+	rgb_matrix[5] = dal_fixed31_32_add(luma_g, rgb_matrix[5]);
+	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K9 + Sin(GrphHue)**/
+	/* K10))*/
+	rgb_matrix[5] = dal_fixed31_32_mul(grph_cont, rgb_matrix[5]);
+
+	/* COEF_2_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 +*/
+	/* Sin(GrphHue) * K12))*/
+	/* (Cos(GrphHue) * K11 + Sin(GrphHue) * K12))*/
+	rgb_matrix[6] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k11),
+			dal_fixed31_32_mul(sin_grph_hue, k12));
+	/* GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12))*/
+	rgb_matrix[6] = dal_fixed31_32_mul(grph_sat, rgb_matrix[6]);
+	/* (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue) * K12))*/
+	rgb_matrix[6] = dal_fixed31_32_add(luma_b, rgb_matrix[6]);
+	/* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K11 + Sin(GrphHue)**/
+	/* K12))*/
+	rgb_matrix[6] = dal_fixed31_32_mul(grph_cont, rgb_matrix[6]);
+
+	/* COEF_2_4 = GrphBright*/
+	rgb_matrix[7] = grph_bright;
+
+	/* COEF_3_1 = GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 +*/
+	/* Sin(GrphHue) * K14))*/
+	/* (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
+	rgb_matrix[8] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k13),
+			dal_fixed31_32_mul(sin_grph_hue, k14));
+	/* GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
+	rgb_matrix[8] = dal_fixed31_32_mul(grph_sat, rgb_matrix[8]);
+	/* (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue) * K14)) */
+	rgb_matrix[8] = dal_fixed31_32_add(luma_r, rgb_matrix[8]);
+	/* GrphCont  * (LumaR + GrphSat * (Cos(GrphHue) * K13 + Sin(GrphHue)**/
+	/* K14)) */
+	rgb_matrix[8] = dal_fixed31_32_mul(grph_cont, rgb_matrix[8]);
+
+	/* COEF_3_2    = GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 +*/
+	/* Sin(GrphHue) * K16)) */
+	/* GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16) */
+	rgb_matrix[9] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k15),
+			dal_fixed31_32_mul(sin_grph_hue, k16));
+	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
+	rgb_matrix[9] = dal_fixed31_32_mul(grph_sat, rgb_matrix[9]);
+	/* (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue) * K16)) */
+	rgb_matrix[9] = dal_fixed31_32_add(luma_g, rgb_matrix[9]);
+	/* GrphCont * (LumaG + GrphSat * (Cos(GrphHue) * K15 + Sin(GrphHue)**/
+	/* K16)) */
+	rgb_matrix[9] = dal_fixed31_32_mul(grph_cont, rgb_matrix[9]);
+
+	/*  COEF_3_3 = GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 +*/
+	/* Sin(GrphHue) * K18)) */
+	/* (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
+	rgb_matrix[10] =
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(cos_grph_hue, k17),
+			dal_fixed31_32_mul(sin_grph_hue, k18));
+	/*  GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
+	rgb_matrix[10] = dal_fixed31_32_mul(grph_sat, rgb_matrix[10]);
+	/* (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue) * K18)) */
+	rgb_matrix[10] = dal_fixed31_32_add(luma_b, rgb_matrix[10]);
+	/* GrphCont * (LumaB + GrphSat * (Cos(GrphHue) * K17 + Sin(GrphHue)**/
+	/* K18)) */
+	rgb_matrix[10] = dal_fixed31_32_mul(grph_cont, rgb_matrix[10]);
+
+	/* COEF_3_4 = GrphBright */
+	rgb_matrix[11] = grph_bright;
+}
+
+static void calculate_rgb_limited_range_matrix(struct core_color *core_color,
+		unsigned int sink_index, struct fixed31_32 *rgb_matrix)
+{
+	struct fixed31_32 ideal[12];
+
+	static const int32_t matrix_[] = {
+			85546875, 0, 0, 6250000,
+			0, 85546875, 0, 6250000,
+			0, 0, 85546875, 6250000
+		};
+
+	uint32_t i = 0;
+
+	do {
+		ideal[i] = dal_fixed31_32_from_fraction(
+			matrix_[i],
+			100000000);
+		++i;
+	} while (i != ARRAY_SIZE(matrix_));
+
+
+	struct fixed31_32 grph_cont;
+	struct fixed31_32 grph_sat;
+	struct fixed31_32 grph_bright;
+	struct fixed31_32 sin_grph_hue;
+	struct fixed31_32 cos_grph_hue;
+
+	initialize_fix_point_color_values(
+		core_color, sink_index, &grph_cont, &grph_sat,
+		&grph_bright, &sin_grph_hue, &cos_grph_hue);
+
+	const struct fixed31_32 multiplier =
+		dal_fixed31_32_mul(grph_cont, grph_sat);
+
+	rgb_matrix[8] = dal_fixed31_32_mul(ideal[0], grph_cont);
+
+	rgb_matrix[9] = dal_fixed31_32_mul(ideal[1], grph_cont);
+
+	rgb_matrix[10] = dal_fixed31_32_mul(ideal[2], grph_cont);
+
+	rgb_matrix[11] = dal_fixed31_32_add(
+			ideal[3],
+			dal_fixed31_32_mul(
+				grph_bright,
+				dal_fixed31_32_from_fraction(86, 100)));
+
+	rgb_matrix[0] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(
+				ideal[8],
+				sin_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[4],
+				cos_grph_hue)));
+
+	rgb_matrix[1] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(
+				ideal[9],
+				sin_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[5],
+				cos_grph_hue)));
+
+	rgb_matrix[2] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(
+				ideal[10],
+				sin_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[6],
+				cos_grph_hue)));
+
+	rgb_matrix[3] = ideal[7];
+
+	rgb_matrix[4] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_sub(
+			dal_fixed31_32_mul(
+				ideal[8],
+				cos_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[4],
+				sin_grph_hue)));
+
+	rgb_matrix[5] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_sub(
+			dal_fixed31_32_mul(
+				ideal[9],
+				cos_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[5],
+				sin_grph_hue)));
+
+	rgb_matrix[6] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_sub(
+			dal_fixed31_32_mul(
+				ideal[10],
+				cos_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[6],
+				sin_grph_hue)));
+
+	rgb_matrix[7] = ideal[11];
+}
+
+static void calculate_yuv_matrix(struct core_color *core_color,
+		unsigned int sink_index,
+		enum dc_color_space color_space,
+		struct fixed31_32 *yuv_matrix)
+{
+	struct fixed31_32 ideal[12];
+	uint32_t i = 0;
+
+	if ((color_space == COLOR_SPACE_YPBPR601) ||
+			(color_space == COLOR_SPACE_YCBCR601) ||
+			(color_space == COLOR_SPACE_YCBCR601_LIMITED)) {
+		static const int32_t matrix_[] = {
+				25578516, 50216016, 9752344, 6250000,
+				-14764391, -28985609, 43750000, 50000000,
+				43750000, -36635164, -7114836, 50000000
+			};
+		do {
+			ideal[i] = dal_fixed31_32_from_fraction(
+					matrix_[i],
+				100000000);
+			++i;
+		} while (i != ARRAY_SIZE(matrix_));
+	} else {
+		static const int32_t matrix_[] = {
+				18187266, 61183125, 6176484, 6250000,
+				-10025059, -33724941, 43750000, 50000000,
+				43750000, -39738379, -4011621, 50000000
+			};
+		do {
+			ideal[i] = dal_fixed31_32_from_fraction(
+					matrix_[i],
+				100000000);
+			++i;
+		} while (i != ARRAY_SIZE(matrix_));
+	}
+
+	struct fixed31_32 grph_cont;
+	struct fixed31_32 grph_sat;
+	struct fixed31_32 grph_bright;
+	struct fixed31_32 sin_grph_hue;
+	struct fixed31_32 cos_grph_hue;
+
+	initialize_fix_point_color_values(
+		core_color, sink_index, &grph_cont, &grph_sat,
+		&grph_bright, &sin_grph_hue, &cos_grph_hue);
+
+	const struct fixed31_32 multiplier =
+			dal_fixed31_32_mul(grph_cont, grph_sat);
+
+	yuv_matrix[0] = dal_fixed31_32_mul(ideal[0], grph_cont);
+
+	yuv_matrix[1] = dal_fixed31_32_mul(ideal[1], grph_cont);
+
+	yuv_matrix[2] = dal_fixed31_32_mul(ideal[2], grph_cont);
+
+	yuv_matrix[4] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(
+				ideal[8],
+				sin_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[4],
+				cos_grph_hue)));
+
+	yuv_matrix[5] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(
+				ideal[9],
+				sin_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[5],
+				cos_grph_hue)));
+
+	yuv_matrix[6] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_add(
+			dal_fixed31_32_mul(
+				ideal[10],
+				sin_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[6],
+				cos_grph_hue)));
+
+	yuv_matrix[7] = ideal[7];
+
+	yuv_matrix[8] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_sub(
+			dal_fixed31_32_mul(
+				ideal[8],
+				cos_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[4],
+				sin_grph_hue)));
+
+	yuv_matrix[9] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_sub(
+			dal_fixed31_32_mul(
+				ideal[9],
+				cos_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[5],
+				sin_grph_hue)));
+
+	yuv_matrix[10] = dal_fixed31_32_mul(
+		multiplier,
+		dal_fixed31_32_sub(
+			dal_fixed31_32_mul(
+				ideal[10],
+				cos_grph_hue),
+			dal_fixed31_32_mul(
+				ideal[6],
+				sin_grph_hue)));
+
+	yuv_matrix[11] = ideal[11];
+
+	if ((color_space == COLOR_SPACE_YCBCR601_LIMITED) ||
+			(color_space == COLOR_SPACE_YCBCR709_LIMITED)) {
+		yuv_matrix[3] = dal_fixed31_32_add(ideal[3], grph_bright);
+	} else {
+		yuv_matrix[3] = dal_fixed31_32_add(
+			ideal[3],
+			dal_fixed31_32_mul(
+				grph_bright,
+				dal_fixed31_32_from_fraction(86, 100)));
+	}
+}
+
+static void calculate_csc_matrix(struct core_color *core_color,
+		unsigned int sink_index,
+		enum dc_color_space color_space,
+		struct fixed31_32 *csc_matrix)
+{
+	switch (color_space) {
+	case COLOR_SPACE_SRGB:
+		calculate_rgb_matrix(core_color, sink_index, csc_matrix);
+		break;
+	case COLOR_SPACE_SRGB_LIMITED:
+		calculate_rgb_limited_range_matrix(core_color, sink_index,
+				csc_matrix);
+		break;
+	case COLOR_SPACE_YCBCR601:
+	case COLOR_SPACE_YCBCR709:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
+	case COLOR_SPACE_YPBPR601:
+	case COLOR_SPACE_YPBPR709:
+		calculate_yuv_matrix(core_color, sink_index, color_space,
+				csc_matrix);
+		break;
+	default:
+		calculate_rgb_matrix(core_color, sink_index, csc_matrix);
+		break;
+	}
+}
+
 struct mod_color *mod_color_create(struct dc *dc)
 {
 	int i = 0;
@@ -471,6 +1100,22 @@ struct mod_color *mod_color_create(struct dc *dc)
 		core_color->state[i].destination_gamut.whiteY = 3290;
 
 		core_color->state[i].custom_color_temperature = 6500;
+
+		core_color->state[i].contrast.current = 100;
+		core_color->state[i].contrast.min = 0;
+		core_color->state[i].contrast.max = 200;
+
+		core_color->state[i].saturation.current = 100;
+		core_color->state[i].saturation.min = 0;
+		core_color->state[i].saturation.max = 200;
+
+		core_color->state[i].brightness.current = 0;
+		core_color->state[i].brightness.min = -100;
+		core_color->state[i].brightness.max = 100;
+
+		core_color->state[i].hue.current = 0;
+		core_color->state[i].hue.min = -30;
+		core_color->state[i].hue.max = 30;
 	}
 
 	if (core_color->state == NULL)
@@ -769,6 +1414,21 @@ bool mod_color_get_user_enable(struct mod_color *mod_color,
 	return true;
 }
 
+bool mod_color_get_custom_color_temperature(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		int *color_temperature)
+{
+	struct core_color *core_color =
+			MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int sink_index = sink_index_from_sink(core_color, sink);
+
+	*color_temperature = core_color->state[sink_index].
+			custom_color_temperature;
+
+	return true;
+}
+
 bool mod_color_set_custom_color_temperature(struct mod_color *mod_color,
 		const struct dc_stream **streams, int num_streams,
 		int color_temperature)
@@ -787,17 +1447,58 @@ bool mod_color_set_custom_color_temperature(struct mod_color *mod_color,
 	return true;
 }
 
-bool mod_color_get_custom_color_temperature(struct mod_color *mod_color,
+bool mod_color_get_color_saturation(struct mod_color *mod_color,
 		const struct dc_sink *sink,
-		int *color_temperature)
+		struct color_range *color_saturation)
 {
 	struct core_color *core_color =
 			MOD_COLOR_TO_CORE(mod_color);
 
 	unsigned int sink_index = sink_index_from_sink(core_color, sink);
 
-	*color_temperature = core_color->state[sink_index].
-			custom_color_temperature;
+	*color_saturation = core_color->state[sink_index].saturation;
+
+	return true;
+}
+
+bool mod_color_get_color_contrast(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_contrast)
+{
+	struct core_color *core_color =
+			MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int sink_index = sink_index_from_sink(core_color, sink);
+
+	*color_contrast = core_color->state[sink_index].contrast;
+
+	return true;
+}
+
+bool mod_color_get_color_brightness(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_brightness)
+{
+	struct core_color *core_color =
+			MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int sink_index = sink_index_from_sink(core_color, sink);
+
+	*color_brightness = core_color->state[sink_index].brightness;
+
+	return true;
+}
+
+bool mod_color_get_color_hue(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_hue)
+{
+	struct core_color *core_color =
+			MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int sink_index = sink_index_from_sink(core_color, sink);
+
+	*color_hue = core_color->state[sink_index].hue;
 
 	return true;
 }
@@ -889,4 +1590,158 @@ function_fail:
 	return false;
 }
 
+bool mod_color_set_brightness(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int brightness_value)
+{
+	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int stream_index, sink_index;
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+		sink_index = sink_index_from_sink(core_color,
+				streams[stream_index]->sink);
+
+		struct core_stream *core_stream =
+						DC_STREAM_TO_CORE
+						(streams[stream_index]);
+
+		core_color->state[sink_index].brightness.current =
+				brightness_value;
+
+		struct fixed31_32 csc_matrix_fixed[12];
+
+		calculate_csc_matrix(core_color, sink_index,
+				core_stream->public.output_color_space,
+				csc_matrix_fixed);
+
+		convert_float_matrix(
+				core_stream->public.csc_color_matrix.matrix,
+				csc_matrix_fixed,
+				12);
+
+		core_stream->public.csc_color_matrix.enable_adjustment = true;
+	}
+
+	core_color->dc->stream_funcs.set_gamut_remap
+			(core_color->dc, streams, num_streams);
+
+	return true;
+}
+
+bool mod_color_set_contrast(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int contrast_value)
+{
+	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int stream_index, sink_index;
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+		sink_index = sink_index_from_sink(core_color,
+				streams[stream_index]->sink);
+
+		struct core_stream *core_stream =
+						DC_STREAM_TO_CORE
+						(streams[stream_index]);
+
+		core_color->state[sink_index].contrast.current =
+				contrast_value;
+
+		struct fixed31_32 csc_matrix_fixed[12];
+
+		calculate_csc_matrix(core_color, sink_index,
+				core_stream->public.output_color_space,
+				csc_matrix_fixed);
+
+		convert_float_matrix(
+				core_stream->public.csc_color_matrix.matrix,
+				csc_matrix_fixed,
+				12);
+
+		core_stream->public.csc_color_matrix.enable_adjustment = true;
+	}
+
+	core_color->dc->stream_funcs.set_gamut_remap
+			(core_color->dc, streams, num_streams);
+
+	return true;
+}
+
+bool mod_color_set_hue(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int hue_value)
+{
+	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int stream_index, sink_index;
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+		sink_index = sink_index_from_sink(core_color,
+				streams[stream_index]->sink);
+
+		struct core_stream *core_stream =
+						DC_STREAM_TO_CORE
+						(streams[stream_index]);
+
+		core_color->state[sink_index].hue.current = hue_value;
+
+		struct fixed31_32 csc_matrix_fixed[12];
+
+		calculate_csc_matrix(core_color, sink_index,
+				core_stream->public.output_color_space,
+				csc_matrix_fixed);
+
+		convert_float_matrix(
+				core_stream->public.csc_color_matrix.matrix,
+				csc_matrix_fixed,
+				12);
+
+		core_stream->public.csc_color_matrix.enable_adjustment = true;
+	}
+
+	core_color->dc->stream_funcs.set_gamut_remap
+			(core_color->dc, streams, num_streams);
+
+	return true;
+}
+
+bool mod_color_set_saturation(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int saturation_value)
+{
+	struct core_color *core_color = MOD_COLOR_TO_CORE(mod_color);
+
+	unsigned int stream_index, sink_index;
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+		sink_index = sink_index_from_sink(core_color,
+				streams[stream_index]->sink);
+
+		struct core_stream *core_stream =
+						DC_STREAM_TO_CORE
+						(streams[stream_index]);
+
+		core_color->state[sink_index].saturation.current =
+				saturation_value;
+
+		struct fixed31_32 csc_matrix_fixed[12];
+
+		calculate_csc_matrix(core_color, sink_index,
+				core_stream->public.output_color_space,
+				csc_matrix_fixed);
+
+		convert_float_matrix(
+				core_stream->public.csc_color_matrix.matrix,
+				csc_matrix_fixed,
+				12);
+
+		core_stream->public.csc_color_matrix.enable_adjustment = true;
+	}
+
+	core_color->dc->stream_funcs.set_gamut_remap
+			(core_color->dc, streams, num_streams);
+
+	return true;
+}
 
diff --git a/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h b/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
index 00f06de..82881e1 100644
--- a/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
+++ b/drivers/gpu/drm/amd/dal/modules/inc/mod_color.h
@@ -80,6 +80,12 @@ struct white_point_coodinates_entry {
 	unsigned int whiteY;
 };
 
+struct color_range {
+	int current;
+	int min;
+	int max;
+};
+
 struct mod_color *mod_color_create(struct dc *dc);
 
 void mod_color_destroy(struct mod_color *mod_color);
@@ -123,6 +129,22 @@ bool mod_color_set_custom_color_temperature(struct mod_color *mod_color,
 		const struct dc_stream **streams, int num_streams,
 		int color_temperature);
 
+bool mod_color_get_color_saturation(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_saturation);
+
+bool mod_color_get_color_contrast(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_contrast);
+
+bool mod_color_get_color_brightness(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_brightness);
+
+bool mod_color_get_color_hue(struct mod_color *mod_color,
+		const struct dc_sink *sink,
+		struct color_range *color_hue);
+
 bool mod_color_get_source_gamut(struct mod_color *mod_color,
 		const struct dc_sink *sink,
 		struct color_space_coordinates *source_gamut);
@@ -130,4 +152,20 @@ bool mod_color_get_source_gamut(struct mod_color *mod_color,
 bool mod_color_notify_mode_change(struct mod_color *mod_color,
 		const struct dc_stream **streams, int num_streams);
 
+bool mod_color_set_brightness(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int brightness_value);
+
+bool mod_color_set_contrast(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int contrast_value);
+
+bool mod_color_set_hue(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int hue_value);
+
+bool mod_color_set_saturation(struct mod_color *mod_color,
+		const struct dc_stream **streams, int num_streams,
+		int saturation_value);
+
 #endif /* MOD_COLOR_H_ */
-- 
2.7.4

