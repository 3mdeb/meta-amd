From 0ba4cde4088fab7b9b7583ad06e37b1e93172e53 Mon Sep 17 00:00:00 2001
From: Maruthi Bayyavarapu <maruthi.bayyavarapu@amd.com>
Date: Fri, 22 May 2015 12:46:42 -0400
Subject: [PATCH 246/401] drm/amd: add ACP driver support (v3)

This adds the ACP (Audio CoProcessor) IP driver and wires
it up to the amdgpu driver.  The ACP block provides the DMA
engine and bus for the i2s codec which is supported by an
alsa driver.  This is required for audio on APUs that
utilize an i2s codec.

v2: integrate i2s/az check patch
v3: s/amd_acp/amdgpu_acp/

Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
Reviewed-by: Maruthi Bayyavarapu <maruthi.bayyavarapu@amd.com>
Signed-off-by: Maruthi Bayyavarapu <maruthi.bayyavarapu@amd.com>
Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/acp/Kconfig              |   9 +
 drivers/gpu/drm/amd/acp/Makefile             |   9 +
 drivers/gpu/drm/amd/acp/acp_hw.c             | 952 +++++++++++++++++++++++++++
 drivers/gpu/drm/amd/acp/acp_hw.h             |  99 +++
 drivers/gpu/drm/amd/acp/include/acp_gfx_if.h |  49 ++
 drivers/gpu/drm/amd/acp/include/amd_acp.h    | 196 ++++++
 drivers/gpu/drm/amd/amdgpu/Makefile          |  14 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h          |  11 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c      | 201 ++++++
 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h      |  40 ++
 drivers/gpu/drm/amd/amdgpu/vi.c              |  12 +
 drivers/gpu/drm/amd/include/amd_shared.h     |   1 +
 12 files changed, 1592 insertions(+), 1 deletion(-)
 create mode 100644 drivers/gpu/drm/amd/acp/Kconfig
 create mode 100644 drivers/gpu/drm/amd/acp/Makefile
 create mode 100644 drivers/gpu/drm/amd/acp/acp_hw.c
 create mode 100644 drivers/gpu/drm/amd/acp/acp_hw.h
 create mode 100644 drivers/gpu/drm/amd/acp/include/acp_gfx_if.h
 create mode 100644 drivers/gpu/drm/amd/acp/include/amd_acp.h
 create mode 100644 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
 create mode 100644 drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h

diff --git a/drivers/gpu/drm/amd/acp/Kconfig b/drivers/gpu/drm/amd/acp/Kconfig
new file mode 100644
index 0000000..11c5faf
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/Kconfig
@@ -0,0 +1,9 @@
+menu "ACP Configuration"
+
+config DRM_AMD_ACP
+       bool "Enable ACP IP support"
+       default y
+       help
+	Choose this option to enable ACP IP support for AMD SOCs.
+
+endmenu
diff --git a/drivers/gpu/drm/amd/acp/Makefile b/drivers/gpu/drm/amd/acp/Makefile
new file mode 100644
index 0000000..c8c3303
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the ACP, which is a sub-component
+# of AMDSOC/AMDGPU drm driver.
+# It provides the HW control for ACP related functionalities.
+
+ccflags-y += -Idrivers/gpu/drm/amd/include/asic_reg/acp
+subdir-ccflags-y += -I$(AMDACPPATH)/ -I$(AMDACPPATH)/include
+
+AMD_ACP_FILES := $(AMDACPPATH)/acp_hw.o
diff --git a/drivers/gpu/drm/amd/acp/acp_hw.c b/drivers/gpu/drm/amd/acp/acp_hw.c
new file mode 100644
index 0000000..5a35a7d
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/acp_hw.c
@@ -0,0 +1,952 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ *
+ */
+
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+
+#define VISLANDS30_IV_SRCID_ACP                                0x000000a2  // 162
+
+#include "acp_gfx_if.h"
+#include "acp_hw.h"
+
+#include "acp_2_2_d.h"
+#include "acp_2_2_sh_mask.h"
+
+/* Configure a given dma channel parameters - enable/disble,
+ * number of descriptors, priority */
+
+static void config_acp_dma_channel(struct amd_acp_device *acp_dev, u8 ch_num,
+				   u16 dscr_strt_idx, u16 num_dscrs,
+				   enum acp_dma_priority_level priority_level)
+{
+	u32 dma_ctrl;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	/* read the dma control register and disable the channel run field */
+	dma_ctrl = cgs_read_register(acp_prv->cgs_device,
+				     mmACP_DMA_CNTL_0 + ch_num);
+	/* clear the dma channel control bits */
+	dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;
+
+	cgs_write_register(acp_prv->cgs_device, (mmACP_DMA_CNTL_0 + ch_num),
+			   dma_ctrl);
+
+	/* there is no transfer happening on this channel so
+	 * program DMAChDscrStrIdx to the index number of the first descriptor
+	 * to be processed.
+	 */
+	cgs_write_register(acp_prv->cgs_device,
+			   (mmACP_DMA_DSCR_STRT_IDX_0 + ch_num),
+			   (ACP_DMA_DSCR_STRT_IDX_0__DMAChDscrStrtIdx_MASK &
+			    dscr_strt_idx));
+
+	/* program DMAChDscrDscrCnt to the number of descriptors to be
+	 * processed in the transfer
+	 */
+	cgs_write_register(acp_prv->cgs_device,
+			   (mmACP_DMA_DSCR_CNT_0 + ch_num),
+			   (ACP_DMA_DSCR_CNT_0__DMAChDscrCnt_MASK & num_dscrs));
+
+	/* set DMAChPrioLvl according to the priority */
+	cgs_write_register(acp_prv->cgs_device,	(mmACP_DMA_PRIO_0 + ch_num),
+			   priority_level);
+}
+
+
+
+/* Initialize the dma descriptors location in SRAM and page size */
+static void acp_dma_descr_init(struct amd_acp_device *acp_dev)
+{
+	u32 sram_pte_offset = 0;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	/* SRAM starts at 0x04000000. From that offset one page (4KB) left for
+	 * filling DMA descriptors.sram_pte_offset = 0x04001000 , used for
+	 * filling system RAM's physical pages.
+	 * This becomes the ALSA's Ring buffer start address
+	 */
+	sram_pte_offset = ACP_DAGB_GRP_SRAM_BASE_ADDRESS;
+
+	/* snoopable */
+	sram_pte_offset |= ACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBSnoopSel_MASK;
+	/* Memmory is system mmemory */
+	sram_pte_offset |= ACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBTargetMemSel_MASK;
+	/* Page Enabled */
+	sram_pte_offset |= ACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBGrpEnable_MASK;
+
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DAGB_BASE_ADDR_GRP_1,
+			   sram_pte_offset);
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DAGB_PAGE_SIZE_GRP_1,
+			   PAGE_SIZE_4K_ENABLE);
+}
+
+/* Initialize a dma descriptor in SRAM based on descritor information passed */
+static void config_dma_descriptor_in_sram(struct amd_acp_device *acp_dev,
+					  u16 descr_idx,
+					  acp_dma_dscr_transfer_t *descr_info)
+{
+	u32 sram_offset;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	sram_offset = (descr_idx * sizeof(acp_dma_dscr_transfer_t));
+
+	/* program the source base address. */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Addr,
+			   sram_offset);
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Data,
+			   descr_info->src);
+	/* program the destination base address. */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Addr,
+			   (sram_offset + 4));
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Data,
+						descr_info->dest);
+
+	/* program the number of bytes to be transferred for this descriptor. */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Addr,
+			   (sram_offset + 8));
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SRBM_Targ_Idx_Data,
+			   descr_info->size_xfer_dir.val);
+}
+
+/* Initialize the DMA descriptor information */
+static void set_acp_sysmem_dma_descriptors(struct amd_acp_device *acp_dev,
+					   u32 size, int direction, u32 pte_offset)
+{
+	u16 dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12;
+	u16 num_descr;
+	acp_dma_dscr_transfer_t dmadscr[2];
+
+	num_descr = 2;
+
+	dmadscr[0].size_xfer_dir.val = (u32) 0x0;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12;
+		dmadscr[0].dest = ACP_SHARED_RAM_BANK_38_ADDRESS;
+		dmadscr[0].src = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS +
+			(pte_offset * PAGE_SIZE_4K);
+		dmadscr[0].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM;
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH14;
+		dmadscr[0].src = ACP_SHARED_RAM_BANK_47_ADDRESS;
+		dmadscr[0].dest = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS +
+			(pte_offset * PAGE_SIZE_4K);
+		dmadscr[0].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION;
+	}
+
+	/* allot 1 period size per descriptor = total size (size) /2
+	 * => params_buffer_bytes(params)/params_periods(params);
+	 */
+	dmadscr[0].size_xfer_dir.s.size = size / 2;
+
+	dmadscr[0].size_xfer_dir.s.ioc = (u32) 0x0;
+
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[0]);
+
+	dmadscr[1].size_xfer_dir.val = (u32) 0x0;
+	dmadscr[1].dest = dmadscr[0].dest + dmadscr[0].size_xfer_dir.s.size;
+	dmadscr[1].src = dmadscr[0].src + dmadscr[0].size_xfer_dir.s.size;
+	dmadscr[1].size_xfer_dir.s.size = dmadscr[0].size_xfer_dir.s.size;
+	dmadscr[1].size_xfer_dir.s.ioc = (u32) 0x0;
+
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_END_DMA_DESCR_CH12;
+		dmadscr[1].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM;
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_END_DMA_DESCR_CH14;
+		dmadscr[1].size_xfer_dir.s.trans_direction =
+		    ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION;
+	}
+
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[1]);
+
+	if (direction == STREAM_PLAYBACK) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12;
+		config_acp_dma_channel(acp_dev, SYSRAM_TO_ACP_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	} else if (direction == STREAM_CAPTURE) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH14;
+		config_acp_dma_channel(acp_dev, ACP_TO_SYSRAM_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	}
+}
+
+/* Initialize the i2s dma descriptors in SRAM */
+static void set_acp_to_i2s_dma_descriptors(struct amd_acp_device *acp_dev,
+					   u32 size, int direction)
+{
+
+	u16 num_descr;
+	u16 dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;
+	acp_dma_dscr_transfer_t dmadscr[2];
+
+	num_descr = 2;
+
+	/* Let I2s Know the direction of transfer and source/destination
+	 *  of data
+	 */
+	dmadscr[0].size_xfer_dir.val = (u32) 0x0;
+	dmadscr[0].size_xfer_dir.s.size = (size / 2);
+	dmadscr[0].size_xfer_dir.s.ioc = (u32) 0x1;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;
+		dmadscr[0].src = ACP_SHARED_RAM_BANK_38_ADDRESS;
+		dmadscr[0].size_xfer_dir.s.trans_direction = TO_ACP_I2S_1;
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH15;
+		dmadscr[0].dest = ACP_SHARED_RAM_BANK_47_ADDRESS;
+		dmadscr[0].size_xfer_dir.s.trans_direction = 0xa;
+	}
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[0]);
+
+	dmadscr[1].size_xfer_dir.val = (u32) 0x0;
+	dmadscr[1].size_xfer_dir.s.size = (size / 2);
+	dmadscr[1].size_xfer_dir.s.ioc = (u32) 0x1;
+	if (direction == STREAM_PLAYBACK) {
+		dma_dscr_idx = PLAYBACK_END_DMA_DESCR_CH13;
+		dmadscr[1].src = dmadscr[0].src +
+		    dmadscr[0].size_xfer_dir.s.size;
+		dmadscr[1].size_xfer_dir.s.trans_direction = TO_ACP_I2S_1;
+
+	} else if (direction == STREAM_CAPTURE) {
+		dma_dscr_idx = CAPTURE_END_DMA_DESCR_CH15;
+		dmadscr[1].dest = dmadscr[0].dest +
+		    dmadscr[0].size_xfer_dir.s.size;
+		dmadscr[1].size_xfer_dir.s.trans_direction = 0xa;
+	}
+	config_dma_descriptor_in_sram(acp_dev, dma_dscr_idx, &dmadscr[1]);
+
+	/* Configure the DMA channel with the above descriptore */
+	if (direction == STREAM_PLAYBACK) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;
+		config_acp_dma_channel(acp_dev, ACP_TO_I2S_DMA_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	} else if (direction == STREAM_CAPTURE) {
+		/* starting descriptor for this channel */
+		dma_dscr_idx = CAPTURE_START_DMA_DESCR_CH15;
+		config_acp_dma_channel(acp_dev, I2S_TO_ACP_DMA_CH_NUM,
+					dma_dscr_idx, num_descr,
+					ACP_DMA_PRIORITY_LEVEL_NORMAL);
+	}
+
+}
+
+static u16 get_dscr_idx(struct amd_acp_device *acp_dev, int direction)
+{
+	u16 dscr_idx;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK) {
+		dscr_idx = cgs_read_register(acp_prv->cgs_device,
+							mmACP_DMA_CUR_DSCR_13);
+		dscr_idx = (dscr_idx == PLAYBACK_START_DMA_DESCR_CH13) ?
+				PLAYBACK_END_DMA_DESCR_CH12 :
+				PLAYBACK_START_DMA_DESCR_CH12;
+	} else {
+		dscr_idx = cgs_read_register(acp_prv->cgs_device,
+							mmACP_DMA_CUR_DSCR_15);
+		dscr_idx = (dscr_idx == CAPTURE_START_DMA_DESCR_CH15) ?
+				CAPTURE_END_DMA_DESCR_CH14 :
+				CAPTURE_START_DMA_DESCR_CH14;
+	}
+
+	return dscr_idx;
+
+}
+
+/*	Create page table entries in ACP SRAM for the allocated memory */
+static void acp_pte_config(struct amd_acp_device *acp_dev, struct page *pg,
+			   u16 num_of_pages, u32 pte_offset)
+{
+	u16 page_idx;
+	u64 addr;
+	u32 low;
+	u32 high;
+	u32 offset;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	offset	= ACP_DAGB_GRP_SRBM_SRAM_BASE_OFFSET + (pte_offset * 8);
+	for (page_idx = 0; page_idx < (num_of_pages); page_idx++) {
+		/* Load the low address of page int ACP SRAM through SRBM */
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Addr,
+				   (offset + (page_idx * 8)));
+		addr = page_to_phys(pg);
+
+		low = lower_32_bits(addr);
+		high = upper_32_bits(addr);
+
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Data, low);
+
+		/* Load the High address of page int ACP SRAM through SRBM */
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Addr,
+				   (offset + (page_idx * 8) + 4));
+
+		/* page enable in ACP */
+		high |= BIT(31);
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_SRBM_Targ_Idx_Data, high);
+
+		/* Move to next physically contiguos page */
+		pg++;
+	}
+}
+
+
+/* enables/disables ACP's external interrupt */
+static void acp_enable_external_interrupts(struct amd_acp_device *acp_dev,
+					   int enable)
+{
+	u32 acp_ext_intr_enb;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	acp_ext_intr_enb = enable ?
+		ACP_EXTERNAL_INTR_ENB__ACPExtIntrEnb_MASK :
+		0;
+
+	/* Write the Software External Interrupt Enable register */
+	cgs_write_register(acp_prv->cgs_device,
+			   mmACP_EXTERNAL_INTR_ENB, acp_ext_intr_enb);
+}
+
+/*	Clear (acknowledge) DMA 'Interrupt on Complete' (IOC) in ACP
+ *	external interrupt status register
+ */
+static void acp_ext_stat_clear_dmaioc(struct amd_acp_device *acp_dev, u8 ch_num)
+{
+	u32 ext_intr_stat;
+	u32 chmask = BIT(ch_num);
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	ext_intr_stat = cgs_read_register(acp_prv->cgs_device,
+					  mmACP_EXTERNAL_INTR_STAT);
+	if (ext_intr_stat & (chmask <<
+			     ACP_EXTERNAL_INTR_STAT__DMAIOCStat__SHIFT)) {
+
+		ext_intr_stat &= (chmask <<
+				  ACP_EXTERNAL_INTR_STAT__DMAIOCAck__SHIFT);
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_EXTERNAL_INTR_STAT, ext_intr_stat);
+	}
+}
+
+/*	Check whether interrupt (IOC) is generated or not	*/
+static u16 acp_get_intr_flag(struct amd_acp_device *acp_dev)
+{
+	u32 ext_intr_status;
+	u32 intr_gen;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	ext_intr_status = cgs_read_register(acp_prv->cgs_device,
+					    mmACP_EXTERNAL_INTR_STAT);
+	intr_gen = (((ext_intr_status &
+		      ACP_EXTERNAL_INTR_STAT__DMAIOCStat_MASK) >>
+		     ACP_EXTERNAL_INTR_STAT__DMAIOCStat__SHIFT));
+
+	return intr_gen;
+}
+
+static int irq_set_source(void *private_data, unsigned src_id, unsigned type,
+								int enabled)
+{
+	struct amd_acp_device *acp_dev =
+		((struct acp_irq_prv *)private_data)->acp_dev;
+
+	if (src_id == VISLANDS30_IV_SRCID_ACP) {
+		acp_enable_external_interrupts(acp_dev, enabled);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+
+static inline void i2s_clear_irqs(struct amd_acp_device *acp_dev,
+				  int direction)
+{
+	u32 i = 0;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SSP_TOR0 + (0x10 * i)), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SMICSP_ROR0 +(0x10 * i)), 0);
+	}
+}
+
+static void i2s_disable_channels(struct amd_acp_device *acp_dev,
+					u32 stream)
+{
+	u32 i = 0;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (stream == STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SSP_TER0 + (0x10 * i)), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			cgs_write_register(acp_prv->cgs_device,
+					(mmACP_I2SMICSP_RER0 + (0x10 * i)), 0);
+	}
+}
+
+static void configure_i2s_stream(struct amd_acp_device *acp_dev,
+					struct acp_i2s_config *i2s_config)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (i2s_config->direction == STREAM_PLAYBACK) {
+		/* Transmit configuration register for data width */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_TCR0 + (0x10 *
+							i2s_config->ch_reg)),
+				   i2s_config->xfer_resolution);
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_TFCR0 + (0x10 *
+							 i2s_config->ch_reg)),
+				   0x02);
+
+		/* Read interrupt mask register */
+		i2s_config->irq =
+			cgs_read_register(acp_prv->cgs_device,
+					  (mmACP_I2SSP_IMR0 +
+					   (0x10 * i2s_config->ch_reg)));
+		/* TX FIFO Overrun,Empty interrupts */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_IMR0 + (0x10 *
+							i2s_config->ch_reg)),
+				   (i2s_config->irq & ~0x30));
+		/*Enable Transmit */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SSP_TER0 + (0x10 *
+							i2s_config->ch_reg)), 1);
+	} else {
+		/* Receive configuration register for data width */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_RCR0 + (0x10 *
+							   i2s_config->ch_reg)),
+				   i2s_config->xfer_resolution);
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_RFCR0 + (0x10 *
+							    i2s_config->ch_reg)), 0x07);
+		/*Read interrupt mask register */
+		i2s_config->irq = cgs_read_register(acp_prv->cgs_device,
+						    (mmACP_I2SMICSP_IMR0 +
+						     (0x10 * i2s_config->ch_reg)));
+
+		/* TX FIFO Overrun,Empty interrupts */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_IMR0 + (0x10 *
+							   i2s_config->ch_reg)),
+				   i2s_config->irq & ~0x03);
+		/*Enable Receive */
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_I2SMICSP_RER0 + (0x10 *
+							   i2s_config->ch_reg)), 1);
+
+	}
+}
+
+static void config_acp_dma(struct amd_acp_device *acp_dev,
+			   struct acp_dma_config *dma_config)
+{
+	u32 pte_offset;
+
+	if (dma_config->direction == STREAM_PLAYBACK)
+		pte_offset = PLAYBACK_PTE_OFFSET;
+	else
+		pte_offset = CAPTURE_PTE_OFFSET;
+
+	acp_pte_config(acp_dev, dma_config->pg,	dma_config->num_of_pages,
+		       pte_offset);
+
+	/* Configure System memory to acp dma descriptors */
+	set_acp_sysmem_dma_descriptors(acp_dev, dma_config->size,
+				       dma_config->direction,
+				       pte_offset);
+
+	/* Configure acp to i2s dma descriptors */
+	set_acp_to_i2s_dma_descriptors(acp_dev, dma_config->size,
+				       dma_config->direction);
+}
+
+/* Start a given dma channel */
+static int acp_dma_start(struct amd_acp_device *acp_dev,
+			 u16 ch_num, bool is_circular)
+{
+	int status;
+	u32 dma_ctrl;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	status = STATUS_UNSUCCESSFUL;
+
+	/* read the dma control register and disable the channel run field */
+	dma_ctrl = cgs_read_register(acp_prv->cgs_device,
+				     mmACP_DMA_CNTL_0 + ch_num);
+
+	/*Invalidating the DAGB cache */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DAGB_ATU_CTRL, ENABLE);
+
+	/* configure the DMA channel and start the DMA transfer
+	 * set dmachrun bit to start the transfer and enable the
+	 * interrupt on completion of the dma transfer
+	 */
+	dma_ctrl |= ACP_DMA_CNTL_0__DMAChRun_MASK;
+
+	if ((ch_num == ACP_TO_I2S_DMA_CH_NUM) ||
+	    (ch_num == I2S_TO_ACP_DMA_CH_NUM)) {
+		dma_ctrl |= ACP_DMA_CNTL_0__DMAChIOCEn_MASK;
+		cgs_irq_get(acp_prv->cgs_device, VISLANDS30_IV_SRCID_ACP, 0);
+	} else {
+		dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;
+	}
+
+	/* enable  for ACP SRAM to/from I2S DMA channel */
+	if (is_circular == true)
+		dma_ctrl |= ACP_DMA_CNTL_0__Circular_DMA_En_MASK;
+	else
+		dma_ctrl &= ~ACP_DMA_CNTL_0__Circular_DMA_En_MASK;
+
+	cgs_write_register(acp_prv->cgs_device,	(mmACP_DMA_CNTL_0 + ch_num),
+			   dma_ctrl);
+
+	status = STATUS_SUCCESS;
+
+	return status;
+}
+
+/* Stop a given dma channel number*/
+static int acp_dma_stop(struct amd_acp_device *acp_dev, u8 ch_num)
+{
+	int status = STATUS_UNSUCCESSFUL;
+	u32 dma_ctrl;
+	u32 dma_ch_sts;
+	u32 delay_time = ACP_DMA_RESET_TIME;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (acp_dev == NULL)
+		return status;
+
+	/* register mask value to check the channel status bits */
+	dma_ctrl = cgs_read_register(acp_prv->cgs_device,
+				     mmACP_DMA_CNTL_0 + ch_num);
+
+	/* clear the dma control register fields before writing zero
+	 * in reset bit
+	 */
+	dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;
+	dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;
+
+	cgs_write_register(acp_prv->cgs_device,
+			   (mmACP_DMA_CNTL_0 + ch_num), dma_ctrl);
+	dma_ch_sts = cgs_read_register(acp_prv->cgs_device, mmACP_DMA_CH_STS);
+
+	if (dma_ch_sts & BIT(ch_num)) {
+		/* set the reset bit for this channel
+		 * to stop the dma transfer */
+		dma_ctrl |= ACP_DMA_CNTL_0__DMAChRst_MASK;
+		cgs_write_register(acp_prv->cgs_device,
+				   (mmACP_DMA_CNTL_0 + ch_num), dma_ctrl);
+	}
+
+	/* if channel transfer is not stopped with in time delay
+	 * return this status */
+	status = -EBUSY;
+
+	/* check the channel status bit for some time and return the status */
+	while (0 < delay_time) {
+		dma_ch_sts = cgs_read_register(acp_prv->cgs_device,
+					       mmACP_DMA_CH_STS);
+		if (!(dma_ch_sts & BIT(ch_num))) {
+			/* clear the reset flag after successfully stopping
+			   the dma transfer and break from the loop */
+			dma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRst_MASK;
+
+			cgs_write_register(acp_prv->cgs_device,
+					   (mmACP_DMA_CNTL_0 + ch_num), dma_ctrl);
+			status = STATUS_SUCCESS;
+			break;
+		}
+		delay_time--;
+	}
+
+	if ((ch_num == ACP_TO_I2S_DMA_CH_NUM) ||
+	    (ch_num == I2S_TO_ACP_DMA_CH_NUM)) {
+		cgs_irq_put(acp_prv->cgs_device, VISLANDS30_IV_SRCID_ACP, 0);
+	}
+
+	return status;
+}
+
+static int dma_irq_handler(void *prv_data)
+{
+	u16 play_intr, capture_intr;
+	u16 dscr_idx, intr_flag;
+	int priority_level = 0x0;
+	int dma_transfer_status = STATUS_UNSUCCESSFUL;
+	struct acp_irq_prv *idata = prv_data;
+	struct amd_acp_device *acp_dev = idata->acp_dev;
+
+	intr_flag = acp_get_intr_flag(acp_dev);
+	play_intr = (intr_flag & BIT(ACP_TO_I2S_DMA_CH_NUM));
+	capture_intr = (intr_flag & BIT(I2S_TO_ACP_DMA_CH_NUM));
+
+	if (!play_intr && !capture_intr) {
+		/* We registered for DMA Interrupt-On-Complete interrupts only.
+		 * If we hit here, just return. */
+		pr_info("ACP:irq_handler: play_intr && capture_intr = false\n");
+		return 0;
+	}
+
+	if (play_intr) {
+		dscr_idx = get_dscr_idx(acp_dev, STREAM_PLAYBACK);
+		config_acp_dma_channel(acp_dev, SYSRAM_TO_ACP_CH_NUM, dscr_idx,
+				       1, priority_level);
+		dma_transfer_status = acp_dma_start(acp_dev,
+						    SYSRAM_TO_ACP_CH_NUM,
+						    false);
+		idata->set_elapsed(idata->dev, play_intr, capture_intr);
+
+		acp_ext_stat_clear_dmaioc(acp_dev, ACP_TO_I2S_DMA_CH_NUM);
+	}
+
+	if (capture_intr) {
+		dscr_idx = get_dscr_idx(acp_dev, STREAM_CAPTURE);
+		config_acp_dma_channel(acp_dev, ACP_TO_SYSRAM_CH_NUM, dscr_idx,
+				       1, priority_level);
+		dma_transfer_status = acp_dma_start(acp_dev,
+						    ACP_TO_SYSRAM_CH_NUM,
+						    false);
+		idata->set_elapsed(idata->dev, play_intr, capture_intr);
+
+		acp_ext_stat_clear_dmaioc(acp_dev, I2S_TO_ACP_DMA_CH_NUM);
+	}
+	return 0;
+}
+
+static int irq_handler(void *private_data, unsigned src_id,
+		       const uint32_t *iv_entry)
+{
+	if (src_id == VISLANDS30_IV_SRCID_ACP)
+		return dma_irq_handler(private_data);
+	else
+		return -1;
+}
+
+/* Initialize and bring ACP hardware to default state. */
+static int acp_hw_init(struct amd_acp_device *acp_dev, void *iprv)
+{
+	u32 val;
+	u32 timeout_value;
+	int acp_hw_init_status = STATUS_UNSUCCESSFUL;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (acp_dev == NULL)
+		return acp_hw_init_status;
+
+	/* Assert Soft reset of ACP */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+
+	val |= ACP_SOFT_RESET__SoftResetAud_MASK;
+	cgs_write_register(acp_prv->cgs_device,
+			   mmACP_SOFT_RESET, val);
+
+	timeout_value = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+		if (ACP_SOFT_RESET__SoftResetAudDone_MASK ==
+		    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))
+			break;
+	}
+
+	/* Enabling clock to ACP and waits until the clock is enabled */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_CONTROL);
+	val = val | ACP_CONTROL__ClkEn_MASK;
+	cgs_write_register(acp_prv->cgs_device,	mmACP_CONTROL, val);
+
+	timeout_value = ACP_CLOCK_EN_TIME_OUT_VALUE;
+
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_STATUS);
+		if (val & (u32) 0x1)
+			break;
+		udelay(100);
+	}
+
+	/* Deassert the SOFT RESET flags */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+	val &= ~ACP_SOFT_RESET__SoftResetAud_MASK;
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SOFT_RESET, val);
+
+	/* initiailizing Garlic Control DAGB register */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_AXI2DAGB_ONION_CNTL,
+			   ONION_CNTL_DEFAULT);
+
+	/* initiailizing Onion Control DAGB registers */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_AXI2DAGB_GARLIC_CNTL,
+			   GARLIC_CNTL_DEFAULT);
+
+	acp_dma_descr_init(acp_dev);
+
+	/* DMA DSCR BASE ADDRESS IN SRAM */
+	cgs_write_register(acp_prv->cgs_device,	mmACP_DMA_DESC_BASE_ADDR,
+			   ACP_SRAM_BASE_ADDRESS);
+
+	/* Num of descriptiors in SRAM 0x4, means 256 descriptors;(64 * 4) */
+	cgs_write_register(acp_prv->cgs_device, mmACP_DMA_DESC_MAX_NUM_DSCR,
+			   0x4);
+
+	cgs_write_register(acp_prv->cgs_device,	mmACP_EXTERNAL_INTR_CNTL,
+			   ACP_EXTERNAL_INTR_CNTL__DMAIOCMask_MASK);
+
+	cgs_add_irq_source(acp_prv->cgs_device, VISLANDS30_IV_SRCID_ACP, 1,
+			   irq_set_source,	irq_handler, iprv);
+
+	pr_info("ACP: Initialized.\n");
+	return STATUS_SUCCESS;
+}
+
+static void acp_hw_deinit(struct amd_acp_device *acp_dev)
+{
+	u32 val;
+	u32 timeout_value;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	  /* Assert Soft reset of ACP */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+
+	val |= ACP_SOFT_RESET__SoftResetAud_MASK;
+	cgs_write_register(acp_prv->cgs_device,	mmACP_SOFT_RESET, val);
+
+	timeout_value = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_SOFT_RESET);
+		if (ACP_SOFT_RESET__SoftResetAudDone_MASK ==
+		    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK)) {
+			break;
+	    }
+	}
+	 /** Disable ACP clock */
+	val = cgs_read_register(acp_prv->cgs_device, mmACP_CONTROL);
+	val &= ~ACP_CONTROL__ClkEn_MASK;
+	cgs_write_register(acp_prv->cgs_device, mmACP_CONTROL, val);
+
+	timeout_value = ACP_CLOCK_EN_TIME_OUT_VALUE;
+
+	while (timeout_value--) {
+		val = cgs_read_register(acp_prv->cgs_device, mmACP_STATUS);
+		if (!(val & (u32) 0x1))
+			break;
+		udelay(100);
+	}
+
+	pr_info("ACP: De-Initialized.\n");
+}
+
+
+/*	Get the number of bytes consumed for SRAM_TO_I2S DMA
+ *	 channel during rendering
+ */
+static u32 acp_update_dma_pointer(struct amd_acp_device *acp_dev, int direction,
+				  u32 period_size)
+{
+	u32 pos;
+	u16 dscr;
+	u32 mul;
+	u32 dma_config;
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+	pos = 0;
+
+	if (direction == STREAM_PLAYBACK) {
+		dscr = cgs_read_register(acp_prv->cgs_device,
+					 mmACP_DMA_CUR_DSCR_13);
+		pos = cgs_read_register(acp_prv->cgs_device,
+					mmACP_DMA_CUR_TRANS_CNT_13);
+		/* dscr = either 2 or 3 only */
+		mul = (dscr == PLAYBACK_START_DMA_DESCR_CH13) ? 1 : 0;
+		pos =  (mul * period_size) + pos;
+	} else if (direction == STREAM_CAPTURE) {
+		dscr = cgs_read_register(acp_prv->cgs_device,
+					 mmACP_DMA_CUR_DSCR_15);
+		pos = cgs_read_register(acp_prv->cgs_device,
+					mmACP_DMA_CUR_TRANS_CNT_15);
+		dma_config = cgs_read_register(acp_prv->cgs_device,
+					       mmACP_DMA_CNTL_14);
+		if (dma_config != 0) {
+			mul = (dscr == CAPTURE_START_DMA_DESCR_CH15) ? 1 : 0;
+			pos =  (mul * period_size) + pos;
+		}
+	}
+
+	return pos;
+}
+
+/*	Wait for complete buffering to complete in HOST
+ *	 to SRAM DMA channel
+ */
+static void wait_for_prebuffer_finish(struct amd_acp_device *acp_dev)
+{
+	u32 dma_ch_sts;
+	u32 channel_mask = BIT(SYSRAM_TO_ACP_CH_NUM);
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	do {
+		/* Read the channel status to poll dma transfer completion
+		 * (System RAM to SRAM)
+		 * In this case, it will be runtime->start_threshold
+		 * (2 ALSA periods) of transfer. Rendering starts after this
+		 * threshold is met.
+		 */
+		dma_ch_sts = cgs_read_register(acp_prv->cgs_device,
+					       mmACP_DMA_CH_STS);
+		udelay(20);
+	} while (dma_ch_sts & channel_mask);
+}
+
+static void i2s_reset(struct amd_acp_device *acp_dev, int direction)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK)
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_TXFFR, 1);
+	else
+		cgs_write_register(acp_prv->cgs_device,
+				   mmACP_I2SMICSP_RXFFR, 1);
+
+}
+
+static void i2s_start(struct amd_acp_device *acp_dev, int direction)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	if (direction == STREAM_PLAYBACK) {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_IER, 1);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_ITER, 1);
+
+	} else {
+		cgs_write_register(acp_prv->cgs_device, mmACP_I2SMICSP_IER, 1);
+		cgs_write_register(acp_prv->cgs_device, mmACP_I2SMICSP_IRER, 1);
+	}
+
+	cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_CER, 1);
+}
+
+static void i2s_stop(struct amd_acp_device *acp_dev, int direction)
+{
+	struct amd_acp_private *acp_prv = (struct amd_acp_private *)acp_dev;
+
+	i2s_clear_irqs(acp_dev, direction);
+
+	if (direction == STREAM_PLAYBACK)
+		cgs_write_register(acp_prv->cgs_device, mmACP_I2SSP_ITER, 0);
+	else
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SMICSP_IRER, 0);
+
+	if (direction == STREAM_PLAYBACK) {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_CER, 0);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SSP_IER, 0);
+	} else {
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SMICSP_CER, 0);
+		cgs_write_register(acp_prv->cgs_device,	mmACP_I2SMICSP_IER, 0);
+	}
+}
+
+static void configure_i2s(struct amd_acp_device *acp_dev,
+			  struct acp_i2s_config *i2s_config)
+{
+	i2s_disable_channels(acp_dev, i2s_config->direction);
+	configure_i2s_stream(acp_dev, i2s_config);
+}
+
+int amd_acp_hw_init(void *cgs_device,
+		    unsigned acp_version_major, unsigned acp_version_minor,
+		    struct amd_acp_private **acp_private)
+{
+	unsigned int acp_mode = ACP_MODE_I2S;
+
+	if ((acp_version_major == 2) && (acp_version_minor == 2))
+		acp_mode = cgs_read_register(cgs_device,
+					mmACP_AZALIA_I2S_SELECT);
+
+	if (acp_mode != ACP_MODE_I2S)
+		return -ENODEV;
+
+	*acp_private = kzalloc(sizeof(struct amd_acp_private), GFP_KERNEL);
+	if (*acp_private == NULL)
+		return -ENOMEM;
+
+	(*acp_private)->cgs_device = cgs_device;
+	(*acp_private)->acp_version_major = acp_version_major;
+	(*acp_private)->acp_version_minor = acp_version_minor;
+
+	(*acp_private)->public.init = acp_hw_init;
+	(*acp_private)->public.fini = acp_hw_deinit;
+	(*acp_private)->public.config_dma = config_acp_dma;
+	(*acp_private)->public.config_dma_channel = config_acp_dma_channel;
+	(*acp_private)->public.dma_start = acp_dma_start;
+	(*acp_private)->public.dma_stop = acp_dma_stop;
+	(*acp_private)->public.update_dma_pointer = acp_update_dma_pointer;
+	(*acp_private)->public.prebuffer_audio = wait_for_prebuffer_finish;
+
+	(*acp_private)->public.i2s_reset = i2s_reset;
+	(*acp_private)->public.config_i2s = configure_i2s;
+	(*acp_private)->public.i2s_start = i2s_start;
+	(*acp_private)->public.i2s_stop = i2s_stop;
+
+	return 0;
+}
+
+int amd_acp_hw_fini(struct amd_acp_private *acp_private)
+{
+	kfree(acp_private);
+	return 0;
+}
+
+void amd_acp_suspend(struct amd_acp_private *acp_private)
+{
+	/* TODO */
+}
+
+void amd_acp_resume(struct amd_acp_private *acp_private)
+{
+	/* TODO */
+}
diff --git a/drivers/gpu/drm/amd/acp/acp_hw.h b/drivers/gpu/drm/amd/acp/acp_hw.h
new file mode 100644
index 0000000..384d97d
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/acp_hw.h
@@ -0,0 +1,99 @@
+#ifndef __ACP_HW_H
+#define __ACP_HW_H
+
+#define ACP_MODE_I2S				0
+#define ACP_MODE_AZ				1
+
+#define DISABLE					0
+#define ENABLE					1
+
+#define PAGE_SIZE_4K				4096
+#define PAGE_SIZE_4K_ENABLE			0x02
+
+#define PLAYBACK_PTE_OFFSET			10
+#define CAPTURE_PTE_OFFSET			0
+
+#define GARLIC_CNTL_DEFAULT			0x00000FB4
+#define ONION_CNTL_DEFAULT			0x00000FB4
+
+#define ACP_PHYSICAL_BASE			0x14000
+
+/* Playback SRAM address (as a destination in dma descriptor) */
+#define ACP_SHARED_RAM_BANK_38_ADDRESS		0x404A000
+
+/* Capture SRAM address (as a source in dma descriptor) */
+#define ACP_SHARED_RAM_BANK_47_ADDRESS		0x405C000
+
+#define ACP_DMA_RESET_TIME			10000
+#define ACP_CLOCK_EN_TIME_OUT_VALUE		0x000000FF
+#define ACP_SOFT_RESET_DONE_TIME_OUT_VALUE	0x000000FF
+#define ACP_DMA_COMPLETE_TIME_OUT_VALUE		0x000000FF
+
+#define ACP_SRAM_BASE_ADDRESS			0x4000000
+#define ACP_DAGB_GRP_SRAM_BASE_ADDRESS		0x4001000
+#define ACP_DAGB_GRP_SRBM_SRAM_BASE_OFFSET	0x1000
+#define ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS	0x00000000
+#define ACP_INTERNAL_APERTURE_WINDOW_4_ADDRESS	0x01800000
+
+enum {
+	STREAM_PLAYBACK = 0,
+	STREAM_CAPTURE,
+	STREAM_LAST = STREAM_CAPTURE,
+};
+
+enum {
+	To_DAGB_O = 0x0,
+	To_DAGB_G,
+	TO_ACP_I2S_1,
+	TO_BLUETOOTH,
+	TO_ACP_I2S_2,
+	FROM_DAGB_O,
+	FROM_DAGB_G,
+	FROM_ACP_I2S_1,
+	FROM_ACP_I2S_2
+};
+
+enum {
+	ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION = 0x0,
+	ACP_DMA_ATTRIBUTES_SHARED_MEM_TO_DAGB_GARLIC = 0x1,
+	ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM = 0x8,
+	ACP_DMA_ATTRIBUTES_DAGB_GARLIC_TO_SHAREDMEM = 0x9,
+	ACP_DMA_ATTRIBUTES_FORCE_SIZE = 0xF
+};
+
+typedef struct acp_dma_dscr_size_transfer_direction {
+	/* Specifies the number of bytes need to be transferred
+	 *  from source to destination memory. */
+	u32 size:16;
+	/* Specifies transfer direction. */
+	u32 trans_direction:4;
+	/* reserved. */
+	u32 reserved1:2;
+	/* Specifies the IOC enable or not for descriptor. */
+	/* Defaultly this will be 0, for the last descriptor, make it Enable */
+	u32 ioc:1;
+	/* reserved. */
+	u32 reserved2:9;
+} acp_dma_dscr_size_transfer_direction_t;
+
+typedef union {
+	u32 val:32;
+	acp_dma_dscr_size_transfer_direction_t s;
+} acp_dma_dscr_size_transfer_direction_u;
+
+typedef struct acp_dma_dscr_transfer {
+	/* Specifies the source memory location for the DMA data transfer. */
+	u32 src;
+	/* Specifies the destination memory location to where the data will
+	   be transferred.
+	 */
+	u32 dest;
+	/* Specifies the number of bytes need to be transferred
+	 * from source to destination memory.Transfer direction & IOC enable
+	 */
+	acp_dma_dscr_size_transfer_direction_u size_xfer_dir;
+	/** Reserved for future use */
+	u32 reserved;
+} acp_dma_dscr_transfer_t;
+
+#endif /*__ACP_HW_H */
diff --git a/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h b/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h
new file mode 100644
index 0000000..83662d6
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/include/acp_gfx_if.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+*/
+
+#ifndef _ACP_GFX_IF_H
+#define _ACP_GFX_IF_H
+
+#include <linux/types.h>
+#include "cgs_linux.h"
+#include "cgs_common.h"
+#include "amd_acp.h"
+
+struct amd_acp_private {
+	/* The public struture is first, so that pointers can be cast
+	 * between the public and private structure */
+	struct amd_acp_device public;
+
+	/* private elements not expose through the bus interface */
+	void *cgs_device;
+	unsigned acp_version_major, acp_version_minor;
+};
+
+int amd_acp_hw_init(void *cgs_device,
+		    unsigned acp_version_major, unsigned acp_version_minor,
+		    struct amd_acp_private **apriv);
+int amd_acp_hw_fini(struct amd_acp_private *apriv);
+void amd_acp_suspend(struct amd_acp_private *acp_private);
+void amd_acp_resume(struct amd_acp_private *acp_private);
+
+#endif /* _ACP_GFX_IF_H */
diff --git a/drivers/gpu/drm/amd/acp/include/amd_acp.h b/drivers/gpu/drm/amd/acp/include/amd_acp.h
new file mode 100644
index 0000000..988d72a
--- /dev/null
+++ b/drivers/gpu/drm/amd/acp/include/amd_acp.h
@@ -0,0 +1,196 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+*/
+
+#ifndef _AMD_ACP_H
+#define _AMD_ACP_H
+
+#include <linux/types.h>
+
+/* Playback DMA channels */
+#define SYSRAM_TO_ACP_CH_NUM 12
+#define ACP_TO_I2S_DMA_CH_NUM 13
+
+/* Capture DMA channels */
+#define ACP_TO_SYSRAM_CH_NUM 14
+#define I2S_TO_ACP_DMA_CH_NUM 15
+
+#define PLAYBACK_START_DMA_DESCR_CH12 0
+#define PLAYBACK_END_DMA_DESCR_CH12 1
+
+#define PLAYBACK_START_DMA_DESCR_CH13 2
+#define PLAYBACK_END_DMA_DESCR_CH13 3
+
+
+#define CAPTURE_START_DMA_DESCR_CH14 4
+#define CAPTURE_END_DMA_DESCR_CH14 5
+
+#define CAPTURE_START_DMA_DESCR_CH15 6
+#define CAPTURE_END_DMA_DESCR_CH15 7
+
+#define STATUS_SUCCESS 0
+#define STATUS_UNSUCCESSFUL -1
+
+enum acp_dma_priority_level {
+	/* 0x0 Specifies the DMA channel is given normal priority */
+	ACP_DMA_PRIORITY_LEVEL_NORMAL = 0x0,
+	/* 0x1 Specifies the DMA channel is given high priority */
+	ACP_DMA_PRIORITY_LEVEL_HIGH = 0x1,
+	ACP_DMA_PRIORITY_LEVEL_FORCESIZE = 0xFF
+};
+
+struct acp_dma_config {
+	struct page *pg;
+	u16 num_of_pages;
+	u16 direction;
+	uint64_t size;
+};
+
+struct acp_i2s_config {
+	u16 direction;
+	u32 xfer_resolution;
+	u32 irq;
+	u32 ch_reg;
+};
+
+struct acp_irq_prv {
+	struct device *dev;
+	struct amd_acp_device *acp_dev;
+	void (*set_elapsed)(struct device *pdev, u16 play_intr,
+						u16 capture_intr);
+};
+
+/* Public interface of ACP device exposed on AMD GNB bus */
+struct amd_acp_device {
+	/* Handshake when ALSA driver connects, disconnects
+	 * TBD: is this really needed? */
+	int (*init)(struct amd_acp_device *acp_dev, void *iprv);
+	void (*fini)(struct amd_acp_device *acp_dev);
+
+	/**
+	 * config_dma() - Configure ACP internal DMA controller
+	 * @acp_dev:	    acp device
+	 * @acp_dma_config: DMA configuration parameters
+	 *
+	 * This will configure the DMA controller with the given
+	 * configuration parameters.
+	 */
+	void (*config_dma)(struct amd_acp_device *acp_dev,
+			   struct acp_dma_config *dma_config);
+
+	/**
+	 * config_dma_channel() - Configure ACP DMA channel
+	 * @acp_dev:	    acp device
+	 * @ch_num:	    channel number to be configured
+	 * @dscr_strt_idx:  DMA descriptor starting index
+	 * @priority_level: priority level of channel
+	 *
+	 * This will configure the DMA channel with the given
+	 * configuration parameters.
+	 */
+	void (*config_dma_channel)(struct amd_acp_device *acp_dev,
+				   u8 ch_num, u16 dscr_strt_idx, u16 num_dscrs,
+				   enum acp_dma_priority_level priority_level);
+
+	/**
+	 * dma_start() - Start ACP DMA engine
+	 * @acp_dev:	 acp device
+	 * @ch_num:	 DMA channel number
+	 * @is_circular: configure circular DMA
+	 *
+	 * Start DMA channel as configured.
+	 */
+	int (*dma_start)(struct amd_acp_device *acp_dev, u16 ch_num,
+			  bool is_circular);
+
+	/**
+	 * dma_stop() - Stop ACP DMA engine
+	 * @acp_dev:	acp device
+	 * @ch_num:	DMA channel number
+	 *
+	 * Stop DMA channel as configured.
+	 */
+	int (*dma_stop)(struct amd_acp_device *acp_dev, u8 ch_num);
+
+	/**
+	 * update_dma_pointer() - Query the buffer postion
+	 * @acp_dev:	 acp device
+	 * @direction:   Dma transfer direction
+	 * @period_size: size of buffer in-terms of ALSA terminology
+	 *
+	 * This will query the buffer position from ACP IP, based on data
+	 * produced/consumed
+	 */
+	u32 (*update_dma_pointer)(struct amd_acp_device *acp_dev,
+				  int direction, u32 period_size);
+
+	/**
+	 * prebuffer_audio() - Wait for buffering to complete
+	 * @acp_dev:	acp device
+	 *
+	 * Wait for buffering to complete in HOST to SRAM DMA channel.
+	 */
+	void (*prebuffer_audio)(struct amd_acp_device *acp_dev);
+
+	/**
+	 * i2s_reset() -  Reset i2s FIFOs
+	 * @acp_dev:	  acp device
+	 * @direction:    direction of stream – playback/record
+	 *
+	 * Resets I2S FIFOs
+	 */
+	void (*i2s_reset)(struct amd_acp_device *acp_dev, int direction);
+
+	/**
+	 * config_i2s() - Configure the i2s controller
+	 * @acp_dev:    acp device
+	 * @i2s_config: configuration of i2s controller
+	 *
+	 * This will configure the i2s controller instance used on the
+	 * board, with the given configuration parameters.
+	 */
+	void (*config_i2s)(struct amd_acp_device *acp_dev,
+			   struct acp_i2s_config *i2s_config);
+
+	/**
+	 * i2s_start() - Start i2s controller
+	 * @acp_dev:	  acp device
+	 * @direction:    direction of stream – playback/record
+	 *
+	 * Starts I2S data transmission
+	 */
+	void (*i2s_start)(struct amd_acp_device *acp_dev, int direction);
+
+	/**
+	 * i2s_stop() - Stop i2s controller
+	 * @acp_dev:	acp device
+	 * @stream:	Type of stream – playback/record
+	 *
+	 * Stops I2S data transmission
+	 */
+	void (*i2s_stop)(struct amd_acp_device *acp_dev, int direction);
+
+	/* TODO: Need callback registration interface for asynchronous
+	 * notifications */
+};
+
+#endif /* _AMD_ACP_H */
diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index f17d0cc..ddf4549 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -3,7 +3,9 @@
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 
 ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/amd/include/asic_reg \
-	-Idrivers/gpu/drm/amd/include
+		-Idrivers/gpu/drm/amd/include \
+		-Idrivers/gpu/drm/amd/include/bus \
+		-Idrivers/gpu/drm/amd/acp/include
 
 amdgpu-y := amdgpu_drv.o
 
@@ -74,6 +76,16 @@ amdgpu-y += \
 # add cgs
 amdgpu-y += amdgpu_cgs.o
 
+# ACP componet
+ifneq ($(CONFIG_DRM_AMD_ACP),)
+amdgpu-y += amdgpu_acp.o
+
+AMDACPPATH := ../acp
+include drivers/gpu/drm/amd/acp/Makefile
+
+amdgpu-y += $(AMD_ACP_FILES)
+endif
+
 amdgpu-$(CONFIG_COMPAT) += amdgpu_ioc32.o
 amdgpu-$(CONFIG_VGA_SWITCHEROO) += amdgpu_atpx_handler.o
 amdgpu-$(CONFIG_ACPI) += amdgpu_acpi.o
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 01d4791..3591ff9 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -53,6 +53,7 @@
 #include "amdgpu_irq.h"
 #include "amdgpu_ucode.h"
 #include "amdgpu_gds.h"
+#include "amdgpu_acp.h"
 
 /*
  * Modules parameters.
@@ -1852,6 +1853,12 @@ int amdgpu_ctx_put(struct amdgpu_ctx *ctx);
 
 extern int amdgpu_ctx_ioctl(struct drm_device *dev, void *data,
 						 struct drm_file *filp);
+/*
+ * CGS
+ */
+void *amdgpu_cgs_create_device(struct amdgpu_device *adev);
+void amdgpu_cgs_destroy_device(void *cgs_device);
+
 
 /*
  * Core structure, functions and helpers.
@@ -1868,6 +1875,10 @@ struct amdgpu_device {
 	struct pci_dev			*pdev;
 	struct rw_semaphore		exclusive_lock;
 
+#ifdef CONFIG_DRM_AMD_ACP
+	struct amdgpu_acp		acp;
+#endif
+
 	/* ASIC */
 	enum amdgpu_asic_type           asic_type;
 	uint32_t			family;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
new file mode 100644
index 0000000..e4112ea
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "amdgpu.h"
+#include "atom.h"
+#include "amdgpu_acp.h"
+#include "amd_gnb_bus.h"
+#include "acp_gfx_if.h"
+
+static int acp_early_init(void *handle)
+{
+	return 0;
+}
+
+static int acp_sw_init(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	adev->acp.parent = adev->dev;
+
+	adev->acp.cgs_device =
+		amdgpu_cgs_create_device(adev);
+	if (!adev->acp.cgs_device)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int acp_sw_fini(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->acp.cgs_device)
+		amdgpu_cgs_destroy_device(adev->acp.cgs_device);
+
+	return 0;
+}
+
+/**
+ * acp_hw_init - start and test UVD block
+ *
+ * @adev: amdgpu_device pointer
+ *
+ */
+static int acp_hw_init(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	int r;
+	const struct amdgpu_ip_block_version *ip_version =
+		amdgpu_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);
+
+	if (!ip_version)
+		return -EINVAL;
+
+	r = amd_acp_hw_init(adev->acp.cgs_device,
+			    ip_version->major, ip_version->minor,
+			    &adev->acp.private);
+	/* -ENODEV means board uses AZ rather than ACP */
+	if (r == -ENODEV)
+		return 0;
+	else if (r)
+		return r;
+	r = amd_gnb_bus_device_init(&adev->acp.acp_pcm_dev,
+				    AMD_GNB_IP_ACP_PCM,
+				    "acp_pcm_dev",
+				    adev->acp.private,
+				    adev->acp.parent);
+	if (r) {
+		amd_acp_hw_fini(adev->acp.private);
+		return r;
+	}
+
+	return 0;
+}
+
+/**
+ * acp_hw_fini - stop the hardware block
+ *
+ * @adev: amdgpu_device pointer
+ *
+ */
+static int acp_hw_fini(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->acp.private) {
+		amd_acp_hw_fini(adev->acp.private);
+		amd_gnb_bus_unregister_device(&adev->acp.acp_pcm_dev);
+	}
+
+	return 0;
+}
+
+static int acp_suspend(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->acp.private)
+		amd_acp_suspend(adev->acp.private);
+
+	return 0;
+}
+
+static int acp_resume(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->acp.private)
+		amd_acp_resume(adev->acp.private);
+
+	return 0;
+}
+
+static bool acp_is_idle(void *handle)
+{
+	return true;
+}
+
+static int acp_wait_for_idle(void *handle)
+{
+	return 0;
+}
+
+static int acp_soft_reset(void *handle)
+{
+	return 0;
+}
+
+static void acp_print_status(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	dev_info(adev->dev, "ACP STATUS\n");
+}
+
+static int acp_set_clockgating_state(void *handle,
+				     enum amd_clockgating_state state)
+{
+	return 0;
+}
+
+static int acp_set_powergating_state(void *handle,
+				     enum amd_powergating_state state)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	/* This doesn't actually powergate the ACP block.
+	 * That's done in the dpm code via the SMC.  This
+	 * just re-inits the block as necessary.  The actual
+	 * gating still happens in the dpm code.  We should
+	 * revisit this when there is a cleaner line between
+	 * the smc and the hw blocks
+	 */
+	if (state == AMD_PG_STATE_GATE) {
+		if (adev->acp.private)
+			amd_acp_suspend(adev->acp.private);
+	} else {
+		if (adev->acp.private)
+			amd_acp_resume(adev->acp.private);
+	}
+	return 0;
+}
+
+const struct amd_ip_funcs acp_ip_funcs = {
+	.early_init = acp_early_init,
+	.late_init = NULL,
+	.sw_init = acp_sw_init,
+	.sw_fini = acp_sw_fini,
+	.hw_init = acp_hw_init,
+	.hw_fini = acp_hw_fini,
+	.suspend = acp_suspend,
+	.resume = acp_resume,
+	.is_idle = acp_is_idle,
+	.wait_for_idle = acp_wait_for_idle,
+	.soft_reset = acp_soft_reset,
+	.print_status = acp_print_status,
+	.set_clockgating_state = acp_set_clockgating_state,
+	.set_powergating_state = acp_set_powergating_state,
+};
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h
new file mode 100644
index 0000000..424cd52f
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __AMDGPU_ACP_H__
+#define __AMDGPU_ACP_H__
+
+#include "amd_gnb_bus.h"
+
+struct amdgpu_acp {
+	struct device *parent;
+	struct amd_gnb_bus_dev acp_pcm_dev;
+	void *cgs_device;
+	struct amd_acp_private *private;
+};
+
+extern const struct amd_ip_funcs acp_ip_funcs;
+
+#endif /* __AMDGPU_ACP_H__ */
diff --git a/drivers/gpu/drm/amd/amdgpu/vi.c b/drivers/gpu/drm/amd/amdgpu/vi.c
index be7c176..98a3b66 100644
--- a/drivers/gpu/drm/amd/amdgpu/vi.c
+++ b/drivers/gpu/drm/amd/amdgpu/vi.c
@@ -71,6 +71,9 @@
 #include "uvd_v5_0.h"
 #include "uvd_v6_0.h"
 #include "vce_v3_0.h"
+#if defined(CONFIG_DRM_AMD_ACP)
+#include "amdgpu_acp.h"
+#endif
 
 /*
  * Indirect registers accessor
@@ -1171,6 +1174,15 @@ static const struct amdgpu_ip_block_version cz_ip_blocks[] =
 		.rev = 0,
 		.funcs = &vce_v3_0_ip_funcs,
 	},
+#if defined(CONFIG_DRM_AMD_ACP)
+	{
+		.type = AMD_IP_BLOCK_TYPE_ACP,
+		.major = 2,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &acp_ip_funcs,
+	},
+#endif
 };
 
 int vi_set_ip_blocks(struct amdgpu_device *adev)
diff --git a/drivers/gpu/drm/amd/include/amd_shared.h b/drivers/gpu/drm/amd/include/amd_shared.h
index 5bdf1b4..832602e 100644
--- a/drivers/gpu/drm/amd/include/amd_shared.h
+++ b/drivers/gpu/drm/amd/include/amd_shared.h
@@ -33,6 +33,7 @@ enum amd_ip_block_type {
 	AMD_IP_BLOCK_TYPE_SDMA,
 	AMD_IP_BLOCK_TYPE_UVD,
 	AMD_IP_BLOCK_TYPE_VCE,
+	AMD_IP_BLOCK_TYPE_ACP,
 };
 
 enum amd_clockgating_state {
-- 
1.9.1

