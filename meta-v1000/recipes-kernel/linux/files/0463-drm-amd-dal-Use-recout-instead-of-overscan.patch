From 76ccb75736465b69bfd183fa392725fa2e94beee Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Mon, 2 May 2016 16:33:07 -0400
Subject: [PATCH 0463/1722] drm/amd/dal: Use recout instead of overscan

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Kalyan Alle <kalyan.alle@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c   |  1 +
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      | 71 ++++------------------
 .../drm/amd/dal/dc/dce110/dce110_transform_scl.c   | 24 ++++++--
 .../gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c | 32 +++++++---
 .../gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c | 24 ++++++--
 drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h      |  3 +-
 6 files changed, 74 insertions(+), 81 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c b/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
index d40ab63..0fd29bb 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/scaler_filter.c
@@ -1873,6 +1873,7 @@ bool dal_scaler_filter_generate(
 		return false;
 	}
 
+	/* TODO: bilinear filter*/
 	if ((params->taps < 3) || (params->taps > 16)) {
 		BREAK_TO_DEBUGGER();
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index c07bece7..b596675 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -285,58 +285,15 @@ static void calculate_viewport(
 		pipe_ctx->scl_data.viewport.height = 2;
 }
 
-static void calculate_overscan(
-		const struct dc_surface *surface,
-		struct pipe_ctx *pipe_ctx)
-{
-	struct core_stream *stream = pipe_ctx->stream;
-
-	pipe_ctx->scl_data.overscan.left = stream->public.dst.x;
-	if (stream->public.src.x < surface->clip_rect.x)
-		pipe_ctx->scl_data.overscan.left += (surface->clip_rect.x
-			- stream->public.src.x) * stream->public.dst.width
-			/ stream->public.src.width;
-
-	pipe_ctx->scl_data.overscan.right = stream->public.timing.h_addressable
-		- stream->public.dst.x - stream->public.dst.width;
-	if (stream->public.src.x + stream->public.src.width
-		> surface->clip_rect.x + surface->clip_rect.width)
-		pipe_ctx->scl_data.overscan.right = stream->public.timing.h_addressable -
-			dal_fixed31_32_floor(dal_fixed31_32_div(
-				dal_fixed31_32_from_int(
-						pipe_ctx->scl_data.viewport.width),
-						pipe_ctx->scl_data.ratios.horz)) -
-						pipe_ctx->scl_data.overscan.left;
-
-	pipe_ctx->scl_data.overscan.top = stream->public.dst.y;
-	if (stream->public.src.y < surface->clip_rect.y)
-		pipe_ctx->scl_data.overscan.top += (surface->clip_rect.y
-			- stream->public.src.y) * stream->public.dst.height
-			/ stream->public.src.height;
-
-	pipe_ctx->scl_data.overscan.bottom = stream->public.timing.v_addressable
-		- stream->public.dst.y - stream->public.dst.height;
-	if (stream->public.src.y + stream->public.src.height
-		> surface->clip_rect.y + surface->clip_rect.height)
-		pipe_ctx->scl_data.overscan.bottom = stream->public.timing.v_addressable -
-			dal_fixed31_32_floor(dal_fixed31_32_div(
-				dal_fixed31_32_from_int(
-						pipe_ctx->scl_data.viewport.height),
-						pipe_ctx->scl_data.ratios.vert)) -
-						pipe_ctx->scl_data.overscan.top;
-
-	/* TODO: Add timing overscan to finalize overscan calculation*/
-}
-
 static void calculate_recout(
 		const struct dc_surface *surface,
 		struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
 
-	pipe_ctx->scl_data.recout.x = 0;
+	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
 	if (stream->public.src.x < surface->clip_rect.x)
-		pipe_ctx->scl_data.recout.x = (surface->clip_rect.x
+		pipe_ctx->scl_data.recout.x += (surface->clip_rect.x
 			- stream->public.src.x) * stream->public.dst.width
 						/ stream->public.src.width;
 
@@ -348,9 +305,9 @@ static void calculate_recout(
 			stream->public.dst.x + stream->public.dst.width
 						- pipe_ctx->scl_data.recout.x;
 
-	pipe_ctx->scl_data.recout.y = 0;
+	pipe_ctx->scl_data.recout.y = stream->public.dst.y;
 	if (stream->public.src.y < surface->clip_rect.y)
-		pipe_ctx->scl_data.recout.y = (surface->clip_rect.y
+		pipe_ctx->scl_data.recout.y += (surface->clip_rect.y
 			- stream->public.src.y) * stream->public.dst.height
 						/ stream->public.src.height;
 
@@ -390,6 +347,9 @@ static void calculate_scaling_ratios(
 	pipe_ctx->scl_data.ratios.horz.value = div64_s64(
 		pipe_ctx->scl_data.ratios.horz.value * in_w, out_w);
 
+	pipe_ctx->scl_data.ratios.horz.value++;
+	pipe_ctx->scl_data.ratios.vert.value++;
+
 	pipe_ctx->scl_data.ratios.horz_c = pipe_ctx->scl_data.ratios.horz;
 	pipe_ctx->scl_data.ratios.vert_c = pipe_ctx->scl_data.ratios.vert;
 
@@ -404,19 +364,19 @@ void resource_build_scaling_params(
 	struct pipe_ctx *pipe_ctx)
 {
 	/* Important: scaling ratio calculation requires pixel format,
-	 * overscan calculation requires scaling ratios and viewport
-	 * and lb depth/taps calculation requires overscan. Call sequence
-	 * is therefore important */
+	 * lb depth calculation requires recout and taps require scaling ratios.
+	 */
 	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(surface->format);
 
 	calculate_viewport(surface, pipe_ctx);
 
 	calculate_scaling_ratios(surface, pipe_ctx);
 
-	calculate_overscan(surface, pipe_ctx);
-
 	calculate_recout(surface, pipe_ctx);
 
+	pipe_ctx->scl_data.h_active = pipe_ctx->stream->public.timing.h_addressable;
+	pipe_ctx->scl_data.v_active = pipe_ctx->stream->public.timing.v_addressable;
+
 	/* Check if scaling is required update taps if not */
 	if (dal_fixed31_32_u2d19(pipe_ctx->scl_data.ratios.horz) == 1 << 19)
 		pipe_ctx->scl_data.taps.h_taps = 1;
@@ -441,15 +401,10 @@ void resource_build_scaling_params(
 	dal_logger_write(pipe_ctx->stream->ctx->logger,
 				LOG_MAJOR_DCP,
 				LOG_MINOR_DCP_SCALER,
-				"%s: Overscan:\n bot:%d left:%d right:%d "
-				"top:%d\nViewport:\nheight:%d width:%d x:%d "
+				"%s: Viewport:\nheight:%d width:%d x:%d "
 				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
 				"y:%d\n",
 				__func__,
-				pipe_ctx->scl_data.overscan.bottom,
-				pipe_ctx->scl_data.overscan.left,
-				pipe_ctx->scl_data.overscan.right,
-				pipe_ctx->scl_data.overscan.top,
 				pipe_ctx->scl_data.viewport.height,
 				pipe_ctx->scl_data.viewport.width,
 				pipe_ctx->scl_data.viewport.x,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
index 0f7336a..d97ec52 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_scl.c
@@ -132,21 +132,33 @@ static bool setup_scaling_configuration(
 */
 static void program_overscan(
 		struct dce110_transform *xfm110,
-		const struct overscan_info *overscan)
+		const struct scaler_data *data)
 {
 	uint32_t overscan_left_right = 0;
 	uint32_t overscan_top_bottom = 0;
 
-	set_reg_field_value(overscan_left_right, overscan->left,
+	int overscan_right = data->h_active - data->recout.x - data->recout.width;
+	int overscan_bottom = data->v_active - data->recout.y - data->recout.height;
+
+	if (overscan_right < 0) {
+		BREAK_TO_DEBUGGER();
+		overscan_right = 0;
+	}
+	if (overscan_bottom < 0) {
+		BREAK_TO_DEBUGGER();
+		overscan_bottom = 0;
+	}
+
+	set_reg_field_value(overscan_left_right, data->recout.x,
 			EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT);
 
-	set_reg_field_value(overscan_left_right, overscan->right,
+	set_reg_field_value(overscan_left_right, overscan_right,
 			EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_RIGHT);
 
-	set_reg_field_value(overscan_top_bottom, overscan->top,
+	set_reg_field_value(overscan_top_bottom, data->recout.y,
 			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_TOP);
 
-	set_reg_field_value(overscan_top_bottom, overscan->bottom,
+	set_reg_field_value(overscan_top_bottom, overscan_bottom,
 			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);
 
 	dm_write_reg(xfm110->base.ctx,
@@ -637,7 +649,7 @@ bool dce110_transform_set_scaler(
 	disable_enhanced_sharpness(xfm110);
 
 	/* 3. Program overscan */
-	program_overscan(xfm110, &data->overscan);
+	program_overscan(xfm110, data);
 
 	/* 4. Program taps and configuration */
 	is_scaling_required = setup_scaling_configuration(xfm110, data);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
index dbca59c..2db72c2 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_transform_v.c
@@ -245,22 +245,34 @@ static bool setup_scaling_configuration(
 */
 static void program_overscan(
 		struct dce110_transform *xfm110,
-		const struct overscan_info *overscan)
+		const struct scaler_data *data)
 {
 	uint32_t overscan_left_right = 0;
 	uint32_t overscan_top_bottom = 0;
 
-	set_reg_field_value(overscan_left_right, overscan->left,
-		SCLV_EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT);
+	int overscan_right = data->h_active - data->recout.x - data->recout.width;
+	int overscan_bottom = data->v_active - data->recout.y - data->recout.height;
 
-	set_reg_field_value(overscan_left_right, overscan->right,
-		SCLV_EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_RIGHT);
+	if (overscan_right < 0) {
+		BREAK_TO_DEBUGGER();
+		overscan_right = 0;
+	}
+	if (overscan_bottom < 0) {
+		BREAK_TO_DEBUGGER();
+		overscan_bottom = 0;
+	}
+
+	set_reg_field_value(overscan_left_right, data->recout.x,
+			EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT);
+
+	set_reg_field_value(overscan_left_right, overscan_right,
+			EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_RIGHT);
 
-	set_reg_field_value(overscan_top_bottom, overscan->top,
-		SCLV_EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_TOP);
+	set_reg_field_value(overscan_top_bottom, data->recout.y,
+			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_TOP);
 
-	set_reg_field_value(overscan_top_bottom, overscan->bottom,
-		SCLV_EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);
+	set_reg_field_value(overscan_top_bottom, overscan_bottom,
+			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);
 
 	dm_write_reg(xfm110->base.ctx,
 			mmSCLV_EXT_OVERSCAN_LEFT_RIGHT,
@@ -485,7 +497,7 @@ static bool dce110_transform_v_set_scaler(
 	calculate_viewport(data, &luma_viewport, &chroma_viewport);
 
 	/* 2. Program overscan */
-	program_overscan(xfm110, &data->overscan);
+	program_overscan(xfm110, data);
 
 	/* 3. Program taps and configuration */
 	is_scaling_required = setup_scaling_configuration(xfm110, data);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c
index 3cc955d..5d674f2 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_transform_scl.c
@@ -135,21 +135,33 @@ static bool setup_scaling_configuration(
 */
 static void program_overscan(
 		struct dce80_transform *xfm80,
-		const struct overscan_info *overscan)
+		const struct scaler_data *data)
 {
 	uint32_t overscan_left_right = 0;
 	uint32_t overscan_top_bottom = 0;
 
-	set_reg_field_value(overscan_left_right, overscan->left,
+	int overscan_right = data->h_active - data->recout.x - data->recout.width;
+	int overscan_bottom = data->v_active - data->recout.y - data->recout.height;
+
+	if (overscan_right < 0) {
+		BREAK_TO_DEBUGGER();
+		overscan_right = 0;
+	}
+	if (overscan_bottom < 0) {
+		BREAK_TO_DEBUGGER();
+		overscan_bottom = 0;
+	}
+
+	set_reg_field_value(overscan_left_right, data->recout.x,
 			EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_LEFT);
 
-	set_reg_field_value(overscan_left_right, overscan->right,
+	set_reg_field_value(overscan_left_right, overscan_right,
 			EXT_OVERSCAN_LEFT_RIGHT, EXT_OVERSCAN_RIGHT);
 
-	set_reg_field_value(overscan_top_bottom, overscan->top,
+	set_reg_field_value(overscan_top_bottom, data->recout.y,
 			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_TOP);
 
-	set_reg_field_value(overscan_top_bottom, overscan->bottom,
+	set_reg_field_value(overscan_top_bottom, overscan_bottom,
 			EXT_OVERSCAN_TOP_BOTTOM, EXT_OVERSCAN_BOTTOM);
 
 	dm_write_reg(xfm80->base.ctx,
@@ -638,7 +650,7 @@ bool dce80_transform_set_scaler(
 	disable_enhanced_sharpness(xfm80);
 
 	/* 3. Program overscan */
-	program_overscan(xfm80, &data->overscan);
+	program_overscan(xfm80, data);
 
 	/* 4. Program taps and configuration */
 	is_scaling_required = setup_scaling_configuration(xfm80, data);
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
index 0e1ebde..5c51786 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/transform.h
@@ -141,7 +141,8 @@ struct sharpness_adj {
 };
 
 struct scaler_data {
-	struct overscan_info overscan;
+	uint32_t h_active;
+	uint32_t v_active;
 	struct scaling_taps taps;
 	struct rect viewport;
 	struct rect recout;
-- 
2.7.4

