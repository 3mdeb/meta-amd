From a8874ed0926c0b75ac3a85841c4e10065da31e54 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 20 Jul 2017 11:43:32 -0400
Subject: [PATCH 2733/2831] drm/amd/display: Roll core_surface into dc_surface

Change-Id: Id4be5e785fc6f030851882d6a11c8f55bf2dbdfc
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <Harry.Wentland@amd.com>
---
 .../drm/amd/display/amdgpu_dm/amdgpu_dm_types.c    |   8 +-
 drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c   |  16 ++--
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c   |  26 +++---
 drivers/gpu/drm/amd/display/dc/core/dc.c           |  73 +++++++--------
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c  |  42 ++++-----
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c    |   4 +-
 drivers/gpu/drm/amd/display/dc/core/dc_surface.c   |  44 ++++-----
 drivers/gpu/drm/amd/display/dc/dc.h                |  45 +++++----
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c     |   4 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h     |   2 +-
 .../amd/display/dc/dce110/dce110_hw_sequencer.c    | 102 ++++++++++-----------
 .../drm/amd/display/dc/dce110/dce110_resource.c    |   2 +-
 .../drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c  |  76 +++++++--------
 drivers/gpu/drm/amd/display/dc/inc/core_types.h    |  16 +---
 drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h  |   4 +-
 drivers/gpu/drm/amd/display/dc/inc/resource.h      |   2 +-
 16 files changed, 226 insertions(+), 240 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
index af28c27..73a1187 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_types.c
@@ -2494,7 +2494,7 @@ static void amdgpu_dm_commit_surfaces(struct drm_atomic_state *state,
 	struct drm_plane *plane;
 	struct drm_plane_state *old_plane_state;
 	const struct dc_stream *dc_stream_attach;
-	const struct dc_surface *dc_surfaces_constructed[MAX_SURFACES];
+	struct dc_surface *dc_surfaces_constructed[MAX_SURFACES];
 	struct amdgpu_crtc *acrtc_attach = to_amdgpu_crtc(pcrtc);
 	struct dm_crtc_state *acrtc_state = to_dm_crtc_state(pcrtc->state);
 	int planes_count = 0;
@@ -2775,7 +2775,7 @@ void amdgpu_dm_atomic_commit_tail(
 		struct dm_connector_state *con_old_state =
 				to_dm_connector_state(old_conn_state);
 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(con_new_state->base.crtc);
-		const struct dc_stream_status *status = NULL;
+		struct dc_stream_status *status = NULL;
 
 		/* Skip any modesets/resets */
 		if (!acrtc || drm_atomic_crtc_needs_modeset(acrtc->base.state))
@@ -2800,7 +2800,7 @@ void amdgpu_dm_atomic_commit_tail(
 		/*TODO How it works with MPO ?*/
 		if (!dc_commit_surfaces_to_stream(
 				dm->dc,
-				(const struct dc_surface **)status->surfaces,
+				status->surfaces,
 				status->surface_count,
 				new_acrtc_state->stream))
 			dm_error("%s: Failed to update stream scaling!\n", __func__);
@@ -2944,7 +2944,7 @@ static uint32_t add_val_sets_surface(
 	struct dc_validation_set *val_sets,
 	uint32_t set_count,
 	const struct dc_stream *stream,
-	const struct dc_surface *surface)
+	struct dc_surface *surface)
 {
 	uint32_t i = 0, j = 0;
 
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
index 8766698..5ef44ff 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c
@@ -2597,12 +2597,12 @@ static void populate_initial_data(
 		ASSERT(pipe[i].surface);
 
 		if (num_displays == 0) {
-			if (!pipe[i].surface->public.visible)
+			if (!pipe[i].surface->visible)
 				data->d0_underlay_mode = bw_def_underlay_only;
 			else
 				data->d0_underlay_mode = bw_def_blend;
 		} else {
-			if (!pipe[i].surface->public.visible)
+			if (!pipe[i].surface->visible)
 				data->d1_underlay_mode = bw_def_underlay_only;
 			else
 				data->d1_underlay_mode = bw_def_blend;
@@ -2620,7 +2620,7 @@ static void populate_initial_data(
 		data->v_taps[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.taps.v_taps);
 		data->h_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.horz.value);
 		data->v_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.vert.value);
-		switch (pipe[i].surface->public.rotation) {
+		switch (pipe[i].surface->rotation) {
 		case ROTATION_ANGLE_0:
 			data->rotation_angle[num_displays + 4] = bw_int_to_fixed(0);
 			break;
@@ -2636,7 +2636,7 @@ static void populate_initial_data(
 		default:
 			break;
 		}
-		switch (pipe[i].surface->public.format) {
+		switch (pipe[i].surface->format) {
 		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 		case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
 		case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
@@ -2670,14 +2670,14 @@ static void populate_initial_data(
 			data->src_height[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.viewport.height);
 			data->src_width[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.viewport.width);
 			data->pitch_in_pixels[num_displays * 2 + j] = bw_int_to_fixed(
-					pipe[i].bottom_pipe->surface->public.plane_size.grph.surface_pitch);
+					pipe[i].bottom_pipe->surface->plane_size.grph.surface_pitch);
 			data->h_taps[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.taps.h_taps);
 			data->v_taps[num_displays * 2 + j] = bw_int_to_fixed(pipe[i].bottom_pipe->scl_data.taps.v_taps);
 			data->h_scale_ratio[num_displays * 2 + j] = fixed31_32_to_bw_fixed(
 					pipe[i].bottom_pipe->scl_data.ratios.horz.value);
 			data->v_scale_ratio[num_displays * 2 + j] = fixed31_32_to_bw_fixed(
 					pipe[i].bottom_pipe->scl_data.ratios.vert.value);
-			switch (pipe[i].bottom_pipe->surface->public.rotation) {
+			switch (pipe[i].bottom_pipe->surface->rotation) {
 			case ROTATION_ANGLE_0:
 				data->rotation_angle[num_displays * 2 + j] = bw_int_to_fixed(0);
 				break;
@@ -2718,7 +2718,7 @@ static void populate_initial_data(
 			data->v_taps[num_displays + 4] = bw_int_to_fixed(pipe[i].scl_data.taps.v_taps);
 			data->h_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.horz.value);
 			data->v_scale_ratio[num_displays + 4] = fixed31_32_to_bw_fixed(pipe[i].scl_data.ratios.vert.value);
-			switch (pipe[i].surface->public.rotation) {
+			switch (pipe[i].surface->rotation) {
 			case ROTATION_ANGLE_0:
 				data->rotation_angle[num_displays + 4] = bw_int_to_fixed(0);
 				break;
@@ -2734,7 +2734,7 @@ static void populate_initial_data(
 			default:
 				break;
 			}
-			switch (pipe[i].surface->public.format) {
+			switch (pipe[i].surface->format) {
 			case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 			case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 			case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
diff --git a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
index 17b2828..1651b75 100644
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -238,11 +238,11 @@ static void pipe_ctx_to_e2e_pipe_params (
 	else if (pipe->bottom_pipe != NULL && pipe->bottom_pipe->surface == pipe->surface)
 		input->src.is_hsplit = true;
 
-	input->src.dcc                 = pipe->surface->public.dcc.enable;
+	input->src.dcc                 = pipe->surface->dcc.enable;
 	input->src.dcc_rate            = 1;
-	input->src.meta_pitch          = pipe->surface->public.dcc.grph.meta_pitch;
+	input->src.meta_pitch          = pipe->surface->dcc.grph.meta_pitch;
 	input->src.source_scan         = dm_horz;
-	input->src.sw_mode             = pipe->surface->public.tiling_info.gfx9.swizzle;
+	input->src.sw_mode             = pipe->surface->tiling_info.gfx9.swizzle;
 
 	input->src.viewport_width      = pipe->scl_data.viewport.width;
 	input->src.viewport_height     = pipe->scl_data.viewport.height;
@@ -251,7 +251,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	input->src.cur0_src_width      = 128; /* TODO: Cursor calcs, not curently stored */
 	input->src.cur0_bpp            = 32;
 
-	switch (pipe->surface->public.tiling_info.gfx9.swizzle) {
+	switch (pipe->surface->tiling_info.gfx9.swizzle) {
 	/* for 4/8/16 high tiles */
 	case DC_SW_LINEAR:
 		input->src.is_display_sw = 1;
@@ -299,7 +299,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 		break;
 	}
 
-	switch (pipe->surface->public.rotation) {
+	switch (pipe->surface->rotation) {
 	case ROTATION_ANGLE_0:
 	case ROTATION_ANGLE_180:
 		input->src.source_scan = dm_horz;
@@ -314,7 +314,7 @@ static void pipe_ctx_to_e2e_pipe_params (
 	}
 
 	/* TODO: Fix pixel format mappings */
-	switch (pipe->surface->public.format) {
+	switch (pipe->surface->format) {
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 		input->src.source_format = dm_420_8;
@@ -455,7 +455,7 @@ static void dcn_bw_calc_rq_dlg_ttu(
 			true,
 			true,
 			v->pte_enable == dcn_bw_yes,
-			pipe->surface->public.flip_immediate);
+			pipe->surface->flip_immediate);
 }
 
 static void dcn_dml_wm_override(
@@ -527,7 +527,7 @@ static void dcn_dml_wm_override(
 			true,
 			true,
 			v->pte_enable == dcn_bw_yes,
-			pipe->surface->public.flip_immediate);
+			pipe->surface->flip_immediate);
 		in_idx++;
 	}
 	dm_free(input);
@@ -883,7 +883,7 @@ bool dcn_validate_bandwidth(
 			v->scaler_rec_out_width[input_idx] = pipe->scl_data.recout.width;
 			v->scaler_recout_height[input_idx] = pipe->scl_data.recout.height;
 			if (pipe->bottom_pipe && pipe->bottom_pipe->surface == pipe->surface) {
-				if (pipe->surface->public.rotation % 2 == 0) {
+				if (pipe->surface->rotation % 2 == 0) {
 					int viewport_end = pipe->scl_data.viewport.width
 							+ pipe->scl_data.viewport.x;
 					int viewport_b_end = pipe->bottom_pipe->scl_data.viewport.width
@@ -912,17 +912,17 @@ bool dcn_validate_bandwidth(
 						+ pipe->bottom_pipe->scl_data.recout.width;
 			}
 
-			v->dcc_enable[input_idx] = pipe->surface->public.dcc.enable ? dcn_bw_yes : dcn_bw_no;
+			v->dcc_enable[input_idx] = pipe->surface->dcc.enable ? dcn_bw_yes : dcn_bw_no;
 			v->source_pixel_format[input_idx] = tl_pixel_format_to_bw_defs(
-					pipe->surface->public.format);
+					pipe->surface->format);
 			v->source_surface_mode[input_idx] = tl_sw_mode_to_bw_defs(
-					pipe->surface->public.tiling_info.gfx9.swizzle);
+					pipe->surface->tiling_info.gfx9.swizzle);
 			v->lb_bit_per_pixel[input_idx] = tl_lb_bpp_to_int(pipe->scl_data.lb_params.depth);
 			v->override_hta_ps[input_idx] = pipe->scl_data.taps.h_taps;
 			v->override_vta_ps[input_idx] = pipe->scl_data.taps.v_taps;
 			v->override_hta_pschroma[input_idx] = pipe->scl_data.taps.h_taps_c;
 			v->override_vta_pschroma[input_idx] = pipe->scl_data.taps.v_taps_c;
-			v->source_scan[input_idx] = (pipe->surface->public.rotation % 2) ? dcn_bw_vert : dcn_bw_hor;
+			v->source_scan[input_idx] = (pipe->surface->rotation % 2) ? dcn_bw_vert : dcn_bw_hor;
 		}
 		if (v->is_line_buffer_bpp_fixed == dcn_bw_yes)
 			v->lb_bit_per_pixel[input_idx] = v->line_buffer_fixed_bpp;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ed9cc2f..ec4c9c4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -946,8 +946,8 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		const struct core_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			struct core_surface *surface =
-					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
+			const struct dc_surface *surface =
+					context->stream_status[i].surfaces[j];
 
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
 
@@ -1098,7 +1098,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
-		const struct dc_surface **new_surfaces,
+		struct dc_surface **new_surfaces,
 		uint8_t new_surface_count,
 		const struct dc_stream *dc_stream)
 {
@@ -1189,7 +1189,7 @@ static bool is_surface_in_context(
 	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (surface == &pipe_ctx->surface->public) {
+		if (surface == pipe_ctx->surface) {
 			return true;
 		}
 	}
@@ -1422,7 +1422,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		const struct dc_surface *new_surfaces[MAX_SURFACES] = {0};
+		struct dc_surface *new_surfaces[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
 			new_surfaces[i] = srf_updates[i].surface;
@@ -1448,46 +1448,45 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* save update parameters into surface */
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface =
-				DC_SURFACE_TO_CORE(srf_updates[i].surface);
+		struct dc_surface *surface = srf_updates[i].surface;
 
 		if (srf_updates[i].flip_addr) {
-			surface->public.address = srf_updates[i].flip_addr->address;
-			surface->public.flip_immediate =
+			surface->address = srf_updates[i].flip_addr->address;
+			surface->flip_immediate =
 					srf_updates[i].flip_addr->flip_immediate;
 		}
 
 		if (srf_updates[i].scaling_info) {
-			surface->public.scaling_quality =
+			surface->scaling_quality =
 					srf_updates[i].scaling_info->scaling_quality;
-			surface->public.dst_rect =
+			surface->dst_rect =
 					srf_updates[i].scaling_info->dst_rect;
-			surface->public.src_rect =
+			surface->src_rect =
 					srf_updates[i].scaling_info->src_rect;
-			surface->public.clip_rect =
+			surface->clip_rect =
 					srf_updates[i].scaling_info->clip_rect;
 		}
 
 		if (srf_updates[i].plane_info) {
-			surface->public.color_space =
+			surface->color_space =
 					srf_updates[i].plane_info->color_space;
-			surface->public.format =
+			surface->format =
 					srf_updates[i].plane_info->format;
-			surface->public.plane_size =
+			surface->plane_size =
 					srf_updates[i].plane_info->plane_size;
-			surface->public.rotation =
+			surface->rotation =
 					srf_updates[i].plane_info->rotation;
-			surface->public.horizontal_mirror =
+			surface->horizontal_mirror =
 					srf_updates[i].plane_info->horizontal_mirror;
-			surface->public.stereo_format =
+			surface->stereo_format =
 					srf_updates[i].plane_info->stereo_format;
-			surface->public.tiling_info =
+			surface->tiling_info =
 					srf_updates[i].plane_info->tiling_info;
-			surface->public.visible =
+			surface->visible =
 					srf_updates[i].plane_info->visible;
-			surface->public.per_pixel_alpha =
+			surface->per_pixel_alpha =
 					srf_updates[i].plane_info->per_pixel_alpha;
-			surface->public.dcc =
+			surface->dcc =
 					srf_updates[i].plane_info->dcc;
 		}
 
@@ -1503,31 +1502,31 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 
 		if (srf_updates[i].gamma &&
-			srf_updates[i].gamma != surface->public.gamma_correction) {
-			if (surface->public.gamma_correction != NULL)
-				dc_gamma_release(&surface->public.
+			srf_updates[i].gamma != surface->gamma_correction) {
+			if (surface->gamma_correction != NULL)
+				dc_gamma_release(&surface->
 						gamma_correction);
 
 			dc_gamma_retain(srf_updates[i].gamma);
-			surface->public.gamma_correction =
+			surface->gamma_correction =
 						srf_updates[i].gamma;
 		}
 
 		if (srf_updates[i].in_transfer_func &&
-			srf_updates[i].in_transfer_func != surface->public.in_transfer_func) {
-			if (surface->public.in_transfer_func != NULL)
+			srf_updates[i].in_transfer_func != surface->in_transfer_func) {
+			if (surface->in_transfer_func != NULL)
 				dc_transfer_func_release(
-						surface->public.
+						surface->
 						in_transfer_func);
 
 			dc_transfer_func_retain(
 					srf_updates[i].in_transfer_func);
-			surface->public.in_transfer_func =
+			surface->in_transfer_func =
 					srf_updates[i].in_transfer_func;
 		}
 
 		if (srf_updates[i].hdr_static_metadata)
-			surface->public.hdr_static_ctx =
+			surface->hdr_static_ctx =
 				*(srf_updates[i].hdr_static_metadata);
 	}
 
@@ -1543,12 +1542,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	if (update_type > UPDATE_TYPE_FAST) {
 		for (i = 0; i < surface_count; i++) {
-			struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
-
 			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-				if (pipe_ctx->surface != surface)
+				if (pipe_ctx->surface != srf_updates[i].surface)
 					continue;
 
 				core_dc->hwss.wait_for_mpcc_disconnect(core_dc->res_pool, pipe_ctx);
@@ -1561,7 +1558,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
+		struct dc_surface *surface = srf_updates[i].surface;
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1613,7 +1610,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
+		struct dc_surface *surface = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(
@@ -1654,7 +1651,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		for (j = 0; j < surface_count; j++) {
 			if (update_type != UPDATE_TYPE_FULL &&
-					srf_updates[j].surface != &pipe_ctx->surface->public)
+			    srf_updates[j].surface != pipe_ctx->surface)
 				continue;
 			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
 				continue;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7437c3d..857a2a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -428,7 +428,7 @@ static void rect_swap_helper(struct rect *rect)
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	const struct dc_stream *stream = &pipe_ctx->stream->public;
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
@@ -446,8 +446,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		sec_split = false;
 	}
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	/* The actual clip is an intersection between stream
@@ -527,14 +527,14 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	struct core_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	struct rect surf_clip = surface->clip_rect;
 	int recout_full_x, recout_full_y;
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
@@ -605,7 +605,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	struct core_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	const int in_w = stream->public.src.width;
@@ -613,8 +613,8 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 	const int out_w = stream->public.dst.width;
 	const int out_h = stream->public.dst.height;
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
@@ -647,13 +647,13 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect src = pipe_ctx->surface->public.src_rect;
+	struct rect src = pipe_ctx->surface->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
@@ -803,8 +803,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -812,7 +812,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
@@ -822,7 +822,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
 	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
-			pipe_ctx->surface->public.format);
+			pipe_ctx->surface->format);
 
 	calculate_scaling_ratios(pipe_ctx);
 
@@ -1029,7 +1029,7 @@ static int acquire_first_split_pipe(
 #endif
 
 bool resource_attach_surfaces_to_context(
-		const struct dc_surface * const *surfaces,
+		struct dc_surface * const *surfaces,
 		int surface_count,
 		const struct dc_stream *dc_stream,
 		struct validate_context *context,
@@ -1077,7 +1077,7 @@ bool resource_attach_surfaces_to_context(
 
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
+		struct dc_surface *surface = surfaces[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, dc_stream);
 
@@ -1358,7 +1358,7 @@ bool resource_is_stream_unchanged(
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
-	struct core_surface *surface = to_pipe_ctx->surface;
+	struct dc_surface *surface = to_pipe_ctx->surface;
 	struct core_stream *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
@@ -2072,7 +2072,7 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_surface *surface,
+		struct dc_surface *surface,
 		struct core_stream *stream)
 {
 	uint16_t i = 0;
@@ -2083,7 +2083,7 @@ static void set_hdr_static_info_packet(
 	if (!surface)
 		return;
 
-	hdr_metadata = surface->public.hdr_static_ctx;
+	hdr_metadata = surface->hdr_static_ctx;
 
 	if (!hdr_metadata.hdr_supported)
 		return;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index ead7b63..73712fd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -157,7 +157,7 @@ struct dc_stream *dc_create_stream_for_sink(
 	return NULL;
 }
 
-const struct dc_stream_status *dc_stream_get_status(
+struct dc_stream_status *dc_stream_get_status(
 	const struct dc_stream *dc_stream)
 {
 	uint8_t i;
@@ -252,7 +252,7 @@ bool dc_stream_set_cursor_position(
 				!pipe_ctx->ipp || !pipe_ctx->surface)
 			continue;
 
-		if (pipe_ctx->surface->public.address.type
+		if (pipe_ctx->surface->address.type
 				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 			pos_cpy.enable = false;
 
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 3784358..9a21ea7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -47,33 +47,32 @@ struct gamma {
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct core_surface *surface)
+static bool construct(struct dc_context *ctx, struct dc_surface *surface)
 {
 	surface->ctx = ctx;
-	memset(&surface->public.hdr_static_ctx,
+	memset(&surface->hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 
-static void destruct(struct core_surface *surface)
+static void destruct(struct dc_surface *surface)
 {
-	if (surface->public.gamma_correction != NULL) {
-		dc_gamma_release(&surface->public.gamma_correction);
+	if (surface->gamma_correction != NULL) {
+		dc_gamma_release(&surface->gamma_correction);
 	}
-	if (surface->public.in_transfer_func != NULL) {
+	if (surface->in_transfer_func != NULL) {
 		dc_transfer_func_release(
-				surface->public.in_transfer_func);
-		surface->public.in_transfer_func = NULL;
+				surface->in_transfer_func);
+		surface->in_transfer_func = NULL;
 	}
 }
 
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-void enable_surface_flip_reporting(struct dc_surface *dc_surface,
+void enable_surface_flip_reporting(struct dc_surface *surface,
 		uint32_t controller_id)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
 	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
@@ -82,7 +81,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_surface *surface = dm_alloc(sizeof(*surface));
+	struct dc_surface *surface = dm_alloc(sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
@@ -92,7 +91,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 
 	++surface->ref_count;
 
-	return &surface->public;
+	return surface;
 
 construct_fail:
 	dm_free(surface);
@@ -104,20 +103,19 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 const struct dc_surface_status *dc_surface_get_status(
 		const struct dc_surface *dc_surface)
 {
-	struct dc_surface_status *surface_status;
-	struct core_surface *core_surface = DC_SURFACE_TO_CORE(dc_surface);
+	const struct dc_surface_status *surface_status;
 	struct core_dc *core_dc;
 	int i;
 
 	if (!dc_surface ||
-		!core_surface->ctx ||
-		!core_surface->ctx->dc) {
+		!dc_surface->ctx ||
+		!dc_surface->ctx->dc) {
 		ASSERT(0);
 		return NULL; /* remove this if above assert never hit */
 	}
 
-	surface_status = &core_surface->status;
-	core_dc = DC_TO_CORE(core_surface->ctx->dc);
+	surface_status = &dc_surface->status;
+	core_dc = DC_TO_CORE(dc_surface->ctx->dc);
 
 	if (core_dc->current_context == NULL)
 		return NULL;
@@ -126,7 +124,7 @@ const struct dc_surface_status *dc_surface_get_status(
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != core_surface)
+		if (pipe_ctx->surface != dc_surface)
 			continue;
 
 		core_dc->hwss.update_pending_status(pipe_ctx);
@@ -135,18 +133,14 @@ const struct dc_surface_status *dc_surface_get_status(
 	return surface_status;
 }
 
-void dc_surface_retain(const struct dc_surface *dc_surface)
+void dc_surface_retain(struct dc_surface *surface)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
-
 	ASSERT(surface->ref_count > 0);
 	++surface->ref_count;
 }
 
-void dc_surface_release(const struct dc_surface *dc_surface)
+void dc_surface_release(struct dc_surface *surface)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
-
 	ASSERT(surface->ref_count > 0);
 	--surface->ref_count;
 
diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 109657e..5d8f5e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -299,6 +299,18 @@ struct dc_transfer_func {
 	int ref_count;
 };
 
+/*
+ * This structure is filled in by dc_surface_get_status and contains
+ * the last requested address and the currently active address so the called
+ * can determine if there are any outstanding flips
+ */
+struct dc_surface_status {
+	struct dc_plane_address requested_address;
+	struct dc_plane_address current_address;
+	bool is_flip_pending;
+	bool is_right_eye;
+};
+
 struct dc_surface {
 	struct dc_plane_address address;
 
@@ -325,6 +337,14 @@ struct dc_surface {
 	bool visible;
 	bool flip_immediate;
 	bool horizontal_mirror;
+
+	/* private to DC core */
+	struct dc_surface_status status;
+	struct dc_context *ctx;
+
+	/* private to dc_surface.c */
+	enum dc_irq_source irq_source;
+	int ref_count;
 };
 
 struct dc_plane_info {
@@ -348,7 +368,7 @@ struct dc_scaling_info {
 };
 
 struct dc_surface_update {
-	const struct dc_surface *surface;
+	struct dc_surface *surface;
 
 	/* isr safe update parameters.  null means no updates */
 	struct dc_flip_addrs *flip_addr;
@@ -362,17 +382,6 @@ struct dc_surface_update {
 	struct dc_transfer_func *in_transfer_func;
 	struct dc_hdr_static_metadata *hdr_static_metadata;
 };
-/*
- * This structure is filled in by dc_surface_get_status and contains
- * the last requested address and the currently active address so the called
- * can determine if there are any outstanding flips
- */
-struct dc_surface_status {
-	struct dc_plane_address requested_address;
-	struct dc_plane_address current_address;
-	bool is_flip_pending;
-	bool is_right_eye;
-};
 
 /*
  * Create a new surface with default parameters;
@@ -381,8 +390,8 @@ struct dc_surface *dc_create_surface(const struct dc *dc);
 const struct dc_surface_status *dc_surface_get_status(
 		const struct dc_surface *dc_surface);
 
-void dc_surface_retain(const struct dc_surface *dc_surface);
-void dc_surface_release(const struct dc_surface *dc_surface);
+void dc_surface_retain(struct dc_surface *dc_surface);
+void dc_surface_release(struct dc_surface *dc_surface);
 
 void dc_gamma_retain(const struct dc_gamma *dc_gamma);
 void dc_gamma_release(const struct dc_gamma **dc_gamma);
@@ -428,7 +437,7 @@ void dc_flip_surface_addrs(struct dc *dc,
 
 bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
-		const struct dc_surface **dc_surfaces,
+		struct dc_surface **dc_surfaces,
 		uint8_t surface_count,
 		const struct dc_stream *stream);
 
@@ -557,7 +566,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
  */
 struct dc_validation_set {
 	const struct dc_stream *stream;
-	const struct dc_surface *surfaces[MAX_SURFACES];
+	struct dc_surface *surfaces[MAX_SURFACES];
 	uint8_t surface_count;
 };
 
@@ -639,7 +648,7 @@ void dc_stream_release(const struct dc_stream *dc_stream);
 struct dc_stream_status {
 	int primary_otg_inst;
 	int surface_count;
-	const struct dc_surface *surfaces[MAX_SURFACE_NUM];
+	struct dc_surface *surfaces[MAX_SURFACE_NUM];
 
 	/*
 	 * link this stream passes through
@@ -647,7 +656,7 @@ struct dc_stream_status {
 	const struct dc_link *link;
 };
 
-const struct dc_stream_status *dc_stream_get_status(
+struct dc_stream_status *dc_stream_get_status(
 	const struct dc_stream *dc_stream);
 
 enum surface_update_type dc_check_update_surfaces_for_stream(
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
index cc3178a..a8c254f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.c
@@ -193,9 +193,9 @@ void dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,
 }
 
 /* Only use LUT for 8 bit formats */
-bool dce_use_lut(const struct core_surface *surface)
+bool dce_use_lut(const struct dc_surface *surface)
 {
-	switch (surface->public.format) {
+	switch (surface->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		return true;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
index a8a5569..490ca12 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_hwseq.h
@@ -558,5 +558,5 @@ void dce_crtc_switch_to_clk_src(struct dce_hwseq *hws,
 		struct clock_source *clk_src,
 		unsigned int tg_inst);
 
-bool dce_use_lut(const struct core_surface *surface);
+bool dce_use_lut(const struct dc_surface *surface);
 #endif   /*__DCE_HWSEQ_H__*/
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index efba8d7..cf6bf20 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -215,11 +215,11 @@ static bool dce110_enable_display_power_gating(
 }
 
 static void build_prescale_params(struct ipp_prescale_params *prescale_params,
-		const struct core_surface *surface)
+		const struct dc_surface *surface)
 {
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
-	switch (surface->public.format) {
+	switch (surface->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;
@@ -240,7 +240,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_surface *surface)
+	const struct dc_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -250,14 +250,14 @@ static bool dce110_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->public.in_transfer_func)
-		tf = surface->public.in_transfer_func;
+	if (surface->in_transfer_func)
+		tf = surface->in_transfer_func;
 
 	build_prescale_params(&prescale_params, surface);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->public.gamma_correction && dce_use_lut(surface))
-		ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
+	if (surface->gamma_correction && dce_use_lut(surface))
+		ipp->funcs->ipp_program_input_lut(ipp, surface->gamma_correction);
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
@@ -1857,7 +1857,7 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 		default_adjust.in_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.in_color_space =
-				pipe_ctx->surface->public.color_space;
+				pipe_ctx->surface->color_space;
 	if (pipe_ctx->stream == NULL)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
@@ -1908,16 +1908,16 @@ static void program_surface_visibility(const struct core_dc *dc,
 		/* For now we are supporting only two pipes */
 		ASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);
 
-		if (pipe_ctx->bottom_pipe->surface->public.visible) {
-			if (pipe_ctx->surface->public.visible)
+		if (pipe_ctx->bottom_pipe->surface->visible) {
+			if (pipe_ctx->surface->visible)
 				blender_mode = BLND_MODE_BLENDING;
 			else
 				blender_mode = BLND_MODE_OTHER_PIPE;
 
-		} else if (!pipe_ctx->surface->public.visible)
+		} else if (!pipe_ctx->surface->visible)
 			blank_target = true;
 
-	} else if (!pipe_ctx->surface->public.visible)
+	} else if (!pipe_ctx->surface->visible)
 		blank_target = true;
 
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
@@ -1975,7 +1975,7 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	struct mem_input *mi = pipe_ctx->mi;
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2040,42 +2040,42 @@ static void set_plane_config(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->public.format,
-			&surface->public.tiling_info,
-			&surface->public.plane_size,
-			surface->public.rotation,
+			surface->format,
+			&surface->tiling_info,
+			&surface->plane_size,
+			surface->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->public.visible);
+		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->public.format,
-				&surface->public.tiling_info,
-				surface->public.rotation);
+				surface->format,
+				&surface->tiling_info,
+				surface->rotation);
 }
 
 static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
 
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->public.address,
-			surface->public.flip_immediate);
+			&surface->address,
+			surface->flip_immediate);
 
-	surface->status.requested_address = surface->public.address;
+	surface->status.requested_address = surface->address;
 }
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
@@ -2084,7 +2084,7 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
-	if (surface->status.is_flip_pending && !surface->public.visible)
+	if (surface->status.is_flip_pending && !surface->visible)
 		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
 
 	surface->status.current_address = pipe_ctx->mi->current_address;
@@ -2425,7 +2425,7 @@ static void dce110_program_front_end_for_pipe(
 {
 	struct mem_input *mi = pipe_ctx->mi;
 	struct pipe_ctx *old_pipe = NULL;
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2493,21 +2493,21 @@ static void dce110_program_front_end_for_pipe(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->public.format,
-			&surface->public.tiling_info,
-			&surface->public.plane_size,
-			surface->public.rotation,
+			surface->format,
+			&surface->tiling_info,
+			&surface->plane_size,
+			surface->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->public.visible);
+		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->public.format,
-				&surface->public.tiling_info,
-				surface->public.rotation);
+				surface->format,
+				&surface->tiling_info,
+				surface->rotation);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
@@ -2517,20 +2517,20 @@ static void dce110_program_front_end_for_pipe(
 			"clip: %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
 			pipe_ctx->surface,
-			pipe_ctx->surface->public.address.grph.addr.high_part,
-			pipe_ctx->surface->public.address.grph.addr.low_part,
-			pipe_ctx->surface->public.src_rect.x,
-			pipe_ctx->surface->public.src_rect.y,
-			pipe_ctx->surface->public.src_rect.width,
-			pipe_ctx->surface->public.src_rect.height,
-			pipe_ctx->surface->public.dst_rect.x,
-			pipe_ctx->surface->public.dst_rect.y,
-			pipe_ctx->surface->public.dst_rect.width,
-			pipe_ctx->surface->public.dst_rect.height,
-			pipe_ctx->surface->public.clip_rect.x,
-			pipe_ctx->surface->public.clip_rect.y,
-			pipe_ctx->surface->public.clip_rect.width,
-			pipe_ctx->surface->public.clip_rect.height);
+			pipe_ctx->surface->address.grph.addr.high_part,
+			pipe_ctx->surface->address.grph.addr.low_part,
+			pipe_ctx->surface->src_rect.x,
+			pipe_ctx->surface->src_rect.y,
+			pipe_ctx->surface->src_rect.width,
+			pipe_ctx->surface->src_rect.height,
+			pipe_ctx->surface->dst_rect.x,
+			pipe_ctx->surface->dst_rect.y,
+			pipe_ctx->surface->dst_rect.width,
+			pipe_ctx->surface->dst_rect.height,
+			pipe_ctx->surface->clip_rect.x,
+			pipe_ctx->surface->clip_rect.y,
+			pipe_ctx->surface->clip_rect.width,
+			pipe_ctx->surface->clip_rect.height);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe %d: width, height, x, y\n"
@@ -2549,7 +2549,7 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		struct core_surface *surface,
+		const struct dc_surface *surface,
 		struct validate_context *context)
 {
 	int i;
diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
index 8b7bc1c..0fcb1cf 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -766,7 +766,7 @@ static bool is_surface_pixel_format_supported(struct pipe_ctx *pipe_ctx, unsigne
 		return true;
 	if (!pipe_ctx->surface)
 		return false;
-	if (pipe_ctx->surface->public.format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+	if (pipe_ctx->surface->format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 		return false;
 	return true;
 }
diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b794087..4390023 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -945,24 +945,24 @@ static void reset_hw_ctx_wrap(
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
-	if (sec_split && surface->public.address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 		(pipe_ctx->stream->public.timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
 		 pipe_ctx->stream->public.timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
-		*addr = surface->public.address.grph_stereo.left_addr;
-		surface->public.address.grph_stereo.left_addr =
-		surface->public.address.grph_stereo.right_addr;
+		*addr = surface->address.grph_stereo.left_addr;
+		surface->address.grph_stereo.left_addr =
+		surface->address.grph_stereo.right_addr;
 		return true;
 	} else {
 		if (pipe_ctx->stream->public.view_format != VIEW_3D_FORMAT_NONE &&
-			surface->public.address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
-			surface->public.address.type = PLN_ADDR_TYPE_GRPH_STEREO;
-			surface->public.address.grph_stereo.right_addr =
-			surface->public.address.grph_stereo.left_addr;
+			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
+			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
+			surface->address.grph_stereo.right_addr =
+			surface->address.grph_stereo.left_addr;
 		}
 	}
 	return false;
@@ -972,22 +972,22 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->public.address,
-			surface->public.flip_immediate);
-	surface->status.requested_address = surface->public.address;
+			&surface->address,
+			surface->flip_immediate);
+	surface->status.requested_address = surface->address;
 	if (addr_patched)
-		pipe_ctx->surface->public.address.grph_stereo.left_addr = addr;
+		pipe_ctx->surface->address.grph_stereo.left_addr = addr;
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct core_surface *surface)
+	struct pipe_ctx *pipe_ctx, const struct dc_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -996,12 +996,12 @@ static bool dcn10_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->public.in_transfer_func)
-		tf = surface->public.in_transfer_func;
+	if (surface->in_transfer_func)
+		tf = surface->in_transfer_func;
 
-	if (surface->public.gamma_correction && dce_use_lut(surface))
+	if (surface->gamma_correction && dce_use_lut(surface))
 		ipp->funcs->ipp_program_input_lut(ipp,
-				surface->public.gamma_correction);
+				surface->gamma_correction);
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
@@ -1594,7 +1594,7 @@ static void dcn10_power_on_fe(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
-	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
+	struct dc_surface *dc_surface = pipe_ctx->surface;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	power_on_plane(dc->hwseq,
@@ -1710,7 +1710,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->public.visible)
+	if (pipe_ctx->surface->visible)
 		return true;
 	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
 		return true;
@@ -1719,7 +1719,7 @@ static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->public.visible)
+	if (pipe_ctx->surface->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1728,7 +1728,7 @@ static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->public.visible)
+	if (pipe_ctx->surface->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1803,12 +1803,12 @@ static void update_dchubp_dpp(
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	struct core_surface *surface = pipe_ctx->surface;
-	union plane_size size = surface->public.plane_size;
+	struct dc_surface *surface = pipe_ctx->surface;
+	union plane_size size = surface->plane_size;
 	struct default_adjustment ocsc = {0};
 	struct tg_color black_color = {0};
 	struct mpcc_cfg mpcc_cfg;
-	bool per_pixel_alpha = surface->public.per_pixel_alpha && pipe_ctx->bottom_pipe;
+	bool per_pixel_alpha = surface->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1841,12 +1841,12 @@ static void update_dchubp_dpp(
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->public.format,
-				&surface->public.tiling_info,
-				surface->public.rotation);
+				surface->format,
+				&surface->tiling_info,
+				surface->rotation);
 
 	ipp->funcs->ipp_setup(ipp,
-			surface->public.format,
+			surface->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
@@ -1892,12 +1892,12 @@ static void update_dchubp_dpp(
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,
-		surface->public.format,
-		&surface->public.tiling_info,
+		surface->format,
+		&surface->tiling_info,
 		&size,
-		surface->public.rotation,
-		&surface->public.dcc,
-		surface->public.horizontal_mirror);
+		surface->rotation,
+		&surface->dcc,
+		surface->horizontal_mirror);
 
 	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
@@ -1978,7 +1978,7 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		struct core_surface *surface,
+		const struct dc_surface *surface,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2337,7 +2337,7 @@ static bool dcn10_dummy_display_power_gating(
 
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	struct timing_generator *tg = pipe_ctx->tg;
 
 	if (surface->ctx->dc->debug.sanity_checks) {
@@ -2355,7 +2355,7 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 
 	/* DCN we read INUSE address in MI, do we still need this wa? */
 	if (surface->status.is_flip_pending &&
-			!surface->public.visible) {
+			!surface->visible) {
 		pipe_ctx->mi->current_address =
 				pipe_ctx->mi->request_address;
 		BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/display/dc/inc/core_types.h b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
index cc65cfd..07a1aec 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/core_types.h
@@ -40,23 +40,9 @@ struct core_stream;
 
 #define MAX_CLOCK_SOURCES 7
 
-/********* core_surface **********/
-#define DC_SURFACE_TO_CORE(dc_surface) \
-	container_of(dc_surface, struct core_surface, public)
-
 #define DC_GAMMA_TO_CORE(dc_gamma) \
 	container_of(dc_gamma, struct core_gamma, public)
 
-struct core_surface {
-	struct dc_surface public;
-	struct dc_surface_status status;
-	struct dc_context *ctx;
-
-	/* private to dc_surface.c */
-	enum dc_irq_source irq_source;
-	int ref_count;
-};
-
 struct core_gamma {
 	struct dc_gamma public;
 	struct dc_context *ctx;
@@ -263,7 +249,7 @@ struct resource_pool {
 };
 
 struct pipe_ctx {
-	struct core_surface *surface;
+	struct dc_surface *surface;
 	struct core_stream *stream;
 
 	struct mem_input *mi;
diff --git a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
index d865df8..2343beb 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
@@ -59,7 +59,7 @@ struct hw_sequencer_funcs {
 
 	void (*apply_ctx_for_surface)(
 			struct core_dc *dc,
-			struct core_surface *surface,
+			const struct dc_surface *surface,
 			struct validate_context *context);
 
 	void (*set_plane_config)(
@@ -88,7 +88,7 @@ struct hw_sequencer_funcs {
 
 	bool (*set_input_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
-				const struct core_surface *surface);
+				const struct dc_surface *surface);
 
 	bool (*set_output_transfer_func)(
 				struct pipe_ctx *pipe_ctx,
diff --git a/drivers/gpu/drm/amd/display/dc/inc/resource.h b/drivers/gpu/drm/amd/display/dc/inc/resource.h
index 04e5fd1..ed94df1 100644
--- a/drivers/gpu/drm/amd/display/dc/inc/resource.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/resource.h
@@ -119,7 +119,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 		const struct core_stream *stream);
 
 bool resource_attach_surfaces_to_context(
-		const struct dc_surface *const *surfaces,
+		struct dc_surface *const *surfaces,
 		int surface_count,
 		const struct dc_stream *dc_stream,
 		struct validate_context *context,
-- 
2.7.4

