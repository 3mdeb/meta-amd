meta-seattle
============

This is the location for AMD Seattle maintained BSP.


Overview of AMD 64-bit ARM-based processor
------------------------------------------

The AMD Opteron A1100-Series features AMDs first 64-bit ARM-based processor, codenamed "Seattle".


Yocto Project Compatible
========================

This BSP is compatible with the Yocto Project as per the requirements
listed here:

  https://www.yoctoproject.org/webform/yocto-project-compatible-registration

Dependencies
============

This layer depends on:

  URI: git://git.openembedded.org/bitbake
  branch: master

  URI: git://git.openembedded.org/openembedded-core
  layers: meta
  branch: master

Patches
=======

Please submit any patches against this BSP to the maintainer and cc
the meta-amd mailing list (meta-amd@yoctoproject.org):

Maintainer: Adrian Calianu <adrian.calianu@enea.com>


Table of Contents
=================

  I. Building the meta-seattle BSP layer
 II. Booting the images
III. How to Run 32-bit Applications on aarch64
 IV. Limitations


I. Building the meta-seattle BSP layer
=======================================

The following instructions require a Poky installation (or equivalent).

Initialize a build using the 'oe-init-build-env' script in Poky.
    $ source oe-init-build-env <build_dir>

Once initialized configure bblayers.conf by adding the 'meta-seattle' layer. e.g.:

    BBLAYERS ?= " \
        <path to layer>/oe-core/meta \
        <path to layer>/meta-amd/meta-seattle \
        "

To build a specific target BSP configure the associated machine in local.conf.
There are two machines defined in order to offer support for Little Endian ("seattle",
default machine) and Big Endian ("seattle-be").

    MACHINE ?= "seattle"

Build the target file system image using bitbake:

    $ bitbake core-image-minimal

Once complete the images for the target machine will be available in the output
directory 'tmp/deploy/images'.


II. Booting the images
=====================================

Booting the images using UEFI firmware

At power-on, the UEFI firmware starts a UEFI bootloader which looks up the EFI
System Partition (ESP) for a script named startup.nsh.
If the script specifies an executable file in the ESP, that file is executed
as a UEFI application.

If no UEFI application can be started, or if the boot process is interrupted
by ESC, the EFI Shell is started with prompt "Shell>". Here you can execute
shell commands or UEFI applications interactively.

A UEFI application can be e.g. a Linux kernel built with an EFI stub. By executing
the EFI-stubbed kernel as an application with arguments, you can control
how to boot Linux, and which rootfs to use.

Boot existing Linux images or install HDD on a different machine,
mount EFI partition and copy kernel image under this partition.

Boot Linux images from UEFI shell with rootfs in RAM
Before that, copy rootfs under EFI partition(FAT).

Shell> FS0:\Image initrd=\core-image-minimal.ext2.gz root=/dev/ram0 rw
 console=ttyAMA0,115200n8 ramdisk_size=524280

Boot Linux images from UEFI shell with rootfs on a HDD ext2/3/4 partition.
Before that, install rootfs under a /dev/sda<X> ext2/3/4 formated partition.

Shell> FS0:\Image root=/dev/sda<X> rw console=ttyAMA0,115200n8

References:
1) https://www.kernel.org/doc/Documentation/efi-stub.txt
2) http://www.uefi.org/specifications
