From 67dbe4a2079ea7c0ed37736b17d37daa92526ab1 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Thu, 16 Jul 2015 06:37:09 -0400
Subject: [PATCH 375/401] amd/dal: Fix checkpatch.pl style errors

Reviewed-By: Jordan Lazare <Jordan.Lazare@amd.com>
Signed-off-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/dal/adapter/adapter_service.c  |  46 ++---
 .../adapter/dce110/hw_ctx_adapter_service_dce110.c |   9 +-
 .../gpu/drm/amd/dal/adapter/wireless_data_source.c |   3 -
 drivers/gpu/drm/amd/dal/audio/audio.c              |   3 +
 .../gpu/drm/amd/dal/audio/dce110/audio_dce110.c    |   2 +
 .../drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c |   8 +-
 drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.c       |   2 +-
 drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.h       |   2 +-
 drivers/gpu/drm/amd/dal/basics/fixed31_32.c        |   1 +
 drivers/gpu/drm/amd/dal/basics/fixed32_32.c        |   9 +
 drivers/gpu/drm/amd/dal/basics/flat_set.c          |   2 +
 drivers/gpu/drm/amd/dal/basics/grph_object_id.c    |   1 +
 drivers/gpu/drm/amd/dal/basics/logger.c            |  58 ++++---
 drivers/gpu/drm/amd/dal/basics/register_logger.c   |   5 +-
 drivers/gpu/drm/amd/dal/basics/vector.c            |   2 +
 drivers/gpu/drm/amd/dal/bios/bios_parser.c         |  32 +++-
 drivers/gpu/drm/amd/dal/bios/command_table.c       |  11 +-
 .../gpu/drm/amd/dal/bios/command_table_helper.c    |   2 +-
 .../dal/bios/dce110/command_table_helper_dce110.c  |   3 +
 drivers/gpu/drm/amd/dal/controller/controller.c    |   2 -
 drivers/gpu/drm/amd/dal/controller/csc_video.c     |   2 +
 drivers/gpu/drm/amd/dal/controller/cursor.c        |   5 +-
 .../amd/dal/controller/dce110/col_man_csc_dce110.c |  54 +++---
 .../amd/dal/controller/dce110/controller_dce110.c  |  15 +-
 .../dal/controller/dce110/controller_v_dce110.c    | 170 ++++++++-----------
 .../gpu/drm/amd/dal/controller/dce110/csc_dce110.c |   2 +-
 .../drm/amd/dal/controller/dce110/cursor_dce110.c  |   6 +
 .../dce110/dcp_bit_depth_reduction_dce110.c        |   1 +
 .../gpu/drm/amd/dal/controller/dce110/fbc_dce110.c |   2 +
 .../amd/dal/controller/dce110/formatter_dce110.c   |   3 +
 .../amd/dal/controller/dce110/grph_gamma_dce110.c  |   1 +
 .../amd/dal/controller/dce110/line_buffer_dce110.c |   3 +
 .../dal/controller/dce110/line_buffer_v_dce110.c   |   1 +
 .../drm/amd/dal/controller/dce110/scaler_dce110.c  |  15 +-
 .../amd/dal/controller/dce110/scaler_v_dce110.c    |  12 +-
 .../drm/amd/dal/controller/dce110/surface_dce110.c |   5 +
 .../amd/dal/controller/dce110/surface_v_dce110.c   |   4 +
 .../controller/dce110/timing_generator_dce110.c    |  14 +-
 .../amd/dal/controller/graphics_and_video_gamma.c  |  11 +-
 .../gpu/drm/amd/dal/controller/timing_generator.c  |   1 +
 drivers/gpu/drm/amd/dal/controller/video_gamma.c   |   6 +
 drivers/gpu/drm/amd/dal/dcs/dcs.c                  |  17 +-
 drivers/gpu/drm/amd/dal/dcs/ddc_i2caux_helper.c    |   8 +-
 drivers/gpu/drm/amd/dal/dcs/ddc_service.c          |   9 +-
 drivers/gpu/drm/amd/dal/dcs/edid/edid.c            |   1 +
 drivers/gpu/drm/amd/dal/dcs/edid/edid13.c          |   7 +
 drivers/gpu/drm/amd/dal/dcs/edid/edid14.c          |   3 +
 drivers/gpu/drm/amd/dal/dcs/edid/edid1x_data.h     |   6 +-
 drivers/gpu/drm/amd/dal/dcs/edid/edid20.c          |   4 +
 drivers/gpu/drm/amd/dal/dcs/edid/edid_base.c       |  30 +++-
 drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c    |   9 +
 drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c     |   1 +
 .../gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c    |   1 +
 drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c    |   3 +
 drivers/gpu/drm/amd/dal/dcs/edid_mgr.c             |  24 +--
 drivers/gpu/drm/amd/dal/dcs/edid_patch.c           |   9 +-
 drivers/gpu/drm/amd/dal/dcs/monitor_tables.c       |   1 +
 drivers/gpu/drm/amd/dal/dcs/vbios_dco.c            |   3 +
 .../gpu/drm/amd/dal/display_path/display_path.c    |  24 ++-
 .../drm/amd/dal/display_service/adjustment_api.c   |  10 +-
 .../amd/dal/display_service/adjustment_container.c |   7 +-
 .../amd/dal/display_service/backlight_adj_group.c  |   5 +
 .../amd/dal/display_service/color_temperature.c    | 186 ++++++++++-----------
 .../drm/amd/dal/display_service/display_service.c  |   2 +
 .../drm/amd/dal/display_service/ds_calculation.c   |   5 +-
 .../dal/display_service/ds_dispatch_adjustment.c   |  11 +-
 .../dal/display_service/ds_dispatch_mode_setting.c |   3 +
 .../gpu/drm/amd/dal/display_service/gamut_space.c  |  59 ++++---
 .../amd/dal/display_service/grph_colors_group.c    |   6 +
 .../drm/amd/dal/display_service/path_mode_set.c    |   4 +
 .../dal/display_service/path_mode_set_with_data.c  |   7 +-
 .../drm/amd/dal/display_service/scaler_adj_group.c |  65 +++----
 .../drm/amd/dal/display_service/set_mode_params.c  |  10 +-
 .../drm/amd/dal/display_service/single_adj_group.c |   1 +
 .../encoder/dce110/digital_encoder_edp_dce110.c    |   4 +-
 .../encoder/dce110/hw_ctx_digital_encoder_dce110.c |  19 ++-
 drivers/gpu/drm/amd/dal/encoder/digital_encoder.c  |   4 +-
 .../gpu/drm/amd/dal/encoder/digital_encoder_dp.c   |   1 +
 drivers/gpu/drm/amd/dal/encoder/encoder.c          |   4 +-
 drivers/gpu/drm/amd/dal/encoder/encoder_impl.c     |   6 -
 .../drm/amd/dal/encoder/external_digital_encoder.c |   1 +
 .../gpu/drm/amd/dal/gpio/dce110/hw_hpd_dce110.c    |   1 +
 drivers/gpu/drm/amd/dal/gpio/gpio_service.c        |  10 +-
 drivers/gpu/drm/amd/dal/gpio/hw_factory.h          |   1 +
 drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c    |   1 +
 .../gpu/drm/amd/dal/gpu/calc_pll_clock_source.c    |   1 +
 drivers/gpu/drm/amd/dal/gpu/clock_source.c         |  25 ++-
 .../amd/dal/gpu/dce110/bandwidth_manager_dce110.c  |  11 +-
 .../amd/dal/gpu/dce110/dc_clock_gating_dce110.c    |   9 +-
 .../drm/amd/dal/gpu/dce110/display_clock_dce110.c  |  10 +-
 drivers/gpu/drm/amd/dal/gpu/dce110/gpu_dce110.c    |   8 +-
 .../amd/dal/gpu/dce110/pll_clock_source_dce110.c   |   3 +-
 .../amd/dal/gpu/dce110/vce_clock_source_dce110.c   |   1 +
 drivers/gpu/drm/amd/dal/gpu/gpu.c                  |   2 +-
 drivers/gpu/drm/amd/dal/gpu/pll_clock_source.c     |   2 +
 .../dal/hw_sequencer/dce110/hw_sequencer_dce110.c  |   7 +-
 .../gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c    |  20 +++
 .../dal/hw_sequencer/hw_sequencer_adjustments.c    |   1 +
 .../amd/dal/hw_sequencer/hw_sequencer_helpers.c    |   2 +
 .../amd/dal/hw_sequencer/hw_sequencer_parameters.c |   6 +-
 .../gpu/drm/amd/dal/hw_sequencer/hw_sync_control.c |   1 +
 .../drm/amd/dal/i2caux/dce110/aux_engine_dce110.c  |  22 +--
 .../amd/dal/i2caux/dce110/i2c_hw_engine_dce110.c   |  10 +-
 .../amd/dal/i2caux/dce110/i2c_sw_engine_dce110.c   |   1 +
 drivers/gpu/drm/amd/dal/i2caux/i2caux.c            |   1 +
 drivers/gpu/drm/amd/dal/include/adjustment_types.h |   4 +-
 drivers/gpu/drm/amd/dal/include/bit_set.h          |   1 +
 drivers/gpu/drm/amd/dal/include/csc_common_types.h |   2 +-
 .../dal/include/dpcd_access_service_interface.h    |  45 ++---
 .../gpu/drm/amd/dal/include/hw_sequencer_types.h   |  10 --
 drivers/gpu/drm/amd/dal/include/isr_config_types.h |   6 +-
 drivers/gpu/drm/amd/dal/include/logger_interface.h |   4 +-
 drivers/gpu/drm/amd/dal/include/plane_types.h      |   9 +-
 drivers/gpu/drm/amd/dal/interface/dal.c            |  49 +++---
 .../gpu/drm/amd/dal/interface/timing_list_query.c  |   2 +
 .../drm/amd/dal/link_service/dpsst_link_service.c  |  54 +++---
 .../gpu/drm/amd/dal/link_service/link_service.c    |   8 +
 drivers/gpu/drm/amd/dal/mode_manager/best_view.c   |  12 +-
 .../gpu/drm/amd/dal/mode_manager/candidate_list.c  |   3 +
 .../gpu/drm/amd/dal/mode_manager/candidate_list.h  |   1 -
 .../cofunctional_mode_query_validator.c            |   2 +
 .../dal/mode_manager/cofunctional_mode_validator.c |   1 +
 .../mode_manager/display_view_solution_container.c |   2 +
 .../gpu/drm/amd/dal/mode_manager/mode_manager.c    |   4 +
 .../drm/amd/dal/mode_manager/mode_manager_types.c  |   3 +
 drivers/gpu/drm/amd/dal/mode_manager/mode_query.c  |  14 ++
 .../amd/dal/mode_manager/mode_query_allow_pan.c    |  21 ++-
 .../drm/amd/dal/mode_manager/mode_query_no_pan.c   |   2 +
 .../gpu/drm/amd/dal/mode_manager/mode_query_set.c  |   1 +
 .../gpu/drm/amd/dal/mode_manager/mode_query_set.h  |   1 +
 drivers/gpu/drm/amd/dal/mode_manager/solution.c    |   1 +
 drivers/gpu/drm/amd/dal/mode_manager/solution.h    |   3 +
 .../gpu/drm/amd/dal/mode_manager/view_solution.c   |   1 +
 .../drm/amd/dal/timing_service/default_mode_list.c |   1 +
 .../drm/amd/dal/timing_service/mode_timing_list.c  |   4 +-
 .../dal/timing_service/mode_timing_source_cea770.c |   2 +
 .../timing_service/mode_timing_source_cea861d.c    |   3 +
 .../timing_service/mode_timing_source_cea861e.c    |   3 +
 .../dal/timing_service/mode_timing_source_dmt.c    |   2 +
 .../timing_service/mode_timing_source_hdmi_vic.c   |   2 +
 .../drm/amd/dal/timing_service/timing_service.c    |   8 +-
 .../gpu/drm/amd/dal/topology/tm_detection_mgr.c    |   5 +
 .../gpu/drm/amd/dal/topology/tm_internal_types.h   |  28 ++--
 drivers/gpu/drm/amd/dal/topology/tm_resource.c     |   1 +
 .../gpu/drm/amd/dal/topology/tm_resource_builder.c |  81 ++++-----
 drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c |  44 ++---
 .../gpu/drm/amd/dal/topology/tm_subsets_cache.c    |  46 ++---
 drivers/gpu/drm/amd/dal/topology/tm_utils.c        |  48 +++---
 drivers/gpu/drm/amd/dal/topology/topology.c        |  92 +++++-----
 149 files changed, 1127 insertions(+), 781 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/adapter/adapter_service.c b/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
index 3317595..d284afb 100644
--- a/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
+++ b/drivers/gpu/drm/amd/dal/adapter/adapter_service.c
@@ -298,7 +298,7 @@ static void initialize_backlight_caps(
 						as->backlight_8bit_lut[index-1];
 				uint16_t delta_signal =
 						signal_level - base_value;
-				uint16_t delta_luma = luminance - index + 1 ;
+				uint16_t delta_luma = luminance - index + 1;
 				uint16_t step = delta_signal;
 
 				for (; index < luminance ; index++) {
@@ -357,7 +357,6 @@ static void initialize_backlight_caps(
 		}
 	}
 	as->backlight_caps_initialized = true;
-	return;
 }
 
 static void log_overriden_features(
@@ -424,6 +423,7 @@ static bool override_default_parameters(
 	bool ret = false;
 	bool bool_feature = true;
 	char *feature_name;
+
 	if (idx >= get_feature_entries_num()) {
 		ASSERT_CRITICAL(false);
 		return false;
@@ -632,9 +632,11 @@ static bool generate_feature_set(
 		if (!override_default_parameters(as, param, i, &value)) {
 			if (!get_feature_value_from_data_sources(
 					as, i, &value)) {
-				/* Can't find feature values from 
-				 * 	above data sources
-				 * Assign default value */
+				/*
+				 * Can't find feature values from
+				 * above data sources
+				 * Assign default value
+				 */
 				value = entry->default_value;
 			}
 		}
@@ -698,8 +700,6 @@ static bool adapter_service_construct(
 	struct adapter_service *as,
 	struct as_init_data *init_data)
 {
-	struct wireless_init_data wireless_init;
-
 	if (!init_data)
 		return false;
 
@@ -716,6 +716,7 @@ static bool adapter_service_construct(
 #if defined(DAL_CZ_BRINGUP)
 	if (dal_adapter_service_get_dce_version(as) == DCE_VERSION_11_0) {
 		uint32_t i;
+
 		for (i = 0; i < ARRAY_SIZE(feature_entry_table); i++) {
 			enum adapter_feature_id id =
 				feature_entry_table[i].feature_id;
@@ -1163,6 +1164,7 @@ uint32_t dal_adapter_service_get_max_cofunc_non_dp_displays(void)
 uint32_t dal_adapter_service_get_single_selected_timing_signals(void)
 {
 	uint32_t signals_bitmap = 0;
+
 	if (dal_adapter_service_is_feature_supported(
 			FEATURE_REPORT_SINGLE_SELECTED_TIMING)) {
 		/* the cached value exist */
@@ -1493,12 +1495,12 @@ struct gpio *dal_adapter_service_obtain_stereo_gpio(
 		return dal_gpio_service_create_gpio_ex(
 			as->gpio_service, GPIO_ID_GENERIC, GPIO_GENERIC_A,
 			GPIO_PIN_OUTPUT_STATE_ACTIVE_LOW);
-       /* Case 2 : runtime parameter override for sideband stereo */
-       else if (have_param_stereo_gpio) {
-               /* TODO implement */
-               return NULL;
-       /* Case 3 : VBIOS gives us GPIO for sideband stereo */
-       } else {
+	/* Case 2 : runtime parameter override for sideband stereo */
+	else if (have_param_stereo_gpio) {
+		/* TODO implement */
+		return NULL;
+	/* Case 3 : VBIOS gives us GPIO for sideband stereo */
+	} else {
 		const struct graphics_object_id id =
 			dal_graphics_object_id_init(
 				GENERIC_ID_STEREO,
@@ -1734,6 +1736,7 @@ bool dal_adapter_service_get_embedded_panel_info(
 	struct embedded_panel_info *info)
 {
 	enum bp_result result;
+
 	if (info == NULL)
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
@@ -1750,6 +1753,7 @@ bool dal_adapter_service_enum_embedded_panel_patch_mode(
 	struct embedded_panel_patch_mode *mode)
 {
 	enum bp_result result;
+
 	if (mode == NULL)
 		/*TODO: add DALASSERT_MSG here*/
 		return false;
@@ -1765,6 +1769,7 @@ bool dal_adapter_service_get_faked_edid_len(
 	uint32_t *len)
 {
 	enum bp_result result;
+
 	result = dal_bios_parser_get_faked_edid_len(
 		as->bios_parser,
 		len);
@@ -1777,6 +1782,7 @@ bool dal_adapter_service_get_faked_edid_buf(
 	uint32_t len)
 {
 	enum bp_result result;
+
 	result = dal_bios_parser_get_faked_edid_buf(
 		as->bios_parser,
 		buf,
@@ -1915,13 +1921,12 @@ bool dal_adapter_service_is_lid_open(struct adapter_service *as)
 	if ((PM_GET_LID_STATE & as->platform_methods_mask) &&
 		dal_get_platform_info(as->dal_context, &params))
 		return is_lid_open;
-	else {
+
 #if defined(CONFIG_DRM_AMD_DAL_VBIOS_PRESENT)
-		return dal_bios_parser_is_lid_open(as->bios_parser);
+	return dal_bios_parser_is_lid_open(as->bios_parser);
 #else
-		return false;
+	return false;
 #endif
-	}
 }
 
 bool dal_adapter_service_get_panel_backlight_default_levels(
@@ -1992,13 +1997,14 @@ bool dal_adapter_service_get_encoder_cap_info(
 	struct bp_encoder_cap_info bp_cap_info = {0};
 	enum bp_result result;
 
-	if (NULL == info)
-	{
+	if (NULL == info) {
 		ASSERT_CRITICAL(false);
 		return false;
 	}
 
-	/* Retrieve Encoder Capability Information from VBIOS and store the call result (success or fail)
+	/*
+	 * Retrieve Encoder Capability Information from VBIOS and store the
+	 * call result (success or fail)
 	 * Info from VBIOS about HBR2 has two fields:
 	 *
 	 * - dpHbr2Cap: indicates supported/not supported by HW Encoder
diff --git a/drivers/gpu/drm/amd/dal/adapter/dce110/hw_ctx_adapter_service_dce110.c b/drivers/gpu/drm/amd/dal/adapter/dce110/hw_ctx_adapter_service_dce110.c
index 2873775..7a4b68a 100644
--- a/drivers/gpu/drm/amd/dal/adapter/dce110/hw_ctx_adapter_service_dce110.c
+++ b/drivers/gpu/drm/amd/dal/adapter/dce110/hw_ctx_adapter_service_dce110.c
@@ -48,9 +48,6 @@ static const struct graphics_object_id invalid_go = {
 };
 
 /* Macro */
-#define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL( \
-	LOG_MINOR_COMPONENT_ADAPTER_SERVICE, "HWCTX_AS:%s()\n", __func__);
-
 #define AUDIO_STRAPS_HDMI_ENABLE 0x2
 
 #define FROM_HW_CTX(ptr) \
@@ -139,6 +136,7 @@ static uint32_t get_number_of_connected_audio_endpoints_multistream(
 	 */
 	for (i = 0; i < MAX_NUMBER_OF_AUDIO_PINS; i++) {
 		uint32_t value = 0;
+
 		set_reg_field_value(value,
 			default_config,
 			AZALIA_F0_CODEC_ENDPOINT_INDEX,
@@ -216,17 +214,14 @@ static bool power_up(
 	hw_ctx->cached_audio_straps = AUDIO_STRAPS_DP_AUDIO_ALLOWED;
 
 	{
-		uint32_t addr = mmCC_DC_HDMI_STRAPS;
 		uint32_t value = 0;
 		uint32_t field = 0;
 
-		value = dal_read_reg(hw_ctx->dal_context, addr);
+		value = dal_read_reg(hw_ctx->dal_context, mmCC_DC_HDMI_STRAPS);
 		field = get_reg_field_value(
 				value, CC_DC_HDMI_STRAPS, HDMI_DISABLE);
 		if (field == 0) {
 
-			addr = mmDC_PINSTRAPS;
-
 			value = dal_read_reg(
 					hw_ctx->dal_context, mmDC_PINSTRAPS);
 
diff --git a/drivers/gpu/drm/amd/dal/adapter/wireless_data_source.c b/drivers/gpu/drm/amd/dal/adapter/wireless_data_source.c
index 88ba307..368dbc5 100644
--- a/drivers/gpu/drm/amd/dal/adapter/wireless_data_source.c
+++ b/drivers/gpu/drm/amd/dal/adapter/wireless_data_source.c
@@ -156,7 +156,6 @@ struct graphics_object_id wireless_get_connector_id(
 		break;
 	default:
 		return unknown_object_id;
-		break;
 	}
 }
 
@@ -167,10 +166,8 @@ uint8_t wireless_get_srcs_num(
 	switch (id.type) {
 	case OBJECT_TYPE_CONNECTOR:
 		return wireless_get_encoders_num(as);
-		break;
 	case OBJECT_TYPE_ENCODER:
 		return 1;
-		break;
 
 	default:
 		ASSERT_CRITICAL(false);
diff --git a/drivers/gpu/drm/amd/dal/audio/audio.c b/drivers/gpu/drm/amd/dal/audio/audio.c
index 6f67ef2..4c70354 100644
--- a/drivers/gpu/drm/amd/dal/audio/audio.c
+++ b/drivers/gpu/drm/amd/dal/audio/audio.c
@@ -148,6 +148,7 @@ static struct audio_feature_support get_supported_features(struct audio *audio)
 {
 	/*DCE specific, must be implemented in derived*/
 	struct audio_feature_support features;
+
 	dal_memset(&features, 0, sizeof(features));
 
 	features.ENGINE_DIGA = 1;
@@ -181,6 +182,7 @@ bool dal_audio_construct_base(
 	const struct audio_init_data *init_data)
 {
 	enum signal_type signals = SIGNAL_TYPE_HDMI_TYPE_A;
+
 	ASSERT(init_data->as != NULL);
 
 	/* base hook functions */
@@ -254,6 +256,7 @@ struct audio *dal_audio_create(
 	const struct audio_init_data *init_data)
 {
 	struct adapter_service *as;
+
 	if (init_data->as == NULL)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/audio/dce110/audio_dce110.c b/drivers/gpu/drm/amd/dal/audio/dce110/audio_dce110.c
index 59e5321..6958017 100644
--- a/drivers/gpu/drm/amd/dal/audio/dce110/audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/audio/dce110/audio_dce110.c
@@ -284,6 +284,7 @@ static enum audio_result initialize(
 	struct audio *audio)
 {
 	uint8_t audio_endpoint_enum_id = 0;
+
 	audio_endpoint_enum_id = audio->id.enum_id;
 
 	/* HW CTX already create*/
@@ -426,6 +427,7 @@ struct audio *dal_audio_create_dce110(
 {
 	/*allocate memory for audio_dce110 */
 	struct audio_dce110 *audio = dal_alloc(sizeof(*audio));
+
 	if (audio == NULL) {
 		ASSERT_CRITICAL(audio);
 		return NULL;
diff --git a/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c b/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c
index 2cbd3fd..24fc94e 100644
--- a/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c
+++ b/drivers/gpu/drm/amd/dal/audio/dce110/hw_ctx_audio_dce110.c
@@ -46,7 +46,7 @@
 #define FIRST_AUDIO_STREAM_ID 1
 
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_AUDIO, \
-			"Audio:%s()\n", __func__);
+			"Audio:%s()\n", __func__)
 
 static const uint32_t engine_offset[] = {
 	0,
@@ -65,6 +65,7 @@ static void destroy(
 	struct hw_ctx_audio **ptr)
 {
 	struct hw_ctx_audio_dce110 *hw_ctx_dce110;
+
 	hw_ctx_dce110 = container_of(
 		*ptr, struct hw_ctx_audio_dce110, base);
 
@@ -849,6 +850,7 @@ static void setup_vce_audio(
 	const struct hw_ctx_audio *hw_ctx)
 {
 	struct dal_context *dal_context = hw_ctx->ctx;
+
 	NOT_IMPLEMENTED();
 
 	/*TODO:
@@ -1462,8 +1464,8 @@ static void setup_azalia(
 	{
 		const uint32_t addr =
 			mmAFMT_AUDIO_PACKET_CONTROL2 + engine_offset[engine_id];
-
 		uint32_t value = dal_read_reg(hw_ctx->ctx, addr);
+
 		set_reg_field_value(value,
 			channels,
 			AFMT_AUDIO_PACKET_CONTROL2,
@@ -1608,6 +1610,7 @@ static void set_unsolicited_response_payload(
 	/* set the payload value for the unsolicited response
 	 Jack presence is not required to be enabled */
 	uint32_t value = 0;
+
 	value = read_indirect_azalia_reg(
 		hw_ctx,
 		ixAZALIA_F0_CODEC_PIN_CONTROL_UNSOLICITED_RESPONSE_FORCE);
@@ -1647,6 +1650,7 @@ static void hw_initialize(
 	addr = mmAZALIA_F0_CODEC_FUNCTION_PARAMETER_SUPPORTED_SIZE_RATES;
 	{
 		uint32_t value;
+
 		value = dal_read_reg(hw_ctx->ctx, addr);
 
 		set_reg_field_value(value, 0x70,
diff --git a/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.c b/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.c
index 4839b34..37d61dd 100644
--- a/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.c
+++ b/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.c
@@ -181,7 +181,7 @@ static void disable_dp_audio(
 /* setup Azalia HW block */
 static void setup_azalia(
 	const struct hw_ctx_audio *hw_ctx,
-	enum engine_id engine_id ,
+	enum engine_id engine_id,
 	enum signal_type signal,
 	const struct audio_crtc_info *crtc_info,
 	const struct audio_pll_info *pll_info,
diff --git a/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.h b/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.h
index ad27ea2..da0a33c 100644
--- a/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.h
+++ b/drivers/gpu/drm/amd/dal/audio/hw_ctx_audio.h
@@ -96,7 +96,7 @@ struct hw_ctx_audio_funcs {
 	/* setup Azalia HW block */
 	void (*setup_azalia)(
 		const struct hw_ctx_audio *hw_ctx,
-		enum engine_id engine_id ,
+		enum engine_id engine_id,
 		enum signal_type signal,
 		const struct audio_crtc_info *crtc_info,
 		const struct audio_pll_info *pll_info,
diff --git a/drivers/gpu/drm/amd/dal/basics/fixed31_32.c b/drivers/gpu/drm/amd/dal/basics/fixed31_32.c
index ba21695..e016dc3 100644
--- a/drivers/gpu/drm/amd/dal/basics/fixed31_32.c
+++ b/drivers/gpu/drm/amd/dal/basics/fixed31_32.c
@@ -46,6 +46,7 @@ static inline uint64_t complete_integer_division_u64(
 	uint64_t *remainder)
 {
 	uint64_t result;
+
 	ASSERT(divisor);
 
 	result = div64_u64_rem(dividend, divisor, remainder);
diff --git a/drivers/gpu/drm/amd/dal/basics/fixed32_32.c b/drivers/gpu/drm/amd/dal/basics/fixed32_32.c
index 765f18f..dd5f915 100644
--- a/drivers/gpu/drm/amd/dal/basics/fixed32_32.c
+++ b/drivers/gpu/drm/amd/dal/basics/fixed32_32.c
@@ -52,6 +52,7 @@ static uint64_t u64_div(uint64_t n, uint64_t d)
 struct fixed32_32 dal_fixed32_32_from_fraction(uint32_t n, uint32_t d)
 {
 	struct fixed32_32 fx;
+
 	fx.value = u64_div((uint64_t)n << 32, (uint64_t)d << 32);
 	return fx;
 }
@@ -59,6 +60,7 @@ struct fixed32_32 dal_fixed32_32_from_fraction(uint32_t n, uint32_t d)
 struct fixed32_32 dal_fixed32_32_from_int(uint32_t value)
 {
 	struct fixed32_32 fx;
+
 	fx.value = (uint64_t)value<<32;
 	return fx;
 }
@@ -68,6 +70,7 @@ struct fixed32_32 dal_fixed32_32_add(
 	struct fixed32_32 rhs)
 {
 	struct fixed32_32 fx = {lhs.value + rhs.value};
+
 	ASSERT(fx.value >= rhs.value);
 	return fx;
 }
@@ -75,6 +78,7 @@ struct fixed32_32 dal_fixed32_32_add(
 struct fixed32_32 dal_fixed32_32_add_int(struct fixed32_32 lhs, uint32_t rhs)
 {
 	struct fixed32_32 fx = {lhs.value + ((uint64_t)rhs << 32)};
+
 	ASSERT(fx.value >= (uint64_t)rhs << 32);
 	return fx;
 
@@ -84,6 +88,7 @@ struct fixed32_32 dal_fixed32_32_sub(
 	struct fixed32_32 rhs)
 {
 	struct fixed32_32 fx;
+
 	ASSERT(lhs.value >= rhs.value);
 	fx.value = lhs.value - rhs.value;
 	return fx;
@@ -92,6 +97,7 @@ struct fixed32_32 dal_fixed32_32_sub(
 struct fixed32_32 dal_fixed32_32_sub_int(struct fixed32_32 lhs, uint32_t rhs)
 {
 	struct fixed32_32 fx;
+
 	ASSERT(lhs.value >= ((uint64_t)rhs<<32));
 	fx.value = lhs.value - ((uint64_t)rhs<<32);
 	return fx;
@@ -123,6 +129,7 @@ struct fixed32_32 dal_fixed32_32_mul_int(struct fixed32_32 lhs, uint32_t rhs)
 	struct fixed32_32 fx;
 	uint64_t lhsi = (lhs.value>>32) * (uint64_t)rhs;
 	uint64_t lhsf;
+
 	ASSERT((lhsi>>32) == 0);
 	lhsf = ((uint32_t)lhs.value) * (uint64_t)rhs;
 	ASSERT((lhsi<<32) + lhsf >= lhsf);
@@ -137,6 +144,7 @@ struct fixed32_32 dal_fixed32_32_div(
 	struct fixed32_32 rhs)
 {
 	struct fixed32_32 fx;
+
 	fx.value = u64_div(lhs.value, rhs.value);
 	return fx;
 }
@@ -144,6 +152,7 @@ struct fixed32_32 dal_fixed32_32_div(
 struct fixed32_32 dal_fixed32_32_div_int(struct fixed32_32 lhs, uint32_t rhs)
 {
 	struct fixed32_32 fx;
+
 	fx.value = u64_div(lhs.value, (uint64_t)rhs << 32);
 	return fx;
 }
diff --git a/drivers/gpu/drm/amd/dal/basics/flat_set.c b/drivers/gpu/drm/amd/dal/basics/flat_set.c
index 6d50287..cfee8d5 100644
--- a/drivers/gpu/drm/amd/dal/basics/flat_set.c
+++ b/drivers/gpu/drm/amd/dal/basics/flat_set.c
@@ -46,6 +46,7 @@ struct flat_set *dal_flat_set_create(
 		const struct flat_set_init_data *init_data)
 {
 	struct flat_set *flat_set;
+
 	if (init_data == NULL)
 		return NULL;
 
@@ -134,6 +135,7 @@ void *dal_flat_set_insert(
 {
 	uint32_t where;
 	void *found_elm = dal_flat_set_search(flat_set, what, &where);
+
 	if (found_elm)
 		/*already there, not inserting*/
 		return found_elm;
diff --git a/drivers/gpu/drm/amd/dal/basics/grph_object_id.c b/drivers/gpu/drm/amd/dal/basics/grph_object_id.c
index 55ce7dc..ee746b6 100644
--- a/drivers/gpu/drm/amd/dal/basics/grph_object_id.c
+++ b/drivers/gpu/drm/amd/dal/basics/grph_object_id.c
@@ -77,6 +77,7 @@ bool dal_graphics_object_id_is_equal(
 uint32_t dal_graphics_object_id_to_uint(struct graphics_object_id id)
 {
 	uint32_t object_id = 0;
+
 	object_id = id.id + (id.enum_id << 0x8) + (id.type << 0xc);
 	return object_id;
 }
diff --git a/drivers/gpu/drm/amd/dal/basics/logger.c b/drivers/gpu/drm/amd/dal/basics/logger.c
index 09cd935..4bf8bc3 100644
--- a/drivers/gpu/drm/amd/dal/basics/logger.c
+++ b/drivers/gpu/drm/amd/dal/basics/logger.c
@@ -201,8 +201,7 @@ static const struct log_minor_info ds_minor_info_tbl[] = {
 };
 
 
-struct log_major_mask_info
-{
+struct log_major_mask_info {
 	struct log_major_info major_info;
 	uint32_t default_mask;
 	const struct log_minor_info *minor_tbl;
@@ -297,6 +296,7 @@ static bool construct(struct dal_logger *logger)
 	for (i = 0; i < NUM_ELEMENTS(log_major_mask_info_tbl); i++) {
 
 		uint32_t dflt_mask = log_major_mask_info_tbl[i].default_mask;
+
 		logger->log_enable_mask_minors[i] = dflt_mask;
 	}
 
@@ -320,6 +320,7 @@ struct dal_logger *dal_logger_create(void)
 {
 	/* malloc struct */
 	struct dal_logger *logger = dal_alloc(sizeof(struct dal_logger));
+
 	if (!logger)
 		return NULL;
 	if (!construct(logger)) {
@@ -510,6 +511,7 @@ static void log_major_minor(struct log_entry *entry)
 
 		const struct log_major_mask_info *maj_mask_info =
 				&log_major_mask_info_tbl[i];
+
 		if (maj_mask_info->major_info.major == major) {
 
 			dal_logger_append(entry, "[%s_",
@@ -517,13 +519,13 @@ static void log_major_minor(struct log_entry *entry)
 
 			if (maj_mask_info->minor_tbl != NULL) {
 				uint32_t j;
+
 				for (j = 0; j < maj_mask_info->tbl_element_cnt; j++) {
 
 					const struct log_minor_info *min_info = &maj_mask_info->minor_tbl[j];
 
-					if (min_info->minor == minor) {
+					if (min_info->minor == minor)
 						dal_logger_append(entry, "%s]\t", min_info->minor_name);
-					}
 				}
 			}
 
@@ -577,6 +579,7 @@ void dal_logger_write(
 		va_list args;
 		char buffer[DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE];
 		struct log_entry entry;
+
 		va_start(args, msg);
 		dal_logger_open(logger, &entry, major, minor);
 
@@ -626,6 +629,7 @@ void dal_logger_append(
 		uint32_t size;
 		va_list args;
 		char buffer[DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE];
+
 		va_start(args, msg);
 
 		size = dal_log_to_buffer(
@@ -644,7 +648,6 @@ uint32_t dal_logger_read(
 	uint32_t *bytes_read, /* >[out] */
 	bool single_line)
 {
-	char cur;
 	uint32_t bytes_remaining = 0;
 	uint32_t bytes_read_count = 0;
 	bool keep_reading = true;
@@ -662,6 +665,7 @@ uint32_t dal_logger_read(
 	 */
 
 	do {
+		char cur;
 
 		/* Stop when we've read everything */
 		if (logger->buffer_read_offset ==
@@ -719,17 +723,15 @@ void dal_logger_open(
 		enum log_major major,
 		enum log_minor minor)
 {
-
-	entry->major = LOG_MAJOR_COUNT;
-	entry->minor = 0;
-	entry->logger = logger;
-
-
 	if (!entry) {
 		BREAK_TO_DEBUGGER();
 		return;
 	}
 
+	entry->major = LOG_MAJOR_COUNT;
+	entry->minor = 0;
+	entry->logger = logger;
+
 	entry->buf = dal_alloc(
 		DAL_LOGGER_BUFFER_MAX_LOG_LINE_SIZE * sizeof(char));
 
@@ -778,9 +780,10 @@ uint32_t dal_logger_get_mask(
 	enum log_major lvl_major, enum log_minor lvl_minor)
 {
 	uint32_t log_mask = 0;
-	if (logger && lvl_major < LOG_MAJOR_COUNT) {
+
+	if (logger && lvl_major < LOG_MAJOR_COUNT)
 		log_mask = logger->log_enable_mask_minors[lvl_major];
-	}
+
 	log_mask &= 1 << lvl_minor;
 	return log_mask;
 }
@@ -807,9 +810,10 @@ uint32_t dal_logger_get_masks(
 	enum log_major lvl_major)
 {
 	uint32_t log_mask = 0;
-	if (logger && lvl_major < LOG_MAJOR_COUNT) {
+
+	if (logger && lvl_major < LOG_MAJOR_COUNT)
 		log_mask = logger->log_enable_mask_minors[lvl_major];
-	}
+
 	return log_mask;
 }
 
@@ -817,10 +821,8 @@ void dal_logger_set_masks(
 	struct dal_logger *logger,
 	enum log_major lvl_major, uint32_t log_mask)
 {
-
-	if (logger && lvl_major < LOG_MAJOR_COUNT) {
+	if (logger && lvl_major < LOG_MAJOR_COUNT)
 		logger->log_enable_mask_minors[lvl_major] = log_mask;
-	}
 }
 
 uint32_t dal_logger_unset_mask(
@@ -872,41 +874,43 @@ uint32_t dal_logger_set_buffer_size(
 }
 
 
-const struct log_major_info* dal_logger_enum_log_major_info(
+const struct log_major_info *dal_logger_enum_log_major_info(
 		struct dal_logger *logger,
 		unsigned int enum_index)
 {
-	const struct log_major_info* major_info;
-	if(enum_index >= NUM_ELEMENTS(log_major_mask_info_tbl))
-	return NULL;
+	const struct log_major_info *major_info;
+
+	if (enum_index >= NUM_ELEMENTS(log_major_mask_info_tbl))
+		return NULL;
+
 	major_info = &log_major_mask_info_tbl[enum_index].major_info;
 	return major_info;
 }
 
-const struct log_minor_info* dal_logger_enum_log_minor_info(
+const struct log_minor_info *dal_logger_enum_log_minor_info(
 		struct dal_logger *logger,
 		enum log_major major,
 		unsigned int enum_index)
 {
-	const struct log_minor_info* minor_info = NULL;
+	const struct log_minor_info *minor_info = NULL;
 	uint32_t i;
 
 	for (i = 0; i < NUM_ELEMENTS(log_major_mask_info_tbl); i++) {
 
 		const struct log_major_mask_info *maj_mask_info =
 				&log_major_mask_info_tbl[i];
+
 		if (maj_mask_info->major_info.major == major) {
 
 			if (maj_mask_info->minor_tbl != NULL) {
 				uint32_t j;
+
 				for (j = 0; j < maj_mask_info->tbl_element_cnt; j++) {
 
 					minor_info = &maj_mask_info->minor_tbl[j];
 
-					if (minor_info->minor == enum_index) {
-
+					if (minor_info->minor == enum_index)
 						return minor_info;
-					}
 				}
 			}
 
diff --git a/drivers/gpu/drm/amd/dal/basics/register_logger.c b/drivers/gpu/drm/amd/dal/basics/register_logger.c
index a12af5b..d1bbb2d 100644
--- a/drivers/gpu/drm/amd/dal/basics/register_logger.c
+++ b/drivers/gpu/drm/amd/dal/basics/register_logger.c
@@ -68,12 +68,11 @@ static struct dal_reg_dump_stack reg_dump_stack = {0};
 static bool is_reg_dump_process(void)
 {
 	uint32_t i;
-	struct dal_reg_dump_stack_location *stack_location;
 
 	/* walk the list of our processes */
 	for (i = 0; i < reg_dump_stack.stack_pointer; i++) {
-
-		stack_location = &reg_dump_stack.stack_locations[i];
+		struct dal_reg_dump_stack_location *stack_location
+					= &reg_dump_stack.stack_locations[i];
 
 		if (stack_location->current_pid == dal_get_pid()
 			&& stack_location->current_tgid == dal_get_tgid())
diff --git a/drivers/gpu/drm/amd/dal/basics/vector.c b/drivers/gpu/drm/amd/dal/basics/vector.c
index 9bb982f..d28f90e 100644
--- a/drivers/gpu/drm/amd/dal/basics/vector.c
+++ b/drivers/gpu/drm/amd/dal/basics/vector.c
@@ -55,6 +55,7 @@ bool dal_vector_presized_costruct(
 	uint32_t struct_size)
 {
 	uint32_t i;
+
 	vector->container = NULL;
 
 	if (!struct_size || !count) {
@@ -179,6 +180,7 @@ void dal_vector_set_at_index(
 	uint32_t index)
 {
 	void *where = dal_vector_at_index(vector, index);
+
 	if (!where) {
 		BREAK_TO_DEBUGGER();
 		return;
diff --git a/drivers/gpu/drm/amd/dal/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/bios/bios_parser.c
index e54224e..41dbca0 100644
--- a/drivers/gpu/drm/amd/dal/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/bios/bios_parser.c
@@ -159,6 +159,7 @@ static bool bios_parser_construct(
 	if (bp->object_info_tbl.revision.major == 1
 		&& bp->object_info_tbl.revision.minor >= 3) {
 		ATOM_OBJECT_HEADER_V3 *tbl_v3;
+
 		tbl_v3 = GET_IMAGE(ATOM_OBJECT_HEADER_V3,
 			bp->object_info_tbl_offset);
 		if (!tbl_v3)
@@ -186,6 +187,7 @@ struct bios_parser *dal_bios_parser_create(
 	struct bp_init_data *init, struct adapter_service *as)
 {
 	struct bios_parser *bp = NULL;
+
 	bp = dal_alloc(sizeof(struct bios_parser));
 	if (!bp)
 		return NULL;
@@ -238,7 +240,7 @@ static uint8_t get_number_of_objects(struct bios_parser *bp, uint32_t offset)
 
 	uint32_t object_table_offset = bp->object_info_tbl_offset + offset;
 
-	table = GET_IMAGE(ATOM_OBJECT_TABLE , object_table_offset);
+	table = GET_IMAGE(ATOM_OBJECT_TABLE, object_table_offset);
 
 	if (!table)
 		return 0;
@@ -265,7 +267,7 @@ uint32_t dal_bios_parser_get_oem_ddc_lines_number(struct bios_parser *bp)
 	if (DATA_TABLES(OemInfo) != 0) {
 		ATOM_OEM_INFO *info;
 
-		info = GET_IMAGE(ATOM_OEM_INFO ,
+		info = GET_IMAGE(ATOM_OEM_INFO,
 			DATA_TABLES(OemInfo));
 
 		if (info->sHeader.usStructureSize
@@ -295,6 +297,7 @@ struct graphics_object_id dal_bios_parser_get_encoder_id(struct bios_parser *bp,
 
 	if (tbl && tbl->ucNumberOfObjects > i) {
 		const uint16_t id = tbl->asObjects[i].usObjectID;
+
 		object_id = object_id_from_bios_object_id(id);
 	}
 
@@ -316,6 +319,7 @@ struct graphics_object_id dal_bios_parser_get_connector_id(
 
 	if (tbl && tbl->ucNumberOfObjects > i) {
 		const uint16_t id = tbl->asObjects[i].usObjectID;
+
 		object_id = object_id_from_bios_object_id(id);
 	}
 
@@ -421,6 +425,7 @@ enum bp_result dal_bios_parser_get_oem_ddc_info(struct bios_parser *bp,
 			> sizeof(ATOM_COMMON_TABLE_HEADER)) {
 			ATOM_I2C_RECORD record;
 			ATOM_I2C_ID_CONFIG_ACCESS *config;
+
 			dal_memset(&record, 0, sizeof(record));
 
 			config = &tbl->sucI2cId + index - 1;
@@ -1385,6 +1390,7 @@ bool dal_bios_parser_is_device_id_supported(
 	struct device_id id)
 {
 	uint32_t mask = get_support_mask_for_device_id(id);
+
 	return (bp->object_info_tbl.v1_1->usDeviceSupport & mask) != 0;
 }
 
@@ -1735,6 +1741,7 @@ static enum bp_result get_ss_info_from_ss_info_table(
 	case ASIC_INTERNAL_SS_ON_LVDS:
 	{
 		struct embedded_panel_info panel_info;
+
 		if (dal_bios_parser_get_embedded_panel_info(bp, &panel_info)
 			== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
@@ -2025,6 +2032,7 @@ static enum bp_result get_embedded_panel_info_v1_3(
 		uint8_t min_rr =
 			lvds->sRefreshRateSupport.ucMinRefreshRateForDRR;
 		uint8_t rr = lvds->sRefreshRateSupport.ucSupportedRefreshRate;
+
 		if (min_rr != 0) {
 			if (SUPPORTED_LCD_REFRESHRATE_30Hz & min_rr)
 				info->supported_rr.REFRESH_RATE_30HZ = 1;
@@ -2331,6 +2339,7 @@ static uint32_t get_ss_entry_number_from_ss_info_tbl(
 		break;
 	case ASIC_INTERNAL_SS_ON_LVDS: {
 		struct embedded_panel_info panel_info;
+
 		if (dal_bios_parser_get_embedded_panel_info(bp, &panel_info)
 			== BP_RESULT_OK)
 			id_local = panel_info.ss_id;
@@ -2912,6 +2921,7 @@ static uint32_t get_record_size(uint8_t *record)
 static uint32_t get_edid_size(const ATOM_FAKE_EDID_PATCH_RECORD *edid)
 {
 	uint32_t length = edid->ucFakeEDIDLength;
+
 	if (length < 128)
 		length = length * 128;
 
@@ -3369,6 +3379,7 @@ static uint32_t get_support_mask_for_device_id(struct device_id device_id)
 {
 	enum dal_device_type device_type = device_id.device_type;
 	uint32_t enum_id = device_id.enum_id;
+
 	switch (device_type) {
 	case DEVICE_TYPE_LCD:
 		switch (enum_id) {
@@ -3580,13 +3591,12 @@ static uint32_t enum_first_device_id(uint32_t dev_id)
 		return ATOM_DEVICE_TV1_SUPPORT;
 	else if (dev_id & ATOM_DEVICE_CV_SUPPORT)
 		return ATOM_DEVICE_CV_SUPPORT;
-	else {
-		/* No group found for this device ID. */
 
-		dal_error("%s: incorrect input %d\n", __func__, dev_id);
-		/* No matching support flag for given device ID */
-		return 0;
-	}
+	/* No group found for this device ID. */
+
+	dal_error("%s: incorrect input %d\n", __func__, dev_id);
+	/* No matching support flag for given device ID */
+	return 0;
 }
 
 /*
@@ -3682,9 +3692,11 @@ static void add_device_tag_from_ext_display_path(
 	enum bp_result result =
 		dal_bios_parser_get_device_tag_record(
 			bp, object, &device_tag_record);
+
 	if ((ext_display_path->usDeviceTag != CONNECTOR_OBJECT_ID_NONE)
 		&& (result == BP_RESULT_OK)) {
 		uint8_t index;
+
 		if ((device_tag_record->ucNumberOfDevice == 1) &&
 			(device_tag_record->asDeviceTag[0].usDeviceID == 0)) {
 			/*Workaround bug in current VBIOS releases where
@@ -3942,6 +3954,7 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 	 * from the external display connection info table. */
 	for (i = 0; i < connector_tbl->ucNumberOfObjects; i++) {
 		uint32_t j;
+
 		object = &connector_tbl->asObjects[i];
 		object_id = object_id_from_bios_object_id(object->usObjectID);
 		if ((OBJECT_TYPE_CONNECTOR != object_id.type) ||
@@ -4005,6 +4018,7 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 			ATOM_OBJECT *next_object;
 			struct graphics_object_id next_object_id;
 			EXT_DISPLAY_PATH *next_ext_display_path;
+
 			next_object = &connector_tbl->asObjects[j];
 			next_object_id = object_id_from_bios_object_id(
 				next_object->usObjectID);
@@ -4045,6 +4059,7 @@ static enum bp_result patch_bios_image_from_ext_display_connection_info(
 
 	for (i = 0; i < encoder_table->ucNumberOfObjects; i++) {
 		uint32_t j;
+
 		object = &encoder_table->asObjects[i];
 
 		dst_number = get_dest_obj_list(bp, object, &dst_object_id_list);
@@ -4683,6 +4698,7 @@ struct integrated_info *dal_bios_parser_create_integrated_info(
 	struct bios_parser *bp)
 {
 	struct integrated_info *info = NULL;
+
 	info = dal_alloc(sizeof(struct integrated_info));
 
 	if (info == NULL) {
diff --git a/drivers/gpu/drm/amd/dal/bios/command_table.c b/drivers/gpu/drm/amd/dal/bios/command_table.c
index 29a44bd..21ad3d1 100644
--- a/drivers/gpu/drm/amd/dal/bios/command_table.c
+++ b/drivers/gpu/drm/amd/dal/bios/command_table.c
@@ -150,6 +150,7 @@ static enum bp_result encoder_control_dig2_v1(
 static void init_encoder_control_dig_v1(struct bios_parser *bp)
 {
 	struct cmd_tbl *cmd_tbl = &bp->cmd_tbl;
+
 	if (1 == BIOS_CMD_TABLE_PARA_REVISION(DIG1EncoderControl))
 		cmd_tbl->encoder_control_dig1 = encoder_control_dig1_v1;
 	else
@@ -489,7 +490,7 @@ static enum bp_result transmitter_control_v2(
 	 * 01 - incoherent mode
 	 */
 
-	params.acConfig.fCoherentMode = cntl->coherent ;
+	params.acConfig.fCoherentMode = cntl->coherent;
 
 	if ((TRANSMITTER_UNIPHY_B == cntl->transmitter)
 			|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)
@@ -789,7 +790,7 @@ static enum bp_result transmitter_control_v4(
 	 * 01 - incoherent mode
 	 */
 
-	params.acConfig.fCoherentMode = cntl->coherent ;
+	params.acConfig.fCoherentMode = cntl->coherent;
 
 	if ((TRANSMITTER_UNIPHY_B == cntl->transmitter)
 		|| (TRANSMITTER_UNIPHY_D == cntl->transmitter)
@@ -1390,6 +1391,7 @@ static enum bp_result adjust_display_pll_v2(
 	/* We need to convert from KHz units into 10KHz units and then convert
 	 * output pixel clock back 10KHz-->KHz */
 	uint32_t pixel_clock_10KHz_in = bp_params->pixel_clock / 10;
+
 	params.usPixelClock = (uint16_t)(pixel_clock_10KHz_in);
 	params.ucTransmitterID =
 		bp->cmd_helper->encoder_id_to_atom(
@@ -1407,6 +1409,7 @@ static enum bp_result adjust_display_pll_v2(
 		 * [output pxlClk/input pxlClk] */
 		uint64_t pixel_clock_10KHz_out = (uint64_t)params.usPixelClock;
 		uint64_t pixel_clock = (uint64_t)bp_params->pixel_clock;
+
 		bp_params->adjusted_pixel_clock =
 			div_u64(pixel_clock * pixel_clock_10KHz_out,
 				pixel_clock_10KHz_in);
@@ -1469,6 +1472,7 @@ static enum bp_result adjust_display_pll_v3(
 		uint64_t pixel_clk_10_khz_out =
 			(uint64_t)params.sOutput.ulDispPllFreq;
 		uint64_t pixel_clk = (uint64_t)bp_params->pixel_clock;
+
 		if (pixel_clk_10_kHz_in != 0) {
 			bp_params->adjusted_pixel_clock =
 				div_u64(pixel_clk * pixel_clk_10_khz_out,
@@ -1758,6 +1762,7 @@ static enum signal_type dac_load_detection_v3(
 		 * VBIOS call
 		 */
 		struct connector_device_tag_info info;
+
 		info.dev_id.device_type = DEVICE_TYPE_CV;
 		info.dev_id.enum_id = 1;
 		info.acpi_device = 0;
@@ -2349,6 +2354,7 @@ static enum bp_result program_clock_v5(
 
 	SET_PIXEL_CLOCK_PS_ALLOCATION_V5 params;
 	uint32_t atom_pll_id;
+
 	dal_memset(&params, 0, sizeof(params));
 	if (!bp->cmd_helper->clock_source_id_to_atom(
 		bp_params->pll_id, &atom_pll_id)) {
@@ -2379,6 +2385,7 @@ static enum bp_result program_clock_v6(
 
 	SET_PIXEL_CLOCK_PS_ALLOCATION_V6 params;
 	uint32_t atom_pll_id;
+
 	dal_memset(&params, 0, sizeof(params));
 
 	if (!bp->cmd_helper->clock_source_id_to_atom(
diff --git a/drivers/gpu/drm/amd/dal/bios/command_table_helper.c b/drivers/gpu/drm/amd/dal/bios/command_table_helper.c
index e643ab9..b0a5d7c 100644
--- a/drivers/gpu/drm/amd/dal/bios/command_table_helper.c
+++ b/drivers/gpu/drm/amd/dal/bios/command_table_helper.c
@@ -296,7 +296,7 @@ uint8_t dal_cmd_table_helper_encoder_id_to_atom(
 	case ENCODER_ID_EXTERNAL_VT1625:
 		return ENCODER_OBJECT_ID_VT1625;
 	case ENCODER_ID_EXTERNAL_SI1932:
-		return ENCODER_OBJECT_ID_HDMI_SI1932 ;
+		return ENCODER_OBJECT_ID_HDMI_SI1932;
 	case ENCODER_ID_EXTERNAL_AN9801:
 		return ENCODER_OBJECT_ID_DP_AN9801;
 	case ENCODER_ID_EXTERNAL_DP501:
diff --git a/drivers/gpu/drm/amd/dal/bios/dce110/command_table_helper_dce110.c b/drivers/gpu/drm/amd/dal/bios/dce110/command_table_helper_dce110.c
index cd92a6c..fa7c02a 100644
--- a/drivers/gpu/drm/amd/dal/bios/dce110/command_table_helper_dce110.c
+++ b/drivers/gpu/drm/amd/dal/bios/dce110/command_table_helper_dce110.c
@@ -104,6 +104,7 @@ static uint8_t clock_source_id_to_atom_phy_clk_src_id(
 		enum clock_source_id id)
 {
 	uint8_t atom_phy_clk_src_id = 0;
+
 	switch (id) {
 	case CLOCK_SOURCE_ID_PLL0:
 		atom_phy_clk_src_id = ATOM_TRANSMITTER_CONFIG_V5_P0PLL;
@@ -195,6 +196,7 @@ static bool clock_source_id_to_atom(
 	uint32_t *atom_pll_id)
 {
 	bool result = true;
+
 	if (atom_pll_id != NULL)
 		switch (id) {
 		case CLOCK_SOURCE_ID_PLL0:
@@ -287,6 +289,7 @@ static bool engine_bp_to_atom(enum engine_id id, uint32_t *atom_engine_id)
 static uint8_t encoder_action_to_atom(enum bp_encoder_control_action action)
 {
 	uint8_t atom_action = 0;
+
 	switch (action) {
 	case ENCODER_CONTROL_ENABLE:
 		atom_action = ATOM_ENABLE;
diff --git a/drivers/gpu/drm/amd/dal/controller/controller.c b/drivers/gpu/drm/amd/dal/controller/controller.c
index 41b9cc2..644b144 100644
--- a/drivers/gpu/drm/amd/dal/controller/controller.c
+++ b/drivers/gpu/drm/amd/dal/controller/controller.c
@@ -497,13 +497,11 @@ void dal_controller_set_lock_graph_surface_registers(
 	bool lock)
 {
 	crtc->tg->funcs->set_lock_graph_surface_registers(crtc->tg, lock);
-	return;
 }
 
 void dal_controller_set_lock_master(struct controller *crtc, bool lock)
 {
 	crtc->tg->funcs->set_lock_master(crtc->tg, lock);
-	return;
 }
 
 /* (Set/Get) Global Swap Lock */
diff --git a/drivers/gpu/drm/amd/dal/controller/csc_video.c b/drivers/gpu/drm/amd/dal/controller/csc_video.c
index 14d63b3..edae42c1 100644
--- a/drivers/gpu/drm/amd/dal/controller/csc_video.c
+++ b/drivers/gpu/drm/amd/dal/controller/csc_video.c
@@ -132,6 +132,7 @@ void dal_csc_video_apply_oem_matrix(
 
 	for (i = 0; i < 4; ++i) {
 		uint32_t j;
+
 		for (j = 0; j < 4; ++j) {
 			struct fixed31_32 value = dal_fixed31_32_zero;
 			uint32_t k;
@@ -150,6 +151,7 @@ void dal_csc_video_apply_oem_matrix(
 
 	for (i = 0; i < 3; ++i) {
 		uint32_t j;
+
 		for (j = 0; j < 4; ++j)
 			matrix[index++] = result[(i << 2) + j];
 	}
diff --git a/drivers/gpu/drm/amd/dal/controller/cursor.c b/drivers/gpu/drm/amd/dal/controller/cursor.c
index a14eeec..b0801eb 100644
--- a/drivers/gpu/drm/amd/dal/controller/cursor.c
+++ b/drivers/gpu/drm/amd/dal/controller/cursor.c
@@ -56,7 +56,10 @@ bool dal_cursor_set_position(
 	cur->funcs->program_position(cur, position->x, position->y);
 
 	if (position->hot_spot_enable)
-		cur->funcs->program_hotspot(cur, position->x_origin, position->y_origin);
+		cur->funcs->program_hotspot(
+				cur,
+				position->x_origin,
+				position->y_origin);
 
 	/* unlock cursor registers */
 	cur->funcs->lock(cur, false);
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/col_man_csc_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/col_man_csc_dce110.c
index 9914cd4..03ffdb1 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/col_man_csc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/col_man_csc_dce110.c
@@ -120,8 +120,6 @@ static void set_denormalization(
 		DENORM_10BIT_OUT);
 
 	dal_write_reg(csc->ctx, addr, value);
-
-	return;
 }
 
 bool configure_graphics_mode(
@@ -151,32 +149,32 @@ bool configure_graphics_mode(
 			 * method) so we handle it in one place.
 			 */
 			return true;
-		} else {
-			switch (color_space) {
-			case COLOR_SPACE_SRGB_FULL_RANGE:
-				/* bypass */
-				break;
-			case COLOR_SPACE_YCBCR601:
-			case COLOR_SPACE_YPBPR601:
-			case COLOR_SPACE_YCBCR601_YONLY:
-				set_reg_field_value(
-					value,
-					2,
-					COL_MAN_OUTPUT_CSC_CONTROL,
-					OUTPUT_CSC_MODE);
-				break;
-			case COLOR_SPACE_YCBCR709:
-			case COLOR_SPACE_YPBPR709:
-			case COLOR_SPACE_YCBCR709_YONLY:
-				set_reg_field_value(
-					value,
-					3,
-					COL_MAN_OUTPUT_CSC_CONTROL,
-					OUTPUT_CSC_MODE);
-				break;
-			default:
-				return false;
-			}
+		}
+
+		switch (color_space) {
+		case COLOR_SPACE_SRGB_FULL_RANGE:
+			/* bypass */
+			break;
+		case COLOR_SPACE_YCBCR601:
+		case COLOR_SPACE_YPBPR601:
+		case COLOR_SPACE_YCBCR601_YONLY:
+			set_reg_field_value(
+				value,
+				2,
+				COL_MAN_OUTPUT_CSC_CONTROL,
+				OUTPUT_CSC_MODE);
+			break;
+		case COLOR_SPACE_YCBCR709:
+		case COLOR_SPACE_YPBPR709:
+		case COLOR_SPACE_YCBCR709_YONLY:
+			set_reg_field_value(
+				value,
+				3,
+				COL_MAN_OUTPUT_CSC_CONTROL,
+				OUTPUT_CSC_MODE);
+			break;
+		default:
+			return false;
 		}
 	} else if (csc_adjust_type == GRAPHICS_CSC_ADJUST_TYPE_HW) {
 		switch (color_space) {
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/controller_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/controller_dce110.c
index 00156e7..7b990cc 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/controller_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/controller_dce110.c
@@ -42,14 +42,6 @@
 
 
 /*****************************************************************************
- * macro definitions
- *****************************************************************************/
-
-#define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_CONTROLLER, \
-			"CTRLR:%s()\n", __func__);
-
-
-/*****************************************************************************
  * functions
  *****************************************************************************/
 static bool is_surface_supported(
@@ -116,6 +108,7 @@ bool dal_controller_dce110_construct(
 
 	{
 		struct grph_gamma_init_data gg_init_data = {0};
+
 		gg_init_data.as = init_data->as;
 		gg_init_data.ctx = base->dal_context;
 		gg_init_data.id = base->id;
@@ -127,6 +120,7 @@ bool dal_controller_dce110_construct(
 
 	{
 		struct csc_init_data csc_init_data = {0};
+
 		csc_init_data.id = base->id;
 		csc_init_data.ctx = base->dal_context;
 		csc_init_data.as = init_data->as;
@@ -161,6 +155,7 @@ bool dal_controller_dce110_construct(
 
 	{
 		struct formatter_init_data fmt_init_data = {0};
+
 		fmt_init_data.ctx = base->dal_context;
 		fmt_init_data.id = base->id;
 		base->fmt = dal_formatter_dce110_create(&fmt_init_data);
@@ -171,6 +166,7 @@ bool dal_controller_dce110_construct(
 
 	{
 		struct scaler_init_data scl_init_data = {0};
+
 		scl_init_data.bp =
 			dal_adapter_service_get_bios_parser(init_data->as);
 		scl_init_data.dal_ctx = base->dal_context;
@@ -184,6 +180,7 @@ bool dal_controller_dce110_construct(
 	{
 
 		struct line_buffer_init_data lb_init_data = {0};
+
 		lb_init_data.dal_context = base->dal_context;
 		lb_init_data.as = init_data->as;
 		lb_init_data.id = init_data->controller;
@@ -195,6 +192,7 @@ bool dal_controller_dce110_construct(
 
 	{
 		struct surface_init_data surf_init_data = {0};
+
 		surf_init_data.dal_ctx = base->dal_context;
 		surf_init_data.id = base->id;
 		base->surface = dal_surface_dce110_create(&surf_init_data);
@@ -206,6 +204,7 @@ bool dal_controller_dce110_construct(
 
 	{
 		struct cursor_init_data cur_init_data = {0};
+
 		cur_init_data.dal_ctx = base->dal_context;
 		cur_init_data.id = base->id;
 		base->cursor = dal_cursor_dce110_create(&cur_init_data);
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/controller_v_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/controller_v_dce110.c
index 03e48c2..047861c 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/controller_v_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/controller_v_dce110.c
@@ -88,126 +88,104 @@ static bool construct(
 	struct controller *crtc,
 	struct controller_init_data *init_data)
 {
-	bool err = false;
 	struct scaler_init_data scl_init_data = {0};
 	struct surface_init_data surf_init_data = {0};
 
 	if (!dal_controller_base_construct(crtc, init_data))
 		return false;
 
-	do {
-		scl_init_data.bp = dal_adapter_service_get_bios_parser(
-				init_data->as);
-		scl_init_data.dal_ctx = init_data->dal_context;
-		scl_init_data.id = CONTROLLER_ID_UNDERLAY0;
+	scl_init_data.bp = dal_adapter_service_get_bios_parser(
+			init_data->as);
+	scl_init_data.dal_ctx = init_data->dal_context;
+	scl_init_data.id = CONTROLLER_ID_UNDERLAY0;
 
-		crtc->scl = dal_scaler_v_dce110_create(&scl_init_data);
+	crtc->scl = dal_scaler_v_dce110_create(&scl_init_data);
 
-		if (!crtc->scl) {
-			err = true;
-			break;
-		}
-
-
-		surf_init_data.dal_ctx = init_data->dal_context;
-		surf_init_data.id = CONTROLLER_ID_UNDERLAY0;
-		crtc->surface = dal_surface_v_dce110_create(&surf_init_data);
-
-		if (!crtc->surface) {
-			err = true;
-			break;
-		}
+	if (!crtc->scl)
+		goto scl_fail;
 
-		crtc->pc = dal_pipe_control_v_dce110_create(
-			init_data->as,
-			init_data->dal_context,
-			init_data->controller);
 
-		if (!crtc->pc) {
-			err = true;
-			break;
-		}
-
-		crtc->tg = dal_timing_generator_v_dce110_create(
-			init_data->as,
-			init_data->dal_context,
-			init_data->controller);
+	surf_init_data.dal_ctx = init_data->dal_context;
+	surf_init_data.id = CONTROLLER_ID_UNDERLAY0;
+	crtc->surface = dal_surface_v_dce110_create(&surf_init_data);
 
-		if (!crtc->tg) {
-			err = true;
-			break;
-		}
-
-		{
-			struct line_buffer_init_data lb_init_data = {0};
-			lb_init_data.dal_context = crtc->dal_context;
-			lb_init_data.as = init_data->as;
-			lb_init_data.id = init_data->controller;
-			crtc->lb =
-				dal_line_buffer_v_dce110_create(&lb_init_data);
-		}
+	if (!crtc->surface)
+		goto surface_fail;
 
-		if (!crtc->lb) {
-			err = true;
-			break;
-		}
+	crtc->pc = dal_pipe_control_v_dce110_create(
+		init_data->as,
+		init_data->dal_context,
+		init_data->controller);
 
-		{
-			struct csc_init_data csc_init_data = {0};
-			csc_init_data.id = init_data->controller;
-			csc_init_data.ctx = crtc->dal_context;
-			csc_init_data.as = init_data->as;
-			crtc->csc =
-				dal_col_man_csc_dce110_create(&csc_init_data);
-		}
+	if (!crtc->pc)
+		goto pc_fail;
 
-		if (!crtc->csc) {
-			err = true;
-			break;
-		}
+	crtc->tg = dal_timing_generator_v_dce110_create(
+		init_data->as,
+		init_data->dal_context,
+		init_data->controller);
 
-		{
-			struct grph_gamma_init_data gg_init_data = {0};
-			gg_init_data.as = init_data->as;
-			gg_init_data.ctx = crtc->dal_context;
-			gg_init_data.id = init_data->controller;
-			crtc->grph_gamma =
-				dal_col_man_grph_dce110_create(&gg_init_data);
-		}
+	if (!crtc->tg)
+		goto tg_fail;
 
-		if (!crtc->grph_gamma) {
-			err = true;
-			break;
-		}
-	} while (0);
+	{
+		struct line_buffer_init_data lb_init_data = {0};
 
-	if (err == false) {
-		/* all OK */
-		crtc->funcs.destroy = destroy;
-		crtc->funcs.is_surface_supported = is_surface_supported;
-		return true;
-	} else {
-		/* cleanup after an error */
-		if (crtc->pc)
-			crtc->pc->funcs->destroy(&crtc->pc);
+		lb_init_data.dal_context = crtc->dal_context;
+		lb_init_data.as = init_data->as;
+		lb_init_data.id = init_data->controller;
+		crtc->lb =
+			dal_line_buffer_v_dce110_create(&lb_init_data);
+	}
 
-		if (crtc->surface)
-			crtc->surface->funcs->destroy(&crtc->surface);
+	if (!crtc->lb)
+		goto lb_fail;
 
-		if (crtc->scl)
-			crtc->scl->funcs->destroy(&crtc->scl);
+	{
+		struct csc_init_data csc_init_data = {0};
 
-		if (crtc->tg)
-			crtc->tg->funcs->destroy(&crtc->tg);
+		csc_init_data.id = init_data->controller;
+		csc_init_data.ctx = crtc->dal_context;
+		csc_init_data.as = init_data->as;
+		crtc->csc =
+			dal_col_man_csc_dce110_create(&csc_init_data);
+	}
 
-		if (crtc->csc)
-			crtc->csc->funcs->destroy(&crtc->csc);
+	if (!crtc->csc)
+		goto csc_fail;
 
-		if (crtc->grph_gamma)
-			crtc->grph_gamma->funcs->destroy(&crtc->grph_gamma);
+	{
+		struct grph_gamma_init_data gg_init_data = {0};
 
-		return false;
+		gg_init_data.as = init_data->as;
+		gg_init_data.ctx = crtc->dal_context;
+		gg_init_data.id = init_data->controller;
+		crtc->grph_gamma =
+			dal_col_man_grph_dce110_create(&gg_init_data);
 	}
+
+	if (!crtc->grph_gamma)
+		goto gamma_fail;
+
+	/* all OK */
+	crtc->funcs.destroy = destroy;
+	crtc->funcs.is_surface_supported = is_surface_supported;
+	return true;
+
+gamma_fail:
+	crtc->csc->funcs->destroy(&crtc->csc);
+csc_fail:
+	crtc->lb->funcs->destroy(&crtc->lb);
+lb_fail:
+	crtc->tg->funcs->destroy(&crtc->tg);
+tg_fail:
+	crtc->pc->funcs->destroy(&crtc->pc);
+pc_fail:
+	crtc->surface->funcs->destroy(&crtc->surface);
+surface_fail:
+	crtc->scl->funcs->destroy(&crtc->scl);
+scl_fail:
+	return false;
 }
 
 struct controller *dal_controller_v_dce110_create(
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/csc_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/csc_dce110.c
index 0585acc..b9fb53b 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/csc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/csc_dce110.c
@@ -232,7 +232,6 @@ static void set_denormalization(
 	dal_write_reg(csc->ctx,
 		FROM_CSC(csc)->dcp_denorm_control_offset, value);
 
-	return;
 }
 
 /*******************************************************************************
@@ -303,6 +302,7 @@ static bool csc_dce110_construct(
 
 	{
 		struct csc_grph_init_data cg_init_data;
+
 		cg_init_data.ctx = csc->base.ctx;
 		cg_init_data.id = init_data->id;
 		csc->base.csc_grph =
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/cursor_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/cursor_dce110.c
index ccc6e56..b2f91a6 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/cursor_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/cursor_dce110.c
@@ -76,6 +76,7 @@ static void enable(
 	struct cursor *cur, bool enable)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(cur->ctx, cur->regs[IDX_CUR_CONTROL]);
 	set_reg_field_value(value, enable, CUR_CONTROL, CURSOR_EN);
 	dal_write_reg(cur->ctx, cur->regs[IDX_CUR_CONTROL], value);
@@ -86,6 +87,7 @@ static void lock(
 	struct cursor *cur, bool lock)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(cur->ctx, cur->regs[IDX_CUR_UPDATE]);
 	set_reg_field_value(value, lock, CUR_UPDATE, CURSOR_UPDATE_LOCK);
 	dal_write_reg(cur->ctx, cur->regs[IDX_CUR_UPDATE], value);
@@ -97,6 +99,7 @@ static void program_position(
 	uint32_t y)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(cur->ctx, cur->regs[IDX_CUR_POSITION]);
 	set_reg_field_value(value, x, CUR_POSITION, CURSOR_X_POSITION);
 	set_reg_field_value(value, y, CUR_POSITION, CURSOR_Y_POSITION);
@@ -151,6 +154,7 @@ static void program_hotspot(
 	uint32_t y)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(cur->ctx, cur->regs[IDX_CUR_HOT_SPOT]);
 	set_reg_field_value(value, x, CUR_HOT_SPOT, CURSOR_HOT_SPOT_X);
 	set_reg_field_value(value, y, CUR_HOT_SPOT, CURSOR_HOT_SPOT_Y);
@@ -163,6 +167,7 @@ static void program_size(
 	uint32_t height)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(cur->ctx, cur->regs[IDX_CUR_SIZE]);
 	set_reg_field_value(value, width, CUR_SIZE, CURSOR_WIDTH);
 	set_reg_field_value(value, height, CUR_SIZE, CURSOR_HEIGHT);
@@ -218,6 +223,7 @@ struct cursor *dal_cursor_dce110_create(
 	struct cursor_init_data *init_data)
 {
 	struct cursor *cur = dal_alloc(sizeof(struct cursor));
+
 	if (!cur)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/dcp_bit_depth_reduction_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/dcp_bit_depth_reduction_dce110.c
index 6545eca..51a917e8 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/dcp_bit_depth_reduction_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/dcp_bit_depth_reduction_dce110.c
@@ -153,6 +153,7 @@ bool dal_dcp_bit_depth_reduction_dce110_program(
 	bool frame_random_enable;
 	bool rgb_random_enable;
 	bool highpass_random_enable;
+
 	if (depth > CSC_COLOR_DEPTH_121212) {
 		ASSERT_CRITICAL(false); /* Invalid clamp bit depth */
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/fbc_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/fbc_dce110.c
index f4d04be..d94dfac 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/fbc_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/fbc_dce110.c
@@ -376,6 +376,7 @@ void dal_fbc_dce110_program_compressed_surface_address_and_pitch(
 
 	if (fbc->options.bits.LPT_SUPPORT) {
 		uint32_t lpt_alignment = lpt_size_alignment(fbc);
+
 		if (lpt_alignment != 0) {
 			compressed_surf_address_low_part =
 				((compressed_surf_address_low_part
@@ -552,6 +553,7 @@ bool dal_fbc_dce110_is_lpt_enabled_in_hw(struct fbc *fbc)
 {
 	/* Check the hardware register */
 	uint32_t value = dal_read_reg(fbc->context, mmLOW_POWER_TILING_CONTROL);
+
 	return get_reg_field_value(
 		value,
 		LOW_POWER_TILING_CONTROL,
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/formatter_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/formatter_dce110.c
index 9d64bec..5b65c8c 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/formatter_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/formatter_dce110.c
@@ -81,6 +81,7 @@ struct formatter *dal_formatter_dce110_create(
 	struct formatter_init_data *init_data)
 {
 	struct formatter *fmt = dal_alloc(sizeof(struct formatter));
+
 	if (!fmt)
 		return NULL;
 
@@ -106,6 +107,7 @@ static void set_dyn_expansion(
 {
 	uint32_t value;
 	bool enable_dyn_exp = false;
+
 	value = dal_read_reg(fmt->ctx,
 			fmt->regs[IDX_FMT_DYNAMIC_EXP_CNTL]);
 
@@ -701,6 +703,7 @@ static void setup_stereo_polarity(
 	bool right_eye_polarity)
 {
 	uint32_t fmt_cntl_value;
+
 	fmt_cntl_value = dal_read_reg(fmt->ctx,
 			fmt->regs[IDX_FMT_CONTROL]);
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c
index 8eb16fd..0192b0c 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/grph_gamma_dce110.c
@@ -1125,6 +1125,7 @@ static void select_lut(
 	struct grph_gamma *gg)
 {
 	uint32_t value = 0;
+
 	set_lut_inc(gg, 0, false, false);
 
 	{
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c
index b090aee..bf32b8a 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c
@@ -102,6 +102,7 @@ static void reset_lb_on_vblank(
 	/* Wait for one frame if CRTC is moving */
 	if (value != dal_read_reg(lb->dal_context, addr)) {
 		uint32_t retry_count = 0;
+
 		addr = lb_dce110->lbx_lb_sync_reset_sel;
 		value = dal_read_reg(lb->dal_context, addr);
 		set_reg_field_value(
@@ -161,6 +162,7 @@ bool dal_line_buffer_dce110_get_pixel_storage_depth(
 		/*we have to go the higher lb if it is possible*/
 		uint32_t i;
 		uint32_t max_depth = LB_PIXEL_DEPTH_36BPP;
+
 		for (i = display_depth; i <= max_depth; i <<= 1) {
 			if (i & lb->caps) {
 				*depth = i;
@@ -175,6 +177,7 @@ bool dal_line_buffer_dce110_get_pixel_storage_depth(
 static uint32_t calculate_pitch(uint32_t depth, uint32_t width)
 {
 	uint32_t pitch = 0;
+
 	switch (depth) {
 	case LB_PIXEL_DEPTH_18BPP:
 		pitch = (width + 7) >> 3;
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c
index 494b59f..893b763 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c
@@ -290,6 +290,7 @@ static bool construct(
 	struct line_buffer_init_data *init_data)
 {
 	bool ret = true;
+
 	if (!dal_line_buffer_dce110_construct(lb, init_data))
 		return false;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/scaler_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/scaler_dce110.c
index 946bd2c..c8e3e42 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/scaler_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/scaler_dce110.c
@@ -100,8 +100,8 @@ enum scl_regs_idx {
 	[IDX_SCL_OVERSCAN_LEFT_RIGHT] =\
 	mmSCL ## id ## _EXT_OVERSCAN_LEFT_RIGHT,\
 	[IDX_SCL_OVERSCAN_TOP_BOTTOM] =\
-	mmSCL ## id ## _EXT_OVERSCAN_TOP_BOTTOM ,\
-	[IDX_SCL_VIEWPORT_START] = mmSCL ## id ## _VIEWPORT_START ,\
+	mmSCL ## id ## _EXT_OVERSCAN_TOP_BOTTOM,\
+	[IDX_SCL_VIEWPORT_START] = mmSCL ## id ## _VIEWPORT_START,\
 	[IDX_SCL_VIEWPORT_SIZE] = mmSCL ## id ## _VIEWPORT_SIZE,\
 	[IDX_SCL_MODE] = mmSCL ## id ## _SCL_MODE,\
 	[IDX_SCL_ROUND_OFFSET] = mmSCL ## id ## _SCL_ROUND_OFFSET,\
@@ -116,15 +116,10 @@ static const uint32_t scl_regs[][SCL_REGS_IDX_SIZE] = {
 	regs_for_scaler(2),
 };
 
-/*****************************************************************************
- * macro definitions
- *****************************************************************************/
-#define NOT_IMPLEMENTED()  DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_CONTROLLER,\
-			"SCALER:%s()\n", __func__);
-
 static void disable_enhanced_sharpness(struct scaler *scl)
 {
 	uint32_t  value;
+
 	value = dal_read_reg(scl->ctx,
 			scl->regs[IDX_SCL_F_SHARP_CONTROL]);
 
@@ -628,6 +623,7 @@ static void calculate_inits(
 	struct fixed31_32 h_init;
 	struct fixed31_32 v_init;
 	struct fixed31_32 v_init_bot;
+
 	inits->bottom_enable = 0;
 	inits->h_int_scale_ratio =
 		dal_fixed31_32_u2d19(data->ratios->horz) << 5;
@@ -676,6 +672,7 @@ static void program_scl_ratios_inits(
 {
 	uint32_t addr = scl->regs[IDX_SCL_HORZ_SCALE_RATIO];
 	uint32_t value = 0;
+
 	set_reg_field_value(
 		value,
 		inits->h_int_scale_ratio,
@@ -761,6 +758,7 @@ static bool set_scaler_wrapper(
 	{
 		uint32_t addr = scl->regs[IDX_SCL_BYPASS_CONTROL];
 		uint32_t value = dal_read_reg(scl->ctx, addr);
+
 		set_reg_field_value(
 			value,
 			0,
@@ -915,6 +913,7 @@ struct scaler *dal_scaler_dce110_create(
 	struct scaler_init_data *init_data)
 {
 	struct scaler *scl = dal_alloc(sizeof(struct scaler));
+
 	if (!scl)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c
index 2dbe6cc..ec97406 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/scaler_v_dce110.c
@@ -92,13 +92,13 @@ enum scl_regs_idx {
 	[IDX_SCL_SCL_COEF_RAM_TAP_DATA] = mmSCLV_COEF_RAM_TAP_DATA,\
 	[IDX_SCL_TAP_CONTROL] = mmSCLV_TAP_CONTROL,\
 	[IDX_SCL_OVERSCAN_LEFT_RIGHT] = mmSCLV_EXT_OVERSCAN_LEFT_RIGHT,\
-	[IDX_SCL_OVERSCAN_TOP_BOTTOM] = mmSCLV_EXT_OVERSCAN_TOP_BOTTOM ,\
-	[IDX_SCL_VIEWPORT_START] = mmSCLV_VIEWPORT_START ,\
+	[IDX_SCL_OVERSCAN_TOP_BOTTOM] = mmSCLV_EXT_OVERSCAN_TOP_BOTTOM,\
+	[IDX_SCL_VIEWPORT_START] = mmSCLV_VIEWPORT_START,\
 	[IDX_SCL_VIEWPORT_SIZE] = mmSCLV_VIEWPORT_SIZE,\
 	[IDX_SCL_MODE] = mmSCLV_MODE,\
 	[IDX_SCL_ROUND_OFFSET] = mmSCL_ROUND_OFFSET,\
 	[IDX_SCL_CONTROL] = mmSCLV_CONTROL,\
-	[IDX_SCL_VIEWPORT_START_C] = mmSCLV_VIEWPORT_START_C ,\
+	[IDX_SCL_VIEWPORT_START_C] = mmSCLV_VIEWPORT_START_C,\
 	[IDX_SCL_VIEWPORT_SIZE_C] = mmSCLV_VIEWPORT_SIZE_C,\
 }
 
@@ -228,7 +228,7 @@ static void program_viewport(
  * macro definitions
  *****************************************************************************/
 #define NOT_IMPLEMENTED()  DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_CONTROLLER,\
-			"SCALER:%s()\n", __func__);
+			"SCALER:%s()\n", __func__)
 
 /* Until and For MPO video play story, to reduce time for implementation,
  * below limits are applied for now: 2_TAPS only
@@ -383,6 +383,7 @@ static void set_scaler_bypass(struct scaler *scl)
 {
 	uint32_t addr = scl->regs[IDX_SCL_MODE];
 	uint32_t value = dal_read_reg(scl->ctx, addr);
+
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_MODE);
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_MODE_C);
 	set_reg_field_value(value, 0, SCLV_MODE, SCL_PSCL_EN);
@@ -459,6 +460,7 @@ static bool program_multi_taps_filter(
 	bool horizontal)
 {
 	struct dal_context *dal_context = scl->ctx;
+
 	NOT_IMPLEMENTED();
 	return false;
 }
@@ -548,6 +550,7 @@ static void program_scl_ratios_inits(
 	struct dal_context *ctx = scl->ctx;
 	uint32_t addr = scl->regs[IDX_SCL_HORZ_SCALE_RATIO];
 	uint32_t value = dal_read_reg(ctx, addr);
+
 	set_reg_field_value(
 		value,
 		inits->h_int_scale_ratio_luma,
@@ -711,6 +714,7 @@ struct scaler *dal_scaler_v_dce110_create(
 	struct scaler_init_data *init_data)
 {
 	struct scaler *scl = dal_alloc(sizeof(struct scaler));
+
 	if (!scl)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/surface_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/surface_dce110.c
index 85b8bfe..31bbf64 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/surface_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/surface_dce110.c
@@ -223,6 +223,7 @@ static void program_size_and_rotation(
 		rotation == PLANE_ROTATION_ANGLE_270) {
 
 		uint32_t swap;
+
 		swap = local_size.grph.surface_size.x;
 		local_size.grph.surface_size.x =
 			local_size.grph.surface_size.y;
@@ -305,6 +306,7 @@ static void program_tiling(
 	const enum surface_pixel_format pixel_format)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(
 			sf->ctx,
 			sf->regs[IDX_GRPH_CONTROL]);
@@ -481,6 +483,7 @@ static void set_flip_control(
 	bool immediate)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(
 			sf->ctx,
 			sf->regs[IDX_GRPH_FLIP_CONTROL]);
@@ -513,6 +516,7 @@ static bool is_phy_addr_equal(
 static void enable(struct surface *sf)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(sf->ctx, sf->regs[IDX_GRPH_ENABLE]);
 	set_reg_field_value(value, 1, GRPH_ENABLE, GRPH_ENABLE);
 	dal_write_reg(sf->ctx, sf->regs[IDX_GRPH_ENABLE], value);
@@ -556,6 +560,7 @@ struct surface *dal_surface_dce110_create(
 	struct surface_init_data *init_data)
 {
 	struct surface *sf = dal_alloc(sizeof(struct surface));
+
 	if (!sf)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/surface_v_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/surface_v_dce110.c
index f0da4e2..4f3f71e 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/surface_v_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/surface_v_dce110.c
@@ -236,6 +236,7 @@ static void program_size_and_rotation(
 		rotation == PLANE_ROTATION_ANGLE_270) {
 
 		uint32_t swap;
+
 		swap = local_size.video.luma_size.x;
 		local_size.video.luma_size.x =
 			local_size.video.luma_size.y;
@@ -372,6 +373,7 @@ static void program_tiling(
 	const enum surface_pixel_format pixel_format)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(
 			sf->ctx,
 			sf->regs[IDX_GRPH_CONTROL]);
@@ -576,6 +578,7 @@ static void set_flip_control(
 static void enable(struct surface *sf)
 {
 	uint32_t value = 0;
+
 	value = dal_read_reg(sf->ctx, sf->regs[IDX_GRPH_ENABLE]);
 	set_reg_field_value(value, 1, UNP_GRPH_ENABLE, GRPH_ENABLE);
 	dal_write_reg(sf->ctx, sf->regs[IDX_GRPH_ENABLE], value);
@@ -619,6 +622,7 @@ struct surface *dal_surface_v_dce110_create(
 	struct surface_init_data *init_data)
 {
 	struct surface *sf = dal_alloc(sizeof(struct surface));
+
 	if (!sf)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/timing_generator_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/timing_generator_dce110.c
index 161cfa6..7c8a715 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/timing_generator_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/timing_generator_dce110.c
@@ -183,6 +183,7 @@ static bool enable_crtc(struct timing_generator *tg)
 	/* 0 value is needed by DRR and is also suggested default value for CZ
 	 */
 	uint32_t value;
+
 	value = dal_read_reg(tg->ctx,
 			tg->regs[IDX_CRTC_MASTER_UPDATE_MODE]);
 	set_reg_field_value(value, 0,
@@ -223,6 +224,7 @@ static bool blank_crtc(
 		uint32_t addr = tg->regs[IDX_CRTC_BLANK_CONTROL];
 		uint32_t value;
 		uint8_t counter = 34;
+
 		while (counter > 0) {
 			value = dal_read_reg(tg->ctx, addr);
 
@@ -377,9 +379,10 @@ static void disable_stereo(struct timing_generator *tg)
 			CRTC_3D_STRUCTURE_CONTROL,
 			CRTC_3D_STRUCTURE_STEREO_SEL_OVR);
 
-	/* When disabling Frame Packing in 2 step mode, we need to program both
+	/*
+	 * When disabling Frame Packing in 2 step mode, we need to program both
 	 * registers at the same frame
-	 * Programming it in the beginning of VActive makes sure we are ok 
+	 * Programming it in the beginning of VActive makes sure we are ok
 	 */
 
 	if (struc_en != 0 && struc_stereo_sel_ovr == 0) {
@@ -426,6 +429,7 @@ static void program_pixel_repetition(
 	uint32_t repeat_cnt)
 {
 	uint32_t regval;
+
 	ASSERT((repeat_cnt > 0) && (repeat_cnt < 10));
 
 	regval = dal_read_reg(tg->ctx,
@@ -448,6 +452,7 @@ static void program_horz_count_by_2(
 	const struct hw_crtc_timing *timing)
 {
 	uint32_t regval;
+
 	regval = dal_read_reg(tg->ctx,
 			tg->regs[IDX_CRTC_COUNT_CONTROL]);
 
@@ -585,6 +590,7 @@ static void program_drr(
 	uint32_t static_screen_cntl = 0;
 
 	uint32_t addr = 0;
+
 	addr = tg->regs[IDX_CRTC_V_TOTAL_MIN];
 	v_total_min = dal_read_reg(tg->ctx, addr);
 
@@ -790,7 +796,7 @@ static uint32_t get_crtc_scanoutpos(
 
 	{
 		uint32_t value = dal_read_reg(tg->ctx,
-				tg->regs[IDX_CRTC_V_TOTAL]);;
+				tg->regs[IDX_CRTC_V_TOTAL]);
 		vtotal = get_reg_field_value(
 			value, CRTC_V_TOTAL, CRTC_V_TOTAL);
 	}
@@ -1124,7 +1130,7 @@ static bool timing_generator_dce110_construct(struct timing_generator *tg,
 
 	tg->ctx = ctx;
 	tg->bp = dal_adapter_service_get_bios_parser(as);
-	tg->regs = tg_regs[id - 1];
+	tg->regs = tg_regs[id-1];
 	tg->funcs = &timing_generator_dce110_funcs;
 	tg->max_h_total = CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1;
 	tg->max_v_total = CRTC_V_TOTAL__CRTC_V_TOTAL_MASK + 1;
diff --git a/drivers/gpu/drm/amd/dal/controller/graphics_and_video_gamma.c b/drivers/gpu/drm/amd/dal/controller/graphics_and_video_gamma.c
index 79b2e0a..b50d581 100644
--- a/drivers/gpu/drm/amd/dal/controller/graphics_and_video_gamma.c
+++ b/drivers/gpu/drm/amd/dal/controller/graphics_and_video_gamma.c
@@ -131,8 +131,9 @@ static bool build_custom_float(
 		dal_fixed31_32_zero)) {
 		*negative = format->sign;
 		value = dal_fixed31_32_neg(value);
-	} else
+	} else {
 		*negative = false;
+	}
 
 	if (dal_fixed31_32_lt(
 		value,
@@ -152,8 +153,9 @@ static bool build_custom_float(
 			*mantissa = 0;
 			*exponenta = 0;
 			return true;
-		} else
-			*exponenta = exp_offset - i;
+		}
+
+		*exponenta = exp_offset - i;
 	} else if (dal_fixed31_32_le(
 		mantissa_constant_plus_max_fraction,
 		value)) {
@@ -167,8 +169,9 @@ static bool build_custom_float(
 			value));
 
 		*exponenta = exp_offset + i - 1;
-	} else
+	} else {
 		*exponenta = exp_offset;
+	}
 
 	mantiss = dal_fixed31_32_sub(
 		value,
diff --git a/drivers/gpu/drm/amd/dal/controller/timing_generator.c b/drivers/gpu/drm/amd/dal/controller/timing_generator.c
index d06c3b9..df83d92 100644
--- a/drivers/gpu/drm/amd/dal/controller/timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/controller/timing_generator.c
@@ -250,6 +250,7 @@ bool dal_timing_generator_validate_timing(
 	uint32_t h_blank;
 	uint32_t h_front_porch;
 	uint32_t h_back_porch;
+
 	ASSERT(hw_crtc_timing != NULL);
 
 	if (!hw_crtc_timing)
diff --git a/drivers/gpu/drm/amd/dal/controller/video_gamma.c b/drivers/gpu/drm/amd/dal/controller/video_gamma.c
index 051265e..8496476 100644
--- a/drivers/gpu/drm/amd/dal/controller/video_gamma.c
+++ b/drivers/gpu/drm/amd/dal/controller/video_gamma.c
@@ -165,6 +165,7 @@ static bool build_custom_gamma_mapping_coefficients(
 	uint32_t points_num)
 {
 	uint32_t i;
+
 	for (i = 0; i <= points_num; ++i) {
 		struct fixed31_32 coord_x;
 		uint32_t index_to_start = 0;
@@ -259,6 +260,7 @@ static bool build_oem_custom_gamma_mapping_coefficients(
 	uint32_t points_num)
 {
 	uint32_t i;
+
 	for (i = 0; i <= points_num; ++i) {
 		struct fixed31_32 coord_x = xhw[i];
 
@@ -362,6 +364,7 @@ static bool build_oem_regamma(
 
 	if (data->regamma.features.bits.GAMMA_RAMP_ARRAY == 0) {
 		uint32_t i;
+
 		for (i = 0; i <= points_num; ++i) {
 			/* for gamma array these values are same because a0-a3
 			 * for ideals are the same */
@@ -587,6 +590,7 @@ static void generate_gamma(
 
 	for (i = 0; i < MAX_GAMMA_256X3X16; ++i) {
 		struct fixed31_32 value;
+
 		gamma_sample[i].point_x =
 			dal_fixed31_32_from_fraction(i, MAX_GAMMA_256X3X16 - 1);
 
@@ -621,6 +625,7 @@ static bool build_resulted_regamma(
 	uint32_t points_num)
 {
 	uint32_t i;
+
 	if (!build_custom_gamma_mapping_coefficients(item->axis_x256,
 		item->regamma, item->coeff_128, CHANNEL_NAME_RED,
 		points_num))
@@ -663,6 +668,7 @@ static bool find_software_points(
 	enum hw_point_position *position)
 {
 	uint32_t i;
+
 	for (i = *index_to_start; i < points_num; ++i) {
 		struct fixed31_32 left = x[i];
 
diff --git a/drivers/gpu/drm/amd/dal/dcs/dcs.c b/drivers/gpu/drm/amd/dal/dcs/dcs.c
index 7ca70c7..c44a48b 100644
--- a/drivers/gpu/drm/amd/dal/dcs/dcs.c
+++ b/drivers/gpu/drm/amd/dal/dcs/dcs.c
@@ -157,6 +157,7 @@ static bool get_default_pixel_encoding(
 	struct display_pixel_encoding_support *pixel_encoding)
 {
 	struct edid_base *edid = NULL;
+
 	pixel_encoding->mask = 0;
 
 	/* Wireless has fixed color depth support */
@@ -222,6 +223,7 @@ static void add_dp_default_audio_modes(
 	 *	bit 1 - 20 bit
 	 *	bit 2 - 24 bit*/
 	struct cea_audio_mode audio_mode = { 0 };
+
 	audio_mode.format_code = AUDIO_FORMAT_CODE_LINEARPCM;
 	audio_mode.channel_count = 2;/* 2 channels */
 	audio_mode.sample_rate = 7;/* 32, 44.1, 48 kHz supported */
@@ -234,6 +236,7 @@ static void add_dp_forced_audio_modes(
 {
 	/* CEA-861 short audio descriptor*/
 	struct cea_audio_mode audio_mode = { 0 };
+
 	audio_mode.format_code = AUDIO_FORMAT_CODE_LINEARPCM;
 	audio_mode.channel_count = 8;/* 8 channels */
 	/*32, 44.1, 48, 88.2, 96, 176.4 kHz */
@@ -253,6 +256,7 @@ static void add_hdmi_default_audio_modes(
 {
 	/* CEA-861 short audio descriptor*/
 	struct cea_audio_mode audio_mode = { 0 };
+
 	audio_mode.format_code = AUDIO_FORMAT_CODE_LINEARPCM;
 	audio_mode.channel_count = 2;/* 2 channels */
 	audio_mode.sample_rate = 7;/* 32, 44.1, 48 kHz supported */
@@ -283,6 +287,7 @@ static void add_wireless_default_audio_modes(
 			* mode that should be appended.
 			*/
 			struct cea_audio_mode resultant_cea_audio_mode;
+
 			if (dal_rdr_get_supported_cea_audio_mode(
 				dcs->rdrm,
 				dal_dcs_cea_audio_mode_list_at_index(
@@ -739,8 +744,7 @@ static void build_drr_settings(struct dcs *dcs)
 		else if (feature_value >= AS_DRR_SUPPORT_MIN_FORCED_FPS) {
 			dcs->drr_config.min_fps_in_microhz = feature_value;
 			if (dcs->drr_config.min_fps_in_microhz > 0)
-				dcs->drr_config.support_method. \
-					FORCED_BY_REGKEY_OR_ESCAPE
+				dcs->drr_config.support_method.FORCED_BY_REGKEY_OR_ESCAPE
 					= true;
 		}
 
@@ -802,6 +806,7 @@ enum edid_retrieve_status dal_dcs_update_edid_from_last_retrieved(
 	struct dcs *dcs)
 {
 	enum edid_retrieve_status ret;
+
 	if (!dcs->edid_mgr) {
 		BREAK_TO_DEBUGGER();
 		return EDID_RETRIEVE_FAIL;
@@ -838,6 +843,7 @@ struct ddc_service *dal_dcs_update_ddc(
 	struct ddc_service *ddc)
 {
 	struct ddc_service *old_ddc_service = dcs->ddc_service;
+
 	dcs->ddc_service = ddc;
 	return old_ddc_service;
 }
@@ -1017,6 +1023,7 @@ static bool should_insert_mode(
 	bool ce_mode = dal_timing_service_is_ce_timing_standard(
 		mode_timing->crtc_timing.timing_standard);
 	bool insert_mode = false;
+
 	switch (mode_timing->crtc_timing.pixel_encoding) {
 	case PIXEL_ENCODING_YCBCR444:
 		/* 3) for CE timing, we allow all color depth for YCbCr444
@@ -1199,6 +1206,7 @@ enum { DEFAULT_3D_RIGHT_EYE_POLARITY = false };
 static void setup_projector_stereo_3d_timings(struct dcs_mode_timing_list *list)
 {
 	uint32_t i;
+
 	for (i = 0; i < dal_dcs_mode_timing_list_get_count(list); i++) {
 		struct mode_timing *mt =
 			dal_dcs_mode_timing_list_at_index(list, i);
@@ -1208,6 +1216,7 @@ static void setup_projector_stereo_3d_timings(struct dcs_mode_timing_list *list)
 		bool progresive_120hz = mt->mode_info.field_rate == 120 &&
 			!mt->mode_info.flags.INTERLACE;
 		bool edid_source = false;
+
 		switch (mt->mode_info.timing_source) {
 		case TIMING_SOURCE_EDID_CEA_SVD_3D:
 		case TIMING_SOURCE_EDID_DETAILED:
@@ -1291,6 +1300,7 @@ static bool are_3d_formats_compatible(
 	 * symmetric */
 	if (f2 == TIMING_3D_FORMAT_SW_FRAME_PACKING) {
 		enum timing_3d_format tmp = f1;
+
 		f1 = f2;
 		f2 = tmp;
 	}
@@ -1542,6 +1552,7 @@ static void add_default_modes(
 		struct mode_timing *mode_timing = NULL;
 		uint32_t list_count = dal_dcs_mode_timing_list_get_count(list);
 		uint32_t i;
+
 		for (i = list_count; i > 0; --i) {
 			mode_timing =
 				dal_dcs_mode_timing_list_at_index(list, i-1);
@@ -1753,6 +1764,7 @@ static void insert_edid_dco_mode_timing(
 			pixel_encoding <= PIXEL_ENCODING_MASK_RGB;
 			pixel_encoding <<= 1) {
 			bool insert_mode = false;
+
 			if (!(pixel_encoding &
 				color_and_pixel_support->
 				pixel_encoding_support.mask))
@@ -2300,6 +2312,7 @@ void dal_dcs_query_sink_capability(
 		if (dal_ddc_service_is_in_aux_transaction_mode(
 			dcs->ddc_service)) {
 			struct av_sync_data av_sync_data = {0};
+
 			dal_ddc_service_aux_query_dp_sink_capability(
 				dcs->ddc_service, sink_cap);
 			dal_ddc_service_retrieve_dpcd_data(
diff --git a/drivers/gpu/drm/amd/dal/dcs/ddc_i2caux_helper.c b/drivers/gpu/drm/amd/dal/dcs/ddc_i2caux_helper.c
index 57c0338..05a56cc 100644
--- a/drivers/gpu/drm/amd/dal/dcs/ddc_i2caux_helper.c
+++ b/drivers/gpu/drm/amd/dal/dcs/ddc_i2caux_helper.c
@@ -39,13 +39,14 @@ struct aux_payloads {
 struct i2c_payloads *dal_ddc_i2c_payloads_create(uint32_t count)
 {
 	struct i2c_payloads *payloads;
+
 	payloads = dal_alloc(sizeof(struct i2c_payloads));
 
 	if (!payloads)
 		return NULL;
 
 	if (dal_vector_construct(
-		&payloads->payloads, count , sizeof(struct i2c_payload)))
+		&payloads->payloads, count, sizeof(struct i2c_payload)))
 		return payloads;
 
 	dal_free(payloads);
@@ -76,13 +77,14 @@ void dal_ddc_i2c_payloads_destroy(struct i2c_payloads **p)
 struct aux_payloads *dal_ddc_aux_payloads_create(uint32_t count)
 {
 	struct aux_payloads *payloads;
+
 	payloads = dal_alloc(sizeof(struct aux_payloads));
 
 	if (!payloads)
 		return NULL;
 
 	if (dal_vector_construct(
-		&payloads->payloads, count , sizeof(struct aux_payloads)))
+		&payloads->payloads, count, sizeof(struct aux_payloads)))
 		return payloads;
 
 	dal_free(payloads);
@@ -122,6 +124,7 @@ void dal_ddc_i2c_payloads_add(
 {
 	uint32_t payload_size = EDID_SEGMENT_SIZE;
 	uint32_t pos;
+
 	for (pos = 0; pos < len; pos += payload_size) {
 		struct i2c_payload payload = {
 			.write = write,
@@ -142,6 +145,7 @@ void dal_ddc_aux_payloads_add(
 {
 	uint32_t payload_size = DEFAULT_AUX_MAX_DATA_SIZE;
 	uint32_t pos;
+
 	for (pos = 0; pos < len; pos += payload_size) {
 		struct aux_payload payload = {
 			.i2c_over_aux = true,
diff --git a/drivers/gpu/drm/amd/dal/dcs/ddc_service.c b/drivers/gpu/drm/amd/dal/dcs/ddc_service.c
index 49cf989..c5e51fc 100644
--- a/drivers/gpu/drm/amd/dal/dcs/ddc_service.c
+++ b/drivers/gpu/drm/amd/dal/dcs/ddc_service.c
@@ -215,6 +215,7 @@ static uint32_t defer_delay_converter_wa(
 	uint32_t defer_delay)
 {
 	struct dp_receiver_id_info dp_rec_info = {0};
+
 	if (dal_ddc_service_get_dp_receiver_id_info(ddc, &dp_rec_info) &&
 		(dp_rec_info.branch_id == DP_BRANCH_DEVICE_ID_4) &&
 		!dal_strncmp(dp_rec_info.branch_name,
@@ -232,6 +233,7 @@ static uint32_t defer_delay_converter_wa(
 static uint32_t get_defer_delay(struct ddc_service *ddc)
 {
 	uint32_t defer_delay = 0;
+
 	switch (ddc->transaction_type) {
 	case DDC_TRANSACTION_TYPE_I2C_OVER_AUX:
 		if ((DISPLAY_DONGLE_DP_VGA_CONVERTER == ddc->dongle_type) ||
@@ -529,6 +531,7 @@ static uint8_t aux_read_edid_block(
 			.length = 1,
 			.data = &segment } };
 		bool result = false;
+
 		segment = 0;
 
 		cmd.number_of_payloads = ARRAY_SIZE(payloads);
@@ -842,8 +845,7 @@ bool dal_ddc_service_i2c_query_dp_dual_mode_adaptor(
 			dal_logger_write(ddc->ctx->logger,
 				LOG_MAJOR_DCS,
 				LOG_MINOR_DCS_DONGLE_DETECTION,
-				"Detected Type 1 DP-HDMI dongle"
-				"(no valid HDMI signature EOT).\n");
+				"Detected Type 1 DP-HDMI dongle (no valid HDMI signature EOT).\n");
 
 			*dongle = DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE;
 			return true;
@@ -869,8 +871,7 @@ bool dal_ddc_service_i2c_query_dp_dual_mode_adaptor(
 			dal_logger_write(ddc->ctx->logger,
 				LOG_MAJOR_DCS,
 				LOG_MINOR_DCS_DONGLE_DETECTION,
-				"Detected Type 1 DP-HDMI dongle"
-				"(no valid HDMI signature EOT).\n");
+				"Detected Type 1 DP-HDMI dongle (no valid HDMI signature EOT).\n");
 
 			*dongle = DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE;
 			return true;
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid.c
index 7e2f600..d2d24aa 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid.c
@@ -39,6 +39,7 @@ bool dal_edid_get_version_raw(
 	uint8_t *minor)
 {
 	const struct edid_data_v1x *data;
+
 	if (!minor || !major)
 		return false;
 
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c
index 4b5f483..de69333 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid13.c
@@ -77,6 +77,7 @@ bool dal_edid13_is_v_13(uint32_t len, const uint8_t *buff)
 {
 	uint8_t major;
 	uint8_t minor;
+
 	if (!dal_edid_get_version_raw(buff, len, &major, &minor))
 		return false;
 
@@ -444,6 +445,7 @@ bool dal_edid13_get_vendor_product_id_info(
 		struct vendor_product_id_info *info)
 {
 	struct edid_13 *e = FROM_EDID(edid);
+
 	if (info == NULL)
 		return false;
 
@@ -673,6 +675,7 @@ static bool get_screen_info(
 		struct edid_screen_info *edid_screen_info)
 {
 	struct edid_13 *e = FROM_EDID(edid);
+
 	ASSERT(edid_screen_info != NULL);
 
 	/* Projector*/
@@ -737,18 +740,21 @@ bool dal_edid13_get_display_pixel_encoding(
 uint8_t dal_edid13_num_of_extension(struct edid_base *edid)
 {
 	struct edid_13 *e = FROM_EDID(edid);
+
 	return e->data->ext_blk_cnt;
 }
 
 uint16_t dal_edid13_get_version(struct edid_base *edid)
 {
 	struct edid_13 *e = FROM_EDID(edid);
+
 	return (e->data->version[0] << 8) | (e->data->version[1]);
 }
 
 const uint8_t *dal_edid13_get_raw_data(struct edid_base *edid)
 {
 	struct edid_13 *e = FROM_EDID(edid);
+
 	return (uint8_t *)e->data;
 }
 
@@ -760,6 +766,7 @@ const uint32_t dal_edid13_get_raw_size(struct edid_base *edid)
 void dal_edid13_validate(struct edid_base *edid)
 {
 	struct edid_13 *e = FROM_EDID(edid);
+
 	if (e->data->checksum != dal_edid_compute_checksum(edid))
 		edid->error.BAD_CHECKSUM = true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid14.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid14.c
index 7adb379..b4e0143 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid14.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid14.c
@@ -164,6 +164,7 @@ bool dal_edid14_is_v_14(uint32_t len, const uint8_t *buff)
 {
 	uint8_t major;
 	uint8_t minor;
+
 	if (!dal_edid_get_version_raw(buff, len, &major, &minor))
 		return false;
 
@@ -390,6 +391,7 @@ static bool add_established_timing(
 /*Parse Established Timing I/II & Manufacturer's Timing without selecting
  preferred mode. Preferred mode will be selected in the end of this function*/
 		bool ignore_preffered = true;
+
 		dal_edid13_add_established_timings(
 			edid, list, &ignore_preffered);
 	}
@@ -591,6 +593,7 @@ static bool get_display_color_depth(
 	uint8_t vsi = e->data->basic_display_params[0];
 	uint8_t bit_depth = vsi & EDID14_BITDEPTH_MASK;
 	enum dcs_edid_connector_type connector;
+
 	color_depth->mask = 0;
 
 	ASSERT(color_depth != NULL);
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid1x_data.h b/drivers/gpu/drm/amd/dal/dcs/edid/edid1x_data.h
index 61b0e01..d4aee69 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid1x_data.h
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid1x_data.h
@@ -132,8 +132,7 @@ struct edid_display_descriptor {
 
 		/* as standard timing id, when ucTypeTag == 0xfa*/
 		struct {
-			struct standard_timing timing[
-			MAX_NUM_OF_STD_TIMING_IDS_IN_DET_TIMING_DESC];
+			struct standard_timing timing[MAX_NUM_OF_STD_TIMING_IDS_IN_DET_TIMING_DESC];
 			uint8_t magic;
 		} std_timings;
 
@@ -145,8 +144,7 @@ struct edid_display_descriptor {
 		/* as CVT 3byte timings, when ucTypeTag == 0xf8*/
 		struct {
 			uint8_t version;
-			struct cvt_3byte_timing timing[
-			MAX_NUM_OF_CVT3BYTE_TIMING_IDS_IN_DET_TIMING_DESC];
+			struct cvt_3byte_timing timing[MAX_NUM_OF_CVT3BYTE_TIMING_IDS_IN_DET_TIMING_DESC];
 		} cvt_3byte_timing;
 
 		/* as established timings III, when ucTypeTag = 0xf7*/
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c
index 3e99387..058e55d 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid20.c
@@ -75,6 +75,7 @@ bool dal_edid20_is_v_20(uint32_t len, const uint8_t *buf)
 {
 	uint8_t major;
 	uint8_t minor;
+
 	if (!dal_edid_get_version_raw(buf, len, &major, &minor))
 		return false;
 
@@ -272,6 +273,7 @@ static bool get_supported_mode_timing(
 	/*Calling sequence/order is important for preferred mode lookup*/
 	bool ret_det = add_detailed_timings(e, list, preferred_mode_found);
 	bool ret_4byte = add_4byte_timings(e, list, preferred_mode_found);
+
 	return ret_det || ret_4byte;
 }
 
@@ -526,6 +528,7 @@ static uint16_t get_version(struct edid_base *edid)
 static const uint8_t *get_raw_data(struct edid_base *edid)
 {
 	struct edid_20 *e = FROM_EDID(edid);
+
 	return (uint8_t *)e->data;
 }
 
@@ -537,6 +540,7 @@ static const uint32_t get_raw_size(struct edid_base *edid)
 static void validate(struct edid_base *edid)
 {
 	struct edid_20 *e = FROM_EDID(edid);
+
 	if (e->data->checksum != dal_edid_compute_checksum(edid))
 		edid->error.BAD_CHECKSUM = true;
 }
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_base.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_base.c
index 4e1b7d8..9c216f5 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_base.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_base.c
@@ -223,6 +223,7 @@ void dal_edid_list_destroy(struct edid_base *edid)
 
 	do {
 		struct edid_base *edid_base = edid->next;
+
 		dal_edid_destroy(&edid);
 		edid = edid_base;
 	} while (edid);
@@ -244,6 +245,7 @@ bool dal_edid_get_supported_mode_timing(
 	bool *preferred_mode_found)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_ALL(
 		edid,
 		get_supported_mode_timing(edid, list, preferred_mode_found),
@@ -256,6 +258,7 @@ bool dal_edid_get_vendor_product_id_info(
 	struct vendor_product_id_info *info)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_vendor_product_id_info(edid, info),
@@ -269,6 +272,7 @@ bool dal_edid_get_display_name(
 	uint32_t name_size)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_display_name(edid, name, name_size),
@@ -281,6 +285,7 @@ bool dal_edid_get_monitor_range_limits(
 	struct monitor_range_limits *limits)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_monitor_range_limits(edid, limits),
@@ -293,6 +298,7 @@ bool dal_edid_get_display_characteristics(
 	struct display_characteristics *characteristics)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_display_characteristics(edid, characteristics),
@@ -305,6 +311,7 @@ bool dal_edid_get_screen_info(
 	struct edid_screen_info *info)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_screen_info(edid, info),
@@ -316,6 +323,7 @@ enum dcs_edid_connector_type dal_edid_get_connector_type(struct edid_base *edid)
 {
 	enum dcs_edid_connector_type type = EDID_CONNECTOR_UNKNOWN;
 	bool res = false;
+
 	FOR_EACH_EDID_ALL(
 		edid, get_connector_type(edid, &type), res);
 	return type;
@@ -325,6 +333,7 @@ bool dal_edid_get_display_color_depth(
 	struct display_color_depth_support *color_depth)
 {
 	bool res = false;
+
 	FOR_EACH_EDID_ALL(
 		edid, get_display_color_depth(edid, color_depth), res);
 	return res;
@@ -349,6 +358,7 @@ bool dal_edid_get_cea861_support(
 	struct cea861_support *cea861_support)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_cea861_support(edid, cea861_support),
@@ -361,6 +371,7 @@ bool dal_edid_get_cea_vendor_specific_data_block(
 	struct cea_vendor_specific_data_block *vendor_block)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_cea_vendor_specific_data_block(edid, vendor_block),
@@ -373,6 +384,7 @@ bool dal_edid_get_cea_speaker_allocation_data_block(
 	union cea_speaker_allocation_data_block *spkr_data)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_cea_speaker_allocation_data_block(edid, spkr_data),
@@ -384,6 +396,7 @@ bool dal_edid_get_cea_colorimetry_data_block(
 	struct cea_colorimetry_data_block *colorimetry_data_block)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_cea_colorimetry_data_block(edid, colorimetry_data_block),
@@ -396,6 +409,7 @@ bool dal_edid_get_cea_video_capability_data_block(
 	union cea_video_capability_data_block *video_capability_data_block)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_cea_video_capability_data_block(
@@ -443,6 +457,7 @@ bool dal_edid_get_stereo_3d_support(
 	struct edid_stereo_3d_capability *stereo_capability)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_stereo_3d_support(edid, stereo_capability),
@@ -453,6 +468,7 @@ bool dal_edid_get_stereo_3d_support(
 bool dal_edid_is_non_continous_frequency(struct edid_base *edid)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		is_non_continuous_frequency(edid),
@@ -463,6 +479,7 @@ bool dal_edid_is_non_continous_frequency(struct edid_base *edid)
 uint32_t dal_edid_get_drr_pixel_clk_khz(struct edid_base *edid)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_drr_pixel_clk_khz(edid),
@@ -473,6 +490,7 @@ uint32_t dal_edid_get_drr_pixel_clk_khz(struct edid_base *edid)
 uint32_t dal_edid_get_min_drr_fps(struct edid_base *edid)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_min_drr_fps(edid),
@@ -485,6 +503,7 @@ bool dal_edid_get_display_tile_info(
 	struct dcs_display_tile *display_tile)
 {
 	bool ret = false;
+
 	FOR_EACH_EDID_FIRST(
 		edid,
 		get_display_tile_info(edid, display_tile),
@@ -512,7 +531,8 @@ bool dal_edid_validate_display_gamma(struct edid_base *edid, uint8_t gamma)
 	/*TODO: looks useless, input uint8_t + 100 in range 100-355*/
 	uint32_t min_gamma = 100; /*min acc.to vesa spec*/
 	uint32_t max_gamma = 355; /*max acc.to vesa spec*/
-	uint32_t i_gamma = gamma ;
+	uint32_t i_gamma = gamma;
+
 	/*gamma should be in range 1 - 3.55
 	edid has the gamma in the following form= 120(x78),
 	the usage is (120+100)/100=2.2*/
@@ -734,13 +754,13 @@ bool dal_edid_detailed_to_timing(
 	}
 
 	/* Check if the timing parsed has realistically valid values*/
-	if (dal_timing_service_are_timing_parameters_valid(timing)) {
-		patch_porch_values_for_4k(timing);
-		return true;
-	} else {
+	if (!dal_timing_service_are_timing_parameters_valid(timing)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
+
+	patch_porch_values_for_4k(timing);
+	return true;
 }
 
 bool dal_edid_get_timing_for_vesa_mode(
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c
index f536ae4..0c0b02e 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_cea.c
@@ -526,6 +526,7 @@ struct edid_ext_cea {
 bool dal_edid_ext_cea_is_cea_ext(uint32_t len, const uint8_t *buf)
 {
 	const struct edid_data_cea861_ext *ext;
+
 	if (len < sizeof(struct edid_data_cea861_ext))
 		return false; /* CEA extension is 128 byte in length*/
 
@@ -1121,6 +1122,7 @@ static bool add_hdmi_vic_timings(
 			++i) {
 			/* get non video optimized version */
 			struct mode_timing mode_timing;
+
 			if (get_timing_for_hdmi_vic(
 				edid,
 				video_fields.hdmi_vic[i],
@@ -1252,6 +1254,7 @@ static bool get_cea_vendor_specific_data_block(
 	/* optional 7th byte */
 	if (descr.len >= 7) {
 		const struct monitor_patch_info *patch_info;
+
 		vendor_block->max_tmds_clk_mhz = vsdb->max_tmds_clk * 5;
 
 		patch_info =
@@ -1444,6 +1447,7 @@ static bool get_cea_speaker_allocation_data_block(
 {
 	struct edid_ext_cea *ext = FROM_EDID(edid);
 	struct short_descr_info descr;
+
 	if (!find_short_descr(
 		ext->data,
 		0,
@@ -1610,8 +1614,10 @@ static bool add_cea861b_audio_modes(
 			&descr)) {
 		uint8_t index;
 		const uint8_t *sad = &ext->data->data_block[descr.offset];
+
 		for (index = 0; index < descr.len/3; ++index) {
 			struct cea_audio_mode audio_mode = { 0 };
+
 			audio_mode.format_code = sad[0]>>3;
 			audio_mode.channel_count = (sad[0] & 0x7) + 1;
 			audio_mode.sample_rate = sad[1] & 0x7F;
@@ -1634,18 +1640,21 @@ static bool get_cea_audio_modes(
 	struct dcs_cea_audio_mode_list *audio_list)
 {
 	struct edid_ext_cea *ext = FROM_EDID(edid);
+
 	return add_cea861b_audio_modes(ext, audio_list);
 }
 
 static uint8_t get_edid_extension_tag(struct edid_base *edid)
 {
 	struct edid_ext_cea *ext = FROM_EDID(edid);
+
 	return ext->data->extension_tag;
 }
 
 static const uint8_t *get_raw_data(struct edid_base *edid)
 {
 	struct edid_ext_cea *ext = FROM_EDID(edid);
+
 	return (const uint8_t *)ext->data;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c
index 866400a..9355751 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_di.c
@@ -141,6 +141,7 @@ struct edid_ext_di {
 static const uint8_t *get_raw_data(struct edid_base *edid)
 {
 	struct edid_ext_di *ext = FROM_EDID(edid);
+
 	return (const uint8_t *)ext->data;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c
index 03cb368..a61326d 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_unknown.c
@@ -38,6 +38,7 @@ struct edid_ext_unknown {
 static const uint8_t *get_raw_data(struct edid_base *edid)
 {
 	struct edid_ext_unknown *ext = FROM_EDID(edid);
+
 	return ext->data;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c
index af291a2..9347594 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid/edid_ext_vtb.c
@@ -309,6 +309,7 @@ static bool get_supported_mode_timing(
 static void validate(struct edid_base *edid)
 {
 	struct edid_ext_vtb *ext = FROM_EDID(edid);
+
 	if (ext->data->checksum != dal_edid_compute_checksum(edid))
 		edid->error.BAD_CHECKSUM = true;
 }
@@ -316,6 +317,7 @@ static void validate(struct edid_base *edid)
 static const uint8_t *get_raw_data(struct edid_base *edid)
 {
 	struct edid_ext_vtb *ext = FROM_EDID(edid);
+
 	return (const uint8_t *)ext->data;
 }
 
@@ -424,6 +426,7 @@ struct edid_base *dal_edid_ext_vtb_create(
 bool dal_edid_ext_vtb_is_vtb_ext(uint32_t len, const uint8_t *buf)
 {
 	const struct edid_data_vtb_ext *ext;
+
 	if (len < sizeof(struct edid_data_vtb_ext))
 		return false;
 
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid_mgr.c b/drivers/gpu/drm/amd/dal/dcs/edid_mgr.c
index f527848..f6dae7f 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid_mgr.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid_mgr.c
@@ -67,8 +67,10 @@ static struct edid_base *create_edid_ext_block(
 	struct edid_patch *edid_patch)
 {
 	struct edid_base *ext = NULL;
+
 	if (dal_edid_ext_cea_is_cea_ext(len, buf)) {
 		struct edid_ext_cea_init_data init_data;
+
 		init_data.ts = ts;
 		init_data.len = len;
 		init_data.buf = buf;
@@ -256,18 +258,18 @@ enum edid_retrieve_status dal_edid_mgr_override_raw_data(
 				edid_mgr,
 				&edid_mgr->override_edid_handle);
 			return EDID_RETRIEVE_SAME_EDID;
-		} else {
-			/*We need to return back to physical Edid -
-			 * consider it as successful override to new EDID*/
-			dal_edid_patch_initialize(
-				edid_mgr->edid_patch,
-				edid_handle->edid_buffer,
-				edid_handle->buffer_size);
-			free_edid_handle(
-				edid_mgr,
-				&edid_mgr->override_edid_handle);
-			return EDID_RETRIEVE_SUCCESS;
 		}
+
+		/*We need to return back to physical Edid -
+		 * consider it as successful override to new EDID*/
+		dal_edid_patch_initialize(
+			edid_mgr->edid_patch,
+			edid_handle->edid_buffer,
+			edid_handle->buffer_size);
+		free_edid_handle(
+			edid_mgr,
+			&edid_mgr->override_edid_handle);
+		return EDID_RETRIEVE_SUCCESS;
 	}
 
 	/* New override same as current override/physical: Nothing to do */
diff --git a/drivers/gpu/drm/amd/dal/dcs/edid_patch.c b/drivers/gpu/drm/amd/dal/dcs/edid_patch.c
index 67fb70e..75654bd 100644
--- a/drivers/gpu/drm/amd/dal/dcs/edid_patch.c
+++ b/drivers/gpu/drm/amd/dal/dcs/edid_patch.c
@@ -179,6 +179,7 @@ static inline struct monitor_patch_info *monitor_patch_list_get_patch_info(
 	enum monitor_patch_type type)
 {
 	uint32_t i;
+
 	for (i = 0; i < dal_vector_get_count(&mpl->vector); ++i) {
 		struct monitor_patch_info *info =
 			dal_vector_at_index(&mpl->vector, i);
@@ -539,6 +540,7 @@ static void patch_multipacked_type_panel_edid(
 			MONITOR_PATCH_TYPE_MULTIPLE_PACKED_TYPE);
 	/* check whether the packed type. */
 	union edid13_multipacked_panel_manufacture_reserved_timing_info timing_info;
+
 	timing_info.all = edid_data->established_timings[2];
 
 	if (timing_info.all == 0)
@@ -562,6 +564,7 @@ static void patch_multipacked_type_panel_edid(
 		uint32_t h_total;
 		uint32_t new_h_total;
 		uint32_t pix_clk;
+
 		if (edid_detailed->pix_clk == 0)
 			continue;
 
@@ -829,6 +832,7 @@ void dal_edid_patch_update_dp_receiver_id_based_monitor_patches(
 	/* handle MONITOR_PATCH_TYPE_DELAY_AFTER_DP_RECEIVER_POWER_UP */
 	if (delay_after_power_up > 0) {
 		struct monitor_patch_info info;
+
 		info.type =
 			MONITOR_PATCH_TYPE_DELAY_AFTER_DP_RECEIVER_POWER_UP;
 		info.param = delay_after_power_up;
@@ -863,6 +867,7 @@ void dal_edid_patch_update_dp_receiver_id_based_monitor_patches(
 		 * not. If it isn't applied yet, we insert it to the list. */
 		if (!ep->mpl.flags.flags.KEEP_DP_RECEIVER_POWERED) {
 			struct monitor_patch_info info;
+
 			info.type =
 				MONITOR_PATCH_TYPE_KEEP_DP_RECEIVER_POWERED;
 			info.param = 0;
@@ -882,6 +887,7 @@ void dal_edid_patch_update_dp_receiver_id_based_monitor_patches(
 		 * If it isn't applied yet, we insert it to the list. */
 		if (!ep->mpl.flags.flags.DISABLE_PSR_ENTRY_ABORT) {
 			struct monitor_patch_info info;
+
 			info.type =
 				MONITOR_PATCH_TYPE_DISABLE_PSR_ENTRY_ABORT;
 			info.param = 0;
@@ -899,6 +905,7 @@ void dal_edid_patch_update_dp_receiver_id_based_monitor_patches(
 		if (!ep->mpl.flags.flags.
 				DELAY_AFTER_DISABLE_BACKLIGHT_DFS_BYPASS) {
 			struct monitor_patch_info info;
+
 			info.type =
 				MONITOR_PATCH_TYPE_DELAY_AFTER_DISABLE_BACKLIGHT_DFS_BYPASS;
 			info.param = delay_after_disable_backlight_dfs_bypass;
@@ -910,6 +917,4 @@ void dal_edid_patch_update_dp_receiver_id_based_monitor_patches(
 			monitor_patch_list_insert(&ep->mpl, &info);
 		}
 	}
-
-	return;
 }
diff --git a/drivers/gpu/drm/amd/dal/dcs/monitor_tables.c b/drivers/gpu/drm/amd/dal/dcs/monitor_tables.c
index f2befbe..2096059 100644
--- a/drivers/gpu/drm/amd/dal/dcs/monitor_tables.c
+++ b/drivers/gpu/drm/amd/dal/dcs/monitor_tables.c
@@ -275,6 +275,7 @@ const struct monitor_patch_info *dal_monitor_tables_find_entry(
 	enum monitor_patch_type patch_type)
 {
 	uint32_t i;
+
 	for (i = 0; i < dal_monitor_tables_get_count(); ++i) {
 		const struct monitor_patch_info *entry =
 			&monitor_patch_table[i];
diff --git a/drivers/gpu/drm/amd/dal/dcs/vbios_dco.c b/drivers/gpu/drm/amd/dal/dcs/vbios_dco.c
index 23117e4..0af432f 100644
--- a/drivers/gpu/drm/amd/dal/dcs/vbios_dco.c
+++ b/drivers/gpu/drm/amd/dal/dcs/vbios_dco.c
@@ -59,6 +59,7 @@ bool dal_vbios_dco_construct(
 	struct adapter_service *as)
 {
 	bool ret = false;
+
 	if (!as)
 		return ret;
 
@@ -90,6 +91,7 @@ struct vbios_dco *dal_vbios_dco_create(
 	struct adapter_service *as)
 {
 	struct vbios_dco *dco;
+
 	dco = dal_alloc(sizeof(struct vbios_dco));
 
 	if (!dco)
@@ -205,6 +207,7 @@ static void add_patch_mode_timing(
 		dco->as, index++, &patch_mode)) {
 
 		struct mode_timing mode_timing = { { 0 } };
+
 		if (!patch_mode.width)
 			continue;
 
diff --git a/drivers/gpu/drm/amd/dal/display_path/display_path.c b/drivers/gpu/drm/amd/dal/display_path/display_path.c
index ca44675..5932a7f 100644
--- a/drivers/gpu/drm/amd/dal/display_path/display_path.c
+++ b/drivers/gpu/drm/amd/dal/display_path/display_path.c
@@ -171,6 +171,7 @@ static enum signal_type calculate_asic_signal(
 {
 	uint32_t i;
 	uint32_t current_signal;
+
 	if (path->connector == NULL)
 		return SIGNAL_TYPE_NONE;
 
@@ -270,6 +271,7 @@ bool dal_display_path_validate(
 	enum signal_type sink_signal)
 {
 	uint32_t i;
+
 	path->valid = false;
 	/* verify connector and at least one link present*/
 	if (path->number_of_links < 1 || path->connector == NULL) {
@@ -344,8 +346,10 @@ int32_t dal_display_path_release(struct display_path *path)
 void dal_display_path_release_resources(struct display_path *path)
 {
 	uint32_t i;
+
 	for (i = 0; i < path->number_of_links; i++) {
 		struct stream_context *cntx = &path->stream_contexts[i];
+
 		cntx->state.LINK = false;
 		cntx->state.AUDIO = false;
 		cntx->engine = ENGINE_ID_UNKNOWN;
@@ -521,6 +525,7 @@ struct fbc_info *dal_display_path_get_fbc_info(struct display_path *path)
 void dal_display_path_acquire_links(struct display_path *path)
 {
 	uint32_t i;
+
 	for (i = 0; i < path->number_of_links; i++) {
 		path->stream_contexts[i].input_config_signal =
 			path->stream_contexts[i].input_query_signal;
@@ -536,6 +541,7 @@ struct link_service *dal_display_path_get_mst_link_service(
 {
 	uint32_t i;
 	struct link_service *link_service = NULL;
+
 	for (i = 0; i < path->number_of_links; i++) {
 		link_service = path->stream_contexts[i].link_query_interface;
 		if (link_service != NULL
@@ -630,6 +636,7 @@ bool dal_display_path_set_pixel_clock_safe_range(
 	struct pixel_clock_safe_range *range)
 {
 	struct timing_limits timing_limits = { 0 };
+
 	if (range == NULL)
 		return false;
 
@@ -794,6 +801,7 @@ bool dal_display_path_is_drr_supported(const struct display_path *path)
 		dal_display_path_get_link_query_interface(
 				path, SINK_LINK_INDEX);
 	struct drr_config drr_config;
+
 	dal_display_path_get_drr_config(path, &drr_config);
 
 	/* The check for DRR supported returns true means it satisfied:
@@ -836,6 +844,7 @@ bool dal_display_path_is_audio_present(
 	uint32_t i;
 	const struct stream_context *link;
 	struct audio_feature_support features;
+
 	for (i = 0; i < path->number_of_links; i++) {
 		link = &path->stream_contexts[i];
 
@@ -858,6 +867,7 @@ bool dal_display_path_is_dp_auth_supported(struct display_path *path)
 	uint32_t i;
 	struct encoder_feature_support features;
 	struct stream_context *link;
+
 	for (i = 0; i < path->number_of_links; i++) {
 		link = &path->stream_contexts[i];
 		features = dal_encoder_get_supported_features(link->encoder);
@@ -874,6 +884,7 @@ bool dal_display_path_is_vce_supported(const struct display_path *path)
 	uint32_t i;
 	const struct stream_context *link;
 	struct encoder_feature_support features;
+
 	for (i = 0; i < path->number_of_links; i++) {
 		link = &path->stream_contexts[i];
 		features = dal_encoder_get_supported_features(link->encoder);
@@ -895,7 +906,6 @@ bool dal_display_path_is_sls_capable(const struct display_path *path)
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
 	case SIGNAL_TYPE_EDP:
 		return true;
-		break;
 	default:
 		break;
 	}
@@ -913,7 +923,6 @@ bool dal_display_path_is_gen_lock_capable(const struct display_path *path)
 	case SIGNAL_TYPE_DISPLAY_PORT_MST:
 	case SIGNAL_TYPE_EDP:
 		return true;
-		break;
 	default:
 		break;
 	}
@@ -938,8 +947,8 @@ struct transmitter_configuration dal_display_path_get_transmitter_configuration(
 		if (!dal_encoder_get_supported_features(
 			encoder).flags.bits.EXTERNAL_ENCODER)
 			break;
-		else
-			encoder = NULL;
+
+		encoder = NULL;
 	}
 
 	if (encoder == NULL)
@@ -1125,12 +1134,12 @@ struct controller *dal_display_path_get_controller_for_layer_index(
 
 	/* the planes are ordered starting from zero */
 	plane = dal_display_path_get_plane_at_index(path, layer_index);
-	if (plane)
-		return plane->controller;
-	else {
+	if (!plane) {
 		/* Not found. TODO: add a debug message here. */
 		return NULL;
 	}
+
+	return plane->controller;
 }
 
 void dal_display_path_release_planes(
@@ -1143,6 +1152,7 @@ void dal_display_path_release_non_root_planes(
 	struct display_path *path)
 {
 	uint32_t last_plane = dal_vector_get_count(path->planes) - 1;
+
 	for (; last_plane > 0; last_plane--)
 		dal_vector_remove_at_index(path->planes, last_plane);
 }
diff --git a/drivers/gpu/drm/amd/dal/display_service/adjustment_api.c b/drivers/gpu/drm/amd/dal/display_service/adjustment_api.c
index e07bfe5..979e393 100644
--- a/drivers/gpu/drm/amd/dal/display_service/adjustment_api.c
+++ b/drivers/gpu/drm/amd/dal/display_service/adjustment_api.c
@@ -83,6 +83,7 @@ static bool build_default_adj_table(struct adjustment_api *adj_api)
 	uint32_t i;
 	uint32_t range_alloc_size = 0;
 	const struct range_adjustment_api *tmp_range_table = NULL;
+
 	switch (adj_api->adj_category) {
 	case CAT_CRT:
 		adj_api->range_table_size = sizeof(default_adj_range_crt_table)
@@ -118,13 +119,12 @@ static bool build_default_adj_table(struct adjustment_api *adj_api)
 			/* not to do read config from reg key*/
 			}
 		}
-		if (adj_api->range_table)
-			return true;
-		else {
+		if (adj_api->range_table == NULL) {
 			destruct(adj_api);
 			return false;
 		}
 
+		return true;
 	}
 	/* to do vector table in furture*/
 	return false;
@@ -136,6 +136,7 @@ void dal_adj_api_get_api_flag(
 	union adjustment_api_flag *flag)
 {
 	uint32_t i;
+
 	if (adj_api->range_table) {
 		for (i = 0; i < adj_api->range_table_size; i++) {
 			if (adj_api->range_table[i].adj_id == adj_id) {
@@ -152,6 +153,7 @@ bool dal_adj_api_get_range_adj_data(
 	struct adjustment_info *adj_info)
 {
 	uint32_t i;
+
 	if (adj_api->range_table) {
 		for (i = 0; i < adj_api->range_table_size; i++) {
 			if (adj_api->range_table[i].adj_id == adj_id) {
@@ -201,6 +203,7 @@ static void parent_api_destruct(struct adjustment_parent_api **parent_api)
 struct adjustment_api *dal_adj_api_create(enum adjustment_category category)
 {
 	struct adjustment_api *adj_api;
+
 	adj_api = dal_alloc(sizeof(*adj_api));
 
 	if (!adj_api)
@@ -216,6 +219,7 @@ struct adjustment_api *dal_adj_api_create(enum adjustment_category category)
 struct adjustment_parent_api *dal_adj_parent_api_create()
 {
 	struct adjustment_parent_api *parent_api;
+
 	parent_api = dal_alloc(sizeof(*parent_api));
 	if (!parent_api)
 		return NULL;
diff --git a/drivers/gpu/drm/amd/dal/display_service/adjustment_container.c b/drivers/gpu/drm/amd/dal/display_service/adjustment_container.c
index 295957c..5384844 100644
--- a/drivers/gpu/drm/amd/dal/display_service/adjustment_container.c
+++ b/drivers/gpu/drm/amd/dal/display_service/adjustment_container.c
@@ -44,6 +44,7 @@ void dal_adj_container_update_display_cap(
 	struct cea861_support cea861_support = { 0 };
 	union cea_video_capability_data_block video_cap = { {0} };
 	struct dcs *dcs = dal_display_path_get_dcs(display_path);
+
 	dal_dcs_get_vendor_product_id_info(dcs, &vendor_info);
 	if (!((container->ctx.edid_signature.manufacturer_id ==
 		vendor_info.manufacturer_id) && (container->ctx.
@@ -86,6 +87,7 @@ struct adj_container *dal_adj_container_create()
 {
 
 	struct adj_container *container = dal_alloc(sizeof(*container));
+
 	if (!container) {
 		dal_free(container);
 		BREAK_TO_DEBUGGER();
@@ -159,6 +161,7 @@ static void copy_contents_from(
 	const struct adj_info_set *adj_info_set_src)
 {
 	uint32_t i;
+
 	for (i = 0; i < MAX_ADJUSTMENT_NUM; i++)
 		adj_info_set->adj_info_array[i] =
 			adj_info_set_src->adj_info_array[i];
@@ -312,7 +315,7 @@ bool dal_adj_info_set_get_adj_val(
 {
 	struct adjustment_info *info = dal_adj_info_set_get_adj_info(
 		adj_info_set, adj_id);
-	if(info && val) {
+	if (info && val) {
 		*val = info->adj_data.ranged.cur;
 		return true;
 	}
@@ -326,7 +329,7 @@ bool dal_adj_info_set_update_cur_value(
 {
 	struct adjustment_info *info = dal_adj_info_set_get_adj_info(
 		adj_info_set, adj_id);
-	if(info) {
+	if (info) {
 		info->adj_data.ranged.cur = val;
 		info->adj_state = ADJUSTMENT_STATE_REQUESTED;
 		return true;
diff --git a/drivers/gpu/drm/amd/dal/display_service/backlight_adj_group.c b/drivers/gpu/drm/amd/dal/display_service/backlight_adj_group.c
index 4f26923..bd3b210 100644
--- a/drivers/gpu/drm/amd/dal/display_service/backlight_adj_group.c
+++ b/drivers/gpu/drm/amd/dal/display_service/backlight_adj_group.c
@@ -84,6 +84,7 @@ bool dal_backlight_adj_group_include_backlight_opt_adj(
 	case DS_BACKLIGHT_OPTIMIZATION_DISABLE:
 	{
 		uint32_t backlight;
+
 		if (dal_backlight_adj_group_get_current_adj(
 				backlight_adj,
 				disp_path,
@@ -265,6 +266,7 @@ enum ds_return dal_backlight_adj_group_set_adjustment(
 	if (adj_info == NULL) {
 
 		struct adjustment_info default_adj_info;
+
 		if (dal_ds_dispatch_get_adjustment_info(
 				backlight_adj->ds,
 				display_index,
@@ -386,6 +388,7 @@ enum ds_return dal_backlight_adj_group_set_backlight_optimization_adj(
 	case DS_BACKLIGHT_OPTIMIZATION_DISABLE:
 	{
 		uint32_t backlight;
+
 		if (dal_backlight_adj_group_get_current_adj(
 				backlight_adj,
 				disp_path,
@@ -425,6 +428,7 @@ enum ds_return dal_backlight_adj_group_set_backlight_optimization_adj(
 	{
 		struct panel_backlight_boundaries boundaries = {0};
 		uint32_t backlight;
+
 		if (!dal_adapter_service_get_panel_backlight_boundaries(
 				backlight_adj->as,
 				&boundaries))
@@ -466,6 +470,7 @@ struct backlight_adj_group *dal_backlight_adj_group_create(
 		struct backlight_adj_group_init_data *init_data)
 {
 	struct backlight_adj_group *backlight_adj = NULL;
+
 	backlight_adj = dal_alloc(sizeof(*backlight_adj));
 
 	if (!backlight_adj)
diff --git a/drivers/gpu/drm/amd/dal/display_service/color_temperature.c b/drivers/gpu/drm/amd/dal/display_service/color_temperature.c
index 2827fac..247e858 100644
--- a/drivers/gpu/drm/amd/dal/display_service/color_temperature.c
+++ b/drivers/gpu/drm/amd/dal/display_service/color_temperature.c
@@ -29,98 +29,98 @@
 
 
 static const struct white_point_entry white_point_table[] = {
-/*001*/ { 1000 ,   6499,   3474  },
-/*002*/ { 1100 ,   6361,   3594  },
-/*003*/ { 1200 ,   6226,   3703  },
-/*004*/ { 1300 ,   6095,   3801  },
-/*005*/ { 1400 ,   5966,   3887  },
-/*006*/ { 1500 ,   5841,   3962  },
-/*007*/ { 1600 ,   5720,   4025  },
-/*008*/ { 1700 ,   5601,   4076  },
-/*009*/ { 1800 ,   5486,   4118  },
-/*010*/ { 1900 ,   5375,   4150  },
-/*011*/ { 2000 ,   5267,   4173  },
-/*012*/ { 2100 ,   5162,   4188  },
-/*013*/ { 2200 ,   5062,   4196  },
-/*014*/ { 2300 ,   4965,   4198  },
-/*015*/ { 2400 ,   4872,   4194  },
-/*016*/ { 2500 ,   4782,   4186  },
-/*017*/ { 2600 ,   4696,   4173  },
-/*018*/ { 2700 ,   4614,   4158  },
-/*019*/ { 2800 ,   4535,   4139  },
-/*020*/ { 2900 ,   4460,   4118  },
-/*021*/ { 3000 ,   4388,   4095  },
-/*022*/ { 3100 ,   4320,   4070  },
-/*023*/ { 3200 ,   4254,   4044  },
-/*024*/ { 3300 ,   4192,   4018  },
-/*025*/ { 3400 ,   4132,   3990  },
-/*026*/ { 3500 ,   4075,   3962  },
-/*027*/ { 3600 ,   4021,   3934  },
-/*028*/ { 3700 ,   3969,   3905  },
-/*029*/ { 3800 ,   3919,   3877  },
-/*030*/ { 3900 ,   3872,   3849  },
-/*031*/ { 4000 ,   3827,   3820  },
-/*032*/ { 4100 ,   3784,   3793  },
-/*033*/ { 4200 ,   3743,   3765  },
-/*034*/ { 4300 ,   3704,   3738  },
-/*035*/ { 4400 ,   3666,   3711  },
-/*036*/ { 4500 ,   3631,   3685  },
-/*037*/ { 4600 ,   3596,   3659  },
-/*038*/ { 4700 ,   3563,   3634  },
-/*039*/ { 4800 ,   3532,   3609  },
-/*040*/ { 4900 ,   3502,   3585  },
-/*041*/ { 5000 ,   3473,   3561  },
-/*042*/ { 5100 ,   3446,   3538  },
-/*043*/ { 5200 ,   3419,   3516  },
-/*044*/ { 5300 ,   3394,   3494  },
-/*045*/ { 5400 ,   3369,   3472  },
-/*046*/ { 5500 ,   3346,   3451  },
-/*047*/ { 5600 ,   3323,   3431  },
-/*048*/ { 5700 ,   3302,   3411  },
-/*049*/ { 5800 ,   3281,   3392  },
-/*050*/ { 5900 ,   3261,   3373  },
-/*051*/ { 6000 ,   3242,   3355  },
-/*052*/ { 6100 ,   3223,   3337  },
-/*053*/ { 6200 ,   3205,   3319  },
-/*054*/ { 6300 ,   3188,   3302  },
+/*001*/ { 1000,   6499,   3474  },
+/*002*/ { 1100,   6361,   3594  },
+/*003*/ { 1200,   6226,   3703  },
+/*004*/ { 1300,   6095,   3801  },
+/*005*/ { 1400,   5966,   3887  },
+/*006*/ { 1500,   5841,   3962  },
+/*007*/ { 1600,   5720,   4025  },
+/*008*/ { 1700,   5601,   4076  },
+/*009*/ { 1800,   5486,   4118  },
+/*010*/ { 1900,   5375,   4150  },
+/*011*/ { 2000,   5267,   4173  },
+/*012*/ { 2100,   5162,   4188  },
+/*013*/ { 2200,   5062,   4196  },
+/*014*/ { 2300,   4965,   4198  },
+/*015*/ { 2400,   4872,   4194  },
+/*016*/ { 2500,   4782,   4186  },
+/*017*/ { 2600,   4696,   4173  },
+/*018*/ { 2700,   4614,   4158  },
+/*019*/ { 2800,   4535,   4139  },
+/*020*/ { 2900,   4460,   4118  },
+/*021*/ { 3000,   4388,   4095  },
+/*022*/ { 3100,   4320,   4070  },
+/*023*/ { 3200,   4254,   4044  },
+/*024*/ { 3300,   4192,   4018  },
+/*025*/ { 3400,   4132,   3990  },
+/*026*/ { 3500,   4075,   3962  },
+/*027*/ { 3600,   4021,   3934  },
+/*028*/ { 3700,   3969,   3905  },
+/*029*/ { 3800,   3919,   3877  },
+/*030*/ { 3900,   3872,   3849  },
+/*031*/ { 4000,   3827,   3820  },
+/*032*/ { 4100,   3784,   3793  },
+/*033*/ { 4200,   3743,   3765  },
+/*034*/ { 4300,   3704,   3738  },
+/*035*/ { 4400,   3666,   3711  },
+/*036*/ { 4500,   3631,   3685  },
+/*037*/ { 4600,   3596,   3659  },
+/*038*/ { 4700,   3563,   3634  },
+/*039*/ { 4800,   3532,   3609  },
+/*040*/ { 4900,   3502,   3585  },
+/*041*/ { 5000,   3473,   3561  },
+/*042*/ { 5100,   3446,   3538  },
+/*043*/ { 5200,   3419,   3516  },
+/*044*/ { 5300,   3394,   3494  },
+/*045*/ { 5400,   3369,   3472  },
+/*046*/ { 5500,   3346,   3451  },
+/*047*/ { 5600,   3323,   3431  },
+/*048*/ { 5700,   3302,   3411  },
+/*049*/ { 5800,   3281,   3392  },
+/*050*/ { 5900,   3261,   3373  },
+/*051*/ { 6000,   3242,   3355  },
+/*052*/ { 6100,   3223,   3337  },
+/*053*/ { 6200,   3205,   3319  },
+/*054*/ { 6300,   3188,   3302  },
 
-/*055*/ { 6400 ,   3161,   3296  },
-/*056*/ { 6500 ,   3127,   3290  },
-/*057*/ { 6600 ,   3126,   3264  },
-/*058*/ { 6700 ,   3125,   3238  },
-/*059*/ { 6800 ,   3110,   3224  },
-/*060*/ { 6900 ,   3097,   3209  },
-/*061*/ { 7000 ,   3083,   3195  },
-/*062*/ { 7100 ,   3070,   3181  },
-/*063*/ { 7200 ,   3058,   3168  },
-/*064*/ { 7300 ,   3045,   3154  },
-/*065*/ { 7400 ,   3034,   3142  },
-/*066*/ { 7500 ,   3022,   3129  },
-/*067*/ { 7600 ,   3011,   3117  },
-/*068*/ { 7700 ,   3000,   3105  },
-/*069*/ { 7800 ,   2990,   3094  },
-/*070*/ { 7900 ,   2980,   3082  },
-/*071*/ { 8000 ,   2970,   3071  },
-/*072*/ { 8100 ,   2961,   3061  },
-/*073*/ { 8200 ,   2952,   3050  },
-/*074*/ { 8300 ,   2943,   3040  },
-/*075*/ { 8400 ,   2934,   3030  },
-/*076*/ { 8500 ,   2926,   3020  },
-/*077*/ { 8600 ,   2917,   3011  },
-/*078*/ { 8700 ,   2910,   3001  },
-/*079*/ { 8800 ,   2902,   2992  },
-/*080*/ { 8900 ,   2894,   2983  },
-/*081*/ { 9000 ,   2887,   2975  },
-/*082*/ { 9100 ,   2880,   2966  },
-/*083*/ { 9200 ,   2873,   2958  },
-/*084*/ { 9300 ,   2866,   2950  },
-/*085*/ { 9400 ,   2860,   2942  },
-/*086*/ { 9500 ,   2853,   2934  },
-/*087*/ { 9600 ,   2847,   2927  },
-/*088*/ { 9700 ,   2841,   2919  },
-/*089*/ { 9800 ,   2835,   2912  },
-/*090*/ { 9900 ,   2829,   2905  },
-/*091*/ { 10000 ,  2824,   2898  },
+/*055*/ { 6400,   3161,   3296  },
+/*056*/ { 6500,   3127,   3290  },
+/*057*/ { 6600,   3126,   3264  },
+/*058*/ { 6700,   3125,   3238  },
+/*059*/ { 6800,   3110,   3224  },
+/*060*/ { 6900,   3097,   3209  },
+/*061*/ { 7000,   3083,   3195  },
+/*062*/ { 7100,   3070,   3181  },
+/*063*/ { 7200,   3058,   3168  },
+/*064*/ { 7300,   3045,   3154  },
+/*065*/ { 7400,   3034,   3142  },
+/*066*/ { 7500,   3022,   3129  },
+/*067*/ { 7600,   3011,   3117  },
+/*068*/ { 7700,   3000,   3105  },
+/*069*/ { 7800,   2990,   3094  },
+/*070*/ { 7900,   2980,   3082  },
+/*071*/ { 8000,   2970,   3071  },
+/*072*/ { 8100,   2961,   3061  },
+/*073*/ { 8200,   2952,   3050  },
+/*074*/ { 8300,   2943,   3040  },
+/*075*/ { 8400,   2934,   3030  },
+/*076*/ { 8500,   2926,   3020  },
+/*077*/ { 8600,   2917,   3011  },
+/*078*/ { 8700,   2910,   3001  },
+/*079*/ { 8800,   2902,   2992  },
+/*080*/ { 8900,   2894,   2983  },
+/*081*/ { 9000,   2887,   2975  },
+/*082*/ { 9100,   2880,   2966  },
+/*083*/ { 9200,   2873,   2958  },
+/*084*/ { 9300,   2866,   2950  },
+/*085*/ { 9400,   2860,   2942  },
+/*086*/ { 9500,   2853,   2934  },
+/*087*/ { 9600,   2847,   2927  },
+/*088*/ { 9700,   2841,   2919  },
+/*089*/ { 9800,   2835,   2912  },
+/*090*/ { 9900,   2829,   2905  },
+/*091*/ { 10000,  2824,   2898  },
 };
 
 bool dal_color_temperature_find_white_point(
@@ -151,7 +151,7 @@ bool dal_color_temperature_search_white_point_table(
 	const struct white_point_entry *p;
 	uint32_t const_size;
 
-	const_size = sizeof(white_point_table) / sizeof(white_point_table[0]);
+	const_size = ARRAY_SIZE(white_point_table);
 
 	for (p = white_point_table; p < &white_point_table[const_size]; p++) {
 		if (p->temperature == temp_to_find) {
@@ -174,7 +174,7 @@ bool dal_color_temperature_find_color_temperature(
 	const struct white_point_entry *foundx = NULL;
 	uint32_t const_size;
 
-	const_size = sizeof(white_point_table) / sizeof(white_point_table[0]);
+	const_size = ARRAY_SIZE(white_point_table);
 
 	for (p = white_point_table; p < &white_point_table[const_size]; p++) {
 		if (p->dx == data->white_x && p->dy == data->white_y) {
diff --git a/drivers/gpu/drm/amd/dal/display_service/display_service.c b/drivers/gpu/drm/amd/dal/display_service/display_service.c
index 92a28225..45a69ff 100644
--- a/drivers/gpu/drm/amd/dal/display_service/display_service.c
+++ b/drivers/gpu/drm/amd/dal/display_service/display_service.c
@@ -55,6 +55,7 @@ static bool ds_construct(
 struct display_service *dal_display_service_create(struct ds_init_data *data)
 {
 	struct display_service *ds;
+
 	ds = dal_alloc(sizeof(struct display_service));
 
 	if (ds == NULL)
@@ -408,6 +409,7 @@ enum ds_return dal_display_service_mem_request_control(
 		struct display_path *display_path;
 		enum signal_type signal;
 		struct hw_path_mode mode;
+
 		if (!dal_ds_dispatch_build_hw_path_mode_for_adjustment(
 				ds->ds_dispatch, &mode, display_index, NULL))
 			return DS_ERROR;
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c b/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c
index a1357dc..cb20a9d 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_calculation.c
@@ -223,6 +223,7 @@ void dal_ds_calculation_setup_ranged_timing(
 	 * detection and prepare ranged timing. */
 	if (drr_supported || psr_supported || vce_supported) {
 		struct static_screen_events ss_events;
+
 		rt->control.program_static_screen_mask = true;
 
 		/* Initialize to the VTOTAL value. This means refresh rate will
@@ -234,8 +235,8 @@ void dal_ds_calculation_setup_ranged_timing(
 		 * if possible, even if not for static screen purpose. It could
 		 * still be used for 48 Hz feature. */
 		if (drr_config.min_fps_in_microhz != 0) {
-			timing->ranged_timing.control. \
-			program_dynamic_refresh_rate = true;
+			timing->ranged_timing.control.program_dynamic_refresh_rate
+					= true;
 
 			/* If DRR is supported, update DRR parameters with min
 			 * and max VTOTAL values to define the refresh rate
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c
index 5a7df82..f5a6430 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_adjustment.c
@@ -46,7 +46,7 @@
 #include "path_mode_set_with_data.h"
 
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL( \
-	LOG_MINOR_COMPONENT_DISPLAY_SERVICE, "Display Service:%s\n", __func__);
+	LOG_MINOR_COMPONENT_DISPLAY_SERVICE, "Display Service:%s\n", __func__)
 
 /* NOTE make sure to update CURRENT_ADJUSTMENT_NUM when updating this array */
 static const struct adj_global_info adj_global_info_array[CURRENT_ADJUSTMENT_NUM] = {
@@ -79,6 +79,7 @@ static enum ds_return get_adj_type(
 	enum adjustment_data_type *type)
 {
 	uint32_t i = 0;
+
 	if (adj_id < ADJ_ID_BEGIN || ADJ_ID_END < adj_id)
 		return DS_ERROR;
 	for (i = 0; i < CURRENT_ADJUSTMENT_NUM; i++) {
@@ -101,6 +102,7 @@ static enum ds_return get_adj_info_from_defaults(
 	enum signal_type signal;
 	union cea_video_capability_data_block video_cap = { {0} };
 	struct dcs *dcs = dal_display_path_get_dcs(path);
+
 	dal_dcs_get_cea_video_capability_data_block(dcs, &video_cap);
 	signal = dal_display_path_get_query_signal(path, SINK_LINK_INDEX);
 
@@ -287,6 +289,7 @@ static enum ds_return get_adj_property(
 {
 	enum ds_return result = DS_ERROR;
 	uint32_t i = 0;
+
 	if (disp_index >= dal_tm_get_num_display_paths(ds->tm, false))
 		return DS_ERROR;
 	for (i = 0; i < CURRENT_ADJUSTMENT_NUM; i++) {
@@ -441,6 +444,7 @@ void dal_ds_dispatch_update_adj_container_for_path_with_edid(
 {
 	uint32_t index = dal_display_path_get_display_index(path);
 	struct adj_container *container;
+
 	if (!path)
 		dal_logger_write(ds->dal_context->logger,
 			LOG_MAJOR_ERROR,
@@ -461,6 +465,7 @@ void dal_ds_dispatch_update_adj_container_for_path_with_mode_info(
 {
 	uint32_t index = dal_display_path_get_display_index(display_path);
 	struct adj_container *container;
+
 	if (!display_path)
 		dal_logger_write(ds->dal_context->logger,
 			LOG_MAJOR_ERROR,
@@ -624,6 +629,7 @@ void dal_ds_dispatch_cleanup_adjustment(struct ds_dispatch *ds)
 {
 	uint32_t i;
 	uint32_t num;
+
 	num = ds->disp_path_num;
 
 	for (i = 0; i < num; i++)
@@ -668,6 +674,7 @@ bool dal_ds_dispatch_apply_scaling(
 	struct ds_adjustment_scaler scaler;
 	const struct adjustment_info *info;
 	struct adj_container *set;
+
 	if (!hw_path_mode || !container)
 		return false;
 	info = dal_adj_info_set_get_adj_info(&container->adj_info_set, adj_id);
@@ -1001,6 +1008,7 @@ static void build_adj_container_for_path(
 
 	struct adjustment_info info;
 	struct adj_container *container = NULL;
+
 	dal_memset(&info, 0, sizeof(struct adjustment_info));
 	index = dal_display_path_get_display_index(display_path);
 	if (!display_path)
@@ -1022,6 +1030,7 @@ static void build_adj_container_for_path(
 
 	for (i = ADJ_ID_BEGIN; i < ADJ_ID_END; i++) {
 		enum adjustment_id adj_id = i;
+
 		if (is_adjustment_supported(ds, display_path, adj_id)) {
 			if (DS_SUCCESS != get_adj_info_from_defaults(
 				ds,
diff --git a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
index 612067e..f61fcf4 100644
--- a/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
+++ b/drivers/gpu/drm/amd/dal/display_service/ds_dispatch_mode_setting.c
@@ -1437,6 +1437,7 @@ bool dal_ds_dispatch_build_hw_path_set(
 	if (!result) {
 		uint32_t j;
 		struct hw_path_mode *mode;
+
 		for (j = 0; j < i; j++) {
 			mode = dal_hw_path_mode_set_get_path_by_index(
 				hw_mode_set, j);
@@ -1972,6 +1973,7 @@ static void tune_up_timing(
 	struct hw_path_mode *hw_mode)
 {
 	struct timing_limits timing_limits;
+
 	if (dal_dcs_get_timing_limits(dal_display_path_get_dcs(display_path),
 			&timing_limits)) {
 		struct pixel_clock_safe_range pixel_clock_safe_range;
@@ -2561,6 +2563,7 @@ static void send_wireless_setmode_end_event(
 {
 	uint32_t i;
 	uint32_t path_mode_num = dal_pms_get_path_mode_num(path_mode_set);
+
 	for (i = 0; i < path_mode_num; i++) {
 		const struct path_mode *path_mode_in =
 				dal_pms_get_path_mode_at_index(
diff --git a/drivers/gpu/drm/amd/dal/display_service/gamut_space.c b/drivers/gpu/drm/amd/dal/display_service/gamut_space.c
index 7eaa317..0797d06 100644
--- a/drivers/gpu/drm/amd/dal/display_service/gamut_space.c
+++ b/drivers/gpu/drm/amd/dal/display_service/gamut_space.c
@@ -136,7 +136,6 @@ static void set_regamma_support(
 
 		}
 	}
-	return;
 }
 
 
@@ -200,7 +199,7 @@ bool dal_gamut_space_find_predefined_gamut(
 	uint32_t const_size;
 	uint32_t i;
 
-	const_size = sizeof(gamut_array) / sizeof(gamut_array[0]);
+	const_size = ARRAY_SIZE(gamut_array);
 
 	for (p = gamut_array ; p < &gamut_array[const_size]; p++) {
 		if (p->index == predefine.u32all) {
@@ -256,7 +255,7 @@ bool dal_gamut_space_find_regamma_coefficients(
 		coeff->gamma[0] != coeff->gamma[2])
 		return false;
 
-	const_size = sizeof(gamut_array) / sizeof(gamut_array[0]);
+	const_size = ARRAY_SIZE(gamut_array);
 
 	for (p = gamut_array; p < &gamut_array[const_size]; p++) {
 		if (p->a0 == coeff->coeff_a0[0] &&
@@ -281,7 +280,7 @@ bool dal_gamut_space_find_color_coordinates(
 	const struct gamut_space_entry *p;
 	uint32_t const_size;
 
-	const_size = sizeof(gamut_array) / sizeof(gamut_array[0]);
+	const_size = ARRAY_SIZE(gamut_array);
 	for (p = gamut_array; p < &gamut_array[const_size]; p++) {
 		if (p->red_x == csc->red_x &&
 			p->red_y == csc->red_y &&
@@ -363,6 +362,7 @@ bool dal_gamut_space_build_gamut_space_matrix(
 {
 	struct gamut_matrixs matrix;
 	bool ret = false;
+
 	matrix.rgb_coeff_dst = NULL;
 
 	if (gamut->source == GAMUT_SPACE_SOURCE_DEFAULT) {
@@ -521,24 +521,23 @@ bool dal_gamut_space_build_gamut_matrix(
 		csc.blue_x = data->gamut.custom.blue_x;
 		csc.blue_y = data->gamut.custom.blue_y;
 	} else {
-		dal_memset(&coeff, 0 , sizeof(coeff));
+		dal_memset(&coeff, 0, sizeof(coeff));
 		if (!dal_gamut_space_find_predefined_gamut(
 				data->gamut.predefined,
 				&csc,
 				&coeff))
 			return false;
-		else {
-			if (custom_regamma->flags.bits.GAMMA_RAMP_ARRAY
-					== 0) {
-				regamma->coeff = coeff;
-				dal_gamut_space_is_equal_gamma_coefficients(
-						&coeff,
-						&custom_regamma->coeff,
-						flags);
-				regamma->flags.bits.GAMMA_FROM_USER = 1;
-				regamma->flags.bits.GAMMA_FROM_EDID = 0;
-				regamma->flags.bits.GAMMA_FROM_EDID_EX = 0;
-			}
+
+		if (custom_regamma->flags.bits.GAMMA_RAMP_ARRAY
+				== 0) {
+			regamma->coeff = coeff;
+			dal_gamut_space_is_equal_gamma_coefficients(
+					&coeff,
+					&custom_regamma->coeff,
+					flags);
+			regamma->flags.bits.GAMMA_FROM_USER = 1;
+			regamma->flags.bits.GAMMA_FROM_EDID = 0;
+			regamma->flags.bits.GAMMA_FROM_EDID_EX = 0;
 		}
 	}
 	if (data->option.bits.CUSTOM_WHITE_POINT == 1) {
@@ -976,7 +975,7 @@ void dal_gamut_space_transpose_matrix(
 	uint32_t cols,
 	struct fixed31_32 *transposed)
 {
-	uint32_t i , j;
+	uint32_t i, j;
 
 	for (i = 0 ; i < rows ;  i++) {
 		for (j = 0 ; j < cols ; j++)
@@ -990,22 +989,22 @@ bool dal_gamut_space_setup_white_point(
 	struct gamut_data *gamut,
 	struct ds_white_point_coordinates *data)
 {
+	struct color_space_coodinates csc;
+
 	if (gamut->option.bits.CUSTOM_WHITE_POINT == 1) {
 		data->white_x = gamut->white_point.custom.white_x;
 		data->white_y = gamut->white_point.custom.white_y;
 		return true;
-	} else {
-		{
-			struct color_space_coodinates csc;
-			if (dal_gamut_space_find_predefined_white_point(
-					gamut->white_point.predefined,
-					&csc)) {
-				data->white_x = csc.white_x;
-				data->white_y = csc.white_y;
-				return true;
-			}
-		}
 	}
+
+	if (dal_gamut_space_find_predefined_white_point(
+			gamut->white_point.predefined,
+			&csc)) {
+		data->white_x = csc.white_x;
+		data->white_y = csc.white_y;
+		return true;
+	}
+
 	return false;
 }
 
@@ -1017,7 +1016,7 @@ bool dal_gamut_space_find_predefined_white_point(
 	const struct white_point_coodinates_entry *p;
 	uint32_t const_size;
 
-	const_size = sizeof(white_point_array) / sizeof(white_point_array[0]);
+	const_size = ARRAY_SIZE(white_point_array);
 	for (p = white_point_array;
 			p < &white_point_array[const_size]; p++) {
 		if (p->index == predefined.u32all) {
diff --git a/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c b/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c
index 7e39bcb..575f993 100644
--- a/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c
+++ b/drivers/gpu/drm/amd/dal/display_service/grph_colors_group.c
@@ -392,12 +392,14 @@ bool dal_grph_colors_group_compute_hw_adj_color_control(
 				&gamut->gamut_src);
 		{
 			struct adjustment_info *non_const_temp = temperature;
+
 			non_const_temp->adj_data.ranged.cur =
 					requested_temperature;
 		}
 	}
 	{
 		union update_color_flags flags = {0};
+
 		if (!dal_gamut_space_update_gamut(
 					gamut, false, &flags))
 				return false;
@@ -583,6 +585,7 @@ enum ds_color_space dal_grph_colors_group_build_default_color_space(
 	case SIGNAL_TYPE_HDMI_TYPE_A:
 	{
 		uint32_t pix_clk_khz;
+
 		color_space = hdmi_request_color_space;
 		if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR422 &&
 			timing->pixel_encoding == PIXEL_ENCODING_YCBCR444) {
@@ -826,6 +829,7 @@ enum ds_return dal_grph_colors_group_set_color_graphics_gamut(
 	if (apply_to_hw) {
 		enum hwss_result result;
 		enum ds_color_space color_space;
+
 		color_control = dal_alloc(sizeof(*color_control));
 		if (!color_control)
 			return DS_ERROR;
@@ -861,6 +865,7 @@ enum ds_return dal_grph_colors_group_set_color_graphics_gamut(
 		if (result == HWSS_RESULT_OK) {
 			if (grph_colors_adj->regamma_updated) {
 				enum ds_return ret;
+
 				if (!dal_adj_container_get_regamma_copy(
 						adj_container,
 						old_regamma))
@@ -1256,6 +1261,7 @@ enum ds_return dal_grph_colors_group_update_gamut(
 	dal_memmove(&gamut->regamma, const_regamma, sizeof(gamut->regamma));
 	{
 		union update_color_flags flags = {0};
+
 		if (!dal_gamut_space_update_gamut(
 				gamut, false, &flags))
 			goto gamut_fail;
diff --git a/drivers/gpu/drm/amd/dal/display_service/path_mode_set.c b/drivers/gpu/drm/amd/dal/display_service/path_mode_set.c
index 6700f78..432bebf 100644
--- a/drivers/gpu/drm/amd/dal/display_service/path_mode_set.c
+++ b/drivers/gpu/drm/amd/dal/display_service/path_mode_set.c
@@ -33,6 +33,7 @@
 struct path_mode_set *dal_pms_create()
 {
 	struct path_mode_set *set;
+
 	set = dal_alloc(sizeof(struct path_mode_set));
 
 	if (set == NULL)
@@ -74,6 +75,7 @@ struct path_mode_set *dal_pms_copy(const struct path_mode_set *copy)
 
 	if (dal_pms_construct(set)) {
 		uint32_t i = 0;
+
 		set->count = copy->count;
 		set->control_flags.all = copy->control_flags.all;
 
@@ -148,6 +150,7 @@ const struct path_mode *dal_pms_get_path_mode_for_display_index(
 		uint32_t index)
 {
 	uint32_t i;
+
 	for (i = 0; i < set->count; i++) {
 		if (set->path_mode_set[i].display_path_index == index)
 			return &set->path_mode_set[i];
@@ -191,6 +194,7 @@ bool dal_pms_remove_path_mode_at_index(
 {
 	if (index < set->count) {
 		uint32_t i = 0;
+
 		for (i = index; i < set->count; i++)
 			set->path_mode_set[i] = set->path_mode_set[i + 1];
 		set->count--;
diff --git a/drivers/gpu/drm/amd/dal/display_service/path_mode_set_with_data.c b/drivers/gpu/drm/amd/dal/display_service/path_mode_set_with_data.c
index fcd2e93..65181de 100644
--- a/drivers/gpu/drm/amd/dal/display_service/path_mode_set_with_data.c
+++ b/drivers/gpu/drm/amd/dal/display_service/path_mode_set_with_data.c
@@ -147,6 +147,7 @@ struct active_path_data *dal_pms_with_data_get_path_data_for_display_index(
 		uint32_t index)
 {
 	uint32_t i;
+
 	for (i = 0; i < set->base.count; i++) {
 		if (set->base.path_mode_set[i].display_path_index == index)
 			return &set->path_data[i];
@@ -212,7 +213,9 @@ bool dal_pms_with_data_remove_path_mode_for_display_index(
 
 	for (i = 0; i < set_with_data->base.count; i++) {
 		if (set_with_data->base.path_mode_set[i].display_path_index == index)
-			return dal_pms_with_data_remove_path_mode_at_index(set_with_data, i);
+			return dal_pms_with_data_remove_path_mode_at_index(
+					set_with_data,
+					i);
 	}
 
 	return false;
@@ -230,6 +233,7 @@ static bool get_path_mode_index(
 	uint32_t *index)
 {
 	uint32_t i;
+
 	for (i = 0; i < set->base.count; ++i) {
 		if (set->base.path_mode_set[i].display_path_index ==
 			display_index) {
@@ -288,6 +292,7 @@ void dal_pms_with_data_clear_plane_configs(
 static void destruct(struct path_mode_set_with_data *set)
 {
 	uint32_t i;
+
 	for (i = 0; i < dal_pms_get_path_mode_num(&set->base); ++i)
 		dal_vector_destruct(&set->plane_configs[i]);
 }
diff --git a/drivers/gpu/drm/amd/dal/display_service/scaler_adj_group.c b/drivers/gpu/drm/amd/dal/display_service/scaler_adj_group.c
index 3132603..0da3761 100644
--- a/drivers/gpu/drm/amd/dal/display_service/scaler_adj_group.c
+++ b/drivers/gpu/drm/amd/dal/display_service/scaler_adj_group.c
@@ -53,6 +53,7 @@ static bool can_scaling_be_applied(
 {
 	struct adjustment_info *info = NULL;
 	enum signal_type type;
+
 	if (!container)
 		return false;
 
@@ -85,39 +86,40 @@ static bool is_pass_thru_enabled(
 	enum build_path_set_reason reason)
 {
 	const struct adjustment_info *info;
+	enum underscan_reason reason_for_underscan;
+
 	if (scaler_param->adjust_id == ADJ_ID_MULTIMEDIA_PASS_THROUGH &&
 		scaler_param->value > 0)
 		return true;
-	else {
-		enum underscan_reason reason_for_underscan;
-		switch (reason) {
-		case BUILD_PATH_SET_REASON_FALLBACK_UNDERSCAN:
-			reason_for_underscan = UNDERSCAN_REASON_FALL_BACK;
-			break;
-		case BUILD_PATH_SET_REASON_SET_MODE:
-			reason_for_underscan = UNDERSCAN_REASON_PATCH_TIMING;
-			break;
-		case BUILD_PATH_SET_REASON_SET_ADJUSTMENT:
-		default:
-			reason_for_underscan = UNDERSCAN_REASON_SET_ADJUSTMENT;
-			break;
-		}
 
-		if (can_scaling_be_applied(
-			container,
-			scaler_param->timing_standard,
-			scaler_param->timing_source,
-			scaler_param->adjust_id,
-			reason_for_underscan)) {
-			info = dal_adj_info_set_get_adj_info(
-				&container->adj_info_set,
-				ADJ_ID_MULTIMEDIA_PASS_THROUGH);
-			if (!info)
-				return false;
-			if (info->adj_data.ranged.cur > 0)
-				return true;
-			}
+	switch (reason) {
+	case BUILD_PATH_SET_REASON_FALLBACK_UNDERSCAN:
+		reason_for_underscan = UNDERSCAN_REASON_FALL_BACK;
+		break;
+	case BUILD_PATH_SET_REASON_SET_MODE:
+		reason_for_underscan = UNDERSCAN_REASON_PATCH_TIMING;
+		break;
+	case BUILD_PATH_SET_REASON_SET_ADJUSTMENT:
+	default:
+		reason_for_underscan = UNDERSCAN_REASON_SET_ADJUSTMENT;
+		break;
 	}
+
+	if (can_scaling_be_applied(
+		container,
+		scaler_param->timing_standard,
+		scaler_param->timing_source,
+		scaler_param->adjust_id,
+		reason_for_underscan)) {
+		info = dal_adj_info_set_get_adj_info(
+			&container->adj_info_set,
+			ADJ_ID_MULTIMEDIA_PASS_THROUGH);
+		if (!info)
+			return false;
+		if (info->adj_data.ranged.cur > 0)
+			return true;
+	}
+
 	return false;
 }
 
@@ -130,6 +132,7 @@ static bool build_base_avi_info_frame_parameter(
 	enum hw_scale_options *underscan_avi_rule)
 {
 	struct cea861_support cea861_support = {0};
+
 	if (hw_path_mode->mode.ds_info.cea_vic != 0)
 		if (is_pass_thru_enabled(
 			scaler_param, underscan_param, container, reason))
@@ -157,6 +160,7 @@ static bool build_avi_info_frame_parameter(
 {
 	union cea_video_capability_data_block vcdb = { {0} };
 	bool result = false;
+
 	if (dal_adj_container_get_cea_video_cap_data_block(container, &vcdb)) {
 		if (hw_path_mode->mode.ds_info.DISPLAY_PREFERED_MODE == 1 &&
 			(vcdb.bits.S_PT0 != 0 || vcdb.bits.S_PT1 != 0)) {
@@ -476,6 +480,7 @@ bool dal_scaler_adj_group_build_scaler_parameter(
 {
 	struct dcs *dcs = dal_display_path_get_dcs(display_path);
 	struct dcs_stereo_3d_features feature;
+
 	if (!display_path || !path_mode || !dcs)
 		return false;
 	dal_memset(param, 0, sizeof(*param));
@@ -518,6 +523,7 @@ static bool build_underscan_bundle(
 {
 	struct adjustment_info *mm_pass_thur;
 	struct adjustment_info *underscan;
+
 	dal_memset(group, 0, sizeof(*group));
 	group->id_overscan = ADJ_ID_OVERSCAN;
 	group->id_underscan = ADJ_ID_UNDERSCAN;
@@ -563,6 +569,7 @@ static bool build_underscan_parameters(
 	struct ds_overscan *overscan)
 {
 	struct underscan_adjustment_group group;
+
 	if (!build_underscan_bundle(
 		param,
 		container,
@@ -594,6 +601,7 @@ static struct hw_path_mode *find_hw_path_mode(
 	uint32_t num_of_path;
 	struct hw_path_mode *mode = NULL;
 	struct hw_path_mode *local_mode;
+
 	num_of_path = dal_hw_path_mode_set_get_paths_number(hw_pms);
 	for (i = 0; i < num_of_path; i++) {
 		local_mode = dal_hw_path_mode_set_get_path_by_index(hw_pms, i);
@@ -860,6 +868,7 @@ enum ds_return dal_scaler_adj_group_set_adjustment(
 	const struct path_mode *path_mode;
 	enum ds_return result = DS_ERROR;
 	const struct adjustment_info *adj_info;
+
 	pms_wd = dal_ds_dispatch_get_active_pms_with_data(ds);
 	if (NULL == pms_wd)
 		return DS_ERROR;
diff --git a/drivers/gpu/drm/amd/dal/display_service/set_mode_params.c b/drivers/gpu/drm/amd/dal/display_service/set_mode_params.c
index c30f0d2..9ac5e16 100644
--- a/drivers/gpu/drm/amd/dal/display_service/set_mode_params.c
+++ b/drivers/gpu/drm/amd/dal/display_service/set_mode_params.c
@@ -225,6 +225,7 @@ bool dal_set_mode_params_update_tiling_mode_on_path(
 static void update_hw_path_mode_scaling_info(struct set_mode_params *smp)
 {
 	uint32_t i;
+
 	for (i = 0; i < smp->path_num; ++i) {
 		struct hw_path_mode *path_mode =
 			dal_hw_path_mode_set_get_path_by_index(
@@ -283,8 +284,8 @@ static void update_hw_path_mode_scaling_info(struct set_mode_params *smp)
 			dal_logger_write(smp->ctx->logger,
 				LOG_MAJOR_ERROR,
 				LOG_MINOR_COMPONENT_DISPLAY_SERVICE,
-				"%s: something is wrong here, why do we have"
-				" bogus parameters?", __func__);
+				"%s: something is wrong here, why do we have bogus parameters?",
+				__func__);
 			break;
 		}
 	}
@@ -420,6 +421,7 @@ static bool validate_path_mode(
 		uint32_t i;
 
 		struct link_validation_flags flags = { 0 };
+
 		flags.CANDIDATE_TIMING = guaranteed_validation;
 		flags.START_OF_VALIDATION =
 			smp->guaranteed_validation_count == 0;
@@ -581,6 +583,7 @@ bool dal_set_mode_params_report_ce_mode_only(struct set_mode_params *smp,
 				SINK_LINK_INDEX);
 		bool is_hdmi = signal == SIGNAL_TYPE_HDMI_TYPE_A;
 		bool enabled = false;
+
 		if (dal_dcs_get_fid9204_allow_ce_mode_only_option(
 			dcs,
 			is_hdmi,
@@ -597,6 +600,7 @@ bool dal_set_mode_params_init_with_topology(
 	uint32_t idx_num)
 {
 	struct hw_path_mode path_mode;
+
 	ASSERT(smp->display_path_set == NULL);
 	ASSERT(smp->hw_path_mode_set == NULL);
 
@@ -650,6 +654,7 @@ bool dal_set_mode_params_init_with_topology(
 
 	if (smp->hw_path_mode_set) {
 		uint32_t i;
+
 		for (i = 0; i < idx_num; i++) {
 			dal_memset(&path_mode, 0, sizeof(path_mode));
 
@@ -748,6 +753,7 @@ enum pixel_encoding dal_set_mode_params_get_default_pixel_format_preference(
 				SINK_LINK_INDEX);
 		bool is_hdmi = signal == SIGNAL_TYPE_HDMI_TYPE_A;
 		bool enabled = false;
+
 		if (dal_dcs_get_fid9204_allow_ce_mode_only_option(
 			dcs, is_hdmi, &enabled))
 			pf = PIXEL_ENCODING_RGB;
diff --git a/drivers/gpu/drm/amd/dal/display_service/single_adj_group.c b/drivers/gpu/drm/amd/dal/display_service/single_adj_group.c
index cd35ee6..fe6d7a1 100644
--- a/drivers/gpu/drm/amd/dal/display_service/single_adj_group.c
+++ b/drivers/gpu/drm/amd/dal/display_service/single_adj_group.c
@@ -327,6 +327,7 @@ bool dal_single_adj_group_setup_bit_depth_parameters(
 		{
 			union panel_misc_info panel_info;
 			struct dcs *dcs = dal_display_path_get_dcs(disp_path);
+
 			bit_depth->bits.TEMPORAL_LEVEL = 0;
 			if (dal_dcs_get_panel_misc_info(dcs, &panel_info)) {
 				if (panel_info.bits.GREY_LEVEL)
diff --git a/drivers/gpu/drm/amd/dal/encoder/dce110/digital_encoder_edp_dce110.c b/drivers/gpu/drm/amd/dal/encoder/dce110/digital_encoder_edp_dce110.c
index d0db702..72e182f 100644
--- a/drivers/gpu/drm/amd/dal/encoder/dce110/digital_encoder_edp_dce110.c
+++ b/drivers/gpu/drm/amd/dal/encoder/dce110/digital_encoder_edp_dce110.c
@@ -120,8 +120,8 @@ static enum encoder_result power_up(
 		dal_logger_write(enc->ctx->logger,
 			LOG_MAJOR_ERROR,
 			LOG_MINOR_COMPONENT_ENCODER,
-			"%s: Failed to execute VBIOS"
-			" command table!\n", __func__);
+			"%s: Failed to execute VBIOS command table!\n",
+			__func__);
 
 		return ENCODER_RESULT_ERROR;
 	}
diff --git a/drivers/gpu/drm/amd/dal/encoder/dce110/hw_ctx_digital_encoder_dce110.c b/drivers/gpu/drm/amd/dal/encoder/dce110/hw_ctx_digital_encoder_dce110.c
index a483cf4..228e072 100644
--- a/drivers/gpu/drm/amd/dal/encoder/dce110/hw_ctx_digital_encoder_dce110.c
+++ b/drivers/gpu/drm/amd/dal/encoder/dce110/hw_ctx_digital_encoder_dce110.c
@@ -63,7 +63,7 @@
 #endif
 
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_ENCODER,\
-		"ENC:%s\n", __func__);
+		"ENC:%s\n", __func__)
 
 enum hw_ctx_digital_encoder_dce110_constants {
 	/* Sending blank requires to wait until stream is disabled.
@@ -242,6 +242,7 @@ static void set_dvo_stream_attributes(
 	bool ddr_memory_rate)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 }
 
@@ -251,6 +252,7 @@ static bool setup_tmds_stereo_sync(
 	enum tmds_stereo_sync_select stereo_select)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 
 	return false;
@@ -262,6 +264,7 @@ static bool setup_stereo_sync(
 	enum sync_source source)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return false;
 }
@@ -272,6 +275,7 @@ static bool control_stereo_sync(
 	bool enable)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return false;
 }
@@ -285,6 +289,7 @@ static void hpd_initialize(
 	/* Associate HPD with DIG_BE */
 	const uint32_t addr = mmDIG_BE_CNTL + FROM_HAL(ctx)->be_engine_offset;
 	uint32_t value = dal_read_reg(ctx->base.dal_ctx, addr);
+
 	set_reg_field_value(value, hpd_source, DIG_BE_CNTL, DIG_HPD_SELECT);
 	dal_write_reg(ctx->base.dal_ctx, addr, value);
 }
@@ -627,6 +632,7 @@ static bool get_lane_settings(
 	struct link_training_settings *link_training_settings)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return true;
 }
@@ -636,6 +642,7 @@ static bool enable_dvo_sync_output(
 	enum sync_source source)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return false;
 }
@@ -644,6 +651,7 @@ static bool disable_dvo_sync_output(
 	struct hw_ctx_digital_encoder_hal *ctx)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return false;
 }
@@ -1164,6 +1172,7 @@ static void setup_hdmi(
 
 		/* TODO: New feature for DCE11, still need to implement */
 		struct dal_context *dal_context = ctx->base.dal_ctx;
+
 		NOT_IMPLEMENTED();
 
 		/* enable HDMI data scrambler */
@@ -1365,6 +1374,7 @@ static void backlight_control(
 	 * If yes, this function is not needed for android becuase LVDS is not
 	 * supported. If yes, need implemented.*/
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 }
 
@@ -1375,6 +1385,7 @@ static void enable_mvpu_downstream(
 	/*TODO android does not support mvpu, should remove functions
 	 * for upper layer  */
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 }
 
@@ -1383,6 +1394,7 @@ static void disable_mvpu_downstream(struct hw_ctx_digital_encoder_hal *ctx)
 	/*TODO android does not support mvpu, should remove functions
 	 * for upper layer  */
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 }
 
@@ -1393,6 +1405,7 @@ static void update_mst_stream_allocation_table(
 	bool is_removal)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 }
 
@@ -1402,6 +1415,7 @@ static void set_mst_bandwidth(
 	struct fixed31_32 avg_time_slots_per_mtp)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 }
 
@@ -1653,6 +1667,7 @@ static void set_dp_phy_pattern_symbol_error(
 	{
 		const uint32_t addr = mmDP_DPHY_PRBS_CNTL + addr_offset;
 		uint32_t value = dal_read_reg(ctx, addr);
+
 		set_reg_field_value(value, 1,
 				DP_DPHY_PRBS_CNTL, DPHY_PRBS_SEL);
 		set_reg_field_value(value, 1,
@@ -2032,6 +2047,7 @@ static enum clock_source_id get_active_clock_source(
 	enum transmitter transmitter)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return CLOCK_SOURCE_ID_UNDEFINED;
 }
@@ -2099,6 +2115,7 @@ static enum engine_id get_active_engine(
 	enum transmitter transmitter)
 {
 	struct dal_context *dal_context = ctx->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return ENGINE_ID_UNKNOWN;
 }
diff --git a/drivers/gpu/drm/amd/dal/encoder/digital_encoder.c b/drivers/gpu/drm/amd/dal/encoder/digital_encoder.c
index a6c8397..c498491 100644
--- a/drivers/gpu/drm/amd/dal/encoder/digital_encoder.c
+++ b/drivers/gpu/drm/amd/dal/encoder/digital_encoder.c
@@ -574,9 +574,8 @@ enum encoder_result dal_digital_encoder_setup_stereo(
 
 		/* Enable output side-band stereo-sync through GPIO */
 
-		if (!enc->stereo_gpio) {
+		if (!enc->stereo_gpio)
 			return ENCODER_RESULT_ERROR;
-		}
 
 		/* Open GPIO in HW mode */
 
@@ -872,6 +871,7 @@ void dal_digital_encoder_destruct(
 {
 	if (enc->hw_ctx) {
 		struct hw_ctx_digital_encoder *hw_ctx_base = &enc->hw_ctx->base;
+
 		enc->hw_ctx->base.funcs->destroy(&hw_ctx_base);
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/encoder/digital_encoder_dp.c b/drivers/gpu/drm/amd/dal/encoder/digital_encoder_dp.c
index 8786920..c5697dc 100644
--- a/drivers/gpu/drm/amd/dal/encoder/digital_encoder_dp.c
+++ b/drivers/gpu/drm/amd/dal/encoder/digital_encoder_dp.c
@@ -261,6 +261,7 @@ enum encoder_result dal_digital_encoder_dp_unblank(
 		 * m_vid / n_vid = pixel rate / link rate */
 
 		uint64_t m_vid_l = n_vid;
+
 		m_vid_l *= param->crtc_timing.pixel_clock;
 		m_vid_l = div_u64(m_vid_l, param->link_settings.link_rate *
 			LINK_RATE_REF_FREQ_IN_KHZ);
diff --git a/drivers/gpu/drm/amd/dal/encoder/encoder.c b/drivers/gpu/drm/amd/dal/encoder/encoder.c
index 3955d5f..85a82fb 100644
--- a/drivers/gpu/drm/amd/dal/encoder/encoder.c
+++ b/drivers/gpu/drm/amd/dal/encoder/encoder.c
@@ -68,6 +68,7 @@ const struct graphics_object_id dal_encoder_get_graphics_object_id(
 	const struct encoder *enc)
 {
 	struct graphics_object_id id = {0};
+
 	if (enc->impl)
 		return enc->impl->id;
 
@@ -427,9 +428,8 @@ enum encoder_result dal_encoder_power_up(
 	signal = dal_encoder_impl_convert_downstream_to_signal(
 		enc->impl->id, ctx->downstream);
 
-	if (create_impl(enc, signal, enc->impl->id) == CREATION_FAILED) {
+	if (create_impl(enc, signal, enc->impl->id) == CREATION_FAILED)
 		return ENCODER_RESULT_ERROR;
-	}
 
 	if (!enc->impl) {
 		BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/encoder/encoder_impl.c b/drivers/gpu/drm/amd/dal/encoder/encoder_impl.c
index 1bfd27b..4aa22dc 100644
--- a/drivers/gpu/drm/amd/dal/encoder/encoder_impl.c
+++ b/drivers/gpu/drm/amd/dal/encoder/encoder_impl.c
@@ -39,12 +39,6 @@
 
 #include "encoder_impl.h"
 
-/*
- * Post-requisites: headers required by this unit
- */
-
-#define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_ENCODER,\
-	"ENC:%s\n", __func__);
 
 /******************************************************************************
  * This unit
diff --git a/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c b/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c
index 3bc2ce76..4c7b43b 100644
--- a/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c
+++ b/drivers/gpu/drm/amd/dal/encoder/external_digital_encoder.c
@@ -196,6 +196,7 @@ void dal_external_digital_encoder_destruct(
 {
 	if (enc->hw_ctx) {
 		struct hw_ctx_digital_encoder *base = &enc->hw_ctx->base;
+
 		enc->hw_ctx->base.funcs->destroy(&base);
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/gpio/dce110/hw_hpd_dce110.c b/drivers/gpu/drm/amd/dal/gpio/dce110/hw_hpd_dce110.c
index 4cd969f..24d48a9 100644
--- a/drivers/gpu/drm/amd/dal/gpio/dce110/hw_hpd_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpio/dce110/hw_hpd_dce110.c
@@ -273,6 +273,7 @@ static enum gpio_result set_config(
 
 	{
 		uint32_t value;
+
 		value = dal_read_reg(
 			ptr->ctx,
 			pin->addr.DC_HPD_TOGGLE_FILT_CNTL);
diff --git a/drivers/gpu/drm/amd/dal/gpio/gpio_service.c b/drivers/gpu/drm/amd/dal/gpio/gpio_service.c
index e17614d..78b7677 100644
--- a/drivers/gpu/drm/amd/dal/gpio/gpio_service.c
+++ b/drivers/gpu/drm/amd/dal/gpio/gpio_service.c
@@ -435,15 +435,15 @@ enum gpio_result dal_gpio_service_open(
 		return GPIO_RESULT_NON_SPECIFIC_ERROR;
 	}
 
-	if (pin->funcs->open(pin, mode, options)) {
-		set_pin_busy(service, id, en);
-		*ptr = pin;
-		return GPIO_RESULT_OK;
-	} else {
+	if (!pin->funcs->open(pin, mode, options)) {
 		ASSERT_CRITICAL(false);
 		dal_gpio_service_close(service, &pin);
 		return GPIO_RESULT_OPEN_FAILED;
 	}
+
+	set_pin_busy(service, id, en);
+	*ptr = pin;
+	return GPIO_RESULT_OK;
 }
 
 void dal_gpio_service_close(
diff --git a/drivers/gpu/drm/amd/dal/gpio/hw_factory.h b/drivers/gpu/drm/amd/dal/gpio/hw_factory.h
index 56c728d..b84b4a5 100644
--- a/drivers/gpu/drm/amd/dal/gpio/hw_factory.h
+++ b/drivers/gpu/drm/amd/dal/gpio/hw_factory.h
@@ -30,6 +30,7 @@ struct hw_gpio_pin;
 
 struct hw_factory {
 	uint32_t number_of_pins[GPIO_ID_COUNT];
+
 	const struct hw_factory_funcs {
 		struct hw_gpio_pin *(*create_dvo)(
 			struct dal_context *ctx,
diff --git a/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c b/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c
index 97f8705..5511632 100644
--- a/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c
+++ b/drivers/gpu/drm/amd/dal/gpu/bandwidth_manager.c
@@ -328,6 +328,7 @@ uint32_t dal_bandwidth_manager_get_available_mclk_switch_time(
 uint32_t dal_bandwidth_manager_controller_id_to_index(enum controller_id id)
 {
 	uint32_t index = 0;
+
 	switch (id) {
 	case CONTROLLER_ID_D0:
 	case CONTROLLER_ID_UNDERLAY0:
diff --git a/drivers/gpu/drm/amd/dal/gpu/calc_pll_clock_source.c b/drivers/gpu/drm/amd/dal/gpu/calc_pll_clock_source.c
index 54d76a0..bcbdac9 100644
--- a/drivers/gpu/drm/amd/dal/gpu/calc_pll_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/gpu/calc_pll_clock_source.c
@@ -321,6 +321,7 @@ static bool calc_pll_clock_source_max_vco_construct(
 
 	uint32_t i;
 	struct firmware_info fw_info = {};
+
 	if (calc_pll_cs == NULL ||
 			init_data == NULL ||
 			init_data->bp == NULL)
diff --git a/drivers/gpu/drm/amd/dal/gpu/clock_source.c b/drivers/gpu/drm/amd/dal/gpu/clock_source.c
index c3908d7..be01379 100644
--- a/drivers/gpu/drm/amd/dal/gpu/clock_source.c
+++ b/drivers/gpu/drm/amd/dal/gpu/clock_source.c
@@ -182,6 +182,7 @@ bool dal_clock_source_adjust_pxl_clk_by_pxl_amount(
 	uint32_t cur_pix_rate_hz;
 	uint32_t reqested_pix_rate_hz;
 	bool success = false;
+
 	if (pix_clk_params == NULL)
 			return false;
 
@@ -190,8 +191,7 @@ bool dal_clock_source_adjust_pxl_clk_by_pxl_amount(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[start]: Current(Raw): %u,%03u,%03uHz, "
-		"Requested(Raw): %u,%03u,%03uHz\n",
+		"%s[start]: Current(Raw): %u,%03u,%03uHz, Requested(Raw): %u,%03u,%03uHz\n",
 		__func__,
 		(cur_pix_rate_hz / 1000000),
 		(cur_pix_rate_hz / 1000) % 1000,
@@ -215,8 +215,7 @@ bool dal_clock_source_adjust_pxl_clk_by_pxl_amount(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[end]: Current(Raw): %u,%03u,%03uHz, "
-		"Requested(Raw): %u,%03u,%03uHz\n\n",
+		"%s[end]: Current(Raw): %u,%03u,%03uHz, Requested(Raw): %u,%03u,%03uHz\n\n",
 		__func__,
 		(cur_pix_rate_hz / 1000000),
 		(cur_pix_rate_hz / 1000) % 1000,
@@ -441,8 +440,8 @@ bool dal_clock_source_adjust_pxl_clk_by_ref_pixel_rate(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[start]: Current: %u,%03u,%03uHz, "
-		"Requested: %u,%03u,%03uHz\n", __func__,
+		"%s[start]: Current: %u,%03u,%03uHz, Requested: %u,%03u,%03uHz\n",
+		__func__,
 		(current_pix_rate_hz / 1000000),
 		(current_pix_rate_hz / 1000) % 1000,
 		(current_pix_rate_hz % 1000),
@@ -477,8 +476,7 @@ bool dal_clock_source_adjust_pxl_clk_by_ref_pixel_rate(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[end]: Current: %u,%03u,%03uHz, "
-		"Requested: %u,%03u,%03uHz\n",
+		"%s[end]: Current: %u,%03u,%03uHz, Requested: %u,%03u,%03uHz\n",
 		__func__,
 		(current_pix_rate_hz / 1000000),
 		(current_pix_rate_hz / 1000) % 1000,
@@ -490,8 +488,7 @@ bool dal_clock_source_adjust_pxl_clk_by_ref_pixel_rate(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[end]: Current(Raw): %u,%03u,%03uHz, "
-		"Requested(Raw): %u,%03u,%03uHz\n\n",
+		"%s[end]: Current(Raw): %u,%03u,%03uHz, Requested(Raw): %u,%03u,%03uHz\n\n",
 		__func__,
 		(raw_cur_pix_rate_hz / 1000000),
 		(raw_cur_pix_rate_hz / 1000) % 1000,
@@ -510,7 +507,7 @@ bool dal_clock_source_adjust_pxl_clk_by_pix_amount(
 					int32_t pix_num)
 {
 	bool success = false;
-	uint32_t requested_pix_rate_hz ;
+	uint32_t requested_pix_rate_hz;
 	uint32_t cur_pix_rate_hz = retrieve_raw_pix_rate_hz(
 			clk_src,
 			pix_clk_params);
@@ -522,8 +519,7 @@ bool dal_clock_source_adjust_pxl_clk_by_pix_amount(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[start]: Current(Raw): %u,%03u,%03uHz, "
-		"Requested(Raw): %u,%03u,%03uHz\n",
+		"%s[start]: Current(Raw): %u,%03u,%03uHz, Requested(Raw): %u,%03u,%03uHz\n",
 		__func__,
 		(cur_pix_rate_hz / 1000000),
 		(cur_pix_rate_hz / 1000) % 1000,
@@ -548,8 +544,7 @@ bool dal_clock_source_adjust_pxl_clk_by_pix_amount(
 	dal_logger_write(clk_src->dal_ctx->logger,
 		LOG_MAJOR_SYNC,
 		LOG_MINOR_SYNC_HW_CLOCK_ADJUST,
-		"%s[end]: Current(Raw): %u,%03u,%03uHz,"
-		"Requested(Raw): %u,%03u,%03uHz\n\n",
+		"%s[end]: Current(Raw): %u,%03u,%03uHz,Requested(Raw): %u,%03u,%03uHz\n\n",
 		__func__,
 		(cur_pix_rate_hz / 1000000),
 		(cur_pix_rate_hz / 1000) % 1000,
diff --git a/drivers/gpu/drm/amd/dal/gpu/dce110/bandwidth_manager_dce110.c b/drivers/gpu/drm/amd/dal/gpu/dce110/bandwidth_manager_dce110.c
index 69d0761..b49af8a 100644
--- a/drivers/gpu/drm/amd/dal/gpu/dce110/bandwidth_manager_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpu/dce110/bandwidth_manager_dce110.c
@@ -44,10 +44,10 @@
 
 /* Debug macros */
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_GPU, \
-		"BM:%s()\n", __func__);
+		"BM:%s()\n", __func__)
 
 #define BM_DBG_REQ_BANDW(...) dal_logger_write(dal_ctx->logger, LOG_MAJOR_BWM, \
-	LOG_MINOR_BWM_REQUIRED_BANDWIDTH_CALCS, __VA_ARGS__);
+	LOG_MINOR_BWM_REQUIRED_BANDWIDTH_CALCS, __VA_ARGS__)
 
 
 #define regs_for_bm(id) \
@@ -2741,6 +2741,7 @@ static bool register_interrupt(
 	enum controller_id ctrl_id)
 {
 	struct dal_context *dal_context = bm_dce110->base.dal_ctx;
+
 	NOT_IMPLEMENTED();
 	return false;
 }
@@ -3641,6 +3642,7 @@ static uint32_t validate_stutter_mode(
 	uint32_t stutter_mode = 0;
 	struct bandwidth_manager_dce110 *bm_dce110 = BM110_FROM_BM_BASE(bm);
 	uint32_t i = 0;
+
 	stutter_mode = bm_dce110->supported_stutter_mode;
 
 	for (i = 0; i < path_num; ++i) {
@@ -3768,6 +3770,7 @@ static void self_refresh_dmif_watermark(
 			} else {
 				struct bandwidth_params chroma_params;
 				uint32_t adjusted_buffer_size = 0;
+
 				get_chroma_surface_params_for_underlay(
 					bm->dal_ctx,
 					bw_params_copy,
@@ -3892,6 +3895,7 @@ static void urgency_marks(
 					dal_fixed32_32_from_int(MAX_WATERMARK);
 		} else {
 			uint32_t adjusted_buffer_size = 0;
+
 			if ((local_wm_params->pixel_clk_khz == 0) ||
 				local_wm_params->timing_info.h_total == 0){
 
@@ -3956,6 +3960,7 @@ static void urgency_marks(
 			} else {
 				struct bandwidth_params chroma_params;
 				uint32_t adjusted_buffer_size = 0;
+
 				get_chroma_surface_params_for_underlay(
 					bm->dal_ctx,
 					bw_params_copy,
@@ -4232,6 +4237,7 @@ static void nb_pstate_watermark(
 				wm_low_clks = MAX_WATERMARK;
 			} else {
 				struct bandwidth_params bw_chroma_param;
+
 				get_chroma_surface_params_for_underlay(
 					bm->dal_ctx,
 					cur_bw_params,
@@ -4588,6 +4594,7 @@ static uint32_t get_min_deep_sleep_sclk(
 	 */
 	for (i = 0; i < paths_num; i++) {
 		uint32_t total_pixels;
+
 		if (bw_params == NULL ||
 			bw_params->timing_info.pix_clk_khz == 0 ||
 			bw_params->timing_info.h_total == 0) {
diff --git a/drivers/gpu/drm/amd/dal/gpu/dce110/dc_clock_gating_dce110.c b/drivers/gpu/drm/amd/dal/gpu/dce110/dc_clock_gating_dce110.c
index 229b723..e09fb89 100644
--- a/drivers/gpu/drm/amd/dal/gpu/dce110/dc_clock_gating_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpu/dce110/dc_clock_gating_dce110.c
@@ -36,7 +36,7 @@
  *****************************************************************************/
 
 #define NOT_IMPLEMENTED() DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_GPU, \
-		"%s:%s()\n", __FILE__, __func__);
+		"%s:%s()\n", __FILE__, __func__)
 
 /******************************************************************************
  * static functions
@@ -87,13 +87,10 @@ void dal_dc_clock_gating_dce110_power_up(
 		struct dal_context *dal_context,
 		bool enable)
 {
-	if(enable)
-	{
+	if (enable) {
 		enable_hw_base_light_sleep(dal_context);
 		disable_sw_manual_control_light_sleep(dal_context);
-	}
-	else
-	{
+	} else {
 		force_hw_base_light_sleep(dal_context);
 	}
 }
diff --git a/drivers/gpu/drm/amd/dal/gpu/dce110/display_clock_dce110.c b/drivers/gpu/drm/amd/dal/gpu/dce110/display_clock_dce110.c
index 63b6261..58ec0bc 100644
--- a/drivers/gpu/drm/amd/dal/gpu/dce110/display_clock_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpu/dce110/display_clock_dce110.c
@@ -37,12 +37,6 @@
 
 #include "display_clock_dce110.h"
 
-/*****************************************************************************
- * macro definitions
- *****************************************************************************/
-#define NOT_IMPLEMENTED()  DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_GPU, \
-			"DCLK:%s()\n", __func__);
-
 #define FROM_DISPLAY_CLOCK(base) \
 	container_of(base, struct display_clock_dce110, disp_clk_base)
 
@@ -621,6 +615,7 @@ static uint32_t calculate_min_clock(
 
 	if (params != NULL) {
 		uint32_t disp_clk_khz = 0;
+
 		for (i = 0; i < path_num; ++i) {
 
 			disp_clk_khz = calc_single_display_min_clks(
@@ -669,6 +664,7 @@ static bool display_clock_integrated_info_construct(
 	/*update the maximum display clock for each power state*/
 	for (i = 0; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {
 		enum clocks_state clk_state = CLOCKS_STATE_INVALID;
+
 		switch (i) {
 		case 0:
 			clk_state = CLOCKS_STATE_ULTRA_LOW;
@@ -805,6 +801,7 @@ static void set_clock_state(
 	struct display_clock_state clk_state)
 {
 	struct display_clock_dce110 *disp_clk = DCLCK110_FROM_BASE(dc);
+
 	disp_clk->clock_state = clk_state;
 }
 
@@ -812,6 +809,7 @@ static struct display_clock_state get_clock_state(
 	struct display_clock *dc)
 {
 	struct display_clock_dce110 *disp_clk = DCLCK110_FROM_BASE(dc);
+
 	return disp_clk->clock_state;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/gpu/dce110/gpu_dce110.c b/drivers/gpu/drm/amd/dal/gpu/dce110/gpu_dce110.c
index 80f5a8f..47ee4e1 100644
--- a/drivers/gpu/drm/amd/dal/gpu/dce110/gpu_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpu/dce110/gpu_dce110.c
@@ -50,7 +50,7 @@ const enum controller_id controller_array[4] = {
  *****************************************************************************/
 
 #define FROM_BASE_TO_DCE11(ptr) \
-	container_of((ptr), struct gpu_dce110, base);
+	container_of((ptr), struct gpu_dce110, base)
 
 /*****************************************************************************
  * static functions
@@ -64,6 +64,7 @@ static void destruct(struct gpu_dce110 *gpu)
 static void destroy(struct gpu **base)
 {
 	struct gpu_dce110 *gpu;
+
 	gpu = FROM_BASE_TO_DCE11(*base);
 	destruct(gpu);
 	dal_free(gpu);
@@ -217,7 +218,9 @@ static void power_up(struct gpu *base)
 
 	dal_gpu_power_up_base(base);
 
-	dal_dc_clock_gating_dce110_power_up(base->dal_context, gpu110->dc_clock_gating );
+	dal_dc_clock_gating_dce110_power_up(
+			base->dal_context,
+			gpu110->dc_clock_gating);
 }
 
 static void power_down(
@@ -320,6 +323,7 @@ static bool construct(
 struct gpu *dal_gpu_dce110_create(struct gpu_init_data *init_data)
 {
 	struct gpu_dce110 *gpu = dal_alloc(sizeof(struct gpu_dce110));
+
 	if (gpu == NULL)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/gpu/dce110/pll_clock_source_dce110.c b/drivers/gpu/drm/amd/dal/gpu/dce110/pll_clock_source_dce110.c
index 21a6e20..38c78cb 100644
--- a/drivers/gpu/drm/amd/dal/gpu/dce110/pll_clock_source_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpu/dce110/pll_clock_source_dce110.c
@@ -100,7 +100,7 @@ static bool calculate_ss(
 
 	/* compute SS_STEP_SIZE_DSFRAC */
 	modulation_time = dal_fixed32_32_from_fraction(
-		pll_settings->reference_freq * 1000 ,
+		pll_settings->reference_freq * 1000,
 		pll_settings->reference_divider * ss_data->modulation_freq_hz);
 
 
@@ -464,6 +464,7 @@ static void ss_info_from_atombios_create(
 	struct pll_clock_source_dce110 *clk_src)
 {
 	struct clock_source *base = &clk_src->base.base;
+
 	dal_clock_source_get_ss_info_from_atombios(
 		base,
 		AS_SIGNAL_TYPE_DISPLAY_PORT,
diff --git a/drivers/gpu/drm/amd/dal/gpu/dce110/vce_clock_source_dce110.c b/drivers/gpu/drm/amd/dal/gpu/dce110/vce_clock_source_dce110.c
index c5aaa92..623ce33 100644
--- a/drivers/gpu/drm/amd/dal/gpu/dce110/vce_clock_source_dce110.c
+++ b/drivers/gpu/drm/amd/dal/gpu/dce110/vce_clock_source_dce110.c
@@ -130,6 +130,7 @@ static bool construct(
 			struct clock_source_init_data *clk_src_init_data)
 {
 	struct firmware_info fw_info = {};
+
 	if (!dal_clock_source_construct(
 		&vce_clk_src->base, clk_src_init_data)) {
 		ASSERT_CRITICAL(false);
diff --git a/drivers/gpu/drm/amd/dal/gpu/gpu.c b/drivers/gpu/drm/amd/dal/gpu/gpu.c
index fbab6e3..1dbe896 100644
--- a/drivers/gpu/drm/amd/dal/gpu/gpu.c
+++ b/drivers/gpu/drm/amd/dal/gpu/gpu.c
@@ -44,8 +44,8 @@ void dal_gpu_init_controller_info_table(
 
 	for (i = 0; i < combinations_num; ++i)
 		for (j = 0; j < controllers_num; ++j) {
-
 			uint32_t idx = i * controllers_num + j;
+
 			infos[idx].id = ids[idx];
 			infos[idx].HARVESTED = 0;
 			infos[idx].CREATED = 0;
diff --git a/drivers/gpu/drm/amd/dal/gpu/pll_clock_source.c b/drivers/gpu/drm/amd/dal/gpu/pll_clock_source.c
index d40300b..628e1de 100644
--- a/drivers/gpu/drm/amd/dal/gpu/pll_clock_source.c
+++ b/drivers/gpu/drm/amd/dal/gpu/pll_clock_source.c
@@ -57,6 +57,7 @@ bool dal_pll_clock_source_adjust_pix_clk(
 	struct bp_adjust_pixel_clock_parameters bp_adjust_pixel_clock_params = {
 							0 };
 	enum bp_result bp_result;
+
 	switch (pix_clk_params->signal_type) {
 	case SIGNAL_TYPE_HDMI_TYPE_A: {
 		requested_clk_khz = pix_clk_params->requested_pix_clk;
@@ -124,6 +125,7 @@ bool dal_pll_clock_source_construct(
 		struct clock_source_init_data *clk_src_init_data)
 {
 	struct firmware_info fw_info = {};
+
 	if (!dal_clock_source_construct(
 			&pll_clk_src->base,
 			clk_src_init_data))
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c b/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c
index d2f88bd..c6d323b 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/dce110/hw_sequencer_dce110.c
@@ -38,11 +38,6 @@
 #include "hw_sequencer_dce110.h"
 #include "hw_sync_control_dce110.h"
 
-/**********************/
-/* Additional defines */
-/**********************/
-#define NOT_IMPLEMENTED()  DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_HWSS, \
-			"%s()\n", __func__);
 
 /******************/
 /* Implementation */
@@ -452,6 +447,7 @@ static void set_display_clock_dfs_bypass(
 				DELAY_AFTER_DISABLE_BACKLIGHT_DFS_BYPASS) {
 			const struct monitor_patch_info *patch_info;
 			unsigned int delay_after_disable_backlight_dfs_bypass;
+
 			patch_info =  dal_dcs_get_monitor_patch_info(
 				dal_display_path_get_dcs(display_path),
 				MONITOR_PATCH_TYPE_DELAY_AFTER_DISABLE_BACKLIGHT_DFS_BYPASS);
@@ -474,6 +470,7 @@ static void set_display_clock_dfs_bypass(
 		embedded_dp_display) {
 		struct pixel_clk_params pixel_clk_params;
 		int32_t j;
+
 		dal_memset(&pixel_clk_params, 0, sizeof(pixel_clk_params));
 		dal_hw_sequencer_get_pixel_clock_parameters(
 			path_mode, &pixel_clk_params);
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
index f6e0d9b..5e44d5f 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
@@ -360,6 +360,7 @@ void build_encoder_context(
 	uint32_t i;
 	struct connector_feature_support cfs;
 	uint32_t links_number = dal_display_path_get_number_of_links(dp);
+
 	ASSERT(dp != NULL);
 	ASSERT(context != NULL);
 
@@ -447,6 +448,7 @@ void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 		uint8_t chk_sum = 0;
 		uint8_t *ptr;
 		uint8_t i;
+
 		dal_memmove(
 			&encoder_info_frame->gamut,
 			&hw_info_frame->gamut_packet,
@@ -970,6 +972,7 @@ bool dal_hw_sequencer_enable_line_buffer_power_gating(
 	bool interlaced)
 {
 	struct lb_config_data lb_config_data;
+
 	if (!lb)
 		return false;
 
@@ -1033,6 +1036,7 @@ static void enable_hpd(
 {
 	struct encoder_context encoder_context;
 	struct display_path_objects disp_path_obj;
+
 	dal_hw_sequencer_get_objects(display_path, &disp_path_obj);
 	build_encoder_context(
 			display_path,
@@ -1100,6 +1104,7 @@ static void build_upstream_encoder_output(
 	struct dcs *dcs;
 	struct encoder *enc;
 	union dcs_monitor_patch_flags patch_flags;
+
 	if (hw_path_mode == NULL || encoder_output == NULL)
 		return;
 	dcs = dal_display_path_get_dcs(hw_path_mode->display_path);
@@ -1255,6 +1260,7 @@ void dal_hw_sequencer_enable_audio_endpoint(
 	bool enable)
 {
 	struct audio *audio;
+
 	if (!display_path)
 		return;
 
@@ -1339,6 +1345,7 @@ enum hwss_result dal_hw_sequencer_reset_audio_device(
 
 	if (disp_path_obj.audio != NULL) {
 		struct audio_channel_associate_info audio_mapping;
+
 		audio_mapping.u32all = 0;
 
 		dal_audio_enable_channel_splitting_mapping(
@@ -1466,6 +1473,7 @@ static enum hwss_result encoder_validate_path_mode(
 		path_mode->action == HW_PATH_ACTION_STATIC_VALIDATE ?
 			bo_validate : bo_enable;
 	enum encoder_result validation_result;
+
 	build_encoder_output(path_mode, option, &enc_output);
 
 	validation_result =
@@ -1492,6 +1500,7 @@ enum hwss_result dal_hw_sequencer_validate_display_path_mode(
 	enum hwss_result validation_result;
 	struct display_path_objects disp_path_obj;
 	struct controller *controller;
+
 	dal_hw_sequencer_get_objects(path_mode->display_path, &disp_path_obj);
 
 	controller = dal_display_path_get_controller(path_mode->display_path);
@@ -1688,6 +1697,7 @@ bool dal_hw_sequencer_is_supported_dp_training_pattern3(
 {
 	struct encoder *encoder;
 	struct encoder_feature_support features;
+
 	if (!display_path) {
 		BREAK_TO_DEBUGGER();
 
@@ -1717,6 +1727,7 @@ enum hwss_result dal_hw_sequencer_set_dp_phy_pattern(
 
 	/* Build encoder context */
 	struct encoder_context context;
+
 	build_encoder_context(param->display_path, encoder, &context);
 
 	/* Set EncoderDpPhyPattern */
@@ -1765,6 +1776,7 @@ enum hwss_result dal_hw_sequencer_set_lane_settings(
 	struct display_path_objects obj;
 	struct encoder *encoder;
 	struct encoder_context context;
+
 	if (!link_settings) {
 		BREAK_TO_DEBUGGER();
 		return HWSS_RESULT_ERROR;
@@ -2015,6 +2027,7 @@ void dal_hw_sequencer_blank_stream(
 {
 	struct encoder *enc;
 	struct encoder_context enc_ctx;
+
 	ASSERT(in && in->display_path);
 	enc = dal_display_path_get_upstream_encoder(in->display_path,
 				in->link_idx);
@@ -2029,6 +2042,7 @@ void dal_hw_sequencer_unblank_stream(
 {
 	struct encoder *enc;
 	struct encoder_unblank_param enc_unbl_param;
+
 	ASSERT(in != NULL && in->display_path != NULL);
 
 	enc = dal_display_path_get_upstream_encoder(
@@ -2470,6 +2484,7 @@ static void program_encoder_and_audio(
 		path_mode->action_flags.PIXEL_ENCODING_CHANGED) {
 		/* setup Encoder - prepare enable encoder parameters */
 		struct encoder_output encoder_output;
+
 		build_encoder_output(path_mode, BUILD_OPTION_ENABLE_UPSTREAM,
 			&encoder_output);
 
@@ -2520,6 +2535,7 @@ static void reprogram_crtc_and_pll(
 
 		/* program PLL */
 		struct pixel_clk_params pixel_clk_params;
+
 		dal_memset(&pixel_clk_params, 0, sizeof(pixel_clk_params));
 		dal_hw_sequencer_get_pixel_clock_parameters(
 			path_mode, &pixel_clk_params);
@@ -2678,6 +2694,7 @@ static enum hwss_result set_path_mode_back_end(
 	{
 		/* select CRTC source for encoder */
 		struct bp_crtc_source_select crtc_source_select;
+
 		dal_memset(&crtc_source_select, 0, sizeof(crtc_source_select));
 		crtc_source_select.engine_id = engine_id;
 		crtc_source_select.controller_id =
@@ -2877,6 +2894,7 @@ enum signal_type dal_hw_sequencer_detect_load(
 	struct display_path_objects objs;
 	struct encoder *encoder;
 	struct encoder_context context;
+
 	dal_hw_sequencer_get_objects(display_path, &objs);
 
 	encoder = objs.downstream_encoder != NULL ?
@@ -3277,6 +3295,7 @@ static enum hwss_result set_path_mode_front_end(
 
 		{
 			struct watermark_input_params params;
+
 			params.controller_id = dal_controller_get_id(crtc);
 
 			/*
@@ -3364,6 +3383,7 @@ static void configure_locking(struct display_path *dp, bool enable)
 		struct display_path_plane *plane =
 			dal_display_path_get_plane_at_index(dp, i);
 		struct controller *crtc = plane->controller;
+
 		dal_controller_pipe_control_lock(
 			crtc,
 			PIPE_LOCK_CONTROL_MODE,
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
index 0369ef3..17587a1 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
@@ -56,6 +56,7 @@ static struct hw_path_mode *get_required_mode_path(
 {
 	struct hw_path_mode *path_mode;
 	uint32_t i;
+
 	for (i = 0; i < dal_hw_path_mode_set_get_paths_number(set); i++) {
 		path_mode = dal_hw_path_mode_set_get_path_by_index(set, i);
 	if (path_mode->action == action)
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_helpers.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_helpers.c
index c2da86d..0015b11 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_helpers.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_helpers.c
@@ -129,6 +129,7 @@ void dal_hw_sequencer_get_objects(
 {
 	uint32_t i;
 	uint32_t links_number = dal_display_path_get_number_of_links(dp);
+
 	dal_memset(objs, 0, sizeof(struct display_path_objects));
 
 	for (i = 0; i < links_number; ++i) {
@@ -151,6 +152,7 @@ enum engine_id dal_hw_sequencer_get_engine_id(struct display_path *dp)
 {
 	uint32_t i;
 	uint32_t links_number = dal_display_path_get_number_of_links(dp);
+
 	for (i = 0; i < links_number; ++i) {
 		if (dal_display_path_get_stream_engine(dp, i) !=
 			ENGINE_ID_UNKNOWN) {
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c
index 27a56ca..cf9e575 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c
@@ -1032,10 +1032,10 @@ static uint32_t prepare_per_path_parameters(
 			params_prepared = 0;
 			ASSERT(false);
 			return params_prepared;
-		} else {
-			/* OK */
-			param_current++;
 		}
+
+		/* OK */
+		param_current++;
 	} /* for() */
 
 	/* we prepared as many parameters as planes */
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sync_control.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sync_control.c
index 08d55f7..bf87ab9 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sync_control.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sync_control.c
@@ -63,6 +63,7 @@ enum hwss_result dal_hw_sync_control_inter_path_synchronize(
 	/* Perform CRTC synchronization*/
 	if (sync_needed) {
 		struct hw_resync_flags resync_flags = { false, false, false };
+
 		resync_flags.INTERPATH = true;
 		resync_flags.NOTIFY_SYNCED = true;
 		return sync_control->funcs->resync_display_paths(
diff --git a/drivers/gpu/drm/amd/dal/i2caux/dce110/aux_engine_dce110.c b/drivers/gpu/drm/amd/dal/i2caux/dce110/aux_engine_dce110.c
index d5ad4b9..b744c82 100644
--- a/drivers/gpu/drm/amd/dal/i2caux/dce110/aux_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/i2caux/dce110/aux_engine_dce110.c
@@ -120,6 +120,7 @@ static bool acquire_engine(
 
 		if (field == 0) {
 			uint8_t counter = 0;
+
 			set_reg_field_value(
 				value,
 				1,
@@ -669,18 +670,17 @@ static enum aux_channel_operation_result get_channel_status(
 			AUX_SW_STATUS,
 			AUX_SW_RX_INVALID_STOP))
 			return AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY;
+
+		*returned_bytes = get_reg_field_value(
+				value,
+				AUX_SW_STATUS,
+				AUX_SW_REPLY_BYTE_COUNT);
+		if (*returned_bytes == 0)
+			return
+			AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY;
 		else {
-			*returned_bytes = get_reg_field_value(
-					value,
-					AUX_SW_STATUS,
-					AUX_SW_REPLY_BYTE_COUNT);
-			if (*returned_bytes == 0)
-				return
-				AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY;
-			else {
-				*returned_bytes -= 1;
-				return AUX_CHANNEL_OPERATION_SUCCEEDED;
-			}
+			*returned_bytes -= 1;
+			return AUX_CHANNEL_OPERATION_SUCCEEDED;
 		}
 	} else {
 		/*time_elapsed >= aux_engine->timeout_period */
diff --git a/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_hw_engine_dce110.c b/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_hw_engine_dce110.c
index 4ac81b7..3f94b40 100644
--- a/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_hw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_hw_engine_dce110.c
@@ -99,6 +99,7 @@ static void disable_i2c_hw_engine(
 	uint32_t value = 0;
 
 	struct dal_context *ctx = NULL;
+
 	ctx = engine->base.base.base.ctx;
 
 	value = dal_read_reg(ctx, addr);
@@ -143,6 +144,7 @@ static void release_engine(
 	/* Reset HW engine */
 	{
 		uint32_t i2c_sw_status = 0;
+
 		value = dal_read_reg(engine->ctx, mmDC_I2C_SW_STATUS);
 
 		i2c_sw_status = get_reg_field_value(
@@ -425,6 +427,7 @@ static bool process_transaction(
 	uint32_t value = 0;
 
 	struct dal_context *ctx = NULL;
+
 	ctx = engine->base.base.base.ctx;
 
 	{
@@ -558,6 +561,7 @@ static void execute_transaction(
 {
 	uint32_t value = 0;
 	struct dal_context *ctx = NULL;
+
 	ctx = engine->base.base.base.ctx;
 
 	{
@@ -745,9 +749,9 @@ static enum i2c_channel_operation_result get_channel_status(
 		return I2C_CHANNEL_OPERATION_FAILED;
 	else if (value & DC_I2C_SW_STATUS__DC_I2C_SW_DONE_MASK)
 		return I2C_CHANNEL_OPERATION_SUCCEEDED;
-	else
-		/* in DAL2, I2C_RESULT_OK was returned */
-		return I2C_CHANNEL_OPERATION_NOT_STARTED;
+
+	/* in DAL2, I2C_RESULT_OK was returned */
+	return I2C_CHANNEL_OPERATION_NOT_STARTED;
 }
 
 static uint8_t get_hw_buffer_available_size(
diff --git a/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_sw_engine_dce110.c b/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_sw_engine_dce110.c
index 399af15..f9cb00e 100644
--- a/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_sw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/dal/i2caux/dce110/i2c_sw_engine_dce110.c
@@ -124,6 +124,7 @@ static bool construct(
 	const struct i2c_sw_engine_dce110_create_arg *arg_dce110)
 {
 	struct i2c_sw_engine_create_arg arg_base;
+
 	arg_base.ctx = arg_dce110->ctx;
 	arg_base.default_speed = arg_dce110->default_speed;
 
diff --git a/drivers/gpu/drm/amd/dal/i2caux/i2caux.c b/drivers/gpu/drm/amd/dal/i2caux/i2caux.c
index 4b338d0..185a367 100644
--- a/drivers/gpu/drm/amd/dal/i2caux/i2caux.c
+++ b/drivers/gpu/drm/amd/dal/i2caux/i2caux.c
@@ -465,6 +465,7 @@ bool dal_i2caux_construct(
 	struct dal_context *dal_context)
 {
 	uint32_t i = 0;
+
 	i2caux->dal_context = dal_context;
 	do {
 		i2caux->i2c_sw_engines[i] = NULL;
diff --git a/drivers/gpu/drm/amd/dal/include/adjustment_types.h b/drivers/gpu/drm/amd/dal/include/adjustment_types.h
index 54a18a2..94e3611 100644
--- a/drivers/gpu/drm/amd/dal/include/adjustment_types.h
+++ b/drivers/gpu/drm/amd/dal/include/adjustment_types.h
@@ -40,7 +40,7 @@ enum adjustment_id {
 
 	/*this useful type when i need to indicate unknown adjustment and code
 	look if not the specific type*/
-	ADJ_ID_INVALID ,
+	ADJ_ID_INVALID,
 
 	ADJ_ID_CONTRAST,
 	ADJ_ID_BRIGHTNESS,
@@ -141,7 +141,7 @@ in place and not wait for flush call*/
 enum adjustment_state {
 	ADJUSTMENT_STATE_INVALID,
 	ADJUSTMENT_STATE_VALID,
-	ADJUSTMENT_STATE_REQUESTED ,
+	ADJUSTMENT_STATE_REQUESTED,
 	ADJUSTMENT_STATE_COMMITTED_TO_HW,
 };
 
diff --git a/drivers/gpu/drm/amd/dal/include/bit_set.h b/drivers/gpu/drm/amd/dal/include/bit_set.h
index 14077a6..d3e8e03 100644
--- a/drivers/gpu/drm/amd/dal/include/bit_set.h
+++ b/drivers/gpu/drm/amd/dal/include/bit_set.h
@@ -39,6 +39,7 @@ static inline uint32_t get_next_significant_bit(
 		struct bit_set_iterator_32 *bs32)
 {
 	uint32_t lsb = least_significant_bit(bs32->value);
+
 	bs32->value &= ~lsb;
 	return lsb;
 }
diff --git a/drivers/gpu/drm/amd/dal/include/csc_common_types.h b/drivers/gpu/drm/amd/dal/include/csc_common_types.h
index c63c427..5765d19 100644
--- a/drivers/gpu/drm/amd/dal/include/csc_common_types.h
+++ b/drivers/gpu/drm/amd/dal/include/csc_common_types.h
@@ -52,7 +52,7 @@ enum surface_type {
 
 /* used by Graphics and Overlay gamma */
 struct gamma_coeff {
-	int32_t gamma[3]  ;
+	int32_t gamma[3];
 	int32_t a0[3]; /* index 0 for red, 1 for green, 2 for blue */
 	int32_t a1[3];
 	int32_t a2[3];
diff --git a/drivers/gpu/drm/amd/dal/include/dpcd_access_service_interface.h b/drivers/gpu/drm/amd/dal/include/dpcd_access_service_interface.h
index b0c3fe2..fefd856 100644
--- a/drivers/gpu/drm/amd/dal/include/dpcd_access_service_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/dpcd_access_service_interface.h
@@ -29,32 +29,37 @@
 /* DDC service transaction error codes
  * depends on transaction status
  */
-enum ddc_result
-{
-    DDCRESULT_UNKNOWN       = 0,
-    DDCRESULT_SUCESSFULL,
-    DDCRESULT_FAILEDCHANNELBUSY,
-    DDCRESULT_FAILEDTIMEOUT,
-    DDCRESULT_FAILEDPROTOCOLERROR,
-    DDCRESULT_FAILEDNACK,
-    DDCRESULT_FAILEDINCOMPLETE,
-    DDCRESULT_FAILEDOPERATION,
-    DDCRESULT_FAILEDINVALIDOPERATION,
-    DDCRESULT_FAILEDBUFFEROVERFLOW
+enum ddc_result {
+	DDCRESULT_UNKNOWN = 0,
+	DDCRESULT_SUCESSFULL,
+	DDCRESULT_FAILEDCHANNELBUSY,
+	DDCRESULT_FAILEDTIMEOUT,
+	DDCRESULT_FAILEDPROTOCOLERROR,
+	DDCRESULT_FAILEDNACK,
+	DDCRESULT_FAILEDINCOMPLETE,
+	DDCRESULT_FAILEDOPERATION,
+	DDCRESULT_FAILEDINVALIDOPERATION,
+	DDCRESULT_FAILEDBUFFEROVERFLOW
 };
 
-enum 
-{
-    MaxNativeAuxTransactionSize = 16
+enum {
+	MaxNativeAuxTransactionSize = 16
 };
 
 struct display_sink_capability;
 
 /* TO DO: below functions can be moved to ddc_service (think about it)*/
-enum ddc_result dal_ddc_read_dpcd_data(uint32_t address, unsigned char* data, uint32_t size);
-enum ddc_result dal_ddc_write_dpcd_data(uint32_t address, const unsigned char* data uint32_t size);
-bool dal_aux_query_dp_sink_capability(display_sink_capability* sink_cap);
-bool start_gtc_sync();
-bool stop_gtc_sync();
+enum ddc_result dal_ddc_read_dpcd_data(
+		uint32_t address,
+		unsigned char *data,
+		uint32_t size);
+
+enum ddc_result dal_ddc_write_dpcd_data(
+		uint32_t address,
+		const unsigned char *data uint32_t size);
+
+bool dal_aux_query_dp_sink_capability(display_sink_capability *sink_cap);
+bool start_gtc_sync(void);
+bool stop_gtc_sync(void);
 
 #endif /*__DPCD_ACCESS_SERVICE_INTERFACE_HPP__*/
diff --git a/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h b/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h
index 66d4738..8f9ce2a 100644
--- a/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h
+++ b/drivers/gpu/drm/amd/dal/include/hw_sequencer_types.h
@@ -259,16 +259,6 @@ enum hw_stereo_format {
 	HW_STEREO_FORMAT_CHECKER_BOARD = 7 /* the same as pixel interleave */
 };
 
-#define HW_STEREO_FORMAT_TO_MIXER_MODE(hw_format) \
-	(hw_format == HW_STEREO_FORMAT_ROW_INTERLEAVED ? \
-			HW_STEREO_MIXER_MODE_ROW_INTERLEAVE : \
-	hw_format == HW_STEREO_FORMAT_COLUMN_INTERLEAVED ? \
-			HW_STEREO_MIXER_MODE_COLUMN_INTERLEAVE : \
-	hw_format == HW_STEREO_FORMAT_CHECKER_BOARD ? \
-			HW_STEREO_MIXER_MODE_PIXEL_INTERLEAVE : \
-	HW_STEREO_MIXER_MODE_INACTIVE);
-
-
 enum hw_dithering_options {
 	HW_DITHERING_OPTION_UNKNOWN,
 	HW_DITHERING_OPTION_SKIP_PROGRAMMING,
diff --git a/drivers/gpu/drm/amd/dal/include/isr_config_types.h b/drivers/gpu/drm/amd/dal/include/isr_config_types.h
index 28bc658..cf0956d 100644
--- a/drivers/gpu/drm/amd/dal/include/isr_config_types.h
+++ b/drivers/gpu/drm/amd/dal/include/isr_config_types.h
@@ -83,7 +83,7 @@ struct display_plane_set {
 };
 
 enum layers_setup {
-	LAYERS_SETUP_NOTHING = 0 ,
+	LAYERS_SETUP_NOTHING = 0,
 	LAYERS_SETUP_SET,
 	LAYERS_SETUP_FREE
 };
@@ -104,7 +104,7 @@ struct plane_cfg_internal {
 };
 
 enum lock_type {
-	LOCK_TYPE_GRPH = 0 ,
+	LOCK_TYPE_GRPH = 0,
 	LOCK_TYPE_SURF,
 	LOCK_TYPE_SCL,
 	LOCK_TYPE_BLND,
@@ -113,7 +113,7 @@ enum lock_type {
 };
 
 enum alpha_mode {
-	ALPHA_MODE_PIXEL = 0 ,
+	ALPHA_MODE_PIXEL = 0,
 	ALPHA_MODE_PIXEL_AND_GLOBAL = 1,
 	ALPHA_MODE_GLOBAL = 2
 };
diff --git a/drivers/gpu/drm/amd/dal/include/logger_interface.h b/drivers/gpu/drm/amd/dal/include/logger_interface.h
index ce887f4..5b6f435 100644
--- a/drivers/gpu/drm/amd/dal/include/logger_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/logger_interface.h
@@ -112,11 +112,11 @@ uint32_t dal_logger_set_buffer_size(
 		struct dal_logger *logger,
 		uint32_t new_size);
 
-const struct log_major_info* dal_logger_enum_log_major_info(
+const struct log_major_info *dal_logger_enum_log_major_info(
 		struct dal_logger *logger,
 		unsigned int enum_index);
 
-const struct log_minor_info* dal_logger_enum_log_minor_info(
+const struct log_minor_info *dal_logger_enum_log_minor_info(
 		struct dal_logger *logger,
 		enum log_major major,
 		unsigned int enum_index);
diff --git a/drivers/gpu/drm/amd/dal/include/plane_types.h b/drivers/gpu/drm/amd/dal/include/plane_types.h
index c40280c..7306f67 100644
--- a/drivers/gpu/drm/amd/dal/include/plane_types.h
+++ b/drivers/gpu/drm/amd/dal/include/plane_types.h
@@ -618,10 +618,15 @@ struct cursor_position {
 	uint32_t x_origin;
 	uint32_t y_origin;
 
-	/*This parameter indicates whether HW cursor should be enabled */
+	/*
+	 * This parameter indicates whether HW cursor should be enabled
+	 */
 	bool enable;
 
-	/* This parameter indicates whether cursor hot spot should be programmed */
+	/*
+	 * This parameter indicates whether cursor hot spot should be
+	 * programmed
+	 */
 	bool hot_spot_enable;
 };
 
diff --git a/drivers/gpu/drm/amd/dal/interface/dal.c b/drivers/gpu/drm/amd/dal/interface/dal.c
index 8f89ed0..81377c4 100644
--- a/drivers/gpu/drm/amd/dal/interface/dal.c
+++ b/drivers/gpu/drm/amd/dal/interface/dal.c
@@ -63,24 +63,20 @@ struct dal {
 
 /* debugging macro definitions */
 #define DAL_IF_TRACE()	\
-	do {	\
-		dal_logger_write(dal_context->logger, \
-			LOG_MAJOR_INTERFACE_TRACE, \
-			LOG_MINOR_COMPONENT_DAL_INTERFACE, \
-			"DAL_IF_TRACE: %s()\n", __func__);	\
-	} while (0)
+	dal_logger_write(dal_context->logger, \
+		LOG_MAJOR_INTERFACE_TRACE, \
+		LOG_MINOR_COMPONENT_DAL_INTERFACE, \
+		"DAL_IF_TRACE: %s()\n", __func__)
 
 #define DAL_IF_NOT_IMPLEMENTED() \
 	DAL_LOGGER_NOT_IMPL(LOG_MINOR_COMPONENT_DAL_INTERFACE, \
 			"DAL_IF:%s()\n", __func__)
 
 #define DAL_IF_ERROR(...) \
-	do { \
-		dal_logger_write(dal_context->logger, \
-			LOG_MAJOR_ERROR, \
-			LOG_MINOR_COMPONENT_DAL_INTERFACE, \
-			__VA_ARGS__); \
-	} while (0)
+	dal_logger_write(dal_context->logger, \
+		LOG_MAJOR_ERROR, \
+		LOG_MINOR_COMPONENT_DAL_INTERFACE, \
+		__VA_ARGS__)
 
 enum {
 	MAX_PLANE_NUM = 4
@@ -116,12 +112,12 @@ struct dal *dal_create(struct dal_init_data *init)
 		return NULL;
 	}
 
-	if (dal_construct(init, dal_instance))
-		return dal_instance;
-	else {
+	if (!dal_construct(init, dal_instance)) {
 		dal_free(dal_instance);
 		return NULL;
 	}
+
+	return dal_instance;
 }
 
 void dal_destroy(struct dal **dal)
@@ -150,6 +146,7 @@ static bool dal_construct(struct dal_init_data *init,
 		struct dal *dal_instance)
 {
 	struct dal_context *dal_context = &dal_instance->dal_context;
+
 	dal_instance->init_data = *init;
 	dal_instance->dal_context.driver_context = init->driver;
 	dal_instance->dal_context.cgs_device = init->cgs_device;
@@ -176,8 +173,8 @@ static bool dal_construct(struct dal_init_data *init,
 	/* Initialise HW controlled by Adapter Service */
 	if (false == dal_adapter_service_initialize_hw_data(
 			dal_instance->adapter_srv)) {
-		DAL_IF_ERROR("%s: dal_adapter_service_initialize_hw_data()"\
-				"  failed!\n", __func__);
+		DAL_IF_ERROR("%s: dal_adapter_service_initialize_hw_data() failed!\n",
+				__func__);
 		/* Note that AS exist, so have to destroy it.*/
 		goto ts_fail;
 	}
@@ -212,6 +209,7 @@ static bool dal_construct(struct dal_init_data *init,
 
 	{
 		struct mode_manager_init_data init_data;
+
 		init_data.as = dal_instance->adapter_srv;
 		init_data.default_modes =
 			dal_timing_service_get_default_mode_list(
@@ -393,13 +391,11 @@ static bool dal_enable(struct dal *dal)
 		tm_rc = dal_tm_register_for_display_detection_interrupt(tm_mgr);
 	}
 
-	if (TM_RESULT_SUCCESS == tm_rc) {
-		/* no error */
-		return true;
-	} else {
+	if (TM_RESULT_SUCCESS != tm_rc)
 		/* error occurred */
 		return false;
-	}
+
+	return true;
 }
 
 /*
@@ -451,9 +447,8 @@ uint32_t dal_get_connected_targets_vector(struct dal *dal)
 	for (ind = 0; ind < disp_path_num; ind++) {
 		disp_path = dal_tm_display_index_to_display_path(tm_mgr, ind);
 
-		if (dal_display_path_is_target_connected(disp_path)) {
+		if (dal_display_path_is_target_connected(disp_path))
 			connected_displays |= (1 << ind);
-		}
 	} /* for() */
 
 	return connected_displays;
@@ -1101,10 +1096,10 @@ uint32_t dal_get_crtc_scanoutpos(
 				tm, display_index);
 	struct controller *cont = dal_display_path_get_controller(dp);
 
-	if (!cont)
-	{
+	if (!cont) {
 		dal_logger_write(dal->dal_context.logger,
-				LOG_MAJOR_ERROR, LOG_MINOR_COMPONENT_DAL_INTERFACE,
+				LOG_MAJOR_ERROR,
+				LOG_MINOR_COMPONENT_DAL_INTERFACE,
 				"Failed to find controller at display index %d\n",
 				display_index);
 		return 0;
diff --git a/drivers/gpu/drm/amd/dal/interface/timing_list_query.c b/drivers/gpu/drm/amd/dal/interface/timing_list_query.c
index 43d52eb..c773e94 100644
--- a/drivers/gpu/drm/amd/dal/interface/timing_list_query.c
+++ b/drivers/gpu/drm/amd/dal/interface/timing_list_query.c
@@ -310,6 +310,7 @@ bool dal_timing_list_query_add_timing(struct dal_timing_list_query *tlsq,
 		/* mt.crtc_timing.pixel_encoding is NOT defined.
 		 * We need to get from DCS the supported pixel encoding. */
 		enum pixel_encoding pe;
+
 		query_dcs = true;
 		pe = PIXEL_ENCODING_UNDEFINED;
 
@@ -328,6 +329,7 @@ bool dal_timing_list_query_add_timing(struct dal_timing_list_query *tlsq,
 		 * we need to get from DCS the supported
 		 */
 		enum pixel_encoding pe = PIXEL_ENCODING_UNDEFINED;
+
 		query_dcs = true;
 		while (get_next_display_supported_pixel_encoding(
 			tlsq,
diff --git a/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c b/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c
index 29447b6..f0395ef 100644
--- a/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c
+++ b/drivers/gpu/drm/amd/dal/link_service/dpsst_link_service.c
@@ -190,8 +190,8 @@ static bool tmds_converter_capability_translate(
 		 * exists and treat as a "no converter" case. */
 		if (downstream_port->bits.FORMAT_CONV)
 			return false;
-		else
-			converter_caps->use_default_caps = true;
+
+		converter_caps->use_default_caps = true;
 	}
 
 	if (converter_caps->use_default_caps) {
@@ -459,6 +459,7 @@ static void disable_mst_mode(struct link_service *ls)
 {
 	struct dpsst_link_service *dpsst;
 	union mstm_cntl mstm_cntl;
+
 	dal_memset(&mstm_cntl, '\0', sizeof(union mstm_cntl));
 
 	dpsst = container_of(ls, struct dpsst_link_service, link_service);
@@ -523,10 +524,9 @@ static void retrieve_link_setting(struct link_service *ls,
 			status_01.bits.CHANNEL_EQ_DONE_0 != 1 ||
 			status_01.bits.SYMBOL_LOCKED_0 != 1)
 			break;
-		else {
-			lane_status_ok = true;
-			break;
-		}
+
+		lane_status_ok = true;
+		break;
 	default:
 		break;
 
@@ -668,6 +668,7 @@ static void retrieve_link_cap(struct link_service *ls)
 	if (dpsst->prev_sink_count == UNKNOWN_SINK_COUNT) {
 
 		uint8_t sink_count = 0;
+
 		dal_dpsst_ls_read_dpcd_data(ls,
 			DPCD_ADDRESS_SINK_COUNT,
 			&sink_count,
@@ -781,6 +782,7 @@ static bool disable_stream(
 	struct hw_path_mode *path_mode)
 {
 	struct enable_stream_param stream_params;
+
 	dal_memset(&stream_params, '\0', sizeof(struct enable_stream_param));
 
 	if (ls->strm_state != STREAM_STATE_ENABLED &&
@@ -879,8 +881,7 @@ static void program_drr(
 
 	if ((path_mode->mode.timing.ranged_timing.vertical_total_min !=
 		path_mode->mode.timing.ranged_timing.vertical_total_max) &&
-		(!path_mode->mode.timing.ranged_timing.control.\
-				force_disable_drr))
+		(!path_mode->mode.timing.ranged_timing.control.force_disable_drr))
 		downspread_write.bits.IGNORE_MSA_TIMING_PARAM = 1;
 	else
 		downspread_write.bits.IGNORE_MSA_TIMING_PARAM = 0;
@@ -1036,6 +1037,7 @@ static bool validate_link(struct link_service *ls,
 {
 	enum hwss_result result;
 	struct validate_link_param param = {0};
+
 	dal_memset(&param, '\0', sizeof(struct validate_link_param));
 
 	param.display_path = display_path;
@@ -1430,6 +1432,7 @@ static void dpcd_configure_assr(
 
 	if (DP_ALT_SCRAMBLER_RESET_NONE != assr) {
 		bool alt_scrambler_reset_enable = false;
+
 		switch (assr) {
 		case DP_ALT_SCRAMBLER_RESET_STANDARD:
 		case DP_ALT_SCRAMBLER_RESET_SPECIAL:
@@ -1468,6 +1471,7 @@ static uint8_t get_nibble_at_index(const uint8_t *buf,
 	uint32_t index)
 {
 	uint8_t nibble;
+
 	nibble = buf[index / 2];
 
 	if (index % 2)
@@ -1501,6 +1505,7 @@ static bool is_ch_eq_done(enum lane_count ln_count,
 {
 	bool done = true;
 	uint32_t lane;
+
 	if (!lane_status_updated->bits.INTERLANE_ALIGN_DONE)
 		done = false;
 	else {
@@ -1537,6 +1542,7 @@ static enum pre_emphasis get_max_pre_emphasis_for_voltage_swing(
 	enum voltage_swing voltage)
 {
 	enum pre_emphasis pre_emphasis;
+
 	pre_emphasis = PRE_EMPHASIS_MAX_LEVEL;
 
 	if (voltage <= VOLTAGE_SWING_MAX_LEVEL)
@@ -1554,6 +1560,7 @@ static void find_max_drive_settings(
 	uint32_t lane;
 
 	struct lane_settings max_requested;
+
 	max_requested.VOLTAGE_SWING =
 		link_training_setting->
 		lane_settings[0].VOLTAGE_SWING;
@@ -1652,6 +1659,7 @@ static void update_drive_settings(
 		struct link_training_settings src)
 {
 	uint32_t lane;
+
 	for (lane = 0; lane <
 		src.link_settings.lane_count; lane++) {
 
@@ -1669,6 +1677,7 @@ static bool is_max_vs_reached(
 	const struct link_training_settings *lt_settings)
 {
 	uint32_t lane;
+
 	for (lane = 0; lane <
 		(uint32_t)(lt_settings->link_settings.lane_count);
 		lane++) {
@@ -1862,6 +1871,7 @@ static bool set_dp_phy_pattern(
 {
 	struct set_dp_phy_pattern_param set_dp_phy_pattern_param = {0};
 	enum hwss_result hwss_result;
+
 	set_dp_phy_pattern_param.display_path = display_path;
 	set_dp_phy_pattern_param.link_idx = ls->link_idx;
 	set_dp_phy_pattern_param.test_pattern = test_pattern;
@@ -2126,8 +2136,7 @@ static void dpcd_set_lt_pattern_and_lane_settings(
 	dal_logger_write(ls->dal_context->logger,
 		LOG_MAJOR_HW_TRACE,
 		LOG_MINOR_HW_TRACE_LINK_TRAINING,
-		"%s:\n %x VS set = %x  PE set = %x \
-		max VS Reached = %x  max PE Reached = %x\n",
+		"%s:\n %x VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\n",
 		__func__,
 		DPCD_ADDRESS_LANE0_SET,
 		dpcd_lane[0].bits.VOLTAGE_SWING_SET,
@@ -2223,8 +2232,7 @@ static void dpcd_set_lane_settings(
 	dal_logger_write(ls->dal_context->logger,
 		LOG_MAJOR_HW_TRACE,
 		LOG_MINOR_HW_TRACE_LINK_TRAINING,
-		"%s\n %x VS set = %x  PE set = %x \
-		max VS Reached = %x  max PE Reached = %x\n",
+		"%s\n %x VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\n",
 		__func__,
 		DPCD_ADDRESS_LANE0_SET,
 		dpcd_lane[0].bits.VOLTAGE_SWING_SET,
@@ -2347,9 +2355,8 @@ static bool perform_clock_recovery_sequence(
 		dal_logger_write(ls->dal_context->logger,
 			LOG_MAJOR_ERROR,
 			LOG_MINOR_COMPONENT_LINK_SERVICE,
-			"%s: Link Training Error, could not \
-			 get CR after %d tries. \
-			Possibly voltage swing issue", __func__,
+			"%s: Link Training Error, could not get CR after %d tries. Possibly voltage swing issue",
+			__func__,
 			LINK_TRAINING_MAX_CR_RETRY);
 
 	}
@@ -2805,9 +2812,7 @@ static bool handle_hpd_irq_psr_sink(struct link_service *ls)
 			dal_logger_write(ls->dal_context->logger,
 				LOG_MAJOR_WARNING,
 				LOG_MINOR_COMPONENT_LINK_SERVICE,
-				"PSR: Unexpected IRQ_HPD triggered by \
-				Sink with no PSR Error Status! May point \
-				to panel issue!");
+				"PSR: Unexpected IRQ_HPD triggered by Sink with no PSR Error Status! May point to panel issue!");
 
 			 /* In this case no error is detected,
 			 * but PSR is active.*
@@ -3517,6 +3522,7 @@ static bool retry_link_training_workaround(struct link_service *ls,
 	struct dcs *dcs;
 	uint32_t max_retry;
 	uint32_t sleep_in_ms;
+
 	dcs = dal_display_path_get_dcs(path_mode->display_path);
 	patch_info = dal_dcs_get_monitor_patch_info(dcs,
 		MONITOR_PATCH_TYPE_RETRY_LINK_TRAINING_ON_FAILURE);
@@ -3548,6 +3554,7 @@ static void destroy(struct link_service **ls)
 {
 
 	struct dpsst_link_service *dpsst;
+
 	dpsst = container_of(*ls, struct dpsst_link_service, link_service);
 	destruct(dpsst);
 	dal_free(dpsst);
@@ -3641,6 +3648,7 @@ struct link_service *dal_dpsst_ls_create(
 	struct link_service_init_data *init_data)
 {
 	struct dpsst_link_service *dpsst_link_service = dal_alloc(
+
 	sizeof(struct dpsst_link_service));
 
 	if (dpsst_link_service == NULL)
@@ -3752,8 +3760,7 @@ bool dal_dpsst_ls_try_enable_link_with_hbr2_fallback(
 		dal_logger_write(ls->dal_context->logger,
 			LOG_MAJOR_HW_TRACE,
 			LOG_MINOR_HW_TRACE_LINK_TRAINING,
-			"%s: Link training failed, sending \
-			notification for user pop-up\n",
+			"%s: Link training failed, sending notification for user pop-up\n",
 			__func__);
 
 		/* sends the notification only
@@ -3832,6 +3839,7 @@ bool dal_dpsst_ls_verify_link_cap(
 				uint8_t num_retries = 3;
 				uint8_t j;
 				uint8_t delay_between_retries = 10;
+
 				for (j = 0; j < num_retries; ++j) {
 					success = perform_link_training(
 						ls,
@@ -3883,8 +3891,7 @@ bool dal_dpsst_ls_verify_link_cap(
 		dal_logger_write(ls->dal_context->logger,
 			LOG_MAJOR_HW_TRACE,
 			LOG_MINOR_HW_TRACE_LINK_TRAINING,
-			"%s: Link settings were reduced, sending \
-			notification for mode re-enumeration\n",
+			"%s: Link settings were reduced, sending notification for mode re-enumeration\n",
 			__func__);
 
 		/* notify lower settings applied
@@ -3971,6 +3978,7 @@ struct link_training_preference dal_dpsst_ls_get_link_training_preference(
 {
 	struct dpsst_link_service *dpsst;
 	struct link_training_preference lt_preference;
+
 	lt_preference.FAIL_LINK_TRAINING = 0;
 
 	dpsst = container_of(ls, struct dpsst_link_service, link_service);
@@ -3984,6 +3992,7 @@ uint32_t dal_dpsst_ls_bandwidth_in_kbps_from_timing(
 {
 	uint32_t bits_per_channel = 0;
 	uint32_t kbps;
+
 	switch (timing->flags.COLOR_DEPTH) {
 
 	case HW_COLOR_DEPTH_666:
@@ -4028,6 +4037,7 @@ uint32_t dal_dpsst_ls_bandwidth_in_kbps_from_link_settings(
 
 	uint32_t lane_count  = link_setting->lane_count;
 	uint32_t kbps = link_rate_in_kbps;
+
 	kbps *= lane_count;
 	kbps *= 8;   /* 8 bits per byte*/
 
diff --git a/drivers/gpu/drm/amd/dal/link_service/link_service.c b/drivers/gpu/drm/amd/dal/link_service/link_service.c
index 4db9a84..814ac82 100644
--- a/drivers/gpu/drm/amd/dal/link_service/link_service.c
+++ b/drivers/gpu/drm/amd/dal/link_service/link_service.c
@@ -44,6 +44,7 @@ static bool enable_stream(struct link_service *ls,
 		struct hw_path_mode *path_mode)
 {
 	enum signal_type signal;
+
 	ASSERT(ls->strm_state == STREAM_STATE_DISABLED ||
 		ls->strm_state == STREAM_STATE_OPTIMIZED_READY);
 
@@ -147,6 +148,7 @@ bool dal_link_service_blank_stream(struct link_service *ls,
 				struct hw_path_mode *path_mode)
 {
 	struct blank_stream_param blank_param = {0};
+
 	ASSERT(ls->strm_state == STREAM_STATE_ACTIVE ||
 			ls->strm_state == STREAM_STATE_OPTIMIZED_READY ||
 			ls->strm_state == STREAM_STATE_POWER_SAVE  ||
@@ -175,6 +177,7 @@ bool dal_link_service_unblank_stream(struct link_service *ls,
 			struct hw_path_mode *path_mode)
 {
 	struct blank_stream_param blank_param = {0};
+
 	ASSERT(ls->strm_state == STREAM_STATE_ENABLED ||
 			ls->strm_state == STREAM_STATE_OPTIMIZED_READY ||
 			ls->strm_state == STREAM_STATE_ACTIVE);
@@ -444,6 +447,7 @@ static struct link_service *create_legacy_link_service(
 				struct link_service_init_data *init_data)
 {
 	struct link_service *link_service = NULL;
+
 	link_service = dal_alloc(sizeof(struct link_service));
 
 	if (link_service == NULL)
@@ -514,6 +518,7 @@ void dal_ls_try_enable_stream(
 				const struct link_settings *link_setting)
 {
 	struct enable_stream_param stream_param = {0};
+
 	stream_param.display_path = path_mode->display_path;
 	stream_param.link_idx = ls->link_idx;
 	stream_param.timing = path_mode->mode.timing;
@@ -621,6 +626,7 @@ bool dal_ls_try_enable_link_base(
 {
 	enum hwss_result result = HWSS_RESULT_UNKNOWN;
 	struct enable_link_param link_param = {0};
+
 	link_param.display_path = path_mode->display_path;
 	link_param.link_idx = ls->link_idx;
 	link_param.optimized_programming =
@@ -744,6 +750,7 @@ void dal_ls_disable_link(struct link_service *ls,
 				const struct hw_path_mode *path_mode)
 {
 	struct enable_link_param link_param = {0};
+
 	link_param.display_path = path_mode->display_path;
 	link_param.link_idx = ls->link_idx;
 	link_param.path_mode = path_mode;
@@ -757,6 +764,7 @@ bool dal_ls_disable_stream_base(
 	struct hw_path_mode *path_mode)
 {
 	struct enable_stream_param stream_param = {0};
+
 	dal_memset(&ls->cur_link_setting, '\0', sizeof(ls->cur_link_setting));
 
 	/* When we returning from S3/S4 we want to remain in
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/best_view.c b/drivers/gpu/drm/amd/dal/mode_manager/best_view.c
index d2d4495..c96b369 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/best_view.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/best_view.c
@@ -131,6 +131,7 @@ static bool is_timing_priority_higher(
 		const struct mode_timing *rhs)
 {
 	uint32_t distance_lhs, distance_rhs;
+
 	if (rhs == NULL || lhs == NULL) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -201,6 +202,7 @@ void update_solution_support_matrix_for_scaling_trans(
 {
 	enum pixel_format pf;
 	bool guaranteed, supported;
+
 	dal_set_mode_params_update_scaling_on_path(
 			bv->set_mode_params,
 			bv->display_index,
@@ -351,6 +353,7 @@ static bool add_timing_to_candidate_list_with_priority(
 	struct mtp last_mtp;
 	enum timing_3d_format last_mt_3d_fmt;
 	enum timing_3d_format new_mt_3d_fmt;
+
 	if (cl == NULL || mode_timing == NULL) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -435,6 +438,7 @@ static bool is_fid9204hp_ce_mode(const struct mode_info *mode_info)
 {
 	uint32_t i;
 	const struct mode_info *ce_mode_info;
+
 	for (i = 0; i < NUM_FID9204HP_CE_MODES; i++) {
 		ce_mode_info = &best_view_ce_mode_only_fid9204hp_ce_modes[i];
 		if ((mode_info->pixel_width == ce_mode_info->pixel_width) &&
@@ -458,6 +462,7 @@ static enum display_view_importance
 {
 	uint32_t i;
 	const struct mode_info *ce_mode_info;
+
 	for (i = 0; i < NUM_FID9204HP_CE_MODES; i++) {
 		ce_mode_info =  &best_view_ce_mode_only_fid9204hp_ce_modes[i];
 		if (vw->width == ce_mode_info->pixel_width &&
@@ -815,6 +820,7 @@ static bool best_view_single_selected_timing_construct(
 		struct best_view_init_data *bv_init_data)
 {
 	const struct mode_timing *selected_mode_timing;
+
 	if (bv_init_data == NULL ||
 			bv_init_data->mode_timing_list == NULL ||
 			!best_view_construct(bv, bv_init_data))
@@ -928,6 +934,7 @@ static bool match_view_with_identity_timing(
 	struct mtp mtp;
 	struct scaling_support scaling_support;
 	const struct crtc_timing *crtc_timing;
+
 	if (dal_candidate_list_find_matching_view(
 			&bv->identity_candidates,
 			vw,
@@ -1050,6 +1057,7 @@ static bool match_view_with_next_lower_timing(
 	int32_t i;
 	struct scaling_support scaling_support;
 	struct mtp mtp;
+
 	for (i = start_index; i >= 0; i--) {
 		mtp = dal_candidate_list_at_index(&bv->scaled_candidates, i);
 
@@ -1201,6 +1209,7 @@ bool dal_best_view_match_view_to_timing(
 {
 	uint32_t index;
 	bool found = match_view_with_identity_timing(bv, vw, target_list);
+
 	if (!found) {
 		/* Either no timing found, or the timing is OS forced
 		 * may not be able to use,
@@ -1275,8 +1284,7 @@ void dal_best_view_dump_statistics(struct best_view *bv)
 	dal_logger_write(bv->ctx->logger,
 		LOG_MAJOR_MODE_ENUM,
 		LOG_MINOR_MODE_ENUM_BEST_VIEW_CANDIDATES,
-		"Path #%d contains %d supported PathMode combinations."
-		" %d PathModes are supported but not guaranteed\n",
+		"Path #%d contains %d supported PathMode combinations. %d PathModes are supported but not guaranteed\n",
 		bv->display_index,
 		bv->supported_path_mode_cnt,
 		bv->non_guaranteed_path_mode_cnt);
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.c b/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.c
index a42b631..20d2500 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.c
@@ -37,6 +37,7 @@ static bool mtp_less_than(
 {
 	const struct mtp *lhs = lhs_address;
 	const struct mtp *rhs = rhs_address;
+
 	return dal_mode_timing_less_than(lhs->value, rhs->value);
 }
 
@@ -74,6 +75,7 @@ bool dal_candidate_list_insert(
 		const struct mode_timing *mode_timing)
 {
 	struct mtp mtp = { mode_timing };
+
 	return dal_flat_set_insert(&cl->mode_timing_set, &mtp);
 }
 
@@ -97,6 +99,7 @@ bool dal_candidate_list_find_matching_view(
 	const struct mode_info *mode_info;
 	struct mode_timing mt = { { 0 } };
 	struct mtp mtp = { &mt };
+
 	mt.mode_info.pixel_width = vw->width;
 	mt.mode_info.pixel_height = vw->height;
 
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.h b/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.h
index 6111111..286bc3c 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.h
+++ b/drivers/gpu/drm/amd/dal/mode_manager/candidate_list.h
@@ -66,7 +66,6 @@ bool dal_candidate_list_find_matching_view(
 static inline void dal_candidate_list_print_to_log(
 		const struct candidate_list *cl)
 {
-	return;
 }
 
 #endif /*__DAL_CANDIDATE_LIST_H__*/
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_query_validator.c b/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_query_validator.c
index 59b23fd..d317fbe 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_query_validator.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_query_validator.c
@@ -92,6 +92,7 @@ bool dal_cmqv_add_mode_query(
 	uint32_t count =
 		dal_pms_get_path_mode_num(validator->cmv.pms);
 	struct path_mode pm = {};
+
 	for (i = 0; i < topology->disp_path_num; i++) {
 		if (count >= MAX_COFUNC_PATH)
 			return false; /* too many displays */
@@ -119,6 +120,7 @@ void dal_cmqv_update_mode_query(
 {
 	uint32_t i;
 	uint32_t count = dal_pms_get_path_mode_num(validator->cmv.pms);
+
 	for (i = 0; i < count; ++i) {
 		struct mode_query *mq = validator->mode_query[i];
 
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_validator.c b/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_validator.c
index bcfc0eb..6bec135 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_validator.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/cofunctional_mode_validator.c
@@ -53,6 +53,7 @@ static bool validate(struct cofunctional_mode_validator *cmv)
 {
 	uint32_t i;
 	uint32_t mode_count = get_total_mode_count(cmv);
+
 	if (cmv->set_mode_params == NULL) {
 		uint32_t disp_idx[MAX_COFUNC_PATH];
 
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/display_view_solution_container.c b/drivers/gpu/drm/amd/dal/mode_manager/display_view_solution_container.c
index f9190a1..d9d515b 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/display_view_solution_container.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/display_view_solution_container.c
@@ -40,6 +40,7 @@ struct view_solution dal_dvsc_get_view_solution_at_index(
 	uint32_t index)
 {
 	struct view_solution vw_sol;
+
 	view_solution_construct(
 		&vw_sol,
 		&dal_view_info_list_at_index(
@@ -123,6 +124,7 @@ static bool construct(
 	const struct display_view_solution_container_init_data *dvsc_init_data)
 {
 	uint32_t display_index_array[] = { dvsc_init_data->display_index };
+
 	dvsc->display_index = dvsc_init_data->display_index;
 	dvsc->master_view_list = dvsc_init_data->master_view_list;
 	dvsc->bv_flags = dvsc_init_data->bv_flags;
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c
index 2baa54a..91c718f 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_manager.c
@@ -70,6 +70,7 @@ DAL_VECTOR_APPEND(solution_container,
 static void destruct(struct mode_manager *mm)
 {
 	uint32_t i;
+
 	dal_view_info_list_destruct(&mm->master_view_list);
 
 	for (i = 0; i < dal_vector_get_count(&mm->solution_container_list);
@@ -307,6 +308,7 @@ struct mode_query *dal_mode_manager_create_mode_query(
 	struct mode_query_set_init_data mqs_init_data = {0};
 
 	uint32_t i;
+
 	if (topology == NULL) {
 		dal_logger_write(mm->ctx->logger,
 			LOG_MAJOR_MODE_ENUM,
@@ -613,6 +615,7 @@ static void process_display_views(
 {
 	uint32_t i;
 	uint32_t mtl_count = dal_mode_timing_list_get_count(mode_timing_list);
+
 	for (i = 0; i < mtl_count; ++i) {
 		const struct mode_timing *mt =
 			dal_mode_timing_list_get_timing_at_index(
@@ -638,6 +641,7 @@ static void process_display_views(
 
 		{
 			struct view_info vi_sls_compatible = vi;
+
 			if (patch_view_for_sls_compatibility(
 				mm, &vi_sls_compatible))
 				add_display_view(
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_manager_types.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_manager_types.c
index 6e5fd38..6e5845a 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_manager_types.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_manager_types.c
@@ -50,6 +50,7 @@ bool dal_refresh_rate_less_than(
 {
 	unsigned int lhsRefreshRate;
 	unsigned int rhsRefreshRate;
+
 	lhsRefreshRate = lhs->INTERLACED ?
 			(lhs->field_rate / 2) : lhs->field_rate;
 	rhsRefreshRate = rhs->INTERLACED ?
@@ -73,6 +74,7 @@ bool dal_solution_less_than(const void *lhs, const void *rhs)
 	const struct solution *rhs_solution = rhs;
 	struct refresh_rate l_refresh_rate, r_refresh_rate;
 	enum timing_3d_format l_timing_3d_format, r_timing_3d_format;
+
 	refresh_rate_from_mode_info(
 				&l_refresh_rate,
 				&lhs_solution->mode_timing->mode_info);
@@ -104,6 +106,7 @@ uint32_t dal_pixel_format_list_get_count(
 		const struct pixel_format_list *pfl)
 {
 	uint32_t i, count = 0;
+
 	for (i = pfl->set; i > 0; i >>= 1)
 		if ((i & 1) != 0)
 			count += 1;
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_query.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_query.c
index ffc404a..ca857e0 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_query.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_query.c
@@ -57,6 +57,7 @@ bool dal_mode_query_construct(
 
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		enum mode_aspect_ratio aspect;
+
 		path_mode.display_path_index =
 			mode_query_set_get_solution_container_on_path(
 					mq->query_set,
@@ -230,6 +231,7 @@ static bool increment_cofunc_3d_view_it(struct mode_query *mq)
 void increment_cofunc_view_solution_it(struct mode_query *mq)
 {
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		struct view_solution *vs;
 		uint32_t vs_count;
@@ -253,6 +255,7 @@ void increment_cofunc_view_solution_it(struct mode_query *mq)
 static bool increment_cofunc_scaling_support_it(struct mode_query *mq)
 {
 	int32_t i;
+
 	for (i = mq->query_set->num_path - 1; i >= 0; i--) {
 		for (mq->cofunc_scl[i]++;
 			*mq->cofunc_scl[i] != SCALING_TRANSFORMATION_INVALID;
@@ -280,9 +283,11 @@ static bool is_cofunc_view_solution_it_in_range(struct mode_query *mq)
 	uint32_t i;
 	uint32_t valid_solution_idx_cnt;
 	bool all_has_solution;
+
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		struct view_solution *vs = &mq->cur_view_solutions[i];
 		uint32_t view_solution_count = view_solution_get_count(vs);
+
 		while (mq->cur_solution_idxs[i] < view_solution_count) {
 			bool strict_match_3d_view;
 			const struct crtc_timing *crtc_timing;
@@ -417,6 +422,7 @@ static bool is_cur_3d_view_valid(struct mode_query *mq)
 static void reset_cofunc_scaling_support_it(struct mode_query *mq)
 {
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++)
 		mq->cofunc_scl[i] =
 			mode_query_set_get_solution_container_on_path(
@@ -434,6 +440,7 @@ void dal_mode_query_update_validator_entry(
 		uint32_t mode_query_index)
 {
 	bool is_guaranteed;
+
 	dal_memmove(
 		&cofunctional_mode_validator_get_at(
 			validator, validator_index)->view,
@@ -466,6 +473,7 @@ void dal_mode_query_update_validator_entry(
 static void update_cur_path_mode_set(struct mode_query *mq)
 {
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++)
 		dal_mode_query_update_validator_entry(mq, &mq->validator, i, i);
 }
@@ -473,6 +481,7 @@ static void update_cur_path_mode_set(struct mode_query *mq)
 static bool is_cur_scaling_valid(struct mode_query *mq)
 {
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		if (!dal_solution_is_supported(
 			mq->cur_solutions[i],
@@ -544,6 +553,7 @@ bool dal_mode_query_base_select_next_refresh_rate(struct mode_query *mq)
 void dal_mode_query_reset_cofunc_view_solution_it(struct mode_query *mq)
 {
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		mq->cur_solution_idxs[i] = 0;
 		mq->cur_solutions[i] = NULL;
@@ -582,6 +592,7 @@ static void reset_confunc_3d_view_it(struct mode_query *mq)
 static bool increment_render_mode_iterator(struct mode_query *mq)
 {
 	uint32_t view_count = dal_mode_query_set_get_view_count(mq->query_set);
+
 	dal_pixel_format_list_next(&mq->query_set->pixel_format_list_iterator);
 	if (dal_pixel_format_list_get_pixel_format(
 		&mq->query_set->pixel_format_list_iterator)) {
@@ -642,6 +653,7 @@ bool dal_mode_query_select_render_mode(struct mode_query *mq,
 	uint32_t vw_count = dal_mode_query_set_get_view_count(mq->query_set);
 	bool view_found = false;
 	bool found = false;
+
 	mq->valid_iterators.RENDER_MODE = false;
 
 	for (mq->cur_view_idx = 0;
@@ -659,6 +671,7 @@ bool dal_mode_query_select_render_mode(struct mode_query *mq,
 	if (view_found) {
 		if (render_mode->pixel_format != PIXEL_FORMAT_UNINITIALIZED) {
 			enum pixel_format fmt;
+
 			dal_pixel_format_list_reset_iterator(
 				&mq->query_set->pixel_format_list_iterator);
 			fmt = dal_pixel_format_list_get_pixel_format(
@@ -752,6 +765,7 @@ bool dal_mode_query_select_refresh_rate_ex(
 		bool interlaced)
 {
 	uint32_t field_rate = interlaced ? refresh_rate * 2 : refresh_rate;
+
 	dal_mode_query_reset_cofunc_view_solution_it(mq);
 
 	while (dal_mode_query_select_next_refresh_rate(mq)) {
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_allow_pan.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_allow_pan.c
index 7732f7d..c47f68d 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_allow_pan.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_allow_pan.c
@@ -50,6 +50,7 @@ static bool build_cofunc_view_solution_set(struct mode_query *mq)
 			mq->cur_view_solutions[i] = vs;
 		} else {
 			struct view_solution vs_pan;
+
 			if (mq_allow_pan->panning_view_solution_indicies[i]
 				== INVALID_VIEW_SOLUTION_INDEX){
 				BREAK_TO_DEBUGGER();
@@ -230,6 +231,7 @@ void dal_mode_query_allow_pan_post_initialize(struct mode_query *mq)
 			base);
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		uint32_t j;
+
 		mq_allow_pan->panning_view_solution_indicies[i] =
 				INVALID_VIEW_SOLUTION_INDEX;
 
@@ -251,16 +253,17 @@ void dal_mode_query_allow_pan_post_initialize(struct mode_query *mq)
 				mq_allow_pan->panning_view_solution_indicies[i]
 					= j - 1;
 				break;
-			} else
-				if (mq_allow_pan->
-					panning_view_solution_indicies[i] ==
-						INVALID_VIEW_SOLUTION_INDEX &&
-				view_solution_get_display_view_importance(&vs)
-						<= mq->enum_display_view_level)
+			}
 
-					mq_allow_pan->
-					panning_view_solution_indicies[i] =
-							j - 1;
+			if (mq_allow_pan->
+				panning_view_solution_indicies[i] ==
+					INVALID_VIEW_SOLUTION_INDEX &&
+			view_solution_get_display_view_importance(&vs)
+					<= mq->enum_display_view_level)
+
+				mq_allow_pan->
+				panning_view_solution_indicies[i] =
+						j - 1;
 		}
 
 		ASSERT(mq_allow_pan->panning_view_solution_indicies[i] !=
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_no_pan.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_no_pan.c
index d1ed51e..e7fa210 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_no_pan.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_no_pan.c
@@ -32,6 +32,7 @@ bool dal_mode_query_no_pan_build_cofunc_view_solution_set(struct mode_query *mq)
 	bool is_display_view = false;
 	bool is_view_supported = true;
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		struct view_solution vs = get_solution_on_path_by_index(
 			mq,
@@ -92,6 +93,7 @@ static bool mode_query_no_pan_construct(
 static bool are_all_refresh_rates_equal_and_preferred(struct mode_query *mq)
 {
 	uint32_t i;
+
 	for (i = 0; i < mq->query_set->num_path; i++) {
 		ASSERT(mq->cur_solutions[i] != NULL);
 		if (mq->cur_solutions[i]->importance
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.c b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.c
index cc0f076..08ec982 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.c
@@ -45,6 +45,7 @@ struct mode_query_set *dal_mode_query_set_create(
 		struct mode_query_set_init_data *mqs_init_data)
 {
 	struct mode_query_set *mqs = dal_alloc(sizeof(struct mode_query_set));
+
 	if (mqs == NULL)
 		return NULL;
 
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.h b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.h
index a63c496..6bd8713 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.h
+++ b/drivers/gpu/drm/amd/dal/mode_manager/mode_query_set.h
@@ -37,6 +37,7 @@ struct mode_query_set {
 	struct pixel_format_list pixel_format_list_iterator;
 	const struct view_info_list *master_view_info_list;
 	uint32_t num_path;
+
 	const struct display_view_solution_container
 		*solutions[MAX_COFUNC_PATH];
 };
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/solution.c b/drivers/gpu/drm/amd/dal/mode_manager/solution.c
index 69d5620..7de94a0 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/solution.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/solution.c
@@ -127,6 +127,7 @@ static bool solution_less_then(const void *p1, const void *p2)
 bool dal_solution_set_construct(struct solution_set *ss)
 {
 	struct flat_set_init_data data;
+
 	data.capacity = SOLUTION_SET_INITIAL_CAPACITY;
 	data.struct_size = sizeof(struct solution);
 	data.funcs.less_than = solution_less_then;
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/solution.h b/drivers/gpu/drm/amd/dal/mode_manager/solution.h
index 354185f..fb97b11 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/solution.h
+++ b/drivers/gpu/drm/amd/dal/mode_manager/solution.h
@@ -63,6 +63,7 @@ static inline enum solution_importance dal_solution_get_importance(
 static inline bool dal_solution_is_empty(struct solution *solution)
 {
 	uint32_t i;
+
 	for (i = 0; i < NUM_PIXEL_FORMATS; i++)
 		if (solution->scl_support[i])
 			return false;
@@ -105,6 +106,7 @@ static inline bool dal_solution_is_supported(
 		enum scaling_transformation st)
 {
 	uint32_t i = get_support_index_for_pixel_fmt(pf);
+
 	if (i >= NUM_PIXEL_FORMATS) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -118,6 +120,7 @@ static inline bool dal_solution_is_guaranteed(
 		enum scaling_transformation st)
 {
 	uint32_t i = get_support_index_for_pixel_fmt(pf);
+
 	return (sol->scl_support_guaranteed[i] & st) != 0;
 }
 
diff --git a/drivers/gpu/drm/amd/dal/mode_manager/view_solution.c b/drivers/gpu/drm/amd/dal/mode_manager/view_solution.c
index 6eb72dc..200e019 100644
--- a/drivers/gpu/drm/amd/dal/mode_manager/view_solution.c
+++ b/drivers/gpu/drm/amd/dal/mode_manager/view_solution.c
@@ -44,6 +44,7 @@ static bool view_info_list_less_then(const void *lhs, const void *rhs)
 {
 	const struct view_info *lvi = lhs;
 	const struct view_info *rvi = rhs;
+
 	return view_less_then(&lvi->view, &rvi->view);
 }
 
diff --git a/drivers/gpu/drm/amd/dal/timing_service/default_mode_list.c b/drivers/gpu/drm/amd/dal/timing_service/default_mode_list.c
index 815a535..e41ce93 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/default_mode_list.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/default_mode_list.c
@@ -126,6 +126,7 @@ bool default_mode_list_construct(
 		const struct flat_set_init_data *fs_init_data)
 {
 	uint32_t i;
+
 	if (!dal_flat_set_construct(&dml->set, fs_init_data))
 		return false;
 
diff --git a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_list.c b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_list.c
index abf1c68..fd11598 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_list.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_list.c
@@ -94,6 +94,7 @@ struct mode_timing_list *dal_mode_timing_list_create(
 	};
 
 	struct mode_timing_list *mtl = dal_alloc(sizeof(*mtl));
+
 	if (mtl == NULL)
 		return NULL;
 
@@ -211,8 +212,7 @@ const struct mode_timing *dal_mode_timing_list_get_single_selected_mode_timing(
 		dal_logger_write(mtl->ctx->logger,
 			LOG_MAJOR_MODE_ENUM,
 			LOG_MINOR_MODE_ENUM_TS_LIST_BUILD,
-			"Failed to find valid timing. "
-			"Returned timing may be not supported");
+			"Failed to find valid timing. Returned timing may be not supported");
 		return dal_mode_timing_list_get_timing_at_index(
 				mtl,
 				entries_num - 1);
diff --git a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea770.c b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea770.c
index d7b5a07..792eca1 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea770.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea770.c
@@ -136,6 +136,7 @@ static bool get_timing_for_mode(
 		struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
+
 	if (crtc_timing == NULL)
 		return false;
 	for (i = 0; i < MODE_COUNT; ++i)
@@ -150,6 +151,7 @@ static bool get_timing_for_mode(
 static bool is_timing_in_standard(const struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
+
 	for (i = 0; i < MODE_COUNT; ++i)
 		if (dal_crtc_timing_is_equal(
 				crtc_timing,
diff --git a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861d.c b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861d.c
index 3c21306..60c28e1 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861d.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861d.c
@@ -804,6 +804,7 @@ static bool get_timing_for_mode(
 		struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
+
 	if (crtc_timing == NULL)
 		return false;
 	for (i = 0; i < MODE_COUNT; ++i)
@@ -827,6 +828,7 @@ static bool is_timing_in_standard(const struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
 	struct crtc_timing modified_timing = *crtc_timing;
+
 	modified_timing.timing_3d_format = TIMING_3D_FORMAT_NONE;
 	modified_timing.display_color_depth = DISPLAY_COLOR_DEPTH_UNDEFINED;
 	modified_timing.pixel_encoding = PIXEL_ENCODING_UNDEFINED;
@@ -856,6 +858,7 @@ static enum aspect_ratio get_aspect_ratio_for_timing(
 		const struct crtc_timing *crtc_timing)
 {
 	uint32_t index;
+
 	for (index = 0; index < MODE_COUNT; index++) {
 		if (crtc_timing->vic == mode_timings[index].mode_timing.
 								crtc_timing.vic)
diff --git a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861e.c b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861e.c
index ed0d236..96b001e 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861e.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_cea861e.c
@@ -848,6 +848,7 @@ static bool get_timing_for_mode(
 		struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
+
 	if (crtc_timing == NULL)
 		return false;
 	for (i = 0; i < MODE_COUNT; ++i)
@@ -871,6 +872,7 @@ static bool is_timing_in_standard(const struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
 	struct crtc_timing modified_timing = *crtc_timing;
+
 	modified_timing.timing_3d_format = TIMING_3D_FORMAT_NONE;
 	modified_timing.display_color_depth = DISPLAY_COLOR_DEPTH_UNDEFINED;
 	modified_timing.pixel_encoding = PIXEL_ENCODING_UNDEFINED;
@@ -900,6 +902,7 @@ static enum aspect_ratio get_aspect_ratio_for_timing(
 		const struct crtc_timing *crtc_timing)
 {
 	uint32_t index;
+
 	for (index = 0; index < MODE_COUNT; index++) {
 		if (crtc_timing->vic == mode_timings[index].mode_timing.
 								crtc_timing.vic)
diff --git a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_dmt.c b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_dmt.c
index 06d884a..b903a91 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_dmt.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_dmt.c
@@ -705,6 +705,7 @@ static bool get_timing_for_mode(
 		struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
+
 	if (crtc_timing == NULL)
 		return false;
 	for (i = 0; i < MODE_COUNT; ++i)
@@ -725,6 +726,7 @@ static bool get_timing_for_mode(
 static bool is_timing_in_standard(const struct crtc_timing *timing)
 {
 	uint32_t i;
+
 	for (i = 0; i < MODE_COUNT; ++i)
 		if (dal_crtc_timing_is_equal(
 				timing,
diff --git a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_hdmi_vic.c b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_hdmi_vic.c
index a54b4fa..15678a7 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_hdmi_vic.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/mode_timing_source_hdmi_vic.c
@@ -115,6 +115,7 @@ static bool get_timing_for_mode(
 		struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
+
 	if (crtc_timing == NULL)
 		return false;
 	for (i = 0; i < MODE_COUNT; ++i)
@@ -136,6 +137,7 @@ static bool is_timing_in_standard(const struct crtc_timing *crtc_timing)
 {
 	uint32_t i;
 	struct crtc_timing modified_timing = *crtc_timing;
+
 	modified_timing.timing_3d_format = TIMING_3D_FORMAT_NONE;
 	modified_timing.display_color_depth = DISPLAY_COLOR_DEPTH_UNDEFINED;
 	modified_timing.pixel_encoding = PIXEL_ENCODING_UNDEFINED;
diff --git a/drivers/gpu/drm/amd/dal/timing_service/timing_service.c b/drivers/gpu/drm/amd/dal/timing_service/timing_service.c
index a098565..2b0e072 100644
--- a/drivers/gpu/drm/amd/dal/timing_service/timing_service.c
+++ b/drivers/gpu/drm/amd/dal/timing_service/timing_service.c
@@ -117,6 +117,7 @@ struct mode_timing_list *dal_timing_service_get_mode_timing_list_for_path(
 	struct mode_timing_list **mtl;
 	uint32_t i;
 	uint32_t size = dal_vector_get_count(&ts->mtl_vec);
+
 	for (i = 0; i < size; ++i) {
 		mtl = dal_vector_at_index(&ts->mtl_vec, i);
 		if (dal_mode_timing_list_get_display_index(*mtl) ==
@@ -132,13 +133,13 @@ static bool create_mode_timing_list_for_path(
 		uint32_t display_index)
 {
 	struct mode_timing_list *timing_list;
+
 	if (dal_timing_service_get_mode_timing_list_for_path(ts, display_index)
 								!= NULL) {
 		dal_logger_write(ts->dal_context->logger,
 			LOG_MAJOR_MODE_ENUM,
 			LOG_MINOR_MODE_ENUM_TS_LIST_BUILD,
-			"Attempted to create a new ModeTimingList "
-			"for an existing display_index");
+			"Attempted to create a new ModeTimingList for an existing display_index");
 		return false;
 	}
 
@@ -173,6 +174,7 @@ bool dal_timing_service_add_mode_timing_to_path(
 		const struct mode_timing *mode_timing)
 {
 	struct mode_timing_list *timing_list;
+
 	if (mode_timing == NULL) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -312,6 +314,7 @@ bool dal_timing_service_get_mode_timing_for_video_code(
 	struct mode_timing_source_funcs *mts_cea861 =
 			ts->timing_sources[TIMING_STANDARD_CEA861];
 	const struct mode_timing *mt;
+
 	if (mode_timing == NULL || mts_cea861 == NULL || video_code == 0) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -851,6 +854,7 @@ struct timing_service *dal_timing_service_create(
 		bool support_cea861e)
 {
 	struct timing_service *ts;
+
 	ts = dal_alloc(sizeof(struct timing_service));
 
 	if (ts == NULL)
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
index 4a445db..7f4d879 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_detection_mgr.c
@@ -365,6 +365,7 @@ static enum dal_irq_source get_irq_source(
 
 	case TM_INTERRUPT_TYPE_HOTPLUG: {
 		struct irq *hpd_gpio;
+
 		hpd_gpio = dal_adapter_service_obtain_hpd_irq(tm_dm->as,
 				connector);
 
@@ -933,6 +934,7 @@ static void detect_sink_caps(
 	if (detection_status->connected &&
 		detection_status->detected_signal == SIGNAL_TYPE_DISPLAY_PORT) {
 		struct link_service *link_service;
+
 		link_service = tm_resource_mgr_find_link_service(
 				tm_dm->resource_mgr,
 				display_path,
@@ -1425,6 +1427,7 @@ static void reconnect_link_services(
 		/*connect link service*/
 		for (i = 0; i < link_count; ++i) {
 			enum signal_type current_signal;
+
 			current_signal =
 				dal_display_path_sink_signal_to_link_signal(
 					display_path, connect_signal, i);
@@ -1672,6 +1675,7 @@ static void register_interrupt(
 
 	case TM_INTERRUPT_TYPE_HOTPLUG: {
 		struct display_sink_capability sink_cap;
+
 		int_params.int_context = INTERRUPT_LOW_IRQ_CONTEXT;
 		int_params.irq_source = irq_src;
 
@@ -2019,6 +2023,7 @@ void dal_tm_detection_mgr_release_hw(
 
 	for (i = 0; i < tm_dm->irq_registrations_num; ++i) {
 		uint8_t j;
+
 		for (j = 0; j < TM_INTERRUPT_TYPE_COUNT; ++j) {
 			enum tm_interrupt_type irq_type;
 
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_internal_types.h b/drivers/gpu/drm/amd/dal/topology/tm_internal_types.h
index df16dda..be3486f 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_internal_types.h
+++ b/drivers/gpu/drm/amd/dal/topology/tm_internal_types.h
@@ -49,51 +49,51 @@
 #define TM_IFACE_TRACE() \
 	dal_logger_write(dal_context->logger, \
 		LOG_MAJOR_TM, LOG_MINOR_TM_IFACE_TRACE, \
-			"%s():line:%d\n", __func__, __LINE__);
+			"%s():line:%d\n", __func__, __LINE__)
 
 #define TM_RESOURCES(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_RESOURCES, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_RESOURCES, __VA_ARGS__)
 
 #define TM_ENCODER_CTL(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_ENCODER_CTL, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_ENCODER_CTL, __VA_ARGS__)
 
 #define TM_ENG_ASN(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_ENG_ASN, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_ENG_ASN, __VA_ARGS__)
 
 #define TM_CONTROLLER_ASN(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_CONTROLLER_ASN, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_CONTROLLER_ASN, __VA_ARGS__)
 
 #define TM_PWR_GATING(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_PWR_GATING, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_PWR_GATING, __VA_ARGS__)
 
 #define TM_BUILD_DSP_PATH(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_BUILD_DSP_PATH, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_BUILD_DSP_PATH, __VA_ARGS__)
 
 #define TM_INFO(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_INFO, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_INFO, __VA_ARGS__)
 
 #define TM_DISPLAY_DETECT(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_DISPLAY_DETECT, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_DISPLAY_DETECT, __VA_ARGS__)
 
 #define TM_LINK_SRV(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_LINK_SRV, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_LINK_SRV, __VA_ARGS__)
 
 #define TM_COFUNC_PATH(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_TM, LOG_MINOR_TM_COFUNC_PATH, __VA_ARGS__);
+		LOG_MAJOR_TM, LOG_MINOR_TM_COFUNC_PATH, __VA_ARGS__)
 
 #define TM_HPD_IRQ(...) \
 	dal_logger_write(dal_context->logger, \
-		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_INTERRUPT, __VA_ARGS__);
+		LOG_MAJOR_HW_TRACE, LOG_MINOR_HW_TRACE_INTERRUPT, __VA_ARGS__)
 
 #define TM_MPO(...) \
 	dal_logger_write(dal_context->logger, \
@@ -102,7 +102,7 @@
 #define TM_NOT_IMPLEMENTED()  \
 	dal_logger_write(dal_context->logger, \
 		LOG_MAJOR_TM, LOG_MINOR_TM_NOT_IMPLEMENTED, \
-				"%s()\n", __func__);
+				"%s()\n", __func__)
 
 #define TM_ASSERT(condition) \
 	do { \
@@ -125,7 +125,7 @@
 #define TM_WARNING(...) \
 	dal_logger_write(dal_context->logger, LOG_MAJOR_WARNING, \
 		LOG_MINOR_COMPONENT_TOPOLOGY_MANAGER, \
-		__VA_ARGS__);
+		__VA_ARGS__)
 
 /*******
  Enums
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource.c b/drivers/gpu/drm/amd/dal/topology/tm_resource.c
index 3e65892..2f83627 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource.c
@@ -112,6 +112,7 @@ static void connector_destroy(struct tm_resource **resource)
 static void engine_destroy(struct tm_resource **resource)
 {
 	struct tm_resource_engine_info *info;
+
 	info = TO_ENGINE_INFO(*resource);
 	dal_free((*resource)->res_private);
 	dal_free(info);
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c b/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c
index a02b8d8..6fbd621 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_builder.c
@@ -149,8 +149,7 @@ static void init_gpu_static_clocks(struct tm_resource_builder *tm_rb,
 		dal_logger_write(tm_rb->dal_context->logger,
 			LOG_MAJOR_WARNING,
 			LOG_MINOR_COMPONENT_GPU,
-			"Failed to get BM Static Clock Ranges!"\
-			" Will be using default values.\n");
+			"Failed to get BM Static Clock Ranges! Will be using default values.\n");
 	} else {
 		struct gpu_clock_info gpu_clk_info;
 
@@ -461,8 +460,7 @@ static void tmrb_set_display_path_properties(struct tm_resource_builder *tm_rb,
 
 			if (!aud_support.bits.HDMI_AUDIO_NATIVE) {
 				/* this should not happen */
-				TM_ERROR("%s: HDMI connector exists, but HDMI"\
-						"native audio not supported",
+				TM_ERROR("%s: HDMI connector exists, but HDMI native audio not supported",
 						__func__);
 			}
 		} else {
@@ -524,8 +522,8 @@ static enum tm_result tmrb_update_device_tag(
 	conn_object_id = dal_connector_get_graphics_object_id(connector);
 
 	if (conn_object_id.type != OBJECT_TYPE_CONNECTOR) {
-		TM_ERROR("%s: This path doesn't have connector,"\
-			" something is wrong!\n", __func__);
+		TM_ERROR("%s: This path doesn't have connector, something is wrong!\n",
+				__func__);
 		return TM_RESULT_FAILURE;
 	}
 
@@ -540,8 +538,7 @@ static enum tm_result tmrb_update_device_tag(
 
 		dal_display_path_set_device_tag(display_path, device_tag);
 
-		TM_BUILD_DSP_PATH("  Device tag \"fake\" [%u:%u] was set"\
-				" on display path [0x%p].\n",
+		TM_BUILD_DSP_PATH("  Device tag \"fake\" [%u:%u] was set on display path [0x%p].\n",
 			device_tag.dev_id.device_type,
 			device_tag.dev_id.enum_id,
 			display_path);
@@ -580,8 +577,7 @@ static enum tm_result tmrb_update_device_tag(
 
 		dal_display_path_set_device_tag(display_path, device_tag);
 
-		TM_BUILD_DSP_PATH("  Device tag \"CF\" [%u:%u] was set on "\
-				"display path [0x%p].\n",
+		TM_BUILD_DSP_PATH("  Device tag \"CF\" [%u:%u] was set on display path [0x%p].\n",
 				device_tag.dev_id.device_type,
 				device_tag.dev_id.enum_id,
 				display_path);
@@ -598,8 +594,7 @@ static enum tm_result tmrb_update_device_tag(
 
 		dal_display_path_set_device_tag(display_path, device_tag);
 
-		TM_BUILD_DSP_PATH("  Device tag \"wireless\" [%u:%u] was"\
-				" set on display path [0x%p].\n",
+		TM_BUILD_DSP_PATH("  Device tag \"wireless\" [%u:%u] was set on display path [0x%p].\n",
 				device_tag.dev_id.device_type,
 				device_tag.dev_id.enum_id,
 				display_path);
@@ -630,8 +625,7 @@ static enum tm_result tmrb_update_device_tag(
 						device_tag);
 
 				TM_BUILD_DSP_PATH(
-					"  Device tag [%u:%u] was"
-					" set on display path [0x%p].\n",
+					"  Device tag [%u:%u] was set on display path [0x%p].\n",
 						device_tag.dev_id.device_type,
 						device_tag.dev_id.enum_id,
 						display_path);
@@ -857,8 +851,8 @@ static enum tm_result tmrb_activate_display_path_resource(
 		 * is no TM Resource which 'knows' about it. Possible scenario
 		 * is BIOS parser created an object but returns invalid
 		 * GO pointer for it. */
-		TM_ERROR("%s: No corresponding TM Resource for a Graphics"\
-				" Object!\n", __func__);
+		TM_ERROR("%s: No corresponding TM Resource for a Graphics Object!\n",
+				__func__);
 		return TM_RESULT_FAILURE;
 	}
 
@@ -918,8 +912,7 @@ static void tmrb_clone_mst_paths(struct tm_resource_builder *tm_rb,
 			continue;
 		}
 
-		TM_BUILD_DSP_PATH("  Creating branch-MST display path"\
-				" from [0x%p]. New Display path is [0x%p]\n",
+		TM_BUILD_DSP_PATH("  Creating branch-MST display path from [0x%p]. New Display path is [0x%p]\n",
 				root_display_path, branch_display_path);
 
 		/* copy signal from source to new display path */
@@ -1002,9 +995,8 @@ static void tmrb_clone_mst_paths(struct tm_resource_builder *tm_rb,
 
 				if (NULL == link_service) {
 					success = false;
-					TM_ERROR("%s: Failed to GET Root"\
-						" Link Service for link"\
-						" index:%d!\n", __func__,
+					TM_ERROR("%s: Failed to GET Root Link Service for link index:%d!\n",
+							__func__,
 						link_index);
 					break;
 				}
@@ -1016,9 +1008,8 @@ static void tmrb_clone_mst_paths(struct tm_resource_builder *tm_rb,
 						link_index,
 						link_service)) {
 					success = false;
-					TM_ERROR("%s: Failed to add Root"\
-						" Link Service for branch"\
-						" link index:%d!\n", __func__,
+					TM_ERROR("%s: Failed to add Root Link Service for branch link index:%d!\n",
+							__func__,
 						link_index);
 					break;
 				}
@@ -1041,8 +1032,7 @@ static void tmrb_clone_mst_paths(struct tm_resource_builder *tm_rb,
 			tm_rb->num_of_display_paths++;
 		} else {
 
-			TM_BUILD_DSP_PATH("  Destroying unsuccessful"\
-				" branch-MST of display path [0x%p].\n",
+			TM_BUILD_DSP_PATH("  Destroying unsuccessful branch-MST of display path [0x%p].\n",
 					branch_display_path);
 
 			dcs = dal_display_path_get_dcs(branch_display_path);
@@ -1106,6 +1096,7 @@ static void tmrb_create_display_path(
 		i = init_data->num_of_encoders;
 		do {
 			enum tm_result tm_result;
+
 			i--; /* "index" is less-by-one than "number" */
 
 			tm_result = tmrb_add_link(tm_rb, display_path,
@@ -1188,8 +1179,8 @@ static void tmrb_create_display_path(
 
 				dal_display_path_set_dcs(display_path, dcs);
 			} else {
-				TM_ERROR("%s: DDC service is"\
-					" not initialised!\n", __func__);
+				TM_ERROR("%s: DDC service is not initialised!\n",
+						__func__);
 				success = false;
 			}
 
@@ -1235,8 +1226,7 @@ static void tmrb_create_display_path(
 					dal_encoder_get_graphics_object_id(
 						encoder)) != TM_RESULT_SUCCESS){
 				success = false;
-				TM_ERROR("%s:Failed to activate Encoder"\
-						" resource for link:%d!\n",
+				TM_ERROR("%s:Failed to activate Encoder resource for link:%d!\n",
 					__func__, i);
 				break;
 			}
@@ -1248,8 +1238,7 @@ static void tmrb_create_display_path(
 				dal_audio_get_graphics_object_id(audio)) !=
 					TM_RESULT_SUCCESS){
 				success = false;
-				TM_ERROR("%s:Failed to activate Audio"\
-						" resource for link:%d!\n",
+				TM_ERROR("%s:Failed to activate Audio resource for link:%d!\n",
 					__func__, i);
 				break;
 			}
@@ -1302,8 +1291,7 @@ static void tmrb_create_display_path(
 	} /* if (success) */
 
 	if (success) {
-		TM_BUILD_DSP_PATH("  Display path [0x%p] at index %u"\
-			" was successfully created.\n",
+		TM_BUILD_DSP_PATH("  Display path [0x%p] at index %u was successfully created.\n",
 			display_path, tm_rb->num_of_display_paths - 1);
 	} else {
 		struct dcs *dcs;
@@ -1393,8 +1381,8 @@ static void tmrb_build_link_chain(struct tm_resource_builder *tm_rb,
 				this_object_id, source);
 
 		if (false == dal_graphics_object_id_is_valid(src_object_id)) {
-			TM_ERROR("%s: dal_adapter_service_get_src_obj()"\
-				" returned invalid src!\n", __func__);
+			TM_ERROR("%s: dal_adapter_service_get_src_obj() returned invalid src!\n",
+					__func__);
 		}
 
 		/* For each 'source' object (at this level) the starting
@@ -1404,6 +1392,7 @@ static void tmrb_build_link_chain(struct tm_resource_builder *tm_rb,
 		switch (src_object_id.type) {
 		case OBJECT_TYPE_ENCODER: {
 			struct encoder *enc;
+
 			tm_resource_src = tm_resource_mgr_find_resource(
 					tm_rb->tm_rm, src_object_id);
 
@@ -1437,8 +1426,8 @@ static void tmrb_build_link_chain(struct tm_resource_builder *tm_rb,
 			}
 
 			if (NULL == tm_resource_src) {
-				TM_ERROR("%s: Failed to add Encoder Resource"\
-						" to display path", __func__);
+				TM_ERROR("%s: Failed to add Encoder Resource to display path",
+						__func__);
 			} else {
 				init_data->
 					encoders[init_data->num_of_encoders] =
@@ -1482,8 +1471,7 @@ static void tmrb_build_single_display_path(struct tm_resource_builder *tm_rb,
 			connector_index);
 
 	if (connector_obj_id.type != OBJECT_TYPE_CONNECTOR) {
-		TM_WARNING("%s: Invalid Connector ObjectID from"\
-				" Adapter Service for connector index:%d!\n",
+		TM_WARNING("%s: Invalid Connector ObjectID from Adapter Service for connector index:%d!\n",
 				__func__, connector_index);
 		return;
 	}
@@ -1501,8 +1489,8 @@ static void tmrb_build_single_display_path(struct tm_resource_builder *tm_rb,
 		dal_tm_resource_connector_create(connector));
 
 	if (NULL == tm_resource) {
-		TM_WARNING("TM_RB: failed to add connector resource "\
-				"for connector index: %d\n", connector_index);
+		TM_WARNING("TM_RB: failed to add connector resource for connector index: %d\n",
+				connector_index);
 		return;
 	}
 
@@ -1517,8 +1505,8 @@ static void tmrb_build_single_display_path(struct tm_resource_builder *tm_rb,
 		dal_ddc_service_create(&ddc_init_data);
 
 	if (NULL == TO_CONNECTOR_INFO(tm_resource)->ddc_service) {
-		TM_WARNING("TM_RB: failed to create DDC service "\
-			"for connector index:%d!\n", connector_index);
+		TM_WARNING("TM_RB: failed to create DDC service for connector index:%d!\n",
+				connector_index);
 		return;
 	}
 
@@ -1544,8 +1532,8 @@ static void tmrb_build_single_display_path(struct tm_resource_builder *tm_rb,
 		tmrb_build_link_chain(tm_rb, &path_init_data);
 	}
 
-	TM_BUILD_DSP_PATH("Finished building display paths"\
-			" for connector index: %d.\n", connector_index);
+	TM_BUILD_DSP_PATH("Finished building display paths for connector index: %d.\n",
+			connector_index);
 }
 
 /**
@@ -1601,6 +1589,7 @@ enum tm_result tm_resource_builder_add_fake_display_paths(
 		struct tm_resource_builder *tm_rb)
 {
 	struct dal_context *dal_context = tm_rb->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return TM_RESULT_SUCCESS;
 }
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
index 3e647e3..6aaa11e 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_resource_mgr.c
@@ -191,6 +191,7 @@ static enum tm_result tm_resource_mgr_construct(struct tm_resource_mgr *tm_rm)
 {
 	struct dal_context *dal_context = tm_rm->dal_context;
 	struct flat_set_init_data init;
+
 	init.capacity = TM_RM_MAX_NUM_OF_RESOURCES;
 	init.funcs.less_than = tm_rm_less_than;
 	init.struct_size = sizeof(struct tm_resource *);
@@ -548,6 +549,7 @@ struct tm_resource_mgr *tm_resource_mgr_clone(
 
 		{
 			struct flat_set_init_data init_data;
+
 			init_data.capacity = TM_RM_MAX_NUM_OF_RESOURCES;
 			init_data.funcs.less_than = tm_rm_less_than;
 			init_data.struct_size = sizeof(struct tm_resource *);
@@ -954,8 +956,7 @@ static bool tmrm_resources_available(struct tm_resource_mgr *tm_rm,
 	if (TM_RES_REF_CNT_GET(tm_resource) > 0
 			&& !tm_resource->flags.mst_resource) {
 
-		TM_WARNING("%s: Connector resource NOT available!"\
-				" ref_count:%d\n",
+		TM_WARNING("%s: Connector resource NOT available! ref_count:%d\n",
 				__func__,
 				TM_RES_REF_CNT_GET(tm_resource));
 		return false;
@@ -976,8 +977,7 @@ static bool tmrm_resources_available(struct tm_resource_mgr *tm_rm,
 		/* Primary resource is busy */
 		if (TM_RES_REF_CNT_GET(tm_resource) > 0 &&
 				!tm_resource->flags.mst_resource) {
-			TM_WARNING("%s: Encoder resource NOT available!"\
-					" ref_count:%d, Link Index:%d\n",
+			TM_WARNING("%s: Encoder resource NOT available! ref_count:%d, Link Index:%d\n",
 				__func__,
 				TM_RES_REF_CNT_GET(tm_resource),
 				i);
@@ -1002,8 +1002,7 @@ static bool tmrm_resources_available(struct tm_resource_mgr *tm_rm,
 		if (tm_paired_resource != NULL &&
 			TM_RES_REF_CNT_GET(tm_paired_resource) > 0) {
 			/* Paired resource required, but is busy */
-			TM_WARNING("%s: Paired resource is busy!"\
-					" Link Index:%d\n",
+			TM_WARNING("%s: Paired resource is busy! Link Index:%d\n",
 					__func__, i);
 			return false;
 		}
@@ -1415,14 +1414,12 @@ static void tmrm_do_controller_power_gating(
 	if (enable == true) {
 
 		if (false == tm_rm->pipe_power_gating_enabled) {
-			TM_PWR_GATING("Pipe PG Feature disabled"\
-						" --> not gating.\n");
+			TM_PWR_GATING("Pipe PG Feature disabled  --> not gating.\n");
 			return;
 		}
 
 		if (ref_counter != 0) {
-			TM_WARNING("%s: Can NOT power gate with non-zero "\
-					"reference counter:%d!\n",
+			TM_WARNING("%s: Can NOT power gate with non-zero reference counter:%d!\n",
 				__func__, ref_counter);
 			return;
 		}
@@ -1431,8 +1428,7 @@ static void tmrm_do_controller_power_gating(
 		 * It must have logical state of "not power gated". */
 		if (TO_CONTROLLER_INFO(tm_resource)->power_gating_state !=
 				TM_POWER_GATE_STATE_OFF) {
-			TM_WARNING("%s: Invalid state:%d!"\
-				" (expected TM_POWER_GATE_STATE_OFF)\n",
+			TM_WARNING("%s: Invalid state:%d! (expected TM_POWER_GATE_STATE_OFF)\n",
 				__func__,
 				TO_CONTROLLER_INFO(tm_resource)->
 				power_gating_state);
@@ -1456,8 +1452,7 @@ static void tmrm_do_controller_power_gating(
 
 		if (ref_counter != 1) {
 			/* Un-gate only once! */
-			TM_WARNING("%s: Can NOT un-gate with reference "\
-					"counter '%d' note equal to one!\n",
+			TM_WARNING("%s: Can NOT un-gate with reference counter '%d' note equal to one!\n",
 				__func__, ref_counter);
 			return;
 		}
@@ -1465,8 +1460,7 @@ static void tmrm_do_controller_power_gating(
 		/* Un-gate the pipe, if NOT un-gated already. */
 		if (TO_CONTROLLER_INFO(tm_resource)->power_gating_state !=
 				TM_POWER_GATE_STATE_ON) {
-			TM_WARNING("%s: Invalid state:%d!"\
-				" (expected TM_POWER_GATE_STATE_ON)\n",
+			TM_WARNING("%s: Invalid state:%d! (expected TM_POWER_GATE_STATE_ON)\n",
 				__func__,
 				TO_CONTROLLER_INFO(tm_resource)->
 				power_gating_state);
@@ -1589,8 +1583,7 @@ void dal_tmrm_acquire_controller(
 	if (1 == tm_resource_ref_counter_increment(tm_rm, tm_resource)
 			&& update_hw_state_needed(method)) {
 
-		TM_CONTROLLER_ASN("Path[%02d]: "\
-				"Acquired: Controller: %s(%d)\n",
+		TM_CONTROLLER_ASN("Path[%02d]: Acquired: Controller: %s(%d)\n",
 			display_index,
 			tm_utils_go_id_to_str(GRPH_ID(tm_resource)),
 			dal_graphics_object_id_get_controller_id(
@@ -1823,8 +1816,7 @@ void dal_tmrm_release_controller(
 					tm_rsrc,
 					NULL);
 
-			TM_CONTROLLER_ASN("Path[%02d]: "\
-				"Released: Controller: %s(%d)\n",
+			TM_CONTROLLER_ASN("Path[%02d]: Released: Controller: %s(%d)\n",
 				display_index,
 				tm_utils_go_id_to_str(GRPH_ID(tm_rsrc)),
 				dal_graphics_object_id_get_controller_id(
@@ -2589,8 +2581,8 @@ enum tm_result tm_resource_mgr_attach_audio_to_display_path(
 			!path_props.bits.IS_DP_AUDIO_SUPPORTED) ||
 	(dal_is_hdmi_signal(sig_type) &&
 			!path_props.bits.IS_HDMI_AUDIO_SUPPORTED)) {
-		TM_WARNING("%s: can't attach audio - no audio support"\
-				" on path!\n ", __func__);
+		TM_WARNING("%s: can't attach audio - no audio support on path!\n ",
+				__func__);
 		return TM_RESULT_FAILURE;
 	}
 
@@ -2736,14 +2728,14 @@ enum tm_result tm_resource_mgr_setup_link_storage(
 
 	tm_rm->link_services = link_services;
 
-	if (tm_rm->link_services != NULL && requested_num_of_cells > 0) {
-		tm_rm->link_services_number_of_paths = number_of_paths;
-		return TM_RESULT_SUCCESS;
-	} else {
+	if (tm_rm->link_services == NULL || requested_num_of_cells == 0) {
 		tm_rm->link_services_number_of_paths = 0;
 		TM_ERROR("%s: no link services were allocated!\n", __func__);
 		return TM_RESULT_FAILURE;
 	}
+
+	tm_rm->link_services_number_of_paths = number_of_paths;
+	return TM_RESULT_SUCCESS;
 }
 
 /**
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_subsets_cache.c b/drivers/gpu/drm/amd/dal/topology/tm_subsets_cache.c
index d57e944..e62e9f7 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_subsets_cache.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_subsets_cache.c
@@ -442,30 +442,30 @@ void dal_update_display_mapping(
 				tm_subsets_cache->
 					dp2_cache_mapping[display_index] = i;
 				break;
-			} else {
-				/* check if current index is set,
-				 * but disconnected, we can reuse it
-				 */
-				if (!tm_utils_test_bit(
-					&tm_subsets_cache->connected,
-					tm_subsets_cache->
-						cache_2dp_mapping[i])) {
+			}
 
-					uint32_t previous_index =
-						tm_subsets_cache->
-						cache_2dp_mapping[i];
-					tm_subsets_cache->
-						cache_2dp_mapping[i] =
-							display_index;
-					tm_subsets_cache->
-						dp2_cache_mapping[
-						display_index] = i;
+			/* check if current index is set,
+			 * but disconnected, we can reuse it
+			 */
+			if (!tm_utils_test_bit(
+				&tm_subsets_cache->connected,
+				tm_subsets_cache->
+					cache_2dp_mapping[i])) {
+
+				uint32_t previous_index =
 					tm_subsets_cache->
-						dp2_cache_mapping[
-						previous_index] =
-						MAPPING_NOT_SET;
-					break;
-				}
+					cache_2dp_mapping[i];
+				tm_subsets_cache->
+					cache_2dp_mapping[i] =
+						display_index;
+				tm_subsets_cache->
+					dp2_cache_mapping[
+					display_index] = i;
+				tm_subsets_cache->
+					dp2_cache_mapping[
+					previous_index] =
+					MAPPING_NOT_SET;
+				break;
 			}
 		}
 		/* whatever happened above, we need
@@ -536,6 +536,7 @@ static bool all_connected(
 	uint32_t array_size)
 {
 	uint32_t i;
+
 	for (i = 0; i < array_size; ++i) {
 		if (!tm_utils_test_bit(
 				&tm_subsets_cache->connected,
@@ -606,6 +607,7 @@ static uint32_t find_index(
 		 * smallest such element, and so on.
 		 */
 		uint32_t j = 0;
+
 		while (j < array_size &&
 			tm_subsets_cache->dp2_cache_mapping[displays[j]] <
 			next_possible_min) {
diff --git a/drivers/gpu/drm/amd/dal/topology/tm_utils.c b/drivers/gpu/drm/amd/dal/topology/tm_utils.c
index b64cc0f..92ced77 100644
--- a/drivers/gpu/drm/amd/dal/topology/tm_utils.c
+++ b/drivers/gpu/drm/amd/dal/topology/tm_utils.c
@@ -397,9 +397,8 @@ const char *tm_utils_engine_priority_to_str(enum tm_engine_priority priority)
 
 const char *tm_utils_transmitter_id_to_str(struct graphics_object_id encoder)
 {
-	if (encoder.type != OBJECT_TYPE_ENCODER) {
+	if (encoder.type != OBJECT_TYPE_ENCODER)
 		return "\b";
-	}
 
 	switch (dal_graphics_object_id_get_encoder_id(encoder)) {
 	case ENCODER_ID_INTERNAL_UNIPHY: {
@@ -549,19 +548,19 @@ const char *tm_utils_ddc_line_to_str(enum channel_id line)
 
 const char *tm_utils_device_type_to_str(enum dal_device_type device)
 {
-    switch (device)
-    {
-        case DEVICE_TYPE_LCD:      return "LCD";
-        case DEVICE_TYPE_CRT:      return "CRT";
-        case DEVICE_TYPE_DFP:      return "DFP";
-        case DEVICE_TYPE_CV:       return "CV";
-        case DEVICE_TYPE_TV:       return "TV";
-        case DEVICE_TYPE_CF:       return "CF";
-        case DEVICE_TYPE_WIRELESS: return "Wireless";
-        default:                  break;
-    }
-
-    return "Unknown";
+	switch (device) {
+	case DEVICE_TYPE_LCD:		return "LCD";
+	case DEVICE_TYPE_CRT:		return "CRT";
+	case DEVICE_TYPE_DFP:		return "DFP";
+	case DEVICE_TYPE_CV:		return "CV";
+	case DEVICE_TYPE_TV:		return "TV";
+	case DEVICE_TYPE_CF:		return "CF";
+	case DEVICE_TYPE_WIRELESS:	return "Wireless";
+	default:
+		break;
+	}
+
+	return "Unknown";
 }
 
 
@@ -589,11 +588,11 @@ bool tm_utils_is_edid_connector_type_valid_with_signal_type(
 		 that may convert digital signal to analog. In this case
 		 EDID connector type will be analog. Here we need to check
 		 the dongle type and switch to analog signal */
-		if (dongle_type == DISPLAY_DONGLE_DP_VGA_CONVERTER) {
+		if (dongle_type == DISPLAY_DONGLE_DP_VGA_CONVERTER)
 			is_signal_digital = false;
-		} else {
+		else
 			is_signal_digital = true;
-		}
+
 	}
 		break;
 	case SIGNAL_TYPE_RGB:
@@ -633,6 +632,7 @@ enum tm_utils_display_type tm_utils_signal_to_display_type(
 	enum signal_type signal)
 {
 	enum tm_utils_display_type res = DISPLAY_DFP;
+
 	switch (signal) {
 	case SIGNAL_TYPE_DVI_SINGLE_LINK:
 	case SIGNAL_TYPE_DVI_SINGLE_LINK1:
@@ -853,7 +853,7 @@ enum signal_type tm_utils_get_downgraded_signal_type(
 		hdmi1 = false;
 		break;
 	default:
-		return signal; //No need to downgrade the signal
+		return signal; /* No need to downgrade the signal */
 
 	};
 
@@ -867,20 +867,19 @@ enum signal_type tm_utils_get_downgraded_signal_type(
 		hdmi2 = false;
 		break;
 	default:
-		return signal; //No need to downgrade the signal
+		return signal; /* No need to downgrade the signal */
 
 	};
 
 	dl3 = dl1 && dl2;
 	hdmi3 = hdmi1 && hdmi2;
 
-	if (dl3 && !hdmi3) {
+	if (dl3 && !hdmi3)
 		signal = SIGNAL_TYPE_DVI_DUAL_LINK;
-	} else if (!dl3 && hdmi3) {
+	else if (!dl3 && hdmi3)
 		signal = SIGNAL_TYPE_HDMI_TYPE_A;
-	} else if (!dl3 && !hdmi3) {
+	else if (!dl3 && !hdmi3)
 		signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
-	}
 
 	return signal;
 }
@@ -1097,6 +1096,7 @@ uint32_t dal_tm_calc_subset_get_value(
 bool dal_tm_calc_subset_step(struct tm_calc_subset *subset)
 {
 	uint32_t next_value;
+
 	if (subset->subset_size == 0 ||
 		subset->subset_size > subset->max_subset_size)
 		return false;
diff --git a/drivers/gpu/drm/amd/dal/topology/topology.c b/drivers/gpu/drm/amd/dal/topology/topology.c
index aa920ed..242da89 100644
--- a/drivers/gpu/drm/amd/dal/topology/topology.c
+++ b/drivers/gpu/drm/amd/dal/topology/topology.c
@@ -215,10 +215,10 @@ static bool construct(struct topology_mgr_init_data *init_data,
 			init_err = true;
 			TM_ERROR("tm_resource_mgr_create() failed!\n");
 			break;
-		} else {
-			tm->tm_rm = tm_rm;
 		}
 
+		tm->tm_rm = tm_rm;
+
 		/* create/initialise Detection Manager */
 		tm_dm_init_data.dal_context = init_data->dal_context;
 		tm_dm_init_data.as = init_data->adapter_srv;
@@ -231,10 +231,10 @@ static bool construct(struct topology_mgr_init_data *init_data,
 			TM_ERROR("dal_tm_detection_mgr_create() failed!\n");
 			init_err = true;
 			break;
-		} else {
-			tm->tm_dm = tm_dm;
 		}
 
+		tm->tm_dm = tm_dm;
+
 		/* create/initialise Resource Builder */
 		tm_rb_init_data.dal_context = tm->dal_context;
 		tm_rb_init_data.adapter_service = init_data->adapter_srv;
@@ -250,15 +250,14 @@ static bool construct(struct topology_mgr_init_data *init_data,
 			TM_ERROR("tm_resource_builder_create() failed!\n");
 			init_err = true;
 			break;
-		} else {
-			tm->tm_rb = tm_rb;
 		}
 
+		tm->tm_rb = tm_rb;
+
 	} while (0);
 
-	if (false == init_err) {
+	if (false == init_err)
 		init_err = (tm_init_during_construct(tm) != TM_RESULT_SUCCESS);
-	}
 
 	if (true == init_err) {
 		/* Clean-up.
@@ -276,10 +275,10 @@ static bool construct(struct topology_mgr_init_data *init_data,
 			tm_resource_builder_destroy(&tm->tm_rb);
 
 		return false;
-	} else {
-		/* All O.K. */
-		return true;
 	}
+
+	/* All O.K. */
+	return true;
 }
 
 static struct display_path *tm_get_display_path_at_index(
@@ -334,6 +333,7 @@ static void destruct(struct topology_mgr *tm)
 
 	if (tm->display_paths) {
 		uint32_t i;
+
 		for (i = 0; i < tm_get_display_path_count(tm); i++) {
 			struct display_path *display_path =
 				tm_get_display_path_at_index(tm, i);
@@ -378,19 +378,18 @@ struct topology_mgr *dal_tm_create(struct topology_mgr_init_data *init_data)
 		return NULL;
 	}
 
-	if (construct(init_data, tm) == true)
-		return tm;
-	else {
+	if (!construct(init_data, tm) == true) {
 		dal_free(tm);
 		return NULL;
 	}
+
+	return tm;
 }
 
 void dal_tm_destroy(struct topology_mgr **tm)
 {
-	if (!tm || !(*tm)) {
+	if (!tm || !(*tm))
 		return;
-	}
 
 	/***************************************
 	 * deallocate all subcomponents of TM
@@ -422,6 +421,7 @@ enum tm_result dal_tm_acquire_display_path(struct topology_mgr *tm,
 {
 	struct display_path *display_path;
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_IFACE_TRACE();
 
 	if (!tm_is_display_index_valid(tm, display_index, __func__))
@@ -1538,12 +1538,11 @@ static void tm_power_up_encoder(struct topology_mgr *tm,
 		if (ENCODER_RESULT_OK != dal_encoder_update_implementation(
 				enc_input, &context)) {
 			/* TODO: should we return error to caller? */
-			TM_ERROR("%s: failed to update encoder"\
-				" implementation!\n", __func__);
+			TM_ERROR("%s: failed to update encoder implementation!\n",
+					__func__);
 		}
 
-		TM_ENCODER_CTL("%s:[UpdateImpl]: %s, on Active Path=%u,"\
-				" Link=%u, Engine=%s, Signal=%s",
+		TM_ENCODER_CTL("%s:[UpdateImpl]: %s, on Active Path=%u, Link=%u, Engine=%s, Signal=%s",
 			__func__,
 			tm_utils_transmitter_id_to_str(
 				dal_encoder_get_graphics_object_id(
@@ -1738,9 +1737,7 @@ static void tm_power_down_encoder(struct topology_mgr *tm,
 						__func__);
 
 			TM_ENCODER_CTL(
-				"TM Encoder PowerDown [Supported Engine]: %s,"
-				" Active Path=%u, Link=%u,"
-				" Engine=%s, Signal=%s",
+				"TM Encoder PowerDown [Supported Engine]: %s, Active Path=%u, Link=%u, Engine=%s, Signal=%s",
 				tm_utils_transmitter_id_to_str(
 						enc_input_obj_id),
 				dal_display_path_get_display_index(
@@ -1768,9 +1765,7 @@ static void tm_power_down_encoder(struct topology_mgr *tm,
 						__func__);
 
 			TM_ENCODER_CTL(
-				"TM Encoder PowerDown [1st Valid Engine]: %s,"
-				" Active Path=%u, Link=%u,"
-				" Engine=%s, Signal=%s",
+				"TM Encoder PowerDown [1st Valid Engine]: %s, Active Path=%u, Link=%u, Engine=%s, Signal=%s",
 				tm_utils_transmitter_id_to_str(
 						enc_input_obj_id),
 				dal_display_path_get_display_index(
@@ -1795,9 +1790,7 @@ static void tm_power_down_encoder(struct topology_mgr *tm,
 					__func__);
 
 		TM_ENCODER_CTL(
-			"TM Encoder PowerDown [Input Engine]: %s,"
-			" Active Path=%u, Link=%u,"
-			" Engine=%s, Signal=%s",
+			"TM Encoder PowerDown [Input Engine]: %s, Active Path=%u, Link=%u, Engine=%s, Signal=%s",
 			tm_utils_transmitter_id_to_str(
 					enc_input_obj_id),
 			dal_display_path_get_display_index(
@@ -1860,8 +1853,7 @@ static void tm_power_down_controller(struct topology_mgr *tm,
 	} else {
 		/* Resource is power gated and we could not
 		 * access it to PowerDown(). */
-		TM_PWR_GATING("Could not PowerDown Controller Id:%d because it"\
-			"is power gated.",
+		TM_PWR_GATING("Could not PowerDown Controller Id:%d because it is power gated.",
 			dal_controller_get_graphics_object_id(
 				info->controller));
 	}
@@ -2135,6 +2127,7 @@ enum tm_result dal_tm_power_down_hw(struct topology_mgr *tm)
 		for (i = controllers->start; i < controllers->end; i++) {
 
 			struct controller *controller = NULL;
+
 			tm_resource =
 				tm_resource_mgr_enum_resource(
 					tm->tm_rm, i);
@@ -2232,6 +2225,7 @@ void dal_tm_reset_vbios_controllers(struct topology_mgr *tm)
 /*ResetControllersForFSDOSToWindows()*/
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 }
 
@@ -2441,8 +2435,8 @@ static void arbitrate_audio_on_disconnect(struct topology_mgr *tm,
 		if (tm->attached_hdmi_num > 0)
 			tm->attached_hdmi_num--;
 		else
-			TM_ERROR("%s: can NOT reduce attached_hdmi_num"\
-					" below zero!\n", __func__);
+			TM_ERROR("%s: can NOT reduce attached_hdmi_num below zero!\n",
+					__func__);
 	}
 }
 
@@ -2744,16 +2738,15 @@ static void tm_update_on_connect_link_services_and_encoder_implementation(
 		if (ENCODER_RESULT_OK != dal_encoder_update_implementation(
 				encoder, &context)) {
 			/* should never happen */
-			TM_ERROR("%s:dal_encoder_update_implementation()"\
-					" failed!\n", __func__);
+			TM_ERROR("%s:dal_encoder_update_implementation() failed!\n",
+					__func__);
 		}
 
 		id = dal_encoder_get_graphics_object_id(encoder);
 		display_index = dal_display_path_get_display_index(
 				display_path);
 
-		TM_ENCODER_CTL("OnConnect[UpdateImpl]: Transmitter=%s,"\
-				" Path=%u, LinkIdx=%u, Engine=%s, Signal=%s\n",
+		TM_ENCODER_CTL("OnConnect[UpdateImpl]: Transmitter=%s, Path=%u, LinkIdx=%u, Engine=%s, Signal=%s\n",
 				tm_utils_transmitter_id_to_str(id),
 				display_index,
 				link_idx,
@@ -3314,6 +3307,7 @@ void dal_tm_do_detection_for_connector(struct topology_mgr *tm,
 		uint32_t connector_index)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 }
 
@@ -3379,6 +3373,7 @@ uint32_t dal_tm_do_complete_detection(
 enum tm_result dal_tm_do_asynchronous_detection(struct topology_mgr *tm)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return TM_RESULT_FAILURE;
 }
@@ -3388,6 +3383,7 @@ void dal_tm_toggle_hw_base_light_sleep(struct topology_mgr *tm,
 		bool enable)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 }
 
@@ -3460,6 +3456,7 @@ void dal_tm_enable_accelerated_mode(struct topology_mgr *tm)
 void dal_tm_block_interrupts(struct topology_mgr *tm, bool blocking)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 }
 
@@ -3467,6 +3464,7 @@ void dal_tm_block_interrupts(struct topology_mgr *tm, bool blocking)
 enum tm_result dal_tm_setup_embedded_display_path(struct topology_mgr *tm)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return TM_RESULT_FAILURE;
 }
@@ -3585,6 +3583,7 @@ bool dal_tm_is_sync_output_available_for_display_path(
 		enum sync_source sync_output)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return false;
 }
@@ -3630,6 +3629,7 @@ struct gpu_clock_interface *dal_tm_get_gpu_clock_interface(
 		struct topology_mgr *tm)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return NULL;
 }
@@ -3640,6 +3640,7 @@ struct ddc *dal_tm_get_dpcd_access_interface(
 		uint32_t display_index)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return NULL;
 }
@@ -3650,6 +3651,7 @@ struct ddc *dal_tm_get_ddc_access_interface_by_index(
 		uint32_t display_index)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return NULL;
 }
@@ -3660,6 +3662,7 @@ struct ddc *dal_tm_get_ddc_access_interface_by_connector(
 		struct graphics_object_id connector)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return NULL;
 }
@@ -3668,6 +3671,7 @@ struct ddc *dal_tm_get_ddc_access_interface_by_connector(
 uint32_t dal_tm_get_num_functional_controllers(struct topology_mgr *tm)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return 0;
 }
@@ -3685,6 +3689,7 @@ enum dal_video_power_state dal_tm_get_current_power_state(
 		struct topology_mgr *tm)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_IFACE_TRACE();
 	return tm->current_power_state;
 }
@@ -3694,6 +3699,7 @@ enum dal_video_power_state dal_tm_get_previous_power_state(
 		struct topology_mgr *tm)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_IFACE_TRACE();
 	return tm->previous_power_state;
 }
@@ -3714,6 +3720,7 @@ enum tm_result dal_tm_set_signal_type(struct topology_mgr *tm,
 		enum signal_type signal)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return TM_RESULT_FAILURE;
 }
@@ -3810,6 +3817,7 @@ enum tm_result dal_tm_detect_and_notify_target_connection(
 		enum tm_detection_method method)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 	return TM_RESULT_FAILURE;
 }
@@ -3820,6 +3828,7 @@ void dal_tm_detect_notify_connectivity_change(struct topology_mgr *tm,
 		bool connected)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 }
 
@@ -3830,6 +3839,7 @@ void dal_tm_notify_capability_change(struct topology_mgr *tm,
 		enum tm_reenum_modes_reason reason)
 {
 	struct dal_context *dal_context = tm->dal_context;
+
 	TM_NOT_IMPLEMENTED();
 }
 
@@ -4128,8 +4138,8 @@ static enum tm_result create_gpu_resources(struct topology_mgr *tm)
 	rc = tm_resource_builder_create_gpu_resources(tm->tm_rb);
 
 	if (TM_RESULT_FAILURE == rc) {
-		TM_ERROR("%s: tm_resource_builder_create_gpu_resources()"\
-				" failed!\n", __func__);
+		TM_ERROR("%s: tm_resource_builder_create_gpu_resources() failed!\n",
+				__func__);
 	}
 
 	return rc;
@@ -4349,8 +4359,7 @@ static enum tm_result tm_update_single_encoder_implementation(
 
 	dsp_index = dal_display_path_get_display_index(display_path);
 
-	TM_ENCODER_CTL("Encoder Update Impl:"\
-			"%s, Path=%u, Link=%u, Engine=%s, Signal=%s\n",
+	TM_ENCODER_CTL("Encoder Update Impl: %s, Path=%u, Link=%u, Engine=%s, Signal=%s\n",
 			transmitter_str,
 			dsp_index,
 			link_index,
@@ -5291,6 +5300,7 @@ void dal_tm_handle_sink_connectivity_change(
 {
 	struct display_path *display_path;
 	struct dal_context *dal_context = tm->dal_context;
+
 	display_path = tm_get_display_path_at_index(tm, display_index);
 
 	if (NULL == display_path) {
-- 
1.9.1

