From a97488b25a9f6b203a211a630f1c55119d161464 Mon Sep 17 00:00:00 2001
From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Thu, 13 Oct 2016 15:52:56 -0400
Subject: [PATCH 1306/1722] drm/amd/dal: report correct watermark clock ranges
 to pplib

Change-Id: I0dcf540b4a55ccefd53c31978d0d6cd0b46fdbe2
Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c |  15 +-
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    | 248 ++++-----------------
 2 files changed, 44 insertions(+), 219 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
index 0022f7b..915ee89 100644
--- a/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
+++ b/drivers/gpu/drm/amd/dal/dc/calcs/bandwidth_calcs.c
@@ -2685,10 +2685,9 @@ bool bw_calcs(struct dc_context *ctx,
 				urgent_watermark[9], bw_int_to_fixed(1000)));
 
 		if (dceip->version != BW_CALCS_VERSION_CARRIZO) {
-			((struct bw_calcs_vbios *)vbios)->low_sclk = mid4_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid1_sclk = mid4_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid2_sclk = mid4_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid3_sclk = mid4_sclk;
+			((struct bw_calcs_vbios *)vbios)->low_sclk = mid3_sclk;
+			((struct bw_calcs_vbios *)vbios)->mid1_sclk = mid3_sclk;
+			((struct bw_calcs_vbios *)vbios)->mid2_sclk = mid3_sclk;
 			calculate_bandwidth(dceip, vbios, data);
 
 			calcs_output->nbp_state_change_wm_ns[0].b_mark =
@@ -2783,7 +2782,6 @@ bool bw_calcs(struct dc_context *ctx,
 			((struct bw_calcs_vbios *)vbios)->low_sclk = low_sclk;
 			((struct bw_calcs_vbios *)vbios)->mid1_sclk = mid1_sclk;
 			((struct bw_calcs_vbios *)vbios)->mid2_sclk = mid2_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid3_sclk = mid3_sclk;
 			((struct bw_calcs_vbios *)vbios)->low_yclk = mid_yclk;
 			calculate_bandwidth(dceip, vbios, data);
 
@@ -2885,10 +2883,9 @@ bool bw_calcs(struct dc_context *ctx,
 			((struct bw_calcs_vbios *)vbios)->mid6_sclk = high_sclk;
 		} else {
 			((struct bw_calcs_vbios *)vbios)->low_yclk = mid_yclk;
-			((struct bw_calcs_vbios *)vbios)->low_sclk = mid4_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid1_sclk = mid4_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid2_sclk = mid4_sclk;
-			((struct bw_calcs_vbios *)vbios)->mid3_sclk = mid4_sclk;
+			((struct bw_calcs_vbios *)vbios)->low_sclk = mid3_sclk;
+			((struct bw_calcs_vbios *)vbios)->mid1_sclk = mid3_sclk;
+			((struct bw_calcs_vbios *)vbios)->mid2_sclk = mid3_sclk;
 		}
 
 		calculate_bandwidth(dceip, vbios, data);
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 5cd46cd..d506622 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -963,7 +963,7 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 {
 	struct dm_pp_clock_levels_with_latency eng_clks = {0};
 	struct dm_pp_clock_levels_with_latency mem_clks = {0};
-	struct dm_pp_wm_sets_with_clock_ranges wm_clocks = {0};
+	struct dm_pp_wm_sets_with_clock_ranges clk_ranges = {0};
 
 	/*do system clock*/
 	dm_pp_get_clock_levels_by_type_with_latency(
@@ -994,13 +994,18 @@ static void bw_calcs_data_update_from_pplib(struct core_dc *dc)
 			DM_PP_CLOCK_TYPE_MEMORY_CLK,
 			&mem_clks);
 
+	/* we don't need to call PPLIB for validation clock since they
+	 * also give us the highest sclk and highest mclk (UMA clock).
+	 * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):
+	 * YCLK = UMACLK*m_memoryTypeMultiplier
+	 */
 	dc->bw_vbios.low_yclk = bw_frc_to_fixed(
 		mem_clks.data[0].clocks_in_khz * MEMORY_TYPE_MULTIPLIER, 1000);
 	dc->bw_vbios.mid_yclk = bw_frc_to_fixed(
-mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
+		mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
 	dc->bw_vbios.high_yclk = bw_frc_to_fixed(
-mem_clks.data[mem_clks.num_levels-1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
+		mem_clks.data[mem_clks.num_levels-1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 		1000);
 
 	/* Now notify PPLib/SMU about which Watermarks sets they should select
@@ -1008,226 +1013,49 @@ mem_clks.data[mem_clks.num_levels-1].clocks_in_khz * MEMORY_TYPE_MULTIPLIER,
 	 * Memory clock member variables for Watermarks calculations for each
 	 * Watermark Set
 	 */
-
-	/* default expected case: engineClkInfoWithLatency.numLevels == 8
-	 * && memoryClkInfoWithLatency.numLevels == 3
-	 */
-	wm_clocks.num_wm_sets = 4;
-	wm_clocks.wm_clk_ranges[0].wm_set_id = WM_SET_A;
-	wm_clocks.wm_clk_ranges[0].wm_min_eng_clk_in_khz =
+	clk_ranges.num_wm_sets = 4;
+	clk_ranges.wm_clk_ranges[0].wm_set_id = WM_SET_A;
+	clk_ranges.wm_clk_ranges[0].wm_min_eng_clk_in_khz =
 			eng_clks.data[0].clocks_in_khz;
-	wm_clocks.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
-			eng_clks.data[3].clocks_in_khz - 1;
-	wm_clocks.wm_clk_ranges[0].wm_min_memg_clk_in_khz =
+	clk_ranges.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
+			eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;
+	clk_ranges.wm_clk_ranges[0].wm_min_memg_clk_in_khz =
 			mem_clks.data[0].clocks_in_khz;
-	wm_clocks.wm_clk_ranges[0].wm_max_mem_clk_in_khz =
-			mem_clks.data[1].clocks_in_khz - 1;
-
-	/* TODO  TODO TODO  : below is for DWB. Will be-revisted later */
-	/* this GFX E clock is used for Watermark Set A and DWB Watermark
-	 * Set B calculations
-	 */
-	/* m_wmSetClocks.wmSetEngineClocks[WMSetA].clockInKHz =
-	 * m_wmDWBSetBEngineClock = eng_clks.data[0].clocks_in_khz;
-	 */
-	/* this M clock is used for Watermark Set A and DWB Watermark Set B
-	 * calculations
-	 */
-	/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].clockInKHz =
-	 * m_wmDWBSetBMemoryClock = mem_clks.data[0].clocks_in_khz;
-	 */
-	/* this GFX E clock is used for Watermark Set A and DWB Watermark Set
-	 *B calculations
-	 */
-	/* m_wmSetClocks.wmSetEngineClocks[WMSetA].latencyInUs =
-	 * eng_clks.data[0].latency_in_us;
-	 */
-	/* this M clock is used for Watermark Set A and DWB Watermark Set B
-	 * calculations
-	 */
-	/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].latencyInUs =
-	 * mem_clks.data[0].latency_in_us;
-	 */
+	clk_ranges.wm_clk_ranges[0].wm_max_mem_clk_in_khz =
+			mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;
 
-	wm_clocks.wm_clk_ranges[1].wm_set_id = WM_SET_B;
-	wm_clocks.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
-			eng_clks.data[3].clocks_in_khz;
+	clk_ranges.wm_clk_ranges[1].wm_set_id = WM_SET_B;
+	clk_ranges.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
+			eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;
 	/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */
-	wm_clocks.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;
-	wm_clocks.wm_clk_ranges[1].wm_min_memg_clk_in_khz =
+	clk_ranges.wm_clk_ranges[1].wm_max_eng_clk_in_khz = 5000000;
+	clk_ranges.wm_clk_ranges[1].wm_min_memg_clk_in_khz =
 			mem_clks.data[0].clocks_in_khz;
-	wm_clocks.wm_clk_ranges[1].wm_max_mem_clk_in_khz =
-			mem_clks.data[1].clocks_in_khz - 1;
+	clk_ranges.wm_clk_ranges[1].wm_max_mem_clk_in_khz =
+			mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz - 1;
 
-	wm_clocks.wm_clk_ranges[2].wm_set_id = WM_SET_C;
-	wm_clocks.wm_clk_ranges[2].wm_min_eng_clk_in_khz =
+	clk_ranges.wm_clk_ranges[2].wm_set_id = WM_SET_C;
+	clk_ranges.wm_clk_ranges[2].wm_min_eng_clk_in_khz =
 			eng_clks.data[0].clocks_in_khz;
-	wm_clocks.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
-			eng_clks.data[3].clocks_in_khz - 1;
-	wm_clocks.wm_clk_ranges[2].wm_min_memg_clk_in_khz =
-			mem_clks.data[1].clocks_in_khz;
+	clk_ranges.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
+			eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz - 1;
+	clk_ranges.wm_clk_ranges[2].wm_min_memg_clk_in_khz =
+			mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;
 	/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */
-	wm_clocks.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;
+	clk_ranges.wm_clk_ranges[2].wm_max_mem_clk_in_khz = 5000000;
 
-	wm_clocks.wm_clk_ranges[3].wm_set_id = WM_SET_D;
-	wm_clocks.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
-			eng_clks.data[3].clocks_in_khz;
+	clk_ranges.wm_clk_ranges[3].wm_set_id = WM_SET_D;
+	clk_ranges.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
+			eng_clks.data[eng_clks.num_levels*3/8].clocks_in_khz;
 	/* 5 GHz instead of data[7].clockInKHz to cover Overdrive */
-	wm_clocks.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;
-	wm_clocks.wm_clk_ranges[3].wm_min_memg_clk_in_khz =
-			mem_clks.data[1].clocks_in_khz;
+	clk_ranges.wm_clk_ranges[3].wm_max_eng_clk_in_khz = 5000000;
+	clk_ranges.wm_clk_ranges[3].wm_min_memg_clk_in_khz =
+			mem_clks.data[mem_clks.num_levels>>1].clocks_in_khz;
 	/* 5 GHz instead of data[2].clockInKHz to cover Overdrive */
-	wm_clocks.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;
-
-	/* need to adjust above entries if engineClkInfoWithLatency.numLevels
-	 * != 8 does not need to adjust if memoryClkInfoWithLatency.numLevels
-	 * != 3
-	 */
-	switch (eng_clks.num_levels) {
-	case 8:
-	case 7:
-	default:
-		break;
-
-	case 6:
-	case 5:
-	case 4:
-		wm_clocks.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
-				eng_clks.data[2].clocks_in_khz - 1;
-		wm_clocks.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
-				eng_clks.data[2].clocks_in_khz;
-
-		/* this GFX E clock is used for Watermark Set B calculations
-		 * m_wmSetClocks.wmSetEngineClocks[WMSetB].clockInKHz =
-		 * eng_clks.data[2].clockInKHz;
-		 */
-
-		wm_clocks.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
-				eng_clks.data[2].clocks_in_khz - 1;
-		wm_clocks.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
-				eng_clks.data[2].clocks_in_khz;
-
-		/* this GFX E clock is used for Watermark Set D and DWB
-		 * Watermark Set A calculations
-		 * m_wmSetClocks.wmSetEngineClocks[WMSetD].clockInKHz =
-		 * m_wmDWBSetAEngineClock = eng_clks.data[2].clockInKHz;
-		 */
-		break;
-
-	case 3:
-	case 2:
-		wm_clocks.wm_clk_ranges[0].wm_max_eng_clk_in_khz =
-				eng_clks.data[1].clocks_in_khz - 1;
-		wm_clocks.wm_clk_ranges[1].wm_min_eng_clk_in_khz =
-				eng_clks.data[1].clocks_in_khz;
-
-		/* this GFX E clock is used for Watermark Set B calculations
-		 * m_wmSetClocks.wmSetEngineClocks[WMSetB].clockInKHz =
-		 * eng_clks.data[1].clockInKHz;
-		 */
-
-		wm_clocks.wm_clk_ranges[2].wm_max_eng_clk_in_khz =
-				eng_clks.data[1].clocks_in_khz - 1;
-		wm_clocks.wm_clk_ranges[3].wm_min_eng_clk_in_khz =
-				eng_clks.data[1].clocks_in_khz;
-
-		/* this GFX E clock is used for Watermark Set D and DWB
-		 * Watermark Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetEngineClocks[WMSetD].clockInKHz =
-		 * m_wmDWBSetAEngineClock = eng_clks.data[1].clockInKHz;
-		 */
-		break;
-	}
-
-	/* use same memory clock and latency for all 4 watermark levels if we
-	 * only have one MCLK reported
-	 */
-	if (mem_clks.num_levels == 1) {
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].clockInKHz  =
-		 * m_wmDWBSetBMemoryClock = 250000;
-		 */
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetA].latencyInUs = 45; */
-
-		wm_clocks.wm_clk_ranges[WM_SET_A].wm_min_memg_clk_in_khz =
-				250000;
-		wm_clocks.wm_clk_ranges[WM_SET_A].wm_max_mem_clk_in_khz =
-				mem_clks.data[0].clocks_in_khz - 1;
-
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetB].clockInKHz
-		 *  = 250000;
-		 */
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetB].latencyInUs = 45; */
-
-		wm_clocks.wm_clk_ranges[WM_SET_B].wm_min_memg_clk_in_khz =
-				250000;
-		wm_clocks.wm_clk_ranges[WM_SET_B].wm_max_mem_clk_in_khz =
-				mem_clks.data[0].clocks_in_khz - 1;
-
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetC].clockInKHz =
-		 * memoryClkInfoWithLatency.data[0].clockInKHz;
-		 */
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetC].latencyInUs =
-		 * memoryClkInfoWithLatency.data[0].latencyInMicros;
-		 */
-
-		wm_clocks.wm_clk_ranges[WM_SET_C].wm_min_memg_clk_in_khz =
-				mem_clks.data[0].clocks_in_khz;
-		wm_clocks.wm_clk_ranges[WM_SET_C].wm_max_mem_clk_in_khz =
-				5000000;
-
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetD].clockInKHz  =
-		 * m_wmDWBSetAMemoryClock =
-		 * memoryClkInfoWithLatency.data[0].clockInKHz;
-		 */
-		/* this M clock is used for Watermark Set D and DWB Watermark
-		 * Set A calculations
-		 */
-		/* m_wmSetClocks.wmSetMemoryClocks[WMSetD].latencyInUs =
-		 * memoryClkInfoWithLatency.data[0].latencyInMicros;
-		 */
-
-		wm_clocks.wm_clk_ranges[WM_SET_D].wm_min_memg_clk_in_khz =
-				mem_clks.data[0].clocks_in_khz;
-		wm_clocks.wm_clk_ranges[WM_SET_D].wm_max_mem_clk_in_khz =
-				5000000;
-	}
+	clk_ranges.wm_clk_ranges[3].wm_max_mem_clk_in_khz = 5000000;
 
 	/* Notify PP Lib/SMU which Watermarks to use for which clock ranges */
-	dm_pp_notify_wm_clock_changes(dc->ctx, &wm_clocks);
-
-	/* we don't need to call PPLIB for validation clock any more since they
-	 * also give us the highest sclk and highest mclk (UMA clock).
-	 * ALSO always convert UMA clock (from PPLIB)  to YCLK (HW formula):
-	 * YCLK = UMACLK*m_memoryTypeMultiplier
-	 */
-	/* m_validationMemoryClockInKHz  =
-	 * m_clockLevels.memoryClocksInKHz[m_clockLevels.numMemclkLevels - 1];
-	 */
-	/* m_validationEngineClockInKHz  =
-	 * m_clockLevels.engineClocksInKHz[m_clockLevels.numEngclkLevels - 1];
-	 */
+	dm_pp_notify_wm_clock_changes(dc->ctx, &clk_ranges);
 }
 
 
-- 
2.7.4

