From 3fc3a3f8d5ebccb260165b6519258bc9af267c94 Mon Sep 17 00:00:00 2001
From: Mykola Lysenko <mykola.lysenko@amd.com>
Date: Tue, 9 Jun 2015 03:14:05 -0400
Subject: [PATCH 324/343] amd/dal: added taps validation against lb
 capabilities

Taps could get lower after this verification

Signed-off-by: Mykola Lysenko <mykola.lysenko@amd.com>
Reviewed-by: Eagle Yeh <eagle.yeh@amd.com>
Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
---
 drivers/gpu/drm/amd/dal/bios/bios_parser.c         |  18 +-
 .../amd/dal/controller/dce110/line_buffer_dce110.c |  88 ++++++--
 .../amd/dal/controller/dce110/line_buffer_dce110.h |   2 +-
 .../dal/controller/dce110/line_buffer_v_dce110.c   |  42 +++-
 drivers/gpu/drm/amd/dal/controller/line_buffer.c   |  41 ++++
 drivers/gpu/drm/amd/dal/controller/line_buffer.h   |  13 +-
 .../gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c    |  33 ++-
 .../dal/hw_sequencer/hw_sequencer_adjustments.c    |   7 +-
 .../amd/dal/hw_sequencer/hw_sequencer_parameters.c | 247 ++++++++++++++++++++-
 .../amd/dal/hw_sequencer/hw_sequencer_parameters.h |   4 +-
 .../drm/amd/dal/include/bandwidth_manager_types.h  |  10 +-
 .../drm/amd/dal/include/hw_sequencer_interface.h   |   2 +-
 .../drm/amd/dal/include/line_buffer_interface.h    |   8 +-
 drivers/gpu/drm/amd/dal/include/scaler_types.h     |   7 +-
 14 files changed, 458 insertions(+), 64 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/bios/bios_parser.c b/drivers/gpu/drm/amd/dal/bios/bios_parser.c
index 047748f..e54224e 100644
--- a/drivers/gpu/drm/amd/dal/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/dal/bios/bios_parser.c
@@ -1125,9 +1125,11 @@ static enum bp_result get_ss_info_v3_1(
 	uint32_t index,
 	struct spread_spectrum_info *ss_info)
 {
-	ATOM_ASIC_INTERNAL_SS_INFO_V3 *ssTableHeaderInclude;
+	ATOM_ASIC_INTERNAL_SS_INFO_V3 *ss_table_header_include;
 	ATOM_ASIC_SS_ASSIGNMENT_V3 *tbl;
-	uint32_t tableSize, i, tableIndex = 0;
+	uint32_t table_size;
+	uint32_t i;
+	uint32_t table_index = 0;
 
 	if (!ss_info)
 		return BP_RESULT_BADINPUT;
@@ -1135,23 +1137,23 @@ static enum bp_result get_ss_info_v3_1(
 	if (!DATA_TABLES(ASIC_InternalSS_Info))
 		return BP_RESULT_UNSUPPORTED;
 
-	ssTableHeaderInclude = GET_IMAGE(ATOM_ASIC_INTERNAL_SS_INFO_V3,
+	ss_table_header_include = GET_IMAGE(ATOM_ASIC_INTERNAL_SS_INFO_V3,
 		DATA_TABLES(ASIC_InternalSS_Info));
-	tableSize = (ssTableHeaderInclude->sHeader.usStructureSize
+	table_size = (ss_table_header_include->sHeader.usStructureSize
 		- sizeof(ATOM_COMMON_TABLE_HEADER))
 				/ sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);
 
 	tbl = (ATOM_ASIC_SS_ASSIGNMENT_V3 *)
-		&ssTableHeaderInclude->asSpreadSpectrum[0];
+		&ss_table_header_include->asSpreadSpectrum[0];
 
 	dal_memset(ss_info, 0, sizeof(struct spread_spectrum_info));
 
-	for (i = 0; i < tableSize; i++) {
+	for (i = 0; i < table_size; i++) {
 		if (tbl[i].ucClockIndication != (uint8_t) id)
 			continue;
 
-		if (tableIndex != index) {
-			tableIndex++;
+		if (table_index != index) {
+			table_index++;
 			continue;
 		}
 		/* VBIOS introduced new defines for Version 3, same values as
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c
index b23397c..406126b 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.c
@@ -154,7 +154,7 @@ bool dal_line_buffer_dce110_get_pixel_storage_depth(
 	/* default value */
 	display_depth = dal_line_buffer_display_bpp_to_lb_depth(display_bpp);
 
-	if (lb->capabilites & display_depth) {
+	if (lb->caps & display_depth) {
 		/*we got the match lb and display bpp*/
 		*depth = display_depth;
 	} else {
@@ -162,7 +162,7 @@ bool dal_line_buffer_dce110_get_pixel_storage_depth(
 		uint32_t i;
 		uint32_t max_depth = LB_PIXEL_DEPTH_36BPP;
 		for (i = display_depth; i <= max_depth; i <<= 1) {
-			if (i & lb->capabilites) {
+			if (i & lb->caps) {
 				*depth = i;
 				break;
 			}
@@ -294,7 +294,7 @@ static bool set_pixel_storage_depth(
 		set_reg_field_value(value, 0, LB_DATA_FORMAT, ALPHA_EN);
 		dal_write_reg(
 				base->dal_context, lb->lbx_data_format, value);
-		if (!(lb->capabilites & depth)) {
+		if (!(lb->caps & depth)) {
 			/*we should use unsupported capabilities
 			 *  unless it is required by w/a*/
 			dal_logger_write(base->dal_context->logger,
@@ -350,17 +350,17 @@ static bool enable_power_gating(
 	/* Calculate maximum number of lines*/
 	num_lines_max = LB_ENTRIES_TOTAL_NUMBER / pitch;
 	/* DCE 11.0 LB line calculation, scalar enabled case*/
-	if (lb_config->v_taps > 1) {
+	if (lb_config->taps.v_taps > 1) {
 		struct fixed32_32 scale_ratio = dal_fixed32_32_from_fraction(
 			lb_config->src_height, lb_config->dst_height);
 
 		uint32_t vsr_ceil = dal_fixed32_32_ceil(scale_ratio) *
 			(lb_config->interlaced ? 2 : 1);
 
-		if (lb_config->v_taps == vsr_ceil && (vsr_ceil % 2) != 0)
-			num_lines_required = lb_config->v_taps + 2;
+		if (lb_config->taps.v_taps == vsr_ceil && (vsr_ceil % 2) != 0)
+			num_lines_required = lb_config->taps.v_taps + 2;
 		else
-			num_lines_required = lb_config->v_taps + 1;
+			num_lines_required = lb_config->taps.v_taps + 1;
 
 	} else if (pixel_width <= 2560) {
 		/*Usually 3 lines, no scalar enabled case.
@@ -417,7 +417,7 @@ static bool enable_power_gating(
 		" MEMORY_SIZE:0x%x, NUM_PARTITIONS:%d, MEMORY_CONFIG:%d (%s)\n",
 		idx, lb->index,
 		lb_config->src_pixel_width, lb_config->src_height,
-		lb_config->dst_height, lb_config->v_taps,
+		lb_config->dst_height, lb_config->taps.v_taps,
 		get_reg_field_value(value, LB_MEMORY_CTRL, LB_MEMORY_SIZE),
 		get_reg_field_value(value, LB_MEMORY_CTRL, LB_NUM_PARTITIONS),
 		get_reg_field_value(value, LB_MEMORY_CTRL, LB_MEMORY_CONFIG),
@@ -462,6 +462,62 @@ static void enable_alpha(
 	dal_write_reg(dal_ctx, addr, value);
 }
 
+static enum lb_pixel_depth translate_display_bpp_to_lb_depth(
+	uint32_t display_bpp)
+{
+	switch (display_bpp) {
+	case 18:
+		return LB_PIXEL_DEPTH_18BPP;
+	case 24:
+		return LB_PIXEL_DEPTH_24BPP;
+	case 36:
+	case 42:
+	case 48:
+		return LB_PIXEL_DEPTH_36BPP;
+	case 30:
+	default:
+		return LB_PIXEL_DEPTH_30BPP;
+	}
+}
+
+static bool get_next_lower_pixel_storage_depth(
+	struct line_buffer *base,
+	uint32_t display_bpp,
+	enum lb_pixel_depth depth,
+	enum lb_pixel_depth *lower_depth)
+{
+	struct line_buffer_dce110 *lb = LB110_FROM_BASE(base);
+	enum lb_pixel_depth depth_req_by_display =
+		translate_display_bpp_to_lb_depth(display_bpp);
+	uint32_t current_required_depth = depth_req_by_display;
+	uint32_t current_depth = depth;
+
+	/* if required display depth < current we could go down, for example
+	 * from LB_PIXEL_DEPTH_30BPP to LB_PIXEL_DEPTH_24BPP
+	 */
+	if (current_required_depth < current_depth) {
+		current_depth = current_depth >> 1;
+		if (lb->caps & current_depth) {
+			*lower_depth = current_depth;
+			return true;
+		}
+	}
+	return false;
+}
+
+static bool is_prefetch_supported(
+	struct line_buffer *base,
+	struct lb_config_data *lb_config)
+{
+	struct line_buffer_dce110 *lb = LB110_FROM_BASE(base);
+	uint32_t value = dal_read_reg(base->dal_context, lb->lbx_data_format);
+
+	if (get_reg_field_value(value, LB_DATA_FORMAT, PREFETCH) == 1)
+		return true;
+
+	return false;
+}
+
 static const struct line_buffer_funcs funcs = {
 	.destroy = destroy,
 	.power_up = power_up,
@@ -470,12 +526,14 @@ static const struct line_buffer_funcs funcs = {
 	.get_current_pixel_storage_depth = get_current_pixel_storage_depth,
 	.get_pixel_storage_depth =
 		dal_line_buffer_dce110_get_pixel_storage_depth,
-	.get_next_lower_pixel_storage_depth = NULL,
+	.get_next_lower_pixel_storage_depth =
+		get_next_lower_pixel_storage_depth,
 	.get_max_num_of_supported_lines =
 		dal_line_buffer_dce110_get_max_num_of_supported_lines,
 	.reset_lb_on_vblank = reset_lb_on_vblank,
 	.set_vblank_irq = set_vblank_irq,
-	.enable_alpha = enable_alpha
+	.enable_alpha = enable_alpha,
+	.is_prefetch_supported = is_prefetch_supported
 };
 
 bool dal_line_buffer_dce110_construct(
@@ -495,7 +553,7 @@ bool dal_line_buffer_dce110_construct(
 	base->funcs = &funcs;
 
 	/* data members init */
-	lb->capabilites = LB_PIXEL_DEPTH_30BPP;
+	lb->caps = LB_PIXEL_DEPTH_30BPP;
 	lb->default_pixel_depth = LB_PIXEL_DEPTH_30BPP;
 	lb->controller_id = init_data->id;
 
@@ -506,14 +564,14 @@ bool dal_line_buffer_dce110_construct(
 
 		/*we may change lb capability here*/
 		if (flags.bits.WORKSTATION) {
-			lb->capabilites |= LB_PIXEL_DEPTH_18BPP;
-			lb->capabilites |= LB_PIXEL_DEPTH_24BPP;
+			lb->caps |= LB_PIXEL_DEPTH_18BPP;
+			lb->caps |= LB_PIXEL_DEPTH_24BPP;
 			/* 04/13: HW removed 12bpc LB. */
 
 		} else if (dal_adapter_service_is_feature_supported(
 			FEATURE_LINE_BUFFER_ENHANCED_PIXEL_DEPTH)) {
-			lb->capabilites |= LB_PIXEL_DEPTH_18BPP;
-			lb->capabilites |= LB_PIXEL_DEPTH_24BPP;
+			lb->caps |= LB_PIXEL_DEPTH_18BPP;
+			lb->caps |= LB_PIXEL_DEPTH_24BPP;
 		}
 
 		/* TODO: read FEATURE_POWER_GATING_LINE_BUFFER_PORTION when
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.h b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.h
index e18e3bd..dc24c97 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.h
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_dce110.h
@@ -38,7 +38,7 @@ struct line_buffer_dce110 {
 
 	enum lb_pixel_depth default_pixel_depth;
 
-	uint32_t capabilites;
+	uint32_t caps;
 	uint32_t index;
 	uint32_t power_gating;
 
diff --git a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c
index 123bb1f..494b59f 100644
--- a/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c
+++ b/drivers/gpu/drm/amd/dal/controller/dce110/line_buffer_v_dce110.c
@@ -204,7 +204,7 @@ static bool set_pixel_storage_depth(
 
 		set_reg_field_value(value, 0, LBV_DATA_FORMAT, ALPHA_EN);
 		dal_write_reg(base->dal_context, lb->lbx_data_format, value);
-		if (!(lb->capabilites & depth)) {
+		if (!(lb->caps & depth)) {
 			/*we should use unsupported capabilities
 			 *  unless it is required by w/a*/
 			dal_logger_write(base->dal_context->logger,
@@ -233,6 +233,41 @@ static void enable_alpha(
 {
 }
 
+static bool is_prefetch_supported(
+	struct line_buffer *base,
+	struct lb_config_data *lb_config_data)
+{
+	uint32_t pitch_l =
+		dal_line_buffer_base_calculate_pitch(
+			lb_config_data->depth,
+			lb_config_data->src_pixel_width);
+	uint32_t pitch_c =
+		dal_line_buffer_base_calculate_pitch(
+			lb_config_data->depth,
+			lb_config_data->src_pixel_width_c);
+
+	/* Required number of lines from taps, minimum is 3 for prefetch */
+	uint32_t num_lines_required_l = lb_config_data->taps.v_taps + 2;
+	uint32_t num_lines_required_c = lb_config_data->taps.v_taps_c + 2;
+	uint32_t min_req_lb_entries_l;
+	uint32_t min_req_lb_entries_c;
+
+	if (num_lines_required_l < 3)
+		num_lines_required_l = 3;
+
+	if (num_lines_required_c < 3)
+		num_lines_required_c = 3;
+
+	min_req_lb_entries_l = num_lines_required_l * pitch_l;
+	min_req_lb_entries_c = num_lines_required_c * pitch_c;
+
+	if (min_req_lb_entries_l < LB_ENTRIES_TOTAL_NUMBER &&
+		min_req_lb_entries_c <= LB_ENTRIES_TOTAL_NUMBER)
+		return true;
+
+	return false;
+}
+
 static const struct line_buffer_funcs funcs = {
 	.destroy = destroy,
 	.power_up = power_up,
@@ -246,7 +281,8 @@ static const struct line_buffer_funcs funcs = {
 		dal_line_buffer_dce110_get_max_num_of_supported_lines,
 	.reset_lb_on_vblank = NULL,
 	.set_vblank_irq = NULL,
-	.enable_alpha = enable_alpha
+	.enable_alpha = enable_alpha,
+	.is_prefetch_supported = is_prefetch_supported
 };
 
 static bool construct(
@@ -257,7 +293,7 @@ static bool construct(
 	if (!dal_line_buffer_dce110_construct(lb, init_data))
 		return false;
 
-	lb->capabilites = LB_PIXEL_DEPTH_24BPP;
+	lb->caps = LB_PIXEL_DEPTH_24BPP;
 	lb->default_pixel_depth = LB_PIXEL_DEPTH_24BPP;
 
 	switch (lb->controller_id) {
diff --git a/drivers/gpu/drm/amd/dal/controller/line_buffer.c b/drivers/gpu/drm/amd/dal/controller/line_buffer.c
index a1a702d..61c9f6c 100644
--- a/drivers/gpu/drm/amd/dal/controller/line_buffer.c
+++ b/drivers/gpu/drm/amd/dal/controller/line_buffer.c
@@ -179,3 +179,44 @@ void dal_line_buffer_enable_alpha(
 	lb->funcs->enable_alpha(lb, enable);
 }
 
+bool dal_line_buffer_is_prefetch_supported(
+	struct line_buffer *lb,
+	struct lb_config_data *lb_config)
+{
+	return lb->funcs->is_prefetch_supported(lb, lb_config);
+}
+
+bool dal_line_buffer_base_is_prefetch_supported(
+	struct line_buffer *lb,
+	struct lb_config_data *lb_config)
+{
+	return false;
+}
+
+uint32_t dal_line_buffer_base_calculate_pitch(
+	enum lb_pixel_depth depth,
+	uint32_t width)
+{
+	uint32_t pitch = 0;
+
+	switch (depth) {
+	case LB_PIXEL_DEPTH_18BPP:
+		pitch = (width + 7) >> 3;
+		break;
+
+	case LB_PIXEL_DEPTH_24BPP:
+		pitch = ((width + 7) / 8) * 683;
+		pitch = (pitch + 511) >> 9;
+		break;
+
+	case LB_PIXEL_DEPTH_30BPP:
+		pitch = ((width + 7) / 8) * 854;
+		pitch = (pitch + 511) >> 9;
+		break;
+
+	case LB_PIXEL_DEPTH_36BPP:
+		pitch = (width + 3) >> 2;
+		break;
+	}
+	return pitch;
+}
diff --git a/drivers/gpu/drm/amd/dal/controller/line_buffer.h b/drivers/gpu/drm/amd/dal/controller/line_buffer.h
index 6d3acca..4dc0680 100644
--- a/drivers/gpu/drm/amd/dal/controller/line_buffer.h
+++ b/drivers/gpu/drm/amd/dal/controller/line_buffer.h
@@ -64,6 +64,9 @@ struct line_buffer_funcs {
 	void (*enable_alpha)(
 		struct line_buffer *lb,
 		bool enable);
+	bool (*is_prefetch_supported)(
+		struct line_buffer *lb,
+		struct lb_config_data *lb_config);
 };
 
 struct line_buffer {
@@ -85,9 +88,15 @@ bool dal_line_buffer_construct_base(
 void dal_line_buffer_destruct_base(struct line_buffer *lb);
 void dal_line_buffer_destroy(struct line_buffer **lb);
 
-enum lb_pixel_depth dal_line_buffer_display_bpp_to_lb_depth(uint32_t disp_bpp);
-
+enum lb_pixel_depth dal_line_buffer_display_bpp_to_lb_depth(
+	uint32_t disp_bpp);
 
+bool dal_line_buffer_base_is_prefetch_supported(
+	struct line_buffer *lb,
+	struct lb_config_data *lb_config);
 
+uint32_t dal_line_buffer_base_calculate_pitch(
+	enum lb_pixel_depth depth,
+	uint32_t width);
 
 #endif /* __DAL_LINE_BUFFER_H__ */
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
index f4bcd20..bd206fa 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer.c
@@ -988,7 +988,7 @@ bool dal_hw_sequencer_enable_line_buffer_power_gating(
 	enum pixel_type pixel_type,
 	uint32_t src_pixel_width,
 	uint32_t dst_pixel_width,
-	uint32_t v_taps,
+	struct scaling_tap_info *taps,
 	enum lb_pixel_depth lb_depth,
 	uint32_t src_height,
 	uint32_t dst_height,
@@ -1002,7 +1002,7 @@ bool dal_hw_sequencer_enable_line_buffer_power_gating(
 
 	lb_config_data.src_pixel_width = src_pixel_width;
 	lb_config_data.dst_pixel_width = dst_pixel_width;
-	lb_config_data.v_taps = v_taps;
+	lb_config_data.taps = *taps;
 	/* this parameter is meaningful for DCE8 and up */
 	lb_config_data.depth = lb_depth;
 	/* this parameter is meaningful for DCE8 and up */
@@ -2224,7 +2224,8 @@ enum hwss_result dal_hw_sequencer_set_mode(
 	build_params = dal_hw_sequencer_prepare_path_parameters(
 			hws,
 			path_set,
-			params_mask);
+			params_mask,
+			false);
 
 	if (NULL == build_params) {
 		dal_logger_write(dal_context->logger,
@@ -2641,7 +2642,7 @@ static void program_scaler(
 		scaler_data.pixel_type,
 		path_mode->mode.scaling_info.src.width,
 		path_mode->mode.scaling_info.dst.width,
-		build_params->scaling_taps_params[path_id][plane_id].v_taps,
+		&build_params->scaling_taps_params[path_id][plane_id],
 		build_params->line_buffer_params[path_id][plane_id].depth,
 		path_mode->mode.scaling_info.src.height,
 		path_mode->mode.scaling_info.dst.height,
@@ -3030,8 +3031,12 @@ enum hwss_result dal_hw_sequencer_validate_display_hwpms(
 	params_mask.bits.BANDWIDTH = true;
 
 	/* fill information for active set of display paths */
-	build_params = dal_hw_sequencer_prepare_path_parameters(
-		hws, path_set, params_mask);
+	build_params =
+		dal_hw_sequencer_prepare_path_parameters(
+			hws,
+			path_set,
+			params_mask,
+			true);
 
 	if (NULL == build_params)
 		return HWSS_RESULT_ERROR;
@@ -3082,8 +3087,12 @@ enum hwss_result dal_hw_sequencer_set_safe_displaymark(
 
 	/* TODO: do we really need to calculate anything for SAFE marks?
 	 * If not, we don't need to "prepare parameters" too. */
-	build_params = dal_hw_sequencer_prepare_path_parameters(
-		hws, path_set, params_mask);
+	build_params =
+		dal_hw_sequencer_prepare_path_parameters(
+			hws,
+			path_set,
+			params_mask,
+			false);
 
 	if (NULL == build_params) {
 		dal_logger_write(hws->dal_context->logger, LOG_MAJOR_ERROR,
@@ -3127,7 +3136,7 @@ enum hwss_result dal_hw_sequencer_set_displaymark(
 	params_mask.bits.BANDWIDTH = true;
 
 	build_params = dal_hw_sequencer_prepare_path_parameters(
-		hws, path_set, params_mask);
+		hws, path_set, params_mask, false);
 
 	if (NULL == build_params) {
 		dal_logger_write(hws->dal_context->logger, LOG_MAJOR_ERROR,
@@ -3468,7 +3477,11 @@ enum hwss_result dal_hw_sequencer_set_plane_config(
 	mask.bits.LINE_BUFFER = true;
 
 	build_params =
-		dal_hw_sequencer_prepare_path_parameters(hws, path_set, mask);
+		dal_hw_sequencer_prepare_path_parameters(
+			hws,
+			path_set,
+			mask,
+			false);
 
 	if (!build_params) {
 		dal_logger_write(dal_context->logger,
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
index 7204fb3..e85e2ae 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_adjustments.c
@@ -136,7 +136,7 @@ static enum hwss_result program_overscan(
 			scaler_data.pixel_type,
 			param->hw_path_mode->mode.scaling_info.src.width,
 			param->hw_path_mode->mode.scaling_info.dst.width,
-			param->taps[plane].v_taps,
+			&param->taps[plane],
 			param->line_buffer_array[plane].depth,
 			param->hw_path_mode->mode.scaling_info.src.height,
 			param->hw_path_mode->mode.scaling_info.dst.height,
@@ -164,7 +164,7 @@ static enum hwss_result program_overscan(
 			scaler_data.pixel_type,
 			param->hw_path_mode->mode.scaling_info.src.width,
 			param->hw_path_mode->mode.scaling_info.dst.width,
-			param->taps[plane].v_taps,
+			&param->taps[plane],
 			param->line_buffer_array[plane].depth,
 			param->hw_path_mode->mode.scaling_info.src.height,
 			param->hw_path_mode->mode.scaling_info.dst.height,
@@ -228,7 +228,8 @@ enum hwss_result dal_hw_sequencer_set_overscan_adj(
 	build_params = dal_hw_sequencer_prepare_path_parameters(
 		hws,
 		set,
-		params_mask);
+		params_mask,
+		false);
 
 	if (NULL == build_params)
 		return HWSS_RESULT_ERROR;
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c
index 1667d63..5d302dbc 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.c
@@ -433,6 +433,171 @@ translate_lb_pixel_depth_to_scaler_efficiency(
 	return scaler_eff;
 }
 
+static enum scaler_validation_code get_optimal_number_of_taps(
+	struct controller *crtc,
+	struct scaler_validation_params *scaling_params,
+	enum hw_color_depth display_color_depth,
+	struct lb_params_data *lb_params,
+	struct scaling_tap_info *actual_taps_info,
+	bool interlaced,
+	enum hw_pixel_encoding pixel_encoding)
+{
+	enum scaler_validation_code code =
+		SCALER_VALIDATION_INVALID_INPUT_PARAMETERS;
+
+	uint32_t max_lines_number = 0;
+
+	struct line_buffer *lb = dal_controller_get_line_buffer(crtc);
+
+	uint32_t display_bpp = translate_to_display_bpp(display_color_depth);
+	enum lb_pixel_depth depth = lb_params->depth;
+	enum lb_pixel_depth lower_depth = depth;
+
+	bool failure_max_number_of_supported_lines = false;
+	bool failure_next_lower_number_of_taps = false;
+	bool use_predefined_taps = false;
+
+	/* Variable to pass in to calculate number of lines supported by
+	 * Line Buffer */
+	uint32_t pixel_width = 0;
+	uint32_t pixel_width_c;
+
+	/* If downscaling, use destination pixel width to calculate Line Buffer
+	 * size (how many lines can fit in line buffer) (We assume the 4:1
+	 * scaling ratio is already checked in static validation -> no modes
+	 * should be here that doesn't fit that limitation)
+	 */
+	if (scaling_params->source_view.width >
+		scaling_params->dest_view.width)
+		pixel_width = scaling_params->dest_view.width;
+	else
+		pixel_width = scaling_params->source_view.width;
+
+	pixel_width_c = pixel_width;
+
+	/* Source width for chroma is half size for 420 and 422 rotated to 90
+	 * or 270 */
+	if (scaling_params->pixel_format == PIXEL_FORMAT_420BPP12 ||
+		((scaling_params->rotation == ROTATION_ANGLE_90 ||
+			scaling_params->rotation == ROTATION_ANGLE_270) &&
+		scaling_params->pixel_format == PIXEL_FORMAT_420BPP12)) {
+		if (scaling_params->source_view.width / 2 <
+			scaling_params->dest_view.width) {
+			pixel_width_c = scaling_params->source_view.width / 2;
+		}
+	}
+
+	if (!dal_line_buffer_get_max_num_of_supported_lines(
+		lb,
+		depth,
+		pixel_width,
+		&max_lines_number))
+		return code;
+
+	/* TODO: before usage check taps_requested initialized
+	if (false && scaling_params->taps_requested.h_taps > 0 &&
+		scaling_params->taps_requested.v_taps > 0) {
+		struct lb_config_data lb_config_data = { 0 };
+		lb_config_data.src_height =
+			scaling_params->source_view.height;
+		lb_config_data.src_pixel_width = pixel_width;
+		lb_config_data.src_pixel_width_c = pixel_width_c;
+		lb_config_data.dst_height =
+			scaling_params->dest_view.height;
+		lb_config_data.dst_pixel_width =
+			scaling_params->dest_view.width;
+		lb_config_data.taps.h_taps =
+			scaling_params->taps_requested.h_taps;
+		lb_config_data.taps.v_taps =
+			scaling_params->taps_requested.v_taps;
+		lb_config_data.taps.h_taps_c =
+			scaling_params->taps_requested.h_taps_c;
+		lb_config_data.taps.v_taps_c =
+			scaling_params->taps_requested.v_taps_c;
+		lb_config_data.interlaced = interlaced;
+		lb_config_data.depth = lb_params->depth;
+
+		if (dal_line_buffer_validate_taps_info(
+			lb,
+			&lb_config_data,
+			display_bpp)) {
+			*actual_taps_info = scaling_params->taps_requested;
+			use_predefined_taps = true;
+		}
+	} else */
+
+	/* To get the number of taps, we still want to know the original scaling
+	 * parameters. The horizontal downscaling TAPS use a value that is
+	 * consistent to the original scaling parameters. ie. We don't need to
+	 * use the destination horizontal width
+	 */
+	if (dal_controller_get_optimal_taps_number(
+		crtc,
+		scaling_params,
+		actual_taps_info) != SCALER_VALIDATION_OK) {
+		return code;
+	}
+
+	/* v_taps go lower and maxNumberOfLines could go higher when lb format
+	 * is changed
+	 * Do loop until taps <  lines - 1, taps + 1 = lines
+	 */
+	while (actual_taps_info->v_taps > max_lines_number - 1) {
+		/* adjust lb size */
+		if (dal_line_buffer_get_next_lower_pixel_storage_depth(
+			lb,
+			display_bpp,
+			depth,
+			&lower_depth)) {
+			depth = lower_depth;
+			if (!dal_line_buffer_get_max_num_of_supported_lines(
+				lb,
+				depth,
+				pixel_width,
+				&max_lines_number)) {
+				failure_max_number_of_supported_lines = true;
+				break;
+			}
+
+			continue;
+		}
+
+		if (use_predefined_taps == true) {
+			code = SCALER_VALIDATION_FAILURE_PREDEFINED_TAPS_NUMBER;
+			break;
+		} else if (dal_controller_get_next_lower_taps_number(
+			crtc,
+			NULL,
+			actual_taps_info) != SCALER_VALIDATION_OK) {
+			failure_next_lower_number_of_taps = true;
+			break;
+		}
+	}
+
+	if (use_predefined_taps == true &&
+		code == SCALER_VALIDATION_FAILURE_PREDEFINED_TAPS_NUMBER)
+		return code;
+
+	if (actual_taps_info->v_taps > 1 && max_lines_number <= 2)
+		return SCALER_VALIDATION_SOURCE_VIEW_WIDTH_EXCEEDING_LIMIT;
+
+	if (failure_max_number_of_supported_lines == true
+		|| failure_next_lower_number_of_taps == true) {
+		/* we requested scaling ,but it could not be supported */
+		return SCALER_VALIDATION_SOURCE_VIEW_WIDTH_EXCEEDING_LIMIT;
+	}
+
+	if (actual_taps_info->v_taps == 1 && max_lines_number < 2) {
+		/* no scaling ,but LB should accommodate at least 2 source lines
+		 */
+		return SCALER_VALIDATION_SOURCE_VIEW_WIDTH_EXCEEDING_LIMIT;
+	}
+
+	lb_params->depth = depth;
+
+	return SCALER_VALIDATION_OK;
+}
+
 static enum scaler_validation_code build_path_parameters(
 	struct hw_sequencer *hws,
 	const struct hw_path_mode *path_mode,
@@ -443,7 +608,8 @@ static enum scaler_validation_code build_path_parameters(
 	struct min_clock_params *min_clock_params,
 	struct watermark_input_params *wm_input_params,
 	struct bandwidth_params *bandwidth_params,
-	struct lb_params_data *line_buffer_params)
+	struct lb_params_data *line_buffer_params,
+	bool use_predefined_hw_state)
 {
 	enum scaler_validation_code scaler_return_code = SCALER_VALIDATION_OK;
 	struct pixel_clk_params pixel_clk_params = { 0 };
@@ -481,6 +647,62 @@ static enum scaler_validation_code build_path_parameters(
 			line_buffer_params != NULL ?
 				line_buffer_params : &line_buffer_params_local;
 
+	bool line_buffer_prefetch_enabled;
+
+	uint32_t pixel_width;
+	uint32_t pixel_width_c;
+
+	/* If downscaling, use destination pixel width to calculate Line Buffer
+	 * size (how many lines can fit in line buffer) (We assume the 4:1
+	 * scaling ratio is already checked in static validation -> no modes
+	 * should be here that doesn't fit that limitation)
+	 */
+	if (path_mode->mode.scaling_info.src.width >
+		path_mode->mode.scaling_info.dst.width)
+		pixel_width = path_mode->mode.scaling_info.dst.width;
+	else
+		pixel_width = path_mode->mode.scaling_info.src.width;
+
+	pixel_width_c = pixel_width;
+
+	if (pl_cfg &&
+		(pl_cfg->config.dal_pixel_format == PIXEL_FORMAT_420BPP12 ||
+		(pl_cfg->config.dal_pixel_format == PIXEL_FORMAT_422BPP16 &&
+			(pl_cfg->config.rotation == PLANE_ROTATION_ANGLE_90 ||
+				pl_cfg->config.rotation ==
+					PLANE_ROTATION_ANGLE_270)))) {
+		if (path_mode->mode.scaling_info.src.width / 2 <
+			path_mode->mode.scaling_info.dst.width)
+			pixel_width_c = path_mode->mode.scaling_info.src.width;
+	}
+
+	if (use_predefined_hw_state)
+		line_buffer_prefetch_enabled = false;
+	else {
+		struct lb_config_data lb_config_data;
+
+		dal_memset(&lb_config_data, 0, sizeof(lb_config_data));
+		lb_config_data.src_height =
+			path_mode->mode.scaling_info.src.height;
+		lb_config_data.src_pixel_width = pixel_width;
+		lb_config_data.src_pixel_width_c = pixel_width_c;
+		lb_config_data.dst_height =
+			path_mode->mode.scaling_info.dst.height;
+		lb_config_data.dst_pixel_width =
+			path_mode->mode.scaling_info.dst.width;
+		lb_config_data.taps.h_taps = actual_tap_info->h_taps;
+		lb_config_data.taps.v_taps = actual_tap_info->v_taps;
+		lb_config_data.taps.h_taps_c = actual_tap_info->h_taps_c;
+		lb_config_data.taps.v_taps_c = actual_tap_info->v_taps_c;
+		lb_config_data.interlaced =
+			path_mode->mode.timing.flags.INTERLACED;
+		lb_config_data.depth = actual_line_buffer_params->depth;
+		line_buffer_prefetch_enabled =
+			dal_line_buffer_is_prefetch_supported(
+				dal_controller_get_line_buffer(crtc),
+				&lb_config_data);
+	}
+
 	/* calc pixel clock parameters and PLL dividers */
 	dal_hw_sequencer_get_pixel_clock_parameters(path_mode,
 			&pixel_clk_params);
@@ -529,10 +751,14 @@ static enum scaler_validation_code build_path_parameters(
 
 		/** get taps that are fit to lb size the lb depth could be
 		 * updated , taps are set if return code is Ok */
-		scaler_return_code = dal_controller_get_optimal_taps_number(
+		scaler_return_code = get_optimal_number_of_taps(
 				crtc,
 				&scaler_params,
-				actual_tap_info);
+				path_mode->mode.timing.flags.COLOR_DEPTH,
+				actual_line_buffer_params,
+				actual_tap_info,
+				path_mode->mode.timing.flags.INTERLACED == 0,
+				path_mode->mode.timing.flags.PIXEL_ENCODING);
 
 		/* Prepare min clock params */
 
@@ -589,7 +815,8 @@ static enum scaler_validation_code build_path_parameters(
 		actual_min_clock_params->scaler_efficiency =
 				translate_lb_pixel_depth_to_scaler_efficiency(
 					actual_line_buffer_params->depth);
-		actual_min_clock_params->line_buffer_prefetch_enabled = false;
+		actual_min_clock_params->line_buffer_prefetch_enabled =
+			line_buffer_prefetch_enabled;
 		actual_line_buffer_params->id = path_index;
 
 		/* validate taps if it is set */
@@ -704,7 +931,8 @@ static uint32_t prepare_per_path_parameters(
 	union hwss_build_params_mask params_mask,
 	struct hwss_build_params *build_params,
 	uint32_t path_index,
-	uint32_t param_num_in)
+	uint32_t param_num_in,
+	bool use_predefined_hw_state)
 {
 	struct dal_context *dal_context = hws->dal_context;
 	enum scaler_validation_code build_result = SCALER_VALIDATION_OK;
@@ -775,7 +1003,8 @@ static uint32_t prepare_per_path_parameters(
 			(params_mask.bits.LINE_BUFFER ?
 				&build_params->
 				line_buffer_params[path_index][plane_index] :
-				NULL));
+				NULL),
+			use_predefined_hw_state);
 
 		if (build_result != SCALER_VALIDATION_OK) {
 			/* we can't support requested mode */
@@ -830,7 +1059,8 @@ static void compute_minimum_clocks_for_path_mode_set(
 struct hwss_build_params *dal_hw_sequencer_prepare_path_parameters(
 	struct hw_sequencer *hws,
 	struct hw_path_mode_set *path_set,
-	union hwss_build_params_mask params_mask)
+	union hwss_build_params_mask params_mask,
+	bool use_predefined_hw_state)
 {
 	struct dal_context *dal_context = hws->dal_context;
 	struct hw_path_mode *path_mode;
@@ -890,7 +1120,8 @@ struct hwss_build_params *dal_hw_sequencer_prepare_path_parameters(
 				params_mask,
 				build_params,
 				i,
-				total_params_num_prepared);
+				total_params_num_prepared,
+				use_predefined_hw_state);
 
 		if (!path_params_num_prepared) {
 			dal_hw_sequencer_free_path_parameters(build_params);
diff --git a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.h b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.h
index 3b65013..770eca0 100644
--- a/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.h
+++ b/drivers/gpu/drm/amd/dal/hw_sequencer/hw_sequencer_parameters.h
@@ -100,11 +100,11 @@ struct hwss_build_params {
 	void *mem_block;
 };
 
-
 struct hwss_build_params *dal_hw_sequencer_prepare_path_parameters(
 	struct hw_sequencer *hws,
 	struct hw_path_mode_set *path_set,
-	union hwss_build_params_mask params_mask);
+	union hwss_build_params_mask params_mask,
+	bool use_predefined_hw_state);
 
 void dal_hw_sequencer_free_path_parameters(
 	struct hwss_build_params *build_params);
diff --git a/drivers/gpu/drm/amd/dal/include/bandwidth_manager_types.h b/drivers/gpu/drm/amd/dal/include/bandwidth_manager_types.h
index 161b987..ca029ec 100644
--- a/drivers/gpu/drm/amd/dal/include/bandwidth_manager_types.h
+++ b/drivers/gpu/drm/amd/dal/include/bandwidth_manager_types.h
@@ -26,6 +26,7 @@
 #define __DAL_BANDWIDTH_MANAGER_TYPES_H__
 
 #include "hw_sequencer_types.h"
+#include "scaler_types.h"
 
 #include "set_mode_types.h"
 
@@ -60,13 +61,6 @@ struct watermark_input_params {
 	enum hw_stereo_format stereo_format;
 };
 
-struct scaling_taps {
-	uint32_t h_taps;
-	uint32_t v_taps;
-	uint32_t h_taps_c;
-	uint32_t v_taps_c;
-};
-
 struct validation_timing_params {
 	uint32_t PREFETCH:1;
 	uint32_t INTERLACED:1;
@@ -81,7 +75,7 @@ struct bandwidth_params {
 	struct view_params src_vw;
 	struct view_params dst_vw;
 	struct validation_timing_params timing_info;
-	struct scaling_taps scaler_taps;
+	struct scaling_tap_info scaler_taps;
 	struct color_quality color_info;
 	enum hw_tiling_mode tiling_mode;
 	bool is_tiling_rotated;
diff --git a/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h b/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h
index b93d904..4a225e0 100644
--- a/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/hw_sequencer_interface.h
@@ -324,7 +324,7 @@ bool dal_hw_sequencer_enable_line_buffer_power_gating(
 	enum pixel_type pixel_type,
 	uint32_t src_pixel_width,
 	uint32_t dst_pixel_width,
-	uint32_t v_taps,
+	struct scaling_tap_info *taps,
 	enum lb_pixel_depth lb_depth,
 	uint32_t src_height,
 	uint32_t dst_height,
diff --git a/drivers/gpu/drm/amd/dal/include/line_buffer_interface.h b/drivers/gpu/drm/amd/dal/include/line_buffer_interface.h
index b649632..e8520f3 100644
--- a/drivers/gpu/drm/amd/dal/include/line_buffer_interface.h
+++ b/drivers/gpu/drm/amd/dal/include/line_buffer_interface.h
@@ -27,6 +27,7 @@
 #define __LINE_BUFFER_INTERFACE_H__
 
 #include "grph_object_id.h"
+#include "scaler_types.h"
 
 enum lb_pixel_depth {
 	/* do not change the values because it is used as bit vector */
@@ -37,10 +38,10 @@ enum lb_pixel_depth {
 };
 
 struct lb_config_data {
-	/*enum lb_storage_type storage_type;*//*this is always 30 bpp not used*/
 	uint32_t src_pixel_width;
+	uint32_t src_pixel_width_c;
 	uint32_t dst_pixel_width;
-	uint32_t v_taps;
+	struct scaling_tap_info taps;
 	enum lb_pixel_depth depth; /* for dce8 and up use this */
 	uint32_t src_height; /* dce8 vsr calculation on lb power gating */
 	uint32_t dst_height; /* dce8 vsr calculation on lb power gating */
@@ -94,5 +95,8 @@ void dal_line_buffer_set_vblank_irq(
 void dal_line_buffer_enable_alpha(
 	struct line_buffer *lb,
 	bool enable);
+bool dal_line_buffer_is_prefetch_supported(
+	struct line_buffer *lb,
+	struct lb_config_data *lb_config);
 
 #endif /* __LINE_BUFFER_INTERFACE_H__ */
diff --git a/drivers/gpu/drm/amd/dal/include/scaler_types.h b/drivers/gpu/drm/amd/dal/include/scaler_types.h
index 092e5fb..6f5ed41 100644
--- a/drivers/gpu/drm/amd/dal/include/scaler_types.h
+++ b/drivers/gpu/drm/amd/dal/include/scaler_types.h
@@ -88,6 +88,10 @@ struct scaler_validation_params {
 	struct view source_view;
 	struct view dest_view;
 	enum signal_type signal_type;
+
+	struct scaling_tap_info taps_requested;
+	enum pixel_format pixel_format;
+	enum rotation_angle rotation;
 };
 
 struct adjustment_factor {
@@ -119,7 +123,8 @@ enum scaler_validation_code {
 	SCALER_VALIDATION_INVALID_INPUT_PARAMETERS,
 	SCALER_VALIDATION_SCALING_RATIO_NOT_SUPPORTED,
 	SCALER_VALIDATION_SOURCE_VIEW_WIDTH_EXCEEDING_LIMIT,
-	SCALER_VALIDATION_DISPLAY_CLOCK_BELOW_PIXEL_CLOCK
+	SCALER_VALIDATION_DISPLAY_CLOCK_BELOW_PIXEL_CLOCK,
+	SCALER_VALIDATION_FAILURE_PREDEFINED_TAPS_NUMBER
 };
 
 /* Pixel format */
-- 
1.9.1

