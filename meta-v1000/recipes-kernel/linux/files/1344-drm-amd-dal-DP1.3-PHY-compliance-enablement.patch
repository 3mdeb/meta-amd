From e604763c858b9740f7326b8a88d262bb4b3808e9 Mon Sep 17 00:00:00 2001
From: Amy Zhang <Amy.Zhang@amd.com>
Date: Mon, 17 Oct 2016 10:33:00 -0400
Subject: [PATCH 1344/1722] drm/amd/dal: DP1.3 PHY compliance enablement

- Set PHY/CRTC test patterns

Change-Id: If771d8789110131e85b9e2b5b3e780a62b306c2c
Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
---
 .../dal/dc/asic_capability/tonga_asic_capability.c |   1 -
 drivers/gpu/drm/amd/dal/dc/core/dc.c               |  36 ++
 drivers/gpu/drm/amd/dal/dc/core/dc_link.c          |   4 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c       | 569 ++++++++++++++++++++-
 drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c     |  28 +-
 drivers/gpu/drm/amd/dal/dc/core/dc_resource.c      |   2 -
 drivers/gpu/drm/amd/dal/dc/core/dc_stream.c        |  11 +-
 drivers/gpu/drm/amd/dal/dc/dc.h                    |  22 +
 .../drm/amd/dal/dc/dce100/dce100_link_encoder.c    |   6 +-
 .../drm/amd/dal/dc/dce100/dce100_link_encoder.h    |   3 +-
 .../gpu/drm/amd/dal/dc/dce100/dce100_resource.c    |  17 +-
 .../drm/amd/dal/dc/dce110/dce110_hw_sequencer.c    |   1 +
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.c    |  50 +-
 .../drm/amd/dal/dc/dce110/dce110_link_encoder.h    |  16 +-
 drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c   |   2 +
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.c    |  22 +-
 .../gpu/drm/amd/dal/dc/dce110/dce110_resource.h    |   4 +
 .../amd/dal/dc/dce110/dce110_timing_generator.c    | 357 ++++++++++++-
 .../drm/amd/dal/dc/dce112/dce112_link_encoder.c    |   8 +-
 .../drm/amd/dal/dc/dce112/dce112_link_encoder.h    |   3 +-
 drivers/gpu/drm/amd/dal/dc/dce112/dce112_opp.c     |   2 +
 .../gpu/drm/amd/dal/dc/dce112/dce112_resource.c    |  17 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c  |   4 +-
 .../gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.h  |   3 +-
 drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c  |  27 +-
 drivers/gpu/drm/amd/dal/dc/inc/core_types.h        |   5 +
 drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h   |   2 +
 drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h            |   4 +
 .../gpu/drm/amd/dal/dc/inc/hw/timing_generator.h   |   5 +
 drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h      |   3 +
 drivers/gpu/drm/amd/dal/dc/inc/link_hwss.h         |   6 +-
 drivers/gpu/drm/amd/dal/include/dpcd_defs.h        |  71 ++-
 32 files changed, 1250 insertions(+), 61 deletions(-)

diff --git a/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c b/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
index 74ce3f8..8fa4d85 100644
--- a/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
+++ b/drivers/gpu/drm/amd/dal/dc/asic_capability/tonga_asic_capability.c
@@ -32,7 +32,6 @@
 
 #include "atom.h"
 #include "dce/dce_10_0_d.h"
-#include "smu/smu_8_0_d.h"
 #include "dce/dce_10_0_sh_mask.h"
 #include "dal_asic_id.h"
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc.c b/drivers/gpu/drm/amd/dal/dc/core/dc.c
index f1207a7..a01385d 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc.c
@@ -407,6 +407,33 @@ static void set_preferred_link_settings(struct dc *dc,
 	}
 }
 
+static void enable_hpd(const struct dc_link *link)
+{
+	dc_link_dp_enable_hpd(link);
+}
+
+static void disable_hpd(const struct dc_link *link)
+{
+	dc_link_dp_disable_hpd(link);
+}
+
+
+static void set_test_pattern(
+		const struct dc_link *link,
+		enum dp_test_pattern test_pattern,
+		const struct link_training_settings *p_link_settings,
+		const unsigned char *p_custom_pattern,
+		unsigned int cust_pattern_size)
+{
+	if (link != NULL)
+		dc_link_dp_set_test_pattern(
+			link,
+			test_pattern,
+			p_link_settings,
+			p_custom_pattern,
+			cust_pattern_size);
+}
+
 static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 {
 	core_dc->public.stream_funcs.stream_update_scaling = stream_update_scaling;
@@ -441,6 +468,15 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 
 	core_dc->public.link_funcs.set_preferred_link_settings =
 			set_preferred_link_settings;
+
+	core_dc->public.link_funcs.enable_hpd =
+			enable_hpd;
+
+	core_dc->public.link_funcs.disable_hpd =
+			disable_hpd;
+
+	core_dc->public.link_funcs.set_test_pattern =
+			set_test_pattern;
 }
 
 static bool construct(struct core_dc *dc,
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
index a323229..4801b14 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link.c
@@ -1507,7 +1507,9 @@ bool dc_link_setup_psr(const struct dc_link *dc_link,
 
 	if (dc_link != NULL && dc_link->psr_caps.psr_version > 0) {
 		/* updateSinkPsrDpcdConfig*/
-		union dpcd_psr_configuration psr_configuration = {0};
+		union dpcd_psr_configuration psr_configuration;
+
+		memset(&psr_configuration, 0, sizeof(psr_configuration));
 
 		psr_configuration.bits.ENABLE                    = 1;
 		psr_configuration.bits.CRC_VERIFICATION          = 1;
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
index 2c47feb..77b90ca 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_dp.c
@@ -938,7 +938,7 @@ static inline bool perform_link_training_int(
 	dpcd_set_training_pattern(link, dpcd_pattern);
 
 	/* 4. mainlink output idle pattern*/
-	dp_set_hw_test_pattern(link, DP_TEST_PATTERN_VIDEO_MODE);
+	dp_set_hw_test_pattern(link, DP_TEST_PATTERN_VIDEO_MODE, NULL, 0);
 
 	/*
 	 * 5. post training adjust if required
@@ -974,7 +974,7 @@ bool dc_link_dp_perform_link_training(
 	struct core_link *core_link = DC_LINK_TO_CORE(link);
 	bool status;
 
-	const int8_t *link_rate = "Unknown";
+	char *link_rate = "Unknown";
 	struct link_training_settings lt_settings;
 
 	status = false;
@@ -1547,6 +1547,256 @@ static bool handle_hpd_irq_psr_sink(const struct core_link *link)
 	return false;
 }
 
+static void dp_test_send_link_training(struct core_link *link)
+{
+	struct dc_link_settings link_settings;
+
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_LANE_COUNT,
+			(unsigned char *)(&link_settings.lane_count),
+			1);
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_LINK_RATE,
+			(unsigned char *)(&link_settings.link_rate),
+			1);
+
+	/* Set preferred link settings */
+	link->public.verified_link_cap.lane_count = link_settings.lane_count;
+	link->public.verified_link_cap.link_rate = link_settings.link_rate;
+
+	dp_retrain_link(link);
+}
+
+static void dp_test_send_phy_test_pattern(struct core_link *link)
+{
+	union phy_test_pattern dpcd_test_pattern;
+	union lane_adjust dpcd_lane_adjustment[2];
+	unsigned char dpcd_post_cursor_2_adjustment = 0;
+	unsigned char test_80_bit_pattern[
+			(DPCD_ADDRESS_TEST_80BIT_CUSTOM_PATTERN_79_72 -
+			DPCD_ADDRESS_TEST_80BIT_CUSTOM_PATTERN_7_0)+1] = {0};
+	enum dp_test_pattern test_pattern;
+	struct dc_link_training_settings link_settings;
+	union lane_adjust dpcd_lane_adjust;
+	unsigned int lane;
+	struct link_training_settings link_training_settings;
+	int i = 0;
+
+	dpcd_test_pattern.raw = 0;
+	memset(dpcd_lane_adjustment, 0, sizeof(dpcd_lane_adjustment));
+	memset(&link_settings, 0, sizeof(link_settings));
+
+	/* get phy test pattern and pattern parameters from DP receiver */
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_PHY_PATTERN,
+			&dpcd_test_pattern.raw,
+			sizeof(dpcd_test_pattern));
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_ADJUST_REQUEST_LANE0_1,
+			&dpcd_lane_adjustment[0].raw,
+			sizeof(dpcd_lane_adjustment));
+
+	/*get post cursor 2 parameters
+	 * For DP 1.1a or eariler, this DPCD register's value is 0
+	 * For DP 1.2 or later:
+	 * Bits 1:0 = POST_CURSOR2_LANE0; Bits 3:2 = POST_CURSOR2_LANE1
+	 * Bits 5:4 = POST_CURSOR2_LANE2; Bits 7:6 = POST_CURSOR2_LANE3
+	 */
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_ADJUST_REQUEST_POST_CURSOR2,
+			&dpcd_post_cursor_2_adjustment,
+			sizeof(dpcd_post_cursor_2_adjustment));
+
+	/* translate request */
+	switch (dpcd_test_pattern.bits.PATTERN) {
+	case PHY_TEST_PATTERN_D10_2:
+		test_pattern = DP_TEST_PATTERN_D102;
+	break;
+	case PHY_TEST_PATTERN_SYMBOL_ERROR:
+		test_pattern = DP_TEST_PATTERN_SYMBOL_ERROR;
+	break;
+	case PHY_TEST_PATTERN_PRBS7:
+		test_pattern = DP_TEST_PATTERN_PRBS7;
+	break;
+	case PHY_TEST_PATTERN_80BIT_CUSTOM:
+		test_pattern = DP_TEST_PATTERN_80BIT_CUSTOM;
+	break;
+	case PHY_TEST_PATTERN_HBR2_COMPLIANCE_EYE:
+		test_pattern = DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE;
+	break;
+	default:
+		test_pattern = DP_TEST_PATTERN_VIDEO_MODE;
+	break;
+	}
+
+	if (test_pattern == DP_TEST_PATTERN_80BIT_CUSTOM)
+		core_link_read_dpcd(
+				link,
+				DPCD_ADDRESS_TEST_80BIT_CUSTOM_PATTERN_7_0,
+				test_80_bit_pattern,
+				sizeof(test_80_bit_pattern));
+
+	/* prepare link training settings */
+	link_settings.link = link->public.cur_link_settings;
+
+	for (lane = 0; lane <
+		(unsigned int)(link->public.cur_link_settings.lane_count);
+		lane++) {
+		dpcd_lane_adjust.raw =
+			get_nibble_at_index(&dpcd_lane_adjustment[0].raw, lane);
+		link_settings.lane_settings[lane].VOLTAGE_SWING =
+			(enum dc_voltage_swing)
+			(dpcd_lane_adjust.bits.VOLTAGE_SWING_LANE);
+		link_settings.lane_settings[lane].PRE_EMPHASIS =
+			(enum dc_pre_emphasis)
+			(dpcd_lane_adjust.bits.PRE_EMPHASIS_LANE);
+		link_settings.lane_settings[lane].POST_CURSOR2 =
+			(enum dc_post_cursor2)
+			((dpcd_post_cursor_2_adjustment >> (lane * 2)) & 0x03);
+	}
+
+	for (i = 0; i < 4; i++)
+		link_training_settings.lane_settings[i] =
+				link_settings.lane_settings[i];
+	link_training_settings.link_settings = link_settings.link;
+	link_training_settings.allow_invalid_msa_timing_param = false;
+	/*Usage: Measure DP physical lane signal
+	 * by DP SI test equipment automatically.
+	 * PHY test pattern request is generated by equipment via HPD interrupt.
+	 * HPD needs to be active all the time. HPD should be active
+	 * all the time. Do not touch it.
+	 * forward request to DS
+	 */
+	dc_link_dp_set_test_pattern(
+		&link->public,
+		test_pattern,
+		&link_training_settings,
+		test_80_bit_pattern,
+		(DPCD_ADDRESS_TEST_80BIT_CUSTOM_PATTERN_79_72 -
+		DPCD_ADDRESS_TEST_80BIT_CUSTOM_PATTERN_7_0)+1);
+}
+
+static void dp_test_send_link_test_pattern(struct core_link *link)
+{
+	union link_test_pattern dpcd_test_pattern;
+	union test_misc dpcd_test_params;
+
+	memset(&dpcd_test_pattern, 0, sizeof(dpcd_test_pattern));
+	memset(&dpcd_test_params, 0, sizeof(dpcd_test_params));
+
+	/* get link test pattern and pattern parameters */
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_PATTERN,
+			&dpcd_test_pattern.raw,
+			sizeof(dpcd_test_pattern));
+	core_link_read_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_MISC1,
+			&dpcd_test_params.raw,
+			sizeof(dpcd_test_params));
+
+	/* translate request */
+	enum controller_dp_test_pattern test_pattern;
+	enum dc_color_depth color_depth;
+
+	switch (dpcd_test_pattern.bits.PATTERN) {
+	case LINK_TEST_PATTERN_COLOR_RAMP:
+		test_pattern = CONTROLLER_DP_TEST_PATTERN_COLORRAMP;
+	break;
+	case LINK_TEST_PATTERN_VERTICAL_BARS:
+		test_pattern = CONTROLLER_DP_TEST_PATTERN_VERTICALBARS;
+	break; /* black and white */
+	case LINK_TEST_PATTERN_COLOR_SQUARES:
+		test_pattern = (dpcd_test_params.bits.DYN_RANGE ==
+				TEST_DYN_RANGE_VESA ?
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES :
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA);
+	break;
+	default:
+		test_pattern = CONTROLLER_DP_TEST_PATTERN_VIDEOMODE;
+	break;
+	}
+
+	switch (dpcd_test_params.bits.BPC) {
+	case TEST_BIT_DEPTH_6:
+		color_depth = COLOR_DEPTH_666;
+	break;
+	case TEST_BIT_DEPTH_8:
+		color_depth = COLOR_DEPTH_888;
+	break;
+	case TEST_BIT_DEPTH_10:
+		color_depth = COLOR_DEPTH_101010;
+	break;
+	case TEST_BIT_DEPTH_12:
+		color_depth = COLOR_DEPTH_121212;
+	break;
+	case TEST_BIT_DEPTH_16:
+		color_depth = COLOR_DEPTH_161616;
+	break;
+	default:
+		color_depth = COLOR_DEPTH_UNDEFINED;
+	break;
+	}
+
+	link->dc->current_context->res_ctx.pipe_ctx->tg->funcs->
+		set_test_pattern(link->dc->current_context->res_ctx.
+				pipe_ctx->tg, test_pattern, color_depth);
+}
+
+static void handle_automated_test(struct core_link *link)
+{
+	union test_request test_request;
+	union test_response test_response;
+
+	memset(&test_request, 0, sizeof(test_request));
+	memset(&test_response, 0, sizeof(test_response));
+
+	core_link_read_dpcd(
+		link,
+		DPCD_ADDRESS_TEST_REQUEST,
+		&test_request.raw,
+		sizeof(union test_request));
+	if (test_request.bits.LINK_TRAINING) {
+		/* ACK first to let DP RX test box monitor LT sequence */
+		test_response.bits.ACK = 1;
+		core_link_write_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_RESPONSE,
+			&test_response.raw,
+			sizeof(test_response));
+		dp_test_send_link_training(link);
+		/* no acknowledge request is needed again */
+		test_response.bits.ACK = 0;
+	}
+	if (test_request.bits.LINK_TEST_PATTRN) {
+		dp_test_send_link_test_pattern(link);
+		link->public.compliance_test_state.bits.
+			SET_TEST_PATTERN_PENDING = 1;
+	}
+	if (test_request.bits.PHY_TEST_PATTERN) {
+		dp_test_send_phy_test_pattern(link);
+		test_response.bits.ACK = 1;
+	}
+	if (!test_request.raw)
+		/* no requests, revert all test signals
+		 * TODO: revert all test signals
+		 */
+		test_response.bits.ACK = 1;
+	/* send request acknowledgment */
+	if (test_response.bits.ACK)
+		core_link_write_dpcd(
+			link,
+			DPCD_ADDRESS_TEST_RESPONSE,
+			&test_response.raw,
+			sizeof(test_response));
+}
+
 bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link)
 {
 	struct core_link *link = DC_LINK_TO_LINK(dc_link);
@@ -1563,28 +1813,37 @@ bool dc_link_handle_hpd_rx_irq(const struct dc_link *dc_link)
 		"%s: Got short pulse HPD on link %d\n",
 		__func__, link->public.link_index);
 
-	if (!allow_hpd_rx_irq(link)) {
+	 /* All the "handle_hpd_irq_xxx()" methods
+		 * should be called only after
+		 * dal_dpsst_ls_read_hpd_irq_data
+		 * Order of calls is important too
+		 */
+	result = read_hpd_rx_irq_data(link, &hpd_irq_dpcd_data);
+
+	if (result != DC_OK) {
 		dal_logger_write(link->ctx->logger,
 			LOG_MAJOR_HW_TRACE,
 			LOG_MINOR_HW_TRACE_HPD_IRQ,
-			"%s: skipping HPD handling on %d\n",
-			__func__, link->public.link_index);
+			"%s: DPCD read failed to obtain irq data\n",
+			__func__);
 		return false;
 	}
 
-	 /* All the "handle_hpd_irq_xxx()" methods
-	 * should be called only after
-	 * dal_dpsst_ls_read_hpd_irq_data
-	 * Order of calls is important too
-	 */
-	result = read_hpd_rx_irq_data(link, &hpd_irq_dpcd_data);
+	if (hpd_irq_dpcd_data.bytes.device_service_irq.bits.AUTOMATED_TEST) {
+		core_link_write_dpcd(
+			link,
+			DPCD_ADDRESS_DEVICE_SERVICE_IRQ_VECTOR,
+			&hpd_irq_dpcd_data.bytes.device_service_irq.raw,
+			sizeof(hpd_irq_dpcd_data.bytes.device_service_irq));
+		handle_automated_test(link);
+	}
 
-	if (result != DC_OK) {
+	if (!allow_hpd_rx_irq(link)) {
 		dal_logger_write(link->ctx->logger,
 			LOG_MAJOR_HW_TRACE,
 			LOG_MINOR_HW_TRACE_HPD_IRQ,
-			"%s: DPCD read failed to obtain irq data\n",
-			__func__);
+			"%s: skipping HPD handling on %d\n",
+			__func__, link->public.link_index);
 		return false;
 	}
 
@@ -1912,6 +2171,9 @@ static void retrieve_link_cap(struct core_link *link)
 
 	link->edp_revision = DPCD_EDP_REVISION_EDP_UNKNOWN;
 
+	link->public.test_pattern_enabled = false;
+	link->public.compliance_test_state.raw = 0;
+
 	/* read sink count */
 	core_link_read_dpcd(link,
 			DPCD_ADDRESS_SINK_COUNT,
@@ -1954,3 +2216,282 @@ void detect_dp_sink_caps(struct core_link *link)
 	}
 	/* TODO save sink caps in link->sink */
 }
+
+void dc_link_dp_enable_hpd(const struct dc_link *link)
+{
+	struct core_link *core_link = DC_LINK_TO_CORE(link);
+	struct link_encoder *encoder = core_link->link_enc;
+
+	if (encoder != NULL && encoder->funcs->enable_hpd != NULL)
+		encoder->funcs->enable_hpd(encoder);
+}
+
+void dc_link_dp_disable_hpd(const struct dc_link *link)
+{
+	struct core_link *core_link = DC_LINK_TO_CORE(link);
+	struct link_encoder *encoder = core_link->link_enc;
+
+	if (encoder != NULL && encoder->funcs->enable_hpd != NULL)
+		encoder->funcs->disable_hpd(encoder);
+}
+
+static bool is_dp_phy_pattern(enum dp_test_pattern test_pattern)
+{
+	if (test_pattern == DP_TEST_PATTERN_D102 ||
+	test_pattern == DP_TEST_PATTERN_SYMBOL_ERROR ||
+	test_pattern == DP_TEST_PATTERN_PRBS7 ||
+	test_pattern == DP_TEST_PATTERN_80BIT_CUSTOM ||
+	test_pattern == DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE ||
+	test_pattern == DP_TEST_PATTERN_TRAINING_PATTERN1 ||
+	test_pattern == DP_TEST_PATTERN_TRAINING_PATTERN2 ||
+	test_pattern == DP_TEST_PATTERN_TRAINING_PATTERN3 ||
+	test_pattern == DP_TEST_PATTERN_TRAINING_PATTERN4 ||
+	test_pattern == DP_TEST_PATTERN_VIDEO_MODE)
+		return true;
+	else
+		return false;
+}
+
+static void set_crtc_test_pattern(struct core_link *link,
+				struct pipe_ctx *pipe_ctx,
+				enum dp_test_pattern test_pattern)
+{
+	enum controller_dp_test_pattern controller_test_pattern;
+	enum dc_color_depth color_depth = pipe_ctx->
+		stream->public.timing.display_color_depth;
+	struct bit_depth_reduction_params params;
+
+	memset(&params, 0, sizeof(params));
+
+	switch (test_pattern) {
+	case DP_TEST_PATTERN_COLOR_SQUARES:
+		controller_test_pattern =
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES;
+	break;
+	case DP_TEST_PATTERN_COLOR_SQUARES_CEA:
+		controller_test_pattern =
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA;
+	break;
+	case DP_TEST_PATTERN_VERTICAL_BARS:
+		controller_test_pattern =
+				CONTROLLER_DP_TEST_PATTERN_VERTICALBARS;
+	break;
+	case DP_TEST_PATTERN_HORIZONTAL_BARS:
+		controller_test_pattern =
+				CONTROLLER_DP_TEST_PATTERN_HORIZONTALBARS;
+	break;
+	case DP_TEST_PATTERN_COLOR_RAMP:
+		controller_test_pattern =
+				CONTROLLER_DP_TEST_PATTERN_COLORRAMP;
+	break;
+	default:
+		controller_test_pattern =
+				CONTROLLER_DP_TEST_PATTERN_VIDEOMODE;
+	break;
+	}
+
+	switch (test_pattern) {
+	case DP_TEST_PATTERN_COLOR_SQUARES:
+	case DP_TEST_PATTERN_COLOR_SQUARES_CEA:
+	case DP_TEST_PATTERN_VERTICAL_BARS:
+	case DP_TEST_PATTERN_HORIZONTAL_BARS:
+	case DP_TEST_PATTERN_COLOR_RAMP:
+	{
+		/* disable bit depth reduction */
+		pipe_ctx->stream->bit_depth_params = params;
+		pipe_ctx->opp->funcs->
+			opp_program_bit_depth_reduction(pipe_ctx->opp, &params);
+
+		pipe_ctx->tg->funcs->set_test_pattern(pipe_ctx->tg,
+				controller_test_pattern, color_depth);
+	}
+	break;
+	case DP_TEST_PATTERN_VIDEO_MODE:
+	{
+		/* restore bitdepth reduction */
+		link->dc->current_context->res_ctx.pool->funcs->
+			build_bit_depth_reduction_params(pipe_ctx->stream,
+					&params);
+		pipe_ctx->stream->bit_depth_params = params;
+		pipe_ctx->opp->funcs->
+			opp_program_bit_depth_reduction(pipe_ctx->opp, &params);
+
+		pipe_ctx->tg->funcs->set_test_pattern(pipe_ctx->tg,
+				CONTROLLER_DP_TEST_PATTERN_VIDEOMODE,
+				color_depth);
+	}
+	break;
+
+	default:
+	break;
+	}
+}
+
+bool dc_link_dp_set_test_pattern(
+	const struct dc_link *link,
+	enum dp_test_pattern test_pattern,
+	const struct link_training_settings *p_link_settings,
+	const unsigned char *p_custom_pattern,
+	unsigned int cust_pattern_size)
+{
+	struct core_link *core_link = DC_LINK_TO_CORE(link);
+	struct pipe_ctx *pipes =
+			core_link->dc->current_context->res_ctx.pipe_ctx;
+	struct pipe_ctx pipe_ctx = pipes[0];
+	unsigned int lane;
+	unsigned int i;
+	unsigned char link_qual_pattern[LANE_COUNT_DP_MAX] = {0};
+	union dpcd_training_pattern training_pattern;
+	union test_response test_response;
+
+	memset(&training_pattern, 0, sizeof(training_pattern));
+	memset(&test_response, 0, sizeof(test_response));
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (pipes[i].stream->sink->link == core_link) {
+			pipe_ctx = pipes[i];
+			break;
+		}
+	}
+
+	/* Reset CRTC Test Pattern if it is currently running and request
+	 * is VideoMode Reset DP Phy Test Pattern if it is currently running
+	 * and request is VideoMode
+	 */
+	if (core_link->public.test_pattern_enabled && test_pattern ==
+			DP_TEST_PATTERN_VIDEO_MODE) {
+		/* Set CRTC Test Pattern */
+		set_crtc_test_pattern(core_link, &pipe_ctx, test_pattern);
+		dp_set_hw_test_pattern(core_link, test_pattern,
+				(uint8_t *)p_custom_pattern,
+				(uint32_t)cust_pattern_size);
+
+		/* Unblank Stream */
+		core_link->dc->hwss.unblank_stream(
+			&pipe_ctx,
+			&core_link->public.verified_link_cap);
+		/* TODO:m_pHwss->MuteAudioEndpoint
+		 * (pPathMode->pDisplayPath, false);
+		 */
+
+		/* Reset Test Pattern state */
+		core_link->public.test_pattern_enabled = false;
+
+		return true;
+	}
+
+	/* Check for PHY Test Patterns */
+	if (is_dp_phy_pattern(test_pattern)) {
+		/* Set DPCD Lane Settings before running test pattern */
+		if (p_link_settings != NULL) {
+			dp_set_hw_lane_settings(core_link, p_link_settings);
+			dpcd_set_lane_settings(core_link, p_link_settings);
+		}
+
+		/* Blank stream if running test pattern */
+		if (test_pattern != DP_TEST_PATTERN_VIDEO_MODE) {
+			/*TODO:
+			 * m_pHwss->
+			 * MuteAudioEndpoint(pPathMode->pDisplayPath, true);
+			 */
+			/* Blank stream */
+			pipes->stream_enc->funcs->dp_blank(pipe_ctx.stream_enc);
+		}
+
+		dp_set_hw_test_pattern(core_link, test_pattern,
+				(uint8_t *)p_custom_pattern,
+				(uint32_t)cust_pattern_size);
+
+		if (test_pattern != DP_TEST_PATTERN_VIDEO_MODE) {
+			/* Set Test Pattern state */
+			core_link->public.test_pattern_enabled = true;
+			if (p_link_settings != NULL)
+				dpcd_set_link_settings(core_link,
+						p_link_settings);
+		}
+
+		enum dpcd_phy_test_patterns pattern;
+
+		switch (test_pattern) {
+		case DP_TEST_PATTERN_VIDEO_MODE:
+			pattern = PHY_TEST_PATTERN_NONE;
+		break;
+		case DP_TEST_PATTERN_D102:
+			pattern = PHY_TEST_PATTERN_D10_2;
+		break;
+		case DP_TEST_PATTERN_SYMBOL_ERROR:
+			pattern = PHY_TEST_PATTERN_SYMBOL_ERROR;
+		break;
+		case DP_TEST_PATTERN_PRBS7:
+			pattern = PHY_TEST_PATTERN_PRBS7;
+		break;
+		case DP_TEST_PATTERN_80BIT_CUSTOM:
+			pattern = PHY_TEST_PATTERN_80BIT_CUSTOM;
+		break;
+		case DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE:
+			pattern = PHY_TEST_PATTERN_HBR2_COMPLIANCE_EYE;
+		break;
+		default:
+			return false;
+		}
+
+		if (test_pattern == DP_TEST_PATTERN_VIDEO_MODE
+		/*TODO:&& !pPathMode->pDisplayPath->IsTargetPoweredOn()*/)
+			return false;
+
+		if (core_link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {
+			/* tell receiver that we are sending qualification
+			 * pattern DP 1.2 or later - DP receiver's link quality
+			 * pattern is set using DPCD LINK_QUAL_LANEx_SET
+			 * register (0x10B~0x10E)\
+			 */
+			for (lane = 0; lane < LANE_COUNT_DP_MAX; lane++)
+				link_qual_pattern[lane] =
+						(unsigned char)(pattern);
+
+			core_link_write_dpcd(core_link,
+					DPCD_ADDRESS_LINK_QUAL_LANE0_SET,
+					link_qual_pattern,
+					sizeof(link_qual_pattern));
+		} else if (core_link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_10 ||
+				core_link->dpcd_caps.dpcd_rev.raw == 0) {
+			/* tell receiver that we are sending qualification
+			 * pattern DP 1.1a or earlier - DP receiver's link
+			 * quality pattern is set using
+			 * DPCD TRAINING_PATTERN_SET -> LINK_QUAL_PATTERN_SET
+			 * register (0x102). We will use v_1.3 when we are
+			 * setting test pattern for DP 1.1.
+			 */
+			core_link_read_dpcd(core_link,
+					DPCD_ADDRESS_TRAINING_PATTERN_SET,
+					&training_pattern.raw,
+					sizeof(training_pattern));
+			training_pattern.v1_3.LINK_QUAL_PATTERN_SET = pattern;
+			core_link_write_dpcd(core_link,
+					DPCD_ADDRESS_TRAINING_PATTERN_SET,
+					&training_pattern.raw,
+					sizeof(training_pattern));
+		}
+	} else {
+	/* CRTC Patterns */
+		set_crtc_test_pattern(core_link, &pipe_ctx, test_pattern);
+		/* Set Test Pattern state */
+		core_link->public.test_pattern_enabled = true;
+
+		/* If this is called because of compliance test request,
+		 * we respond ack here.
+		 */
+		if (core_link->public.compliance_test_state.bits.
+				SET_TEST_PATTERN_PENDING == 1) {
+			core_link->public.compliance_test_state.bits.
+						SET_TEST_PATTERN_PENDING = 0;
+			test_response.bits.ACK = 1;
+			core_link_write_dpcd(core_link,
+					DPCD_ADDRESS_TEST_RESPONSE,
+					&test_response.raw,
+					sizeof(test_response));
+		}
+	}
+
+	return true;
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
index 98ff372..e18fb1c 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_link_hwss.c
@@ -125,7 +125,7 @@ bool dp_set_hw_training_pattern(
 		break;
 	}
 
-	dp_set_hw_test_pattern(link, test_pattern);
+	dp_set_hw_test_pattern(link, test_pattern, NULL, 0);
 
 	return true;
 }
@@ -182,15 +182,35 @@ enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
 
 void dp_set_hw_test_pattern(
 	struct core_link *link,
-	enum dp_test_pattern test_pattern)
+	enum dp_test_pattern test_pattern,
+	uint8_t *custom_pattern,
+	uint32_t custom_pattern_size)
 {
 	struct encoder_set_dp_phy_pattern_param pattern_param = {0};
 	struct link_encoder *encoder = link->link_enc;
 
 	pattern_param.dp_phy_pattern = test_pattern;
-	pattern_param.custom_pattern = NULL;
-	pattern_param.custom_pattern_size = 0;
+	pattern_param.custom_pattern = custom_pattern;
+	pattern_param.custom_pattern_size = custom_pattern_size;
 	pattern_param.dp_panel_mode = dp_get_panel_mode(link);
 
 	encoder->funcs->dp_set_phy_pattern(encoder, &pattern_param);
 }
+
+
+void dp_retrain_link(struct core_link *link)
+{
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
+	unsigned int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (pipes[i].stream_enc != NULL) {
+			dm_delay_in_microseconds(link->ctx, 100);
+			pipes->stream_enc->funcs->dp_blank(pipes[i].stream_enc);
+			link->dc->hwss.disable_stream(&pipes[i]);
+			link->dc->hwss.enable_stream(&pipes[i]);
+			link->dc->hwss.unblank_stream(&pipes[i],
+					&link->public.verified_link_cap);
+		}
+	}
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
index f9cd5f5..bcb8e6e 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_resource.c
@@ -1710,10 +1710,8 @@ static void set_vsc_info_packet(struct core_stream *stream,
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
-	bool psrPanelSupport = false;
 
 	if (stream->sink->link->public.psr_caps.psr_version != 0) {
-		psrPanelSupport = true;
 		vscPacketRevision = 2;
 	}
 
diff --git a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
index 01fa198..8d6aa60 100644
--- a/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/dal/dc/core/dc_stream.c
@@ -101,11 +101,14 @@ void dc_stream_release(const struct dc_stream *public)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(public);
 	struct core_stream *protected = DC_STREAM_TO_CORE(public);
-	stream->ref_count--;
 
-	if (stream->ref_count == 0) {
-		destruct(protected);
-		dm_free(stream);
+	if (public != NULL) {
+		stream->ref_count--;
+
+		if (stream->ref_count == 0) {
+			destruct(protected);
+			dm_free(stream);
+		}
 	}
 }
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dc.h b/drivers/gpu/drm/amd/dal/dc/dc.h
index 6f0947e..d47c1fc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dc.h
+++ b/drivers/gpu/drm/amd/dal/dc/dc.h
@@ -31,6 +31,7 @@
 #include "grph_object_defs.h"
 #include "logger_types.h"
 #include "gpio_types.h"
+#include "link_service_types.h"
 
 #define MAX_TARGETS 6
 #define MAX_SURFACES 6
@@ -87,6 +88,14 @@ struct dc_link_funcs {
 			bool skip_video_pattern);
 	void (*set_preferred_link_settings)(struct dc *dc,
 			struct dc_link_settings *link_setting);
+	void (*enable_hpd)(const struct dc_link *link);
+	void (*disable_hpd)(const struct dc_link *link);
+	void (*set_test_pattern)(
+			const struct dc_link *link,
+			enum dp_test_pattern test_pattern,
+			const struct link_training_settings *p_link_settings,
+			const unsigned char *p_custom_pattern,
+			unsigned int cust_pattern_size);
 };
 
 /* Structure to hold configuration flags set by dm at dc creation. */
@@ -475,6 +484,8 @@ struct dc_link {
 	uint8_t link_enc_hw_inst;
 
 	struct psr_caps psr_caps;
+	bool test_pattern_enabled;
+	union compliance_test_state compliance_test_state;
 };
 
 struct dpcd_caps {
@@ -568,6 +579,17 @@ bool dc_link_dp_perform_link_training(
 	const struct dc_link_settings *link_setting,
 	bool skip_video_pattern);
 
+void dc_link_dp_enable_hpd(const struct dc_link *link);
+
+void dc_link_dp_disable_hpd(const struct dc_link *link);
+
+bool dc_link_dp_set_test_pattern(
+	const struct dc_link *link,
+	enum dp_test_pattern test_pattern,
+	const struct link_training_settings *p_link_settings,
+	const unsigned char *p_custom_pattern,
+	unsigned int cust_pattern_size);
+
 /*******************************************************************************
  * Sink Interfaces - A sink corresponds to a display output device
  ******************************************************************************/
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c
index 13f4b95..0e85ce2 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.c
@@ -68,13 +68,15 @@ bool dce100_link_encoder_construct(
 		struct dce110_link_encoder *enc110,
 		const struct encoder_init_data *init_data,
 		const struct dce110_link_enc_registers *link_regs,
-		const struct dce110_link_enc_aux_registers *aux_regs)
+		const struct dce110_link_enc_aux_registers *aux_regs,
+		const struct dce110_link_enc_hpd_registers *hpd_regs)
 {
 	dce110_link_encoder_construct(
 			enc110,
 			init_data,
 			link_regs,
-			aux_regs);
+			aux_regs,
+			hpd_regs);
 
 	enc110->base.funcs = &dce100_lnk_enc_funcs;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h
index 6c644c0..af5b864 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_link_encoder.h
@@ -36,6 +36,7 @@ bool dce100_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs);
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs);
 
 #endif /* __DC_LINK_ENCODER__DCE100_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
index ac85178..8a651af 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce100/dce100_resource.c
@@ -258,6 +258,20 @@ static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
 		aux_regs(5)
 };
 
+#define hpd_regs(id)\
+[id] = {\
+	HPD_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {
+		hpd_regs(0),
+		hpd_regs(1),
+		hpd_regs(2),
+		hpd_regs(3),
+		hpd_regs(4),
+		hpd_regs(5)
+};
+
 #define link_regs(id)\
 [id] = {\
 	LE_DCE110_REG_LIST(id)\
@@ -501,7 +515,8 @@ struct link_encoder *dce100_link_encoder_create(
 			enc110,
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
-			&link_enc_aux_regs[enc_init_data->channel - 1]))
+			&link_enc_aux_regs[enc_init_data->channel - 1],
+			&link_enc_hpd_regs[enc_init_data->hpd_source]))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
index 848e7b2..324a7ae 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_hw_sequencer.c
@@ -2092,6 +2092,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.update_info_frame = update_info_frame,
 	.enable_stream = enable_stream,
 	.disable_stream = disable_stream,
+	.unblank_stream = unblank_stream,
 	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
 	.crtc_switch_to_clk_src = dce110_crtc_switch_to_clk_src,
 	.enable_display_power_gating = dce110_enable_display_power_gating,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
index 0617d28..6bdb202 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.c
@@ -51,6 +51,14 @@
 #define ATOM_S2_CURRENT_BL_LEVEL_SHIFT  8
 #endif
 
+#ifndef HPD0_DC_HPD_CONTROL__DC_HPD_EN_MASK
+#define HPD0_DC_HPD_CONTROL__DC_HPD_EN_MASK  0x10000000L
+#endif
+
+#ifndef HPD0_DC_HPD_CONTROL__DC_HPD_EN__SHIFT
+#define HPD0_DC_HPD_CONTROL__DC_HPD_EN__SHIFT  0x1c
+#endif
+
 #define CTX \
 	enc110->base.ctx
 
@@ -60,6 +68,9 @@
 #define AUX_REG(reg)\
 	(enc110->aux_regs->reg)
 
+#define HPD_REG(reg)\
+	(enc110->hpd_regs->reg)
+
 /* For current ASICs pixel clock - 600MHz */
 #define MAX_ENCODER_CLK 600000
 
@@ -146,6 +157,8 @@ static const struct link_encoder_funcs dce110_lnk_enc_funcs = {
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
+	.enable_hpd = dce110_link_encoder_enable_hpd,
+	.disable_hpd = dce110_link_encoder_disable_hpd,
 	.destroy = dce110_link_encoder_destroy
 };
 
@@ -967,7 +980,8 @@ bool dce110_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs)
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs)
 {
 	struct graphics_object_encoder_cap_info enc_cap_info = {0};
 	struct adapter_service *as = init_data->adapter_service;
@@ -1029,6 +1043,7 @@ bool dce110_link_encoder_construct(
 
 	enc110->link_regs = link_regs;
 	enc110->aux_regs = aux_regs;
+	enc110->hpd_regs = hpd_regs;
 
 	switch (enc110->base.transmitter) {
 	case TRANSMITTER_UNIPHY_A:
@@ -1655,8 +1670,6 @@ void dce110_link_encoder_set_lcd_backlight_level(
 
 	const uint32_t backlight_update_pending_max_retry = 1000;
 
-	uint32_t backlight;
-	uint32_t backlight_period;
 	uint32_t backlight_lock;
 
 	uint32_t i;
@@ -1669,8 +1682,6 @@ void dce110_link_encoder_set_lcd_backlight_level(
 	uint64_t active_duty_cycle;
 	uint32_t pwm_period_bitcnt;
 
-	backlight = REG_READ(BL_PWM_CNTL);
-	backlight_period = REG_READ(BL_PWM_PERIOD_CNTL);
 	backlight_lock = REG_READ(BL_PWM_GRP1_REG_LOCK);
 
 	/*
@@ -1833,7 +1844,6 @@ void dce110_link_encoder_init_dmcu_backlight_settings(
 	uint32_t pwmCntl;
 	uint32_t pwmCntl2;
 	uint32_t periodCntl;
-	uint32_t pwmSeqRefDiv;
 	uint32_t s2;
 	uint32_t value;
 
@@ -1870,8 +1880,6 @@ void dce110_link_encoder_init_dmcu_backlight_settings(
 		stored_backlight_registers.vBL_PWM_PERIOD_CNTL =
 				REG_READ(BL_PWM_PERIOD_CNTL);
 
-		pwmSeqRefDiv = REG_READ(LVTMA_PWRSEQ_REF_DIV);
-
 		REG_GET(LVTMA_PWRSEQ_REF_DIV, BL_PWM_REF_DIV,
 				&stored_backlight_registers.
 				vLVTMA_PWRSEQ_REF_DIV_BL_PWM_REF_DIV);
@@ -1923,8 +1931,6 @@ static void get_dmcu_psr_state(struct link_encoder *enc, uint32_t *psr_state)
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
 	struct dc_context *ctx = enc110->base.ctx;
 
-	uint32_t powerStatus;
-
 	uint32_t count = 0;
 	uint32_t psrStateOffset = 0xf0;
 	uint32_t value;
@@ -1934,7 +1940,6 @@ static void get_dmcu_psr_state(struct link_encoder *enc, uint32_t *psr_state)
 
 	do {
 		dm_delay_in_microseconds(ctx, 2);
-		powerStatus = REG_READ(DCI_MEM_PWR_STATUS);
 		REG_GET(DCI_MEM_PWR_STATUS,
 					DMCU_IRAM_MEM_PWR_STATE, &value);
 	} while
@@ -2172,3 +2177,26 @@ void dce110_link_encoder_connect_dig_be_to_fe(
 	}
 }
 
+void dce110_link_encoder_enable_hpd(struct link_encoder *enc)
+{
+	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
+	struct dc_context *ctx = enc110->base.ctx;
+	uint32_t addr = HPD_REG(DC_HPD_CONTROL);
+	uint32_t hpd_enable = 0;
+	uint32_t value = dm_read_reg(ctx, addr);
+
+	get_reg_field_value(hpd_enable, DC_HPD_CONTROL, DC_HPD_EN);
+
+	if (hpd_enable == 0)
+		set_reg_field_value(value, 1, DC_HPD_CONTROL, DC_HPD_EN);
+}
+
+void dce110_link_encoder_disable_hpd(struct link_encoder *enc)
+{
+	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
+	struct dc_context *ctx = enc110->base.ctx;
+	uint32_t addr = HPD_REG(DC_HPD_CONTROL);
+	uint32_t value = dm_read_reg(ctx, addr);
+
+	set_reg_field_value(value, 0, DC_HPD_CONTROL, DC_HPD_EN);
+}
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
index 35ab6fd..b499972 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_link_encoder.h
@@ -35,6 +35,9 @@
 	SRI(AUX_CONTROL, DP_AUX, id), \
 	SRI(AUX_DPHY_RX_CONTROL0, DP_AUX, id)
 
+#define HPD_REG_LIST(id)\
+	SRI(DC_HPD_CONTROL, HPD, id)
+
 #define LE_COMMON_REG_LIST_BASE(id) \
 	SR(BL_PWM_CNTL), \
 	SR(BL_PWM_GRP1_REG_LOCK), \
@@ -74,7 +77,6 @@
 	SRI(DP_DPHY_FAST_TRAINING, DP, id), \
 	SRI(DP_SEC_CNTL1, DP, id)
 
-
 	#define LE_COMMON_REG_LIST(id)\
 		LE_COMMON_REG_LIST_BASE(id), \
 		SRI(DP_DPHY_BS_SR_SWAP_CNTL, DP, id), \
@@ -99,6 +101,10 @@ struct dce110_link_enc_aux_registers {
 	uint32_t AUX_DPHY_RX_CONTROL0;
 };
 
+struct dce110_link_enc_hpd_registers {
+	uint32_t DC_HPD_CONTROL;
+};
+
 struct dce110_link_enc_registers {
 	/* BL registers */
 	uint32_t BL_PWM_CNTL;
@@ -152,6 +158,7 @@ struct dce110_link_encoder {
 	struct link_encoder base;
 	const struct dce110_link_enc_registers *link_regs;
 	const struct dce110_link_enc_aux_registers *aux_regs;
+	const struct dce110_link_enc_hpd_registers *hpd_regs;
 };
 
 /*******************************************************************
@@ -222,7 +229,8 @@ bool dce110_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs);
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs);
 
 bool dce110_link_encoder_validate_dvi_output(
 	const struct dce110_link_encoder *enc110,
@@ -340,4 +348,8 @@ void dce110_link_encoder_set_dp_phy_pattern_training_pattern(
 	struct link_encoder *enc,
 	uint32_t index);
 
+void dce110_link_encoder_enable_hpd(struct link_encoder *enc);
+
+void dce110_link_encoder_disable_hpd(struct link_encoder *enc);
+
 #endif /* __DC_LINK_ENCODER__DCE110_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c
index 64baff6..4b32397 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_opp_v.c
@@ -47,6 +47,8 @@ static const struct opp_funcs funcs = {
 		.opp_set_regamma_mode = dce110_opp_set_regamma_mode,
 		.opp_destroy = dce110_opp_destroy,
 		.opp_program_fmt = dce110_opp_program_fmt,
+		.opp_program_bit_depth_reduction =
+				dce110_opp_program_bit_depth_reduction
 };
 
 bool dce110_opp_v_construct(struct dce110_opp *opp110,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
index a70135c..eab5f44 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.c
@@ -214,6 +214,21 @@ static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
 		aux_regs(5)
 };
 
+#define hpd_regs(id)\
+[id] = {\
+	HPD_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {
+		hpd_regs(0),
+		hpd_regs(1),
+		hpd_regs(2),
+		hpd_regs(3),
+		hpd_regs(4),
+		hpd_regs(5)
+};
+
+
 #define link_regs(id)\
 [id] = {\
 	LE_DCE110_REG_LIST(id)\
@@ -469,7 +484,8 @@ struct link_encoder *dce110_link_encoder_create(
 			enc110,
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
-			&link_enc_aux_regs[enc_init_data->channel - 1]))
+			&link_enc_aux_regs[enc_init_data->channel - 1],
+			&link_enc_hpd_regs[enc_init_data->hpd_source]))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
@@ -1001,7 +1017,9 @@ static const struct resource_funcs dce110_res_pool_funcs = {
 	.validate_with_context = dce110_validate_with_context,
 	.validate_guaranteed = dce110_validate_guaranteed,
 	.validate_bandwidth = dce110_validate_bandwidth,
-	.acquire_idle_pipe_for_layer = dce110_acquire_idle_pipe_for_layer
+	.acquire_idle_pipe_for_layer = dce110_acquire_idle_pipe_for_layer,
+	.build_bit_depth_reduction_params =
+			dce110_resource_build_bit_depth_reduction_params
 };
 
 static void underlay_create(struct dc_context *ctx, struct resource_pool *pool)
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
index 00799f3..95c5873 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_resource.h
@@ -44,6 +44,10 @@ enum dc_status dce110_resource_build_pipe_hw_param(struct pipe_ctx *pipe_ctx);
 enum clocks_state dce110_resource_convert_clock_state_pp_to_dc(
 	enum dm_pp_clocks_state pp_clock_state);
 
+void dce110_resource_build_bit_depth_reduction_params(
+		const struct core_stream *stream,
+		struct bit_depth_reduction_params *fmt_bit_depth);
+
 struct resource_pool *dce110_create_resource_pool(
 	struct adapter_service *as,
 	uint8_t num_virtual_links,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
index d29e9ec..de94845 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce110/dce110_timing_generator.c
@@ -698,10 +698,53 @@ void dce110_timing_generator_set_test_pattern(
 	uint32_t value;
 	uint32_t addr;
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
+	enum test_pattern_color_format bit_depth;
+	enum test_pattern_dyn_range dyn_range;
+	enum test_pattern_mode mode;
+	/* color ramp generator mixes 16-bits color */
+	uint32_t src_bpc = 16;
+	/* requested bpc */
+	uint32_t dst_bpc;
+	uint32_t index;
+	/* RGB values of the color bars.
+	 * Produce two RGB colors: RGB0 - white (all Fs)
+	 * and RGB1 - black (all 0s)
+	 * (three RGB components for two colors)
+	 */
+	uint16_t src_color[6] = {0xFFFF, 0xFFFF, 0xFFFF, 0x0000,
+						0x0000, 0x0000};
+	/* dest color (converted to the specified color format) */
+	uint16_t dst_color[6];
+	uint32_t inc_base;
+
+	/* translate to bit depth */
+	switch (color_depth) {
+	case COLOR_DEPTH_666:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_6;
+	break;
+	case COLOR_DEPTH_888:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;
+	break;
+	case COLOR_DEPTH_101010:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_10;
+	break;
+	case COLOR_DEPTH_121212:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_12;
+	break;
+	default:
+		bit_depth = TEST_PATTERN_COLOR_FORMAT_BPC_8;
+	break;
+	}
 
-	/* TODO: add support for other test patterns */
 	switch (test_pattern) {
-	default:
+	case CONTROLLER_DP_TEST_PATTERN_COLORSQUARES:
+	case CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA:
+	{
+		dyn_range = (test_pattern ==
+				CONTROLLER_DP_TEST_PATTERN_COLORSQUARES_CEA ?
+				TEST_PATTERN_DYN_RANGE_CEA :
+				TEST_PATTERN_DYN_RANGE_VESA);
+		mode = TEST_PATTERN_MODE_COLORSQUARES_RGB;
 		value = 0;
 		addr = CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS);
 
@@ -729,24 +772,323 @@ void dce110_timing_generator_set_test_pattern(
 
 		set_reg_field_value(
 			value,
-			0,
+			mode,
 			CRTC_TEST_PATTERN_CONTROL,
 			CRTC_TEST_PATTERN_MODE);
 
 		set_reg_field_value(
 			value,
-			1,
+			dyn_range,
 			CRTC_TEST_PATTERN_CONTROL,
 			CRTC_TEST_PATTERN_DYNAMIC_RANGE);
-		/* add color depth translation here */
+		set_reg_field_value(
+			value,
+			bit_depth,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_COLOR_FORMAT);
+		dm_write_reg(ctx, addr, value);
+	}
+	break;
+
+	case CONTROLLER_DP_TEST_PATTERN_VERTICALBARS:
+	case CONTROLLER_DP_TEST_PATTERN_HORIZONTALBARS:
+	{
+		mode = (test_pattern ==
+			CONTROLLER_DP_TEST_PATTERN_VERTICALBARS ?
+			TEST_PATTERN_MODE_VERTICALBARS :
+			TEST_PATTERN_MODE_HORIZONTALBARS);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+			dst_bpc = 6;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+			dst_bpc = 8;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+			dst_bpc = 10;
+		break;
+		default:
+			dst_bpc = 8;
+		break;
+		}
+
+		/* adjust color to the required colorFormat */
+		for (index = 0; index < 6; index++) {
+			/* dst = 2^dstBpc * src / 2^srcBpc = src >>
+			 * (srcBpc - dstBpc);
+			 */
+			dst_color[index] =
+				src_color[index] >> (src_bpc - dst_bpc);
+		/* CRTC_TEST_PATTERN_DATA has 16 bits,
+		 * lowest 6 are hardwired to ZERO
+		 * color bits should be left aligned aligned to MSB
+		 * XXXXXXXXXX000000 for 10 bit,
+		 * XXXXXXXX00000000 for 8 bit and XXXXXX0000000000 for 6
+		 */
+			dst_color[index] <<= (16 - dst_bpc);
+		}
+
+		value = 0;
+		addr = CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS);
+		dm_write_reg(ctx, addr, value);
+
+		/* We have to write the mask before data, similar to pipeline.
+		 * For example, for 8 bpc, if we want RGB0 to be magenta,
+		 * and RGB1 to be cyan,
+		 * we need to make 7 writes:
+		 * MASK   DATA
+		 * 000001 00000000 00000000                     set mask to R0
+		 * 000010 11111111 00000000     R0 255, 0xFF00, set mask to G0
+		 * 000100 00000000 00000000     G0 0,   0x0000, set mask to B0
+		 * 001000 11111111 00000000     B0 255, 0xFF00, set mask to R1
+		 * 010000 00000000 00000000     R1 0,   0x0000, set mask to G1
+		 * 100000 11111111 00000000     G1 255, 0xFF00, set mask to B1
+		 * 100000 11111111 00000000     B1 255, 0xFF00
+		 *
+		 * we will make a loop of 6 in which we prepare the mask,
+		 * then write, then prepare the color for next write.
+		 * first iteration will write mask only,
+		 * but each next iteration color prepared in
+		 * previous iteration will be written within new mask,
+		 * the last component will written separately,
+		 * mask is not changing between 6th and 7th write
+		 * and color will be prepared by last iteration
+		 */
+
+		/* write color, color values mask in CRTC_TEST_PATTERN_MASK
+		 * is B1, G1, R1, B0, G0, R0
+		 */
+		value = 0;
+		addr = CRTC_REG(mmCRTC_TEST_PATTERN_COLOR);
+		for (index = 0; index < 6; index++) {
+			/* prepare color mask, first write PATTERN_DATA
+			 * will have all zeros
+			 */
+			set_reg_field_value(
+				value,
+				(1 << index),
+				CRTC_TEST_PATTERN_COLOR,
+				CRTC_TEST_PATTERN_MASK);
+			/* write color component */
+			dm_write_reg(ctx, addr, value);
+			/* prepare next color component,
+			 * will be written in the next iteration
+			 */
+			set_reg_field_value(
+				value,
+				dst_color[index],
+				CRTC_TEST_PATTERN_COLOR,
+				CRTC_TEST_PATTERN_DATA);
+		}
+		/* write last color component,
+		 * it's been already prepared in the loop
+		 */
+		dm_write_reg(ctx, addr, value);
+
+		/* enable test pattern */
+		addr = CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL);
+		value = 0;
+
 		set_reg_field_value(
 			value,
 			1,
 			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_EN);
+
+		set_reg_field_value(
+			value,
+			mode,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_MODE);
+
+		set_reg_field_value(
+			value,
+			0,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_DYNAMIC_RANGE);
+
+		set_reg_field_value(
+			value,
+			bit_depth,
+			CRTC_TEST_PATTERN_CONTROL,
 			CRTC_TEST_PATTERN_COLOR_FORMAT);
+
 		dm_write_reg(ctx, addr, value);
+	}
+	break;
+
+	case CONTROLLER_DP_TEST_PATTERN_COLORRAMP:
+	{
+		mode = (bit_depth ==
+			TEST_PATTERN_COLOR_FORMAT_BPC_10 ?
+			TEST_PATTERN_MODE_DUALRAMP_RGB :
+			TEST_PATTERN_MODE_SINGLERAMP_RGB);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+			dst_bpc = 6;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+			dst_bpc = 8;
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+			dst_bpc = 10;
+		break;
+		default:
+			dst_bpc = 8;
+		break;
+		}
+
+		/* increment for the first ramp for one color gradation
+		 * 1 gradation for 6-bit color is 2^10
+		 * gradations in 16-bit color
+		 */
+		inc_base = (src_bpc - dst_bpc);
+
+		value = 0;
+		addr = CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS);
+
+		switch (bit_depth) {
+		case TEST_PATTERN_COLOR_FORMAT_BPC_6:
+		{
+			set_reg_field_value(
+				value,
+				inc_base,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_INC0);
+			set_reg_field_value(
+				value,
+				0,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_INC1);
+			set_reg_field_value(
+				value,
+				6,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_HRES);
+			set_reg_field_value(
+				value,
+				6,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_VRES);
+			set_reg_field_value(
+				value,
+				0,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_RAMP0_OFFSET);
+		}
 		break;
-	} /* switch() */
+		case TEST_PATTERN_COLOR_FORMAT_BPC_8:
+		{
+			set_reg_field_value(
+				value,
+				inc_base,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_INC0);
+			set_reg_field_value(
+				value,
+				0,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_INC1);
+			set_reg_field_value(
+				value,
+				8,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_HRES);
+			set_reg_field_value(
+				value,
+				6,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_VRES);
+			set_reg_field_value(
+				value,
+				0,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_RAMP0_OFFSET);
+		}
+		break;
+		case TEST_PATTERN_COLOR_FORMAT_BPC_10:
+		{
+			set_reg_field_value(
+				value,
+				inc_base,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_INC0);
+			set_reg_field_value(
+				value,
+				inc_base + 2,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_INC1);
+			set_reg_field_value(
+				value,
+				8,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_HRES);
+			set_reg_field_value(
+				value,
+				5,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_VRES);
+			set_reg_field_value(
+				value,
+				384 << 6,
+				CRTC_TEST_PATTERN_PARAMETERS,
+				CRTC_TEST_PATTERN_RAMP0_OFFSET);
+		}
+		break;
+		default:
+		break;
+		}
+		dm_write_reg(ctx, addr, value);
+
+		value = 0;
+		addr = CRTC_REG(mmCRTC_TEST_PATTERN_COLOR);
+		dm_write_reg(ctx, addr, value);
+
+		/* enable test pattern */
+		addr = CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL);
+		value = 0;
+
+		set_reg_field_value(
+			value,
+			1,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_EN);
+
+		set_reg_field_value(
+			value,
+			mode,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_MODE);
+
+		set_reg_field_value(
+			value,
+			0,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_DYNAMIC_RANGE);
+		/* add color depth translation here */
+		set_reg_field_value(
+			value,
+			bit_depth,
+			CRTC_TEST_PATTERN_CONTROL,
+			CRTC_TEST_PATTERN_COLOR_FORMAT);
+
+		dm_write_reg(ctx, addr, value);
+	}
+	break;
+	case CONTROLLER_DP_TEST_PATTERN_VIDEOMODE:
+	{
+		value = 0;
+		dm_write_reg(ctx, CRTC_REG(mmCRTC_TEST_PATTERN_CONTROL), value);
+		dm_write_reg(ctx, CRTC_REG(mmCRTC_TEST_PATTERN_COLOR), value);
+		dm_write_reg(ctx, CRTC_REG(mmCRTC_TEST_PATTERN_PARAMETERS),
+				value);
+	}
+	break;
+	default:
+	break;
+	}
 }
 
 /**
@@ -1578,7 +1920,8 @@ static const struct timing_generator_funcs dce110_tg_funcs = {
 		.set_drr =
 				dce110_timing_generator_set_drr,
 		.set_static_screen_control =
-			dce110_timing_generator_set_static_screen_control
+			dce110_timing_generator_set_static_screen_control,
+		.set_test_pattern = dce110_timing_generator_set_test_pattern
 
 };
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
index 97350f5..88ed54f4 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.c
@@ -162,6 +162,8 @@ static const struct link_encoder_funcs dce112_lnk_enc_funcs = {
 	.backlight_control = dce110_link_encoder_edp_backlight_control,
 	.power_control = dce110_link_encoder_edp_power_control,
 	.connect_dig_be_to_fe = dce110_link_encoder_connect_dig_be_to_fe,
+	.enable_hpd = dce110_link_encoder_enable_hpd,
+	.disable_hpd = dce110_link_encoder_disable_hpd,
 	.destroy = dce110_link_encoder_destroy
 };
 
@@ -169,13 +171,15 @@ bool dce112_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs)
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs)
 {
 	dce110_link_encoder_construct(
 		enc110,
 		init_data,
 		link_regs,
-		aux_regs);
+		aux_regs,
+		hpd_regs);
 
 	enc110->base.funcs = &dce112_lnk_enc_funcs;
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h
index 4face57..ab37335 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_link_encoder.h
@@ -33,7 +33,8 @@ bool dce112_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs);
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs);
 
 /****************** HW programming ************************/
 
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_opp.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_opp.c
index 66b3609..23c2d10 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_opp.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_opp.c
@@ -51,6 +51,8 @@ static struct opp_funcs funcs = {
 		.opp_set_regamma_mode = dce110_opp_set_regamma_mode,
 		.opp_destroy = dce110_opp_destroy,
 		.opp_program_fmt = dce112_opp_program_fmt,
+		.opp_program_bit_depth_reduction =
+				dce110_opp_program_bit_depth_reduction
 };
 
 bool dce112_opp_construct(struct dce110_opp *opp110,
diff --git a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
index 82ca35b..34e54cc 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce112/dce112_resource.c
@@ -252,6 +252,20 @@ static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
 		aux_regs(5)
 };
 
+#define hpd_regs(id)\
+[id] = {\
+	HPD_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {
+		hpd_regs(0),
+		hpd_regs(1),
+		hpd_regs(2),
+		hpd_regs(3),
+		hpd_regs(4),
+		hpd_regs(5)
+};
+
 #define link_regs(id)\
 [id] = {\
 	LE_DCE110_REG_LIST(id)\
@@ -497,7 +511,8 @@ struct link_encoder *dce112_link_encoder_create(
 			enc110,
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
-			&link_enc_aux_regs[enc_init_data->channel - 1]))
+			&link_enc_aux_regs[enc_init_data->channel - 1],
+			&link_enc_hpd_regs[enc_init_data->hpd_source]))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
index bec2b45..fab427c 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.c
@@ -219,7 +219,8 @@ bool dce80_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs)
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs)
 {
 	struct graphics_object_encoder_cap_info enc_cap_info = {0};
 
@@ -279,6 +280,7 @@ bool dce80_link_encoder_construct(
 
 	enc110->link_regs = link_regs;
 	enc110->aux_regs = aux_regs;
+	enc110->hpd_regs = hpd_regs;
 
 	switch (enc110->base.transmitter) {
 	case TRANSMITTER_UNIPHY_A:
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.h b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.h
index 73be5fc..326409b 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_link_encoder.h
@@ -33,6 +33,7 @@ bool dce80_link_encoder_construct(
 	struct dce110_link_encoder *enc110,
 	const struct encoder_init_data *init_data,
 	const struct dce110_link_enc_registers *link_regs,
-	const struct dce110_link_enc_aux_registers *aux_regs);
+	const struct dce110_link_enc_aux_registers *aux_regs,
+	const struct dce110_link_enc_hpd_registers *hpd_regs);
 
 #endif /* __DC_LINK_ENCODER__DCE80_H__ */
diff --git a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
index a9658e7..a41241f 100644
--- a/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/dal/dc/dce80/dce80_resource.c
@@ -84,6 +84,16 @@
 #endif
 
 
+#ifndef mmHPD_DC_HPD_CONTROL
+	#define mmHPD_DC_HPD_CONTROL                            0x189A
+	#define mmHPD0_DC_HPD_CONTROL                           0x189A
+	#define mmHPD1_DC_HPD_CONTROL                           0x18A2
+	#define mmHPD2_DC_HPD_CONTROL                           0x18AA
+	#define mmHPD3_DC_HPD_CONTROL                           0x18B2
+	#define mmHPD4_DC_HPD_CONTROL                           0x18BA
+	#define mmHPD5_DC_HPD_CONTROL                           0x18C2
+#endif
+
 #define DCE11_DIG_FE_CNTL 0x4a00
 #define DCE11_DIG_BE_CNTL 0x4a47
 #define DCE11_DP_SEC 0x4ac3
@@ -258,6 +268,20 @@ static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
 	aux_regs(5)
 };
 
+#define hpd_regs(id)\
+[id] = {\
+	HPD_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {
+		hpd_regs(0),
+		hpd_regs(1),
+		hpd_regs(2),
+		hpd_regs(3),
+		hpd_regs(4),
+		hpd_regs(5)
+};
+
 #define link_regs(id)\
 [id] = {\
 	LE_DCE80_REG_LIST(id)\
@@ -482,7 +506,8 @@ struct link_encoder *dce80_link_encoder_create(
 			enc110,
 			enc_init_data,
 			&link_enc_regs[enc_init_data->transmitter],
-			&link_enc_aux_regs[enc_init_data->channel - 1]))
+			&link_enc_aux_regs[enc_init_data->channel - 1],
+			&link_enc_hpd_regs[enc_init_data->hpd_source]))
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
index d10b157..5ae6ed6 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/core_types.h
@@ -221,9 +221,14 @@ struct resource_funcs {
 	struct validate_context *(*apply_clk_constraints)(
 					const struct core_dc *dc,
 					struct validate_context *context);
+
 	struct pipe_ctx *(*acquire_idle_pipe_for_layer)(
 			struct resource_context *res_ctx,
 			struct core_stream *stream);
+
+	void (*build_bit_depth_reduction_params)(
+			const struct core_stream *stream,
+			struct bit_depth_reduction_params *fmt_bit_depth);
 };
 
 struct audio_support{
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
index 3fa1a29..02fa1d2 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/link_encoder.h
@@ -257,6 +257,8 @@ struct link_encoder_funcs {
 	void (*connect_dig_be_to_fe)(struct link_encoder *enc,
 		enum engine_id engine,
 		bool connect);
+	void (*enable_hpd)(struct link_encoder *enc);
+	void (*disable_hpd)(struct link_encoder *enc);
 	void (*destroy)(struct link_encoder **enc);
 };
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
index ff554ae..e615997 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/opp.h
@@ -306,6 +306,10 @@ struct opp_funcs {
 		enum dc_color_depth color_dpth,
 		enum signal_type signal);
 
+	void (*opp_program_bit_depth_reduction)(
+		struct output_pixel_processor *opp,
+		const struct bit_depth_reduction_params *params);
+
 	/* underlay related */
 	void (*opp_get_underlay_adjustment_range)(
 			struct output_pixel_processor *opp,
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
index 334a6ab..6ac609f 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw/timing_generator.h
@@ -152,6 +152,11 @@ struct timing_generator_funcs {
 	void (*set_drr)(struct timing_generator *tg, const struct drr_params *params);
 	void (*set_static_screen_control)(struct timing_generator *tg,
 							uint32_t value);
+	void (*set_test_pattern)(
+		struct timing_generator *tg,
+		enum controller_dp_test_pattern test_pattern,
+		enum dc_color_depth color_depth);
+
 };
 
 #endif
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
index 4586b11..cb382e9 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/hw_sequencer.h
@@ -115,6 +115,9 @@ struct hw_sequencer_funcs {
 
 	void (*disable_stream)(struct pipe_ctx *pipe_ctx);
 
+	void (*unblank_stream)(struct pipe_ctx *pipe_ctx,
+			struct dc_link_settings *link_settings);
+
 	void (*enable_fe_clock)(
 		struct dc_context *ctx, uint8_t controller_id, bool enable);
 
diff --git a/drivers/gpu/drm/amd/dal/dc/inc/link_hwss.h b/drivers/gpu/drm/amd/dal/dc/inc/link_hwss.h
index d4d9084..662fa30 100644
--- a/drivers/gpu/drm/amd/dal/dc/inc/link_hwss.h
+++ b/drivers/gpu/drm/amd/dal/dc/inc/link_hwss.h
@@ -62,8 +62,12 @@ void dp_set_hw_lane_settings(
 
 void dp_set_hw_test_pattern(
 	struct core_link *link,
-	enum dp_test_pattern test_pattern);
+	enum dp_test_pattern test_pattern,
+	uint8_t *custom_pattern,
+	uint32_t custom_pattern_size);
 
 enum dp_panel_mode dp_get_panel_mode(struct core_link *link);
 
+void dp_retrain_link(struct core_link *link);
+
 #endif /* __DC_LINK_HWSS_H__ */
diff --git a/drivers/gpu/drm/amd/dal/include/dpcd_defs.h b/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
index 8b659a4..fbb2729 100644
--- a/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
+++ b/drivers/gpu/drm/amd/dal/include/dpcd_defs.h
@@ -287,7 +287,8 @@ enum dpcd_test_bit_depth {
 };
 
 /* PHY (encoder) test patterns
-The order of test patterns follows DPCD register PHY_TEST_PATTERN (0x248) */
+The order of test patterns follows DPCD register PHY_TEST_PATTERN (0x248)
+*/
 enum dpcd_phy_test_patterns {
 	PHY_TEST_PATTERN_NONE = 0,
 	PHY_TEST_PATTERN_D10_2,
@@ -670,4 +671,72 @@ union training_aux_rd_interval {
 	uint8_t raw;
 };
 
+/* Automated test structures */
+union test_request {
+	struct {
+	uint8_t LINK_TRAINING         :1;
+	uint8_t LINK_TEST_PATTRN      :1;
+	uint8_t EDID_REAT             :1;
+	uint8_t PHY_TEST_PATTERN      :1;
+	uint8_t AUDIO_TEST_PATTERN    :1;
+	uint8_t RESERVED              :1;
+	uint8_t TEST_STEREO_3D        :1;
+	} bits;
+	uint8_t raw;
+};
+
+union test_response {
+	struct {
+		uint8_t ACK         :1;
+		uint8_t NO_ACK      :1;
+		uint8_t RESERVED    :6;
+	} bits;
+	uint8_t raw;
+};
+
+union phy_test_pattern {
+	struct {
+		/* DpcdPhyTestPatterns. This field is 2 bits for DP1.1
+		 * and 3 bits for DP1.2.
+		 */
+		uint8_t PATTERN     :3;
+		/* BY speci, bit7:2 is 0 for DP1.1. */
+		uint8_t RESERVED    :5;
+	} bits;
+	uint8_t raw;
+};
+
+/* States of Compliance Test Specification (CTS DP1.2). */
+union compliance_test_state {
+	struct {
+		unsigned char STEREO_3D_RUNNING        : 1;
+		unsigned char SET_TEST_PATTERN_PENDING : 1;
+		unsigned char RESERVED                 : 6;
+	} bits;
+	unsigned char raw;
+};
+
+union link_test_pattern {
+	struct {
+		/* dpcd_link_test_patterns */
+		unsigned char PATTERN :2;
+		unsigned char RESERVED:6;
+	} bits;
+	unsigned char raw;
+};
+
+union test_misc {
+	struct dpcd_test_misc_bits {
+		unsigned char SYNC_CLOCK :1;
+		/* dpcd_test_color_format */
+		unsigned char CLR_FORMAT :2;
+		/* dpcd_test_dyn_range */
+		unsigned char DYN_RANGE  :1;
+		unsigned char YCBCR      :1;
+		/* dpcd_test_bit_depth */
+		unsigned char BPC        :3;
+	} bits;
+	unsigned char raw;
+};
+
 #endif /* __DAL_DPCD_DEFS_H__ */
-- 
2.7.4

